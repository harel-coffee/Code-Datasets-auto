<?xml version="1.0" encoding="UTF-8"?>
<jel>
	<admin creation="Fri Aug 17 15:41:11 CEST 2012" xsdversion="1.0.0" version="1.0.0" />
	<jelclass abstract="true" visibility="public" package="java.net" interface="true" fulltype="java.net.ContentHandlerFactory" type="ContentHandlerFactory">
		<comment>
			<description>This interface defines a factory for content handlers. An
 implementation of this interface should map a MIME type into an
 instance of &lt;code&gt;ContentHandler&lt;/code&gt;.
 &lt;p&gt;
 This interface is used by the &lt;code&gt;URLStreamHandler&lt;/code&gt; class
 to create a &lt;code&gt;ContentHandler&lt;/code&gt; for a MIME type.</description>
			<attribute name="@author">
				<description>James Gosling</description>
			</attribute>
			<attribute name="@see">
				<description>java.net.ContentHandler</description>
			</attribute>
			<attribute name="@see">
				<description>java.net.URLStreamHandler</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.0</description>
			</attribute>
		</comment>
		<methods>
			<method visibility="public" name="createContentHandler" returncomment="a new &lt;code&gt;ContentHandler&lt;/code&gt; to read an object from a
          &lt;code&gt;URLStreamHandler&lt;/code&gt;." fulltype="java.net.ContentHandler" type="ContentHandler">
				<comment>
					<description>Creates a new &lt;code&gt;ContentHandler&lt;/code&gt; to read an object from
 a &lt;code&gt;URLStreamHandler&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>mimetype   the MIME type for which a content handler is desired.</description>
					</attribute>
					<attribute name="@return">
						<description>a new &lt;code&gt;ContentHandler&lt;/code&gt; to read an object from a
          &lt;code&gt;URLStreamHandler&lt;/code&gt;.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.ContentHandler</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URLStreamHandler</description>
					</attribute>
				</comment>
				<params>
					<param name="mimetype" comment="the MIME type for which a content handler is desired." fulltype="java.lang.String" type="String" />
				</params>
			</method>
		</methods>
	</jelclass>
	<jelclass abstract="true" visibility="package-private" package="java.net" interface="true" fulltype="java.net.InetAddressImpl" type="InetAddressImpl">
		<methods>
			<method visibility="public" name="getLocalHostName" fulltype="java.lang.String" type="String">
				<exceptions>
					<exception fulltype="java.net.UnknownHostException" type="UnknownHostException" />
				</exceptions>
			</method>
			<method visibility="public" name="lookupAllHostAddr" fulltype="java.net.InetAddress[]" type="InetAddress">
				<params>
					<param name="hostname" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception fulltype="java.net.UnknownHostException" type="UnknownHostException" />
				</exceptions>
			</method>
			<method visibility="public" name="getHostByAddr" fulltype="java.lang.String" type="String">
				<params>
					<param name="addr" fulltype="byte[]" type="byte" />
				</params>
				<exceptions>
					<exception fulltype="java.net.UnknownHostException" type="UnknownHostException" />
				</exceptions>
			</method>
			<method visibility="public" name="anyLocalAddress" fulltype="java.net.InetAddress" type="InetAddress" />
			<method visibility="public" name="loopbackAddress" fulltype="java.net.InetAddress" type="InetAddress" />
			<method visibility="public" name="isReachable" fulltype="boolean" type="boolean">
				<params>
					<param name="addr" fulltype="java.net.InetAddress" type="InetAddress" />
					<param name="timeout" fulltype="int" type="int" />
					<param name="netif" fulltype="java.net.NetworkInterface" type="NetworkInterface" />
					<param name="ttl" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass abstract="true" superclass="Object" visibility="public" package="java.net" superclassfulltype="java.lang.Object" fulltype="java.net.URLStreamHandler" type="URLStreamHandler">
		<comment>
			<description>The abstract class &lt;code&gt;URLStreamHandler&lt;/code&gt; is the common
 superclass for all stream protocol handlers. A stream protocol
 handler knows how to make a connection for a particular protocol
 type, such as &lt;code&gt;http&lt;/code&gt;, &lt;code&gt;ftp&lt;/code&gt;, or
 &lt;code&gt;gopher&lt;/code&gt;.
 &lt;p&gt;
 In most cases, an instance of a &lt;code&gt;URLStreamHandler&lt;/code&gt;
 subclass is not created directly by an application. Rather, the
 first time a protocol name is encountered when constructing a
 &lt;code&gt;URL&lt;/code&gt;, the appropriate stream protocol handler is
 automatically loaded.</description>
			<attribute name="@author">
				<description>James Gosling</description>
			</attribute>
			<attribute name="@see">
				<description>java.net.URL#URL(java.lang.String, java.lang.String, int, java.lang.String)</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.0</description>
			</attribute>
		</comment>
		<methods>
			<constructor visibility="public" name="URLStreamHandler" />
			<method abstract="true" visibility="protected" name="openConnection" returncomment="a &lt;code&gt;URLConnection&lt;/code&gt; object for the &lt;code&gt;URL&lt;/code&gt;." fulltype="java.net.URLConnection" type="URLConnection">
				<comment>
					<description>Opens a connection to the object referenced by the
 &lt;code&gt;URL&lt;/code&gt; argument.
 This method should be overridden by a subclass.

 &lt;p&gt;If for the handler&apos;s protocol (such as HTTP or JAR), there
 exists a public, specialized URLConnection subclass belonging
 to one of the following packages or one of their subpackages:
 java.lang, java.io, java.util, java.net, the connection
 returned will be of that subclass. For example, for HTTP an
 HttpURLConnection will be returned, and for JAR a
 JarURLConnection will be returned.</description>
					<attribute name="@param">
						<description>u   the URL that this connects to.</description>
					</attribute>
					<attribute name="@return">
						<description>a &lt;code&gt;URLConnection&lt;/code&gt; object for the &lt;code&gt;URL&lt;/code&gt;.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs while opening the
               connection.</description>
					</attribute>
				</comment>
				<params>
					<param name="u" comment="the URL that this connects to." fulltype="java.net.URL" type="URL" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs while opening the
               connection." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="protected" name="openConnection" returncomment="a &lt;code&gt;URLConnection&lt;/code&gt; object for the &lt;code&gt;URL&lt;/code&gt;." fulltype="java.net.URLConnection" type="URLConnection">
				<comment>
					<description>Same as openConnection(URL), except that the connection will be
 made through the specified proxy; Protocol handlers that do not
 support proxying will ignore the proxy parameter and make a
 normal connection.

 Calling this method preempts the system&apos;s default ProxySelector
 settings.</description>
					<attribute name="@param">
						<description>u   the URL that this connects to.</description>
					</attribute>
					<attribute name="@param">
						<description>p   the proxy through which the connection will be made.
                 If direct connection is desired, Proxy.NO_PROXY
                 should be specified.</description>
					</attribute>
					<attribute name="@return">
						<description>a &lt;code&gt;URLConnection&lt;/code&gt; object for the &lt;code&gt;URL&lt;/code&gt;.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs while opening the
               connection.</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if either u or p is null,
               or p has the wrong type.</description>
					</attribute>
					<attribute name="@exception">
						<description>UnsupportedOperationException if the subclass that
               implements the protocol doesn&apos;t support this method.</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
				<params>
					<param name="u" comment="the URL that this connects to." fulltype="java.net.URL" type="URL" />
					<param name="p" comment="the proxy through which the connection will be made.
                 If direct connection is desired, Proxy.NO_PROXY
                 should be specified." fulltype="java.net.Proxy" type="Proxy" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs while opening the
               connection." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="protected" name="parseURL" fulltype="void" type="void">
				<comment>
					<description>Parses the string representation of a &lt;code&gt;URL&lt;/code&gt; into a
 &lt;code&gt;URL&lt;/code&gt; object.
 &lt;p&gt;
 If there is any inherited context, then it has already been
 copied into the &lt;code&gt;URL&lt;/code&gt; argument.
 &lt;p&gt;
 The &lt;code&gt;parseURL&lt;/code&gt; method of &lt;code&gt;URLStreamHandler&lt;/code&gt;
 parses the string representation as if it were an
 &lt;code&gt;http&lt;/code&gt; specification. Most URL protocol families have a
 similar parsing. A stream protocol handler for a protocol that has
 a different syntax must override this routine.</description>
					<attribute name="@param">
						<description>u       the &lt;code&gt;URL&lt;/code&gt; to receive the result of parsing
                  the spec.</description>
					</attribute>
					<attribute name="@param">
						<description>spec    the &lt;code&gt;String&lt;/code&gt; representing the URL that
                  must be parsed.</description>
					</attribute>
					<attribute name="@param">
						<description>start   the character index at which to begin parsing. This is
                  just past the &apos;&lt;code&gt;:&lt;/code&gt;&apos; (if there is one) that
                  specifies the determination of the protocol name.</description>
					</attribute>
					<attribute name="@param">
						<description>limit   the character position to stop parsing at. This is the
                  end of the string or the position of the
                  &quot;&lt;code&gt;#&lt;/code&gt;&quot; character, if present. All information
                  after the sharp sign indicates an anchor.</description>
					</attribute>
				</comment>
				<params>
					<param name="u" comment="the &lt;code&gt;URL&lt;/code&gt; to receive the result of parsing
                  the spec." fulltype="java.net.URL" type="URL" />
					<param name="spec" comment="the &lt;code&gt;String&lt;/code&gt; representing the URL that
                  must be parsed." fulltype="java.lang.String" type="String" />
					<param name="start" comment="the character index at which to begin parsing. This is
                  just past the &apos;&lt;code&gt;:&lt;/code&gt;&apos; (if there is one) that
                  specifies the determination of the protocol name." fulltype="int" type="int" />
					<param name="limit" comment="the character position to stop parsing at. This is the
                  end of the string or the position of the
                  &quot;&lt;code&gt;#&lt;/code&gt;&quot; character, if present. All information
                  after the sharp sign indicates an anchor." fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="protected" name="getDefaultPort" returncomment="the default port for a &lt;code&gt;URL&lt;/code&gt; parsed by this handler." fulltype="int" type="int">
				<comment>
					<description>Returns the default port for a URL parsed by this handler. This method
 is meant to be overidden by handlers with default port numbers.</description>
					<attribute name="@return">
						<description>the default port for a &lt;code&gt;URL&lt;/code&gt; parsed by this handler.</description>
					</attribute>
					<attribute name="@since">
						<description>1.3</description>
					</attribute>
				</comment>
			</method>
			<method visibility="protected" name="equals" returncomment="&lt;tt&gt;true&lt;/tt&gt; if the two urls are
 considered equal, ie. they refer to the same
 fragment in the same file." fulltype="boolean" type="boolean">
				<comment>
					<description>Provides the default equals calculation. May be overidden by handlers
 for other protocols that have different requirements for equals().
 This method requires that none of its arguments is null. This is
 guaranteed by the fact that it is only called by java.net.URL class.</description>
					<attribute name="@param">
						<description>u1 a URL object</description>
					</attribute>
					<attribute name="@param">
						<description>u2 a URL object</description>
					</attribute>
					<attribute name="@return">
						<description>&lt;tt&gt;true&lt;/tt&gt; if the two urls are
 considered equal, ie. they refer to the same
 fragment in the same file.</description>
					</attribute>
					<attribute name="@since">
						<description>1.3</description>
					</attribute>
				</comment>
				<params>
					<param name="u1" comment="a URL object" fulltype="java.net.URL" type="URL" />
					<param name="u2" comment="a URL object" fulltype="java.net.URL" type="URL" />
				</params>
			</method>
			<method visibility="protected" name="hashCode" returncomment="an &lt;tt&gt;int&lt;/tt&gt; suitable for hash table indexing" fulltype="int" type="int">
				<comment>
					<description>Provides the default hash calculation. May be overidden by handlers for
 other protocols that have different requirements for hashCode
 calculation.</description>
					<attribute name="@param">
						<description>u a URL object</description>
					</attribute>
					<attribute name="@return">
						<description>an &lt;tt&gt;int&lt;/tt&gt; suitable for hash table indexing</description>
					</attribute>
					<attribute name="@since">
						<description>1.3</description>
					</attribute>
				</comment>
				<params>
					<param name="u" comment="a URL object" fulltype="java.net.URL" type="URL" />
				</params>
			</method>
			<method visibility="protected" name="sameFile" returncomment="true if u1 and u2 refer to the same file" fulltype="boolean" type="boolean">
				<comment>
					<description>Compare two urls to see whether they refer to the same file,
 i.e., having the same protocol, host, port, and path.
 This method requires that none of its arguments is null. This is
 guaranteed by the fact that it is only called indirectly
 by java.net.URL class.</description>
					<attribute name="@param">
						<description>u1 a URL object</description>
					</attribute>
					<attribute name="@param">
						<description>u2 a URL object</description>
					</attribute>
					<attribute name="@return">
						<description>true if u1 and u2 refer to the same file</description>
					</attribute>
					<attribute name="@since">
						<description>1.3</description>
					</attribute>
				</comment>
				<params>
					<param name="u1" comment="a URL object" fulltype="java.net.URL" type="URL" />
					<param name="u2" comment="a URL object" fulltype="java.net.URL" type="URL" />
				</params>
			</method>
			<method synchronized="true" visibility="protected" name="getHostAddress" returncomment="an &lt;code&gt;InetAddress&lt;/code&gt; representing the host
 IP address." fulltype="java.net.InetAddress" type="InetAddress">
				<comment>
					<description>Get the IP address of our host. An empty host field or a DNS failure
 will result in a null return.</description>
					<attribute name="@param">
						<description>u a URL object</description>
					</attribute>
					<attribute name="@return">
						<description>an &lt;code&gt;InetAddress&lt;/code&gt; representing the host
 IP address.</description>
					</attribute>
					<attribute name="@since">
						<description>1.3</description>
					</attribute>
				</comment>
				<params>
					<param name="u" comment="a URL object" fulltype="java.net.URL" type="URL" />
				</params>
			</method>
			<method visibility="protected" name="hostsEqual" returncomment="&lt;tt&gt;true&lt;/tt&gt; if and only if they
 are equal, &lt;tt&gt;false&lt;/tt&gt; otherwise." fulltype="boolean" type="boolean">
				<comment>
					<description>Compares the host components of two URLs.</description>
					<attribute name="@param">
						<description>u1 the URL of the first host to compare</description>
					</attribute>
					<attribute name="@param">
						<description>u2 the URL of the second host to compare</description>
					</attribute>
					<attribute name="@return">
						<description>&lt;tt&gt;true&lt;/tt&gt; if and only if they
 are equal, &lt;tt&gt;false&lt;/tt&gt; otherwise.</description>
					</attribute>
					<attribute name="@since">
						<description>1.3</description>
					</attribute>
				</comment>
				<params>
					<param name="u1" comment="the URL of the first host to compare" fulltype="java.net.URL" type="URL" />
					<param name="u2" comment="the URL of the second host to compare" fulltype="java.net.URL" type="URL" />
				</params>
			</method>
			<method visibility="protected" name="toExternalForm" returncomment="a string representation of the &lt;code&gt;URL&lt;/code&gt; argument." fulltype="java.lang.String" type="String">
				<comment>
					<description>Converts a &lt;code&gt;URL&lt;/code&gt; of a specific protocol to a
 &lt;code&gt;String&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>u   the URL.</description>
					</attribute>
					<attribute name="@return">
						<description>a string representation of the &lt;code&gt;URL&lt;/code&gt; argument.</description>
					</attribute>
				</comment>
				<params>
					<param name="u" comment="the URL." fulltype="java.net.URL" type="URL" />
				</params>
			</method>
			<method visibility="protected" name="setURL" fulltype="void" type="void">
				<comment>
					<description>Sets the fields of the &lt;code&gt;URL&lt;/code&gt; argument to the indicated values.
 Only classes derived from URLStreamHandler are supposed to be able
 to call the set method on a URL.</description>
					<attribute name="@param">
						<description>u         the URL to modify.</description>
					</attribute>
					<attribute name="@param">
						<description>protocol  the protocol name.</description>
					</attribute>
					<attribute name="@param">
						<description>host      the remote host value for the URL.</description>
					</attribute>
					<attribute name="@param">
						<description>port      the port on the remote machine.</description>
					</attribute>
					<attribute name="@param">
						<description>authority the authority part for the URL.</description>
					</attribute>
					<attribute name="@param">
						<description>userInfo the userInfo part of the URL.</description>
					</attribute>
					<attribute name="@param">
						<description>path      the path component of the URL.</description>
					</attribute>
					<attribute name="@param">
						<description>query     the query part for the URL.</description>
					</attribute>
					<attribute name="@param">
						<description>ref       the reference.</description>
					</attribute>
					<attribute name="@exception">
						<description>SecurityException       if the protocol handler of the URL is
                                  different from this one</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URL#set(java.lang.String, java.lang.String, int, java.lang.String, java.lang.String)</description>
					</attribute>
					<attribute name="@since">
						<description>1.3</description>
					</attribute>
				</comment>
				<params>
					<param name="u" comment="the URL to modify." fulltype="java.net.URL" type="URL" />
					<param name="protocol" comment="the protocol name." fulltype="java.lang.String" type="String" />
					<param name="host" comment="the remote host value for the URL." fulltype="java.lang.String" type="String" />
					<param name="port" comment="the port on the remote machine." fulltype="int" type="int" />
					<param name="authority" comment="the authority part for the URL." fulltype="java.lang.String" type="String" />
					<param name="userInfo" comment="the userInfo part of the URL." fulltype="java.lang.String" type="String" />
					<param name="path" comment="the path component of the URL." fulltype="java.lang.String" type="String" />
					<param name="query" comment="the query part for the URL." fulltype="java.lang.String" type="String" />
					<param name="ref" comment="the reference." fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="protected" name="setURL" fulltype="void" type="void">
				<comment>
					<description>Sets the fields of the &lt;code&gt;URL&lt;/code&gt; argument to the indicated values.
 Only classes derived from URLStreamHandler are supposed to be able
 to call the set method on a URL.</description>
					<attribute name="@param">
						<description>u         the URL to modify.</description>
					</attribute>
					<attribute name="@param">
						<description>protocol  the protocol name. This value is ignored since 1.2.</description>
					</attribute>
					<attribute name="@param">
						<description>host      the remote host value for the URL.</description>
					</attribute>
					<attribute name="@param">
						<description>port      the port on the remote machine.</description>
					</attribute>
					<attribute name="@param">
						<description>file      the file.</description>
					</attribute>
					<attribute name="@param">
						<description>ref       the reference.</description>
					</attribute>
					<attribute name="@exception">
						<description>SecurityException       if the protocol handler of the URL is
                                  different from this one</description>
					</attribute>
					<attribute name="@deprecated">
						<description>Use setURL(URL, String, String, int, String, String, String,
             String);</description>
					</attribute>
				</comment>
				<params>
					<param name="u" comment="the URL to modify." fulltype="java.net.URL" type="URL" />
					<param name="protocol" comment="the protocol name. This value is ignored since 1.2." fulltype="java.lang.String" type="String" />
					<param name="host" comment="the remote host value for the URL." fulltype="java.lang.String" type="String" />
					<param name="port" comment="the port on the remote machine." fulltype="int" type="int" />
					<param name="file" comment="the file." fulltype="java.lang.String" type="String" />
					<param name="ref" comment="the reference." fulltype="java.lang.String" type="String" />
				</params>
			</method>
		</methods>
	</jelclass>
	<jelclass final="true" superclass="Object" visibility="public" package="java.net" serializable="true" superclassfulltype="java.lang.Object" fulltype="java.net.URL" type="URL">
		<implements>
			<interface fulltype="java.io.Serializable" type="Serializable" />
		</implements>
		<comment>
			<description>Class &lt;code&gt;URL&lt;/code&gt; represents a Uniform Resource
 Locator, a pointer to a &quot;resource&quot; on the World
 Wide Web. A resource can be something as simple as a file or a
 directory, or it can be a reference to a more complicated object,
 such as a query to a database or to a search engine. More
 information on the types of URLs and their formats can be found at:
 &lt;blockquote&gt;
     &lt;a href=&quot;http://www.socs.uts.edu.au/MosaicDocs-old/url-primer.html&quot;&gt;
    &lt;i&gt;http://www.socs.uts.edu.au/MosaicDocs-old/url-primer.html&lt;/i&gt;&lt;/a&gt;
 &lt;/blockquote&gt;
 &lt;p&gt;
 In general, a URL can be broken into several parts. The previous
 example of a URL indicates that the protocol to use is
 &lt;code&gt;http&lt;/code&gt; (HyperText Transfer Protocol) and that the
 information resides on a host machine named
 &lt;code&gt;www.socs.uts.edu.au&lt;/code&gt;. The information on that host
 machine is named &lt;code&gt;/MosaicDocs-old/url-primer.html&lt;/code&gt;. The exact
 meaning of this name on the host machine is both protocol
 dependent and host dependent. The information normally resides in
 a file, but it could be generated on the fly. This component of
 the URL is called the &lt;i&gt;path&lt;/i&gt; component.
 &lt;p&gt;
 A URL can optionally specify a &quot;port&quot;, which is the
 port number to which the TCP connection is made on the remote host
 machine. If the port is not specified, the default port for
 the protocol is used instead. For example, the default port for
 &lt;code&gt;http&lt;/code&gt; is &lt;code&gt;80&lt;/code&gt;. An alternative port could be
 specified as:
 &lt;blockquote&gt;&lt;pre&gt;
     http://www.socs.uts.edu.au:80/MosaicDocs-old/url-primer.html
 &lt;/pre&gt;&lt;/blockquote&gt;
 &lt;p&gt;
 The syntax of &lt;code&gt;URL&lt;/code&gt; is defined by  &lt;a
 href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2396: Uniform
 Resource Identifiers (URI): Generic Syntax&lt;/i&gt;&lt;/a&gt;, amended by &lt;a
 href=&quot;http://www.ietf.org/rfc/rfc2732.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2732: Format for
 Literal IPv6 Addresses in URLs&lt;/i&gt;&lt;/a&gt;. The Literal IPv6 address format
 also supports scope_ids. The syntax and usage of scope_ids is described
 &lt;a href=&quot;Inet6Address.html#scoped&quot;&gt;here&lt;/a&gt;.
 &lt;p&gt;
 A URL may have appended to it a &quot;fragment&quot;, also known
 as a &quot;ref&quot; or a &quot;reference&quot;. The fragment is indicated by the sharp
 sign character &quot;#&quot; followed by more characters. For example,
 &lt;blockquote&gt;&lt;pre&gt;
     http://java.sun.com/index.html#chapter1
 &lt;/pre&gt;&lt;/blockquote&gt;
 &lt;p&gt;
 This fragment is not technically part of the URL. Rather, it
 indicates that after the specified resource is retrieved, the
 application is specifically interested in that part of the
 document that has the tag &lt;code&gt;chapter1&lt;/code&gt; attached to it. The
 meaning of a tag is resource specific.
 &lt;p&gt;
 An application can also specify a &quot;relative URL&quot;,
 which contains only enough information to reach the resource
 relative to another URL. Relative URLs are frequently used within
 HTML pages. For example, if the contents of the URL:
 &lt;blockquote&gt;&lt;pre&gt;
     http://java.sun.com/index.html
 &lt;/pre&gt;&lt;/blockquote&gt;
 contained within it the relative URL:
 &lt;blockquote&gt;&lt;pre&gt;
     FAQ.html
 &lt;/pre&gt;&lt;/blockquote&gt;
 it would be a shorthand for:
 &lt;blockquote&gt;&lt;pre&gt;
     http://java.sun.com/FAQ.html
 &lt;/pre&gt;&lt;/blockquote&gt;
 &lt;p&gt;
 The relative URL need not specify all the components of a URL. If
 the protocol, host name, or port number is missing, the value is
 inherited from the fully specified URL. The file component must be
 specified. The optional fragment is not inherited.
 &lt;p&gt;
 The URL class does not itself encode or decode any URL components
 according to the escaping mechanism defined in RFC2396. It is the
 responsibility of the caller to encode any fields, which need to be
 escaped prior to calling URL, and also to decode any escaped fields,
 that are returned from URL. Furthermore, because URL has no knowledge
 of URL escaping, it does not recognise equivalence between the encoded
 or decoded form of the same URL. For example, the two URLs:&lt;br&gt;
 &lt;pre&gt;    http://foo.com/hello world/ and http://foo.com/hello%20world&lt;/pre&gt;
 would be considered not equal to each other.
 &lt;p&gt;
 Note, the {@link java.net.URI} class does perform escaping of its
 component fields in certain circumstances. The recommended way
 to manage the encoding and decoding of URLs is to use {@link java.net.URI},
 and to convert between these two classes using {@link #toURI()} and
 {@link URI#toURL()}.
 &lt;p&gt;
 The {@link URLEncoder} and {@link URLDecoder} classes can also be
 used, but only for HTML form encoding, which is not the same
 as the encoding scheme defined in RFC2396.</description>
			<attribute name="@author">
				<description>James Gosling</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.0</description>
			</attribute>
		</comment>
		<fields>
			<field final="true" static="true" const="-7627629688361524110" visibility="package-private" name="serialVersionUID" constexpr="-7627629688361524110L" fulltype="long" type="long" />
			<field final="true" static="true" const="java.protocol.handler.pkgs" visibility="private" name="protocolPathProp" constexpr="&quot;java.protocol.handler.pkgs&quot;" fulltype="java.lang.String" type="String">
				<comment>
					<description>The property which specifies the package prefix list to be scanned
 for protocol handlers.  The value of this property (if any) should
 be a vertical bar delimited list of package names to search through
 for a protocol handler to load.  The policy of this class is that
 all protocol handlers will be in a class called &lt;protocolname&gt;.Handler,
 and each package in the list is examined in turn for a matching
 handler.  If none are found (or the property is not specified), the
 default package prefix, sun.net.www.protocol, is used.  The search
 proceeds from the first package in the list to the last and stops
 when a match is found.</description>
				</comment>
			</field>
			<field visibility="private" name="protocol" fulltype="java.lang.String" type="String">
				<comment>
					<description>The protocol to use (ftp, http, nntp, ... etc.) .</description>
					<attribute name="@serial" />
				</comment>
			</field>
			<field visibility="private" name="host" fulltype="java.lang.String" type="String">
				<comment>
					<description>The host name to connect to.</description>
					<attribute name="@serial" />
				</comment>
			</field>
			<field visibility="private" name="port" fulltype="int" type="int">
				<comment>
					<description>The protocol port to connect to.</description>
					<attribute name="@serial" />
				</comment>
			</field>
			<field visibility="private" name="file" fulltype="java.lang.String" type="String">
				<comment>
					<description>The specified file name on that host. &lt;code&gt;file&lt;/code&gt; is
 defined as &lt;code&gt;path[?query]&lt;/code&gt;</description>
					<attribute name="@serial" />
				</comment>
			</field>
			<field visibility="private" transient="true" name="query" fulltype="java.lang.String" type="String">
				<comment>
					<description>The query part of this URL.</description>
				</comment>
			</field>
			<field visibility="private" name="authority" fulltype="java.lang.String" type="String">
				<comment>
					<description>The authority part of this URL.</description>
					<attribute name="@serial" />
				</comment>
			</field>
			<field visibility="private" transient="true" name="path" fulltype="java.lang.String" type="String">
				<comment>
					<description>The path part of this URL.</description>
				</comment>
			</field>
			<field visibility="private" transient="true" name="userInfo" fulltype="java.lang.String" type="String">
				<comment>
					<description>The userinfo part of this URL.</description>
				</comment>
			</field>
			<field visibility="private" name="ref" fulltype="java.lang.String" type="String">
				<comment>
					<description># reference.</description>
					<attribute name="@serial" />
				</comment>
			</field>
			<field visibility="package-private" transient="true" name="hostAddress" fulltype="java.net.InetAddress" type="InetAddress">
				<comment>
					<description>The host&apos;s IP address, used in equals and hashCode.
 Computed on demand. An uninitialized or unknown hostAddress is null.</description>
				</comment>
			</field>
			<field visibility="package-private" transient="true" name="handler" fulltype="java.net.URLStreamHandler" type="URLStreamHandler">
				<comment>
					<description>The URLStreamHandler for this URL.</description>
				</comment>
			</field>
			<field visibility="private" name="hashCode" fulltype="int" type="int" />
			<field static="true" visibility="package-private" name="factory" fulltype="java.net.URLStreamHandlerFactory" type="URLStreamHandlerFactory">
				<comment>
					<description>The URLStreamHandler factory.</description>
				</comment>
			</field>
			<field static="true" visibility="package-private" name="handlers" fulltype="java.util.Hashtable" type="Hashtable">
				<comment>
					<description>A table of protocol handlers.</description>
				</comment>
			</field>
			<field static="true" visibility="private" name="streamHandlerLock" fulltype="java.lang.Object" type="Object" />
		</fields>
		<methods>
			<constructor visibility="public" name="URL">
				<comment>
					<description>Creates a &lt;code&gt;URL&lt;/code&gt; object from the specified
 &lt;code&gt;protocol&lt;/code&gt;, &lt;code&gt;host&lt;/code&gt;, &lt;code&gt;port&lt;/code&gt;
 number, and &lt;code&gt;file&lt;/code&gt;.&lt;p&gt;

 &lt;code&gt;host&lt;/code&gt; can be expressed as a host name or a literal
 IP address. If IPv6 literal address is used, it should be
 enclosed in square brackets (&lt;tt&gt;&apos;[&apos;&lt;/tt&gt; and &lt;tt&gt;&apos;]&apos;&lt;/tt&gt;), as
 specified by &lt;a
 href=&quot;http://www.ietf.org/rfc/rfc2732.txt&quot;&gt;RFC&amp;nbsp;2732&lt;/a&gt;;
 However, the literal IPv6 address format defined in &lt;a
 href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2373: IP
 Version 6 Addressing Architecture&lt;/i&gt;&lt;/a&gt; is also accepted.&lt;p&gt;

 Specifying a &lt;code&gt;port&lt;/code&gt; number of &lt;code&gt;-1&lt;/code&gt;
 indicates that the URL should use the default port for the
 protocol.&lt;p&gt;

 If this is the first URL object being created with the specified
 protocol, a &lt;i&gt;stream protocol handler&lt;/i&gt; object, an instance of
 class &lt;code&gt;URLStreamHandler&lt;/code&gt;, is created for that protocol:
 &lt;ol&gt;
 &lt;li&gt;If the application has previously set up an instance of
     &lt;code&gt;URLStreamHandlerFactory&lt;/code&gt; as the stream handler factory,
     then the &lt;code&gt;createURLStreamHandler&lt;/code&gt; method of that instance
     is called with the protocol string as an argument to create the
     stream protocol handler.
 &lt;li&gt;If no &lt;code&gt;URLStreamHandlerFactory&lt;/code&gt; has yet been set up,
     or if the factory&apos;s &lt;code&gt;createURLStreamHandler&lt;/code&gt; method
     returns &lt;code&gt;null&lt;/code&gt;, then the constructor finds the
     value of the system property:
     &lt;blockquote&gt;&lt;pre&gt;
         java.protocol.handler.pkgs
     &lt;/pre&gt;&lt;/blockquote&gt;
     If the value of that system property is not &lt;code&gt;null&lt;/code&gt;,
     it is interpreted as a list of packages separated by a vertical
     slash character &apos;&lt;code&gt;|&lt;/code&gt;&apos;. The constructor tries to load
     the class named:
     &lt;blockquote&gt;&lt;pre&gt;
         &amp;lt;&lt;i&gt;package&lt;/i&gt;&amp;gt;.&amp;lt;&lt;i&gt;protocol&lt;/i&gt;&amp;gt;.Handler
     &lt;/pre&gt;&lt;/blockquote&gt;
     where &amp;lt;&lt;i&gt;package&lt;/i&gt;&amp;gt; is replaced by the name of the package
     and &amp;lt;&lt;i&gt;protocol&lt;/i&gt;&amp;gt; is replaced by the name of the protocol.
     If this class does not exist, or if the class exists but it is not
     a subclass of &lt;code&gt;URLStreamHandler&lt;/code&gt;, then the next package
     in the list is tried.
 &lt;li&gt;If the previous step fails to find a protocol handler, then the
     constructor tries to load from a system default package.
     &lt;blockquote&gt;&lt;pre&gt;
         &amp;lt;&lt;i&gt;system default package&lt;/i&gt;&amp;gt;.&amp;lt;&lt;i&gt;protocol&lt;/i&gt;&amp;gt;.Handler
     &lt;/pre&gt;&lt;/blockquote&gt;
     If this class does not exist, or if the class exists but it is not a
     subclass of &lt;code&gt;URLStreamHandler&lt;/code&gt;, then a
     &lt;code&gt;MalformedURLException&lt;/code&gt; is thrown.
 &lt;/ol&gt;

 &lt;p&gt;Protocol handlers for the following protocols are guaranteed
 to exist on the search path :-
 &lt;blockquote&gt;&lt;pre&gt;
     http, https, ftp, file, and jar
 &lt;/pre&gt;&lt;/blockquote&gt;
 Protocol handlers for additional protocols may also be
 available.

 &lt;p&gt;No validation of the inputs is performed by this constructor.</description>
					<attribute name="@param">
						<description>protocol   the name of the protocol to use.</description>
					</attribute>
					<attribute name="@param">
						<description>host       the name of the host.</description>
					</attribute>
					<attribute name="@param">
						<description>port       the port number on the host.</description>
					</attribute>
					<attribute name="@param">
						<description>file       the file on the host</description>
					</attribute>
					<attribute name="@exception">
						<description>MalformedURLException  if an unknown protocol is specified.</description>
					</attribute>
					<attribute name="@see">
						<description>java.lang.System#getProperty(java.lang.String)</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URL#setURLStreamHandlerFactory(
                  java.net.URLStreamHandlerFactory)</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URLStreamHandler</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URLStreamHandlerFactory#createURLStreamHandler(
                  java.lang.String)</description>
					</attribute>
				</comment>
				<params>
					<param name="protocol" comment="the name of the protocol to use." fulltype="java.lang.String" type="String" />
					<param name="host" comment="the name of the host." fulltype="java.lang.String" type="String" />
					<param name="port" comment="the port number on the host." fulltype="int" type="int" />
					<param name="file" comment="the file on the host" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception comment="if an unknown protocol is specified." fulltype="java.net.MalformedURLException" type="MalformedURLException" />
				</exceptions>
			</constructor>
			<constructor visibility="public" name="URL">
				<comment>
					<description>Creates a URL from the specified &lt;code&gt;protocol&lt;/code&gt;
 name, &lt;code&gt;host&lt;/code&gt; name, and &lt;code&gt;file&lt;/code&gt; name. The
 default port for the specified protocol is used.
 &lt;p&gt;
 This method is equivalent to calling the four-argument
 constructor with the arguments being &lt;code&gt;protocol&lt;/code&gt;,
 &lt;code&gt;host&lt;/code&gt;, &lt;code&gt;-1&lt;/code&gt;, and &lt;code&gt;file&lt;/code&gt;.

 No validation of the inputs is performed by this constructor.</description>
					<attribute name="@param">
						<description>protocol   the name of the protocol to use.</description>
					</attribute>
					<attribute name="@param">
						<description>host       the name of the host.</description>
					</attribute>
					<attribute name="@param">
						<description>file       the file on the host.</description>
					</attribute>
					<attribute name="@exception">
						<description>MalformedURLException  if an unknown protocol is specified.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URL#URL(java.lang.String, java.lang.String,
                  int, java.lang.String)</description>
					</attribute>
				</comment>
				<params>
					<param name="protocol" comment="the name of the protocol to use." fulltype="java.lang.String" type="String" />
					<param name="host" comment="the name of the host." fulltype="java.lang.String" type="String" />
					<param name="file" comment="the file on the host." fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception comment="if an unknown protocol is specified." fulltype="java.net.MalformedURLException" type="MalformedURLException" />
				</exceptions>
			</constructor>
			<constructor visibility="public" name="URL">
				<comment>
					<description>Creates a &lt;code&gt;URL&lt;/code&gt; object from the specified
 &lt;code&gt;protocol&lt;/code&gt;, &lt;code&gt;host&lt;/code&gt;, &lt;code&gt;port&lt;/code&gt;
 number, &lt;code&gt;file&lt;/code&gt;, and &lt;code&gt;handler&lt;/code&gt;. Specifying
 a &lt;code&gt;port&lt;/code&gt; number of &lt;code&gt;-1&lt;/code&gt; indicates that
 the URL should use the default port for the protocol. Specifying
 a &lt;code&gt;handler&lt;/code&gt; of &lt;code&gt;null&lt;/code&gt; indicates that the URL
 should use a default stream handler for the protocol, as outlined
 for:
     java.net.URL#URL(java.lang.String, java.lang.String, int,
                      java.lang.String)

 &lt;p&gt;If the handler is not null and there is a security manager,
 the security manager&apos;s &lt;code&gt;checkPermission&lt;/code&gt;
 method is called with a
 &lt;code&gt;NetPermission(&quot;specifyStreamHandler&quot;)&lt;/code&gt; permission.
 This may result in a SecurityException.

 No validation of the inputs is performed by this constructor.</description>
					<attribute name="@param">
						<description>protocol   the name of the protocol to use.</description>
					</attribute>
					<attribute name="@param">
						<description>host       the name of the host.</description>
					</attribute>
					<attribute name="@param">
						<description>port       the port number on the host.</description>
					</attribute>
					<attribute name="@param">
						<description>file       the file on the host</description>
					</attribute>
					<attribute name="@param">
						<description>handler    the stream handler for the URL.</description>
					</attribute>
					<attribute name="@exception">
						<description>MalformedURLException  if an unknown protocol is specified.</description>
					</attribute>
					<attribute name="@exception">
						<description>SecurityException
        if a security manager exists and its
        &lt;code&gt;checkPermission&lt;/code&gt; method doesn&apos;t allow
        specifying a stream handler explicitly.</description>
					</attribute>
					<attribute name="@see">
						<description>java.lang.System#getProperty(java.lang.String)</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URL#setURLStreamHandlerFactory(
                  java.net.URLStreamHandlerFactory)</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URLStreamHandler</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URLStreamHandlerFactory#createURLStreamHandler(
                  java.lang.String)</description>
					</attribute>
					<attribute name="@see">
						<description>SecurityManager#checkPermission</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.NetPermission</description>
					</attribute>
				</comment>
				<params>
					<param name="protocol" comment="the name of the protocol to use." fulltype="java.lang.String" type="String" />
					<param name="host" comment="the name of the host." fulltype="java.lang.String" type="String" />
					<param name="port" comment="the port number on the host." fulltype="int" type="int" />
					<param name="file" comment="the file on the host" fulltype="java.lang.String" type="String" />
					<param name="handler" comment="the stream handler for the URL." fulltype="java.net.URLStreamHandler" type="URLStreamHandler" />
				</params>
				<exceptions>
					<exception comment="if an unknown protocol is specified." fulltype="java.net.MalformedURLException" type="MalformedURLException" />
				</exceptions>
			</constructor>
			<constructor visibility="public" name="URL">
				<comment>
					<description>Creates a &lt;code&gt;URL&lt;/code&gt; object from the &lt;code&gt;String&lt;/code&gt;
 representation.
 &lt;p&gt;
 This constructor is equivalent to a call to the two-argument
 constructor with a &lt;code&gt;null&lt;/code&gt; first argument.</description>
					<attribute name="@param">
						<description>spec   the &lt;code&gt;String&lt;/code&gt; to parse as a URL.</description>
					</attribute>
					<attribute name="@exception">
						<description>MalformedURLException  If the string specifies an
               unknown protocol.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URL#URL(java.net.URL, java.lang.String)</description>
					</attribute>
				</comment>
				<params>
					<param name="spec" comment="the &lt;code&gt;String&lt;/code&gt; to parse as a URL." fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception comment="If the string specifies an
               unknown protocol." fulltype="java.net.MalformedURLException" type="MalformedURLException" />
				</exceptions>
			</constructor>
			<constructor visibility="public" name="URL">
				<comment>
					<description>Creates a URL by parsing the given spec within a specified context.

 The new URL is created from the given context URL and the spec
 argument as described in
 RFC2396 &amp;quot;Uniform Resource Identifiers : Generic * Syntax&amp;quot; :
 &lt;blockquote&gt;&lt;pre&gt;
          &amp;lt;scheme&amp;gt;://&amp;lt;authority&amp;gt;&amp;lt;path&amp;gt;?&amp;lt;query&amp;gt;#&amp;lt;fragment&amp;gt;
 &lt;/pre&gt;&lt;/blockquote&gt;
 The reference is parsed into the scheme, authority, path, query and
 fragment parts. If the path component is empty and the scheme,
 authority, and query components are undefined, then the new URL is a
 reference to the current document. Otherwise, the fragment and query
 parts present in the spec are used in the new URL.
 &lt;p&gt;
 If the scheme component is defined in the given spec and does not match
 the scheme of the context, then the new URL is created as an absolute
 URL based on the spec alone. Otherwise the scheme component is inherited
 from the context URL.
 &lt;p&gt;
 If the authority component is present in the spec then the spec is
 treated as absolute and the spec authority and path will replace the
 context authority and path. If the authority component is absent in the
 spec then the authority of the new URL will be inherited from the
 context.
 &lt;p&gt;
 If the spec&apos;s path component begins with a slash character
 &amp;quot;/&amp;quot; then the
 path is treated as absolute and the spec path replaces the context path.
 &lt;p&gt;
 Otherwise, the path is treated as a relative path and is appended to the
 context path, as described in RFC2396. Also, in this case,
 the path is canonicalized through the removal of directory
 changes made by occurences of &amp;quot;..&amp;quot; and &amp;quot;.&amp;quot;.
 &lt;p&gt;
 For a more detailed description of URL parsing, refer to RFC2396.</description>
					<attribute name="@param">
						<description>context   the context in which to parse the specification.</description>
					</attribute>
					<attribute name="@param">
						<description>spec      the &lt;code&gt;String&lt;/code&gt; to parse as a URL.</description>
					</attribute>
					<attribute name="@exception">
						<description>MalformedURLException  if no protocol is specified, or an
               unknown protocol is found.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URL#URL(java.lang.String, java.lang.String,
                  int, java.lang.String)</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URLStreamHandler</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URLStreamHandler#parseURL(java.net.URL,
                  java.lang.String, int, int)</description>
					</attribute>
				</comment>
				<params>
					<param name="context" comment="the context in which to parse the specification." fulltype="java.net.URL" type="URL" />
					<param name="spec" comment="the &lt;code&gt;String&lt;/code&gt; to parse as a URL." fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception comment="if no protocol is specified, or an
               unknown protocol is found." fulltype="java.net.MalformedURLException" type="MalformedURLException" />
				</exceptions>
			</constructor>
			<constructor visibility="public" name="URL">
				<comment>
					<description>Creates a URL by parsing the given spec with the specified handler
 within a specified context. If the handler is null, the parsing
 occurs as with the two argument constructor.</description>
					<attribute name="@param">
						<description>context   the context in which to parse the specification.</description>
					</attribute>
					<attribute name="@param">
						<description>spec      the &lt;code&gt;String&lt;/code&gt; to parse as a URL.</description>
					</attribute>
					<attribute name="@param">
						<description>handler   the stream handler for the URL.</description>
					</attribute>
					<attribute name="@exception">
						<description>MalformedURLException  if no protocol is specified, or an
               unknown protocol is found.</description>
					</attribute>
					<attribute name="@exception">
						<description>SecurityException
        if a security manager exists and its
        &lt;code&gt;checkPermission&lt;/code&gt; method doesn&apos;t allow
        specifying a stream handler.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URL#URL(java.lang.String, java.lang.String,
                  int, java.lang.String)</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URLStreamHandler</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URLStreamHandler#parseURL(java.net.URL,
                  java.lang.String, int, int)</description>
					</attribute>
				</comment>
				<params>
					<param name="context" comment="the context in which to parse the specification." fulltype="java.net.URL" type="URL" />
					<param name="spec" comment="the &lt;code&gt;String&lt;/code&gt; to parse as a URL." fulltype="java.lang.String" type="String" />
					<param name="handler" comment="the stream handler for the URL." fulltype="java.net.URLStreamHandler" type="URLStreamHandler" />
				</params>
				<exceptions>
					<exception comment="if no protocol is specified, or an
               unknown protocol is found." fulltype="java.net.MalformedURLException" type="MalformedURLException" />
				</exceptions>
			</constructor>
			<method visibility="private" name="isValidProtocol" fulltype="boolean" type="boolean">
				<params>
					<param name="protocol" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="private" name="checkSpecifyHandler" fulltype="void" type="void">
				<params>
					<param name="sm" fulltype="java.lang.SecurityManager" type="SecurityManager" />
				</params>
			</method>
			<method visibility="protected" name="set" fulltype="void" type="void">
				<comment>
					<description>Sets the fields of the URL. This is not a public method so that
 only URLStreamHandlers can modify URL fields. URLs are
 otherwise constant.</description>
					<attribute name="@param">
						<description>protocol the name of the protocol to use</description>
					</attribute>
					<attribute name="@param">
						<description>host the name of the host</description>
					</attribute>
					<attribute name="@param">
						<description>port the port number on the host</description>
					</attribute>
					<attribute name="@param">
						<description>file the file on the host</description>
					</attribute>
					<attribute name="@param">
						<description>ref the internal reference in the URL</description>
					</attribute>
				</comment>
				<params>
					<param name="protocol" comment="the name of the protocol to use" fulltype="java.lang.String" type="String" />
					<param name="host" comment="the name of the host" fulltype="java.lang.String" type="String" />
					<param name="port" comment="the port number on the host" fulltype="int" type="int" />
					<param name="file" comment="the file on the host" fulltype="java.lang.String" type="String" />
					<param name="ref" comment="the internal reference in the URL" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="protected" name="set" fulltype="void" type="void">
				<comment>
					<description>Sets the specified 8 fields of the URL. This is not a public method so
 that only URLStreamHandlers can modify URL fields. URLs are otherwise
 constant.</description>
					<attribute name="@param">
						<description>protocol the name of the protocol to use</description>
					</attribute>
					<attribute name="@param">
						<description>host the name of the host</description>
					</attribute>
					<attribute name="@param">
						<description>port the port number on the host</description>
					</attribute>
					<attribute name="@param">
						<description>authority the authority part for the url</description>
					</attribute>
					<attribute name="@param">
						<description>userInfo the username and password</description>
					</attribute>
					<attribute name="@param">
						<description>path the file on the host</description>
					</attribute>
					<attribute name="@param">
						<description>ref the internal reference in the URL</description>
					</attribute>
					<attribute name="@param">
						<description>query the query part of this URL</description>
					</attribute>
					<attribute name="@since">
						<description>1.3</description>
					</attribute>
				</comment>
				<params>
					<param name="protocol" comment="the name of the protocol to use" fulltype="java.lang.String" type="String" />
					<param name="host" comment="the name of the host" fulltype="java.lang.String" type="String" />
					<param name="port" comment="the port number on the host" fulltype="int" type="int" />
					<param name="authority" comment="the authority part for the url" fulltype="java.lang.String" type="String" />
					<param name="userInfo" comment="the username and password" fulltype="java.lang.String" type="String" />
					<param name="path" comment="the file on the host" fulltype="java.lang.String" type="String" />
					<param name="query" comment="the query part of this URL" fulltype="java.lang.String" type="String" />
					<param name="ref" comment="the internal reference in the URL" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="public" name="getQuery" returncomment="the query part of this &lt;code&gt;URL&lt;/code&gt;,
 or &lt;CODE&gt;null&lt;/CODE&gt; if one does not exist" fulltype="java.lang.String" type="String">
				<comment>
					<description>Gets the query part of this &lt;code&gt;URL&lt;/code&gt;.</description>
					<attribute name="@return">
						<description>the query part of this &lt;code&gt;URL&lt;/code&gt;,
 or &lt;CODE&gt;null&lt;/CODE&gt; if one does not exist</description>
					</attribute>
					<attribute name="@since">
						<description>1.3</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getPath" returncomment="the path part of this &lt;code&gt;URL&lt;/code&gt;, or an
 empty string if one does not exist" fulltype="java.lang.String" type="String">
				<comment>
					<description>Gets the path part of this &lt;code&gt;URL&lt;/code&gt;.</description>
					<attribute name="@return">
						<description>the path part of this &lt;code&gt;URL&lt;/code&gt;, or an
 empty string if one does not exist</description>
					</attribute>
					<attribute name="@since">
						<description>1.3</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getUserInfo" returncomment="the userInfo part of this &lt;code&gt;URL&lt;/code&gt;, or
 &lt;CODE&gt;null&lt;/CODE&gt; if one does not exist" fulltype="java.lang.String" type="String">
				<comment>
					<description>Gets the userInfo part of this &lt;code&gt;URL&lt;/code&gt;.</description>
					<attribute name="@return">
						<description>the userInfo part of this &lt;code&gt;URL&lt;/code&gt;, or
 &lt;CODE&gt;null&lt;/CODE&gt; if one does not exist</description>
					</attribute>
					<attribute name="@since">
						<description>1.3</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getAuthority" returncomment="the authority part of this &lt;code&gt;URL&lt;/code&gt;" fulltype="java.lang.String" type="String">
				<comment>
					<description>Gets the authority part of this &lt;code&gt;URL&lt;/code&gt;.</description>
					<attribute name="@return">
						<description>the authority part of this &lt;code&gt;URL&lt;/code&gt;</description>
					</attribute>
					<attribute name="@since">
						<description>1.3</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getPort" returncomment="the port number, or -1 if the port is not set" fulltype="int" type="int">
				<comment>
					<description>Gets the port number of this &lt;code&gt;URL&lt;/code&gt;.</description>
					<attribute name="@return">
						<description>the port number, or -1 if the port is not set</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getDefaultPort" returncomment="the port number" fulltype="int" type="int">
				<comment>
					<description>Gets the default port number of the protocol associated
 with this &lt;code&gt;URL&lt;/code&gt;. If the URL scheme or the URLStreamHandler
 for the URL do not define a default port number,
 then -1 is returned.</description>
					<attribute name="@return">
						<description>the port number</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getProtocol" returncomment="the protocol of this &lt;code&gt;URL&lt;/code&gt;." fulltype="java.lang.String" type="String">
				<comment>
					<description>Gets the protocol name of this &lt;code&gt;URL&lt;/code&gt;.</description>
					<attribute name="@return">
						<description>the protocol of this &lt;code&gt;URL&lt;/code&gt;.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getHost" returncomment="the host name of this &lt;code&gt;URL&lt;/code&gt;." fulltype="java.lang.String" type="String">
				<comment>
					<description>Gets the host name of this &lt;code&gt;URL&lt;/code&gt;, if applicable.
 The format of the host conforms to RFC 2732, i.e. for a
 literal IPv6 address, this method will return the IPv6 address
 enclosed in square brackets (&lt;tt&gt;&apos;[&apos;&lt;/tt&gt; and &lt;tt&gt;&apos;]&apos;&lt;/tt&gt;).</description>
					<attribute name="@return">
						<description>the host name of this &lt;code&gt;URL&lt;/code&gt;.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getFile" returncomment="the file name of this &lt;code&gt;URL&lt;/code&gt;,
 or an empty string if one does not exist" fulltype="java.lang.String" type="String">
				<comment>
					<description>Gets the file name of this &lt;code&gt;URL&lt;/code&gt;.
 The returned file portion will be
 the same as &lt;CODE&gt;getPath()&lt;/CODE&gt;, plus the concatenation of
 the value of &lt;CODE&gt;getQuery()&lt;/CODE&gt;, if any. If there is
 no query portion, this method and &lt;CODE&gt;getPath()&lt;/CODE&gt; will
 return identical results.</description>
					<attribute name="@return">
						<description>the file name of this &lt;code&gt;URL&lt;/code&gt;,
 or an empty string if one does not exist</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getRef" returncomment="the anchor (also known as the &quot;reference&quot;) of this
          &lt;code&gt;URL&lt;/code&gt;, or &lt;CODE&gt;null&lt;/CODE&gt; if one does not exist" fulltype="java.lang.String" type="String">
				<comment>
					<description>Gets the anchor (also known as the &quot;reference&quot;) of this
 &lt;code&gt;URL&lt;/code&gt;.</description>
					<attribute name="@return">
						<description>the anchor (also known as the &quot;reference&quot;) of this
          &lt;code&gt;URL&lt;/code&gt;, or &lt;CODE&gt;null&lt;/CODE&gt; if one does not exist</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="equals" returncomment="&lt;code&gt;true&lt;/code&gt; if the objects are the same;
          &lt;code&gt;false&lt;/code&gt; otherwise." fulltype="boolean" type="boolean">
				<comment>
					<description>Compares this URL for equality with another object.&lt;p&gt;

 If the given object is not a URL then this method immediately returns
 &lt;code&gt;false&lt;/code&gt;.&lt;p&gt;

 Two URL objects are equal if they have the same protocol, reference
 equivalent hosts, have the same port number on the host, and the same
 file and fragment of the file.&lt;p&gt;

 Two hosts are considered equivalent if both host names can be resolved
 into the same IP addresses; else if either host name can&apos;t be
 resolved, the host names must be equal without regard to case; or both
 host names equal to null.&lt;p&gt;

 Since hosts comparison requires name resolution, this operation is a
 blocking operation. &lt;p&gt;

 Note: The defined behavior for &lt;code&gt;equals&lt;/code&gt; is known to
 be inconsistent with virtual hosting in HTTP.</description>
					<attribute name="@param">
						<description>obj   the URL to compare against.</description>
					</attribute>
					<attribute name="@return">
						<description>&lt;code&gt;true&lt;/code&gt; if the objects are the same;
          &lt;code&gt;false&lt;/code&gt; otherwise.</description>
					</attribute>
				</comment>
				<params>
					<param name="obj" comment="the URL to compare against." fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method synchronized="true" visibility="public" name="hashCode" returncomment="a hash code for this &lt;code&gt;URL&lt;/code&gt;." fulltype="int" type="int">
				<comment>
					<description>Creates an integer suitable for hash table indexing.&lt;p&gt;

 The hash code is based upon all the URL components relevant for URL
 comparison. As such, this operation is a blocking operation.&lt;p&gt;</description>
					<attribute name="@return">
						<description>a hash code for this &lt;code&gt;URL&lt;/code&gt;.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="sameFile" returncomment="&lt;code&gt;true&lt;/code&gt; if they reference the same remote object;
          &lt;code&gt;false&lt;/code&gt; otherwise." fulltype="boolean" type="boolean">
				<comment>
					<description>Compares two URLs, excluding the fragment component.&lt;p&gt;

 Returns &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;URL&lt;/code&gt; and the
 &lt;code&gt;other&lt;/code&gt; argument are equal without taking the
 fragment component into consideration.</description>
					<attribute name="@param">
						<description>other   the &lt;code&gt;URL&lt;/code&gt; to compare against.</description>
					</attribute>
					<attribute name="@return">
						<description>&lt;code&gt;true&lt;/code&gt; if they reference the same remote object;
          &lt;code&gt;false&lt;/code&gt; otherwise.</description>
					</attribute>
				</comment>
				<params>
					<param name="other" comment="the &lt;code&gt;URL&lt;/code&gt; to compare against." fulltype="java.net.URL" type="URL" />
				</params>
			</method>
			<method visibility="public" name="toString" returncomment="a string representation of this object." fulltype="java.lang.String" type="String">
				<comment>
					<description>Constructs a string representation of this &lt;code&gt;URL&lt;/code&gt;. The
 string is created by calling the &lt;code&gt;toExternalForm&lt;/code&gt;
 method of the stream protocol handler for this object.</description>
					<attribute name="@return">
						<description>a string representation of this object.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URL#URL(java.lang.String, java.lang.String, int,
                  java.lang.String)</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URLStreamHandler#toExternalForm(java.net.URL)</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="toExternalForm" returncomment="a string representation of this object." fulltype="java.lang.String" type="String">
				<comment>
					<description>Constructs a string representation of this &lt;code&gt;URL&lt;/code&gt;. The
 string is created by calling the &lt;code&gt;toExternalForm&lt;/code&gt;
 method of the stream protocol handler for this object.</description>
					<attribute name="@return">
						<description>a string representation of this object.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URL#URL(java.lang.String, java.lang.String,
                  int, java.lang.String)</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URLStreamHandler#toExternalForm(java.net.URL)</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="toURI" returncomment="a URI instance equivalent to this URL." fulltype="java.net.URI" type="URI">
				<comment>
					<description>Returns a {@link java.net.URI} equivalent to this URL.
 This method functions in the same way as &lt;code&gt;new URI (this.toString())&lt;/code&gt;.
 &lt;p&gt;Note, any URL instance that complies with RFC 2396 can be converted
 to a URI. However, some URLs that are not strictly in compliance
 can not be converted to a URI.</description>
					<attribute name="@exception">
						<description>URISyntaxException if this URL is not formatted strictly according to
            to RFC2396 and cannot be converted to a URI.</description>
					</attribute>
					<attribute name="@return">
						<description>a URI instance equivalent to this URL.</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if this URL is not formatted strictly according to
            to RFC2396 and cannot be converted to a URI." fulltype="java.net.URISyntaxException" type="URISyntaxException" />
				</exceptions>
			</method>
			<method visibility="public" name="openConnection" returncomment="a &lt;code&gt;URLConnection&lt;/code&gt; to the URL." fulltype="java.net.URLConnection" type="URLConnection">
				<comment>
					<description>Returns a &lt;code&gt;URLConnection&lt;/code&gt; object that represents a
 connection to the remote object referred to by the &lt;code&gt;URL&lt;/code&gt;.

 &lt;p&gt;A new connection is opened every time by calling the
 &lt;code&gt;openConnection&lt;/code&gt; method of the protocol handler for
 this URL.

 &lt;p&gt;If for the URL&apos;s protocol (such as HTTP or JAR), there
 exists a public, specialized URLConnection subclass belonging
 to one of the following packages or one of their subpackages:
 java.lang, java.io, java.util, java.net, the connection
 returned will be of that subclass. For example, for HTTP an
 HttpURLConnection will be returned, and for JAR a
 JarURLConnection will be returned.</description>
					<attribute name="@return">
						<description>a &lt;code&gt;URLConnection&lt;/code&gt; to the URL.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O exception occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URL#URL(java.lang.String, java.lang.String,
             int, java.lang.String)</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URLConnection</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URLStreamHandler#openConnection(java.net.URL)</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O exception occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="openConnection" returncomment="a &lt;code&gt;URLConnection&lt;/code&gt; to the URL." fulltype="java.net.URLConnection" type="URLConnection">
				<comment>
					<description>Same as openConnection(), except that the connection will be
 made through the specified proxy; Protocol handlers that do not
 support proxing will ignore the proxy parameter and make a
 normal connection.

 Calling this method preempts the system&apos;s default ProxySelector
 settings.</description>
					<attribute name="@param">
						<description>proxy the Proxy through which this connection
             will be made. If direct connection is desired,
             Proxy.NO_PROXY should be specified.</description>
					</attribute>
					<attribute name="@return">
						<description>a &lt;code&gt;URLConnection&lt;/code&gt; to the URL.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O exception occurs.</description>
					</attribute>
					<attribute name="@exception">
						<description>SecurityException if a security manager is present
             and the caller doesn&apos;t have permission to connect
             to the proxy.</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException will be thrown if proxy is null,
             or proxy has the wrong type</description>
					</attribute>
					<attribute name="@exception">
						<description>UnsupportedOperationException if the subclass that
             implements the protocol handler doesn&apos;t support
             this method.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URL#URL(java.lang.String, java.lang.String,
             int, java.lang.String)</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URLConnection</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URLStreamHandler#openConnection(java.net.URL,
             java.net.Proxy)</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
				<params>
					<param name="proxy" comment="the Proxy through which this connection
             will be made. If direct connection is desired,
             Proxy.NO_PROXY should be specified." fulltype="java.net.Proxy" type="Proxy" />
				</params>
				<exceptions>
					<exception comment="if an I/O exception occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="openStream" returncomment="an input stream for reading from the URL connection." fulltype="java.io.InputStream" type="InputStream">
				<comment>
					<description>Opens a connection to this &lt;code&gt;URL&lt;/code&gt; and returns an
 &lt;code&gt;InputStream&lt;/code&gt; for reading from that connection. This
 method is a shorthand for:
 &lt;blockquote&gt;&lt;pre&gt;
     openConnection().getInputStream()
 &lt;/pre&gt;&lt;/blockquote&gt;</description>
					<attribute name="@return">
						<description>an input stream for reading from the URL connection.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O exception occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URL#openConnection()</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URLConnection#getInputStream()</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O exception occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="getContent" returncomment="the contents of this URL." fulltype="java.lang.Object" type="Object">
				<comment>
					<description>Gets the contents of this URL. This method is a shorthand for:
 &lt;blockquote&gt;&lt;pre&gt;
     openConnection().getContent()
 &lt;/pre&gt;&lt;/blockquote&gt;</description>
					<attribute name="@return">
						<description>the contents of this URL.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O exception occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URLConnection#getContent()</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O exception occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="getContent" returncomment="the content object of this URL that is the first match of
               the types specified in the classes array.
               null if none of the requested types are supported." fulltype="java.lang.Object" type="Object">
				<comment>
					<description>Gets the contents of this URL. This method is a shorthand for:
 &lt;blockquote&gt;&lt;pre&gt;
     openConnection().getContent(Class[])
 &lt;/pre&gt;&lt;/blockquote&gt;</description>
					<attribute name="@param">
						<description>classes an array of Java types</description>
					</attribute>
					<attribute name="@return">
						<description>the content object of this URL that is the first match of
               the types specified in the classes array.
               null if none of the requested types are supported.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O exception occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URLConnection#getContent(Class[])</description>
					</attribute>
					<attribute name="@since">
						<description>1.3</description>
					</attribute>
				</comment>
				<params>
					<param name="classes" comment="an array of Java types" fulltype="java.lang.Class[]" type="Class" />
				</params>
				<exceptions>
					<exception comment="if an I/O exception occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method static="true" visibility="public" name="setURLStreamHandlerFactory" fulltype="void" type="void">
				<comment>
					<description>Sets an application&apos;s &lt;code&gt;URLStreamHandlerFactory&lt;/code&gt;.
 This method can be called at most once in a given Java Virtual
 Machine.

&lt;p&gt; The &lt;code&gt;URLStreamHandlerFactory&lt;/code&gt; instance is used to
construct a stream protocol handler from a protocol name.

 &lt;p&gt; If there is a security manager, this method first calls
 the security manager&apos;s &lt;code&gt;checkSetFactory&lt;/code&gt; method
 to ensure the operation is allowed.
 This could result in a SecurityException.</description>
					<attribute name="@param">
						<description>fac   the desired factory.</description>
					</attribute>
					<attribute name="@exception">
						<description>Error  if the application has already set a factory.</description>
					</attribute>
					<attribute name="@exception">
						<description>SecurityException  if a security manager exists and its
             &lt;code&gt;checkSetFactory&lt;/code&gt; method doesn&apos;t allow
             the operation.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URL#URL(java.lang.String, java.lang.String,
             int, java.lang.String)</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URLStreamHandlerFactory</description>
					</attribute>
					<attribute name="@see">
						<description>SecurityManager#checkSetFactory</description>
					</attribute>
				</comment>
				<params>
					<param name="fac" comment="the desired factory." fulltype="java.net.URLStreamHandlerFactory" type="URLStreamHandlerFactory" />
				</params>
			</method>
			<method static="true" visibility="package-private" name="getURLStreamHandler" fulltype="java.net.URLStreamHandler" type="URLStreamHandler">
				<comment>
					<description>Returns the Stream Handler.</description>
					<attribute name="@param">
						<description>protocol the protocol to use</description>
					</attribute>
				</comment>
				<params>
					<param name="protocol" comment="the protocol to use" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method synchronized="true" visibility="private" name="writeObject" fulltype="void" type="void">
				<comment>
					<description>WriteObject is called to save the state of the URL to an
 ObjectOutputStream. The handler is not saved since it is
 specific to this system.</description>
					<attribute name="@serialData">
						<description>the default write object value. When read back in,
 the reader must ensure that calling getURLStreamHandler with
 the protocol variable returns a valid URLStreamHandler and
 throw an IOException if it does not.</description>
					</attribute>
				</comment>
				<params>
					<param name="s" fulltype="java.io.ObjectOutputStream" type="ObjectOutputStream" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="private" name="readObject" fulltype="void" type="void">
				<comment>
					<description>readObject is called to restore the state of the URL from the
 stream.  It reads the components of the URL and finds the local
 stream handler.</description>
				</comment>
				<params>
					<param name="s" fulltype="java.io.ObjectInputStream" type="ObjectInputStream" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
					<exception fulltype="java.lang.ClassNotFoundException" type="ClassNotFoundException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="Object" visibility="package-private" package="java.net" superclassfulltype="java.lang.Object" fulltype="java.net.Parts" type="Parts">
		<fields>
			<field visibility="package-private" name="path" fulltype="java.lang.String" type="String" />
			<field visibility="package-private" name="query" fulltype="java.lang.String" type="String" />
			<field visibility="package-private" name="ref" fulltype="java.lang.String" type="String" />
		</fields>
		<methods>
			<constructor visibility="package-private" name="Parts">
				<params>
					<param name="file" fulltype="java.lang.String" type="String" />
				</params>
			</constructor>
			<method visibility="package-private" name="getPath" fulltype="java.lang.String" type="String" />
			<method visibility="package-private" name="getQuery" fulltype="java.lang.String" type="String" />
			<method visibility="package-private" name="getRef" fulltype="java.lang.String" type="String" />
		</methods>
	</jelclass>
	<jelclass abstract="true" superclass="Object" visibility="public" package="java.net" superclassfulltype="java.lang.Object" fulltype="java.net.CacheRequest" type="CacheRequest">
		<comment>
			<description>Represents channels for storing resources in the
 ResponseCache. Instances of such a class provide an
 OutputStream object which is called by protocol handlers to
 store the resource data into the cache, and also an abort() method
 which allows a cache store operation to be interrupted and
 abandoned. If an IOException is encountered while reading the
 response or writing to the cache, the current cache store operation
 will be aborted.</description>
			<attribute name="@author">
				<description>Yingxian Wang</description>
			</attribute>
			<attribute name="@since">
				<description>1.5</description>
			</attribute>
		</comment>
		<methods>
			<constructor visibility="public" name="CacheRequest" />
			<method abstract="true" visibility="public" name="getBody" returncomment="an OutputStream to which the response body can
         be written" fulltype="java.io.OutputStream" type="OutputStream">
				<comment>
					<description>Returns an OutputStream to which the response body can be
 written.</description>
					<attribute name="@return">
						<description>an OutputStream to which the response body can
         be written</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException if an I/O error occurs while
         writing the response body</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs while
         writing the response body" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="public" name="abort" fulltype="void" type="void">
				<comment>
					<description>Aborts the attempt to cache the response. If an IOException is
 encountered while reading the response or writing to the cache,
 the current cache store operation will be abandoned.</description>
				</comment>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="CookieHandler" visibility="public" package="java.net" superclassfulltype="java.net.CookieHandler" fulltype="java.net.CookieManager" type="CookieManager">
		<comment>
			<description>CookieManager provides a concrete implementation of {@link CookieHandler},
 which separates the storage of cookies from the policy surrounding accepting
 and rejecting cookies. A CookieManager is initialized with a {@link CookieStore}
 which manages storage, and a {@link CookiePolicy} object, which makes
 policy decisions on cookie acceptance/rejection.

 &lt;p&gt; The HTTP cookie management in java.net package looks like:
 &lt;blockquote&gt;
 &lt;pre&gt;
                  use
 CookieHandler &lt;------- HttpURLConnection
       ^
       | impl
       |         use
 CookieManager -------&gt; CookiePolicy
             |   use
             |--------&gt; HttpCookie
             |              ^
             |              | use
             |   use        |
             |--------&gt; CookieStore
                            ^
                            | impl
                            |
                  Internal in-memory implementation
 &lt;/pre&gt;
 &lt;ul&gt;
   &lt;li&gt;
     CookieHandler is at the core of cookie management. User can call
     CookieHandler.setDefault to set a concrete CookieHanlder implementation
     to be used.
   &lt;/li&gt;
   &lt;li&gt;
     CookiePolicy.shouldAccept will be called by CookieManager.put to see whether
     or not one cookie should be accepted and put into cookie store. User can use
     any of three pre-defined CookiePolicy, namely ACCEPT_ALL, ACCEPT_NONE and
     ACCEPT_ORIGINAL_SERVER, or user can define his own CookiePolicy implementation
     and tell CookieManager to use it.
   &lt;/li&gt;
   &lt;li&gt;
     CookieStore is the place where any accepted HTTP cookie is stored in.
     If not specified when created, a CookieManager instance will use an internal
     in-memory implementation. Or user can implements one and tell CookieManager
     to use it.
   &lt;/li&gt;
   &lt;li&gt;
     Currently, only CookieStore.add(URI, HttpCookie) and CookieStore.get(URI)
     are used by CookieManager. Others are for completeness and might be needed
     by a more sophisticated CookieStore implementation, e.g. a NetscapeCookieSotre.
   &lt;/li&gt;
 &lt;/ul&gt;
 &lt;/blockquote&gt;

 &lt;p&gt;There&apos;re various ways user can hook up his own HTTP cookie management behavior, e.g.
 &lt;blockquote&gt;
 &lt;ul&gt;
   &lt;li&gt;Use CookieHandler.setDefault to set a brand new {@link CookieHandler} implementation
   &lt;li&gt;Let CookieManager be the default {@link CookieHandler} implementation,
       but implement user&apos;s own {@link CookieStore} and {@link CookiePolicy}
       and tell default CookieManager to use them:
     &lt;blockquote&gt;&lt;pre&gt;
       // this should be done at the beginning of an HTTP session
       CookieHandler.setDefault(new CookieManager(new MyCookieStore(), new MyCookiePolicy()));
     &lt;/pre&gt;&lt;/blockquote&gt;
   &lt;li&gt;Let CookieManager be the default {@link CookieHandler} implementation, but
       use customized {@link CookiePolicy}:
     &lt;blockquote&gt;&lt;pre&gt;
       // this should be done at the beginning of an HTTP session
       CookieHandler.setDefault(new CookieManager());
       // this can be done at any point of an HTTP session
       ((CookieManager)CookieHandler.getDefault()).setCookiePolicy(new MyCookiePolicy());
     &lt;/pre&gt;&lt;/blockquote&gt;
 &lt;/ul&gt;
 &lt;/blockquote&gt;

 &lt;p&gt;The implementation conforms to RFC 2965, section 3.3.</description>
			<attribute name="@author">
				<description>Edward Wang</description>
			</attribute>
			<attribute name="@since">
				<description>1.6</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="private" name="policyCallback" fulltype="java.net.CookiePolicy" type="CookiePolicy" />
			<field visibility="private" name="cookieJar" fulltype="java.net.CookieStore" type="CookieStore" />
		</fields>
		<methods>
			<constructor visibility="public" name="CookieManager">
				<comment>
					<description>Create a new cookie manager.

 &lt;p&gt;This constructor will create new cookie manager with default
 cookie store and accept policy. The effect is same as
 &lt;tt&gt;CookieManager(null, null)&lt;/tt&gt;.</description>
				</comment>
			</constructor>
			<constructor visibility="public" name="CookieManager">
				<comment>
					<description>Create a new cookie manager with specified cookie store and cookie policy.</description>
					<attribute name="@param">
						<description>store     a &lt;tt&gt;CookieStore&lt;/tt&gt; to be used by cookie manager.
                  if &lt;tt&gt;null&lt;/tt&gt;, cookie manager will use a default one,
                  which is an in-memory CookieStore implmentation.</description>
					</attribute>
					<attribute name="@param">
						<description>cookiePolicy      a &lt;tt&gt;CookiePolicy&lt;/tt&gt; instance
                          to be used by cookie manager as policy callback.
                          if &lt;tt&gt;null&lt;/tt&gt;, ACCEPT_ORIGINAL_SERVER will
                          be used.</description>
					</attribute>
				</comment>
				<params>
					<param name="store" comment="a &lt;tt&gt;CookieStore&lt;/tt&gt; to be used by cookie manager.
                  if &lt;tt&gt;null&lt;/tt&gt;, cookie manager will use a default one,
                  which is an in-memory CookieStore implmentation." fulltype="java.net.CookieStore" type="CookieStore" />
					<param name="cookiePolicy" comment="a &lt;tt&gt;CookiePolicy&lt;/tt&gt; instance
                          to be used by cookie manager as policy callback.
                          if &lt;tt&gt;null&lt;/tt&gt;, ACCEPT_ORIGINAL_SERVER will
                          be used." fulltype="java.net.CookiePolicy" type="CookiePolicy" />
				</params>
			</constructor>
			<method visibility="public" name="setCookiePolicy" fulltype="void" type="void">
				<comment>
					<description>To set the cookie policy of this cookie manager.

 &lt;p&gt; A instance of &lt;tt&gt;CookieManager&lt;/tt&gt; will have
 cookie policy ACCEPT_ORIGINAL_SERVER by default. Users always
 can call this method to set another cookie policy.</description>
					<attribute name="@param">
						<description>cookiePolicy      the cookie policy. Can be &lt;tt&gt;null&lt;/tt&gt;, which
                          has no effects on current cookie policy.</description>
					</attribute>
				</comment>
				<params>
					<param name="cookiePolicy" comment="the cookie policy. Can be &lt;tt&gt;null&lt;/tt&gt;, which
                          has no effects on current cookie policy." fulltype="java.net.CookiePolicy" type="CookiePolicy" />
				</params>
			</method>
			<method visibility="public" name="getCookieStore" returncomment="the cookie store currently used by cookie manager." fulltype="java.net.CookieStore" type="CookieStore">
				<comment>
					<description>To retrieve current cookie store.</description>
					<attribute name="@return">
						<description>the cookie store currently used by cookie manager.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="get" fulltype="java.util.Map" type="Map">
				<params>
					<param name="uri" fulltype="java.net.URI" type="URI" />
					<param name="requestHeaders" fulltype="java.util.Map" type="Map" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="put" fulltype="void" type="void">
				<params>
					<param name="uri" fulltype="java.net.URI" type="URI" />
					<param name="responseHeaders" fulltype="java.util.Map" type="Map" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="shouldAcceptInternal" fulltype="boolean" type="boolean">
				<params>
					<param name="uri" fulltype="java.net.URI" type="URI" />
					<param name="cookie" fulltype="java.net.HttpCookie" type="HttpCookie" />
				</params>
			</method>
			<method visibility="private" name="pathMatches" fulltype="boolean" type="boolean">
				<params>
					<param name="path" fulltype="java.lang.String" type="String" />
					<param name="pathToMatchWith" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="private" name="sortByPath" fulltype="java.util.List" type="List">
				<params>
					<param name="cookies" fulltype="java.util.List" type="List" />
				</params>
			</method>
		</methods>
		<jelclass superclass="Object" visibility="package-private" package="java.net" superclassfulltype="java.lang.Object" fulltype="java.net.CookieManager.CookiePathComparator" type="CookieManager.CookiePathComparator">
			<implements>
				<interface fulltype="java.util.Comparator" type="Comparator" />
			</implements>
			<methods>
				<constructor visibility="package-private" name="CookieManager.CookiePathComparator" />
				<method visibility="public" name="compare" fulltype="int" type="int">
					<params>
						<param name="c1" fulltype="java.net.HttpCookie" type="HttpCookie" />
						<param name="c2" fulltype="java.net.HttpCookie" type="HttpCookie" />
					</params>
				</method>
			</methods>
		</jelclass>
	</jelclass>
	<jelclass superclass="Object" visibility="package-private" package="java.net" superclassfulltype="java.lang.Object" fulltype="java.net.CookieManager.CookiePathComparator" type="CookieManager.CookiePathComparator">
		<implements>
			<interface fulltype="java.util.Comparator" type="Comparator" />
		</implements>
		<methods>
			<constructor visibility="package-private" name="CookieManager.CookiePathComparator" />
			<method visibility="public" name="compare" fulltype="int" type="int">
				<params>
					<param name="c1" fulltype="java.net.HttpCookie" type="HttpCookie" />
					<param name="c2" fulltype="java.net.HttpCookie" type="HttpCookie" />
				</params>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="Object" visibility="package-private" package="java.net" superclassfulltype="java.lang.Object" fulltype="java.net.Inet4AddressImpl" type="Inet4AddressImpl">
		<implements>
			<interface fulltype="java.net.InetAddressImpl" type="InetAddressImpl" />
		</implements>
		<fields>
			<field visibility="private" name="anyLocalAddress" fulltype="java.net.InetAddress" type="InetAddress" />
			<field visibility="private" name="loopbackAddress" fulltype="java.net.InetAddress" type="InetAddress" />
		</fields>
		<methods>
			<constructor visibility="package-private" name="Inet4AddressImpl" />
			<method visibility="public" name="getLocalHostName" fulltype="java.lang.String" type="String">
				<exceptions>
					<exception fulltype="java.net.UnknownHostException" type="UnknownHostException" />
				</exceptions>
			</method>
			<method visibility="public" name="lookupAllHostAddr" fulltype="java.net.InetAddress[]" type="InetAddress">
				<params>
					<param name="hostname" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception fulltype="java.net.UnknownHostException" type="UnknownHostException" />
				</exceptions>
			</method>
			<method visibility="public" name="getHostByAddr" fulltype="java.lang.String" type="String">
				<params>
					<param name="addr" fulltype="byte[]" type="byte" />
				</params>
				<exceptions>
					<exception fulltype="java.net.UnknownHostException" type="UnknownHostException" />
				</exceptions>
			</method>
			<method visibility="private" name="isReachable0" fulltype="boolean" type="boolean">
				<params>
					<param name="addr" fulltype="byte[]" type="byte" />
					<param name="timeout" fulltype="int" type="int" />
					<param name="ifaddr" fulltype="byte[]" type="byte" />
					<param name="ttl" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="public" name="anyLocalAddress" fulltype="java.net.InetAddress" type="InetAddress" />
			<method synchronized="true" visibility="public" name="loopbackAddress" fulltype="java.net.InetAddress" type="InetAddress" />
			<method visibility="public" name="isReachable" fulltype="boolean" type="boolean">
				<params>
					<param name="addr" fulltype="java.net.InetAddress" type="InetAddress" />
					<param name="timeout" fulltype="int" type="int" />
					<param name="netif" fulltype="java.net.NetworkInterface" type="NetworkInterface" />
					<param name="ttl" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass abstract="true" superclass="URLConnection" visibility="public" package="java.net" superclassfulltype="java.net.URLConnection" fulltype="java.net.HttpURLConnection" type="HttpURLConnection">
		<comment>
			<description>A URLConnection with support for HTTP-specific features. See
 &lt;A HREF=&quot;http://www.w3.org/pub/WWW/Protocols/&quot;&gt; the spec &lt;/A&gt; for
 details.
 &lt;p&gt;

 Each HttpURLConnection instance is used to make a single request
 but the underlying network connection to the HTTP server may be
 transparently shared by other instances. Calling the close() methods
 on the InputStream or OutputStream of an HttpURLConnection
 after a request may free network resources associated with this
 instance but has no effect on any shared persistent connection.
 Calling the disconnect() method may close the underlying socket
 if a persistent connection is otherwise idle at that time.</description>
			<attribute name="@see">
				<description>java.net.HttpURLConnection#disconnect()</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.1</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="protected" name="method" fulltype="java.lang.String" type="String">
				<comment>
					<description>The HTTP method (GET,POST,PUT,etc.).</description>
				</comment>
			</field>
			<field visibility="protected" name="chunkLength" fulltype="int" type="int">
				<comment>
					<description>The chunk-length when using chunked encoding streaming mode for output.
 A value of &lt;code&gt;-1&lt;/code&gt; means chunked encoding is disabled for output.</description>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
			</field>
			<field visibility="protected" name="fixedContentLength" fulltype="int" type="int">
				<comment>
					<description>The fixed content-length when using fixed-length streaming mode.
 A value of &lt;code&gt;-1&lt;/code&gt; means fixed-length streaming mode is disabled
 for output.</description>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
			</field>
			<field final="true" static="true" const="4096" visibility="private" name="DEFAULT_CHUNK_SIZE" constexpr="4096" fulltype="int" type="int" />
			<field visibility="protected" name="responseCode" fulltype="int" type="int">
				<comment>
					<description>An &lt;code&gt;int&lt;/code&gt; representing the three digit HTTP Status-Code.
 &lt;ul&gt;
 &lt;li&gt; 1xx: Informational
 &lt;li&gt; 2xx: Success
 &lt;li&gt; 3xx: Redirection
 &lt;li&gt; 4xx: Client Error
 &lt;li&gt; 5xx: Server Error
 &lt;/ul&gt;</description>
				</comment>
			</field>
			<field visibility="protected" name="responseMessage" fulltype="java.lang.String" type="String">
				<comment>
					<description>The HTTP response message.</description>
				</comment>
			</field>
			<field static="true" visibility="private" name="followRedirects" fulltype="boolean" type="boolean" />
			<field visibility="protected" name="instanceFollowRedirects" fulltype="boolean" type="boolean">
				<comment>
					<description>If &lt;code&gt;true&lt;/code&gt;, the protocol will automatically follow redirects.
 If &lt;code&gt;false&lt;/code&gt;, the protocol will not automatically follow
 redirects.
 &lt;p&gt;
 This field is set by the &lt;code&gt;setInstanceFollowRedirects&lt;/code&gt;
 method. Its value is returned by the &lt;code&gt;getInstanceFollowRedirects&lt;/code&gt;
 method.
 &lt;p&gt;
 Its default value is based on the value of the static followRedirects
 at HttpURLConnection construction time.</description>
					<attribute name="@see">
						<description>java.net.HttpURLConnection#setInstanceFollowRedirects(boolean)</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.HttpURLConnection#getInstanceFollowRedirects()</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.HttpURLConnection#setFollowRedirects(boolean)</description>
					</attribute>
				</comment>
			</field>
			<field final="true" static="true" visibility="private" name="methods" fulltype="java.lang.String[]" type="String" />
			<field final="true" static="true" const="200" visibility="public" name="HTTP_OK" constexpr="200" fulltype="int" type="int">
				<comment>
					<description>HTTP Status-Code 200: OK.</description>
				</comment>
			</field>
			<field final="true" static="true" const="201" visibility="public" name="HTTP_CREATED" constexpr="201" fulltype="int" type="int">
				<comment>
					<description>HTTP Status-Code 201: Created.</description>
				</comment>
			</field>
			<field final="true" static="true" const="202" visibility="public" name="HTTP_ACCEPTED" constexpr="202" fulltype="int" type="int">
				<comment>
					<description>HTTP Status-Code 202: Accepted.</description>
				</comment>
			</field>
			<field final="true" static="true" const="203" visibility="public" name="HTTP_NOT_AUTHORITATIVE" constexpr="203" fulltype="int" type="int">
				<comment>
					<description>HTTP Status-Code 203: Non-Authoritative Information.</description>
				</comment>
			</field>
			<field final="true" static="true" const="204" visibility="public" name="HTTP_NO_CONTENT" constexpr="204" fulltype="int" type="int">
				<comment>
					<description>HTTP Status-Code 204: No Content.</description>
				</comment>
			</field>
			<field final="true" static="true" const="205" visibility="public" name="HTTP_RESET" constexpr="205" fulltype="int" type="int">
				<comment>
					<description>HTTP Status-Code 205: Reset Content.</description>
				</comment>
			</field>
			<field final="true" static="true" const="206" visibility="public" name="HTTP_PARTIAL" constexpr="206" fulltype="int" type="int">
				<comment>
					<description>HTTP Status-Code 206: Partial Content.</description>
				</comment>
			</field>
			<field final="true" static="true" const="300" visibility="public" name="HTTP_MULT_CHOICE" constexpr="300" fulltype="int" type="int">
				<comment>
					<description>HTTP Status-Code 300: Multiple Choices.</description>
				</comment>
			</field>
			<field final="true" static="true" const="301" visibility="public" name="HTTP_MOVED_PERM" constexpr="301" fulltype="int" type="int">
				<comment>
					<description>HTTP Status-Code 301: Moved Permanently.</description>
				</comment>
			</field>
			<field final="true" static="true" const="302" visibility="public" name="HTTP_MOVED_TEMP" constexpr="302" fulltype="int" type="int">
				<comment>
					<description>HTTP Status-Code 302: Temporary Redirect.</description>
				</comment>
			</field>
			<field final="true" static="true" const="303" visibility="public" name="HTTP_SEE_OTHER" constexpr="303" fulltype="int" type="int">
				<comment>
					<description>HTTP Status-Code 303: See Other.</description>
				</comment>
			</field>
			<field final="true" static="true" const="304" visibility="public" name="HTTP_NOT_MODIFIED" constexpr="304" fulltype="int" type="int">
				<comment>
					<description>HTTP Status-Code 304: Not Modified.</description>
				</comment>
			</field>
			<field final="true" static="true" const="305" visibility="public" name="HTTP_USE_PROXY" constexpr="305" fulltype="int" type="int">
				<comment>
					<description>HTTP Status-Code 305: Use Proxy.</description>
				</comment>
			</field>
			<field final="true" static="true" const="400" visibility="public" name="HTTP_BAD_REQUEST" constexpr="400" fulltype="int" type="int">
				<comment>
					<description>HTTP Status-Code 400: Bad Request.</description>
				</comment>
			</field>
			<field final="true" static="true" const="401" visibility="public" name="HTTP_UNAUTHORIZED" constexpr="401" fulltype="int" type="int">
				<comment>
					<description>HTTP Status-Code 401: Unauthorized.</description>
				</comment>
			</field>
			<field final="true" static="true" const="402" visibility="public" name="HTTP_PAYMENT_REQUIRED" constexpr="402" fulltype="int" type="int">
				<comment>
					<description>HTTP Status-Code 402: Payment Required.</description>
				</comment>
			</field>
			<field final="true" static="true" const="403" visibility="public" name="HTTP_FORBIDDEN" constexpr="403" fulltype="int" type="int">
				<comment>
					<description>HTTP Status-Code 403: Forbidden.</description>
				</comment>
			</field>
			<field final="true" static="true" const="404" visibility="public" name="HTTP_NOT_FOUND" constexpr="404" fulltype="int" type="int">
				<comment>
					<description>HTTP Status-Code 404: Not Found.</description>
				</comment>
			</field>
			<field final="true" static="true" const="405" visibility="public" name="HTTP_BAD_METHOD" constexpr="405" fulltype="int" type="int">
				<comment>
					<description>HTTP Status-Code 405: Method Not Allowed.</description>
				</comment>
			</field>
			<field final="true" static="true" const="406" visibility="public" name="HTTP_NOT_ACCEPTABLE" constexpr="406" fulltype="int" type="int">
				<comment>
					<description>HTTP Status-Code 406: Not Acceptable.</description>
				</comment>
			</field>
			<field final="true" static="true" const="407" visibility="public" name="HTTP_PROXY_AUTH" constexpr="407" fulltype="int" type="int">
				<comment>
					<description>HTTP Status-Code 407: Proxy Authentication Required.</description>
				</comment>
			</field>
			<field final="true" static="true" const="408" visibility="public" name="HTTP_CLIENT_TIMEOUT" constexpr="408" fulltype="int" type="int">
				<comment>
					<description>HTTP Status-Code 408: Request Time-Out.</description>
				</comment>
			</field>
			<field final="true" static="true" const="409" visibility="public" name="HTTP_CONFLICT" constexpr="409" fulltype="int" type="int">
				<comment>
					<description>HTTP Status-Code 409: Conflict.</description>
				</comment>
			</field>
			<field final="true" static="true" const="410" visibility="public" name="HTTP_GONE" constexpr="410" fulltype="int" type="int">
				<comment>
					<description>HTTP Status-Code 410: Gone.</description>
				</comment>
			</field>
			<field final="true" static="true" const="411" visibility="public" name="HTTP_LENGTH_REQUIRED" constexpr="411" fulltype="int" type="int">
				<comment>
					<description>HTTP Status-Code 411: Length Required.</description>
				</comment>
			</field>
			<field final="true" static="true" const="412" visibility="public" name="HTTP_PRECON_FAILED" constexpr="412" fulltype="int" type="int">
				<comment>
					<description>HTTP Status-Code 412: Precondition Failed.</description>
				</comment>
			</field>
			<field final="true" static="true" const="413" visibility="public" name="HTTP_ENTITY_TOO_LARGE" constexpr="413" fulltype="int" type="int">
				<comment>
					<description>HTTP Status-Code 413: Request Entity Too Large.</description>
				</comment>
			</field>
			<field final="true" static="true" const="414" visibility="public" name="HTTP_REQ_TOO_LONG" constexpr="414" fulltype="int" type="int">
				<comment>
					<description>HTTP Status-Code 414: Request-URI Too Large.</description>
				</comment>
			</field>
			<field final="true" static="true" const="415" visibility="public" name="HTTP_UNSUPPORTED_TYPE" constexpr="415" fulltype="int" type="int">
				<comment>
					<description>HTTP Status-Code 415: Unsupported Media Type.</description>
				</comment>
			</field>
			<field final="true" static="true" const="500" visibility="public" name="HTTP_SERVER_ERROR" constexpr="500" fulltype="int" type="int">
				<comment>
					<description>HTTP Status-Code 500: Internal Server Error.</description>
					<attribute name="@deprecated">
						<description>it is misplaced and shouldn&apos;t have existed.</description>
					</attribute>
				</comment>
			</field>
			<field final="true" static="true" const="500" visibility="public" name="HTTP_INTERNAL_ERROR" constexpr="500" fulltype="int" type="int">
				<comment>
					<description>HTTP Status-Code 500: Internal Server Error.</description>
				</comment>
			</field>
			<field final="true" static="true" const="501" visibility="public" name="HTTP_NOT_IMPLEMENTED" constexpr="501" fulltype="int" type="int">
				<comment>
					<description>HTTP Status-Code 501: Not Implemented.</description>
				</comment>
			</field>
			<field final="true" static="true" const="502" visibility="public" name="HTTP_BAD_GATEWAY" constexpr="502" fulltype="int" type="int">
				<comment>
					<description>HTTP Status-Code 502: Bad Gateway.</description>
				</comment>
			</field>
			<field final="true" static="true" const="503" visibility="public" name="HTTP_UNAVAILABLE" constexpr="503" fulltype="int" type="int">
				<comment>
					<description>HTTP Status-Code 503: Service Unavailable.</description>
				</comment>
			</field>
			<field final="true" static="true" const="504" visibility="public" name="HTTP_GATEWAY_TIMEOUT" constexpr="504" fulltype="int" type="int">
				<comment>
					<description>HTTP Status-Code 504: Gateway Timeout.</description>
				</comment>
			</field>
			<field final="true" static="true" const="505" visibility="public" name="HTTP_VERSION" constexpr="505" fulltype="int" type="int">
				<comment>
					<description>HTTP Status-Code 505: HTTP Version Not Supported.</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="protected" name="HttpURLConnection">
				<comment>
					<description>Constructor for the HttpURLConnection.</description>
					<attribute name="@param">
						<description>u the URL</description>
					</attribute>
				</comment>
				<params>
					<param name="u" comment="the URL" fulltype="java.net.URL" type="URL" />
				</params>
			</constructor>
			<method visibility="public" name="getHeaderFieldKey" returncomment="the key for the &lt;code&gt;n&lt;/code&gt;&lt;sup&gt;th&lt;/sup&gt; header field,
          or &lt;code&gt;null&lt;/code&gt; if the key does not exist." fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the key for the &lt;code&gt;n&lt;/code&gt;&lt;sup&gt;th&lt;/sup&gt; header field.
 Some implementations may treat the &lt;code&gt;0&lt;/code&gt;&lt;sup&gt;th&lt;/sup&gt;
 header field as special, i.e. as the status line returned by the HTTP
 server. In this case, {@link #getHeaderField(int) getHeaderField(0)} returns the status
 line, but &lt;code&gt;getHeaderFieldKey(0)&lt;/code&gt; returns null.</description>
					<attribute name="@param">
						<description>n   an index, where n &gt;=0.</description>
					</attribute>
					<attribute name="@return">
						<description>the key for the &lt;code&gt;n&lt;/code&gt;&lt;sup&gt;th&lt;/sup&gt; header field,
          or &lt;code&gt;null&lt;/code&gt; if the key does not exist.</description>
					</attribute>
				</comment>
				<params>
					<param name="n" comment="an index, where n &gt;=0." fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="setFixedLengthStreamingMode" fulltype="void" type="void">
				<comment>
					<description>This method is used to enable streaming of a HTTP request body
 without internal buffering, when the content length is known in
 advance.
 &lt;p&gt;
 An exception will be thrown if the application
 attempts to write more data than the indicated
 content-length, or if the application closes the OutputStream
 before writing the indicated amount.
 &lt;p&gt;
 When output streaming is enabled, authentication
 and redirection cannot be handled automatically.
 A HttpRetryException will be thrown when reading
 the response if authentication or redirection are required.
 This exception can be queried for the details of the error.
 &lt;p&gt;
 This method must be called before the URLConnection is connected.</description>
					<attribute name="@param">
						<description>contentLength The number of bytes which will be written
          to the OutputStream.</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalStateException if URLConnection is already connected
          or if a different streaming mode is already enabled.</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if a content length less than
          zero is specified.</description>
					</attribute>
					<attribute name="@see">
						<description>#setChunkedStreamingMode(int)</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
				<params>
					<param name="contentLength" comment="The number of bytes which will be written
          to the OutputStream." fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="setChunkedStreamingMode" fulltype="void" type="void">
				<comment>
					<description>This method is used to enable streaming of a HTTP request body
 without internal buffering, when the content length is &lt;b&gt;not&lt;/b&gt;
 known in advance. In this mode, chunked transfer encoding
 is used to send the request body. Note, not all HTTP servers
 support this mode.
 &lt;p&gt;
 When output streaming is enabled, authentication
 and redirection cannot be handled automatically.
 A HttpRetryException will be thrown when reading
 the response if authentication or redirection are required.
 This exception can be queried for the details of the error.
 &lt;p&gt;
 This method must be called before the URLConnection is connected.</description>
					<attribute name="@param">
						<description>chunklen The number of bytes to write in each chunk.
          If chunklen is less than or equal to zero, a default
          value will be used.</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalStateException if URLConnection is already connected
          or if a different streaming mode is already enabled.</description>
					</attribute>
					<attribute name="@see">
						<description>#setFixedLengthStreamingMode(int)</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
				<params>
					<param name="chunklen" comment="The number of bytes to write in each chunk.
          If chunklen is less than or equal to zero, a default
          value will be used." fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="getHeaderField" returncomment="the value of the &lt;code&gt;n&lt;/code&gt;&lt;sup&gt;th&lt;/sup&gt; header field,
          or &lt;code&gt;null&lt;/code&gt; if the value does not exist." fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the value for the &lt;code&gt;n&lt;/code&gt;&lt;sup&gt;th&lt;/sup&gt; header field.
 Some implementations may treat the &lt;code&gt;0&lt;/code&gt;&lt;sup&gt;th&lt;/sup&gt;
 header field as special, i.e. as the status line returned by the HTTP
 server.
 &lt;p&gt;
 This method can be used in conjunction with the
 {@link #getHeaderFieldKey getHeaderFieldKey} method to iterate through all
 the headers in the message.</description>
					<attribute name="@param">
						<description>n   an index, where n&gt;=0.</description>
					</attribute>
					<attribute name="@return">
						<description>the value of the &lt;code&gt;n&lt;/code&gt;&lt;sup&gt;th&lt;/sup&gt; header field,
          or &lt;code&gt;null&lt;/code&gt; if the value does not exist.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.HttpURLConnection#getHeaderFieldKey(int)</description>
					</attribute>
				</comment>
				<params>
					<param name="n" comment="an index, where n&gt;=0." fulltype="int" type="int" />
				</params>
			</method>
			<method static="true" visibility="public" name="setFollowRedirects" fulltype="void" type="void">
				<comment>
					<description>Sets whether HTTP redirects  (requests with response code 3xx) should
 be automatically followed by this class.  True by default.  Applets
 cannot change this variable.
 &lt;p&gt;
 If there is a security manager, this method first calls
 the security manager&apos;s &lt;code&gt;checkSetFactory&lt;/code&gt; method
 to ensure the operation is allowed.
 This could result in a SecurityException.</description>
					<attribute name="@param">
						<description>set a &lt;code&gt;boolean&lt;/code&gt; indicating whether or not
 to follow HTTP redirects.</description>
					</attribute>
					<attribute name="@exception">
						<description>SecurityException  if a security manager exists and its
             &lt;code&gt;checkSetFactory&lt;/code&gt; method doesn&apos;t
             allow the operation.</description>
					</attribute>
					<attribute name="@see">
						<description>SecurityManager#checkSetFactory</description>
					</attribute>
					<attribute name="@see">
						<description>#getFollowRedirects()</description>
					</attribute>
				</comment>
				<params>
					<param name="set" comment="a &lt;code&gt;boolean&lt;/code&gt; indicating whether or not
 to follow HTTP redirects." fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method static="true" visibility="public" name="getFollowRedirects" returncomment="&lt;code&gt;true&lt;/code&gt; if HTTP redirects should
 be automatically followed, &lt;tt&gt;false&lt;/tt&gt; if not." fulltype="boolean" type="boolean">
				<comment>
					<description>Returns a &lt;code&gt;boolean&lt;/code&gt; indicating
 whether or not HTTP redirects (3xx) should
 be automatically followed.</description>
					<attribute name="@return">
						<description>&lt;code&gt;true&lt;/code&gt; if HTTP redirects should
 be automatically followed, &lt;tt&gt;false&lt;/tt&gt; if not.</description>
					</attribute>
					<attribute name="@see">
						<description>#setFollowRedirects(boolean)</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="setInstanceFollowRedirects" fulltype="void" type="void">
				<comment>
					<description>Sets whether HTTP redirects (requests with response code 3xx) should
 be automatically followed by this &lt;code&gt;HttpURLConnection&lt;/code&gt;
 instance.
 &lt;p&gt;
 The default value comes from followRedirects, which defaults to
 true.</description>
					<attribute name="@param">
						<description>followRedirects a &lt;code&gt;boolean&lt;/code&gt; indicating
 whether or not to follow HTTP redirects.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.HttpURLConnection#instanceFollowRedirects</description>
					</attribute>
					<attribute name="@see">
						<description>#getInstanceFollowRedirects</description>
					</attribute>
					<attribute name="@since">
						<description>1.3</description>
					</attribute>
				</comment>
				<params>
					<param name="followRedirects" comment="a &lt;code&gt;boolean&lt;/code&gt; indicating
 whether or not to follow HTTP redirects." fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method visibility="public" name="getInstanceFollowRedirects" returncomment="the value of this &lt;code&gt;HttpURLConnection&lt;/code&gt;&apos;s
          &lt;code&gt;instanceFollowRedirects&lt;/code&gt; field." fulltype="boolean" type="boolean">
				<comment>
					<description>Returns the value of this &lt;code&gt;HttpURLConnection&lt;/code&gt;&apos;s
 &lt;code&gt;instanceFollowRedirects&lt;/code&gt; field.</description>
					<attribute name="@return">
						<description>the value of this &lt;code&gt;HttpURLConnection&lt;/code&gt;&apos;s
          &lt;code&gt;instanceFollowRedirects&lt;/code&gt; field.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.HttpURLConnection#instanceFollowRedirects</description>
					</attribute>
					<attribute name="@see">
						<description>#setInstanceFollowRedirects(boolean)</description>
					</attribute>
					<attribute name="@since">
						<description>1.3</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="setRequestMethod" fulltype="void" type="void">
				<comment>
					<description>Set the method for the URL request, one of:
 &lt;UL&gt;
  &lt;LI&gt;GET
  &lt;LI&gt;POST
  &lt;LI&gt;HEAD
  &lt;LI&gt;OPTIONS
  &lt;LI&gt;PUT
  &lt;LI&gt;DELETE
  &lt;LI&gt;TRACE
 &lt;/UL&gt; are legal, subject to protocol restrictions.  The default
 method is GET.</description>
					<attribute name="@param">
						<description>method the HTTP method</description>
					</attribute>
					<attribute name="@exception">
						<description>ProtocolException if the method cannot be reset or if
              the requested method isn&apos;t valid for HTTP.</description>
					</attribute>
					<attribute name="@see">
						<description>#getRequestMethod()</description>
					</attribute>
				</comment>
				<params>
					<param name="method" comment="the HTTP method" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception comment="if the method cannot be reset or if
              the requested method isn&apos;t valid for HTTP." fulltype="java.net.ProtocolException" type="ProtocolException" />
				</exceptions>
			</method>
			<method visibility="public" name="getRequestMethod" returncomment="the HTTP request method" fulltype="java.lang.String" type="String">
				<comment>
					<description>Get the request method.</description>
					<attribute name="@return">
						<description>the HTTP request method</description>
					</attribute>
					<attribute name="@see">
						<description>#setRequestMethod(java.lang.String)</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getResponseCode" returncomment="the HTTP Status-Code, or -1" fulltype="int" type="int">
				<comment>
					<description>Gets the status code from an HTTP response message.
 For example, in the case of the following status lines:
 &lt;PRE&gt;
 HTTP/1.0 200 OK
 HTTP/1.0 401 Unauthorized
 &lt;/PRE&gt;
 It will return 200 and 401 respectively.
 Returns -1 if no code can be discerned
 from the response (i.e., the response is not valid HTTP).</description>
					<attribute name="@throws">
						<description>IOException if an error occurred connecting to the server.</description>
					</attribute>
					<attribute name="@return">
						<description>the HTTP Status-Code, or -1</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an error occurred connecting to the server." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="getResponseMessage" returncomment="the HTTP response message, or &lt;code&gt;null&lt;/code&gt;" fulltype="java.lang.String" type="String">
				<comment>
					<description>Gets the HTTP response message, if any, returned along with the
 response code from a server.  From responses like:
 &lt;PRE&gt;
 HTTP/1.0 200 OK
 HTTP/1.0 404 Not Found
 &lt;/PRE&gt;
 Extracts the Strings &quot;OK&quot; and &quot;Not Found&quot; respectively.
 Returns null if none could be discerned from the responses
 (the result was not valid HTTP).</description>
					<attribute name="@throws">
						<description>IOException if an error occurred connecting to the server.</description>
					</attribute>
					<attribute name="@return">
						<description>the HTTP response message, or &lt;code&gt;null&lt;/code&gt;</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an error occurred connecting to the server." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="getHeaderFieldDate" fulltype="long" type="long">
				<params>
					<param name="name" fulltype="java.lang.String" type="String" />
					<param name="Default" fulltype="long" type="long" />
				</params>
			</method>
			<method abstract="true" visibility="public" name="disconnect" fulltype="void" type="void">
				<comment>
					<description>Indicates that other requests to the server
 are unlikely in the near future. Calling disconnect()
 should not imply that this HttpURLConnection
 instance can be reused for other requests.</description>
				</comment>
			</method>
			<method abstract="true" visibility="public" name="usingProxy" returncomment="a boolean indicating if the connection is
 using a proxy." fulltype="boolean" type="boolean">
				<comment>
					<description>Indicates if the connection is going through a proxy.</description>
					<attribute name="@return">
						<description>a boolean indicating if the connection is
 using a proxy.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getPermission" fulltype="java.security.Permission" type="Permission">
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="getErrorStream" returncomment="an error stream if any, null if there have been no
 errors, the connection is not connected or the server sent no
 useful data." fulltype="java.io.InputStream" type="InputStream">
				<comment>
					<description>Returns the error stream if the connection failed
 but the server sent useful data nonetheless. The
 typical example is when an HTTP server responds
 with a 404, which will cause a FileNotFoundException
 to be thrown in connect, but the server sent an HTML
 help page with suggestions as to what to do.

 &lt;p&gt;This method will not cause a connection to be initiated.  If
 the connection was not connected, or if the server did not have
 an error while connecting or if the server had an error but
 no error data was sent, this method will return null. This is
 the default.</description>
					<attribute name="@return">
						<description>an error stream if any, null if there have been no
 errors, the connection is not connected or the server sent no
 useful data.</description>
					</attribute>
				</comment>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="SecureClassLoader" visibility="public" package="java.net" superclassfulltype="java.security.SecureClassLoader" fulltype="java.net.URLClassLoader" type="URLClassLoader">
		<comment>
			<description>This class loader is used to load classes and resources from a search
 path of URLs referring to both JAR files and directories. Any URL that
 ends with a &apos;/&apos; is assumed to refer to a directory. Otherwise, the URL
 is assumed to refer to a JAR file which will be opened as needed.
 &lt;p&gt;
 The AccessControlContext of the thread that created the instance of
 URLClassLoader will be used when subsequently loading classes and
 resources.
 &lt;p&gt;
 The classes that are loaded are by default granted permission only to
 access the URLs specified when the URLClassLoader was created.</description>
			<attribute name="@author">
				<description>David Connelly</description>
			</attribute>
			<attribute name="@since">
				<description>1.2</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="package-private" name="ucp" fulltype="sun.misc.URLClassPath" type="URLClassPath" />
			<field visibility="private" name="acc" fulltype="java.security.AccessControlContext" type="AccessControlContext" />
		</fields>
		<methods>
			<constructor visibility="public" name="URLClassLoader">
				<comment>
					<description>Constructs a new URLClassLoader for the given URLs. The URLs will be
 searched in the order specified for classes and resources after first
 searching in the specified parent class loader. Any URL that ends with
 a &apos;/&apos; is assumed to refer to a directory. Otherwise, the URL is assumed
 to refer to a JAR file which will be downloaded and opened as needed.

 &lt;p&gt;If there is a security manager, this method first
 calls the security manager&apos;s &lt;code&gt;checkCreateClassLoader&lt;/code&gt; method
 to ensure creation of a class loader is allowed.</description>
					<attribute name="@param">
						<description>urls the URLs from which to load classes and resources</description>
					</attribute>
					<attribute name="@param">
						<description>parent the parent class loader for delegation</description>
					</attribute>
					<attribute name="@exception">
						<description>SecurityException  if a security manager exists and its
             &lt;code&gt;checkCreateClassLoader&lt;/code&gt; method doesn&apos;t allow
             creation of a class loader.</description>
					</attribute>
					<attribute name="@see">
						<description>SecurityManager#checkCreateClassLoader</description>
					</attribute>
				</comment>
				<params>
					<param name="urls" comment="the URLs from which to load classes and resources" fulltype="java.net.URL[]" type="URL" />
					<param name="parent" comment="the parent class loader for delegation" fulltype="java.lang.ClassLoader" type="ClassLoader" />
				</params>
			</constructor>
			<constructor visibility="public" name="URLClassLoader">
				<comment>
					<description>Constructs a new URLClassLoader for the specified URLs using the
 default delegation parent &lt;code&gt;ClassLoader&lt;/code&gt;. The URLs will
 be searched in the order specified for classes and resources after
 first searching in the parent class loader. Any URL that ends with
 a &apos;/&apos; is assumed to refer to a directory. Otherwise, the URL is
 assumed to refer to a JAR file which will be downloaded and opened
 as needed.

 &lt;p&gt;If there is a security manager, this method first
 calls the security manager&apos;s &lt;code&gt;checkCreateClassLoader&lt;/code&gt; method
 to ensure creation of a class loader is allowed.</description>
					<attribute name="@param">
						<description>urls the URLs from which to load classes and resources</description>
					</attribute>
					<attribute name="@exception">
						<description>SecurityException  if a security manager exists and its
             &lt;code&gt;checkCreateClassLoader&lt;/code&gt; method doesn&apos;t allow
             creation of a class loader.</description>
					</attribute>
					<attribute name="@see">
						<description>SecurityManager#checkCreateClassLoader</description>
					</attribute>
				</comment>
				<params>
					<param name="urls" comment="the URLs from which to load classes and resources" fulltype="java.net.URL[]" type="URL" />
				</params>
			</constructor>
			<constructor visibility="public" name="URLClassLoader">
				<comment>
					<description>Constructs a new URLClassLoader for the specified URLs, parent
 class loader, and URLStreamHandlerFactory. The parent argument
 will be used as the parent class loader for delegation. The
 factory argument will be used as the stream handler factory to
 obtain protocol handlers when creating new jar URLs.

 &lt;p&gt;If there is a security manager, this method first
 calls the security manager&apos;s &lt;code&gt;checkCreateClassLoader&lt;/code&gt; method
 to ensure creation of a class loader is allowed.</description>
					<attribute name="@param">
						<description>urls the URLs from which to load classes and resources</description>
					</attribute>
					<attribute name="@param">
						<description>parent the parent class loader for delegation</description>
					</attribute>
					<attribute name="@param">
						<description>factory the URLStreamHandlerFactory to use when creating URLs</description>
					</attribute>
					<attribute name="@exception">
						<description>SecurityException  if a security manager exists and its
             &lt;code&gt;checkCreateClassLoader&lt;/code&gt; method doesn&apos;t allow
             creation of a class loader.</description>
					</attribute>
					<attribute name="@see">
						<description>SecurityManager#checkCreateClassLoader</description>
					</attribute>
				</comment>
				<params>
					<param name="urls" comment="the URLs from which to load classes and resources" fulltype="java.net.URL[]" type="URL" />
					<param name="parent" comment="the parent class loader for delegation" fulltype="java.lang.ClassLoader" type="ClassLoader" />
					<param name="factory" comment="the URLStreamHandlerFactory to use when creating URLs" fulltype="java.net.URLStreamHandlerFactory" type="URLStreamHandlerFactory" />
				</params>
			</constructor>
			<method visibility="protected" name="addURL" fulltype="void" type="void">
				<comment>
					<description>Appends the specified URL to the list of URLs to search for
 classes and resources.</description>
					<attribute name="@param">
						<description>url the URL to be added to the search path of URLs</description>
					</attribute>
				</comment>
				<params>
					<param name="url" comment="the URL to be added to the search path of URLs" fulltype="java.net.URL" type="URL" />
				</params>
			</method>
			<method visibility="public" name="getURLs" returncomment="the search path of URLs for loading classes and resources." fulltype="java.net.URL[]" type="URL">
				<comment>
					<description>Returns the search path of URLs for loading classes and resources.
 This includes the original list of URLs specified to the constructor,
 along with any URLs subsequently appended by the addURL() method.</description>
					<attribute name="@return">
						<description>the search path of URLs for loading classes and resources.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="protected" name="findClass" returncomment="the resulting class" fulltype="java.lang.Class" type="Class">
				<comment>
					<description>Finds and loads the class with the specified name from the URL search
 path. Any URLs referring to JAR files are loaded and opened as needed
 until the class is found.</description>
					<attribute name="@param">
						<description>name the name of the class</description>
					</attribute>
					<attribute name="@return">
						<description>the resulting class</description>
					</attribute>
					<attribute name="@exception">
						<description>ClassNotFoundException if the class could not be found</description>
					</attribute>
				</comment>
				<params>
					<param name="name" comment="the name of the class" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception comment="if the class could not be found" fulltype="java.lang.ClassNotFoundException" type="ClassNotFoundException" />
				</exceptions>
			</method>
			<method visibility="private" name="defineClass" fulltype="java.lang.Class" type="Class">
				<params>
					<param name="name" fulltype="java.lang.String" type="String" />
					<param name="res" fulltype="sun.misc.Resource" type="Resource" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="protected" name="definePackage" returncomment="the newly defined Package object" fulltype="java.lang.Package" type="Package">
				<comment>
					<description>Defines a new package by name in this ClassLoader. The attributes
 contained in the specified Manifest will be used to obtain package
 version and sealing information. For sealed packages, the additional
 URL specifies the code source URL from which the package was loaded.</description>
					<attribute name="@param">
						<description>name  the package name</description>
					</attribute>
					<attribute name="@param">
						<description>man   the Manifest containing package version and sealing
              information</description>
					</attribute>
					<attribute name="@param">
						<description>url   the code source url for the package, or null if none</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if the package name duplicates
              an existing package either in this class loader or one
              of its ancestors</description>
					</attribute>
					<attribute name="@return">
						<description>the newly defined Package object</description>
					</attribute>
				</comment>
				<params>
					<param name="name" comment="the package name" fulltype="java.lang.String" type="String" />
					<param name="man" comment="the Manifest containing package version and sealing
              information" fulltype="java.util.jar.Manifest" type="Manifest" />
					<param name="url" comment="the code source url for the package, or null if none" fulltype="java.net.URL" type="URL" />
				</params>
				<exceptions>
					<exception comment="if the package name duplicates
              an existing package either in this class loader or one
              of its ancestors" fulltype="java.lang.IllegalArgumentException" type="IllegalArgumentException" />
				</exceptions>
			</method>
			<method visibility="private" name="isSealed" fulltype="boolean" type="boolean">
				<params>
					<param name="name" fulltype="java.lang.String" type="String" />
					<param name="man" fulltype="java.util.jar.Manifest" type="Manifest" />
				</params>
			</method>
			<method visibility="public" name="findResource" returncomment="a &lt;code&gt;URL&lt;/code&gt; for the resource, or &lt;code&gt;null&lt;/code&gt;
 if the resource could not be found." fulltype="java.net.URL" type="URL">
				<comment>
					<description>Finds the resource with the specified name on the URL search path.</description>
					<attribute name="@param">
						<description>name the name of the resource</description>
					</attribute>
					<attribute name="@return">
						<description>a &lt;code&gt;URL&lt;/code&gt; for the resource, or &lt;code&gt;null&lt;/code&gt;
 if the resource could not be found.</description>
					</attribute>
				</comment>
				<params>
					<param name="name" comment="the name of the resource" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="public" name="findResources" returncomment="an &lt;code&gt;Enumeration&lt;/code&gt; of &lt;code&gt;URL&lt;/code&gt;s" fulltype="java.util.Enumeration" type="Enumeration">
				<comment>
					<description>Returns an Enumeration of URLs representing all of the resources
 on the URL search path having the specified name.</description>
					<attribute name="@param">
						<description>name the resource name</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException if an I/O exception occurs</description>
					</attribute>
					<attribute name="@return">
						<description>an &lt;code&gt;Enumeration&lt;/code&gt; of &lt;code&gt;URL&lt;/code&gt;s</description>
					</attribute>
				</comment>
				<params>
					<param name="name" comment="the resource name" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception comment="if an I/O exception occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="protected" name="getPermissions" returncomment="the permissions granted to the codesource" fulltype="java.security.PermissionCollection" type="PermissionCollection">
				<comment>
					<description>Returns the permissions for the given codesource object.
 The implementation of this method first calls super.getPermissions
 and then adds permissions based on the URL of the codesource.
 &lt;p&gt;
 If the protocol of this URL is &quot;jar&quot;, then the permission granted
 is based on the permission that is required by the URL of the Jar
 file.
 &lt;p&gt;
 If the protocol is &quot;file&quot;
 and the path specifies a file, then permission to read that
 file is granted. If protocol is &quot;file&quot; and the path is
 a directory, permission is granted to read all files
 and (recursively) all files and subdirectories contained in
 that directory.
 &lt;p&gt;
 If the protocol is not &quot;file&quot;, then permission
 to connect to and accept connections from the URL&apos;s host is granted.</description>
					<attribute name="@param">
						<description>codesource the codesource</description>
					</attribute>
					<attribute name="@return">
						<description>the permissions granted to the codesource</description>
					</attribute>
				</comment>
				<params>
					<param name="codesource" comment="the codesource" fulltype="java.security.CodeSource" type="CodeSource" />
				</params>
			</method>
			<method static="true" visibility="public" name="newInstance" returncomment="the resulting class loader" fulltype="java.net.URLClassLoader" type="URLClassLoader">
				<comment>
					<description>Creates a new instance of URLClassLoader for the specified
 URLs and parent class loader. If a security manager is
 installed, the &lt;code&gt;loadClass&lt;/code&gt; method of the URLClassLoader
 returned by this method will invoke the
 &lt;code&gt;SecurityManager.checkPackageAccess&lt;/code&gt; method before
 loading the class.</description>
					<attribute name="@param">
						<description>urls the URLs to search for classes and resources</description>
					</attribute>
					<attribute name="@param">
						<description>parent the parent class loader for delegation</description>
					</attribute>
					<attribute name="@return">
						<description>the resulting class loader</description>
					</attribute>
				</comment>
				<params>
					<param name="urls" comment="the URLs to search for classes and resources" fulltype="java.net.URL[]" type="URL" />
					<param name="parent" comment="the parent class loader for delegation" fulltype="java.lang.ClassLoader" type="ClassLoader" />
				</params>
			</method>
			<method static="true" visibility="public" name="newInstance" returncomment="the resulting class loader" fulltype="java.net.URLClassLoader" type="URLClassLoader">
				<comment>
					<description>Creates a new instance of URLClassLoader for the specified
 URLs and default parent class loader. If a security manager is
 installed, the &lt;code&gt;loadClass&lt;/code&gt; method of the URLClassLoader
 returned by this method will invoke the
 &lt;code&gt;SecurityManager.checkPackageAccess&lt;/code&gt; before
 loading the class.</description>
					<attribute name="@param">
						<description>urls the URLs to search for classes and resources</description>
					</attribute>
					<attribute name="@return">
						<description>the resulting class loader</description>
					</attribute>
				</comment>
				<params>
					<param name="urls" comment="the URLs to search for classes and resources" fulltype="java.net.URL[]" type="URL" />
				</params>
			</method>
		</methods>
	</jelclass>
	<jelclass final="true" superclass="URLClassLoader" visibility="package-private" package="java.net" superclassfulltype="java.net.URLClassLoader" fulltype="java.net.FactoryURLClassLoader" type="FactoryURLClassLoader">
		<methods>
			<constructor visibility="package-private" name="FactoryURLClassLoader">
				<params>
					<param name="urls" fulltype="java.net.URL[]" type="URL" />
					<param name="parent" fulltype="java.lang.ClassLoader" type="ClassLoader" />
				</params>
			</constructor>
			<constructor visibility="package-private" name="FactoryURLClassLoader">
				<params>
					<param name="urls" fulltype="java.net.URL[]" type="URL" />
				</params>
			</constructor>
			<method final="true" synchronized="true" visibility="public" name="loadClass" fulltype="java.lang.Class" type="Class">
				<params>
					<param name="name" fulltype="java.lang.String" type="String" />
					<param name="resolve" fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception fulltype="java.lang.ClassNotFoundException" type="ClassNotFoundException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="InterruptedIOException" visibility="public" package="java.net" serializable="true" superclassfulltype="java.io.InterruptedIOException" fulltype="java.net.SocketTimeoutException" type="SocketTimeoutException">
		<comment>
			<description>Signals that a timeout has occurred on a socket read or accept.</description>
			<attribute name="@since">
				<description>1.4</description>
			</attribute>
		</comment>
		<methods>
			<constructor visibility="public" name="SocketTimeoutException">
				<comment>
					<description>Constructs a new SocketTimeoutException with a detail
 message.</description>
					<attribute name="@param">
						<description>msg the detail message</description>
					</attribute>
				</comment>
				<params>
					<param name="msg" comment="the detail message" fulltype="java.lang.String" type="String" />
				</params>
			</constructor>
			<constructor visibility="public" name="SocketTimeoutException">
				<comment>
					<description>Construct a new SocketTimeoutException with no detailed message.</description>
				</comment>
			</constructor>
		</methods>
	</jelclass>
	<jelclass superclass="IOException" visibility="public" package="java.net" serializable="true" superclassfulltype="java.io.IOException" fulltype="java.net.UnknownHostException" type="UnknownHostException">
		<comment>
			<description>Thrown to indicate that the IP address of a host could not be determined.</description>
			<attribute name="@author">
				<description>Jonathan Payne</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.0</description>
			</attribute>
		</comment>
		<methods>
			<constructor visibility="public" name="UnknownHostException">
				<comment>
					<description>Constructs a new &lt;code&gt;UnknownHostException&lt;/code&gt; with the
 specified detail message.</description>
					<attribute name="@param">
						<description>host   the detail message.</description>
					</attribute>
				</comment>
				<params>
					<param name="host" comment="the detail message." fulltype="java.lang.String" type="String" />
				</params>
			</constructor>
			<constructor visibility="public" name="UnknownHostException">
				<comment>
					<description>Constructs a new &lt;code&gt;UnknownHostException&lt;/code&gt; with no detail
 message.</description>
				</comment>
			</constructor>
		</methods>
	</jelclass>
	<jelclass final="true" superclass="Object" visibility="public" package="java.net" superclassfulltype="java.lang.Object" fulltype="java.net.DatagramPacket" type="DatagramPacket">
		<comment>
			<description>This class represents a datagram packet.
 &lt;p&gt;
 Datagram packets are used to implement a connectionless packet
 delivery service. Each message is routed from one machine to
 another based solely on information contained within that packet.
 Multiple packets sent from one machine to another might be routed
 differently, and might arrive in any order. Packet delivery is
 not guaranteed.</description>
			<attribute name="@author">
				<description>Pavani Diwanji</description>
			</attribute>
			<attribute name="@author">
				<description>Benjamin Renaud</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.0</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="package-private" name="buf" fulltype="byte[]" type="byte" />
			<field visibility="package-private" name="offset" fulltype="int" type="int" />
			<field visibility="package-private" name="length" fulltype="int" type="int" />
			<field visibility="package-private" name="bufLength" fulltype="int" type="int" />
			<field visibility="package-private" name="address" fulltype="java.net.InetAddress" type="InetAddress" />
			<field visibility="package-private" name="port" fulltype="int" type="int" />
		</fields>
		<methods>
			<constructor visibility="public" name="DatagramPacket">
				<comment>
					<description>Constructs a &lt;code&gt;DatagramPacket&lt;/code&gt; for receiving packets of
 length &lt;code&gt;length&lt;/code&gt;, specifying an offset into the buffer.
 &lt;p&gt;
 The &lt;code&gt;length&lt;/code&gt; argument must be less than or equal to
 &lt;code&gt;buf.length&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>buf      buffer for holding the incoming datagram.</description>
					</attribute>
					<attribute name="@param">
						<description>offset   the offset for the buffer</description>
					</attribute>
					<attribute name="@param">
						<description>length   the number of bytes to read.</description>
					</attribute>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
				<params>
					<param name="buf" comment="buffer for holding the incoming datagram." fulltype="byte[]" type="byte" />
					<param name="offset" comment="the offset for the buffer" fulltype="int" type="int" />
					<param name="length" comment="the number of bytes to read." fulltype="int" type="int" />
				</params>
			</constructor>
			<constructor visibility="public" name="DatagramPacket">
				<comment>
					<description>Constructs a &lt;code&gt;DatagramPacket&lt;/code&gt; for receiving packets of
 length &lt;code&gt;length&lt;/code&gt;.
 &lt;p&gt;
 The &lt;code&gt;length&lt;/code&gt; argument must be less than or equal to
 &lt;code&gt;buf.length&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>buf      buffer for holding the incoming datagram.</description>
					</attribute>
					<attribute name="@param">
						<description>length   the number of bytes to read.</description>
					</attribute>
				</comment>
				<params>
					<param name="buf" comment="buffer for holding the incoming datagram." fulltype="byte[]" type="byte" />
					<param name="length" comment="the number of bytes to read." fulltype="int" type="int" />
				</params>
			</constructor>
			<constructor visibility="public" name="DatagramPacket">
				<comment>
					<description>Constructs a datagram packet for sending packets of length
 &lt;code&gt;length&lt;/code&gt; with offset &lt;code&gt;ioffset&lt;/code&gt;to the
 specified port number on the specified host. The
 &lt;code&gt;length&lt;/code&gt; argument must be less than or equal to
 &lt;code&gt;buf.length&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>buf      the packet data.</description>
					</attribute>
					<attribute name="@param">
						<description>offset   the packet data offset.</description>
					</attribute>
					<attribute name="@param">
						<description>length   the packet data length.</description>
					</attribute>
					<attribute name="@param">
						<description>address  the destination address.</description>
					</attribute>
					<attribute name="@param">
						<description>port     the destination port number.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.InetAddress</description>
					</attribute>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
				<params>
					<param name="buf" comment="the packet data." fulltype="byte[]" type="byte" />
					<param name="offset" comment="the packet data offset." fulltype="int" type="int" />
					<param name="length" comment="the packet data length." fulltype="int" type="int" />
					<param name="address" comment="the destination address." fulltype="java.net.InetAddress" type="InetAddress" />
					<param name="port" comment="the destination port number." fulltype="int" type="int" />
				</params>
			</constructor>
			<constructor visibility="public" name="DatagramPacket">
				<comment>
					<description>Constructs a datagram packet for sending packets of length
 &lt;code&gt;length&lt;/code&gt; with offset &lt;code&gt;ioffset&lt;/code&gt;to the
 specified port number on the specified host. The
 &lt;code&gt;length&lt;/code&gt; argument must be less than or equal to
 &lt;code&gt;buf.length&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>buf      the packet data.</description>
					</attribute>
					<attribute name="@param">
						<description>offset   the packet data offset.</description>
					</attribute>
					<attribute name="@param">
						<description>length   the packet data length.</description>
					</attribute>
					<attribute name="@param">
						<description>address  the destination socket address.</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if address type is not supported</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.InetAddress</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
				<params>
					<param name="buf" comment="the packet data." fulltype="byte[]" type="byte" />
					<param name="offset" comment="the packet data offset." fulltype="int" type="int" />
					<param name="length" comment="the packet data length." fulltype="int" type="int" />
					<param name="address" comment="the destination socket address." fulltype="java.net.SocketAddress" type="SocketAddress" />
				</params>
				<exceptions>
					<exception fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</constructor>
			<constructor visibility="public" name="DatagramPacket">
				<comment>
					<description>Constructs a datagram packet for sending packets of length
 &lt;code&gt;length&lt;/code&gt; to the specified port number on the specified
 host. The &lt;code&gt;length&lt;/code&gt; argument must be less than or equal
 to &lt;code&gt;buf.length&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>buf      the packet data.</description>
					</attribute>
					<attribute name="@param">
						<description>length   the packet length.</description>
					</attribute>
					<attribute name="@param">
						<description>address  the destination address.</description>
					</attribute>
					<attribute name="@param">
						<description>port     the destination port number.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.InetAddress</description>
					</attribute>
				</comment>
				<params>
					<param name="buf" comment="the packet data." fulltype="byte[]" type="byte" />
					<param name="length" comment="the packet length." fulltype="int" type="int" />
					<param name="address" comment="the destination address." fulltype="java.net.InetAddress" type="InetAddress" />
					<param name="port" comment="the destination port number." fulltype="int" type="int" />
				</params>
			</constructor>
			<constructor visibility="public" name="DatagramPacket">
				<comment>
					<description>Constructs a datagram packet for sending packets of length
 &lt;code&gt;length&lt;/code&gt; to the specified port number on the specified
 host. The &lt;code&gt;length&lt;/code&gt; argument must be less than or equal
 to &lt;code&gt;buf.length&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>buf      the packet data.</description>
					</attribute>
					<attribute name="@param">
						<description>length   the packet length.</description>
					</attribute>
					<attribute name="@param">
						<description>address  the destination address.</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if address type is not supported</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.InetAddress</description>
					</attribute>
				</comment>
				<params>
					<param name="buf" comment="the packet data." fulltype="byte[]" type="byte" />
					<param name="length" comment="the packet length." fulltype="int" type="int" />
					<param name="address" comment="the destination address." fulltype="java.net.SocketAddress" type="SocketAddress" />
				</params>
				<exceptions>
					<exception fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</constructor>
			<method synchronized="true" visibility="public" name="getAddress" returncomment="the IP address of the machine to which this datagram is being
          sent or from which the datagram was received." fulltype="java.net.InetAddress" type="InetAddress">
				<comment>
					<description>Returns the IP address of the machine to which this datagram is being
 sent or from which the datagram was received.</description>
					<attribute name="@return">
						<description>the IP address of the machine to which this datagram is being
          sent or from which the datagram was received.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.InetAddress</description>
					</attribute>
					<attribute name="@see">
						<description>#setAddress(java.net.InetAddress)</description>
					</attribute>
				</comment>
			</method>
			<method synchronized="true" visibility="public" name="getPort" returncomment="the port number on the remote host to which this datagram is
          being sent or from which the datagram was received." fulltype="int" type="int">
				<comment>
					<description>Returns the port number on the remote host to which this datagram is
 being sent or from which the datagram was received.</description>
					<attribute name="@return">
						<description>the port number on the remote host to which this datagram is
          being sent or from which the datagram was received.</description>
					</attribute>
					<attribute name="@see">
						<description>#setPort(int)</description>
					</attribute>
				</comment>
			</method>
			<method synchronized="true" visibility="public" name="getData" returncomment="the buffer used to receive or  send data" fulltype="byte[]" type="byte">
				<comment>
					<description>Returns the data buffer. The data received or the data to be sent
 starts from the &lt;code&gt;offset&lt;/code&gt; in the buffer,
 and runs for &lt;code&gt;length&lt;/code&gt; long.</description>
					<attribute name="@return">
						<description>the buffer used to receive or  send data</description>
					</attribute>
					<attribute name="@see">
						<description>#setData(byte[], int, int)</description>
					</attribute>
				</comment>
			</method>
			<method synchronized="true" visibility="public" name="getOffset" returncomment="the offset of the data to be sent or the offset of the
          data received." fulltype="int" type="int">
				<comment>
					<description>Returns the offset of the data to be sent or the offset of the
 data received.</description>
					<attribute name="@return">
						<description>the offset of the data to be sent or the offset of the
          data received.</description>
					</attribute>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
			</method>
			<method synchronized="true" visibility="public" name="getLength" returncomment="the length of the data to be sent or the length of the
          data received." fulltype="int" type="int">
				<comment>
					<description>Returns the length of the data to be sent or the length of the
 data received.</description>
					<attribute name="@return">
						<description>the length of the data to be sent or the length of the
          data received.</description>
					</attribute>
					<attribute name="@see">
						<description>#setLength(int)</description>
					</attribute>
				</comment>
			</method>
			<method synchronized="true" visibility="public" name="setData" fulltype="void" type="void">
				<comment>
					<description>Set the data buffer for this packet. This sets the
 data, length and offset of the packet.</description>
					<attribute name="@param">
						<description>buf the buffer to set for this packet</description>
					</attribute>
					<attribute name="@param">
						<description>offset the offset into the data</description>
					</attribute>
					<attribute name="@param">
						<description>length the length of the data
       and/or the length of the buffer used to receive data</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if the argument is null</description>
					</attribute>
					<attribute name="@see">
						<description>#getData</description>
					</attribute>
					<attribute name="@see">
						<description>#getOffset</description>
					</attribute>
					<attribute name="@see">
						<description>#getLength</description>
					</attribute>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
				<params>
					<param name="buf" comment="the buffer to set for this packet" fulltype="byte[]" type="byte" />
					<param name="offset" comment="the offset into the data" fulltype="int" type="int" />
					<param name="length" comment="the length of the data
       and/or the length of the buffer used to receive data" fulltype="int" type="int" />
				</params>
			</method>
			<method synchronized="true" visibility="public" name="setAddress" fulltype="void" type="void">
				<comment>
					<description>Sets the IP address of the machine to which this datagram
 is being sent.</description>
					<attribute name="@param">
						<description>iaddr the &lt;code&gt;InetAddress&lt;/code&gt;</description>
					</attribute>
					<attribute name="@since">
						<description>JDK1.1</description>
					</attribute>
					<attribute name="@see">
						<description>#getAddress()</description>
					</attribute>
				</comment>
				<params>
					<param name="iaddr" comment="the &lt;code&gt;InetAddress&lt;/code&gt;" fulltype="java.net.InetAddress" type="InetAddress" />
				</params>
			</method>
			<method synchronized="true" visibility="public" name="setPort" fulltype="void" type="void">
				<comment>
					<description>Sets the port number on the remote host to which this datagram
 is being sent.</description>
					<attribute name="@param">
						<description>iport the port number</description>
					</attribute>
					<attribute name="@since">
						<description>JDK1.1</description>
					</attribute>
					<attribute name="@see">
						<description>#getPort()</description>
					</attribute>
				</comment>
				<params>
					<param name="iport" comment="the port number" fulltype="int" type="int" />
				</params>
			</method>
			<method synchronized="true" visibility="public" name="setSocketAddress" fulltype="void" type="void">
				<comment>
					<description>Sets the SocketAddress (usually IP address + port number) of the remote
 host to which this datagram is being sent.</description>
					<attribute name="@param">
						<description>address the &lt;code&gt;SocketAddress&lt;/code&gt;</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if address is null or is a
          SocketAddress subclass not supported by this socket</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
					<attribute name="@see">
						<description>#getSocketAddress</description>
					</attribute>
				</comment>
				<params>
					<param name="address" comment="the &lt;code&gt;SocketAddress&lt;/code&gt;" fulltype="java.net.SocketAddress" type="SocketAddress" />
				</params>
			</method>
			<method synchronized="true" visibility="public" name="getSocketAddress" returncomment="the &lt;code&gt;SocketAddress&lt;/code&gt;" fulltype="java.net.SocketAddress" type="SocketAddress">
				<comment>
					<description>Gets the SocketAddress (usually IP address + port number) of the remote
 host that this packet is being sent to or is coming from.</description>
					<attribute name="@return">
						<description>the &lt;code&gt;SocketAddress&lt;/code&gt;</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
					<attribute name="@see">
						<description>#setSocketAddress</description>
					</attribute>
				</comment>
			</method>
			<method synchronized="true" visibility="public" name="setData" fulltype="void" type="void">
				<comment>
					<description>Set the data buffer for this packet. With the offset of
 this DatagramPacket set to 0, and the length set to
 the length of &lt;code&gt;buf&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>buf the buffer to set for this packet.</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException if the argument is null.</description>
					</attribute>
					<attribute name="@see">
						<description>#getLength</description>
					</attribute>
					<attribute name="@see">
						<description>#getData</description>
					</attribute>
					<attribute name="@since">
						<description>JDK1.1</description>
					</attribute>
				</comment>
				<params>
					<param name="buf" comment="the buffer to set for this packet." fulltype="byte[]" type="byte" />
				</params>
			</method>
			<method synchronized="true" visibility="public" name="setLength" fulltype="void" type="void">
				<comment>
					<description>Set the length for this packet. The length of the packet is
 the number of bytes from the packet&apos;s data buffer that will be
 sent, or the number of bytes of the packet&apos;s data buffer that
 will be used for receiving data. The length must be lesser or
 equal to the offset plus the length of the packet&apos;s buffer.</description>
					<attribute name="@param">
						<description>length the length to set for this packet.</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if the length is negative
 of if the length is greater than the packet&apos;s data buffer
 length.</description>
					</attribute>
					<attribute name="@see">
						<description>#getLength</description>
					</attribute>
					<attribute name="@see">
						<description>#setData</description>
					</attribute>
					<attribute name="@since">
						<description>JDK1.1</description>
					</attribute>
				</comment>
				<params>
					<param name="length" comment="the length to set for this packet." fulltype="int" type="int" />
				</params>
			</method>
			<method static="true" visibility="private" name="init" fulltype="void" type="void">
				<comment>
					<description>Perform class load-time initializations.</description>
				</comment>
			</method>
		</methods>
	</jelclass>
	<jelclass abstract="true" visibility="public" package="java.net" interface="true" fulltype="java.net.CookieStore" type="CookieStore">
		<comment>
			<description>A CookieStore object represents a storage for cookie. Can store and retrieve
 cookies.

 &lt;p&gt;{@link CookieManager} will call &lt;tt&gt;CookieStore.add&lt;/tt&gt; to save cookies
 for every incoming HTTP response, and call &lt;tt&gt;CookieStore.get&lt;/tt&gt; to
 retrieve cookie for every outgoing HTTP request. A CookieStore
 is responsible for removing HttpCookie instances which have expired.</description>
			<attribute name="@author">
				<description>Edward Wang</description>
			</attribute>
			<attribute name="@since">
				<description>1.6</description>
			</attribute>
		</comment>
		<methods>
			<method visibility="public" name="add" fulltype="void" type="void">
				<comment>
					<description>Adds one HTTP cookie to the store. This is called for every
 incoming HTTP response.

 &lt;p&gt;A cookie to store may or may not be associated with an URI. If it
 is not associated with an URI, the cookie&apos;s domain and path attribute
 will indicate where it comes from. If it is associated with an URI and
 its domain and path attribute are not speicifed, given URI will indicate
 where this cookie comes from.

 &lt;p&gt;If a cookie corresponding to the given URI already exists,
 then it is replaced with the new one.</description>
					<attribute name="@param">
						<description>uri       the uri this cookie associated with.
                  if &lt;tt&gt;null&lt;/tt&gt;, this cookie will not be associated
                  with an URI</description>
					</attribute>
					<attribute name="@param">
						<description>cookie    the cookie to store</description>
					</attribute>
					<attribute name="@throws">
						<description>NullPointerException if &lt;tt&gt;cookie&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;</description>
					</attribute>
					<attribute name="@see">
						<description>#get</description>
					</attribute>
				</comment>
				<params>
					<param name="uri" comment="the uri this cookie associated with.
                  if &lt;tt&gt;null&lt;/tt&gt;, this cookie will not be associated
                  with an URI" fulltype="java.net.URI" type="URI" />
					<param name="cookie" comment="the cookie to store" fulltype="java.net.HttpCookie" type="HttpCookie" />
				</params>
			</method>
			<method visibility="public" name="get" returncomment="an immutable list of HttpCookie,
                  return empty list if no cookies match the given URI" fulltype="java.util.List" type="List">
				<comment>
					<description>Retrieve cookies associated with given URI, or whose domain matches the
 given URI. Only cookies that have not expired are returned.
 This is called for every outgoing HTTP request.</description>
					<attribute name="@return">
						<description>an immutable list of HttpCookie,
                  return empty list if no cookies match the given URI</description>
					</attribute>
					<attribute name="@throws">
						<description>NullPointerException if &lt;tt&gt;uri&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;</description>
					</attribute>
					<attribute name="@see">
						<description>#add</description>
					</attribute>
				</comment>
				<params>
					<param name="uri" fulltype="java.net.URI" type="URI" />
				</params>
			</method>
			<method visibility="public" name="getCookies" returncomment="an immutable list of http cookies;
                  return empty list if there&apos;s no http cookie in store" fulltype="java.util.List" type="List">
				<comment>
					<description>Get all not-expired cookies in cookie store.</description>
					<attribute name="@return">
						<description>an immutable list of http cookies;
                  return empty list if there&apos;s no http cookie in store</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getURIs" returncomment="an immutable list of URIs;
                  return empty list if no cookie in this cookie store
                  is associated with an URI" fulltype="java.util.List" type="List">
				<comment>
					<description>Get all URIs which identify the cookies in this cookie store.</description>
					<attribute name="@return">
						<description>an immutable list of URIs;
                  return empty list if no cookie in this cookie store
                  is associated with an URI</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="remove" returncomment="&lt;tt&gt;true&lt;/tt&gt; if this store contained the specified cookie" fulltype="boolean" type="boolean">
				<comment>
					<description>Remove a cookie from store.</description>
					<attribute name="@param">
						<description>uri       the uri this cookie associated with.
                  if &lt;tt&gt;null&lt;/tt&gt;, the cookie to be removed is not associated
                  with an URI when added; if not &lt;tt&gt;null&lt;/tt&gt;, the cookie
                  to be removed is associated with the given URI when added.</description>
					</attribute>
					<attribute name="@param">
						<description>cookie    the cookie to remove</description>
					</attribute>
					<attribute name="@return">
						<description>&lt;tt&gt;true&lt;/tt&gt; if this store contained the specified cookie</description>
					</attribute>
					<attribute name="@throws">
						<description>NullPointerException if &lt;tt&gt;cookie&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;</description>
					</attribute>
				</comment>
				<params>
					<param name="uri" comment="the uri this cookie associated with.
                  if &lt;tt&gt;null&lt;/tt&gt;, the cookie to be removed is not associated
                  with an URI when added; if not &lt;tt&gt;null&lt;/tt&gt;, the cookie
                  to be removed is associated with the given URI when added." fulltype="java.net.URI" type="URI" />
					<param name="cookie" comment="the cookie to remove" fulltype="java.net.HttpCookie" type="HttpCookie" />
				</params>
			</method>
			<method visibility="public" name="removeAll" returncomment="&lt;tt&gt;true&lt;/tt&gt; if this store changed as a result of the call" fulltype="boolean" type="boolean">
				<comment>
					<description>Remove all cookies in this cookie store.</description>
					<attribute name="@return">
						<description>&lt;tt&gt;true&lt;/tt&gt; if this store changed as a result of the call</description>
					</attribute>
				</comment>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="Object" visibility="public" package="java.net" superclassfulltype="java.lang.Object" fulltype="java.net.Socket" type="Socket">
		<comment>
			<description>This class implements client sockets (also called just
 &quot;sockets&quot;). A socket is an endpoint for communication
 between two machines.
 &lt;p&gt;
 The actual work of the socket is performed by an instance of the
 &lt;code&gt;SocketImpl&lt;/code&gt; class. An application, by changing
 the socket factory that creates the socket implementation,
 can configure itself to create sockets appropriate to the local
 firewall.</description>
			<attribute name="@author">
				<description>unascribed</description>
			</attribute>
			<attribute name="@see">
				<description>java.net.Socket#setSocketImplFactory(java.net.SocketImplFactory)</description>
			</attribute>
			<attribute name="@see">
				<description>java.net.SocketImpl</description>
			</attribute>
			<attribute name="@see">
				<description>java.nio.channels.SocketChannel</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.0</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="private" name="created" fulltype="boolean" type="boolean">
				<comment>
					<description>Various states of this socket.</description>
				</comment>
			</field>
			<field visibility="private" name="bound" fulltype="boolean" type="boolean" />
			<field visibility="private" name="connected" fulltype="boolean" type="boolean" />
			<field visibility="private" name="closed" fulltype="boolean" type="boolean" />
			<field visibility="private" name="closeLock" fulltype="java.lang.Object" type="Object" />
			<field visibility="private" name="shutIn" fulltype="boolean" type="boolean" />
			<field visibility="private" name="shutOut" fulltype="boolean" type="boolean" />
			<field visibility="package-private" name="impl" fulltype="java.net.SocketImpl" type="SocketImpl">
				<comment>
					<description>The implementation of this Socket.</description>
				</comment>
			</field>
			<field visibility="private" name="oldImpl" fulltype="boolean" type="boolean">
				<comment>
					<description>Are we using an older SocketImpl?</description>
				</comment>
			</field>
			<field static="true" visibility="private" name="factory" fulltype="java.net.SocketImplFactory" type="SocketImplFactory">
				<comment>
					<description>The factory for all client sockets.</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="public" name="Socket">
				<comment>
					<description>Creates an unconnected socket, with the
 system-default type of SocketImpl.</description>
					<attribute name="@since">
						<description>JDK1.1</description>
					</attribute>
					<attribute name="@revised">
						<description>1.4</description>
					</attribute>
				</comment>
			</constructor>
			<constructor visibility="public" name="Socket">
				<comment>
					<description>Creates an unconnected socket, specifying the type of proxy, if any,
 that should be used regardless of any other settings.
 &lt;P&gt;
 If there is a security manager, its &lt;code&gt;checkConnect&lt;/code&gt; method
 is called with the proxy host address and port number
 as its arguments. This could result in a SecurityException.
 &lt;P&gt;
 Examples:
 &lt;UL&gt; &lt;LI&gt;&lt;code&gt;Socket s = new Socket(Proxy.NO_PROXY);&lt;/code&gt; will create
 a plain socket ignoring any other proxy configuration.&lt;/LI&gt;
 &lt;LI&gt;&lt;code&gt;Socket s = new Socket(new Proxy(Proxy.Type.SOCKS, new InetSocketAddress(&quot;socks.mydom.com&quot;, 1080)));&lt;/code&gt;
 will create a socket connecting through the specified SOCKS proxy
 server.&lt;/LI&gt;
 &lt;/UL&gt;</description>
					<attribute name="@param">
						<description>proxy a {@link java.net.Proxy Proxy} object specifying what kind
              of proxying should be used.</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if the proxy is of an invalid type
          or &lt;code&gt;null&lt;/code&gt;.</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException if a security manager is present and
                           permission to connect to the proxy is
                           denied.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.ProxySelector</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.Proxy</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
				<params>
					<param name="proxy" comment="a {@link java.net.Proxy Proxy} object specifying what kind
              of proxying should be used." fulltype="java.net.Proxy" type="Proxy" />
				</params>
			</constructor>
			<constructor visibility="protected" name="Socket">
				<comment>
					<description>Creates an unconnected Socket with a user-specified
 SocketImpl.
 &lt;P&gt;</description>
					<attribute name="@param">
						<description>impl an instance of a &lt;B&gt;SocketImpl&lt;/B&gt;
 the subclass wishes to use on the Socket.</description>
					</attribute>
					<attribute name="@exception">
						<description>SocketException if there is an error in the underlying protocol,
 such as a TCP error.</description>
					</attribute>
					<attribute name="@since">
						<description>JDK1.1</description>
					</attribute>
				</comment>
				<params>
					<param name="impl" comment="an instance of a &lt;B&gt;SocketImpl&lt;/B&gt;
 the subclass wishes to use on the Socket." fulltype="java.net.SocketImpl" type="SocketImpl" />
				</params>
				<exceptions>
					<exception comment="if there is an error in the underlying protocol,
 such as a TCP error." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</constructor>
			<constructor visibility="public" name="Socket">
				<comment>
					<description>Creates a stream socket and connects it to the specified port
 number on the named host.
 &lt;p&gt;
 If the specified host is &lt;tt&gt;null&lt;/tt&gt; it is the equivalent of
 specifying the address as &lt;tt&gt;{@link java.net.InetAddress#getByName InetAddress.getByName}(null)&lt;/tt&gt;.
 In other words, it is equivalent to specifying an address of the
 loopback interface. &lt;/p&gt;
 &lt;p&gt;
 If the application has specified a server socket factory, that
 factory&apos;s &lt;code&gt;createSocketImpl&lt;/code&gt; method is called to create
 the actual socket implementation. Otherwise a &quot;plain&quot; socket is created.
 &lt;p&gt;
 If there is a security manager, its
 &lt;code&gt;checkConnect&lt;/code&gt; method is called
 with the host address and &lt;code&gt;port&lt;/code&gt;
 as its arguments. This could result in a SecurityException.</description>
					<attribute name="@param">
						<description>host   the host name, or &lt;code&gt;null&lt;/code&gt; for the loopback address.</description>
					</attribute>
					<attribute name="@param">
						<description>port   the port number.</description>
					</attribute>
					<attribute name="@exception">
						<description>UnknownHostException if the IP address of
 the host could not be determined.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs when creating the socket.</description>
					</attribute>
					<attribute name="@exception">
						<description>SecurityException  if a security manager exists and its
             &lt;code&gt;checkConnect&lt;/code&gt; method doesn&apos;t allow the operation.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.Socket#setSocketImplFactory(java.net.SocketImplFactory)</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.SocketImpl</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.SocketImplFactory#createSocketImpl()</description>
					</attribute>
					<attribute name="@see">
						<description>SecurityManager#checkConnect</description>
					</attribute>
				</comment>
				<params>
					<param name="host" comment="the host name, or &lt;code&gt;null&lt;/code&gt; for the loopback address." fulltype="java.lang.String" type="String" />
					<param name="port" comment="the port number." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if the IP address of
 the host could not be determined." fulltype="java.net.UnknownHostException" type="UnknownHostException" />
					<exception comment="if an I/O error occurs when creating the socket." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</constructor>
			<constructor visibility="public" name="Socket">
				<comment>
					<description>Creates a stream socket and connects it to the specified port
 number at the specified IP address.
 &lt;p&gt;
 If the application has specified a socket factory, that factory&apos;s
 &lt;code&gt;createSocketImpl&lt;/code&gt; method is called to create the
 actual socket implementation. Otherwise a &quot;plain&quot; socket is created.
 &lt;p&gt;
 If there is a security manager, its
 &lt;code&gt;checkConnect&lt;/code&gt; method is called
 with the host address and &lt;code&gt;port&lt;/code&gt;
 as its arguments. This could result in a SecurityException.</description>
					<attribute name="@param">
						<description>address   the IP address.</description>
					</attribute>
					<attribute name="@param">
						<description>port      the port number.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs when creating the socket.</description>
					</attribute>
					<attribute name="@exception">
						<description>SecurityException  if a security manager exists and its
             &lt;code&gt;checkConnect&lt;/code&gt; method doesn&apos;t allow the operation.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.Socket#setSocketImplFactory(java.net.SocketImplFactory)</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.SocketImpl</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.SocketImplFactory#createSocketImpl()</description>
					</attribute>
					<attribute name="@see">
						<description>SecurityManager#checkConnect</description>
					</attribute>
				</comment>
				<params>
					<param name="address" comment="the IP address." fulltype="java.net.InetAddress" type="InetAddress" />
					<param name="port" comment="the port number." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs when creating the socket." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</constructor>
			<constructor visibility="public" name="Socket">
				<comment>
					<description>Creates a socket and connects it to the specified remote host on
 the specified remote port. The Socket will also bind() to the local
 address and port supplied.
 &lt;p&gt;
 If the specified host is &lt;tt&gt;null&lt;/tt&gt; it is the equivalent of
 specifying the address as &lt;tt&gt;{@link java.net.InetAddress#getByName InetAddress.getByName}(null)&lt;/tt&gt;.
 In other words, it is equivalent to specifying an address of the
 loopback interface. &lt;/p&gt;
 &lt;p&gt;
 If there is a security manager, its
 &lt;code&gt;checkConnect&lt;/code&gt; method is called
 with the host address and &lt;code&gt;port&lt;/code&gt;
 as its arguments. This could result in a SecurityException.</description>
					<attribute name="@param">
						<description>host the name of the remote host, or &lt;code&gt;null&lt;/code&gt; for the loopback address.</description>
					</attribute>
					<attribute name="@param">
						<description>port the remote port</description>
					</attribute>
					<attribute name="@param">
						<description>localAddr the local address the socket is bound to</description>
					</attribute>
					<attribute name="@param">
						<description>localPort the local port the socket is bound to</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs when creating the socket.</description>
					</attribute>
					<attribute name="@exception">
						<description>SecurityException  if a security manager exists and its
             &lt;code&gt;checkConnect&lt;/code&gt; method doesn&apos;t allow the operation.</description>
					</attribute>
					<attribute name="@see">
						<description>SecurityManager#checkConnect</description>
					</attribute>
					<attribute name="@since">
						<description>JDK1.1</description>
					</attribute>
				</comment>
				<params>
					<param name="host" comment="the name of the remote host, or &lt;code&gt;null&lt;/code&gt; for the loopback address." fulltype="java.lang.String" type="String" />
					<param name="port" comment="the remote port" fulltype="int" type="int" />
					<param name="localAddr" comment="the local address the socket is bound to" fulltype="java.net.InetAddress" type="InetAddress" />
					<param name="localPort" comment="the local port the socket is bound to" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs when creating the socket." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</constructor>
			<constructor visibility="public" name="Socket">
				<comment>
					<description>Creates a socket and connects it to the specified remote address on
 the specified remote port. The Socket will also bind() to the local
 address and port supplied.
 &lt;p&gt;
 If there is a security manager, its
 &lt;code&gt;checkConnect&lt;/code&gt; method is called
 with the host address and &lt;code&gt;port&lt;/code&gt;
 as its arguments. This could result in a SecurityException.</description>
					<attribute name="@param">
						<description>address the remote address</description>
					</attribute>
					<attribute name="@param">
						<description>port the remote port</description>
					</attribute>
					<attribute name="@param">
						<description>localAddr the local address the socket is bound to</description>
					</attribute>
					<attribute name="@param">
						<description>localPort the local port the socket is bound to</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs when creating the socket.</description>
					</attribute>
					<attribute name="@exception">
						<description>SecurityException  if a security manager exists and its
             &lt;code&gt;checkConnect&lt;/code&gt; method doesn&apos;t allow the operation.</description>
					</attribute>
					<attribute name="@see">
						<description>SecurityManager#checkConnect</description>
					</attribute>
					<attribute name="@since">
						<description>JDK1.1</description>
					</attribute>
				</comment>
				<params>
					<param name="address" comment="the remote address" fulltype="java.net.InetAddress" type="InetAddress" />
					<param name="port" comment="the remote port" fulltype="int" type="int" />
					<param name="localAddr" comment="the local address the socket is bound to" fulltype="java.net.InetAddress" type="InetAddress" />
					<param name="localPort" comment="the local port the socket is bound to" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs when creating the socket." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</constructor>
			<constructor visibility="public" name="Socket">
				<comment>
					<description>Creates a stream socket and connects it to the specified port
 number on the named host.
 &lt;p&gt;
 If the specified host is &lt;tt&gt;null&lt;/tt&gt; it is the equivalent of
 specifying the address as &lt;tt&gt;{@link java.net.InetAddress#getByName InetAddress.getByName}(null)&lt;/tt&gt;.
 In other words, it is equivalent to specifying an address of the
 loopback interface. &lt;/p&gt;
 &lt;p&gt;
 If the stream argument is &lt;code&gt;true&lt;/code&gt;, this creates a
 stream socket. If the stream argument is &lt;code&gt;false&lt;/code&gt;, it
 creates a datagram socket.
 &lt;p&gt;
 If the application has specified a server socket factory, that
 factory&apos;s &lt;code&gt;createSocketImpl&lt;/code&gt; method is called to create
 the actual socket implementation. Otherwise a &quot;plain&quot; socket is created.
 &lt;p&gt;
 If there is a security manager, its
 &lt;code&gt;checkConnect&lt;/code&gt; method is called
 with the host address and &lt;code&gt;port&lt;/code&gt;
 as its arguments. This could result in a SecurityException.
 &lt;p&gt;
 If a UDP socket is used, TCP/IP related socket options will not apply.</description>
					<attribute name="@param">
						<description>host     the host name, or &lt;code&gt;null&lt;/code&gt; for the loopback address.</description>
					</attribute>
					<attribute name="@param">
						<description>port     the port number.</description>
					</attribute>
					<attribute name="@param">
						<description>stream   a &lt;code&gt;boolean&lt;/code&gt; indicating whether this is
                      a stream socket or a datagram socket.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs when creating the socket.</description>
					</attribute>
					<attribute name="@exception">
						<description>SecurityException  if a security manager exists and its
             &lt;code&gt;checkConnect&lt;/code&gt; method doesn&apos;t allow the operation.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.Socket#setSocketImplFactory(java.net.SocketImplFactory)</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.SocketImpl</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.SocketImplFactory#createSocketImpl()</description>
					</attribute>
					<attribute name="@see">
						<description>SecurityManager#checkConnect</description>
					</attribute>
					<attribute name="@deprecated">
						<description>Use DatagramSocket instead for UDP transport.</description>
					</attribute>
				</comment>
				<params>
					<param name="host" comment="the host name, or &lt;code&gt;null&lt;/code&gt; for the loopback address." fulltype="java.lang.String" type="String" />
					<param name="port" comment="the port number." fulltype="int" type="int" />
					<param name="stream" comment="a &lt;code&gt;boolean&lt;/code&gt; indicating whether this is
                      a stream socket or a datagram socket." fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs when creating the socket." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</constructor>
			<constructor visibility="public" name="Socket">
				<comment>
					<description>Creates a socket and connects it to the specified port number at
 the specified IP address.
 &lt;p&gt;
 If the stream argument is &lt;code&gt;true&lt;/code&gt;, this creates a
 stream socket. If the stream argument is &lt;code&gt;false&lt;/code&gt;, it
 creates a datagram socket.
 &lt;p&gt;
 If the application has specified a server socket factory, that
 factory&apos;s &lt;code&gt;createSocketImpl&lt;/code&gt; method is called to create
 the actual socket implementation. Otherwise a &quot;plain&quot; socket is created.

 &lt;p&gt;If there is a security manager, its
 &lt;code&gt;checkConnect&lt;/code&gt; method is called
 with &lt;code&gt;host.getHostAddress()&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt;
 as its arguments. This could result in a SecurityException.
 &lt;p&gt;
 If UDP socket is used, TCP/IP related socket options will not apply.</description>
					<attribute name="@param">
						<description>host     the IP address.</description>
					</attribute>
					<attribute name="@param">
						<description>port      the port number.</description>
					</attribute>
					<attribute name="@param">
						<description>stream    if &lt;code&gt;true&lt;/code&gt;, create a stream socket;
                       otherwise, create a datagram socket.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs when creating the socket.</description>
					</attribute>
					<attribute name="@exception">
						<description>SecurityException  if a security manager exists and its
             &lt;code&gt;checkConnect&lt;/code&gt; method doesn&apos;t allow the operation.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.Socket#setSocketImplFactory(java.net.SocketImplFactory)</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.SocketImpl</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.SocketImplFactory#createSocketImpl()</description>
					</attribute>
					<attribute name="@see">
						<description>SecurityManager#checkConnect</description>
					</attribute>
					<attribute name="@deprecated">
						<description>Use DatagramSocket instead for UDP transport.</description>
					</attribute>
				</comment>
				<params>
					<param name="host" comment="the IP address." fulltype="java.net.InetAddress" type="InetAddress" />
					<param name="port" comment="the port number." fulltype="int" type="int" />
					<param name="stream" comment="if &lt;code&gt;true&lt;/code&gt;, create a stream socket;
                       otherwise, create a datagram socket." fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs when creating the socket." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</constructor>
			<constructor visibility="private" name="Socket">
				<params>
					<param name="address" fulltype="java.net.SocketAddress" type="SocketAddress" />
					<param name="localAddr" fulltype="java.net.SocketAddress" type="SocketAddress" />
					<param name="stream" fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</constructor>
			<method visibility="package-private" name="createImpl" fulltype="void" type="void">
				<comment>
					<description>Creates the socket implementation.</description>
					<attribute name="@param">
						<description>stream a &lt;code&gt;boolean&lt;/code&gt; value : &lt;code&gt;true&lt;/code&gt; for a TCP socket,
               &lt;code&gt;false&lt;/code&gt; for UDP.</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException if creation fails</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
				<params>
					<param name="stream" comment="a &lt;code&gt;boolean&lt;/code&gt; value : &lt;code&gt;true&lt;/code&gt; for a TCP socket,
               &lt;code&gt;false&lt;/code&gt; for UDP." fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method visibility="private" name="checkOldImpl" fulltype="void" type="void" />
			<method visibility="package-private" name="setImpl" fulltype="void" type="void">
				<comment>
					<description>Sets impl to the system-default type of SocketImpl.</description>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</method>
			<method visibility="package-private" name="getImpl" returncomment="the &lt;code&gt;SocketImpl&lt;/code&gt; attached to that ServerSocket." fulltype="java.net.SocketImpl" type="SocketImpl">
				<comment>
					<description>Get the &lt;code&gt;SocketImpl&lt;/code&gt; attached to this socket, creating
 it if necessary.</description>
					<attribute name="@return">
						<description>the &lt;code&gt;SocketImpl&lt;/code&gt; attached to that ServerSocket.</description>
					</attribute>
					<attribute name="@throws">
						<description>SocketException if creation fails</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if creation fails" fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method visibility="public" name="connect" fulltype="void" type="void">
				<comment>
					<description>Connects this socket to the server.</description>
					<attribute name="@param">
						<description>endpoint the &lt;code&gt;SocketAddress&lt;/code&gt;</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException if an error occurs during the connection</description>
					</attribute>
					<attribute name="@throws">
						<description>java.nio.channels.IllegalBlockingModeException
          if this socket has an associated channel,
          and the channel is in non-blocking mode</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if endpoint is null or is a
          SocketAddress subclass not supported by this socket</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
					<attribute name="@spec">
						<description>JSR-51</description>
					</attribute>
				</comment>
				<params>
					<param name="endpoint" comment="the &lt;code&gt;SocketAddress&lt;/code&gt;" fulltype="java.net.SocketAddress" type="SocketAddress" />
				</params>
				<exceptions>
					<exception comment="if an error occurs during the connection" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="connect" fulltype="void" type="void">
				<comment>
					<description>Connects this socket to the server with a specified timeout value.
 A timeout of zero is interpreted as an infinite timeout. The connection
 will then block until established or an error occurs.</description>
					<attribute name="@param">
						<description>endpoint the &lt;code&gt;SocketAddress&lt;/code&gt;</description>
					</attribute>
					<attribute name="@param">
						<description>timeout  the timeout value to be used in milliseconds.</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException if an error occurs during the connection</description>
					</attribute>
					<attribute name="@throws">
						<description>SocketTimeoutException if timeout expires before connecting</description>
					</attribute>
					<attribute name="@throws">
						<description>java.nio.channels.IllegalBlockingModeException
          if this socket has an associated channel,
          and the channel is in non-blocking mode</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if endpoint is null or is a
          SocketAddress subclass not supported by this socket</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
					<attribute name="@spec">
						<description>JSR-51</description>
					</attribute>
				</comment>
				<params>
					<param name="endpoint" comment="the &lt;code&gt;SocketAddress&lt;/code&gt;" fulltype="java.net.SocketAddress" type="SocketAddress" />
					<param name="timeout" comment="the timeout value to be used in milliseconds." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if an error occurs during the connection" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="bind" fulltype="void" type="void">
				<comment>
					<description>Binds the socket to a local address.
 &lt;P&gt;
 If the address is &lt;code&gt;null&lt;/code&gt;, then the system will pick up
 an ephemeral port and a valid local address to bind the socket.</description>
					<attribute name="@param">
						<description>bindpoint the &lt;code&gt;SocketAddress&lt;/code&gt; to bind to</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException if the bind operation fails, or if the socket
                     is already bound.</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if bindpoint is a
          SocketAddress subclass not supported by this socket</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
					<attribute name="@see">
						<description>#isBound</description>
					</attribute>
				</comment>
				<params>
					<param name="bindpoint" comment="the &lt;code&gt;SocketAddress&lt;/code&gt; to bind to" fulltype="java.net.SocketAddress" type="SocketAddress" />
				</params>
				<exceptions>
					<exception comment="if the bind operation fails, or if the socket
                     is already bound." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="checkAddress" fulltype="void" type="void">
				<params>
					<param name="addr" fulltype="java.net.InetAddress" type="InetAddress" />
					<param name="op" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method final="true" visibility="package-private" name="postAccept" fulltype="void" type="void">
				<comment>
					<description>set the flags after an accept() call.</description>
				</comment>
			</method>
			<method visibility="package-private" name="setCreated" fulltype="void" type="void" />
			<method visibility="package-private" name="setBound" fulltype="void" type="void" />
			<method visibility="package-private" name="setConnected" fulltype="void" type="void" />
			<method visibility="public" name="getInetAddress" returncomment="the remote IP address to which this socket is connected,
          or &lt;code&gt;null&lt;/code&gt; if the socket is not connected." fulltype="java.net.InetAddress" type="InetAddress">
				<comment>
					<description>Returns the address to which the socket is connected.</description>
					<attribute name="@return">
						<description>the remote IP address to which this socket is connected,
          or &lt;code&gt;null&lt;/code&gt; if the socket is not connected.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getLocalAddress" returncomment="the local address to which the socket is bound or
         &lt;code&gt;InetAddress.anyLocalAddress()&lt;/code&gt;
         if the socket is not bound yet." fulltype="java.net.InetAddress" type="InetAddress">
				<comment>
					<description>Gets the local address to which the socket is bound.</description>
					<attribute name="@return">
						<description>the local address to which the socket is bound or
         &lt;code&gt;InetAddress.anyLocalAddress()&lt;/code&gt;
         if the socket is not bound yet.</description>
					</attribute>
					<attribute name="@since">
						<description>JDK1.1</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getPort" returncomment="the remote port number to which this socket is connected, or
          0 if the socket is not connected yet." fulltype="int" type="int">
				<comment>
					<description>Returns the remote port number to which this socket is connected.</description>
					<attribute name="@return">
						<description>the remote port number to which this socket is connected, or
          0 if the socket is not connected yet.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getLocalPort" returncomment="the local port number to which this socket is bound or -1
          if the socket is not bound yet." fulltype="int" type="int">
				<comment>
					<description>Returns the local port number to which this socket is bound.</description>
					<attribute name="@return">
						<description>the local port number to which this socket is bound or -1
          if the socket is not bound yet.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getRemoteSocketAddress" returncomment="a &lt;code&gt;SocketAddress&lt;/code&gt; reprensenting the remote endpoint of this
         socket, or &lt;code&gt;null&lt;/code&gt; if it is not connected yet." fulltype="java.net.SocketAddress" type="SocketAddress">
				<comment>
					<description>Returns the address of the endpoint this socket is connected to, or
 &lt;code&gt;null&lt;/code&gt; if it is unconnected.</description>
					<attribute name="@return">
						<description>a &lt;code&gt;SocketAddress&lt;/code&gt; reprensenting the remote endpoint of this
         socket, or &lt;code&gt;null&lt;/code&gt; if it is not connected yet.</description>
					</attribute>
					<attribute name="@see">
						<description>#getInetAddress()</description>
					</attribute>
					<attribute name="@see">
						<description>#getPort()</description>
					</attribute>
					<attribute name="@see">
						<description>#connect(SocketAddress, int)</description>
					</attribute>
					<attribute name="@see">
						<description>#connect(SocketAddress)</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getLocalSocketAddress" returncomment="a &lt;code&gt;SocketAddress&lt;/code&gt; representing the local endpoint of this
         socket, or &lt;code&gt;null&lt;/code&gt; if it is not bound yet." fulltype="java.net.SocketAddress" type="SocketAddress">
				<comment>
					<description>Returns the address of the endpoint this socket is bound to, or
 &lt;code&gt;null&lt;/code&gt; if it is not bound yet.</description>
					<attribute name="@return">
						<description>a &lt;code&gt;SocketAddress&lt;/code&gt; representing the local endpoint of this
         socket, or &lt;code&gt;null&lt;/code&gt; if it is not bound yet.</description>
					</attribute>
					<attribute name="@see">
						<description>#getLocalAddress()</description>
					</attribute>
					<attribute name="@see">
						<description>#getLocalPort()</description>
					</attribute>
					<attribute name="@see">
						<description>#bind(SocketAddress)</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getChannel" returncomment="the socket channel associated with this socket,
          or &lt;tt&gt;null&lt;/tt&gt; if this socket was not created
          for a channel" fulltype="java.nio.channels.SocketChannel" type="SocketChannel">
				<comment>
					<description>Returns the unique {@link java.nio.channels.SocketChannel SocketChannel}
 object associated with this socket, if any.

 &lt;p&gt; A socket will have a channel if, and only if, the channel itself was
 created via the {@link java.nio.channels.SocketChannel#open
 SocketChannel.open} or {@link
 java.nio.channels.ServerSocketChannel#accept ServerSocketChannel.accept}
 methods.</description>
					<attribute name="@return">
						<description>the socket channel associated with this socket,
          or &lt;tt&gt;null&lt;/tt&gt; if this socket was not created
          for a channel</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
					<attribute name="@spec">
						<description>JSR-51</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getInputStream" returncomment="an input stream for reading bytes from this socket." fulltype="java.io.InputStream" type="InputStream">
				<comment>
					<description>Returns an input stream for this socket.

 &lt;p&gt; If this socket has an associated channel then the resulting input
 stream delegates all of its operations to the channel.  If the channel
 is in non-blocking mode then the input stream&apos;s &lt;tt&gt;read&lt;/tt&gt; operations
 will throw an {@link java.nio.channels.IllegalBlockingModeException}.

 &lt;p&gt;Under abnormal conditions the underlying connection may be
 broken by the remote host or the network software (for example
 a connection reset in the case of TCP connections). When a
 broken connection is detected by the network software the
 following applies to the returned input stream :-

 &lt;ul&gt;

   &lt;li&gt;&lt;p&gt;The network software may discard bytes that are buffered
   by the socket. Bytes that aren&apos;t discarded by the network
   software can be read using {@link java.io.InputStream#read read}.

   &lt;li&gt;&lt;p&gt;If there are no bytes buffered on the socket, or all
   buffered bytes have been consumed by
   {@link java.io.InputStream#read read}, then all subsequent
   calls to {@link java.io.InputStream#read read} will throw an
   {@link java.io.IOException IOException}.

   &lt;li&gt;&lt;p&gt;If there are no bytes buffered on the socket, and the
   socket has not been closed using {@link #close close}, then
   {@link java.io.InputStream#available available} will
   return &lt;code&gt;0&lt;/code&gt;.

 &lt;/ul&gt;

 &lt;p&gt; Closing the returned {@link java.io.InputStream InputStream}
 will close the associated socket.</description>
					<attribute name="@return">
						<description>an input stream for reading bytes from this socket.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs when creating the
             input stream, the socket is closed, the socket is
             not connected, or the socket input has been shutdown
             using {@link #shutdownInput()}</description>
					</attribute>
					<attribute name="@revised">
						<description>1.4</description>
					</attribute>
					<attribute name="@spec">
						<description>JSR-51</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs when creating the
             input stream, the socket is closed, the socket is
             not connected, or the socket input has been shutdown
             using {@link #shutdownInput()}" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="getOutputStream" returncomment="an output stream for writing bytes to this socket." fulltype="java.io.OutputStream" type="OutputStream">
				<comment>
					<description>Returns an output stream for this socket.

 &lt;p&gt; If this socket has an associated channel then the resulting output
 stream delegates all of its operations to the channel.  If the channel
 is in non-blocking mode then the output stream&apos;s &lt;tt&gt;write&lt;/tt&gt;
 operations will throw an {@link
 java.nio.channels.IllegalBlockingModeException}.

 &lt;p&gt; Closing the returned {@link java.io.OutputStream OutputStream}
 will close the associated socket.</description>
					<attribute name="@return">
						<description>an output stream for writing bytes to this socket.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs when creating the
               output stream or if the socket is not connected.</description>
					</attribute>
					<attribute name="@revised">
						<description>1.4</description>
					</attribute>
					<attribute name="@spec">
						<description>JSR-51</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs when creating the
               output stream or if the socket is not connected." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="setTcpNoDelay" fulltype="void" type="void">
				<comment>
					<description>Enable/disable TCP_NODELAY (disable/enable Nagle&apos;s algorithm).</description>
					<attribute name="@param">
						<description>on &lt;code&gt;true&lt;/code&gt; to enable TCP_NODELAY,
 &lt;code&gt;false&lt;/code&gt; to disable.</description>
					</attribute>
					<attribute name="@exception">
						<description>SocketException if there is an error
 in the underlying protocol, such as a TCP error.</description>
					</attribute>
					<attribute name="@since">
						<description>JDK1.1</description>
					</attribute>
					<attribute name="@see">
						<description>#getTcpNoDelay()</description>
					</attribute>
				</comment>
				<params>
					<param name="on" comment="&lt;code&gt;true&lt;/code&gt; to enable TCP_NODELAY,
 &lt;code&gt;false&lt;/code&gt; to disable." fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception comment="if there is an error
 in the underlying protocol, such as a TCP error." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method visibility="public" name="getTcpNoDelay" returncomment="a &lt;code&gt;boolean&lt;/code&gt; indicating whether or not TCP_NODELAY is enabled." fulltype="boolean" type="boolean">
				<comment>
					<description>Tests if TCP_NODELAY is enabled.</description>
					<attribute name="@return">
						<description>a &lt;code&gt;boolean&lt;/code&gt; indicating whether or not TCP_NODELAY is enabled.</description>
					</attribute>
					<attribute name="@exception">
						<description>SocketException if there is an error
 in the underlying protocol, such as a TCP error.</description>
					</attribute>
					<attribute name="@since">
						<description>JDK1.1</description>
					</attribute>
					<attribute name="@see">
						<description>#setTcpNoDelay(boolean)</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if there is an error
 in the underlying protocol, such as a TCP error." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method visibility="public" name="setSoLinger" fulltype="void" type="void">
				<comment>
					<description>Enable/disable SO_LINGER with the specified linger time in seconds.
 The maximum timeout value is platform specific.

 The setting only affects socket close.</description>
					<attribute name="@param">
						<description>on     whether or not to linger on.</description>
					</attribute>
					<attribute name="@param">
						<description>linger how long to linger for, if on is true.</description>
					</attribute>
					<attribute name="@exception">
						<description>SocketException if there is an error
 in the underlying protocol, such as a TCP error.</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if the linger value is negative.</description>
					</attribute>
					<attribute name="@since">
						<description>JDK1.1</description>
					</attribute>
					<attribute name="@see">
						<description>#getSoLinger()</description>
					</attribute>
				</comment>
				<params>
					<param name="on" comment="whether or not to linger on." fulltype="boolean" type="boolean" />
					<param name="linger" comment="how long to linger for, if on is true." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if there is an error
 in the underlying protocol, such as a TCP error." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method visibility="public" name="getSoLinger" returncomment="the setting for SO_LINGER." fulltype="int" type="int">
				<comment>
					<description>Returns setting for SO_LINGER. -1 returns implies that the
 option is disabled.

 The setting only affects socket close.</description>
					<attribute name="@return">
						<description>the setting for SO_LINGER.</description>
					</attribute>
					<attribute name="@exception">
						<description>SocketException if there is an error
 in the underlying protocol, such as a TCP error.</description>
					</attribute>
					<attribute name="@since">
						<description>JDK1.1</description>
					</attribute>
					<attribute name="@see">
						<description>#setSoLinger(boolean, int)</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if there is an error
 in the underlying protocol, such as a TCP error." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method visibility="public" name="sendUrgentData" fulltype="void" type="void">
				<comment>
					<description>Send one byte of urgent data on the socket. The byte to be sent is the lowest eight
 bits of the data parameter. The urgent byte is
 sent after any preceding writes to the socket OutputStream
 and before any future writes to the OutputStream.</description>
					<attribute name="@param">
						<description>data The byte of data to send</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException if there is an error
  sending the data.</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
				<params>
					<param name="data" comment="The byte of data to send" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if there is an error
  sending the data." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="setOOBInline" fulltype="void" type="void">
				<comment>
					<description>Enable/disable OOBINLINE (receipt of TCP urgent data)

 By default, this option is disabled and TCP urgent data received on a
 socket is silently discarded. If the user wishes to receive urgent data, then
 this option must be enabled. When enabled, urgent data is received
 inline with normal data.
 &lt;p&gt;
 Note, only limited support is provided for handling incoming urgent
 data. In particular, no notification of incoming urgent data is provided
 and there is no capability to distinguish between normal data and urgent
 data unless provided by a higher level protocol.</description>
					<attribute name="@param">
						<description>on &lt;code&gt;true&lt;/code&gt; to enable OOBINLINE,
 &lt;code&gt;false&lt;/code&gt; to disable.</description>
					</attribute>
					<attribute name="@exception">
						<description>SocketException if there is an error
 in the underlying protocol, such as a TCP error.</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
					<attribute name="@see">
						<description>#getOOBInline()</description>
					</attribute>
				</comment>
				<params>
					<param name="on" comment="&lt;code&gt;true&lt;/code&gt; to enable OOBINLINE,
 &lt;code&gt;false&lt;/code&gt; to disable." fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception comment="if there is an error
 in the underlying protocol, such as a TCP error." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method visibility="public" name="getOOBInline" returncomment="a &lt;code&gt;boolean&lt;/code&gt; indicating whether or not OOBINLINE is enabled." fulltype="boolean" type="boolean">
				<comment>
					<description>Tests if OOBINLINE is enabled.</description>
					<attribute name="@return">
						<description>a &lt;code&gt;boolean&lt;/code&gt; indicating whether or not OOBINLINE is enabled.</description>
					</attribute>
					<attribute name="@exception">
						<description>SocketException if there is an error
 in the underlying protocol, such as a TCP error.</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
					<attribute name="@see">
						<description>#setOOBInline(boolean)</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if there is an error
 in the underlying protocol, such as a TCP error." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="public" name="setSoTimeout" fulltype="void" type="void">
				<comment>
					<description>Enable/disable SO_TIMEOUT with the specified timeout, in
  milliseconds.  With this option set to a non-zero timeout,
  a read() call on the InputStream associated with this Socket
  will block for only this amount of time.  If the timeout expires,
  a &lt;B&gt;java.net.SocketTimeoutException&lt;/B&gt; is raised, though the
  Socket is still valid. The option &lt;B&gt;must&lt;/B&gt; be enabled
  prior to entering the blocking operation to have effect. The
  timeout must be &gt; 0.
  A timeout of zero is interpreted as an infinite timeout.</description>
					<attribute name="@param">
						<description>timeout the specified timeout, in milliseconds.</description>
					</attribute>
					<attribute name="@exception">
						<description>SocketException if there is an error
 in the underlying protocol, such as a TCP error.</description>
					</attribute>
					<attribute name="@since">
						<description>JDK 1.1</description>
					</attribute>
					<attribute name="@see">
						<description>#getSoTimeout()</description>
					</attribute>
				</comment>
				<params>
					<param name="timeout" comment="the specified timeout, in milliseconds." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if there is an error
 in the underlying protocol, such as a TCP error." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="public" name="getSoTimeout" returncomment="the setting for SO_TIMEOUT" fulltype="int" type="int">
				<comment>
					<description>Returns setting for SO_TIMEOUT.  0 returns implies that the
 option is disabled (i.e., timeout of infinity).</description>
					<attribute name="@return">
						<description>the setting for SO_TIMEOUT</description>
					</attribute>
					<attribute name="@exception">
						<description>SocketException if there is an error
 in the underlying protocol, such as a TCP error.</description>
					</attribute>
					<attribute name="@since">
						<description>JDK1.1</description>
					</attribute>
					<attribute name="@see">
						<description>#setSoTimeout(int)</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if there is an error
 in the underlying protocol, such as a TCP error." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="public" name="setSendBufferSize" fulltype="void" type="void">
				<comment>
					<description>Sets the SO_SNDBUF option to the specified value for this
 &lt;tt&gt;Socket&lt;/tt&gt;. The SO_SNDBUF option is used by the platform&apos;s
 networking code as a hint for the size to set
 the underlying network I/O buffers.

 &lt;p&gt;Because SO_SNDBUF is a hint, applications that want to
 verify what size the buffers were set to should call
 {@link #getSendBufferSize()}.</description>
					<attribute name="@exception">
						<description>SocketException if there is an error
 in the underlying protocol, such as a TCP error.</description>
					</attribute>
					<attribute name="@param">
						<description>size the size to which to set the send buffer
 size. This value must be greater than 0.</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if the
 value is 0 or is negative.</description>
					</attribute>
					<attribute name="@see">
						<description>#getSendBufferSize()</description>
					</attribute>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
				<params>
					<param name="size" comment="the size to which to set the send buffer
 size. This value must be greater than 0." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if there is an error
 in the underlying protocol, such as a TCP error." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="public" name="getSendBufferSize" returncomment="the value of the SO_SNDBUF option for this &lt;tt&gt;Socket&lt;/tt&gt;." fulltype="int" type="int">
				<comment>
					<description>Get value of the SO_SNDBUF option for this &lt;tt&gt;Socket&lt;/tt&gt;,
 that is the buffer size used by the platform
 for output on this &lt;tt&gt;Socket&lt;/tt&gt;.</description>
					<attribute name="@return">
						<description>the value of the SO_SNDBUF option for this &lt;tt&gt;Socket&lt;/tt&gt;.</description>
					</attribute>
					<attribute name="@exception">
						<description>SocketException if there is an error
 in the underlying protocol, such as a TCP error.</description>
					</attribute>
					<attribute name="@see">
						<description>#setSendBufferSize(int)</description>
					</attribute>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if there is an error
 in the underlying protocol, such as a TCP error." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="public" name="setReceiveBufferSize" fulltype="void" type="void">
				<comment>
					<description>Sets the SO_RCVBUF option to the specified value for this
 &lt;tt&gt;Socket&lt;/tt&gt;. The SO_RCVBUF option is used by the platform&apos;s
 networking code as a hint for the size to set
 the underlying network I/O buffers.

 &lt;p&gt;Increasing the receive buffer size can increase the performance of
 network I/O for high-volume connection, while decreasing it can
 help reduce the backlog of incoming data.

 &lt;p&gt;Because SO_RCVBUF is a hint, applications that want to
 verify what size the buffers were set to should call
 {@link #getReceiveBufferSize()}.

 &lt;p&gt;The value of SO_RCVBUF is also used to set the TCP receive window
 that is advertized to the remote peer. Generally, the window size
 can be modified at any time when a socket is connected. However, if
 a receive window larger than 64K is required then this must be requested
 &lt;B&gt;before&lt;/B&gt; the socket is connected to the remote peer. There are two
 cases to be aware of:&lt;p&gt;
 &lt;ol&gt;
 &lt;li&gt;For sockets accepted from a ServerSocket, this must be done by calling
 {@link ServerSocket#setReceiveBufferSize(int)} before the ServerSocket
 is bound to a local address.&lt;p&gt;&lt;/li&gt;
 &lt;li&gt;For client sockets, setReceiveBufferSize() must be called before
 connecting the socket to its remote peer.&lt;p&gt;&lt;/li&gt;&lt;/ol&gt;</description>
					<attribute name="@param">
						<description>size the size to which to set the receive buffer
 size. This value must be greater than 0.</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if the value is 0 or is
 negative.</description>
					</attribute>
					<attribute name="@exception">
						<description>SocketException if there is an error
 in the underlying protocol, such as a TCP error.</description>
					</attribute>
					<attribute name="@see">
						<description>#getReceiveBufferSize()</description>
					</attribute>
					<attribute name="@see">
						<description>ServerSocket#setReceiveBufferSize(int)</description>
					</attribute>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
				<params>
					<param name="size" comment="the size to which to set the receive buffer
 size. This value must be greater than 0." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if there is an error
 in the underlying protocol, such as a TCP error." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="public" name="getReceiveBufferSize" returncomment="the value of the SO_RCVBUF option for this &lt;tt&gt;Socket&lt;/tt&gt;." fulltype="int" type="int">
				<comment>
					<description>Gets the value of the SO_RCVBUF option for this &lt;tt&gt;Socket&lt;/tt&gt;,
 that is the buffer size used by the platform for
 input on this &lt;tt&gt;Socket&lt;/tt&gt;.</description>
					<attribute name="@return">
						<description>the value of the SO_RCVBUF option for this &lt;tt&gt;Socket&lt;/tt&gt;.</description>
					</attribute>
					<attribute name="@exception">
						<description>SocketException if there is an error
 in the underlying protocol, such as a TCP error.</description>
					</attribute>
					<attribute name="@see">
						<description>#setReceiveBufferSize(int)</description>
					</attribute>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if there is an error
 in the underlying protocol, such as a TCP error." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method visibility="public" name="setKeepAlive" fulltype="void" type="void">
				<comment>
					<description>Enable/disable SO_KEEPALIVE.</description>
					<attribute name="@param">
						<description>on     whether or not to have socket keep alive turned on.</description>
					</attribute>
					<attribute name="@exception">
						<description>SocketException if there is an error
 in the underlying protocol, such as a TCP error.</description>
					</attribute>
					<attribute name="@since">
						<description>1.3</description>
					</attribute>
					<attribute name="@see">
						<description>#getKeepAlive()</description>
					</attribute>
				</comment>
				<params>
					<param name="on" comment="whether or not to have socket keep alive turned on." fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception comment="if there is an error
 in the underlying protocol, such as a TCP error." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method visibility="public" name="getKeepAlive" returncomment="a &lt;code&gt;boolean&lt;/code&gt; indicating whether or not SO_KEEPALIVE is enabled." fulltype="boolean" type="boolean">
				<comment>
					<description>Tests if SO_KEEPALIVE is enabled.</description>
					<attribute name="@return">
						<description>a &lt;code&gt;boolean&lt;/code&gt; indicating whether or not SO_KEEPALIVE is enabled.</description>
					</attribute>
					<attribute name="@exception">
						<description>SocketException if there is an error
 in the underlying protocol, such as a TCP error.</description>
					</attribute>
					<attribute name="@since">
						<description>1.3</description>
					</attribute>
					<attribute name="@see">
						<description>#setKeepAlive(boolean)</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if there is an error
 in the underlying protocol, such as a TCP error." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method visibility="public" name="setTrafficClass" fulltype="void" type="void">
				<comment>
					<description>Sets traffic class or type-of-service octet in the IP
 header for packets sent from this Socket.
 As the underlying network implementation may ignore this
 value applications should consider it a hint.

 &lt;P&gt; The tc &lt;B&gt;must&lt;/B&gt; be in the range &lt;code&gt; 0 &lt;= tc &lt;=
 255&lt;/code&gt; or an IllegalArgumentException will be thrown.
 &lt;p&gt;Notes:
 &lt;p&gt; For Internet Protocol v4 the value consists of an octet
 with precedence and TOS fields as detailed in RFC 1349. The
 TOS field is bitset created by bitwise-or&apos;ing values such
 the following :-
 &lt;p&gt;
 &lt;UL&gt;
 &lt;LI&gt;&lt;CODE&gt;IPTOS_LOWCOST (0x02)&lt;/CODE&gt;&lt;/LI&gt;
 &lt;LI&gt;&lt;CODE&gt;IPTOS_RELIABILITY (0x04)&lt;/CODE&gt;&lt;/LI&gt;
 &lt;LI&gt;&lt;CODE&gt;IPTOS_THROUGHPUT (0x08)&lt;/CODE&gt;&lt;/LI&gt;
 &lt;LI&gt;&lt;CODE&gt;IPTOS_LOWDELAY (0x10)&lt;/CODE&gt;&lt;/LI&gt;
 &lt;/UL&gt;
 The last low order bit is always ignored as this
 corresponds to the MBZ (must be zero) bit.
 &lt;p&gt;
 Setting bits in the precedence field may result in a
 SocketException indicating that the operation is not
 permitted.
 &lt;p&gt;
 As RFC 1122 section 4.2.4.2 indicates, a compliant TCP
 implementation should, but is not required to, let application
 change the TOS field during the lifetime of a connection.
 So whether the type-of-service field can be changed after the
 TCP connection has been established depends on the implementation
 in the underlying platform. Applications should not assume that
 they can change the TOS field after the connection.
 &lt;p&gt;
 For Internet Protocol v6 &lt;code&gt;tc&lt;/code&gt; is the value that
 would be placed into the sin6_flowinfo field of the IP header.</description>
					<attribute name="@param">
						<description>tc        an &lt;code&gt;int&lt;/code&gt; value for the bitset.</description>
					</attribute>
					<attribute name="@throws">
						<description>SocketException if there is an error setting the
 traffic class or type-of-service</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
					<attribute name="@see">
						<description>#getTrafficClass</description>
					</attribute>
				</comment>
				<params>
					<param name="tc" comment="an &lt;code&gt;int&lt;/code&gt; value for the bitset." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if there is an error setting the
 traffic class or type-of-service" fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method visibility="public" name="getTrafficClass" returncomment="the traffic class or type-of-service already set" fulltype="int" type="int">
				<comment>
					<description>Gets traffic class or type-of-service in the IP header
 for packets sent from this Socket
 &lt;p&gt;
 As the underlying network implementation may ignore the
 traffic class or type-of-service set using {@link #setTrafficClass(int)}
 this method may return a different value than was previously
 set using the {@link #setTrafficClass(int)} method on this Socket.</description>
					<attribute name="@return">
						<description>the traffic class or type-of-service already set</description>
					</attribute>
					<attribute name="@throws">
						<description>SocketException if there is an error obtaining the
 traffic class or type-of-service value.</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
					<attribute name="@see">
						<description>#setTrafficClass(int)</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if there is an error obtaining the
 traffic class or type-of-service value." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method visibility="public" name="setReuseAddress" fulltype="void" type="void">
				<comment>
					<description>Enable/disable the SO_REUSEADDR socket option.
 &lt;p&gt;
 When a TCP connection is closed the connection may remain
 in a timeout state for a period of time after the connection
 is closed (typically known as the &lt;tt&gt;TIME_WAIT&lt;/tt&gt; state
 or &lt;tt&gt;2MSL&lt;/tt&gt; wait state).
 For applications using a well known socket address or port
 it may not be possible to bind a socket to the required
 &lt;tt&gt;SocketAddress&lt;/tt&gt; if there is a connection in the
 timeout state involving the socket address or port.
 &lt;p&gt;
 Enabling &lt;tt&gt;SO_REUSEADDR&lt;/tt&gt; prior to binding the socket
 using {@link #bind(SocketAddress)} allows the socket to be
 bound even though a previous connection is in a timeout
 state.
 &lt;p&gt;
 When a &lt;tt&gt;Socket&lt;/tt&gt; is created the initial setting
 of &lt;tt&gt;SO_REUSEADDR&lt;/tt&gt; is disabled.
 &lt;p&gt;
 The behaviour when &lt;tt&gt;SO_REUSEADDR&lt;/tt&gt; is enabled or
 disabled after a socket is bound (See {@link #isBound()})
 is not defined.</description>
					<attribute name="@param">
						<description>on  whether to enable or disable the socket option</description>
					</attribute>
					<attribute name="@exception">
						<description>SocketException if an error occurs enabling or
            disabling the &lt;tt&gt;SO_RESUEADDR&lt;/tt&gt; socket option,
            or the socket is closed.</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
					<attribute name="@see">
						<description>#getReuseAddress()</description>
					</attribute>
					<attribute name="@see">
						<description>#bind(SocketAddress)</description>
					</attribute>
					<attribute name="@see">
						<description>#isClosed()</description>
					</attribute>
					<attribute name="@see">
						<description>#isBound()</description>
					</attribute>
				</comment>
				<params>
					<param name="on" comment="whether to enable or disable the socket option" fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception comment="if an error occurs enabling or
            disabling the &lt;tt&gt;SO_RESUEADDR&lt;/tt&gt; socket option,
            or the socket is closed." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method visibility="public" name="getReuseAddress" returncomment="a &lt;code&gt;boolean&lt;/code&gt; indicating whether or not SO_REUSEADDR is enabled." fulltype="boolean" type="boolean">
				<comment>
					<description>Tests if SO_REUSEADDR is enabled.</description>
					<attribute name="@return">
						<description>a &lt;code&gt;boolean&lt;/code&gt; indicating whether or not SO_REUSEADDR is enabled.</description>
					</attribute>
					<attribute name="@exception">
						<description>SocketException if there is an error
 in the underlying protocol, such as a TCP error.</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
					<attribute name="@see">
						<description>#setReuseAddress(boolean)</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if there is an error
 in the underlying protocol, such as a TCP error." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="public" name="close" fulltype="void" type="void">
				<comment>
					<description>Closes this socket.
 &lt;p&gt;
 Any thread currently blocked in an I/O operation upon this socket
 will throw a {@link SocketException}.
 &lt;p&gt;
 Once a socket has been closed, it is not available for further networking
 use (i.e. can&apos;t be reconnected or rebound). A new socket needs to be
 created.

 &lt;p&gt; Closing this socket will also close the socket&apos;s
 {@link java.io.InputStream InputStream} and
 {@link java.io.OutputStream OutputStream}.

 &lt;p&gt; If this socket has an associated channel then the channel is closed
 as well.</description>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs when closing this socket.</description>
					</attribute>
					<attribute name="@revised">
						<description>1.4</description>
					</attribute>
					<attribute name="@spec">
						<description>JSR-51</description>
					</attribute>
					<attribute name="@see">
						<description>#isClosed</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs when closing this socket." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="shutdownInput" fulltype="void" type="void">
				<comment>
					<description>Places the input stream for this socket at &quot;end of stream&quot;.
 Any data sent to the input stream side of the socket is acknowledged
 and then silently discarded.
 &lt;p&gt;
 If you read from a socket input stream after invoking
 shutdownInput() on the socket, the stream will return EOF.</description>
					<attribute name="@exception">
						<description>IOException if an I/O error occurs when shutting down this
 socket.</description>
					</attribute>
					<attribute name="@since">
						<description>1.3</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.Socket#shutdownOutput()</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.Socket#close()</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.Socket#setSoLinger(boolean, int)</description>
					</attribute>
					<attribute name="@see">
						<description>#isInputShutdown</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs when shutting down this
 socket." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="shutdownOutput" fulltype="void" type="void">
				<comment>
					<description>Disables the output stream for this socket.
 For a TCP socket, any previously written data will be sent
 followed by TCP&apos;s normal connection termination sequence.

 If you write to a socket output stream after invoking
 shutdownOutput() on the socket, the stream will throw
 an IOException.</description>
					<attribute name="@exception">
						<description>IOException if an I/O error occurs when shutting down this
 socket.</description>
					</attribute>
					<attribute name="@since">
						<description>1.3</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.Socket#shutdownInput()</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.Socket#close()</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.Socket#setSoLinger(boolean, int)</description>
					</attribute>
					<attribute name="@see">
						<description>#isOutputShutdown</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs when shutting down this
 socket." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="toString" returncomment="a string representation of this socket." fulltype="java.lang.String" type="String">
				<comment>
					<description>Converts this socket to a &lt;code&gt;String&lt;/code&gt;.</description>
					<attribute name="@return">
						<description>a string representation of this socket.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="isConnected" returncomment="true if the socket successfuly connected to a server" fulltype="boolean" type="boolean">
				<comment>
					<description>Returns the connection state of the socket.</description>
					<attribute name="@return">
						<description>true if the socket successfuly connected to a server</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="isBound" returncomment="true if the socket successfuly bound to an address" fulltype="boolean" type="boolean">
				<comment>
					<description>Returns the binding state of the socket.</description>
					<attribute name="@return">
						<description>true if the socket successfuly bound to an address</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
					<attribute name="@see">
						<description>#bind</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="isClosed" returncomment="true if the socket has been closed" fulltype="boolean" type="boolean">
				<comment>
					<description>Returns the closed state of the socket.</description>
					<attribute name="@return">
						<description>true if the socket has been closed</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
					<attribute name="@see">
						<description>#close</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="isInputShutdown" returncomment="true if the input of the socket has been shutdown" fulltype="boolean" type="boolean">
				<comment>
					<description>Returns whether the read-half of the socket connection is closed.</description>
					<attribute name="@return">
						<description>true if the input of the socket has been shutdown</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
					<attribute name="@see">
						<description>#shutdownInput</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="isOutputShutdown" returncomment="true if the output of the socket has been shutdown" fulltype="boolean" type="boolean">
				<comment>
					<description>Returns whether the write-half of the socket connection is closed.</description>
					<attribute name="@return">
						<description>true if the output of the socket has been shutdown</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
					<attribute name="@see">
						<description>#shutdownOutput</description>
					</attribute>
				</comment>
			</method>
			<method static="true" synchronized="true" visibility="public" name="setSocketImplFactory" fulltype="void" type="void">
				<comment>
					<description>Sets the client socket implementation factory for the
 application. The factory can be specified only once.
 &lt;p&gt;
 When an application creates a new client socket, the socket
 implementation factory&apos;s &lt;code&gt;createSocketImpl&lt;/code&gt; method is
 called to create the actual socket implementation.
 &lt;p&gt;
 Passing &lt;code&gt;null&lt;/code&gt; to the method is a no-op unless the factory
 was already set.
 &lt;p&gt;If there is a security manager, this method first calls
 the security manager&apos;s &lt;code&gt;checkSetFactory&lt;/code&gt; method
 to ensure the operation is allowed.
 This could result in a SecurityException.</description>
					<attribute name="@param">
						<description>fac   the desired factory.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs when setting the
               socket factory.</description>
					</attribute>
					<attribute name="@exception">
						<description>SocketException  if the factory is already defined.</description>
					</attribute>
					<attribute name="@exception">
						<description>SecurityException  if a security manager exists and its
             &lt;code&gt;checkSetFactory&lt;/code&gt; method doesn&apos;t allow the operation.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.SocketImplFactory#createSocketImpl()</description>
					</attribute>
					<attribute name="@see">
						<description>SecurityManager#checkSetFactory</description>
					</attribute>
				</comment>
				<params>
					<param name="fac" comment="the desired factory." fulltype="java.net.SocketImplFactory" type="SocketImplFactory" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs when setting the
               socket factory." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="setPerformancePreferences" fulltype="void" type="void">
				<comment>
					<description>Sets performance preferences for this socket.

 &lt;p&gt; Sockets use the TCP/IP protocol by default.  Some implementations
 may offer alternative protocols which have different performance
 characteristics than TCP/IP.  This method allows the application to
 express its own preferences as to how these tradeoffs should be made
 when the implementation chooses from the available protocols.

 &lt;p&gt; Performance preferences are described by three integers
 whose values indicate the relative importance of short connection time,
 low latency, and high bandwidth.  The absolute values of the integers
 are irrelevant; in order to choose a protocol the values are simply
 compared, with larger values indicating stronger preferences. Negative
 values represent a lower priority than positive values. If the
 application prefers short connection time over both low latency and high
 bandwidth, for example, then it could invoke this method with the values
 &lt;tt&gt;(1, 0, 0)&lt;/tt&gt;.  If the application prefers high bandwidth above low
 latency, and low latency above short connection time, then it could
 invoke this method with the values &lt;tt&gt;(0, 1, 2)&lt;/tt&gt;.

 &lt;p&gt; Invoking this method after this socket has been connected
 will have no effect.</description>
					<attribute name="@param">
						<description>connectionTime
         An &lt;tt&gt;int&lt;/tt&gt; expressing the relative importance of a short
         connection time</description>
					</attribute>
					<attribute name="@param">
						<description>latency
         An &lt;tt&gt;int&lt;/tt&gt; expressing the relative importance of low
         latency</description>
					</attribute>
					<attribute name="@param">
						<description>bandwidth
         An &lt;tt&gt;int&lt;/tt&gt; expressing the relative importance of high
         bandwidth</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
				<params>
					<param name="connectionTime" comment="An &lt;tt&gt;int&lt;/tt&gt; expressing the relative importance of a short
         connection time" fulltype="int" type="int" />
					<param name="latency" comment="An &lt;tt&gt;int&lt;/tt&gt; expressing the relative importance of low
         latency" fulltype="int" type="int" />
					<param name="bandwidth" comment="An &lt;tt&gt;int&lt;/tt&gt; expressing the relative importance of high
         bandwidth" fulltype="int" type="int" />
				</params>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="Object" visibility="package-private" package="java.net" superclassfulltype="java.lang.Object" fulltype="java.net.Inet6AddressImpl" type="Inet6AddressImpl">
		<implements>
			<interface fulltype="java.net.InetAddressImpl" type="InetAddressImpl" />
		</implements>
		<fields>
			<field visibility="private" name="anyLocalAddress" fulltype="java.net.InetAddress" type="InetAddress" />
			<field visibility="private" name="loopbackAddress" fulltype="java.net.InetAddress" type="InetAddress" />
		</fields>
		<methods>
			<constructor visibility="package-private" name="Inet6AddressImpl" />
			<method visibility="public" name="getLocalHostName" fulltype="java.lang.String" type="String">
				<exceptions>
					<exception fulltype="java.net.UnknownHostException" type="UnknownHostException" />
				</exceptions>
			</method>
			<method visibility="public" name="lookupAllHostAddr" fulltype="java.net.InetAddress[]" type="InetAddress">
				<params>
					<param name="hostname" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception fulltype="java.net.UnknownHostException" type="UnknownHostException" />
				</exceptions>
			</method>
			<method visibility="public" name="getHostByAddr" fulltype="java.lang.String" type="String">
				<params>
					<param name="addr" fulltype="byte[]" type="byte" />
				</params>
				<exceptions>
					<exception fulltype="java.net.UnknownHostException" type="UnknownHostException" />
				</exceptions>
			</method>
			<method visibility="private" name="isReachable0" fulltype="boolean" type="boolean">
				<params>
					<param name="addr" fulltype="byte[]" type="byte" />
					<param name="scope" fulltype="int" type="int" />
					<param name="timeout" fulltype="int" type="int" />
					<param name="inf" fulltype="byte[]" type="byte" />
					<param name="ttl" fulltype="int" type="int" />
					<param name="if_scope" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="isReachable" fulltype="boolean" type="boolean">
				<params>
					<param name="addr" fulltype="java.net.InetAddress" type="InetAddress" />
					<param name="timeout" fulltype="int" type="int" />
					<param name="netif" fulltype="java.net.NetworkInterface" type="NetworkInterface" />
					<param name="ttl" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="public" name="anyLocalAddress" fulltype="java.net.InetAddress" type="InetAddress" />
			<method synchronized="true" visibility="public" name="loopbackAddress" fulltype="java.net.InetAddress" type="InetAddress" />
		</methods>
	</jelclass>
	<jelclass superclass="SocketException" visibility="public" package="java.net" serializable="true" superclassfulltype="java.net.SocketException" fulltype="java.net.PortUnreachableException" type="PortUnreachableException">
		<comment>
			<description>Signals that an ICMP Port Unreachable message has been
 received on a connected datagram.</description>
			<attribute name="@since">
				<description>1.4</description>
			</attribute>
		</comment>
		<methods>
			<constructor visibility="public" name="PortUnreachableException">
				<comment>
					<description>Constructs a new &lt;code&gt;PortUnreachableException&lt;/code&gt; with a
 detail message.</description>
					<attribute name="@param">
						<description>msg the detail message</description>
					</attribute>
				</comment>
				<params>
					<param name="msg" comment="the detail message" fulltype="java.lang.String" type="String" />
				</params>
			</constructor>
			<constructor visibility="public" name="PortUnreachableException">
				<comment>
					<description>Construct a new &lt;code&gt;PortUnreachableException&lt;/code&gt; with no
 detailed message.</description>
				</comment>
			</constructor>
		</methods>
	</jelclass>
	<jelclass abstract="true" visibility="public" package="java.net" interface="true" fulltype="java.net.DatagramSocketImplFactory" type="DatagramSocketImplFactory">
		<comment>
			<description>This interface defines a factory for datagram socket implementations. It
 is used by the classes &lt;code&gt;DatagramSocket&lt;/code&gt; to create actual socket
 implementations.</description>
			<attribute name="@author">
				<description>Yingxian Wang</description>
			</attribute>
			<attribute name="@see">
				<description>java.net.DatagramSocket</description>
			</attribute>
			<attribute name="@since">
				<description>1.3</description>
			</attribute>
		</comment>
		<methods>
			<method visibility="public" name="createDatagramSocketImpl" returncomment="a new instance of &lt;code&gt;DatagramSocketImpl&lt;/code&gt;." fulltype="java.net.DatagramSocketImpl" type="DatagramSocketImpl">
				<comment>
					<description>Creates a new &lt;code&gt;DatagramSocketImpl&lt;/code&gt; instance.</description>
					<attribute name="@return">
						<description>a new instance of &lt;code&gt;DatagramSocketImpl&lt;/code&gt;.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.DatagramSocketImpl</description>
					</attribute>
				</comment>
			</method>
		</methods>
	</jelclass>
	<jelclass abstract="true" superclass="Object" visibility="public" package="java.net" superclassfulltype="java.lang.Object" fulltype="java.net.DatagramSocketImpl" type="DatagramSocketImpl">
		<implements>
			<interface fulltype="java.net.SocketOptions" type="SocketOptions" />
		</implements>
		<comment>
			<description>Abstract datagram and multicast socket implementation base class.</description>
			<attribute name="@author">
				<description>Pavani Diwanji</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.1</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="protected" name="localPort" fulltype="int" type="int">
				<comment>
					<description>The local port number.</description>
				</comment>
			</field>
			<field visibility="protected" name="fd" fulltype="java.io.FileDescriptor" type="FileDescriptor">
				<comment>
					<description>The file descriptor object.</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="public" name="DatagramSocketImpl" />
			<method abstract="true" visibility="protected" name="create" fulltype="void" type="void">
				<comment>
					<description>Creates a datagram socket.</description>
					<attribute name="@exception">
						<description>SocketException if there is an error in the
 underlying protocol, such as a TCP error.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if there is an error in the
 underlying protocol, such as a TCP error." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="protected" name="bind" fulltype="void" type="void">
				<comment>
					<description>Binds a datagram socket to a local port and address.</description>
					<attribute name="@param">
						<description>lport the local port</description>
					</attribute>
					<attribute name="@param">
						<description>laddr the local address</description>
					</attribute>
					<attribute name="@exception">
						<description>SocketException if there is an error in the
 underlying protocol, such as a TCP error.</description>
					</attribute>
				</comment>
				<params>
					<param name="lport" comment="the local port" fulltype="int" type="int" />
					<param name="laddr" comment="the local address" fulltype="java.net.InetAddress" type="InetAddress" />
				</params>
				<exceptions>
					<exception comment="if there is an error in the
 underlying protocol, such as a TCP error." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="protected" name="send" fulltype="void" type="void">
				<comment>
					<description>Sends a datagram packet. The packet contains the data and the
 destination address to send the packet to.</description>
					<attribute name="@param">
						<description>p the packet to be sent.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException if an I/O exception occurs while sending the
 datagram packet.</description>
					</attribute>
					<attribute name="@exception">
						<description>PortUnreachableException may be thrown if the socket is connected
 to a currently unreachable destination. Note, there is no guarantee that
 the exception will be thrown.</description>
					</attribute>
				</comment>
				<params>
					<param name="p" comment="the packet to be sent." fulltype="java.net.DatagramPacket" type="DatagramPacket" />
				</params>
				<exceptions>
					<exception comment="if an I/O exception occurs while sending the
 datagram packet." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="protected" name="connect" fulltype="void" type="void">
				<comment>
					<description>Connects a datagram socket to a remote destination. This associates the remote
 address with the local socket so that datagrams may only be sent to this destination
 and received from this destination. This may be overridden to call a native
 system connect.

 &lt;p&gt;If the remote destination to which the socket is connected does not
 exist, or is otherwise unreachable, and if an ICMP destination unreachable
 packet has been received for that address, then a subsequent call to
 send or receive may throw a PortUnreachableException.
 Note, there is no guarantee that the exception will be thrown.</description>
					<attribute name="@param">
						<description>address the remote InetAddress to connect to</description>
					</attribute>
					<attribute name="@param">
						<description>port the remote port number</description>
					</attribute>
					<attribute name="@exception">
						<description>SocketException may be thrown if the socket cannot be
 connected to the remote destination</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
				<params>
					<param name="address" comment="the remote InetAddress to connect to" fulltype="java.net.InetAddress" type="InetAddress" />
					<param name="port" comment="the remote port number" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="may be thrown if the socket cannot be
 connected to the remote destination" fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method visibility="protected" name="disconnect" fulltype="void" type="void">
				<comment>
					<description>Disconnects a datagram socket from its remote destination.</description>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</method>
			<method abstract="true" visibility="protected" name="peek" returncomment="the port number which the packet came from." fulltype="int" type="int">
				<comment>
					<description>Peek at the packet to see who it is from. Updates the specified &lt;code&gt;InetAddress&lt;/code&gt;
 to the address which the packet came from.</description>
					<attribute name="@param">
						<description>i an InetAddress object</description>
					</attribute>
					<attribute name="@return">
						<description>the port number which the packet came from.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException if an I/O exception occurs</description>
					</attribute>
					<attribute name="@exception">
						<description>PortUnreachableException may be thrown if the socket is connected
       to a currently unreachable destination. Note, there is no guarantee that the
       exception will be thrown.</description>
					</attribute>
				</comment>
				<params>
					<param name="i" comment="an InetAddress object" fulltype="java.net.InetAddress" type="InetAddress" />
				</params>
				<exceptions>
					<exception comment="if an I/O exception occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="protected" name="peekData" returncomment="the port number which the packet came from." fulltype="int" type="int">
				<comment>
					<description>Peek at the packet to see who it is from. The data is copied into the specified
 &lt;code&gt;DatagramPacket&lt;/code&gt;. The data is returned,
 but not consumed, so that a subsequent peekData/receive operation
 will see the same data.</description>
					<attribute name="@param">
						<description>p the Packet Received.</description>
					</attribute>
					<attribute name="@return">
						<description>the port number which the packet came from.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException if an I/O exception occurs</description>
					</attribute>
					<attribute name="@exception">
						<description>PortUnreachableException may be thrown if the socket is connected
       to a currently unreachable destination. Note, there is no guarantee that the
       exception will be thrown.</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
				<params>
					<param name="p" comment="the Packet Received." fulltype="java.net.DatagramPacket" type="DatagramPacket" />
				</params>
				<exceptions>
					<exception comment="if an I/O exception occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="protected" name="receive" fulltype="void" type="void">
				<comment>
					<description>Receive the datagram packet.</description>
					<attribute name="@param">
						<description>p the Packet Received.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException if an I/O exception occurs
 while receiving the datagram packet.</description>
					</attribute>
					<attribute name="@exception">
						<description>PortUnreachableException may be thrown if the socket is connected
       to a currently unreachable destination. Note, there is no guarantee that the
       exception will be thrown.</description>
					</attribute>
				</comment>
				<params>
					<param name="p" comment="the Packet Received." fulltype="java.net.DatagramPacket" type="DatagramPacket" />
				</params>
				<exceptions>
					<exception comment="if an I/O exception occurs
 while receiving the datagram packet." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="protected" name="setTTL" fulltype="void" type="void">
				<comment>
					<description>Set the TTL (time-to-live) option.</description>
					<attribute name="@param">
						<description>ttl a byte specifying the TTL value</description>
					</attribute>
					<attribute name="@deprecated">
						<description>use setTimeToLive instead.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException if an I/O exception occurs while setting
 the time-to-live option.</description>
					</attribute>
					<attribute name="@see">
						<description>#getTTL()</description>
					</attribute>
				</comment>
				<params>
					<param name="ttl" comment="a byte specifying the TTL value" fulltype="byte" type="byte" />
				</params>
				<exceptions>
					<exception comment="if an I/O exception occurs while setting
 the time-to-live option." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="protected" name="getTTL" returncomment="a byte representing the TTL value" fulltype="byte" type="byte">
				<comment>
					<description>Retrieve the TTL (time-to-live) option.</description>
					<attribute name="@exception">
						<description>IOException if an I/O exception occurs
 while retrieving the time-to-live option</description>
					</attribute>
					<attribute name="@deprecated">
						<description>use getTimeToLive instead.</description>
					</attribute>
					<attribute name="@return">
						<description>a byte representing the TTL value</description>
					</attribute>
					<attribute name="@see">
						<description>#setTTL(byte)</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O exception occurs
 while retrieving the time-to-live option" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="protected" name="setTimeToLive" fulltype="void" type="void">
				<comment>
					<description>Set the TTL (time-to-live) option.</description>
					<attribute name="@param">
						<description>ttl an &lt;tt&gt;int&lt;/tt&gt; specifying the time-to-live value</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException if an I/O exception occurs
 while setting the time-to-live option.</description>
					</attribute>
					<attribute name="@see">
						<description>#getTimeToLive()</description>
					</attribute>
				</comment>
				<params>
					<param name="ttl" comment="an &lt;tt&gt;int&lt;/tt&gt; specifying the time-to-live value" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if an I/O exception occurs
 while setting the time-to-live option." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="protected" name="getTimeToLive" returncomment="an &lt;tt&gt;int&lt;/tt&gt; representing the time-to-live value" fulltype="int" type="int">
				<comment>
					<description>Retrieve the TTL (time-to-live) option.</description>
					<attribute name="@exception">
						<description>IOException if an I/O exception occurs
 while retrieving the time-to-live option</description>
					</attribute>
					<attribute name="@return">
						<description>an &lt;tt&gt;int&lt;/tt&gt; representing the time-to-live value</description>
					</attribute>
					<attribute name="@see">
						<description>#setTimeToLive(int)</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O exception occurs
 while retrieving the time-to-live option" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="protected" name="join" fulltype="void" type="void">
				<comment>
					<description>Join the multicast group.</description>
					<attribute name="@param">
						<description>inetaddr multicast address to join.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException if an I/O exception occurs
 while joining the multicast group.</description>
					</attribute>
				</comment>
				<params>
					<param name="inetaddr" comment="multicast address to join." fulltype="java.net.InetAddress" type="InetAddress" />
				</params>
				<exceptions>
					<exception comment="if an I/O exception occurs
 while joining the multicast group." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="protected" name="leave" fulltype="void" type="void">
				<comment>
					<description>Leave the multicast group.</description>
					<attribute name="@param">
						<description>inetaddr multicast address to leave.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException if an I/O exception occurs
 while leaving the multicast group.</description>
					</attribute>
				</comment>
				<params>
					<param name="inetaddr" comment="multicast address to leave." fulltype="java.net.InetAddress" type="InetAddress" />
				</params>
				<exceptions>
					<exception comment="if an I/O exception occurs
 while leaving the multicast group." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="protected" name="joinGroup" fulltype="void" type="void">
				<comment>
					<description>Join the multicast group.</description>
					<attribute name="@param">
						<description>mcastaddr address to join.</description>
					</attribute>
					<attribute name="@param">
						<description>netIf specifies the local interface to receive multicast
        datagram packets</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException if an I/O exception occurs while joining
 the multicast group</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
				<params>
					<param name="mcastaddr" comment="address to join." fulltype="java.net.SocketAddress" type="SocketAddress" />
					<param name="netIf" comment="specifies the local interface to receive multicast
        datagram packets" fulltype="java.net.NetworkInterface" type="NetworkInterface" />
				</params>
				<exceptions>
					<exception comment="if an I/O exception occurs while joining
 the multicast group" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="protected" name="leaveGroup" fulltype="void" type="void">
				<comment>
					<description>Leave the multicast group.</description>
					<attribute name="@param">
						<description>mcastaddr address to leave.</description>
					</attribute>
					<attribute name="@param">
						<description>netIf specified the local interface to leave the group at</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException if an I/O exception occurs while leaving
 the multicast group</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
				<params>
					<param name="mcastaddr" comment="address to leave." fulltype="java.net.SocketAddress" type="SocketAddress" />
					<param name="netIf" comment="specified the local interface to leave the group at" fulltype="java.net.NetworkInterface" type="NetworkInterface" />
				</params>
				<exceptions>
					<exception comment="if an I/O exception occurs while leaving
 the multicast group" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="protected" name="close" fulltype="void" type="void">
				<comment>
					<description>Close the socket.</description>
				</comment>
			</method>
			<method visibility="protected" name="getLocalPort" returncomment="an &lt;tt&gt;int&lt;/tt&gt; representing the local port value" fulltype="int" type="int">
				<comment>
					<description>Gets the local port.</description>
					<attribute name="@return">
						<description>an &lt;tt&gt;int&lt;/tt&gt; representing the local port value</description>
					</attribute>
				</comment>
			</method>
			<method visibility="protected" name="getFileDescriptor" returncomment="a &lt;tt&gt;FileDescriptor&lt;/tt&gt; object representing the datagram socket
 file descriptor" fulltype="java.io.FileDescriptor" type="FileDescriptor">
				<comment>
					<description>Gets the datagram socket file descriptor.</description>
					<attribute name="@return">
						<description>a &lt;tt&gt;FileDescriptor&lt;/tt&gt; object representing the datagram socket
 file descriptor</description>
					</attribute>
				</comment>
			</method>
		</methods>
	</jelclass>
	<jelclass abstract="true" visibility="public" package="java.net" interface="true" fulltype="java.net.CookiePolicy" type="CookiePolicy">
		<comment>
			<description>CookiePolicy implementations decide which cookies should be accepted
 and which should be rejected. Three pre-defined policy implementations
 are provided, namely ACCEPT_ALL, ACCEPT_NONE and ACCEPT_ORIGINAL_SERVER.

 &lt;p&gt;See RFC 2965 sec. 3.3 &amp; 7 for more detail.</description>
			<attribute name="@author">
				<description>Edward Wang</description>
			</attribute>
			<attribute name="@since">
				<description>1.6</description>
			</attribute>
		</comment>
		<fields>
			<field final="true" static="true" visibility="public" name="ACCEPT_ALL" fulltype="java.net.CookiePolicy" type="CookiePolicy">
				<comment>
					<description>One pre-defined policy which accepts all cookies.</description>
				</comment>
			</field>
			<field final="true" static="true" visibility="public" name="ACCEPT_NONE" fulltype="java.net.CookiePolicy" type="CookiePolicy">
				<comment>
					<description>One pre-defined policy which accepts no cookies.</description>
				</comment>
			</field>
			<field final="true" static="true" visibility="public" name="ACCEPT_ORIGINAL_SERVER" fulltype="java.net.CookiePolicy" type="CookiePolicy">
				<comment>
					<description>One pre-defined policy which only accepts cookies from original server.</description>
				</comment>
			</field>
		</fields>
		<methods>
			<method visibility="public" name="shouldAccept" returncomment="&lt;tt&gt;true&lt;/tt&gt; if this cookie should be accepted;
                  otherwise, &lt;tt&gt;false&lt;/tt&gt;" fulltype="boolean" type="boolean">
				<comment>
					<description>Will be called to see whether or not this cookie should be accepted.</description>
					<attribute name="@param">
						<description>uri       the URI to consult accept policy with</description>
					</attribute>
					<attribute name="@param">
						<description>cookie    the HttpCookie object in question</description>
					</attribute>
					<attribute name="@return">
						<description>&lt;tt&gt;true&lt;/tt&gt; if this cookie should be accepted;
                  otherwise, &lt;tt&gt;false&lt;/tt&gt;</description>
					</attribute>
				</comment>
				<params>
					<param name="uri" comment="the URI to consult accept policy with" fulltype="java.net.URI" type="URI" />
					<param name="cookie" comment="the HttpCookie object in question" fulltype="java.net.HttpCookie" type="HttpCookie" />
				</params>
			</method>
		</methods>
	</jelclass>
	<jelclass abstract="true" superclass="Object" visibility="public" package="java.net" superclassfulltype="java.lang.Object" fulltype="java.net.CacheResponse" type="CacheResponse">
		<comment>
			<description>Represent channels for retrieving resources from the
 ResponseCache. Instances of such a class provide an
 InputStream that returns the entity body, and also a
 getHeaders() method which returns the associated response headers.</description>
			<attribute name="@author">
				<description>Yingxian Wang</description>
			</attribute>
			<attribute name="@since">
				<description>1.5</description>
			</attribute>
		</comment>
		<methods>
			<constructor visibility="public" name="CacheResponse" />
			<method abstract="true" visibility="public" name="getHeaders" returncomment="An immutable Map from response header field names to
         lists of field values. The status line has null as its
         field name." fulltype="java.util.Map" type="Map">
				<comment>
					<description>Returns the response headers as a Map.</description>
					<attribute name="@return">
						<description>An immutable Map from response header field names to
         lists of field values. The status line has null as its
         field name.</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException if an I/O error occurs
            while getting the response headers</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs
            while getting the response headers" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="public" name="getBody" returncomment="an InputStream from which the response body can
         be accessed" fulltype="java.io.InputStream" type="InputStream">
				<comment>
					<description>Returns the response body as an InputStream.</description>
					<attribute name="@return">
						<description>an InputStream from which the response body can
         be accessed</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException if an I/O error occurs while
         getting the response body</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs while
         getting the response body" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="Object" visibility="public" package="java.net" superclassfulltype="java.lang.Object" fulltype="java.net.ServerSocket" type="ServerSocket">
		<comment>
			<description>This class implements server sockets. A server socket waits for
 requests to come in over the network. It performs some operation
 based on that request, and then possibly returns a result to the requester.
 &lt;p&gt;
 The actual work of the server socket is performed by an instance
 of the &lt;code&gt;SocketImpl&lt;/code&gt; class. An application can
 change the socket factory that creates the socket
 implementation to configure itself to create sockets
 appropriate to the local firewall.</description>
			<attribute name="@author">
				<description>unascribed</description>
			</attribute>
			<attribute name="@see">
				<description>java.net.SocketImpl</description>
			</attribute>
			<attribute name="@see">
				<description>java.net.ServerSocket#setSocketFactory(java.net.SocketImplFactory)</description>
			</attribute>
			<attribute name="@see">
				<description>java.nio.channels.ServerSocketChannel</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.0</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="private" name="created" fulltype="boolean" type="boolean">
				<comment>
					<description>Various states of this socket.</description>
				</comment>
			</field>
			<field visibility="private" name="bound" fulltype="boolean" type="boolean" />
			<field visibility="private" name="closed" fulltype="boolean" type="boolean" />
			<field visibility="private" name="closeLock" fulltype="java.lang.Object" type="Object" />
			<field visibility="private" name="impl" fulltype="java.net.SocketImpl" type="SocketImpl">
				<comment>
					<description>The implementation of this Socket.</description>
				</comment>
			</field>
			<field visibility="private" name="oldImpl" fulltype="boolean" type="boolean">
				<comment>
					<description>Are we using an older SocketImpl?</description>
				</comment>
			</field>
			<field static="true" visibility="private" name="factory" fulltype="java.net.SocketImplFactory" type="SocketImplFactory">
				<comment>
					<description>The factory for all server sockets.</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="public" name="ServerSocket">
				<comment>
					<description>Creates an unbound server socket.</description>
					<attribute name="@exception">
						<description>IOException IO error when opening the socket.</description>
					</attribute>
					<attribute name="@revised">
						<description>1.4</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="IO error when opening the socket." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</constructor>
			<constructor visibility="public" name="ServerSocket">
				<comment>
					<description>Creates a server socket, bound to the specified port. A port of
 &lt;code&gt;0&lt;/code&gt; creates a socket on any free port.
 &lt;p&gt;
 The maximum queue length for incoming connection indications (a
 request to connect) is set to &lt;code&gt;50&lt;/code&gt;. If a connection
 indication arrives when the queue is full, the connection is refused.
 &lt;p&gt;
 If the application has specified a server socket factory, that
 factory&apos;s &lt;code&gt;createSocketImpl&lt;/code&gt; method is called to create
 the actual socket implementation. Otherwise a &quot;plain&quot; socket is created.
 &lt;p&gt;
 If there is a security manager,
 its &lt;code&gt;checkListen&lt;/code&gt; method is called
 with the &lt;code&gt;port&lt;/code&gt; argument
 as its argument to ensure the operation is allowed.
 This could result in a SecurityException.</description>
					<attribute name="@param">
						<description>port  the port number, or &lt;code&gt;0&lt;/code&gt; to use any
                   free port.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs when opening the socket.</description>
					</attribute>
					<attribute name="@exception">
						<description>SecurityException
 if a security manager exists and its &lt;code&gt;checkListen&lt;/code&gt;
 method doesn&apos;t allow the operation.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.SocketImpl</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.SocketImplFactory#createSocketImpl()</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.ServerSocket#setSocketFactory(java.net.SocketImplFactory)</description>
					</attribute>
					<attribute name="@see">
						<description>SecurityManager#checkListen</description>
					</attribute>
				</comment>
				<params>
					<param name="port" comment="the port number, or &lt;code&gt;0&lt;/code&gt; to use any
                   free port." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs when opening the socket." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</constructor>
			<constructor visibility="public" name="ServerSocket">
				<comment>
					<description>Creates a server socket and binds it to the specified local port
 number, with the specified backlog.
 A port number of &lt;code&gt;0&lt;/code&gt; creates a socket on any
 free port.
 &lt;p&gt;
 The maximum queue length for incoming connection indications (a
 request to connect) is set to the &lt;code&gt;backlog&lt;/code&gt; parameter. If
 a connection indication arrives when the queue is full, the
 connection is refused.
 &lt;p&gt;
 If the application has specified a server socket factory, that
 factory&apos;s &lt;code&gt;createSocketImpl&lt;/code&gt; method is called to create
 the actual socket implementation. Otherwise a &quot;plain&quot; socket is created.
 &lt;p&gt;
 If there is a security manager,
 its &lt;code&gt;checkListen&lt;/code&gt; method is called
 with the &lt;code&gt;port&lt;/code&gt; argument
 as its argument to ensure the operation is allowed.
 This could result in a SecurityException.

 &lt;P&gt;The &lt;code&gt;backlog&lt;/code&gt; argument must be a positive
 value greater than 0. If the value passed is equal or less
 than 0, then the default value will be assumed.
 &lt;P&gt;</description>
					<attribute name="@param">
						<description>port     the port number, or &lt;code&gt;0&lt;/code&gt; to use
                      any free port.</description>
					</attribute>
					<attribute name="@param">
						<description>backlog  the maximum length of the queue.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs when opening the socket.</description>
					</attribute>
					<attribute name="@exception">
						<description>SecurityException
 if a security manager exists and its &lt;code&gt;checkListen&lt;/code&gt;
 method doesn&apos;t allow the operation.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.SocketImpl</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.SocketImplFactory#createSocketImpl()</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.ServerSocket#setSocketFactory(java.net.SocketImplFactory)</description>
					</attribute>
					<attribute name="@see">
						<description>SecurityManager#checkListen</description>
					</attribute>
				</comment>
				<params>
					<param name="port" comment="the port number, or &lt;code&gt;0&lt;/code&gt; to use
                      any free port." fulltype="int" type="int" />
					<param name="backlog" comment="the maximum length of the queue." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs when opening the socket." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</constructor>
			<constructor visibility="public" name="ServerSocket">
				<comment>
					<description>Create a server with the specified port, listen backlog, and
 local IP address to bind to.  The &lt;i&gt;bindAddr&lt;/i&gt; argument
 can be used on a multi-homed host for a ServerSocket that
 will only accept connect requests to one of its addresses.
 If &lt;i&gt;bindAddr&lt;/i&gt; is null, it will default accepting
 connections on any/all local addresses.
 The port must be between 0 and 65535, inclusive.

 &lt;P&gt;If there is a security manager, this method
 calls its &lt;code&gt;checkListen&lt;/code&gt; method
 with the &lt;code&gt;port&lt;/code&gt; argument
 as its argument to ensure the operation is allowed.
 This could result in a SecurityException.

 &lt;P&gt;The &lt;code&gt;backlog&lt;/code&gt; argument must be a positive
 value greater than 0. If the value passed is equal or less
 than 0, then the default value will be assumed.
 &lt;P&gt;</description>
					<attribute name="@param">
						<description>port the local TCP port</description>
					</attribute>
					<attribute name="@param">
						<description>backlog the listen backlog</description>
					</attribute>
					<attribute name="@param">
						<description>bindAddr the local InetAddress the server will bind to</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException if a security manager exists and
 its &lt;code&gt;checkListen&lt;/code&gt; method doesn&apos;t allow the operation.</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException if an I/O error occurs when opening the socket.</description>
					</attribute>
					<attribute name="@see">
						<description>SocketOptions</description>
					</attribute>
					<attribute name="@see">
						<description>SocketImpl</description>
					</attribute>
					<attribute name="@see">
						<description>SecurityManager#checkListen</description>
					</attribute>
					<attribute name="@since">
						<description>JDK1.1</description>
					</attribute>
				</comment>
				<params>
					<param name="port" comment="the local TCP port" fulltype="int" type="int" />
					<param name="backlog" comment="the listen backlog" fulltype="int" type="int" />
					<param name="bindAddr" comment="the local InetAddress the server will bind to" fulltype="java.net.InetAddress" type="InetAddress" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs when opening the socket." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</constructor>
			<method visibility="package-private" name="getImpl" returncomment="the &lt;code&gt;SocketImpl&lt;/code&gt; attached to that ServerSocket." fulltype="java.net.SocketImpl" type="SocketImpl">
				<comment>
					<description>Get the &lt;code&gt;SocketImpl&lt;/code&gt; attached to this socket, creating
 it if necessary.</description>
					<attribute name="@return">
						<description>the &lt;code&gt;SocketImpl&lt;/code&gt; attached to that ServerSocket.</description>
					</attribute>
					<attribute name="@throws">
						<description>SocketException if creation fails.</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if creation fails." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method visibility="private" name="checkOldImpl" fulltype="void" type="void" />
			<method visibility="private" name="setImpl" fulltype="void" type="void" />
			<method visibility="package-private" name="createImpl" fulltype="void" type="void">
				<comment>
					<description>Creates the socket implementation.</description>
					<attribute name="@throws">
						<description>IOException if creation fails</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
				<exceptions>
					<exception fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method visibility="public" name="bind" fulltype="void" type="void">
				<comment>
					<description>Binds the &lt;code&gt;ServerSocket&lt;/code&gt; to a specific address
 (IP address and port number).
 &lt;p&gt;
 If the address is &lt;code&gt;null&lt;/code&gt;, then the system will pick up
 an ephemeral port and a valid local address to bind the socket.
 &lt;p&gt;</description>
					<attribute name="@param">
						<description>endpoint        The IP address &amp; port number to bind to.</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException if the bind operation fails, or if the socket
                     is already bound.</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException       if a &lt;code&gt;SecurityManager&lt;/code&gt; is present and
 its &lt;code&gt;checkListen&lt;/code&gt; method doesn&apos;t allow the operation.</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if endpoint is a
          SocketAddress subclass not supported by this socket</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
				<params>
					<param name="endpoint" comment="The IP address &amp; port number to bind to." fulltype="java.net.SocketAddress" type="SocketAddress" />
				</params>
				<exceptions>
					<exception comment="if the bind operation fails, or if the socket
                     is already bound." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="bind" fulltype="void" type="void">
				<comment>
					<description>Binds the &lt;code&gt;ServerSocket&lt;/code&gt; to a specific address
 (IP address and port number).
 &lt;p&gt;
 If the address is &lt;code&gt;null&lt;/code&gt;, then the system will pick up
 an ephemeral port and a valid local address to bind the socket.
 &lt;P&gt;
 The &lt;code&gt;backlog&lt;/code&gt; argument must be a positive
 value greater than 0. If the value passed is equal or less
 than 0, then the default value will be assumed.</description>
					<attribute name="@param">
						<description>endpoint        The IP address &amp; port number to bind to.</description>
					</attribute>
					<attribute name="@param">
						<description>backlog         The listen backlog length.</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException if the bind operation fails, or if the socket
                     is already bound.</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException       if a &lt;code&gt;SecurityManager&lt;/code&gt; is present and
 its &lt;code&gt;checkListen&lt;/code&gt; method doesn&apos;t allow the operation.</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if endpoint is a
          SocketAddress subclass not supported by this socket</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
				<params>
					<param name="endpoint" comment="The IP address &amp; port number to bind to." fulltype="java.net.SocketAddress" type="SocketAddress" />
					<param name="backlog" comment="The listen backlog length." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if the bind operation fails, or if the socket
                     is already bound." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="getInetAddress" returncomment="the address to which this socket is bound,
          or &lt;code&gt;null&lt;/code&gt; if the socket is unbound." fulltype="java.net.InetAddress" type="InetAddress">
				<comment>
					<description>Returns the local address of this server socket.</description>
					<attribute name="@return">
						<description>the address to which this socket is bound,
          or &lt;code&gt;null&lt;/code&gt; if the socket is unbound.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getLocalPort" returncomment="the port number to which this socket is listening or
          -1 if the socket is not bound yet." fulltype="int" type="int">
				<comment>
					<description>Returns the port number on which this socket is listening.</description>
					<attribute name="@return">
						<description>the port number to which this socket is listening or
          -1 if the socket is not bound yet.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getLocalSocketAddress" returncomment="a &lt;code&gt;SocketAddress&lt;/code&gt; representing the local endpoint of this
         socket, or &lt;code&gt;null&lt;/code&gt; if it is not bound yet." fulltype="java.net.SocketAddress" type="SocketAddress">
				<comment>
					<description>Returns the address of the endpoint this socket is bound to, or
 &lt;code&gt;null&lt;/code&gt; if it is not bound yet.</description>
					<attribute name="@return">
						<description>a &lt;code&gt;SocketAddress&lt;/code&gt; representing the local endpoint of this
         socket, or &lt;code&gt;null&lt;/code&gt; if it is not bound yet.</description>
					</attribute>
					<attribute name="@see">
						<description>#getInetAddress()</description>
					</attribute>
					<attribute name="@see">
						<description>#getLocalPort()</description>
					</attribute>
					<attribute name="@see">
						<description>#bind(SocketAddress)</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="accept" returncomment="the new Socket" fulltype="java.net.Socket" type="Socket">
				<comment>
					<description>Listens for a connection to be made to this socket and accepts
 it. The method blocks until a connection is made.

 &lt;p&gt;A new Socket &lt;code&gt;s&lt;/code&gt; is created and, if there
 is a security manager,
 the security manager&apos;s &lt;code&gt;checkAccept&lt;/code&gt; method is called
 with &lt;code&gt;s.getInetAddress().getHostAddress()&lt;/code&gt; and
 &lt;code&gt;s.getPort()&lt;/code&gt;
 as its arguments to ensure the operation is allowed.
 This could result in a SecurityException.</description>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs when waiting for a
               connection.</description>
					</attribute>
					<attribute name="@exception">
						<description>SecurityException  if a security manager exists and its
             &lt;code&gt;checkAccept&lt;/code&gt; method doesn&apos;t allow the operation.</description>
					</attribute>
					<attribute name="@exception">
						<description>SocketTimeoutException if a timeout was previously set with setSoTimeout and
             the timeout has been reached.</description>
					</attribute>
					<attribute name="@exception">
						<description>java.nio.channels.IllegalBlockingModeException
             if this socket has an associated channel, the channel is in
             non-blocking mode, and there is no connection ready to be
             accepted</description>
					</attribute>
					<attribute name="@return">
						<description>the new Socket</description>
					</attribute>
					<attribute name="@see">
						<description>SecurityManager#checkAccept</description>
					</attribute>
					<attribute name="@revised">
						<description>1.4</description>
					</attribute>
					<attribute name="@spec">
						<description>JSR-51</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs when waiting for a
               connection." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="protected" name="implAccept" fulltype="void" type="void">
				<comment>
					<description>Subclasses of ServerSocket use this method to override accept()
 to return their own subclass of socket.  So a FooServerSocket
 will typically hand this method an &lt;i&gt;empty&lt;/i&gt; FooSocket.  On
 return from implAccept the FooSocket will be connected to a client.</description>
					<attribute name="@param">
						<description>s the Socket</description>
					</attribute>
					<attribute name="@throws">
						<description>java.nio.channels.IllegalBlockingModeException
         if this socket has an associated channel,
         and the channel is in non-blocking mode</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException if an I/O error occurs when waiting
 for a connection.</description>
					</attribute>
					<attribute name="@since">
						<description>JDK1.1</description>
					</attribute>
					<attribute name="@revised">
						<description>1.4</description>
					</attribute>
					<attribute name="@spec">
						<description>JSR-51</description>
					</attribute>
				</comment>
				<params>
					<param name="s" comment="the Socket" fulltype="java.net.Socket" type="Socket" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs when waiting
 for a connection." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="close" fulltype="void" type="void">
				<comment>
					<description>Closes this socket.

 Any thread currently blocked in {@link #accept()} will throw
 a {@link SocketException}.

 &lt;p&gt; If this socket has an associated channel then the channel is closed
 as well.</description>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs when closing the socket.</description>
					</attribute>
					<attribute name="@revised">
						<description>1.4</description>
					</attribute>
					<attribute name="@spec">
						<description>JSR-51</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs when closing the socket." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="getChannel" returncomment="the server-socket channel associated with this socket,
          or &lt;tt&gt;null&lt;/tt&gt; if this socket was not created
          for a channel" fulltype="java.nio.channels.ServerSocketChannel" type="ServerSocketChannel">
				<comment>
					<description>Returns the unique {@link java.nio.channels.ServerSocketChannel} object
 associated with this socket, if any.

 &lt;p&gt; A server socket will have a channel if, and only if, the channel
 itself was created via the {@link
 java.nio.channels.ServerSocketChannel#open ServerSocketChannel.open}
 method.</description>
					<attribute name="@return">
						<description>the server-socket channel associated with this socket,
          or &lt;tt&gt;null&lt;/tt&gt; if this socket was not created
          for a channel</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
					<attribute name="@spec">
						<description>JSR-51</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="isBound" returncomment="true if the ServerSocket succesfuly bound to an address" fulltype="boolean" type="boolean">
				<comment>
					<description>Returns the binding state of the ServerSocket.</description>
					<attribute name="@return">
						<description>true if the ServerSocket succesfuly bound to an address</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="isClosed" returncomment="true if the socket has been closed" fulltype="boolean" type="boolean">
				<comment>
					<description>Returns the closed state of the ServerSocket.</description>
					<attribute name="@return">
						<description>true if the socket has been closed</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</method>
			<method synchronized="true" visibility="public" name="setSoTimeout" fulltype="void" type="void">
				<comment>
					<description>Enable/disable SO_TIMEOUT with the specified timeout, in
 milliseconds.  With this option set to a non-zero timeout,
 a call to accept() for this ServerSocket
 will block for only this amount of time.  If the timeout expires,
 a &lt;B&gt;java.net.SocketTimeoutException&lt;/B&gt; is raised, though the
 ServerSocket is still valid.  The option &lt;B&gt;must&lt;/B&gt; be enabled
 prior to entering the blocking operation to have effect.  The
 timeout must be &gt; 0.
 A timeout of zero is interpreted as an infinite timeout.</description>
					<attribute name="@param">
						<description>timeout the specified timeout, in milliseconds</description>
					</attribute>
					<attribute name="@exception">
						<description>SocketException if there is an error in
 the underlying protocol, such as a TCP error.</description>
					</attribute>
					<attribute name="@since">
						<description>JDK1.1</description>
					</attribute>
					<attribute name="@see">
						<description>#getSoTimeout()</description>
					</attribute>
				</comment>
				<params>
					<param name="timeout" comment="the specified timeout, in milliseconds" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if there is an error in
 the underlying protocol, such as a TCP error." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="public" name="getSoTimeout" returncomment="the SO_TIMEOUT value" fulltype="int" type="int">
				<comment>
					<description>Retrieve setting for SO_TIMEOUT.  0 returns implies that the
 option is disabled (i.e., timeout of infinity).</description>
					<attribute name="@return">
						<description>the SO_TIMEOUT value</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException if an I/O error occurs</description>
					</attribute>
					<attribute name="@since">
						<description>JDK1.1</description>
					</attribute>
					<attribute name="@see">
						<description>#setSoTimeout(int)</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="setReuseAddress" fulltype="void" type="void">
				<comment>
					<description>Enable/disable the SO_REUSEADDR socket option.
 &lt;p&gt;
 When a TCP connection is closed the connection may remain
 in a timeout state for a period of time after the connection
 is closed (typically known as the &lt;tt&gt;TIME_WAIT&lt;/tt&gt; state
 or &lt;tt&gt;2MSL&lt;/tt&gt; wait state).
 For applications using a well known socket address or port
 it may not be possible to bind a socket to the required
 &lt;tt&gt;SocketAddress&lt;/tt&gt; if there is a connection in the
 timeout state involving the socket address or port.
 &lt;p&gt;
 Enabling &lt;tt&gt;SO_REUSEADDR&lt;/tt&gt; prior to binding the socket
 using {@link #bind(SocketAddress)} allows the socket to be
 bound even though a previous connection is in a timeout
 state.
 &lt;p&gt;
 When a &lt;tt&gt;ServerSocket&lt;/tt&gt; is created the initial setting
 of &lt;tt&gt;SO_REUSEADDR&lt;/tt&gt; is not defined. Applications can
 use {@link #getReuseAddress()} to determine the initial
 setting of &lt;tt&gt;SO_REUSEADDR&lt;/tt&gt;.
 &lt;p&gt;
 The behaviour when &lt;tt&gt;SO_REUSEADDR&lt;/tt&gt; is enabled or
 disabled after a socket is bound (See {@link #isBound()})
 is not defined.</description>
					<attribute name="@param">
						<description>on  whether to enable or disable the socket option</description>
					</attribute>
					<attribute name="@exception">
						<description>SocketException if an error occurs enabling or
            disabling the &lt;tt&gt;SO_RESUEADDR&lt;/tt&gt; socket option,
            or the socket is closed.</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
					<attribute name="@see">
						<description>#getReuseAddress()</description>
					</attribute>
					<attribute name="@see">
						<description>#bind(SocketAddress)</description>
					</attribute>
					<attribute name="@see">
						<description>#isBound()</description>
					</attribute>
					<attribute name="@see">
						<description>#isClosed()</description>
					</attribute>
				</comment>
				<params>
					<param name="on" comment="whether to enable or disable the socket option" fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception comment="if an error occurs enabling or
            disabling the &lt;tt&gt;SO_RESUEADDR&lt;/tt&gt; socket option,
            or the socket is closed." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method visibility="public" name="getReuseAddress" returncomment="a &lt;code&gt;boolean&lt;/code&gt; indicating whether or not SO_REUSEADDR is enabled." fulltype="boolean" type="boolean">
				<comment>
					<description>Tests if SO_REUSEADDR is enabled.</description>
					<attribute name="@return">
						<description>a &lt;code&gt;boolean&lt;/code&gt; indicating whether or not SO_REUSEADDR is enabled.</description>
					</attribute>
					<attribute name="@exception">
						<description>SocketException if there is an error
 in the underlying protocol, such as a TCP error.</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
					<attribute name="@see">
						<description>#setReuseAddress(boolean)</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if there is an error
 in the underlying protocol, such as a TCP error." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method visibility="public" name="toString" returncomment="a string representation of this socket." fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the implementation address and implementation port of
 this socket as a &lt;code&gt;String&lt;/code&gt;.</description>
					<attribute name="@return">
						<description>a string representation of this socket.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="package-private" name="setBound" fulltype="void" type="void" />
			<method visibility="package-private" name="setCreated" fulltype="void" type="void" />
			<method static="true" synchronized="true" visibility="public" name="setSocketFactory" fulltype="void" type="void">
				<comment>
					<description>Sets the server socket implementation factory for the
 application. The factory can be specified only once.
 &lt;p&gt;
 When an application creates a new server socket, the socket
 implementation factory&apos;s &lt;code&gt;createSocketImpl&lt;/code&gt; method is
 called to create the actual socket implementation.
 &lt;p&gt;
 Passing &lt;code&gt;null&lt;/code&gt; to the method is a no-op unless the factory
 was already set.
 &lt;p&gt;
 If there is a security manager, this method first calls
 the security manager&apos;s &lt;code&gt;checkSetFactory&lt;/code&gt; method
 to ensure the operation is allowed.
 This could result in a SecurityException.</description>
					<attribute name="@param">
						<description>fac   the desired factory.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs when setting the
               socket factory.</description>
					</attribute>
					<attribute name="@exception">
						<description>SocketException  if the factory has already been defined.</description>
					</attribute>
					<attribute name="@exception">
						<description>SecurityException  if a security manager exists and its
             &lt;code&gt;checkSetFactory&lt;/code&gt; method doesn&apos;t allow the operation.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.SocketImplFactory#createSocketImpl()</description>
					</attribute>
					<attribute name="@see">
						<description>SecurityManager#checkSetFactory</description>
					</attribute>
				</comment>
				<params>
					<param name="fac" comment="the desired factory." fulltype="java.net.SocketImplFactory" type="SocketImplFactory" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs when setting the
               socket factory." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="public" name="setReceiveBufferSize" fulltype="void" type="void">
				<comment>
					<description>Sets a default proposed value for the SO_RCVBUF option for sockets
 accepted from this &lt;tt&gt;ServerSocket&lt;/tt&gt;. The value actually set
 in the accepted socket must be determined by calling
 {@link Socket#getReceiveBufferSize()} after the socket
 is returned by {@link #accept()}.
 &lt;p&gt;
 The value of SO_RCVBUF is used both to set the size of the internal
 socket receive buffer, and to set the size of the TCP receive window
 that is advertized to the remote peer.
 &lt;p&gt;
 It is possible to change the value subsequently, by calling
 {@link Socket#setReceiveBufferSize(int)}. However, if the application
 wishes to allow a receive window larger than 64K bytes, as defined by RFC1323
 then the proposed value must be set in the ServerSocket &lt;B&gt;before&lt;/B&gt;
 it is bound to a local address. This implies, that the ServerSocket must be
 created with the no-argument constructor, then setReceiveBufferSize() must
 be called and lastly the ServerSocket is bound to an address by calling bind().
 &lt;p&gt;
 Failure to do this will not cause an error, and the buffer size may be set to the
 requested value but the TCP receive window in sockets accepted from
 this ServerSocket will be no larger than 64K bytes.</description>
					<attribute name="@exception">
						<description>SocketException if there is an error
 in the underlying protocol, such as a TCP error.</description>
					</attribute>
					<attribute name="@param">
						<description>size the size to which to set the receive buffer
 size. This value must be greater than 0.</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if the
 value is 0 or is negative.</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
					<attribute name="@see">
						<description>#getReceiveBufferSize</description>
					</attribute>
				</comment>
				<params>
					<param name="size" comment="the size to which to set the receive buffer
 size. This value must be greater than 0." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if there is an error
 in the underlying protocol, such as a TCP error." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="public" name="getReceiveBufferSize" returncomment="the value of the SO_RCVBUF option for this &lt;tt&gt;Socket&lt;/tt&gt;." fulltype="int" type="int">
				<comment>
					<description>Gets the value of the SO_RCVBUF option for this &lt;tt&gt;ServerSocket&lt;/tt&gt;,
 that is the proposed buffer size that will be used for Sockets accepted
 from this &lt;tt&gt;ServerSocket&lt;/tt&gt;.

 &lt;p&gt;Note, the value actually set in the accepted socket is determined by
 calling {@link Socket#getReceiveBufferSize()}.</description>
					<attribute name="@return">
						<description>the value of the SO_RCVBUF option for this &lt;tt&gt;Socket&lt;/tt&gt;.</description>
					</attribute>
					<attribute name="@exception">
						<description>SocketException if there is an error
 in the underlying protocol, such as a TCP error.</description>
					</attribute>
					<attribute name="@see">
						<description>#setReceiveBufferSize(int)</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if there is an error
 in the underlying protocol, such as a TCP error." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method visibility="public" name="setPerformancePreferences" fulltype="void" type="void">
				<comment>
					<description>Sets performance preferences for this ServerSocket.

 &lt;p&gt; Sockets use the TCP/IP protocol by default.  Some implementations
 may offer alternative protocols which have different performance
 characteristics than TCP/IP.  This method allows the application to
 express its own preferences as to how these tradeoffs should be made
 when the implementation chooses from the available protocols.

 &lt;p&gt; Performance preferences are described by three integers
 whose values indicate the relative importance of short connection time,
 low latency, and high bandwidth.  The absolute values of the integers
 are irrelevant; in order to choose a protocol the values are simply
 compared, with larger values indicating stronger preferences.  If the
 application prefers short connection time over both low latency and high
 bandwidth, for example, then it could invoke this method with the values
 &lt;tt&gt;(1, 0, 0)&lt;/tt&gt;.  If the application prefers high bandwidth above low
 latency, and low latency above short connection time, then it could
 invoke this method with the values &lt;tt&gt;(0, 1, 2)&lt;/tt&gt;.

 &lt;p&gt; Invoking this method after this socket has been bound
 will have no effect. This implies that in order to use this capability
 requires the socket to be created with the no-argument constructor.</description>
					<attribute name="@param">
						<description>connectionTime
         An &lt;tt&gt;int&lt;/tt&gt; expressing the relative importance of a short
         connection time</description>
					</attribute>
					<attribute name="@param">
						<description>latency
         An &lt;tt&gt;int&lt;/tt&gt; expressing the relative importance of low
         latency</description>
					</attribute>
					<attribute name="@param">
						<description>bandwidth
         An &lt;tt&gt;int&lt;/tt&gt; expressing the relative importance of high
         bandwidth</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
				<params>
					<param name="connectionTime" comment="An &lt;tt&gt;int&lt;/tt&gt; expressing the relative importance of a short
         connection time" fulltype="int" type="int" />
					<param name="latency" comment="An &lt;tt&gt;int&lt;/tt&gt; expressing the relative importance of low
         latency" fulltype="int" type="int" />
					<param name="bandwidth" comment="An &lt;tt&gt;int&lt;/tt&gt; expressing the relative importance of high
         bandwidth" fulltype="int" type="int" />
				</params>
			</method>
		</methods>
	</jelclass>
	<jelclass final="true" superclass="Object" visibility="public" package="java.net" superclassfulltype="java.lang.Object" fulltype="java.net.IDN" type="IDN">
		<comment>
			<description>Provides methods to convert internationalized domain names (IDNs) between
 a normal Unicode representation and an ASCII Compatible Encoding (ACE) representation.
 Internationalized domain names can use characters from the entire range of
 Unicode, while traditional domain names are restricted to ASCII characters.
 ACE is an encoding of Unicode strings that uses only ASCII characters and
 can be used with software (such as the Domain Name System) that only
 understands traditional domain names.

 &lt;p&gt;Internationalized domain names are defined in &lt;a href=&quot;http://www.ietf.org/rfc/rfc3490.txt&quot;&gt;RFC 3490&lt;/a&gt;.
 RFC 3490 defines two operations: ToASCII and ToUnicode. These 2 operations employ
 &lt;a href=&quot;http://www.ietf.org/rfc/rfc3491.txt&quot;&gt;Nameprep&lt;/a&gt; algorithm, which is a
 profile of &lt;a href=&quot;http://www.ietf.org/rfc/rfc3454.txt&quot;&gt;Stringprep&lt;/a&gt;, and
 &lt;a href=&quot;http://www.ietf.org/rfc/rfc3492.txt&quot;&gt;Punycode&lt;/a&gt; algorithm to convert
 domain name string back and forth.

 &lt;p&gt;The behavior of aforementioned conversion process can be adjusted by various flags:
   &lt;ul&gt;
     &lt;li&gt;If the ALLOW_UNASSIGNED flag is used, the domain name string to be converted
         can contain code points that are unassigned in Unicode 3.2, which is the
         Unicode version on which IDN conversion is based. If the flag is not used,
         the presence of such unassigned code points is treated as an error.
     &lt;li&gt;If the USE_STD3_ASCII_RULES flag is used, ASCII strings are checked against &lt;a href=&quot;http://www.ietf.org/rfc/rfc1122.txt&quot;&gt;RFC 1122&lt;/a&gt; and &lt;a href=&quot;http://www.ietf.org/rfc/rfc1123.txt&quot;&gt;RFC 1123&lt;/a&gt;.
         It is an error if they don&apos;t meet the requirements.
   &lt;/ul&gt;
 These flags can be logically OR&apos;ed together.

 &lt;p&gt;The security consideration is important with respect to internationalization
 domain name support. For example, English domain names may be &lt;i&gt;homographed&lt;/i&gt;
 - maliciously misspelled by substitution of non-Latin letters.
 &lt;a href=&quot;http://www.unicode.org/reports/tr36/&quot;&gt;Unicode Technical Report #36&lt;/a&gt;
 discusses security issues of IDN support as well as possible solutions.
 Applications are responsible for taking adequate security measures when using
 international domain names.</description>
			<attribute name="@author">
				<description>Edward Wang</description>
			</attribute>
			<attribute name="@since">
				<description>1.6</description>
			</attribute>
		</comment>
		<fields>
			<field final="true" static="true" const="1" visibility="public" name="ALLOW_UNASSIGNED" constexpr="1" fulltype="int" type="int">
				<comment>
					<description>Flag to allow processing of unassigned code points</description>
				</comment>
			</field>
			<field final="true" static="true" const="2" visibility="public" name="USE_STD3_ASCII_RULES" constexpr="2" fulltype="int" type="int">
				<comment>
					<description>Flag to turn on the check against STD-3 ASCII rules</description>
				</comment>
			</field>
			<field final="true" static="true" const="xn--" visibility="private" name="ACE_PREFIX" constexpr="&quot;xn--&quot;" fulltype="java.lang.String" type="String" />
			<field final="true" static="true" visibility="private" name="ACE_PREFIX_LENGTH" fulltype="int" type="int" />
			<field final="true" static="true" const="63" visibility="private" name="MAX_LABEL_LENGTH" constexpr="63" fulltype="int" type="int" />
			<field static="true" visibility="private" name="namePrep" fulltype="StringPrep" type="StringPrep" />
		</fields>
		<methods>
			<constructor visibility="private" name="IDN" />
			<method static="true" visibility="public" name="toASCII" returncomment="the translated &lt;tt&gt;String&lt;/tt&gt;" fulltype="java.lang.String" type="String">
				<comment>
					<description>Translates a string from Unicode to ASCII Compatible Encoding (ACE),
 as defined by the ToASCII operation of &lt;a href=&quot;http://www.ietf.org/rfc/rfc3490.txt&quot;&gt;RFC 3490&lt;/a&gt;.

 &lt;p&gt;ToASCII operation can fail. ToASCII fails if any step of it fails.
 If ToASCII operation fails, an IllegalArgumentException will be thrown.
 In this case, the input string should not be used in an internationalized domain name.

 &lt;p&gt; A label is an individual part of a domain name. The original ToASCII operation,
 as defined in RFC 3490, only operates on a single label. This method can handle
 both label and entire domain name, by assuming that labels in a domain name are
 always separated by dots. The following characters are recognized as dots:
 &amp;#0092;u002E (full stop), &amp;#0092;u3002 (ideographic full stop), &amp;#0092;uFF0E (fullwidth full stop),
 and &amp;#0092;uFF61 (halfwidth ideographic full stop). if dots are
 used as label separators, this method also changes all of them to &amp;#0092;u002E (full stop)
 in output translated string.</description>
					<attribute name="@param">
						<description>input     the string to be processed</description>
					</attribute>
					<attribute name="@param">
						<description>flag      process flag; can be 0 or any logical OR of possible flags</description>
					</attribute>
					<attribute name="@return">
						<description>the translated &lt;tt&gt;String&lt;/tt&gt;</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException   if the input string doesn&apos;t conform to RFC 3490 specification</description>
					</attribute>
				</comment>
				<params>
					<param name="input" comment="the string to be processed" fulltype="java.lang.String" type="String" />
					<param name="flag" comment="process flag; can be 0 or any logical OR of possible flags" fulltype="int" type="int" />
				</params>
			</method>
			<method static="true" visibility="public" name="toASCII" returncomment="the translated &lt;tt&gt;String&lt;/tt&gt;" fulltype="java.lang.String" type="String">
				<comment>
					<description>Translates a string from Unicode to ASCII Compatible Encoding (ACE),
 as defined by the ToASCII operation of &lt;a href=&quot;http://www.ietf.org/rfc/rfc3490.txt&quot;&gt;RFC 3490&lt;/a&gt;.

 &lt;p&gt; This convenience method works as if by invoking the
 two-argument counterpart as follows:
 &lt;blockquote&gt;&lt;tt&gt;
 {@link #toASCII(String, int) toASCII}(input,&amp;nbsp;0);
 &lt;/tt&gt;&lt;/blockquote&gt;</description>
					<attribute name="@param">
						<description>input     the string to be processed</description>
					</attribute>
					<attribute name="@return">
						<description>the translated &lt;tt&gt;String&lt;/tt&gt;</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException   if the input string doesn&apos;t conform to RFC 3490 specification</description>
					</attribute>
				</comment>
				<params>
					<param name="input" comment="the string to be processed" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method static="true" visibility="public" name="toUnicode" returncomment="the translated &lt;tt&gt;String&lt;/tt&gt;" fulltype="java.lang.String" type="String">
				<comment>
					<description>Translates a string from ASCII Compatible Encoding (ACE) to Unicode,
 as defined by the ToUnicode operation of &lt;a href=&quot;http://www.ietf.org/rfc/rfc3490.txt&quot;&gt;RFC 3490&lt;/a&gt;.

 &lt;p&gt;ToUnicode never fails. In case of any error, the input string is returned unmodified.

 &lt;p&gt; A label is an individual part of a domain name. The original ToUnicode operation,
 as defined in RFC 3490, only operates on a single label. This method can handle
 both label and entire domain name, by assuming that labels in a domain name are
 always separated by dots. The following characters are recognized as dots:
 &amp;#0092;u002E (full stop), &amp;#0092;u3002 (ideographic full stop), &amp;#0092;uFF0E (fullwidth full stop),
 and &amp;#0092;uFF61 (halfwidth ideographic full stop).</description>
					<attribute name="@param">
						<description>input     the string to be processed</description>
					</attribute>
					<attribute name="@param">
						<description>flag      process flag; can be 0 or any logical OR of possible flags</description>
					</attribute>
					<attribute name="@return">
						<description>the translated &lt;tt&gt;String&lt;/tt&gt;</description>
					</attribute>
				</comment>
				<params>
					<param name="input" comment="the string to be processed" fulltype="java.lang.String" type="String" />
					<param name="flag" comment="process flag; can be 0 or any logical OR of possible flags" fulltype="int" type="int" />
				</params>
			</method>
			<method static="true" visibility="public" name="toUnicode" returncomment="the translated &lt;tt&gt;String&lt;/tt&gt;" fulltype="java.lang.String" type="String">
				<comment>
					<description>Translates a string from ASCII Compatible Encoding (ACE) to Unicode,
 as defined by the ToUnicode operation of &lt;a href=&quot;http://www.ietf.org/rfc/rfc3490.txt&quot;&gt;RFC 3490&lt;/a&gt;.

 &lt;p&gt; This convenience method works as if by invoking the
 two-argument counterpart as follows:
 &lt;blockquote&gt;&lt;tt&gt;
 {@link #toUnicode(String, int) toUnicode}(input,&amp;nbsp;0);
 &lt;/tt&gt;&lt;/blockquote&gt;</description>
					<attribute name="@param">
						<description>input     the string to be processed</description>
					</attribute>
					<attribute name="@return">
						<description>the translated &lt;tt&gt;String&lt;/tt&gt;</description>
					</attribute>
				</comment>
				<params>
					<param name="input" comment="the string to be processed" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method static="true" visibility="private" name="toASCIIInternal" fulltype="java.lang.String" type="String">
				<params>
					<param name="label" fulltype="java.lang.String" type="String" />
					<param name="flag" fulltype="int" type="int" />
				</params>
			</method>
			<method static="true" visibility="private" name="toUnicodeInternal" fulltype="java.lang.String" type="String">
				<params>
					<param name="label" fulltype="java.lang.String" type="String" />
					<param name="flag" fulltype="int" type="int" />
				</params>
			</method>
			<method static="true" visibility="private" name="isLDHChar" fulltype="boolean" type="boolean">
				<params>
					<param name="ch" fulltype="int" type="int" />
				</params>
			</method>
			<method static="true" visibility="private" name="searchDots" fulltype="int" type="int">
				<params>
					<param name="s" fulltype="java.lang.String" type="String" />
					<param name="start" fulltype="int" type="int" />
				</params>
			</method>
			<method static="true" visibility="private" name="isAllASCII" fulltype="boolean" type="boolean">
				<params>
					<param name="input" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method static="true" visibility="private" name="startsWithACEPrefix" fulltype="boolean" type="boolean">
				<params>
					<param name="input" fulltype="java.lang.StringBuffer" type="StringBuffer" />
				</params>
			</method>
			<method static="true" visibility="private" name="toASCIILower" fulltype="char" type="char">
				<params>
					<param name="ch" fulltype="char" type="char" />
				</params>
			</method>
			<method static="true" visibility="private" name="toASCIILower" fulltype="java.lang.StringBuffer" type="StringBuffer">
				<params>
					<param name="input" fulltype="java.lang.StringBuffer" type="StringBuffer" />
				</params>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="Exception" visibility="public" package="java.net" serializable="true" superclassfulltype="java.lang.Exception" fulltype="java.net.URISyntaxException" type="URISyntaxException">
		<comment>
			<description>Checked exception thrown to indicate that a string could not be parsed as a
 URI reference.</description>
			<attribute name="@author">
				<description>Mark Reinhold</description>
			</attribute>
			<attribute name="@see">
				<description>URI</description>
			</attribute>
			<attribute name="@since">
				<description>1.4</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="private" name="input" fulltype="java.lang.String" type="String" />
			<field visibility="private" name="index" fulltype="int" type="int" />
		</fields>
		<methods>
			<constructor visibility="public" name="URISyntaxException">
				<comment>
					<description>Constructs an instance from the given input string, reason, and error
 index.</description>
					<attribute name="@param">
						<description>input   The input string</description>
					</attribute>
					<attribute name="@param">
						<description>reason  A string explaining why the input could not be parsed</description>
					</attribute>
					<attribute name="@param">
						<description>index   The index at which the parse error occurred,
                 or &lt;tt&gt;-1&lt;/tt&gt; if the index is not known</description>
					</attribute>
					<attribute name="@throws">
						<description>NullPointerException
          If either the input or reason strings are &lt;tt&gt;null&lt;/tt&gt;</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException
          If the error index is less than &lt;tt&gt;-1&lt;/tt&gt;</description>
					</attribute>
				</comment>
				<params>
					<param name="input" comment="The input string" fulltype="java.lang.String" type="String" />
					<param name="reason" comment="A string explaining why the input could not be parsed" fulltype="java.lang.String" type="String" />
					<param name="index" comment="The index at which the parse error occurred,
                 or &lt;tt&gt;-1&lt;/tt&gt; if the index is not known" fulltype="int" type="int" />
				</params>
			</constructor>
			<constructor visibility="public" name="URISyntaxException">
				<comment>
					<description>Constructs an instance from the given input string and reason.  The
 resulting object will have an error index of &lt;tt&gt;-1&lt;/tt&gt;.</description>
					<attribute name="@param">
						<description>input   The input string</description>
					</attribute>
					<attribute name="@param">
						<description>reason  A string explaining why the input could not be parsed</description>
					</attribute>
					<attribute name="@throws">
						<description>NullPointerException
          If either the input or reason strings are &lt;tt&gt;null&lt;/tt&gt;</description>
					</attribute>
				</comment>
				<params>
					<param name="input" comment="The input string" fulltype="java.lang.String" type="String" />
					<param name="reason" comment="A string explaining why the input could not be parsed" fulltype="java.lang.String" type="String" />
				</params>
			</constructor>
			<method visibility="public" name="getInput" returncomment="The input string" fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the input string.</description>
					<attribute name="@return">
						<description>The input string</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getReason" returncomment="The reason string" fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns a string explaining why the input string could not be parsed.</description>
					<attribute name="@return">
						<description>The reason string</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getIndex" returncomment="The error index" fulltype="int" type="int">
				<comment>
					<description>Returns an index into the input string of the position at which the
 parse error occurred, or &lt;tt&gt;-1&lt;/tt&gt; if this position is not known.</description>
					<attribute name="@return">
						<description>The error index</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getMessage" returncomment="A string describing the parse error" fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns a string describing the parse error.  The resulting string
 consists of the reason string followed by a colon character
 (&lt;tt&gt;&apos;:&apos;&lt;/tt&gt;), a space, and the input string.  If the error index is
 defined then the string &lt;tt&gt;&quot; at index &quot;&lt;/tt&gt; followed by the index, in
 decimal, is inserted after the reason string and before the colon
 character.</description>
					<attribute name="@return">
						<description>A string describing the parse error</description>
					</attribute>
				</comment>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="DatagramSocket" visibility="public" package="java.net" superclassfulltype="java.net.DatagramSocket" fulltype="java.net.MulticastSocket" type="MulticastSocket">
		<comment>
			<description>The multicast datagram socket class is useful for sending
 and receiving IP multicast packets.  A MulticastSocket is
 a (UDP) DatagramSocket, with additional capabilities for
 joining &quot;groups&quot; of other multicast hosts on the internet.
 &lt;P&gt;
 A multicast group is specified by a class D IP address
 and by a standard UDP port number. Class D IP addresses
 are in the range &lt;CODE&gt;224.0.0.0&lt;/CODE&gt; to &lt;CODE&gt;239.255.255.255&lt;/CODE&gt;,
 inclusive. The address 224.0.0.0 is reserved and should not be used.
 &lt;P&gt;
 One would join a multicast group by first creating a MulticastSocket
 with the desired port, then invoking the
 &lt;CODE&gt;joinGroup(InetAddress groupAddr)&lt;/CODE&gt;
 method:
 &lt;PRE&gt;
 // join a Multicast group and send the group salutations
 ...
 String msg = &quot;Hello&quot;;
 InetAddress group = InetAddress.getByName(&quot;228.5.6.7&quot;);
 MulticastSocket s = new MulticastSocket(6789);
 s.joinGroup(group);
 DatagramPacket hi = new DatagramPacket(msg.getBytes(), msg.length(),
                             group, 6789);
 s.send(hi);
 // get their responses!
 byte[] buf = new byte[1000];
 DatagramPacket recv = new DatagramPacket(buf, buf.length);
 s.receive(recv);
 ...
 // OK, I&apos;m done talking - leave the group...
 s.leaveGroup(group);
 &lt;/PRE&gt;

 When one sends a message to a multicast group, &lt;B&gt;all&lt;/B&gt; subscribing
 recipients to that host and port receive the message (within the
 time-to-live range of the packet, see below).  The socket needn&apos;t
 be a member of the multicast group to send messages to it.
 &lt;P&gt;
 When a socket subscribes to a multicast group/port, it receives
 datagrams sent by other hosts to the group/port, as do all other
 members of the group and port.  A socket relinquishes membership
 in a group by the leaveGroup(InetAddress addr) method.  &lt;B&gt;
 Multiple MulticastSocket&apos;s&lt;/B&gt; may subscribe to a multicast group
 and port concurrently, and they will all receive group datagrams.
 &lt;P&gt;
 Currently applets are not allowed to use multicast sockets.</description>
			<attribute name="@author">
				<description>Pavani Diwanji</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.1</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="private" name="ttlLock" fulltype="java.lang.Object" type="Object">
				<comment>
					<description>The lock on the socket&apos;s TTL. This is for set/getTTL and
 send(packet,ttl).</description>
				</comment>
			</field>
			<field visibility="private" name="infLock" fulltype="java.lang.Object" type="Object">
				<comment>
					<description>The lock on the socket&apos;s interface - used by setInterface
 and getInterface</description>
				</comment>
			</field>
			<field visibility="private" name="infAddress" fulltype="java.net.InetAddress" type="InetAddress">
				<comment>
					<description>The &quot;last&quot; interface set by setInterface on this MulticastSocket</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="public" name="MulticastSocket">
				<comment>
					<description>Create a multicast socket.

 &lt;p&gt;If there is a security manager,
 its &lt;code&gt;checkListen&lt;/code&gt; method is first called
 with 0 as its argument to ensure the operation is allowed.
 This could result in a SecurityException.
 &lt;p&gt;
 When the socket is created the
 {@link DatagramSocket#setReuseAddress(boolean)} method is
 called to enable the SO_REUSEADDR socket option.</description>
					<attribute name="@exception">
						<description>IOException if an I/O exception occurs
 while creating the MulticastSocket</description>
					</attribute>
					<attribute name="@exception">
						<description>SecurityException  if a security manager exists and its
             &lt;code&gt;checkListen&lt;/code&gt; method doesn&apos;t allow the operation.</description>
					</attribute>
					<attribute name="@see">
						<description>SecurityManager#checkListen</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.DatagramSocket#setReuseAddress(boolean)</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O exception occurs
 while creating the MulticastSocket" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</constructor>
			<constructor visibility="public" name="MulticastSocket">
				<comment>
					<description>Create a multicast socket and bind it to a specific port.

 &lt;p&gt;If there is a security manager,
 its &lt;code&gt;checkListen&lt;/code&gt; method is first called
 with the &lt;code&gt;port&lt;/code&gt; argument
 as its argument to ensure the operation is allowed.
 This could result in a SecurityException.
 &lt;p&gt;
 When the socket is created the
 {@link DatagramSocket#setReuseAddress(boolean)} method is
 called to enable the SO_REUSEADDR socket option.</description>
					<attribute name="@param">
						<description>port port to use</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException if an I/O exception occurs
 while creating the MulticastSocket</description>
					</attribute>
					<attribute name="@exception">
						<description>SecurityException  if a security manager exists and its
             &lt;code&gt;checkListen&lt;/code&gt; method doesn&apos;t allow the operation.</description>
					</attribute>
					<attribute name="@see">
						<description>SecurityManager#checkListen</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.DatagramSocket#setReuseAddress(boolean)</description>
					</attribute>
				</comment>
				<params>
					<param name="port" comment="port to use" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if an I/O exception occurs
 while creating the MulticastSocket" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</constructor>
			<constructor visibility="public" name="MulticastSocket">
				<comment>
					<description>Create a MulticastSocket bound to the specified socket address.
 &lt;p&gt;
 Or, if the address is &lt;code&gt;null&lt;/code&gt;, create an unbound socket.
 &lt;p&gt;
 &lt;p&gt;If there is a security manager,
 its &lt;code&gt;checkListen&lt;/code&gt; method is first called
 with the SocketAddress port as its argument to ensure the operation is allowed.
 This could result in a SecurityException.
 &lt;p&gt;
 When the socket is created the
 {@link DatagramSocket#setReuseAddress(boolean)} method is
 called to enable the SO_REUSEADDR socket option.</description>
					<attribute name="@param">
						<description>bindaddr Socket address to bind to, or &lt;code&gt;null&lt;/code&gt; for
                 an unbound socket.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException if an I/O exception occurs
 while creating the MulticastSocket</description>
					</attribute>
					<attribute name="@exception">
						<description>SecurityException  if a security manager exists and its
             &lt;code&gt;checkListen&lt;/code&gt; method doesn&apos;t allow the operation.</description>
					</attribute>
					<attribute name="@see">
						<description>SecurityManager#checkListen</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.DatagramSocket#setReuseAddress(boolean)</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
				<params>
					<param name="bindaddr" comment="Socket address to bind to, or &lt;code&gt;null&lt;/code&gt; for
                 an unbound socket." fulltype="java.net.SocketAddress" type="SocketAddress" />
				</params>
				<exceptions>
					<exception comment="if an I/O exception occurs
 while creating the MulticastSocket" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</constructor>
			<method visibility="public" name="setTTL" fulltype="void" type="void">
				<comment>
					<description>Set the default time-to-live for multicast packets sent out
 on this &lt;code&gt;MulticastSocket&lt;/code&gt; in order to control the
 scope of the multicasts.

 &lt;p&gt;The ttl is an &lt;b&gt;unsigned&lt;/b&gt; 8-bit quantity, and so &lt;B&gt;must&lt;/B&gt; be
 in the range &lt;code&gt; 0 &lt;= ttl &lt;= 0xFF &lt;/code&gt;.</description>
					<attribute name="@param">
						<description>ttl the time-to-live</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException if an I/O exception occurs
 while setting the default time-to-live value</description>
					</attribute>
					<attribute name="@deprecated">
						<description>use the setTimeToLive method instead, which uses
 &lt;b&gt;int&lt;/b&gt; instead of &lt;b&gt;byte&lt;/b&gt; as the type for ttl.</description>
					</attribute>
					<attribute name="@see">
						<description>#getTTL()</description>
					</attribute>
				</comment>
				<params>
					<param name="ttl" comment="the time-to-live" fulltype="byte" type="byte" />
				</params>
				<exceptions>
					<exception comment="if an I/O exception occurs
 while setting the default time-to-live value" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="setTimeToLive" fulltype="void" type="void">
				<comment>
					<description>Set the default time-to-live for multicast packets sent out
 on this {@code MulticastSocket} in order to control the
 scope of the multicasts.

 &lt;P&gt; The ttl &lt;B&gt;must&lt;/B&gt; be in the range {@code  0 &lt;= ttl &lt;=
 255} or an {@code IllegalArgumentException} will be thrown.</description>
					<attribute name="@param">
						<description>ttl
         the time-to-live</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException
          if an I/O exception occurs while setting the
          default time-to-live value</description>
					</attribute>
					<attribute name="@see">
						<description>#getTimeToLive()</description>
					</attribute>
				</comment>
				<params>
					<param name="ttl" comment="the time-to-live" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if an I/O exception occurs while setting the
          default time-to-live value" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="getTTL" returncomment="the default time-to-live value" fulltype="byte" type="byte">
				<comment>
					<description>Get the default time-to-live for multicast packets sent out on
 the socket.</description>
					<attribute name="@exception">
						<description>IOException if an I/O exception occurs
 while getting the default time-to-live value</description>
					</attribute>
					<attribute name="@return">
						<description>the default time-to-live value</description>
					</attribute>
					<attribute name="@deprecated">
						<description>use the getTimeToLive method instead, which returns
 an &lt;b&gt;int&lt;/b&gt; instead of a &lt;b&gt;byte&lt;/b&gt;.</description>
					</attribute>
					<attribute name="@see">
						<description>#setTTL(byte)</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O exception occurs
 while getting the default time-to-live value" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="getTimeToLive" returncomment="the default time-to-live value" fulltype="int" type="int">
				<comment>
					<description>Get the default time-to-live for multicast packets sent out on
 the socket.</description>
					<attribute name="@exception">
						<description>IOException if an I/O exception occurs while
 getting the default time-to-live value</description>
					</attribute>
					<attribute name="@return">
						<description>the default time-to-live value</description>
					</attribute>
					<attribute name="@see">
						<description>#setTimeToLive(int)</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O exception occurs while
 getting the default time-to-live value" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="joinGroup" fulltype="void" type="void">
				<comment>
					<description>Joins a multicast group. Its behavior may be affected by
 &lt;code&gt;setInterface&lt;/code&gt; or &lt;code&gt;setNetworkInterface&lt;/code&gt;.

 &lt;p&gt;If there is a security manager, this method first
 calls its &lt;code&gt;checkMulticast&lt;/code&gt; method
 with the &lt;code&gt;mcastaddr&lt;/code&gt; argument
 as its argument.</description>
					<attribute name="@param">
						<description>mcastaddr is the multicast address to join</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException if there is an error joining
 or when the address is not a multicast address.</description>
					</attribute>
					<attribute name="@exception">
						<description>SecurityException  if a security manager exists and its
 &lt;code&gt;checkMulticast&lt;/code&gt; method doesn&apos;t allow the join.</description>
					</attribute>
					<attribute name="@see">
						<description>SecurityManager#checkMulticast(InetAddress)</description>
					</attribute>
				</comment>
				<params>
					<param name="mcastaddr" comment="is the multicast address to join" fulltype="java.net.InetAddress" type="InetAddress" />
				</params>
				<exceptions>
					<exception comment="if there is an error joining
 or when the address is not a multicast address." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="leaveGroup" fulltype="void" type="void">
				<comment>
					<description>Leave a multicast group. Its behavior may be affected by
 &lt;code&gt;setInterface&lt;/code&gt; or &lt;code&gt;setNetworkInterface&lt;/code&gt;.

 &lt;p&gt;If there is a security manager, this method first
 calls its &lt;code&gt;checkMulticast&lt;/code&gt; method
 with the &lt;code&gt;mcastaddr&lt;/code&gt; argument
 as its argument.</description>
					<attribute name="@param">
						<description>mcastaddr is the multicast address to leave</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException if there is an error leaving
 or when the address is not a multicast address.</description>
					</attribute>
					<attribute name="@exception">
						<description>SecurityException  if a security manager exists and its
 &lt;code&gt;checkMulticast&lt;/code&gt; method doesn&apos;t allow the operation.</description>
					</attribute>
					<attribute name="@see">
						<description>SecurityManager#checkMulticast(InetAddress)</description>
					</attribute>
				</comment>
				<params>
					<param name="mcastaddr" comment="is the multicast address to leave" fulltype="java.net.InetAddress" type="InetAddress" />
				</params>
				<exceptions>
					<exception comment="if there is an error leaving
 or when the address is not a multicast address." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="joinGroup" fulltype="void" type="void">
				<comment>
					<description>Joins the specified multicast group at the specified interface.

 &lt;p&gt;If there is a security manager, this method first
 calls its &lt;code&gt;checkMulticast&lt;/code&gt; method
 with the &lt;code&gt;mcastaddr&lt;/code&gt; argument
 as its argument.</description>
					<attribute name="@param">
						<description>mcastaddr is the multicast address to join</description>
					</attribute>
					<attribute name="@param">
						<description>netIf specifies the local interface to receive multicast
        datagram packets, or &lt;i&gt;null&lt;/i&gt; to defer to the interface set by
       {@link MulticastSocket#setInterface(InetAddress)} or
       {@link MulticastSocket#setNetworkInterface(NetworkInterface)}</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException if there is an error joining
 or when the address is not a multicast address.</description>
					</attribute>
					<attribute name="@exception">
						<description>SecurityException  if a security manager exists and its
 &lt;code&gt;checkMulticast&lt;/code&gt; method doesn&apos;t allow the join.</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if mcastaddr is null or is a
          SocketAddress subclass not supported by this socket</description>
					</attribute>
					<attribute name="@see">
						<description>SecurityManager#checkMulticast(InetAddress)</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
				<params>
					<param name="mcastaddr" comment="is the multicast address to join" fulltype="java.net.SocketAddress" type="SocketAddress" />
					<param name="netIf" comment="specifies the local interface to receive multicast
        datagram packets, or &lt;i&gt;null&lt;/i&gt; to defer to the interface set by
       {@link MulticastSocket#setInterface(InetAddress)} or
       {@link MulticastSocket#setNetworkInterface(NetworkInterface)}" fulltype="java.net.NetworkInterface" type="NetworkInterface" />
				</params>
				<exceptions>
					<exception comment="if there is an error joining
 or when the address is not a multicast address." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="leaveGroup" fulltype="void" type="void">
				<comment>
					<description>Leave a multicast group on a specified local interface.

 &lt;p&gt;If there is a security manager, this method first
 calls its &lt;code&gt;checkMulticast&lt;/code&gt; method
 with the &lt;code&gt;mcastaddr&lt;/code&gt; argument
 as its argument.</description>
					<attribute name="@param">
						<description>mcastaddr is the multicast address to leave</description>
					</attribute>
					<attribute name="@param">
						<description>netIf specifies the local interface or &lt;i&gt;null&lt;/i&gt; to defer
             to the interface set by
             {@link MulticastSocket#setInterface(InetAddress)} or
             {@link MulticastSocket#setNetworkInterface(NetworkInterface)}</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException if there is an error leaving
 or when the address is not a multicast address.</description>
					</attribute>
					<attribute name="@exception">
						<description>SecurityException  if a security manager exists and its
 &lt;code&gt;checkMulticast&lt;/code&gt; method doesn&apos;t allow the operation.</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if mcastaddr is null or is a
          SocketAddress subclass not supported by this socket</description>
					</attribute>
					<attribute name="@see">
						<description>SecurityManager#checkMulticast(InetAddress)</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
				<params>
					<param name="mcastaddr" comment="is the multicast address to leave" fulltype="java.net.SocketAddress" type="SocketAddress" />
					<param name="netIf" comment="specifies the local interface or &lt;i&gt;null&lt;/i&gt; to defer
             to the interface set by
             {@link MulticastSocket#setInterface(InetAddress)} or
             {@link MulticastSocket#setNetworkInterface(NetworkInterface)}" fulltype="java.net.NetworkInterface" type="NetworkInterface" />
				</params>
				<exceptions>
					<exception comment="if there is an error leaving
 or when the address is not a multicast address." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="setInterface" fulltype="void" type="void">
				<comment>
					<description>Set the multicast network interface used by methods
 whose behavior would be affected by the value of the
 network interface. Useful for multihomed hosts.</description>
					<attribute name="@param">
						<description>inf the InetAddress</description>
					</attribute>
					<attribute name="@exception">
						<description>SocketException if there is an error in
 the underlying protocol, such as a TCP error.</description>
					</attribute>
					<attribute name="@see">
						<description>#getInterface()</description>
					</attribute>
				</comment>
				<params>
					<param name="inf" comment="the InetAddress" fulltype="java.net.InetAddress" type="InetAddress" />
				</params>
				<exceptions>
					<exception comment="if there is an error in
 the underlying protocol, such as a TCP error." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method visibility="public" name="getInterface" returncomment="An &lt;code&gt;InetAddress&lt;/code&gt; representing
  the address of the network interface used for
  multicast packets." fulltype="java.net.InetAddress" type="InetAddress">
				<comment>
					<description>Retrieve the address of the network interface used for
 multicast packets.</description>
					<attribute name="@return">
						<description>An &lt;code&gt;InetAddress&lt;/code&gt; representing
  the address of the network interface used for
  multicast packets.</description>
					</attribute>
					<attribute name="@exception">
						<description>SocketException if there is an error in
 the underlying protocol, such as a TCP error.</description>
					</attribute>
					<attribute name="@see">
						<description>#setInterface(java.net.InetAddress)</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if there is an error in
 the underlying protocol, such as a TCP error." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method visibility="public" name="setNetworkInterface" fulltype="void" type="void">
				<comment>
					<description>Specify the network interface for outgoing multicast datagrams
 sent on this socket.</description>
					<attribute name="@param">
						<description>netIf the interface</description>
					</attribute>
					<attribute name="@exception">
						<description>SocketException if there is an error in
 the underlying protocol, such as a TCP error.</description>
					</attribute>
					<attribute name="@see">
						<description>#getNetworkInterface()</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
				<params>
					<param name="netIf" comment="the interface" fulltype="java.net.NetworkInterface" type="NetworkInterface" />
				</params>
				<exceptions>
					<exception comment="if there is an error in
 the underlying protocol, such as a TCP error." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method visibility="public" name="getNetworkInterface" returncomment="the multicast &lt;code&gt;NetworkInterface&lt;/code&gt; currently set" fulltype="java.net.NetworkInterface" type="NetworkInterface">
				<comment>
					<description>Get the multicast network interface set.</description>
					<attribute name="@exception">
						<description>SocketException if there is an error in
 the underlying protocol, such as a TCP error.</description>
					</attribute>
					<attribute name="@return">
						<description>the multicast &lt;code&gt;NetworkInterface&lt;/code&gt; currently set</description>
					</attribute>
					<attribute name="@see">
						<description>#setNetworkInterface(NetworkInterface)</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if there is an error in
 the underlying protocol, such as a TCP error." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method visibility="public" name="setLoopbackMode" fulltype="void" type="void">
				<comment>
					<description>Disable/Enable local loopback of multicast datagrams
 The option is used by the platform&apos;s networking code as a hint
 for setting whether multicast data will be looped back to
 the local socket.

 &lt;p&gt;Because this option is a hint, applications that want to
 verify what loopback mode is set to should call
 {@link #getLoopbackMode()}</description>
					<attribute name="@param">
						<description>disable &lt;code&gt;true&lt;/code&gt; to disable the LoopbackMode</description>
					</attribute>
					<attribute name="@throws">
						<description>SocketException if an error occurs while setting the value</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
					<attribute name="@see">
						<description>#getLoopbackMode</description>
					</attribute>
				</comment>
				<params>
					<param name="disable" comment="&lt;code&gt;true&lt;/code&gt; to disable the LoopbackMode" fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception comment="if an error occurs while setting the value" fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method visibility="public" name="getLoopbackMode" returncomment="true if the LoopbackMode has been disabled" fulltype="boolean" type="boolean">
				<comment>
					<description>Get the setting for local loopback of multicast datagrams.</description>
					<attribute name="@throws">
						<description>SocketException  if an error occurs while getting the value</description>
					</attribute>
					<attribute name="@return">
						<description>true if the LoopbackMode has been disabled</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
					<attribute name="@see">
						<description>#setLoopbackMode</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an error occurs while getting the value" fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method visibility="public" name="send" fulltype="void" type="void">
				<comment>
					<description>Sends a datagram packet to the destination, with a TTL (time-
 to-live) other than the default for the socket.  This method
 need only be used in instances where a particular TTL is desired;
 otherwise it is preferable to set a TTL once on the socket, and
 use that default TTL for all packets.  This method does &lt;B&gt;not
 &lt;/B&gt; alter the default TTL for the socket. Its behavior may be
 affected by &lt;code&gt;setInterface&lt;/code&gt;.

 &lt;p&gt;If there is a security manager, this method first performs some
 security checks. First, if &lt;code&gt;p.getAddress().isMulticastAddress()&lt;/code&gt;
 is true, this method calls the
 security manager&apos;s &lt;code&gt;checkMulticast&lt;/code&gt; method
 with &lt;code&gt;p.getAddress()&lt;/code&gt; and &lt;code&gt;ttl&lt;/code&gt; as its arguments.
 If the evaluation of that expression is false,
 this method instead calls the security manager&apos;s
 &lt;code&gt;checkConnect&lt;/code&gt; method with arguments
 &lt;code&gt;p.getAddress().getHostAddress()&lt;/code&gt; and
 &lt;code&gt;p.getPort()&lt;/code&gt;. Each call to a security manager method
 could result in a SecurityException if the operation is not allowed.</description>
					<attribute name="@param">
						<description>p is the packet to be sent. The packet should contain
 the destination multicast ip address and the data to be sent.
 One does not need to be the member of the group to send
 packets to a destination multicast address.</description>
					</attribute>
					<attribute name="@param">
						<description>ttl optional time to live for multicast packet.
 default ttl is 1.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException is raised if an error occurs i.e
 error while setting ttl.</description>
					</attribute>
					<attribute name="@exception">
						<description>SecurityException  if a security manager exists and its
             &lt;code&gt;checkMulticast&lt;/code&gt; or &lt;code&gt;checkConnect&lt;/code&gt;
             method doesn&apos;t allow the send.</description>
					</attribute>
					<attribute name="@deprecated">
						<description>Use the following code or its equivalent instead:
  ......
  int ttl = mcastSocket.getTimeToLive();
  mcastSocket.setTimeToLive(newttl);
  mcastSocket.send(p);
  mcastSocket.setTimeToLive(ttl);
  ......</description>
					</attribute>
					<attribute name="@see">
						<description>DatagramSocket#send</description>
					</attribute>
					<attribute name="@see">
						<description>DatagramSocket#receive</description>
					</attribute>
					<attribute name="@see">
						<description>SecurityManager#checkMulticast(java.net.InetAddress, byte)</description>
					</attribute>
					<attribute name="@see">
						<description>SecurityManager#checkConnect</description>
					</attribute>
				</comment>
				<params>
					<param name="p" comment="is the packet to be sent. The packet should contain
 the destination multicast ip address and the data to be sent.
 One does not need to be the member of the group to send
 packets to a destination multicast address." fulltype="java.net.DatagramPacket" type="DatagramPacket" />
					<param name="ttl" comment="optional time to live for multicast packet.
 default ttl is 1." fulltype="byte" type="byte" />
				</params>
				<exceptions>
					<exception comment="is raised if an error occurs i.e
 error while setting ttl." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass abstract="true" superclass="DatagramSocketImpl" visibility="package-private" package="java.net" superclassfulltype="java.net.DatagramSocketImpl" fulltype="java.net.AbstractPlainDatagramSocketImpl" type="AbstractPlainDatagramSocketImpl">
		<comment>
			<description>Abstract datagram and multicast socket implementation base class.
 Note: This is not a public class, so that applets cannot call
 into the implementation directly and hence cannot bypass the
 security checks present in the DatagramSocket and MulticastSocket
 classes.</description>
			<attribute name="@author">
				<description>Pavani Diwanji</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="package-private" name="timeout" fulltype="int" type="int" />
			<field visibility="package-private" name="connected" fulltype="boolean" type="boolean" />
			<field visibility="private" name="trafficClass" fulltype="int" type="int" />
			<field visibility="private" name="connectedAddress" fulltype="java.net.InetAddress" type="InetAddress" />
			<field visibility="private" name="connectedPort" fulltype="int" type="int" />
			<field visibility="private" name="multicastInterface" fulltype="int" type="int" />
			<field visibility="private" name="loopbackMode" fulltype="boolean" type="boolean" />
			<field visibility="private" name="ttl" fulltype="int" type="int" />
		</fields>
		<methods>
			<constructor visibility="package-private" name="AbstractPlainDatagramSocketImpl" />
			<method synchronized="true" visibility="protected" name="create" fulltype="void" type="void">
				<comment>
					<description>Creates a datagram socket</description>
				</comment>
				<exceptions>
					<exception fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="protected" name="bind" fulltype="void" type="void">
				<comment>
					<description>Binds a datagram socket to a local port.</description>
				</comment>
				<params>
					<param name="lport" fulltype="int" type="int" />
					<param name="laddr" fulltype="java.net.InetAddress" type="InetAddress" />
				</params>
				<exceptions>
					<exception fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="protected" name="bind0" fulltype="void" type="void">
				<params>
					<param name="lport" fulltype="int" type="int" />
					<param name="laddr" fulltype="java.net.InetAddress" type="InetAddress" />
				</params>
				<exceptions>
					<exception fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="protected" name="send" fulltype="void" type="void">
				<comment>
					<description>Sends a datagram packet. The packet contains the data and the
 destination address to send the packet to.</description>
					<attribute name="@param">
						<description>packet to be sent.</description>
					</attribute>
				</comment>
				<params>
					<param name="p" fulltype="java.net.DatagramPacket" type="DatagramPacket" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="protected" name="connect" fulltype="void" type="void">
				<comment>
					<description>Connects a datagram socket to a remote destination. This associates the remote
 address with the local socket so that datagrams may only be sent to this destination
 and received from this destination.</description>
					<attribute name="@param">
						<description>address the remote InetAddress to connect to</description>
					</attribute>
					<attribute name="@param">
						<description>port the remote port number</description>
					</attribute>
				</comment>
				<params>
					<param name="address" comment="the remote InetAddress to connect to" fulltype="java.net.InetAddress" type="InetAddress" />
					<param name="port" comment="the remote port number" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method visibility="protected" name="disconnect" fulltype="void" type="void">
				<comment>
					<description>Disconnects a previously connected socket. Does nothing if the socket was
 not connected already.</description>
				</comment>
			</method>
			<method abstract="true" visibility="protected" name="peek" fulltype="int" type="int">
				<comment>
					<description>Peek at the packet to see who it is from.</description>
					<attribute name="@param">
						<description>return the address which the packet came from.</description>
					</attribute>
				</comment>
				<params>
					<param name="i" fulltype="java.net.InetAddress" type="InetAddress" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="protected" name="peekData" fulltype="int" type="int">
				<params>
					<param name="p" fulltype="java.net.DatagramPacket" type="DatagramPacket" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="protected" name="receive" fulltype="void" type="void">
				<comment>
					<description>Receive the datagram packet.</description>
					<attribute name="@param">
						<description>Packet Received.</description>
					</attribute>
				</comment>
				<params>
					<param name="p" fulltype="java.net.DatagramPacket" type="DatagramPacket" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="protected" name="receive0" fulltype="void" type="void">
				<params>
					<param name="p" fulltype="java.net.DatagramPacket" type="DatagramPacket" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="protected" name="setTimeToLive" fulltype="void" type="void">
				<comment>
					<description>Set the TTL (time-to-live) option.</description>
					<attribute name="@param">
						<description>TTL to be set.</description>
					</attribute>
				</comment>
				<params>
					<param name="ttl" comment="to be set." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="protected" name="getTimeToLive" fulltype="int" type="int">
				<comment>
					<description>Get the TTL (time-to-live) option.</description>
				</comment>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="protected" name="setTTL" fulltype="void" type="void">
				<comment>
					<description>Set the TTL (time-to-live) option.</description>
					<attribute name="@param">
						<description>TTL to be set.</description>
					</attribute>
				</comment>
				<params>
					<param name="ttl" comment="to be set." fulltype="byte" type="byte" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="protected" name="getTTL" fulltype="byte" type="byte">
				<comment>
					<description>Get the TTL (time-to-live) option.</description>
				</comment>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="protected" name="join" fulltype="void" type="void">
				<comment>
					<description>Join the multicast group.</description>
					<attribute name="@param">
						<description>multicast address to join.</description>
					</attribute>
				</comment>
				<params>
					<param name="inetaddr" fulltype="java.net.InetAddress" type="InetAddress" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="protected" name="leave" fulltype="void" type="void">
				<comment>
					<description>Leave the multicast group.</description>
					<attribute name="@param">
						<description>multicast address to leave.</description>
					</attribute>
				</comment>
				<params>
					<param name="inetaddr" fulltype="java.net.InetAddress" type="InetAddress" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="protected" name="joinGroup" fulltype="void" type="void">
				<comment>
					<description>Join the multicast group.</description>
					<attribute name="@param">
						<description>multicast address to join.</description>
					</attribute>
					<attribute name="@param">
						<description>netIf specifies the local interface to receive multicast
        datagram packets</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if mcastaddr is null or is a
          SocketAddress subclass not supported by this socket</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
				<params>
					<param name="mcastaddr" fulltype="java.net.SocketAddress" type="SocketAddress" />
					<param name="netIf" comment="specifies the local interface to receive multicast
        datagram packets" fulltype="java.net.NetworkInterface" type="NetworkInterface" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="protected" name="join" fulltype="void" type="void">
				<params>
					<param name="inetaddr" fulltype="java.net.InetAddress" type="InetAddress" />
					<param name="netIf" fulltype="java.net.NetworkInterface" type="NetworkInterface" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="protected" name="leaveGroup" fulltype="void" type="void">
				<comment>
					<description>Leave the multicast group.</description>
					<attribute name="@param">
						<description>multicast address to leave.</description>
					</attribute>
					<attribute name="@param">
						<description>netIf specified the local interface to leave the group at</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if mcastaddr is null or is a
          SocketAddress subclass not supported by this socket</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
				<params>
					<param name="mcastaddr" fulltype="java.net.SocketAddress" type="SocketAddress" />
					<param name="netIf" comment="specified the local interface to leave the group at" fulltype="java.net.NetworkInterface" type="NetworkInterface" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="protected" name="leave" fulltype="void" type="void">
				<params>
					<param name="inetaddr" fulltype="java.net.InetAddress" type="InetAddress" />
					<param name="netIf" fulltype="java.net.NetworkInterface" type="NetworkInterface" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="protected" name="close" fulltype="void" type="void">
				<comment>
					<description>Close the socket.</description>
				</comment>
			</method>
			<method visibility="protected" name="isClosed" fulltype="boolean" type="boolean" />
			<method visibility="protected" name="finalize" fulltype="void" type="void" />
			<method visibility="public" name="setOption" fulltype="void" type="void">
				<comment>
					<description>set a value - since we only support (setting) binary options
 here, o must be a Boolean</description>
				</comment>
				<params>
					<param name="optID" fulltype="int" type="int" />
					<param name="o" fulltype="java.lang.Object" type="Object" />
				</params>
				<exceptions>
					<exception fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method visibility="public" name="getOption" fulltype="java.lang.Object" type="Object">
				<params>
					<param name="optID" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="protected" name="datagramSocketCreate" fulltype="void" type="void">
				<exceptions>
					<exception fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="protected" name="datagramSocketClose" fulltype="void" type="void" />
			<method abstract="true" visibility="protected" name="socketSetOption" fulltype="void" type="void">
				<params>
					<param name="opt" fulltype="int" type="int" />
					<param name="val" fulltype="java.lang.Object" type="Object" />
				</params>
				<exceptions>
					<exception fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="protected" name="socketGetOption" fulltype="java.lang.Object" type="Object">
				<params>
					<param name="opt" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="protected" name="connect0" fulltype="void" type="void">
				<params>
					<param name="address" fulltype="java.net.InetAddress" type="InetAddress" />
					<param name="port" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="protected" name="disconnect0" fulltype="void" type="void">
				<params>
					<param name="family" fulltype="int" type="int" />
				</params>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="SocketException" visibility="public" package="java.net" serializable="true" superclassfulltype="java.net.SocketException" fulltype="java.net.BindException" type="BindException">
		<comment>
			<description>Signals that an error occurred while attempting to bind a
 socket to a local address and port.  Typically, the port is
 in use, or the requested local address could not be assigned.</description>
			<attribute name="@since">
				<description>JDK1.1</description>
			</attribute>
		</comment>
		<methods>
			<constructor visibility="public" name="BindException">
				<comment>
					<description>Constructs a new BindException with the specified detail
 message as to why the bind error occurred.
 A detail message is a String that gives a specific
 description of this error.</description>
					<attribute name="@param">
						<description>msg the detail message</description>
					</attribute>
				</comment>
				<params>
					<param name="msg" comment="the detail message" fulltype="java.lang.String" type="String" />
				</params>
			</constructor>
			<constructor visibility="public" name="BindException">
				<comment>
					<description>Construct a new BindException with no detailed message.</description>
				</comment>
			</constructor>
		</methods>
	</jelclass>
	<jelclass abstract="true" superclass="SocketImpl" visibility="package-private" package="java.net" superclassfulltype="java.net.SocketImpl" fulltype="java.net.AbstractPlainSocketImpl" type="AbstractPlainSocketImpl">
		<comment>
			<description>Default Socket Implementation. This implementation does
 not implement any security checks.
 Note this class should &lt;b&gt;NOT&lt;/b&gt; be public.</description>
			<attribute name="@author">
				<description>Steven B. Byrne</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="package-private" name="timeout" fulltype="int" type="int" />
			<field visibility="private" name="trafficClass" fulltype="int" type="int" />
			<field visibility="private" name="shut_rd" fulltype="boolean" type="boolean" />
			<field visibility="private" name="shut_wr" fulltype="boolean" type="boolean" />
			<field visibility="private" name="socketInputStream" fulltype="java.net.SocketInputStream" type="SocketInputStream" />
			<field visibility="protected" name="fdUseCount" fulltype="int" type="int" />
			<field visibility="protected" name="fdLock" fulltype="java.lang.Object" type="Object" />
			<field visibility="protected" name="closePending" fulltype="boolean" type="boolean" />
			<field visibility="private" name="CONNECTION_NOT_RESET" fulltype="int" type="int" />
			<field visibility="private" name="CONNECTION_RESET_PENDING" fulltype="int" type="int" />
			<field visibility="private" name="CONNECTION_RESET" fulltype="int" type="int" />
			<field visibility="private" name="resetState" fulltype="int" type="int" />
			<field visibility="private" name="resetLock" fulltype="java.lang.Object" type="Object" />
			<field visibility="private" name="stream" fulltype="boolean" type="boolean" />
			<field final="true" static="true" const="0" visibility="public" name="SHUT_RD" constexpr="0" fulltype="int" type="int" />
			<field final="true" static="true" const="1" visibility="public" name="SHUT_WR" constexpr="1" fulltype="int" type="int" />
		</fields>
		<methods>
			<constructor visibility="package-private" name="AbstractPlainSocketImpl" />
			<method synchronized="true" visibility="protected" name="create" fulltype="void" type="void">
				<comment>
					<description>Creates a socket with a boolean that specifies whether this
 is a stream socket (true) or an unconnected UDP socket (false).</description>
				</comment>
				<params>
					<param name="stream" fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="protected" name="connect" fulltype="void" type="void">
				<comment>
					<description>Creates a socket and connects it to the specified port on
 the specified host.</description>
					<attribute name="@param">
						<description>host the specified host</description>
					</attribute>
					<attribute name="@param">
						<description>port the specified port</description>
					</attribute>
				</comment>
				<params>
					<param name="host" comment="the specified host" fulltype="java.lang.String" type="String" />
					<param name="port" comment="the specified port" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.net.UnknownHostException" type="UnknownHostException" />
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="protected" name="connect" fulltype="void" type="void">
				<comment>
					<description>Creates a socket and connects it to the specified address on
 the specified port.</description>
					<attribute name="@param">
						<description>address the address</description>
					</attribute>
					<attribute name="@param">
						<description>port the specified port</description>
					</attribute>
				</comment>
				<params>
					<param name="address" comment="the address" fulltype="java.net.InetAddress" type="InetAddress" />
					<param name="port" comment="the specified port" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="protected" name="connect" fulltype="void" type="void">
				<comment>
					<description>Creates a socket and connects it to the specified address on
 the specified port.</description>
					<attribute name="@param">
						<description>address the address</description>
					</attribute>
					<attribute name="@param">
						<description>timeout the timeout value in milliseconds, or zero for no timeout.</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException if connection fails</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if address is null or is a
          SocketAddress subclass not supported by this socket</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
				<params>
					<param name="address" comment="the address" fulltype="java.net.SocketAddress" type="SocketAddress" />
					<param name="timeout" comment="the timeout value in milliseconds, or zero for no timeout." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if connection fails" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="connectToAddress" fulltype="void" type="void">
				<params>
					<param name="address" fulltype="java.net.InetAddress" type="InetAddress" />
					<param name="port" fulltype="int" type="int" />
					<param name="timeout" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="setOption" fulltype="void" type="void">
				<params>
					<param name="opt" fulltype="int" type="int" />
					<param name="val" fulltype="java.lang.Object" type="Object" />
				</params>
				<exceptions>
					<exception fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method visibility="public" name="getOption" fulltype="java.lang.Object" type="Object">
				<params>
					<param name="opt" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="package-private" name="doConnect" fulltype="void" type="void">
				<comment>
					<description>The workhorse of the connection operation.  Tries several times to
 establish a connection to the given &lt;host, port&gt;.  If unsuccessful,
 throws an IOException indicating what went wrong.</description>
				</comment>
				<params>
					<param name="address" fulltype="java.net.InetAddress" type="InetAddress" />
					<param name="port" fulltype="int" type="int" />
					<param name="timeout" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="protected" name="bind" fulltype="void" type="void">
				<comment>
					<description>Binds the socket to the specified address of the specified local port.</description>
					<attribute name="@param">
						<description>address the address</description>
					</attribute>
					<attribute name="@param">
						<description>port the port</description>
					</attribute>
				</comment>
				<params>
					<param name="address" comment="the address" fulltype="java.net.InetAddress" type="InetAddress" />
					<param name="lport" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="protected" name="listen" fulltype="void" type="void">
				<comment>
					<description>Listens, for a specified amount of time, for connections.</description>
					<attribute name="@param">
						<description>count the amount of time to listen for connections</description>
					</attribute>
				</comment>
				<params>
					<param name="count" comment="the amount of time to listen for connections" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="protected" name="accept" fulltype="void" type="void">
				<comment>
					<description>Accepts connections.</description>
					<attribute name="@param">
						<description>s the connection</description>
					</attribute>
				</comment>
				<params>
					<param name="s" comment="the connection" fulltype="java.net.SocketImpl" type="SocketImpl" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="protected" name="getInputStream" fulltype="java.io.InputStream" type="InputStream">
				<comment>
					<description>Gets an InputStream for this socket.</description>
				</comment>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="package-private" name="setInputStream" fulltype="void" type="void">
				<params>
					<param name="in" fulltype="java.net.SocketInputStream" type="SocketInputStream" />
				</params>
			</method>
			<method synchronized="true" visibility="protected" name="getOutputStream" fulltype="java.io.OutputStream" type="OutputStream">
				<comment>
					<description>Gets an OutputStream for this socket.</description>
				</comment>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="package-private" name="setFileDescriptor" fulltype="void" type="void">
				<params>
					<param name="fd" fulltype="java.io.FileDescriptor" type="FileDescriptor" />
				</params>
			</method>
			<method visibility="package-private" name="setAddress" fulltype="void" type="void">
				<params>
					<param name="address" fulltype="java.net.InetAddress" type="InetAddress" />
				</params>
			</method>
			<method visibility="package-private" name="setPort" fulltype="void" type="void">
				<params>
					<param name="port" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="package-private" name="setLocalPort" fulltype="void" type="void">
				<params>
					<param name="localport" fulltype="int" type="int" />
				</params>
			</method>
			<method synchronized="true" visibility="protected" name="available" fulltype="int" type="int">
				<comment>
					<description>Returns the number of bytes that can be read without blocking.</description>
				</comment>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="protected" name="close" fulltype="void" type="void">
				<comment>
					<description>Closes the socket.</description>
				</comment>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="package-private" name="reset" fulltype="void" type="void">
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="protected" name="shutdownInput" fulltype="void" type="void">
				<comment>
					<description>Shutdown read-half of the socket connection;</description>
				</comment>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="protected" name="shutdownOutput" fulltype="void" type="void">
				<comment>
					<description>Shutdown write-half of the socket connection;</description>
				</comment>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="protected" name="supportsUrgentData" fulltype="boolean" type="boolean" />
			<method visibility="protected" name="sendUrgentData" fulltype="void" type="void">
				<params>
					<param name="data" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="protected" name="finalize" fulltype="void" type="void">
				<comment>
					<description>Cleans up if the user forgets to close it.</description>
				</comment>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="package-private" name="acquireFD" fulltype="java.io.FileDescriptor" type="FileDescriptor" />
			<method visibility="package-private" name="releaseFD" fulltype="void" type="void" />
			<method visibility="public" name="isConnectionReset" fulltype="boolean" type="boolean" />
			<method visibility="public" name="isConnectionResetPending" fulltype="boolean" type="boolean" />
			<method visibility="public" name="setConnectionReset" fulltype="void" type="void" />
			<method visibility="public" name="setConnectionResetPending" fulltype="void" type="void" />
			<method visibility="public" name="isClosedOrPending" fulltype="boolean" type="boolean" />
			<method visibility="public" name="getTimeout" fulltype="int" type="int" />
			<method visibility="private" name="socketPreClose" fulltype="void" type="void">
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="protected" name="socketClose" fulltype="void" type="void">
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="package-private" name="socketCreate" fulltype="void" type="void">
				<params>
					<param name="isServer" fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="package-private" name="socketConnect" fulltype="void" type="void">
				<params>
					<param name="address" fulltype="java.net.InetAddress" type="InetAddress" />
					<param name="port" fulltype="int" type="int" />
					<param name="timeout" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="package-private" name="socketBind" fulltype="void" type="void">
				<params>
					<param name="address" fulltype="java.net.InetAddress" type="InetAddress" />
					<param name="port" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="package-private" name="socketListen" fulltype="void" type="void">
				<params>
					<param name="count" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="package-private" name="socketAccept" fulltype="void" type="void">
				<params>
					<param name="s" fulltype="java.net.SocketImpl" type="SocketImpl" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="package-private" name="socketAvailable" fulltype="int" type="int">
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="package-private" name="socketClose0" fulltype="void" type="void">
				<params>
					<param name="useDeferredClose" fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="package-private" name="socketShutdown" fulltype="void" type="void">
				<params>
					<param name="howto" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="package-private" name="socketSetOption" fulltype="void" type="void">
				<params>
					<param name="cmd" fulltype="int" type="int" />
					<param name="on" fulltype="boolean" type="boolean" />
					<param name="value" fulltype="java.lang.Object" type="Object" />
				</params>
				<exceptions>
					<exception fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="package-private" name="socketGetOption" fulltype="int" type="int">
				<params>
					<param name="opt" fulltype="int" type="int" />
					<param name="iaContainerObj" fulltype="java.lang.Object" type="Object" />
				</params>
				<exceptions>
					<exception fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="package-private" name="socketGetOption1" fulltype="int" type="int">
				<params>
					<param name="opt" fulltype="int" type="int" />
					<param name="iaContainerObj" fulltype="java.lang.Object" type="Object" />
					<param name="fd" fulltype="java.io.FileDescriptor" type="FileDescriptor" />
				</params>
				<exceptions>
					<exception fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="package-private" name="socketSendUrgentData" fulltype="void" type="void">
				<params>
					<param name="data" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="Object" visibility="package-private" package="java.net" superclassfulltype="java.lang.Object" fulltype="java.net.InetAddressContainer" type="InetAddressContainer">
		<fields>
			<field visibility="package-private" name="addr" fulltype="java.net.InetAddress" type="InetAddress" />
		</fields>
		<methods>
			<constructor visibility="package-private" name="InetAddressContainer" />
		</methods>
	</jelclass>
	<jelclass superclass="IOException" visibility="public" package="java.net" serializable="true" superclassfulltype="java.io.IOException" fulltype="java.net.HttpRetryException" type="HttpRetryException">
		<comment>
			<description>Thrown to indicate that a HTTP request needs to be retried
 but cannot be retried automatically, due to streaming mode
 being enabled.</description>
			<attribute name="@author">
				<description>Michael McMahon</description>
			</attribute>
			<attribute name="@since">
				<description>1.5</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="private" name="responseCode" fulltype="int" type="int" />
			<field visibility="private" name="location" fulltype="java.lang.String" type="String" />
		</fields>
		<methods>
			<constructor visibility="public" name="HttpRetryException">
				<comment>
					<description>Constructs a new &lt;code&gt;HttpRetryException&lt;/code&gt; from the
 specified response code and exception detail message</description>
					<attribute name="@param">
						<description>detail   the detail message.</description>
					</attribute>
					<attribute name="@param">
						<description>code   the HTTP response code from server.</description>
					</attribute>
				</comment>
				<params>
					<param name="detail" comment="the detail message." fulltype="java.lang.String" type="String" />
					<param name="code" comment="the HTTP response code from server." fulltype="int" type="int" />
				</params>
			</constructor>
			<constructor visibility="public" name="HttpRetryException">
				<comment>
					<description>Constructs a new &lt;code&gt;HttpRetryException&lt;/code&gt; with detail message
 responseCode and the contents of the Location response header field.</description>
					<attribute name="@param">
						<description>detail   the detail message.</description>
					</attribute>
					<attribute name="@param">
						<description>code   the HTTP response code from server.</description>
					</attribute>
					<attribute name="@param">
						<description>location   the URL to be redirected to</description>
					</attribute>
				</comment>
				<params>
					<param name="detail" comment="the detail message." fulltype="java.lang.String" type="String" />
					<param name="code" comment="the HTTP response code from server." fulltype="int" type="int" />
					<param name="location" comment="the URL to be redirected to" fulltype="java.lang.String" type="String" />
				</params>
			</constructor>
			<method visibility="public" name="responseCode" returncomment="The http response code." fulltype="int" type="int">
				<comment>
					<description>Returns the http response code</description>
					<attribute name="@return">
						<description>The http response code.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getReason" returncomment="The reason string" fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns a string explaining why the http request could
 not be retried.</description>
					<attribute name="@return">
						<description>The reason string</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getLocation" returncomment="The location string" fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the value of the Location header field if the
 error resulted from redirection.</description>
					<attribute name="@return">
						<description>The location string</description>
					</attribute>
				</comment>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="IOException" visibility="public" package="java.net" serializable="true" superclassfulltype="java.io.IOException" fulltype="java.net.SocketException" type="SocketException">
		<comment>
			<description>Thrown to indicate that there is an error creating or accessing a Socket.</description>
			<attribute name="@author">
				<description>Jonathan Payne</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.0</description>
			</attribute>
		</comment>
		<methods>
			<constructor visibility="public" name="SocketException">
				<comment>
					<description>Constructs a new &lt;code&gt;SocketException&lt;/code&gt; with the
 specified detail message.</description>
					<attribute name="@param">
						<description>msg the detail message.</description>
					</attribute>
				</comment>
				<params>
					<param name="msg" comment="the detail message." fulltype="java.lang.String" type="String" />
				</params>
			</constructor>
			<constructor visibility="public" name="SocketException">
				<comment>
					<description>Constructs a new &lt;code&gt;SocketException&lt;/code&gt; with no detail message.</description>
				</comment>
			</constructor>
		</methods>
	</jelclass>
	<jelclass final="true" superclass="Object" visibility="public" package="java.net" superclassfulltype="java.lang.Object" fulltype="java.net.NetworkInterface" type="NetworkInterface">
		<comment>
			<description>This class represents a Network Interface made up of a name,
 and a list of IP addresses assigned to this interface.
 It is used to identify the local interface on which a multicast group
 is joined.

 Interfaces are normally known by names such as &quot;le0&quot;.</description>
			<attribute name="@since">
				<description>1.4</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="private" name="name" fulltype="java.lang.String" type="String" />
			<field visibility="private" name="displayName" fulltype="java.lang.String" type="String" />
			<field visibility="private" name="index" fulltype="int" type="int" />
			<field visibility="private" name="addrs" fulltype="java.net.InetAddress[]" type="InetAddress" />
			<field visibility="private" name="bindings" fulltype="java.net.InterfaceAddress[]" type="InterfaceAddress" />
			<field visibility="private" name="childs" fulltype="java.net.NetworkInterface[]" type="NetworkInterface" />
			<field visibility="private" name="parent" fulltype="java.net.NetworkInterface" type="NetworkInterface" />
			<field visibility="private" name="virtual" fulltype="boolean" type="boolean" />
		</fields>
		<methods>
			<constructor visibility="package-private" name="NetworkInterface">
				<comment>
					<description>Returns an NetworkInterface object with index set to 0 and name to null.
 Setting such an interface on a MulticastSocket will cause the
 kernel to choose one interface for sending multicast packets.</description>
				</comment>
			</constructor>
			<constructor visibility="package-private" name="NetworkInterface">
				<params>
					<param name="name" fulltype="java.lang.String" type="String" />
					<param name="index" fulltype="int" type="int" />
					<param name="addrs" fulltype="java.net.InetAddress[]" type="InetAddress" />
				</params>
			</constructor>
			<method visibility="public" name="getName" returncomment="the name of this network interface" fulltype="java.lang.String" type="String">
				<comment>
					<description>Get the name of this network interface.</description>
					<attribute name="@return">
						<description>the name of this network interface</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getInetAddresses" returncomment="an Enumeration object with all or a subset of the InetAddresses
 bound to this network interface" fulltype="java.util.Enumeration" type="Enumeration">
				<comment>
					<description>Convenience method to return an Enumeration with all or a
 subset of the InetAddresses bound to this network interface.
 &lt;p&gt;
 If there is a security manager, its &lt;code&gt;checkConnect&lt;/code&gt;
 method is called for each InetAddress. Only InetAddresses where
 the &lt;code&gt;checkConnect&lt;/code&gt; doesn&apos;t throw a SecurityException
 will be returned in the Enumeration.</description>
					<attribute name="@return">
						<description>an Enumeration object with all or a subset of the InetAddresses
 bound to this network interface</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getInterfaceAddresses" returncomment="a &lt;code&gt;List&lt;/code&gt; object with all or a subset of the
         InterfaceAddresss of this network interface" fulltype="java.util.List" type="List">
				<comment>
					<description>Get a List of all or a subset of the &lt;code&gt;InterfaceAddresses&lt;/code&gt;
 of this network interface.
 &lt;p&gt;
 If there is a security manager, its &lt;code&gt;checkConnect&lt;/code&gt;
 method is called with the InetAddress for each InterfaceAddress.
 Only InterfaceAddresses where the &lt;code&gt;checkConnect&lt;/code&gt; doesn&apos;t throw
 a SecurityException will be returned in the List.</description>
					<attribute name="@return">
						<description>a &lt;code&gt;List&lt;/code&gt; object with all or a subset of the
         InterfaceAddresss of this network interface</description>
					</attribute>
					<attribute name="@since">
						<description>1.6</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getSubInterfaces" returncomment="an Enumeration object with all of the subinterfaces
 of this network interface" fulltype="java.util.Enumeration" type="Enumeration">
				<comment>
					<description>Get an Enumeration with all the subinterfaces (also known as virtual
 interfaces) attached to this network interface.
 &lt;p&gt;
 For instance eth0:1 will be a subinterface to eth0.</description>
					<attribute name="@return">
						<description>an Enumeration object with all of the subinterfaces
 of this network interface</description>
					</attribute>
					<attribute name="@since">
						<description>1.6</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getParent" returncomment="The &lt;code&gt;NetworkInterface&lt;/code&gt; this interface is attached to." fulltype="java.net.NetworkInterface" type="NetworkInterface">
				<comment>
					<description>Returns the parent NetworkInterface of this interface if this is
 a subinterface, or &lt;code&gt;null&lt;/code&gt; if it is a physical
 (non virtual) interface or has no parent.</description>
					<attribute name="@return">
						<description>The &lt;code&gt;NetworkInterface&lt;/code&gt; this interface is attached to.</description>
					</attribute>
					<attribute name="@since">
						<description>1.6</description>
					</attribute>
				</comment>
			</method>
			<method visibility="package-private" name="getIndex" returncomment="the index of this network interface" fulltype="int" type="int">
				<comment>
					<description>Get the index of this network interface.</description>
					<attribute name="@return">
						<description>the index of this network interface</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getDisplayName" returncomment="the display name of this network interface,
         or null if no display name is available." fulltype="java.lang.String" type="String">
				<comment>
					<description>Get the display name of this network interface.
 A display name is a human readable String describing the network
 device.</description>
					<attribute name="@return">
						<description>the display name of this network interface,
         or null if no display name is available.</description>
					</attribute>
				</comment>
			</method>
			<method static="true" visibility="public" name="getByName" returncomment="A &lt;tt&gt;NetworkInterface&lt;/tt&gt; with the specified name,
          or &lt;tt&gt;null&lt;/tt&gt; if there is no network interface
          with the specified name." fulltype="java.net.NetworkInterface" type="NetworkInterface">
				<comment>
					<description>Searches for the network interface with the specified name.</description>
					<attribute name="@param">
						<description>name
          The name of the network interface.</description>
					</attribute>
					<attribute name="@return">
						<description>A &lt;tt&gt;NetworkInterface&lt;/tt&gt; with the specified name,
          or &lt;tt&gt;null&lt;/tt&gt; if there is no network interface
          with the specified name.</description>
					</attribute>
					<attribute name="@throws">
						<description>SocketException
          If an I/O error occurs.</description>
					</attribute>
					<attribute name="@throws">
						<description>NullPointerException
          If the specified name is &lt;tt&gt;null&lt;/tt&gt;.</description>
					</attribute>
				</comment>
				<params>
					<param name="name" comment="The name of the network interface." fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception comment="If an I/O error occurs." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method static="true" visibility="package-private" name="getByIndex" returncomment="the NetworkInterface obtained from its index" fulltype="java.net.NetworkInterface" type="NetworkInterface">
				<comment>
					<description>Get a network interface given its index.</description>
					<attribute name="@param">
						<description>index an integer, the index of the interface</description>
					</attribute>
					<attribute name="@return">
						<description>the NetworkInterface obtained from its index</description>
					</attribute>
					<attribute name="@exception">
						<description>SocketException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="index" comment="an integer, the index of the interface" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method static="true" visibility="public" name="getByInetAddress" returncomment="A &lt;tt&gt;NetworkInterface&lt;/tt&gt;
          or &lt;tt&gt;null&lt;/tt&gt; if there is no network interface
          with the specified IP address." fulltype="java.net.NetworkInterface" type="NetworkInterface">
				<comment>
					<description>Convenience method to search for a network interface that
 has the specified Internet Protocol (IP) address bound to
 it.
 &lt;p&gt;
 If the specified IP address is bound to multiple network
 interfaces it is not defined which network interface is
 returned.</description>
					<attribute name="@param">
						<description>addr
          The &lt;tt&gt;InetAddress&lt;/tt&gt; to search with.</description>
					</attribute>
					<attribute name="@return">
						<description>A &lt;tt&gt;NetworkInterface&lt;/tt&gt;
          or &lt;tt&gt;null&lt;/tt&gt; if there is no network interface
          with the specified IP address.</description>
					</attribute>
					<attribute name="@throws">
						<description>SocketException
          If an I/O error occurs.</description>
					</attribute>
					<attribute name="@throws">
						<description>NullPointerException
          If the specified address is &lt;tt&gt;null&lt;/tt&gt;.</description>
					</attribute>
				</comment>
				<params>
					<param name="addr" comment="The &lt;tt&gt;InetAddress&lt;/tt&gt; to search with." fulltype="java.net.InetAddress" type="InetAddress" />
				</params>
				<exceptions>
					<exception comment="If an I/O error occurs." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method static="true" visibility="public" name="getNetworkInterfaces" returncomment="an Enumeration of NetworkInterfaces found on this machine" fulltype="java.util.Enumeration" type="Enumeration">
				<comment>
					<description>Returns all the interfaces on this machine. Returns null if no
 network interfaces could be found on this machine.

 NOTE: can use getNetworkInterfaces()+getInetAddresses()
       to obtain all IP addresses for this node</description>
					<attribute name="@return">
						<description>an Enumeration of NetworkInterfaces found on this machine</description>
					</attribute>
					<attribute name="@exception">
						<description>SocketException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method static="true" visibility="private" name="getAll" fulltype="java.net.NetworkInterface[]" type="NetworkInterface">
				<exceptions>
					<exception fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method static="true" visibility="private" name="getByName0" fulltype="java.net.NetworkInterface" type="NetworkInterface">
				<params>
					<param name="name" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method static="true" visibility="private" name="getByInetAddress0" fulltype="java.net.NetworkInterface" type="NetworkInterface">
				<params>
					<param name="addr" fulltype="java.net.InetAddress" type="InetAddress" />
				</params>
				<exceptions>
					<exception fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method visibility="public" name="isUp" returncomment="&lt;code&gt;true&lt;/code&gt; if the interface is up and running." fulltype="boolean" type="boolean">
				<comment>
					<description>Returns whether a network interface is up and running.</description>
					<attribute name="@return">
						<description>&lt;code&gt;true&lt;/code&gt; if the interface is up and running.</description>
					</attribute>
					<attribute name="@exception">
						<description>SocketException if an I/O error occurs.</description>
					</attribute>
					<attribute name="@since">
						<description>1.6</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method visibility="public" name="isLoopback" returncomment="&lt;code&gt;true&lt;/code&gt; if the interface is a loopback interface." fulltype="boolean" type="boolean">
				<comment>
					<description>Returns whether a network interface is a loopback interface.</description>
					<attribute name="@return">
						<description>&lt;code&gt;true&lt;/code&gt; if the interface is a loopback interface.</description>
					</attribute>
					<attribute name="@exception">
						<description>SocketException if an I/O error occurs.</description>
					</attribute>
					<attribute name="@since">
						<description>1.6</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method visibility="public" name="isPointToPoint" returncomment="&lt;code&gt;true&lt;/code&gt; if the interface is a point to point
          interface." fulltype="boolean" type="boolean">
				<comment>
					<description>Returns whether a network interface is a point to point interface.
 A typical point to point interface would be a PPP connection through
 a modem.</description>
					<attribute name="@return">
						<description>&lt;code&gt;true&lt;/code&gt; if the interface is a point to point
          interface.</description>
					</attribute>
					<attribute name="@exception">
						<description>SocketException if an I/O error occurs.</description>
					</attribute>
					<attribute name="@since">
						<description>1.6</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method visibility="public" name="supportsMulticast" returncomment="&lt;code&gt;true&lt;/code&gt; if the interface supports Multicasting." fulltype="boolean" type="boolean">
				<comment>
					<description>Returns whether a network interface supports multicasting or not.</description>
					<attribute name="@return">
						<description>&lt;code&gt;true&lt;/code&gt; if the interface supports Multicasting.</description>
					</attribute>
					<attribute name="@exception">
						<description>SocketException if an I/O error occurs.</description>
					</attribute>
					<attribute name="@since">
						<description>1.6</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method visibility="public" name="getHardwareAddress" returncomment="a byte array containing the address or &lt;code&gt;null&lt;/code&gt; if
          the address doesn&apos;t exist or is not accessible." fulltype="byte[]" type="byte">
				<comment>
					<description>Returns the hardware address (usually MAC) of the interface if it
 has one and if it can be accessed given the current privileges.</description>
					<attribute name="@return">
						<description>a byte array containing the address or &lt;code&gt;null&lt;/code&gt; if
          the address doesn&apos;t exist or is not accessible.</description>
					</attribute>
					<attribute name="@exception">
						<description>SocketException if an I/O error occurs.</description>
					</attribute>
					<attribute name="@since">
						<description>1.6</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method visibility="public" name="getMTU" returncomment="the value of the MTU for that interface." fulltype="int" type="int">
				<comment>
					<description>Returns the Maximum Transmission Unit (MTU) of this interface.</description>
					<attribute name="@return">
						<description>the value of the MTU for that interface.</description>
					</attribute>
					<attribute name="@exception">
						<description>SocketException if an I/O error occurs.</description>
					</attribute>
					<attribute name="@since">
						<description>1.6</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method visibility="public" name="isVirtual" returncomment="&lt;code&gt;true&lt;/code&gt; if this interface is a virtual interface." fulltype="boolean" type="boolean">
				<comment>
					<description>Returns whether this interface is a virtual interface (also called
 subinterface).
 Virtual interfaces are, on some systems, interfaces created as a child
 of a physical interface and given different settings (like address or
 MTU). Usually the name of the interface will the name of the parent
 followed by a colon (:) and a number identifying the child since there
 can be several virtual interfaces attached to a single physical
 interface.</description>
					<attribute name="@return">
						<description>&lt;code&gt;true&lt;/code&gt; if this interface is a virtual interface.</description>
					</attribute>
					<attribute name="@since">
						<description>1.6</description>
					</attribute>
				</comment>
			</method>
			<method static="true" visibility="private" name="getSubnet0" fulltype="long" type="long">
				<params>
					<param name="name" fulltype="java.lang.String" type="String" />
					<param name="ind" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method static="true" visibility="private" name="getBroadcast0" fulltype="java.net.Inet4Address" type="Inet4Address">
				<params>
					<param name="name" fulltype="java.lang.String" type="String" />
					<param name="ind" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method static="true" visibility="private" name="isUp0" fulltype="boolean" type="boolean">
				<params>
					<param name="name" fulltype="java.lang.String" type="String" />
					<param name="ind" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method static="true" visibility="private" name="isLoopback0" fulltype="boolean" type="boolean">
				<params>
					<param name="name" fulltype="java.lang.String" type="String" />
					<param name="ind" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method static="true" visibility="private" name="supportsMulticast0" fulltype="boolean" type="boolean">
				<params>
					<param name="name" fulltype="java.lang.String" type="String" />
					<param name="ind" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method static="true" visibility="private" name="isP2P0" fulltype="boolean" type="boolean">
				<params>
					<param name="name" fulltype="java.lang.String" type="String" />
					<param name="ind" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method static="true" visibility="private" name="getMacAddr0" fulltype="byte[]" type="byte">
				<params>
					<param name="inAddr" fulltype="byte[]" type="byte" />
					<param name="name" fulltype="java.lang.String" type="String" />
					<param name="ind" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method static="true" visibility="private" name="getMTU0" fulltype="int" type="int">
				<params>
					<param name="name" fulltype="java.lang.String" type="String" />
					<param name="ind" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method visibility="public" name="equals" returncomment="&lt;code&gt;true&lt;/code&gt; if the objects are the same;
          &lt;code&gt;false&lt;/code&gt; otherwise." fulltype="boolean" type="boolean">
				<comment>
					<description>Compares this object against the specified object.
 The result is &lt;code&gt;true&lt;/code&gt; if and only if the argument is
 not &lt;code&gt;null&lt;/code&gt; and it represents the same NetworkInterface
 as this object.
 &lt;p&gt;
 Two instances of &lt;code&gt;NetworkInterface&lt;/code&gt; represent the same
 NetworkInterface if both name and addrs are the same for both.</description>
					<attribute name="@param">
						<description>obj   the object to compare against.</description>
					</attribute>
					<attribute name="@return">
						<description>&lt;code&gt;true&lt;/code&gt; if the objects are the same;
          &lt;code&gt;false&lt;/code&gt; otherwise.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.InetAddress#getAddress()</description>
					</attribute>
				</comment>
				<params>
					<param name="obj" comment="the object to compare against." fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method visibility="public" name="hashCode" fulltype="int" type="int" />
			<method visibility="public" name="toString" fulltype="java.lang.String" type="String" />
			<method static="true" visibility="private" name="init" fulltype="void" type="void" />
		</methods>
	</jelclass>
	<jelclass abstract="true" visibility="public" package="java.net" interface="true" fulltype="java.net.SocketOptions" type="SocketOptions">
		<comment>
			<description>Interface of methods to get/set socket options.  This interface is
 implemented by: &lt;B&gt;SocketImpl&lt;/B&gt; and  &lt;B&gt;DatagramSocketImpl&lt;/B&gt;.
 Subclasses of these should override the methods
 of this interface in order to support their own options.
 &lt;P&gt;
 The methods and constants which specify options in this interface are
 for implementation only.  If you&apos;re not subclassing SocketImpl or
 DatagramSocketImpl, &lt;B&gt;you won&apos;t use these directly.&lt;/B&gt; There are
 type-safe methods to get/set each of these options in Socket, ServerSocket,
 DatagramSocket and MulticastSocket.
 &lt;P&gt;</description>
			<attribute name="@author">
				<description>David Brown</description>
			</attribute>
		</comment>
		<fields>
			<field final="true" static="true" const="1" visibility="public" name="TCP_NODELAY" constexpr="1" fulltype="int" type="int">
				<comment>
					<description>Disable Nagle&apos;s algorithm for this connection.  Written data
 to the network is not buffered pending acknowledgement of
 previously written data.
&lt;P&gt;
 Valid for TCP only: SocketImpl.
 &lt;P&gt;</description>
					<attribute name="@see">
						<description>Socket#setTcpNoDelay</description>
					</attribute>
					<attribute name="@see">
						<description>Socket#getTcpNoDelay</description>
					</attribute>
				</comment>
			</field>
			<field final="true" static="true" const="15" visibility="public" name="SO_BINDADDR" constexpr="15" fulltype="int" type="int">
				<comment>
					<description>Fetch the local address binding of a socket (this option cannot
 be &quot;set&quot; only &quot;gotten&quot;, since sockets are bound at creation time,
 and so the locally bound address cannot be changed).  The default local
 address of a socket is INADDR_ANY, meaning any local address on a
 multi-homed host.  A multi-homed host can use this option to accept
 connections to only one of its addresses (in the case of a
 ServerSocket or DatagramSocket), or to specify its return address
 to the peer (for a Socket or DatagramSocket).  The parameter of
 this option is an InetAddress.
 &lt;P&gt;
 This option &lt;B&gt;must&lt;/B&gt; be specified in the constructor.
 &lt;P&gt;
 Valid for: SocketImpl, DatagramSocketImpl
 &lt;P&gt;</description>
					<attribute name="@see">
						<description>Socket#getLocalAddress</description>
					</attribute>
					<attribute name="@see">
						<description>DatagramSocket#getLocalAddress</description>
					</attribute>
				</comment>
			</field>
			<field final="true" static="true" const="4" visibility="public" name="SO_REUSEADDR" constexpr="4" fulltype="int" type="int">
				<comment>
					<description>Sets SO_REUSEADDR for a socket.  This is used only for MulticastSockets
 in java, and it is set by default for MulticastSockets.
 &lt;P&gt;
 Valid for: DatagramSocketImpl</description>
				</comment>
			</field>
			<field final="true" static="true" const="32" visibility="public" name="SO_BROADCAST" constexpr="32" fulltype="int" type="int">
				<comment>
					<description>Sets SO_BROADCAST for a socket. This option enables and disables
 the ability of the process to send broadcast messages. It is supported
 for only datagram sockets and only on networks that support
 the concept of a broadcast message (e.g. Ethernet, token ring, etc.),
 and it is set by default for DatagramSockets.</description>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</field>
			<field final="true" static="true" const="16" visibility="public" name="IP_MULTICAST_IF" constexpr="16" fulltype="int" type="int">
				<comment>
					<description>Set which outgoing interface on which to send multicast packets.
 Useful on hosts with multiple network interfaces, where applications
 want to use other than the system default.  Takes/returns an InetAddress.
 &lt;P&gt;
 Valid for Multicast: DatagramSocketImpl
 &lt;P&gt;</description>
					<attribute name="@see">
						<description>MulticastSocket#setInterface(InetAddress)</description>
					</attribute>
					<attribute name="@see">
						<description>MulticastSocket#getInterface()</description>
					</attribute>
				</comment>
			</field>
			<field final="true" static="true" const="31" visibility="public" name="IP_MULTICAST_IF2" constexpr="31" fulltype="int" type="int">
				<comment>
					<description>Same as above. This option is introduced so that the behaviour
  with IP_MULTICAST_IF will be kept the same as before, while
  this new option can support setting outgoing interfaces with either
  IPv4 and IPv6 addresses.

  NOTE: make sure there is no conflict with this</description>
					<attribute name="@see">
						<description>MulticastSocket#setNetworkInterface(NetworkInterface)</description>
					</attribute>
					<attribute name="@see">
						<description>MulticastSocket#getNetworkInterface()</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</field>
			<field final="true" static="true" const="18" visibility="public" name="IP_MULTICAST_LOOP" constexpr="18" fulltype="int" type="int">
				<comment>
					<description>This option enables or disables local loopback of multicast datagrams.
 This option is enabled by default for Multicast Sockets.</description>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</field>
			<field final="true" static="true" const="3" visibility="public" name="IP_TOS" constexpr="3" fulltype="int" type="int">
				<comment>
					<description>This option sets the type-of-service or traffic class field
 in the IP header for a TCP or UDP socket.</description>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</field>
			<field final="true" static="true" const="128" visibility="public" name="SO_LINGER" constexpr="128" fulltype="int" type="int">
				<comment>
					<description>Specify a linger-on-close timeout.  This option disables/enables
 immediate return from a &lt;B&gt;close()&lt;/B&gt; of a TCP Socket.  Enabling
 this option with a non-zero Integer &lt;I&gt;timeout&lt;/I&gt; means that a
 &lt;B&gt;close()&lt;/B&gt; will block pending the transmission and acknowledgement
 of all data written to the peer, at which point the socket is closed
 &lt;I&gt;gracefully&lt;/I&gt;.  Upon reaching the linger timeout, the socket is
 closed &lt;I&gt;forcefully&lt;/I&gt;, with a TCP RST. Enabling the option with a
 timeout of zero does a forceful close immediately. If the specified
 timeout value exceeds 65,535 it will be reduced to 65,535.
 &lt;P&gt;
 Valid only for TCP: SocketImpl</description>
					<attribute name="@see">
						<description>Socket#setSoLinger</description>
					</attribute>
					<attribute name="@see">
						<description>Socket#getSoLinger</description>
					</attribute>
				</comment>
			</field>
			<field final="true" static="true" const="4102" visibility="public" name="SO_TIMEOUT" constexpr="4102" fulltype="int" type="int">
				<comment>
					<description>Set a timeout on blocking Socket operations:
 &lt;PRE&gt;
 ServerSocket.accept();
 SocketInputStream.read();
 DatagramSocket.receive();
 &lt;/PRE&gt;

 &lt;P&gt; The option must be set prior to entering a blocking
 operation to take effect.  If the timeout expires and the
 operation would continue to block,
 &lt;B&gt;java.io.InterruptedIOException&lt;/B&gt; is raised.  The Socket is
 not closed in this case.

 &lt;P&gt; Valid for all sockets: SocketImpl, DatagramSocketImpl</description>
					<attribute name="@see">
						<description>Socket#setSoTimeout</description>
					</attribute>
					<attribute name="@see">
						<description>ServerSocket#setSoTimeout</description>
					</attribute>
					<attribute name="@see">
						<description>DatagramSocket#setSoTimeout</description>
					</attribute>
				</comment>
			</field>
			<field final="true" static="true" const="4097" visibility="public" name="SO_SNDBUF" constexpr="4097" fulltype="int" type="int">
				<comment>
					<description>Set a hint the size of the underlying buffers used by the
 platform for outgoing network I/O. When used in set, this is a
 suggestion to the kernel from the application about the size of
 buffers to use for the data to be sent over the socket. When
 used in get, this must return the size of the buffer actually
 used by the platform when sending out data on this socket.

 Valid for all sockets: SocketImpl, DatagramSocketImpl</description>
					<attribute name="@see">
						<description>Socket#setSendBufferSize</description>
					</attribute>
					<attribute name="@see">
						<description>Socket#getSendBufferSize</description>
					</attribute>
					<attribute name="@see">
						<description>DatagramSocket#setSendBufferSize</description>
					</attribute>
					<attribute name="@see">
						<description>DatagramSocket#getSendBufferSize</description>
					</attribute>
				</comment>
			</field>
			<field final="true" static="true" const="4098" visibility="public" name="SO_RCVBUF" constexpr="4098" fulltype="int" type="int">
				<comment>
					<description>Set a hint the size of the underlying buffers used by the
 platform for incoming network I/O. When used in set, this is a
 suggestion to the kernel from the application about the size of
 buffers to use for the data to be received over the
 socket. When used in get, this must return the size of the
 buffer actually used by the platform when receiving in data on
 this socket.

 Valid for all sockets: SocketImpl, DatagramSocketImpl</description>
					<attribute name="@see">
						<description>Socket#setReceiveBufferSize</description>
					</attribute>
					<attribute name="@see">
						<description>Socket#getReceiveBufferSize</description>
					</attribute>
					<attribute name="@see">
						<description>DatagramSocket#setReceiveBufferSize</description>
					</attribute>
					<attribute name="@see">
						<description>DatagramSocket#getReceiveBufferSize</description>
					</attribute>
				</comment>
			</field>
			<field final="true" static="true" const="8" visibility="public" name="SO_KEEPALIVE" constexpr="8" fulltype="int" type="int">
				<comment>
					<description>When the keepalive option is set for a TCP socket and no data
 has been exchanged across the socket in either direction for
 2 hours (NOTE: the actual value is implementation dependent),
 TCP automatically sends a keepalive probe to the peer. This probe is a
 TCP segment to which the peer must respond.
 One of three responses is expected:
 1. The peer responds with the expected ACK. The application is not
    notified (since everything is OK). TCP will send another probe
    following another 2 hours of inactivity.
 2. The peer responds with an RST, which tells the local TCP that
    the peer host has crashed and rebooted. The socket is closed.
 3. There is no response from the peer. The socket is closed.

 The purpose of this option is to detect if the peer host crashes.

 Valid only for TCP socket: SocketImpl</description>
					<attribute name="@see">
						<description>Socket#setKeepAlive</description>
					</attribute>
					<attribute name="@see">
						<description>Socket#getKeepAlive</description>
					</attribute>
				</comment>
			</field>
			<field final="true" static="true" const="4099" visibility="public" name="SO_OOBINLINE" constexpr="4099" fulltype="int" type="int">
				<comment>
					<description>When the OOBINLINE option is set, any TCP urgent data received on
 the socket will be received through the socket input stream.
 When the option is disabled (which is the default) urgent data
 is silently discarded.</description>
					<attribute name="@see">
						<description>Socket#setOOBInline</description>
					</attribute>
					<attribute name="@see">
						<description>Socket#getOOBInline</description>
					</attribute>
				</comment>
			</field>
		</fields>
		<methods>
			<method visibility="public" name="setOption" fulltype="void" type="void">
				<comment>
					<description>Enable/disable the option specified by &lt;I&gt;optID&lt;/I&gt;.  If the option
 is to be enabled, and it takes an option-specific &quot;value&quot;,  this is
 passed in &lt;I&gt;value&lt;/I&gt;.  The actual type of value is option-specific,
 and it is an error to pass something that isn&apos;t of the expected type:
 &lt;BR&gt;&lt;PRE&gt;
 SocketImpl s;
 ...
 s.setOption(SO_LINGER, new Integer(10));
    // OK - set SO_LINGER w/ timeout of 10 sec.
 s.setOption(SO_LINGER, new Double(10));
    // ERROR - expects java.lang.Integer
&lt;/PRE&gt;
 If the requested option is binary, it can be set using this method by
 a java.lang.Boolean:
 &lt;BR&gt;&lt;PRE&gt;
 s.setOption(TCP_NODELAY, new Boolean(true));
    // OK - enables TCP_NODELAY, a binary option
 &lt;/PRE&gt;
 &lt;BR&gt;
 Any option can be disabled using this method with a Boolean(false):
 &lt;BR&gt;&lt;PRE&gt;
 s.setOption(TCP_NODELAY, new Boolean(false));
    // OK - disables TCP_NODELAY
 s.setOption(SO_LINGER, new Boolean(false));
    // OK - disables SO_LINGER
 &lt;/PRE&gt;
 &lt;BR&gt;
 For an option that has a notion of on and off, and requires
 a non-boolean parameter, setting its value to anything other than
 &lt;I&gt;Boolean(false)&lt;/I&gt; implicitly enables it.
 &lt;BR&gt;
 Throws SocketException if the option is unrecognized,
 the socket is closed, or some low-level error occurred
 &lt;BR&gt;</description>
					<attribute name="@param">
						<description>optID identifies the option</description>
					</attribute>
					<attribute name="@param">
						<description>value the parameter of the socket option</description>
					</attribute>
					<attribute name="@throws">
						<description>SocketException if the option is unrecognized,
 the socket is closed, or some low-level error occurred</description>
					</attribute>
					<attribute name="@see">
						<description>#getOption(int)</description>
					</attribute>
				</comment>
				<params>
					<param name="optID" comment="identifies the option" fulltype="int" type="int" />
					<param name="value" comment="the parameter of the socket option" fulltype="java.lang.Object" type="Object" />
				</params>
				<exceptions>
					<exception comment="if the option is unrecognized,
 the socket is closed, or some low-level error occurred" fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method visibility="public" name="getOption" returncomment="the value of the option" fulltype="java.lang.Object" type="Object">
				<comment>
					<description>Fetch the value of an option.
 Binary options will return java.lang.Boolean(true)
 if enabled, java.lang.Boolean(false) if disabled, e.g.:
 &lt;BR&gt;&lt;PRE&gt;
 SocketImpl s;
 ...
 Boolean noDelay = (Boolean)(s.getOption(TCP_NODELAY));
 if (noDelay.booleanValue()) {
     // true if TCP_NODELAY is enabled...
 ...
 }
 &lt;/PRE&gt;
 &lt;P&gt;
 For options that take a particular type as a parameter,
 getOption(int) will return the parameter&apos;s value, else
 it will return java.lang.Boolean(false):
 &lt;PRE&gt;
 Object o = s.getOption(SO_LINGER);
 if (o instanceof Integer) {
     System.out.print(&quot;Linger time is &quot; + ((Integer)o).intValue());
 } else {
   // the true type of o is java.lang.Boolean(false);
 }
 &lt;/PRE&gt;</description>
					<attribute name="@param">
						<description>optID an &lt;code&gt;int&lt;/code&gt; identifying the option to fetch</description>
					</attribute>
					<attribute name="@return">
						<description>the value of the option</description>
					</attribute>
					<attribute name="@throws">
						<description>SocketException if the socket is closed</description>
					</attribute>
					<attribute name="@throws">
						<description>SocketException if &lt;I&gt;optID&lt;/I&gt; is unknown along the
         protocol stack (including the SocketImpl)</description>
					</attribute>
					<attribute name="@see">
						<description>#setOption(int, java.lang.Object)</description>
					</attribute>
				</comment>
				<params>
					<param name="optID" comment="an &lt;code&gt;int&lt;/code&gt; identifying the option to fetch" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if &lt;I&gt;optID&lt;/I&gt; is unknown along the
         protocol stack (including the SocketImpl)" fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass abstract="true" visibility="public" package="java.net" interface="true" fulltype="java.net.FileNameMap" type="FileNameMap">
		<comment>
			<description>A simple interface which provides a mechanism to map
 between a file name and a MIME type string.</description>
			<attribute name="@author">
				<description>Steven B. Byrne</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.1</description>
			</attribute>
		</comment>
		<methods>
			<method visibility="public" name="getContentTypeFor" returncomment="a &lt;code&gt;String&lt;/code&gt; indicating the MIME
 type for the specified file name." fulltype="java.lang.String" type="String">
				<comment>
					<description>Gets the MIME type for the specified file name.</description>
					<attribute name="@param">
						<description>fileName the specified file name</description>
					</attribute>
					<attribute name="@return">
						<description>a &lt;code&gt;String&lt;/code&gt; indicating the MIME
 type for the specified file name.</description>
					</attribute>
				</comment>
				<params>
					<param name="fileName" comment="the specified file name" fulltype="java.lang.String" type="String" />
				</params>
			</method>
		</methods>
	</jelclass>
	<jelclass abstract="true" superclass="Object" visibility="public" package="java.net" superclassfulltype="java.lang.Object" fulltype="java.net.CookieHandler" type="CookieHandler">
		<comment>
			<description>A CookieHandler object provides a callback mechanism to hook up a
 HTTP state management policy implementation into the HTTP protocol
 handler. The HTTP state management mechanism specifies a way to
 create a stateful session with HTTP requests and responses.

 &lt;p&gt;A system-wide CookieHandler that to used by the HTTP protocol
 handler can be registered by doing a
 CookieHandler.setDefault(CookieHandler). The currently registered
 CookieHandler can be retrieved by calling
 CookieHandler.getDefault().

 For more information on HTTP state management, see &lt;a
 href=&quot;http://www.ietf.org/rfc/rfc2965.txt&quot;&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2965: HTTP
 State Management Mechanism&lt;/i&gt;&lt;/a&gt;</description>
			<attribute name="@author">
				<description>Yingxian Wang</description>
			</attribute>
			<attribute name="@since">
				<description>1.5</description>
			</attribute>
		</comment>
		<fields>
			<field static="true" visibility="private" name="cookieHandler" fulltype="java.net.CookieHandler" type="CookieHandler">
				<comment>
					<description>The system-wide cookie handler that will apply cookies to the
 request headers and manage cookies from the response headers.</description>
					<attribute name="@see">
						<description>setDefault(CookieHandler)</description>
					</attribute>
					<attribute name="@see">
						<description>getDefault()</description>
					</attribute>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="public" name="CookieHandler" />
			<method static="true" synchronized="true" visibility="public" name="getDefault" returncomment="the system-wide cookie handler; A null return means
        there is no system-wide cookie handler currently set." fulltype="java.net.CookieHandler" type="CookieHandler">
				<comment>
					<description>Gets the system-wide cookie handler.</description>
					<attribute name="@return">
						<description>the system-wide cookie handler; A null return means
        there is no system-wide cookie handler currently set.</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException
       If a security manager has been installed and it denies
 {@link NetPermission}&lt;tt&gt;(&quot;getCookieHandler&quot;)&lt;/tt&gt;</description>
					</attribute>
					<attribute name="@see">
						<description>#setDefault(CookieHandler)</description>
					</attribute>
				</comment>
			</method>
			<method static="true" synchronized="true" visibility="public" name="setDefault" fulltype="void" type="void">
				<comment>
					<description>Sets (or unsets) the system-wide cookie handler.

 Note: non-standard http protocol handlers may ignore this setting.</description>
					<attribute name="@param">
						<description>cHandler The HTTP cookie handler, or
       &lt;code&gt;null&lt;/code&gt; to unset.</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException
       If a security manager has been installed and it denies
 {@link NetPermission}&lt;tt&gt;(&quot;setCookieHandler&quot;)&lt;/tt&gt;</description>
					</attribute>
					<attribute name="@see">
						<description>#getDefault()</description>
					</attribute>
				</comment>
				<params>
					<param name="cHandler" comment="The HTTP cookie handler, or
       &lt;code&gt;null&lt;/code&gt; to unset." fulltype="java.net.CookieHandler" type="CookieHandler" />
				</params>
			</method>
			<method abstract="true" visibility="public" name="get" returncomment="an immutable map from state management headers, with
            field names &quot;Cookie&quot; or &quot;Cookie2&quot; to a list of
            cookies containing state information" fulltype="java.util.Map" type="Map">
				<comment>
					<description>Gets all the applicable cookies from a cookie cache for the
 specified uri in the request header.

 HTTP protocol implementers should make sure that this method is
 called after all request headers related to choosing cookies
 are added, and before the request is sent.</description>
					<attribute name="@param">
						<description>uri a &lt;code&gt;URI&lt;/code&gt; to send cookies to in a request</description>
					</attribute>
					<attribute name="@param">
						<description>requestHeaders - a Map from request header
            field names to lists of field values representing
            the current request headers</description>
					</attribute>
					<attribute name="@return">
						<description>an immutable map from state management headers, with
            field names &quot;Cookie&quot; or &quot;Cookie2&quot; to a list of
            cookies containing state information</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException if an I/O error occurs</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if either argument is null</description>
					</attribute>
					<attribute name="@see">
						<description>#put(URI, Map)</description>
					</attribute>
				</comment>
				<params>
					<param name="uri" comment="a &lt;code&gt;URI&lt;/code&gt; to send cookies to in a request" fulltype="java.net.URI" type="URI" />
					<param name="requestHeaders" comment="- a Map from request header
            field names to lists of field values representing
            the current request headers" fulltype="java.util.Map" type="Map" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="public" name="put" fulltype="void" type="void">
				<comment>
					<description>Sets all the applicable cookies, examples are response header
 fields that are named Set-Cookie2, present in the response
 headers into a cookie cache.</description>
					<attribute name="@param">
						<description>uri a &lt;code&gt;URI&lt;/code&gt; where the cookies come from</description>
					</attribute>
					<attribute name="@param">
						<description>responseHeaders an immutable map from field names to
            lists of field values representing the response
            header fields returned</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException if an I/O error occurs</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if either argument is null</description>
					</attribute>
					<attribute name="@see">
						<description>#get(URI, Map)</description>
					</attribute>
				</comment>
				<params>
					<param name="uri" comment="a &lt;code&gt;URI&lt;/code&gt; where the cookies come from" fulltype="java.net.URI" type="URI" />
					<param name="responseHeaders" comment="an immutable map from field names to
            lists of field values representing the response
            header fields returned" fulltype="java.util.Map" type="Map" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass abstract="true" superclass="URLConnection" visibility="public" package="java.net" superclassfulltype="java.net.URLConnection" fulltype="java.net.JarURLConnection" type="JarURLConnection">
		<comment>
			<description>A URL Connection to a Java ARchive (JAR) file or an entry in a JAR
 file.

 &lt;p&gt;The syntax of a JAR URL is:

 &lt;pre&gt;
 jar:&amp;lt;url&amp;gt;!/{entry}
 &lt;/pre&gt;

 &lt;p&gt;for example:

 &lt;p&gt;&lt;code&gt;
 jar:http://www.foo.com/bar/baz.jar!/COM/foo/Quux.class&lt;br&gt;
 &lt;/code&gt;

 &lt;p&gt;Jar URLs should be used to refer to a JAR file or entries in
 a JAR file. The example above is a JAR URL which refers to a JAR
 entry. If the entry name is omitted, the URL refers to the whole
 JAR file:

 &lt;code&gt;
 jar:http://www.foo.com/bar/baz.jar!/
 &lt;/code&gt;

 &lt;p&gt;Users should cast the generic URLConnection to a
 JarURLConnection when they know that the URL they created is a JAR
 URL, and they need JAR-specific functionality. For example:

 &lt;pre&gt;
 URL url = new URL(&quot;jar:file:/home/duke/duke.jar!/&quot;);
 JarURLConnection jarConnection = (JarURLConnection)url.openConnection();
 Manifest manifest = jarConnection.getManifest();
 &lt;/pre&gt;

 &lt;p&gt;JarURLConnection instances can only be used to read from JAR files.
 It is not possible to get a {@link java.io.OutputStream} to modify or write
 to the underlying JAR file using this class.
 &lt;p&gt;Examples:

 &lt;dl&gt;

 &lt;dt&gt;A Jar entry
 &lt;dd&gt;&lt;code&gt;jar:http://www.foo.com/bar/baz.jar!/COM/foo/Quux.class&lt;/code&gt;

 &lt;dt&gt;A Jar file
 &lt;dd&gt;&lt;code&gt;jar:http://www.foo.com/bar/baz.jar!/&lt;/code&gt;

 &lt;dt&gt;A Jar directory
 &lt;dd&gt;&lt;code&gt;jar:http://www.foo.com/bar/baz.jar!/COM/foo/&lt;/code&gt;

 &lt;/dl&gt;

 &lt;p&gt;&lt;code&gt;!/&lt;/code&gt; is refered to as the &lt;em&gt;separator&lt;/em&gt;.

 &lt;p&gt;When constructing a JAR url via &lt;code&gt;new URL(context, spec)&lt;/code&gt;,
 the following rules apply:

 &lt;ul&gt;

 &lt;li&gt;if there is no context URL and the specification passed to the
 URL constructor doesn&apos;t contain a separator, the URL is considered
 to refer to a JarFile.

 &lt;li&gt;if there is a context URL, the context URL is assumed to refer
 to a JAR file or a Jar directory.

 &lt;li&gt;if the specification begins with a &apos;/&apos;, the Jar directory is
 ignored, and the spec is considered to be at the root of the Jar
 file.

 &lt;p&gt;Examples:

 &lt;dl&gt;

 &lt;dt&gt;context: &lt;b&gt;jar:http://www.foo.com/bar/jar.jar!/&lt;/b&gt;,
 spec:&lt;b&gt;baz/entry.txt&lt;/b&gt;

 &lt;dd&gt;url:&lt;b&gt;jar:http://www.foo.com/bar/jar.jar!/baz/entry.txt&lt;/b&gt;

 &lt;dt&gt;context: &lt;b&gt;jar:http://www.foo.com/bar/jar.jar!/baz&lt;/b&gt;,
 spec:&lt;b&gt;entry.txt&lt;/b&gt;

 &lt;dd&gt;url:&lt;b&gt;jar:http://www.foo.com/bar/jar.jar!/baz/entry.txt&lt;/b&gt;

 &lt;dt&gt;context: &lt;b&gt;jar:http://www.foo.com/bar/jar.jar!/baz&lt;/b&gt;,
 spec:&lt;b&gt;/entry.txt&lt;/b&gt;

 &lt;dd&gt;url:&lt;b&gt;jar:http://www.foo.com/bar/jar.jar!/entry.txt&lt;/b&gt;

 &lt;/dl&gt;

 &lt;/ul&gt;</description>
			<attribute name="@see">
				<description>java.net.URL</description>
			</attribute>
			<attribute name="@see">
				<description>java.net.URLConnection</description>
			</attribute>
			<attribute name="@see">
				<description>java.util.jar.JarFile</description>
			</attribute>
			<attribute name="@see">
				<description>java.util.jar.JarInputStream</description>
			</attribute>
			<attribute name="@see">
				<description>java.util.jar.Manifest</description>
			</attribute>
			<attribute name="@see">
				<description>java.util.zip.ZipEntry</description>
			</attribute>
			<attribute name="@author">
				<description>Benjamin Renaud</description>
			</attribute>
			<attribute name="@since">
				<description>1.2</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="private" name="jarFileURL" fulltype="java.net.URL" type="URL" />
			<field visibility="private" name="entryName" fulltype="java.lang.String" type="String" />
			<field visibility="protected" name="jarFileURLConnection" fulltype="java.net.URLConnection" type="URLConnection">
				<comment>
					<description>The connection to the JAR file URL, if the connection has been
 initiated. This should be set by connect.</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="protected" name="JarURLConnection">
				<comment>
					<description>Creates the new JarURLConnection to the specified URL.</description>
					<attribute name="@param">
						<description>url the URL</description>
					</attribute>
					<attribute name="@throws">
						<description>MalformedURLException if no legal protocol
 could be found in a specification string or the
 string could not be parsed.</description>
					</attribute>
				</comment>
				<params>
					<param name="url" comment="the URL" fulltype="java.net.URL" type="URL" />
				</params>
				<exceptions>
					<exception comment="if no legal protocol
 could be found in a specification string or the
 string could not be parsed." fulltype="java.net.MalformedURLException" type="MalformedURLException" />
				</exceptions>
			</constructor>
			<method visibility="private" name="parseSpecs" fulltype="void" type="void">
				<params>
					<param name="url" fulltype="java.net.URL" type="URL" />
				</params>
				<exceptions>
					<exception fulltype="java.net.MalformedURLException" type="MalformedURLException" />
				</exceptions>
			</method>
			<method visibility="public" name="getJarFileURL" returncomment="the URL for the Jar file for this connection." fulltype="java.net.URL" type="URL">
				<comment>
					<description>Returns the URL for the Jar file for this connection.</description>
					<attribute name="@return">
						<description>the URL for the Jar file for this connection.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getEntryName" returncomment="the entry name for this connection, if any." fulltype="java.lang.String" type="String">
				<comment>
					<description>Return the entry name for this connection. This method
 returns null if the JAR file URL corresponding to this
 connection points to a JAR file and not a JAR file entry.</description>
					<attribute name="@return">
						<description>the entry name for this connection, if any.</description>
					</attribute>
				</comment>
			</method>
			<method abstract="true" visibility="public" name="getJarFile" returncomment="the JAR file for this connection. If the connection is
 a connection to an entry of a JAR file, the JAR file object is
 returned" fulltype="java.util.jar.JarFile" type="JarFile">
				<comment>
					<description>Return the JAR file for this connection.</description>
					<attribute name="@return">
						<description>the JAR file for this connection. If the connection is
 a connection to an entry of a JAR file, the JAR file object is
 returned</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException if an IOException occurs while trying to
 connect to the JAR file for this connection.</description>
					</attribute>
					<attribute name="@see">
						<description>#connect</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an IOException occurs while trying to
 connect to the JAR file for this connection." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="getManifest" returncomment="the manifest object corresponding to the JAR file object
 for this connection." fulltype="java.util.jar.Manifest" type="Manifest">
				<comment>
					<description>Returns the Manifest for this connection, or null if none.</description>
					<attribute name="@return">
						<description>the manifest object corresponding to the JAR file object
 for this connection.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException if getting the JAR file for this
 connection causes an IOException to be trown.</description>
					</attribute>
					<attribute name="@see">
						<description>#getJarFile</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if getting the JAR file for this
 connection causes an IOException to be trown." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="getJarEntry" returncomment="the JAR entry object for this connection, or null if
 the JAR URL for this connection points to a JAR file." fulltype="java.util.jar.JarEntry" type="JarEntry">
				<comment>
					<description>Return the JAR entry object for this connection, if any. This
 method returns null if the JAR file URL corresponding to this
 connection points to a JAR file and not a JAR file entry.</description>
					<attribute name="@return">
						<description>the JAR entry object for this connection, or null if
 the JAR URL for this connection points to a JAR file.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException if getting the JAR file for this
 connection causes an IOException to be trown.</description>
					</attribute>
					<attribute name="@see">
						<description>#getJarFile</description>
					</attribute>
					<attribute name="@see">
						<description>#getJarEntry</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if getting the JAR file for this
 connection causes an IOException to be trown." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="getAttributes" returncomment="the Attributes object for this connection if the URL
 for it points to a JAR file entry, null otherwise." fulltype="java.util.jar.Attributes" type="Attributes">
				<comment>
					<description>Return the Attributes object for this connection if the URL
 for it points to a JAR file entry, null otherwise.</description>
					<attribute name="@return">
						<description>the Attributes object for this connection if the URL
 for it points to a JAR file entry, null otherwise.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException if getting the JAR entry causes an
 IOException to be thrown.</description>
					</attribute>
					<attribute name="@see">
						<description>#getJarEntry</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if getting the JAR entry causes an
 IOException to be thrown." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="getMainAttributes" returncomment="the main Attributes for the JAR file for this
 connection." fulltype="java.util.jar.Attributes" type="Attributes">
				<comment>
					<description>Returns the main Attributes for the JAR file for this
 connection.</description>
					<attribute name="@return">
						<description>the main Attributes for the JAR file for this
 connection.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException if getting the manifest causes an
 IOException to be thrown.</description>
					</attribute>
					<attribute name="@see">
						<description>#getJarFile</description>
					</attribute>
					<attribute name="@see">
						<description>#getManifest</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if getting the manifest causes an
 IOException to be thrown." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="getCertificates" returncomment="the Certificate object for this connection if the URL
 for it points to a JAR file entry, null otherwise." fulltype="java.security.cert.Certificate[]" type="Certificate">
				<comment>
					<description>Return the Certificate object for this connection if the URL
 for it points to a JAR file entry, null otherwise. This method
 can only be called once
 the connection has been completely verified by reading
 from the input stream until the end of the stream has been
 reached. Otherwise, this method will return &lt;code&gt;null&lt;/code&gt;</description>
					<attribute name="@return">
						<description>the Certificate object for this connection if the URL
 for it points to a JAR file entry, null otherwise.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException if getting the JAR entry causes an
 IOException to be thrown.</description>
					</attribute>
					<attribute name="@see">
						<description>#getJarEntry</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if getting the JAR entry causes an
 IOException to be thrown." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass abstract="true" visibility="package-private" package="java.net" interface="true" fulltype="java.net.SocksConsts" type="SocksConsts">
		<comment>
			<description>Constants used by the SOCKS protocol implementation.</description>
		</comment>
		<fields>
			<field final="true" static="true" const="4" visibility="public" name="PROTO_VERS4" constexpr="4" fulltype="int" type="int" />
			<field final="true" static="true" const="5" visibility="public" name="PROTO_VERS" constexpr="5" fulltype="int" type="int" />
			<field final="true" static="true" const="1080" visibility="public" name="DEFAULT_PORT" constexpr="1080" fulltype="int" type="int" />
			<field final="true" static="true" const="0" visibility="public" name="NO_AUTH" constexpr="0" fulltype="int" type="int" />
			<field final="true" static="true" const="1" visibility="public" name="GSSAPI" constexpr="1" fulltype="int" type="int" />
			<field final="true" static="true" const="2" visibility="public" name="USER_PASSW" constexpr="2" fulltype="int" type="int" />
			<field final="true" static="true" const="-1" visibility="public" name="NO_METHODS" constexpr="-1" fulltype="int" type="int" />
			<field final="true" static="true" const="1" visibility="public" name="CONNECT" constexpr="1" fulltype="int" type="int" />
			<field final="true" static="true" const="2" visibility="public" name="BIND" constexpr="2" fulltype="int" type="int" />
			<field final="true" static="true" const="3" visibility="public" name="UDP_ASSOC" constexpr="3" fulltype="int" type="int" />
			<field final="true" static="true" const="1" visibility="public" name="IPV4" constexpr="1" fulltype="int" type="int" />
			<field final="true" static="true" const="3" visibility="public" name="DOMAIN_NAME" constexpr="3" fulltype="int" type="int" />
			<field final="true" static="true" const="4" visibility="public" name="IPV6" constexpr="4" fulltype="int" type="int" />
			<field final="true" static="true" const="0" visibility="public" name="REQUEST_OK" constexpr="0" fulltype="int" type="int" />
			<field final="true" static="true" const="1" visibility="public" name="GENERAL_FAILURE" constexpr="1" fulltype="int" type="int" />
			<field final="true" static="true" const="2" visibility="public" name="NOT_ALLOWED" constexpr="2" fulltype="int" type="int" />
			<field final="true" static="true" const="3" visibility="public" name="NET_UNREACHABLE" constexpr="3" fulltype="int" type="int" />
			<field final="true" static="true" const="4" visibility="public" name="HOST_UNREACHABLE" constexpr="4" fulltype="int" type="int" />
			<field final="true" static="true" const="5" visibility="public" name="CONN_REFUSED" constexpr="5" fulltype="int" type="int" />
			<field final="true" static="true" const="6" visibility="public" name="TTL_EXPIRED" constexpr="6" fulltype="int" type="int" />
			<field final="true" static="true" const="7" visibility="public" name="CMD_NOT_SUPPORTED" constexpr="7" fulltype="int" type="int" />
			<field final="true" static="true" const="8" visibility="public" name="ADDR_TYPE_NOT_SUP" constexpr="8" fulltype="int" type="int" />
		</fields>
	</jelclass>
	<jelclass superclass="Object" visibility="public" package="java.net" superclassfulltype="java.lang.Object" fulltype="java.net.Proxy" type="Proxy">
		<comment>
			<description>This class represents a proxy setting, typically a type (http, socks) and
 a socket address.
 A &lt;code&gt;Proxy&lt;/code&gt; is an immutable object.</description>
			<attribute name="@see">
				<description>java.net.ProxySelector</description>
			</attribute>
			<attribute name="@author">
				<description>Yingxian Wang</description>
			</attribute>
			<attribute name="@author">
				<description>Jean-Christophe Collet</description>
			</attribute>
			<attribute name="@since">
				<description>1.5</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="private" name="type" fulltype="java.net.Proxy.Type" type="Proxy.Type" />
			<field visibility="private" name="sa" fulltype="java.net.SocketAddress" type="SocketAddress" />
			<field final="true" static="true" visibility="public" name="NO_PROXY" fulltype="java.net.Proxy" type="Proxy">
				<comment>
					<description>A proxy setting that represents a &lt;code&gt;DIRECT&lt;/code&gt; connection,
 basically telling the protocol handler not to use any proxying.
 Used, for instance, to create sockets bypassing any other global
 proxy settings (like SOCKS):
 &lt;P&gt;
 &lt;code&gt;Socket s = new Socket(Proxy.NO_PROXY);&lt;/code&gt;&lt;br&gt;
 &lt;P&gt;</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="private" name="Proxy" />
			<constructor visibility="public" name="Proxy">
				<comment>
					<description>Creates an entry representing a PROXY connection.
 Certain combinations are illegal. For instance, for types Http, and
 Socks, a SocketAddress &lt;b&gt;must&lt;/b&gt; be provided.
 &lt;P&gt;
 Use the &lt;code&gt;Proxy.NO_PROXY&lt;/code&gt; constant
 for representing a direct connection.</description>
					<attribute name="@param">
						<description>type the &lt;code&gt;Type&lt;/code&gt; of the proxy</description>
					</attribute>
					<attribute name="@param">
						<description>sa the &lt;code&gt;SocketAddress&lt;/code&gt; for that proxy</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException when the type and the address are
 incompatible</description>
					</attribute>
				</comment>
				<params>
					<param name="type" comment="the &lt;code&gt;Type&lt;/code&gt; of the proxy" fulltype="java.net.Proxy.Type" type="Proxy.Type" />
					<param name="sa" comment="the &lt;code&gt;SocketAddress&lt;/code&gt; for that proxy" fulltype="java.net.SocketAddress" type="SocketAddress" />
				</params>
			</constructor>
			<method visibility="public" name="type" returncomment="a Type representing the proxy type" fulltype="java.net.Proxy.Type" type="Proxy.Type">
				<comment>
					<description>Returns the proxy type.</description>
					<attribute name="@return">
						<description>a Type representing the proxy type</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="address" returncomment="a &lt;code&gt;SocketAddress&lt;/code&gt; representing the socket end
         point of the proxy" fulltype="java.net.SocketAddress" type="SocketAddress">
				<comment>
					<description>Returns the socket address of the proxy, or
 &lt;code&gt;null&lt;/code&gt; if its a direct connection.</description>
					<attribute name="@return">
						<description>a &lt;code&gt;SocketAddress&lt;/code&gt; representing the socket end
         point of the proxy</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="toString" returncomment="a string representation of this object." fulltype="java.lang.String" type="String">
				<comment>
					<description>Constructs a string representation of this Proxy.
 This String is constructed by calling toString() on its type
 and concatenating &quot; @ &quot; and the toString() result from its address
 if its type is not &lt;code&gt;DIRECT&lt;/code&gt;.</description>
					<attribute name="@return">
						<description>a string representation of this object.</description>
					</attribute>
				</comment>
			</method>
			<method final="true" visibility="public" name="equals" returncomment="&lt;code&gt;true&lt;/code&gt; if the objects are the same;
          &lt;code&gt;false&lt;/code&gt; otherwise." fulltype="boolean" type="boolean">
				<comment>
					<description>Compares this object against the specified object.
 The result is &lt;code&gt;true&lt;/code&gt; if and only if the argument is
 not &lt;code&gt;null&lt;/code&gt; and it represents the same proxy as
 this object.
 &lt;p&gt;
 Two instances of &lt;code&gt;Proxy&lt;/code&gt; represent the same
 address if both the SocketAddresses and type are equal.</description>
					<attribute name="@param">
						<description>obj   the object to compare against.</description>
					</attribute>
					<attribute name="@return">
						<description>&lt;code&gt;true&lt;/code&gt; if the objects are the same;
          &lt;code&gt;false&lt;/code&gt; otherwise.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.InetSocketAddress#equals(java.lang.Object)</description>
					</attribute>
				</comment>
				<params>
					<param name="obj" comment="the object to compare against." fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method final="true" visibility="public" name="hashCode" returncomment="a hash code value for this Proxy." fulltype="int" type="int">
				<comment>
					<description>Returns a hashcode for this Proxy.</description>
					<attribute name="@return">
						<description>a hash code value for this Proxy.</description>
					</attribute>
				</comment>
			</method>
		</methods>
		<jelclass final="true" superclass="Enum" visibility="public" package="java.net" serializable="true" superclassfulltype="java.lang.Enum" fulltype="java.net.Proxy.Type" type="Proxy.Type">
			<comment>
				<description>Represents the proxy type.</description>
				<attribute name="@since">
					<description>1.5</description>
				</attribute>
			</comment>
			<fields>
				<field final="true" static="true" visibility="public" name="DIRECT" fulltype="java.net.Proxy.Type" type="Proxy.Type">
					<comment>
						<description>Represents a direct connection, or the absence of a proxy.</description>
					</comment>
				</field>
				<field final="true" static="true" visibility="public" name="HTTP" fulltype="java.net.Proxy.Type" type="Proxy.Type">
					<comment>
						<description>Represents proxy for high level protocols such as HTTP or FTP.</description>
					</comment>
				</field>
				<field final="true" static="true" visibility="public" name="SOCKS" fulltype="java.net.Proxy.Type" type="Proxy.Type">
					<comment>
						<description>Represents a SOCKS (V4 or V5) proxy.</description>
					</comment>
				</field>
			</fields>
			<methods>
				<constructor visibility="private" name="Proxy.Type" />
				<method static="true" visibility="public" name="values" fulltype="java.net.Proxy.Type[]" type="Proxy.Type" />
				<method static="true" visibility="public" name="valueOf" fulltype="java.net.Proxy.Type" type="Proxy.Type">
					<params>
						<param name="name" fulltype="java.lang.String" type="String" />
					</params>
				</method>
			</methods>
		</jelclass>
	</jelclass>
	<jelclass final="true" superclass="Enum" visibility="public" package="java.net" serializable="true" superclassfulltype="java.lang.Enum" fulltype="java.net.Proxy.Type" type="Proxy.Type">
		<comment>
			<description>Represents the proxy type.</description>
			<attribute name="@since">
				<description>1.5</description>
			</attribute>
		</comment>
		<fields>
			<field final="true" static="true" visibility="public" name="DIRECT" fulltype="java.net.Proxy.Type" type="Proxy.Type">
				<comment>
					<description>Represents a direct connection, or the absence of a proxy.</description>
				</comment>
			</field>
			<field final="true" static="true" visibility="public" name="HTTP" fulltype="java.net.Proxy.Type" type="Proxy.Type">
				<comment>
					<description>Represents proxy for high level protocols such as HTTP or FTP.</description>
				</comment>
			</field>
			<field final="true" static="true" visibility="public" name="SOCKS" fulltype="java.net.Proxy.Type" type="Proxy.Type">
				<comment>
					<description>Represents a SOCKS (V4 or V5) proxy.</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="private" name="Proxy.Type" />
			<method static="true" visibility="public" name="values" fulltype="java.net.Proxy.Type[]" type="Proxy.Type" />
			<method static="true" visibility="public" name="valueOf" fulltype="java.net.Proxy.Type" type="Proxy.Type">
				<params>
					<param name="name" fulltype="java.lang.String" type="String" />
				</params>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="Object" visibility="public" package="java.net" serializable="true" superclassfulltype="java.lang.Object" fulltype="java.net.InetAddress" type="InetAddress">
		<implements>
			<interface fulltype="java.io.Serializable" type="Serializable" />
		</implements>
		<comment>
			<description>This class represents an Internet Protocol (IP) address.

 &lt;p&gt; An IP address is either a 32-bit or 128-bit unsigned number
 used by IP, a lower-level protocol on which protocols like UDP and
 TCP are built. The IP address architecture is defined by &lt;a
 href=&quot;http://www.ietf.org/rfc/rfc790.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;790:
 Assigned Numbers&lt;/i&gt;&lt;/a&gt;, &lt;a
 href=&quot;http://www.ietf.org/rfc/rfc1918.txt&quot;&gt; &lt;i&gt;RFC&amp;nbsp;1918:
 Address Allocation for Private Internets&lt;/i&gt;&lt;/a&gt;, &lt;a
 href=&quot;http://www.ietf.org/rfc/rfc2365.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2365:
 Administratively Scoped IP Multicast&lt;/i&gt;&lt;/a&gt;, and &lt;a
 href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2373: IP
 Version 6 Addressing Architecture&lt;/i&gt;&lt;/a&gt;. An instance of an
 InetAddress consists of an IP address and possibly its
 corresponding host name (depending on whether it is constructed
 with a host name or whether it has already done reverse host name
 resolution).

 &lt;h4&gt; Address types &lt;/h4&gt;

 &lt;blockquote&gt;&lt;table cellspacing=2 summary=&quot;Description of unicast and multicast address types&quot;&gt;
   &lt;tr&gt;&lt;th valign=top&gt;&lt;i&gt;unicast&lt;/i&gt;&lt;/th&gt;
       &lt;td&gt;An identifier for a single interface. A packet sent to
         a unicast address is delivered to the interface identified by
         that address.

         &lt;p&gt; The Unspecified Address -- Also called anylocal or wildcard
         address. It must never be assigned to any node. It indicates the
         absence of an address. One example of its use is as the target of
         bind, which allows a server to accept a client connection on any
         interface, in case the server host has multiple interfaces.

         &lt;p&gt; The &lt;i&gt;unspecified&lt;/i&gt; address must not be used as
         the destination address of an IP packet.

         &lt;p&gt; The &lt;i&gt;Loopback&lt;/i&gt; Addresses -- This is the address
         assigned to the loopback interface. Anything sent to this
         IP address loops around and becomes IP input on the local
         host. This address is often used when testing a
         client.&lt;/td&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;th valign=top&gt;&lt;i&gt;multicast&lt;/i&gt;&lt;/th&gt;
       &lt;td&gt;An identifier for a set of interfaces (typically belonging
         to different nodes). A packet sent to a multicast address is
         delivered to all interfaces identified by that address.&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;&lt;/blockquote&gt;

 &lt;h4&gt; IP address scope &lt;/h4&gt;

 &lt;p&gt; &lt;i&gt;Link-local&lt;/i&gt; addresses are designed to be used for addressing
 on a single link for purposes such as auto-address configuration,
 neighbor discovery, or when no routers are present.

 &lt;p&gt; &lt;i&gt;Site-local&lt;/i&gt; addresses are designed to be used for addressing
 inside of a site without the need for a global prefix.

 &lt;p&gt; &lt;i&gt;Global&lt;/i&gt; addresses are unique across the internet.

 &lt;h4&gt; Textual representation of IP addresses &lt;/h4&gt;

 The textual representation of an IP address is address family specific.

 &lt;p&gt;

 For IPv4 address format, please refer to &lt;A
 HREF=&quot;Inet4Address.html#format&quot;&gt;Inet4Address#format&lt;/A&gt;; For IPv6
 address format, please refer to &lt;A
 HREF=&quot;Inet6Address.html#format&quot;&gt;Inet6Address#format&lt;/A&gt;.

 &lt;h4&gt; Host Name Resolution &lt;/h4&gt;

 Host name-to-IP address &lt;i&gt;resolution&lt;/i&gt; is accomplished through
 the use of a combination of local machine configuration information
 and network naming services such as the Domain Name System (DNS)
 and Network Information Service(NIS). The particular naming
 services(s) being used is by default the local machine configured
 one. For any host name, its corresponding IP address is returned.

 &lt;p&gt; &lt;i&gt;Reverse name resolution&lt;/i&gt; means that for any IP address,
 the host associated with the IP address is returned.

 &lt;p&gt; The InetAddress class provides methods to resolve host names to
 their IP addresses and vice versa.

 &lt;h4&gt; InetAddress Caching &lt;/h4&gt;

 The InetAddress class has a cache to store successful as well as
 unsuccessful host name resolutions.

 &lt;p&gt; By default, when a security manager is installed, in order to
 protect against DNS spoofing attacks,
 the result of positive host name resolutions are
 cached forever. When a security manager is not installed, the default
 behavior is to cache entries for a finite (implementation dependent)
 period of time. The result of unsuccessful host
 name resolution is cached for a very short period of time (10
 seconds) to improve performance.

 &lt;p&gt; If the default behavior is not desired, then a Java security property
 can be set to a different Time-to-live (TTL) value for positive
 caching. Likewise, a system admin can configure a different
 negative caching TTL value when needed.

 &lt;p&gt; Two Java security properties control the TTL values used for
  positive and negative host name resolution caching:

 &lt;blockquote&gt;
 &lt;dl&gt;
 &lt;dt&gt;&lt;b&gt;networkaddress.cache.ttl&lt;/b&gt;&lt;/dt&gt;
 &lt;dd&gt;Indicates the caching policy for successful name lookups from
 the name service. The value is specified as as integer to indicate
 the number of seconds to cache the successful lookup. The default
 setting is to cache for an implementation specific period of time.
 &lt;p&gt;
 A value of -1 indicates &quot;cache forever&quot;.
 &lt;/dd&gt;
 &lt;p&gt;
 &lt;dt&gt;&lt;b&gt;networkaddress.cache.negative.ttl&lt;/b&gt; (default: 10)&lt;/dt&gt;
 &lt;dd&gt;Indicates the caching policy for un-successful name lookups
 from the name service. The value is specified as as integer to
 indicate the number of seconds to cache the failure for
 un-successful lookups.
 &lt;p&gt;
 A value of 0 indicates &quot;never cache&quot;.
 A value of -1 indicates &quot;cache forever&quot;.
 &lt;/dd&gt;
 &lt;/dl&gt;
 &lt;/blockquote&gt;</description>
			<attribute name="@author">
				<description>Chris Warth</description>
			</attribute>
			<attribute name="@see">
				<description>java.net.InetAddress#getByAddress(byte[])</description>
			</attribute>
			<attribute name="@see">
				<description>java.net.InetAddress#getByAddress(java.lang.String, byte[])</description>
			</attribute>
			<attribute name="@see">
				<description>java.net.InetAddress#getAllByName(java.lang.String)</description>
			</attribute>
			<attribute name="@see">
				<description>java.net.InetAddress#getByName(java.lang.String)</description>
			</attribute>
			<attribute name="@see">
				<description>java.net.InetAddress#getLocalHost()</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.0</description>
			</attribute>
		</comment>
		<fields>
			<field final="true" static="true" const="1" visibility="package-private" name="IPv4" constexpr="1" fulltype="int" type="int">
				<comment>
					<description>Specify the address family: Internet Protocol, Version 4</description>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</field>
			<field final="true" static="true" const="2" visibility="package-private" name="IPv6" constexpr="2" fulltype="int" type="int">
				<comment>
					<description>Specify the address family: Internet Protocol, Version 6</description>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</field>
			<field static="true" visibility="package-private" transient="true" name="preferIPv6Address" fulltype="boolean" type="boolean" />
			<field visibility="package-private" name="hostName" fulltype="java.lang.String" type="String">
				<comment>
					<attribute name="@serial" />
				</comment>
			</field>
			<field visibility="package-private" name="address" fulltype="int" type="int">
				<comment>
					<description>Holds a 32-bit IPv4 address.</description>
					<attribute name="@serial" />
				</comment>
			</field>
			<field visibility="package-private" name="family" fulltype="int" type="int">
				<comment>
					<description>Specifies the address family type, for instance, &apos;1&apos; for IPv4
 addresses, and &apos;2&apos; for IPv6 addresses.</description>
					<attribute name="@serial" />
				</comment>
			</field>
			<field static="true" visibility="private" name="nameServices" fulltype="java.util.List" type="List" />
			<field visibility="private" transient="true" name="canonicalHostName" fulltype="java.lang.String" type="String" />
			<field final="true" static="true" const="3286316764910316507" visibility="private" name="serialVersionUID" constexpr="3286316764910316507L" fulltype="long" type="long">
				<comment>
					<description>use serialVersionUID from JDK 1.0.2 for interoperability</description>
				</comment>
			</field>
			<field static="true" visibility="private" name="addressCache" fulltype="java.net.InetAddress.Cache" type="InetAddress.Cache" />
			<field static="true" visibility="private" name="negativeCache" fulltype="java.net.InetAddress.Cache" type="InetAddress.Cache" />
			<field static="true" visibility="private" name="addressCacheInit" fulltype="boolean" type="boolean" />
			<field static="true" visibility="package-private" name="unknown_array" fulltype="java.net.InetAddress[]" type="InetAddress" />
			<field static="true" visibility="package-private" name="impl" fulltype="java.net.InetAddressImpl" type="InetAddressImpl" />
			<field static="true" visibility="private" name="lookupTable" fulltype="java.util.HashMap" type="HashMap" />
			<field static="true" visibility="private" name="cachedLocalHost" fulltype="java.net.InetAddress" type="InetAddress" />
			<field static="true" visibility="private" name="cacheTime" fulltype="long" type="long" />
			<field final="true" static="true" const="5000" visibility="private" name="maxCacheTime" constexpr="5000L" fulltype="long" type="long" />
			<field final="true" static="true" visibility="private" name="cacheLock" fulltype="java.lang.Object" type="Object" />
		</fields>
		<methods>
			<constructor visibility="package-private" name="InetAddress">
				<comment>
					<description>Constructor for the Socket.accept() method.
 This creates an empty InetAddress, which is filled in by
 the accept() method.  This InetAddress, however, is not
 put in the address cache, since it is not created by name.</description>
				</comment>
			</constructor>
			<method visibility="private" name="readResolve" returncomment="the alternate object to the de-serialized object." fulltype="java.lang.Object" type="Object">
				<comment>
					<description>Replaces the de-serialized object with an Inet4Address object.</description>
					<attribute name="@return">
						<description>the alternate object to the de-serialized object.</description>
					</attribute>
					<attribute name="@throws">
						<description>ObjectStreamException if a new object replacing this
 object could not be created</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if a new object replacing this
 object could not be created" fulltype="java.io.ObjectStreamException" type="ObjectStreamException" />
				</exceptions>
			</method>
			<method visibility="public" name="isMulticastAddress" returncomment="a &lt;code&gt;boolean&lt;/code&gt; indicating if the InetAddress is
 an IP multicast address" fulltype="boolean" type="boolean">
				<comment>
					<description>Utility routine to check if the InetAddress is an
 IP multicast address.</description>
					<attribute name="@return">
						<description>a &lt;code&gt;boolean&lt;/code&gt; indicating if the InetAddress is
 an IP multicast address</description>
					</attribute>
					<attribute name="@since">
						<description>JDK1.1</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="isAnyLocalAddress" returncomment="a &lt;code&gt;boolean&lt;/code&gt; indicating if the Inetaddress is
         a wildcard address." fulltype="boolean" type="boolean">
				<comment>
					<description>Utility routine to check if the InetAddress in a wildcard address.</description>
					<attribute name="@return">
						<description>a &lt;code&gt;boolean&lt;/code&gt; indicating if the Inetaddress is
         a wildcard address.</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="isLoopbackAddress" returncomment="a &lt;code&gt;boolean&lt;/code&gt; indicating if the InetAddress is
 a loopback address; or false otherwise." fulltype="boolean" type="boolean">
				<comment>
					<description>Utility routine to check if the InetAddress is a loopback address.</description>
					<attribute name="@return">
						<description>a &lt;code&gt;boolean&lt;/code&gt; indicating if the InetAddress is
 a loopback address; or false otherwise.</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="isLinkLocalAddress" returncomment="a &lt;code&gt;boolean&lt;/code&gt; indicating if the InetAddress is
 a link local address; or false if address is not a link local unicast address." fulltype="boolean" type="boolean">
				<comment>
					<description>Utility routine to check if the InetAddress is an link local address.</description>
					<attribute name="@return">
						<description>a &lt;code&gt;boolean&lt;/code&gt; indicating if the InetAddress is
 a link local address; or false if address is not a link local unicast address.</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="isSiteLocalAddress" returncomment="a &lt;code&gt;boolean&lt;/code&gt; indicating if the InetAddress is
 a site local address; or false if address is not a site local unicast address." fulltype="boolean" type="boolean">
				<comment>
					<description>Utility routine to check if the InetAddress is a site local address.</description>
					<attribute name="@return">
						<description>a &lt;code&gt;boolean&lt;/code&gt; indicating if the InetAddress is
 a site local address; or false if address is not a site local unicast address.</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="isMCGlobal" returncomment="a &lt;code&gt;boolean&lt;/code&gt; indicating if the address has
         is a multicast address of global scope, false if it is not
         of global scope or it is not a multicast address" fulltype="boolean" type="boolean">
				<comment>
					<description>Utility routine to check if the multicast address has global scope.</description>
					<attribute name="@return">
						<description>a &lt;code&gt;boolean&lt;/code&gt; indicating if the address has
         is a multicast address of global scope, false if it is not
         of global scope or it is not a multicast address</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="isMCNodeLocal" returncomment="a &lt;code&gt;boolean&lt;/code&gt; indicating if the address has
         is a multicast address of node-local scope, false if it is not
         of node-local scope or it is not a multicast address" fulltype="boolean" type="boolean">
				<comment>
					<description>Utility routine to check if the multicast address has node scope.</description>
					<attribute name="@return">
						<description>a &lt;code&gt;boolean&lt;/code&gt; indicating if the address has
         is a multicast address of node-local scope, false if it is not
         of node-local scope or it is not a multicast address</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="isMCLinkLocal" returncomment="a &lt;code&gt;boolean&lt;/code&gt; indicating if the address has
         is a multicast address of link-local scope, false if it is not
         of link-local scope or it is not a multicast address" fulltype="boolean" type="boolean">
				<comment>
					<description>Utility routine to check if the multicast address has link scope.</description>
					<attribute name="@return">
						<description>a &lt;code&gt;boolean&lt;/code&gt; indicating if the address has
         is a multicast address of link-local scope, false if it is not
         of link-local scope or it is not a multicast address</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="isMCSiteLocal" returncomment="a &lt;code&gt;boolean&lt;/code&gt; indicating if the address has
         is a multicast address of site-local scope, false if it is not
         of site-local scope or it is not a multicast address" fulltype="boolean" type="boolean">
				<comment>
					<description>Utility routine to check if the multicast address has site scope.</description>
					<attribute name="@return">
						<description>a &lt;code&gt;boolean&lt;/code&gt; indicating if the address has
         is a multicast address of site-local scope, false if it is not
         of site-local scope or it is not a multicast address</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="isMCOrgLocal" returncomment="a &lt;code&gt;boolean&lt;/code&gt; indicating if the address has
         is a multicast address of organization-local scope,
         false if it is not of organization-local scope
         or it is not a multicast address" fulltype="boolean" type="boolean">
				<comment>
					<description>Utility routine to check if the multicast address has organization scope.</description>
					<attribute name="@return">
						<description>a &lt;code&gt;boolean&lt;/code&gt; indicating if the address has
         is a multicast address of organization-local scope,
         false if it is not of organization-local scope
         or it is not a multicast address</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="isReachable" returncomment="a &lt;code&gt;boolean&lt;/code&gt; indicating if the address is reachable." fulltype="boolean" type="boolean">
				<comment>
					<description>Test whether that address is reachable. Best effort is made by the
 implementation to try to reach the host, but firewalls and server
 configuration may block requests resulting in a unreachable status
 while some specific ports may be accessible.
 A typical implementation will use ICMP ECHO REQUESTs if the
 privilege can be obtained, otherwise it will try to establish
 a TCP connection on port 7 (Echo) of the destination host.
 &lt;p&gt;
 The timeout value, in milliseconds, indicates the maximum amount of time
 the try should take. If the operation times out before getting an
 answer, the host is deemed unreachable. A negative value will result
 in an IllegalArgumentException being thrown.</description>
					<attribute name="@param">
						<description>timeout the time, in milliseconds, before the call aborts</description>
					</attribute>
					<attribute name="@return">
						<description>a &lt;code&gt;boolean&lt;/code&gt; indicating if the address is reachable.</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException if a network error occurs</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if &lt;code&gt;timeout&lt;/code&gt; is negative.</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
				<params>
					<param name="timeout" comment="the time, in milliseconds, before the call aborts" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if a network error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="isReachable" returncomment="a &lt;code&gt;boolean&lt;/code&gt;indicating if the address is reachable." fulltype="boolean" type="boolean">
				<comment>
					<description>Test whether that address is reachable. Best effort is made by the
 implementation to try to reach the host, but firewalls and server
 configuration may block requests resulting in a unreachable status
 while some specific ports may be accessible.
 A typical implementation will use ICMP ECHO REQUESTs if the
 privilege can be obtained, otherwise it will try to establish
 a TCP connection on port 7 (Echo) of the destination host.
 &lt;p&gt;
 The &lt;code&gt;network interface&lt;/code&gt; and &lt;code&gt;ttl&lt;/code&gt; parameters
 let the caller specify which network interface the test will go through
 and the maximum number of hops the packets should go through.
 A negative value for the &lt;code&gt;ttl&lt;/code&gt; will result in an
 IllegalArgumentException being thrown.
 &lt;p&gt;
 The timeout value, in milliseconds, indicates the maximum amount of time
 the try should take. If the operation times out before getting an
 answer, the host is deemed unreachable. A negative value will result
 in an IllegalArgumentException being thrown.</description>
					<attribute name="@param">
						<description>netif   the NetworkInterface through which the
                    test will be done, or null for any interface</description>
					</attribute>
					<attribute name="@param">
						<description>ttl     the maximum numbers of hops to try or 0 for the
                  default</description>
					</attribute>
					<attribute name="@param">
						<description>timeout the time, in milliseconds, before the call aborts</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if either &lt;code&gt;timeout&lt;/code&gt;
                          or &lt;code&gt;ttl&lt;/code&gt; are negative.</description>
					</attribute>
					<attribute name="@return">
						<description>a &lt;code&gt;boolean&lt;/code&gt;indicating if the address is reachable.</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException if a network error occurs</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
				<params>
					<param name="netif" comment="the NetworkInterface through which the
                    test will be done, or null for any interface" fulltype="java.net.NetworkInterface" type="NetworkInterface" />
					<param name="ttl" comment="the maximum numbers of hops to try or 0 for the
                  default" fulltype="int" type="int" />
					<param name="timeout" comment="the time, in milliseconds, before the call aborts" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if a network error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="getHostName" returncomment="the host name for this IP address, or if the operation
    is not allowed by the security check, the textual
    representation of the IP address." fulltype="java.lang.String" type="String">
				<comment>
					<description>Gets the host name for this IP address.

 &lt;p&gt;If this InetAddress was created with a host name,
 this host name will be remembered and returned;
 otherwise, a reverse name lookup will be performed
 and the result will be returned based on the system
 configured name lookup service. If a lookup of the name service
 is required, call
 {@link #getCanonicalHostName() getCanonicalHostName}.

 &lt;p&gt;If there is a security manager, its
 &lt;code&gt;checkConnect&lt;/code&gt; method is first called
 with the hostname and &lt;code&gt;-1&lt;/code&gt;
 as its arguments to see if the operation is allowed.
 If the operation is not allowed, it will return
 the textual representation of the IP address.</description>
					<attribute name="@return">
						<description>the host name for this IP address, or if the operation
    is not allowed by the security check, the textual
    representation of the IP address.</description>
					</attribute>
					<attribute name="@see">
						<description>InetAddress#getCanonicalHostName</description>
					</attribute>
					<attribute name="@see">
						<description>SecurityManager#checkConnect</description>
					</attribute>
				</comment>
			</method>
			<method visibility="package-private" name="getHostName" returncomment="the host name for this IP address, or if the operation
    is not allowed by the security check, the textual
    representation of the IP address." fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the hostname for this address.
 If the host is equal to null, then this address refers to any
 of the local machine&apos;s available network addresses.
 this is package private so SocketPermission can make calls into
 here without a security check.

 &lt;p&gt;If there is a security manager, this method first
 calls its &lt;code&gt;checkConnect&lt;/code&gt; method
 with the hostname and &lt;code&gt;-1&lt;/code&gt;
 as its arguments to see if the calling code is allowed to know
 the hostname for this IP address, i.e., to connect to the host.
 If the operation is not allowed, it will return
 the textual representation of the IP address.</description>
					<attribute name="@return">
						<description>the host name for this IP address, or if the operation
    is not allowed by the security check, the textual
    representation of the IP address.</description>
					</attribute>
					<attribute name="@param">
						<description>check make security check if true</description>
					</attribute>
					<attribute name="@see">
						<description>SecurityManager#checkConnect</description>
					</attribute>
				</comment>
				<params>
					<param name="check" comment="make security check if true" fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method visibility="public" name="getCanonicalHostName" returncomment="the fully qualified domain name for this IP address,
    or if the operation is not allowed by the security check,
    the textual representation of the IP address." fulltype="java.lang.String" type="String">
				<comment>
					<description>Gets the fully qualified domain name for this IP address.
 Best effort method, meaning we may not be able to return
 the FQDN depending on the underlying system configuration.

 &lt;p&gt;If there is a security manager, this method first
 calls its &lt;code&gt;checkConnect&lt;/code&gt; method
 with the hostname and &lt;code&gt;-1&lt;/code&gt;
 as its arguments to see if the calling code is allowed to know
 the hostname for this IP address, i.e., to connect to the host.
 If the operation is not allowed, it will return
 the textual representation of the IP address.</description>
					<attribute name="@return">
						<description>the fully qualified domain name for this IP address,
    or if the operation is not allowed by the security check,
    the textual representation of the IP address.</description>
					</attribute>
					<attribute name="@see">
						<description>SecurityManager#checkConnect</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</method>
			<method static="true" visibility="private" name="getHostFromNameService" returncomment="the host name for this IP address, or if the operation
    is not allowed by the security check, the textual
    representation of the IP address." fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the hostname for this address.

 &lt;p&gt;If there is a security manager, this method first
 calls its &lt;code&gt;checkConnect&lt;/code&gt; method
 with the hostname and &lt;code&gt;-1&lt;/code&gt;
 as its arguments to see if the calling code is allowed to know
 the hostname for this IP address, i.e., to connect to the host.
 If the operation is not allowed, it will return
 the textual representation of the IP address.</description>
					<attribute name="@return">
						<description>the host name for this IP address, or if the operation
    is not allowed by the security check, the textual
    representation of the IP address.</description>
					</attribute>
					<attribute name="@param">
						<description>check make security check if true</description>
					</attribute>
					<attribute name="@see">
						<description>SecurityManager#checkConnect</description>
					</attribute>
				</comment>
				<params>
					<param name="addr" fulltype="java.net.InetAddress" type="InetAddress" />
					<param name="check" comment="make security check if true" fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method visibility="public" name="getAddress" returncomment="the raw IP address of this object." fulltype="byte[]" type="byte">
				<comment>
					<description>Returns the raw IP address of this &lt;code&gt;InetAddress&lt;/code&gt;
 object. The result is in network byte order: the highest order
 byte of the address is in &lt;code&gt;getAddress()[0]&lt;/code&gt;.</description>
					<attribute name="@return">
						<description>the raw IP address of this object.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getHostAddress" returncomment="the raw IP address in a string format." fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the IP address string in textual presentation.</description>
					<attribute name="@return">
						<description>the raw IP address in a string format.</description>
					</attribute>
					<attribute name="@since">
						<description>JDK1.0.2</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="hashCode" returncomment="a hash code value for this IP address." fulltype="int" type="int">
				<comment>
					<description>Returns a hashcode for this IP address.</description>
					<attribute name="@return">
						<description>a hash code value for this IP address.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="equals" returncomment="&lt;code&gt;true&lt;/code&gt; if the objects are the same;
          &lt;code&gt;false&lt;/code&gt; otherwise." fulltype="boolean" type="boolean">
				<comment>
					<description>Compares this object against the specified object.
 The result is &lt;code&gt;true&lt;/code&gt; if and only if the argument is
 not &lt;code&gt;null&lt;/code&gt; and it represents the same IP address as
 this object.
 &lt;p&gt;
 Two instances of &lt;code&gt;InetAddress&lt;/code&gt; represent the same IP
 address if the length of the byte arrays returned by
 &lt;code&gt;getAddress&lt;/code&gt; is the same for both, and each of the
 array components is the same for the byte arrays.</description>
					<attribute name="@param">
						<description>obj   the object to compare against.</description>
					</attribute>
					<attribute name="@return">
						<description>&lt;code&gt;true&lt;/code&gt; if the objects are the same;
          &lt;code&gt;false&lt;/code&gt; otherwise.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.InetAddress#getAddress()</description>
					</attribute>
				</comment>
				<params>
					<param name="obj" comment="the object to compare against." fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method visibility="public" name="toString" returncomment="a string representation of this IP address." fulltype="java.lang.String" type="String">
				<comment>
					<description>Converts this IP address to a &lt;code&gt;String&lt;/code&gt;. The
 string returned is of the form: hostname / literal IP
 address.

 If the host name is unresolved, no reverse name service lookup
 is performed. The hostname part will be represented by an empty string.</description>
					<attribute name="@return">
						<description>a string representation of this IP address.</description>
					</attribute>
				</comment>
			</method>
			<method static="true" visibility="private" name="cacheInitIfNeeded" fulltype="void" type="void" />
			<method static="true" visibility="private" name="cacheAddress" fulltype="void" type="void">
				<params>
					<param name="hostname" fulltype="java.lang.String" type="String" />
					<param name="address" fulltype="java.lang.Object" type="Object" />
					<param name="success" fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method static="true" visibility="private" name="getCachedAddress" fulltype="java.lang.Object" type="Object">
				<params>
					<param name="hostname" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method static="true" visibility="private" name="createNSProvider" fulltype="sun.net.spi.nameservice.NameService" type="NameService">
				<params>
					<param name="provider" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method static="true" visibility="public" name="getByAddress" returncomment="an InetAddress object created from the raw IP address." fulltype="java.net.InetAddress" type="InetAddress">
				<comment>
					<description>Create an InetAddress based on the provided host name and IP address
 No name service is checked for the validity of the address.

 &lt;p&gt; The host name can either be a machine name, such as
 &quot;&lt;code&gt;java.sun.com&lt;/code&gt;&quot;, or a textual representation of its IP
 address.
 &lt;p&gt; No validity checking is done on the host name either.

 &lt;p&gt; If addr specifies an IPv4 address an instance of Inet4Address
 will be returned; otherwise, an instance of Inet6Address
 will be returned.

 &lt;p&gt; IPv4 address byte array must be 4 bytes long and IPv6 byte array
 must be 16 bytes long</description>
					<attribute name="@param">
						<description>host the specified host</description>
					</attribute>
					<attribute name="@param">
						<description>addr the raw IP address in network byte order</description>
					</attribute>
					<attribute name="@return">
						<description>an InetAddress object created from the raw IP address.</description>
					</attribute>
					<attribute name="@exception">
						<description>UnknownHostException  if IP address is of illegal length</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
				<params>
					<param name="host" comment="the specified host" fulltype="java.lang.String" type="String" />
					<param name="addr" comment="the raw IP address in network byte order" fulltype="byte[]" type="byte" />
				</params>
				<exceptions>
					<exception comment="if IP address is of illegal length" fulltype="java.net.UnknownHostException" type="UnknownHostException" />
				</exceptions>
			</method>
			<method static="true" visibility="public" name="getByName" returncomment="an IP address for the given host name." fulltype="java.net.InetAddress" type="InetAddress">
				<comment>
					<description>Determines the IP address of a host, given the host&apos;s name.

 &lt;p&gt; The host name can either be a machine name, such as
 &quot;&lt;code&gt;java.sun.com&lt;/code&gt;&quot;, or a textual representation of its
 IP address. If a literal IP address is supplied, only the
 validity of the address format is checked.

 &lt;p&gt; For &lt;code&gt;host&lt;/code&gt; specified in literal IPv6 address,
 either the form defined in RFC 2732 or the literal IPv6 address
 format defined in RFC 2373 is accepted. IPv6 scoped addresses are also
 supported. See &lt;a href=&quot;Inet6Address.html#scoped&quot;&gt;here&lt;/a&gt; for a description of IPv6
 scoped addresses.

 &lt;p&gt; If the host is &lt;tt&gt;null&lt;/tt&gt; then an &lt;tt&gt;InetAddress&lt;/tt&gt;
 representing an address of the loopback interface is returned.
 See &lt;a href=&quot;http://www.ietf.org/rfc/rfc3330.txt&quot;&gt;RFC&amp;nbsp;3330&lt;/a&gt;
 section&amp;nbsp;2 and &lt;a href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;RFC&amp;nbsp;2373&lt;/a&gt;
 section&amp;nbsp;2.5.3. &lt;/p&gt;</description>
					<attribute name="@param">
						<description>host   the specified host, or &lt;code&gt;null&lt;/code&gt;.</description>
					</attribute>
					<attribute name="@return">
						<description>an IP address for the given host name.</description>
					</attribute>
					<attribute name="@exception">
						<description>UnknownHostException  if no IP address for the
               &lt;code&gt;host&lt;/code&gt; could be found, or if a scope_id was specified
               for a global IPv6 address.</description>
					</attribute>
					<attribute name="@exception">
						<description>SecurityException if a security manager exists
             and its checkConnect method doesn&apos;t allow the operation</description>
					</attribute>
				</comment>
				<params>
					<param name="host" comment="the specified host, or &lt;code&gt;null&lt;/code&gt;." fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception comment="if no IP address for the
               &lt;code&gt;host&lt;/code&gt; could be found, or if a scope_id was specified
               for a global IPv6 address." fulltype="java.net.UnknownHostException" type="UnknownHostException" />
				</exceptions>
			</method>
			<method static="true" visibility="private" name="getByName" fulltype="java.net.InetAddress" type="InetAddress">
				<params>
					<param name="host" fulltype="java.lang.String" type="String" />
					<param name="reqAddr" fulltype="java.net.InetAddress" type="InetAddress" />
				</params>
				<exceptions>
					<exception fulltype="java.net.UnknownHostException" type="UnknownHostException" />
				</exceptions>
			</method>
			<method static="true" visibility="public" name="getAllByName" returncomment="an array of all the IP addresses for a given host name." fulltype="java.net.InetAddress[]" type="InetAddress">
				<comment>
					<description>Given the name of a host, returns an array of its IP addresses,
 based on the configured name service on the system.

 &lt;p&gt; The host name can either be a machine name, such as
 &quot;&lt;code&gt;java.sun.com&lt;/code&gt;&quot;, or a textual representation of its IP
 address. If a literal IP address is supplied, only the
 validity of the address format is checked.

 &lt;p&gt; For &lt;code&gt;host&lt;/code&gt; specified in &lt;i&gt;literal IPv6 address&lt;/i&gt;,
 either the form defined in RFC 2732 or the literal IPv6 address
 format defined in RFC 2373 is accepted. A literal IPv6 address may
 also be qualified by appending a scoped zone identifier or scope_id.
 The syntax and usage of scope_ids is described
 &lt;a href=&quot;Inet6Address.html#scoped&quot;&gt;here&lt;/a&gt;.
 &lt;p&gt; If the host is &lt;tt&gt;null&lt;/tt&gt; then an &lt;tt&gt;InetAddress&lt;/tt&gt;
 representing an address of the loopback interface is returned.
 See &lt;a href=&quot;http://www.ietf.org/rfc/rfc3330.txt&quot;&gt;RFC&amp;nbsp;3330&lt;/a&gt;
 section&amp;nbsp;2 and &lt;a href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;RFC&amp;nbsp;2373&lt;/a&gt;
 section&amp;nbsp;2.5.3. &lt;/p&gt;

 &lt;p&gt; If there is a security manager and &lt;code&gt;host&lt;/code&gt; is not
 null and &lt;code&gt;host.length() &lt;/code&gt; is not equal to zero, the
 security manager&apos;s
 &lt;code&gt;checkConnect&lt;/code&gt; method is called
 with the hostname and &lt;code&gt;-1&lt;/code&gt;
 as its arguments to see if the operation is allowed.</description>
					<attribute name="@param">
						<description>host   the name of the host, or &lt;code&gt;null&lt;/code&gt;.</description>
					</attribute>
					<attribute name="@return">
						<description>an array of all the IP addresses for a given host name.</description>
					</attribute>
					<attribute name="@exception">
						<description>UnknownHostException  if no IP address for the
               &lt;code&gt;host&lt;/code&gt; could be found, or if a scope_id was specified
               for a global IPv6 address.</description>
					</attribute>
					<attribute name="@exception">
						<description>SecurityException  if a security manager exists and its
               &lt;code&gt;checkConnect&lt;/code&gt; method doesn&apos;t allow the operation.</description>
					</attribute>
					<attribute name="@see">
						<description>SecurityManager#checkConnect</description>
					</attribute>
				</comment>
				<params>
					<param name="host" comment="the name of the host, or &lt;code&gt;null&lt;/code&gt;." fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception comment="if no IP address for the
               &lt;code&gt;host&lt;/code&gt; could be found, or if a scope_id was specified
               for a global IPv6 address." fulltype="java.net.UnknownHostException" type="UnknownHostException" />
				</exceptions>
			</method>
			<method static="true" visibility="private" name="getAllByName" fulltype="java.net.InetAddress[]" type="InetAddress">
				<params>
					<param name="host" fulltype="java.lang.String" type="String" />
					<param name="reqAddr" fulltype="java.net.InetAddress" type="InetAddress" />
				</params>
				<exceptions>
					<exception fulltype="java.net.UnknownHostException" type="UnknownHostException" />
				</exceptions>
			</method>
			<method static="true" visibility="private" name="checkNumericZone" fulltype="int" type="int">
				<comment>
					<description>check if the literal address string has %nn appended
 returns -1 if not, or the numeric value otherwise.

 %nn may also be a string that represents the displayName of
 a currently available NetworkInterface.</description>
				</comment>
				<params>
					<param name="s" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception fulltype="java.net.UnknownHostException" type="UnknownHostException" />
				</exceptions>
			</method>
			<method static="true" visibility="private" name="getAllByName0" fulltype="java.net.InetAddress[]" type="InetAddress">
				<params>
					<param name="host" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception fulltype="java.net.UnknownHostException" type="UnknownHostException" />
				</exceptions>
			</method>
			<method static="true" visibility="package-private" name="getAllByName0" fulltype="java.net.InetAddress[]" type="InetAddress">
				<comment>
					<description>package private so SocketPermission can call it</description>
				</comment>
				<params>
					<param name="host" fulltype="java.lang.String" type="String" />
					<param name="check" fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception fulltype="java.net.UnknownHostException" type="UnknownHostException" />
				</exceptions>
			</method>
			<method static="true" visibility="private" name="getAllByName0" fulltype="java.net.InetAddress[]" type="InetAddress">
				<params>
					<param name="host" fulltype="java.lang.String" type="String" />
					<param name="reqAddr" fulltype="java.net.InetAddress" type="InetAddress" />
					<param name="check" fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception fulltype="java.net.UnknownHostException" type="UnknownHostException" />
				</exceptions>
			</method>
			<method static="true" visibility="private" name="getAddressFromNameService" fulltype="java.lang.Object" type="Object">
				<params>
					<param name="host" fulltype="java.lang.String" type="String" />
					<param name="reqAddr" fulltype="java.net.InetAddress" type="InetAddress" />
				</params>
				<exceptions>
					<exception fulltype="java.net.UnknownHostException" type="UnknownHostException" />
				</exceptions>
			</method>
			<method static="true" visibility="private" name="checkLookupTable" fulltype="java.lang.Object" type="Object">
				<params>
					<param name="host" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method static="true" visibility="private" name="updateLookupTable" fulltype="void" type="void">
				<params>
					<param name="host" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method static="true" visibility="public" name="getByAddress" returncomment="an InetAddress object created from the raw IP address." fulltype="java.net.InetAddress" type="InetAddress">
				<comment>
					<description>Returns an &lt;code&gt;InetAddress&lt;/code&gt; object given the raw IP address .
 The argument is in network byte order: the highest order
 byte of the address is in &lt;code&gt;getAddress()[0]&lt;/code&gt;.

 &lt;p&gt; This method doesn&apos;t block, i.e. no reverse name service lookup
 is performed.

 &lt;p&gt; IPv4 address byte array must be 4 bytes long and IPv6 byte array
 must be 16 bytes long</description>
					<attribute name="@param">
						<description>addr the raw IP address in network byte order</description>
					</attribute>
					<attribute name="@return">
						<description>an InetAddress object created from the raw IP address.</description>
					</attribute>
					<attribute name="@exception">
						<description>UnknownHostException  if IP address is of illegal length</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
				<params>
					<param name="addr" comment="the raw IP address in network byte order" fulltype="byte[]" type="byte" />
				</params>
				<exceptions>
					<exception comment="if IP address is of illegal length" fulltype="java.net.UnknownHostException" type="UnknownHostException" />
				</exceptions>
			</method>
			<method static="true" visibility="public" name="getLocalHost" returncomment="the address of the local host." fulltype="java.net.InetAddress" type="InetAddress">
				<comment>
					<description>Returns the address of the local host. This is achieved by retrieving
 the name of the host from the system, then resolving that name into
 an &lt;code&gt;InetAddress&lt;/code&gt;.

 &lt;P&gt;Note: The resolved address may be cached for a short period of time.
 &lt;/P&gt;

 &lt;p&gt;If there is a security manager, its
 &lt;code&gt;checkConnect&lt;/code&gt; method is called
 with the local host name and &lt;code&gt;-1&lt;/code&gt;
 as its arguments to see if the operation is allowed.
 If the operation is not allowed, an InetAddress representing
 the loopback address is returned.</description>
					<attribute name="@return">
						<description>the address of the local host.</description>
					</attribute>
					<attribute name="@exception">
						<description>UnknownHostException  if the local host name could not
             be resolved into an address.</description>
					</attribute>
					<attribute name="@see">
						<description>SecurityManager#checkConnect</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.InetAddress#getByName(java.lang.String)</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if the local host name could not
             be resolved into an address." fulltype="java.net.UnknownHostException" type="UnknownHostException" />
				</exceptions>
			</method>
			<method static="true" visibility="private" name="init" fulltype="void" type="void">
				<comment>
					<description>Perform class load-time initializations.</description>
				</comment>
			</method>
			<method static="true" visibility="package-private" name="anyLocalAddress" fulltype="java.net.InetAddress" type="InetAddress" />
			<method static="true" visibility="package-private" name="loadImpl" fulltype="java.lang.Object" type="Object">
				<params>
					<param name="implName" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="private" name="readObjectNoData" fulltype="void" type="void">
				<params>
					<param name="s" fulltype="java.io.ObjectInputStream" type="ObjectInputStream" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
					<exception fulltype="java.lang.ClassNotFoundException" type="ClassNotFoundException" />
				</exceptions>
			</method>
			<method visibility="private" name="readObject" fulltype="void" type="void">
				<params>
					<param name="s" fulltype="java.io.ObjectInputStream" type="ObjectInputStream" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
					<exception fulltype="java.lang.ClassNotFoundException" type="ClassNotFoundException" />
				</exceptions>
			</method>
		</methods>
		<jelclass final="true" superclass="Object" visibility="package-private" package="java.net" superclassfulltype="java.lang.Object" fulltype="java.net.InetAddress.CacheEntry" type="InetAddress.CacheEntry">
			<comment>
				<description>Represents a cache entry</description>
			</comment>
			<fields>
				<field visibility="package-private" name="address" fulltype="java.lang.Object" type="Object" />
				<field visibility="package-private" name="expiration" fulltype="long" type="long" />
			</fields>
			<methods>
				<constructor visibility="package-private" name="InetAddress.CacheEntry">
					<params>
						<param name="address" fulltype="java.lang.Object" type="Object" />
						<param name="expiration" fulltype="long" type="long" />
					</params>
				</constructor>
			</methods>
		</jelclass>
		<jelclass final="true" superclass="Object" visibility="package-private" package="java.net" superclassfulltype="java.lang.Object" fulltype="java.net.InetAddress.Cache" type="InetAddress.Cache">
			<comment>
				<description>A cache that manages entries based on a policy specified
 at creation time.</description>
			</comment>
			<fields>
				<field visibility="private" name="cache" fulltype="java.util.LinkedHashMap" type="LinkedHashMap" />
				<field visibility="private" name="type" fulltype="java.net.InetAddress.Cache.Type" type="InetAddress.Cache.Type" />
			</fields>
			<methods>
				<constructor visibility="public" name="InetAddress.Cache">
					<comment>
						<description>Create cache</description>
					</comment>
					<params>
						<param name="type" fulltype="java.net.InetAddress.Cache.Type" type="InetAddress.Cache.Type" />
					</params>
				</constructor>
				<method visibility="private" name="getPolicy" fulltype="int" type="int" />
				<method visibility="public" name="put" fulltype="java.net.InetAddress.Cache" type="InetAddress.Cache">
					<comment>
						<description>Add an entry to the cache. If there&apos;s already an
 entry then for this host then the entry will be
 replaced.</description>
					</comment>
					<params>
						<param name="host" fulltype="java.lang.String" type="String" />
						<param name="address" fulltype="java.lang.Object" type="Object" />
					</params>
				</method>
				<method visibility="public" name="get" fulltype="java.net.InetAddress.CacheEntry" type="InetAddress.CacheEntry">
					<comment>
						<description>Query the cache for the specific host. If found then
 return its CacheEntry, or null if not found.</description>
					</comment>
					<params>
						<param name="host" fulltype="java.lang.String" type="String" />
					</params>
				</method>
			</methods>
			<jelclass final="true" superclass="Enum" visibility="package-private" package="java.net" serializable="true" superclassfulltype="java.lang.Enum" fulltype="java.net.InetAddress.Cache.Type" type="InetAddress.Cache.Type">
				<fields>
					<field final="true" static="true" visibility="public" name="Positive" fulltype="java.net.InetAddress.Cache.Type" type="InetAddress.Cache.Type" />
					<field final="true" static="true" visibility="public" name="Negative" fulltype="java.net.InetAddress.Cache.Type" type="InetAddress.Cache.Type" />
				</fields>
				<methods>
					<constructor visibility="private" name="InetAddress.Cache.Type" />
					<method static="true" visibility="public" name="values" fulltype="java.net.InetAddress.Cache.Type[]" type="InetAddress.Cache.Type" />
					<method static="true" visibility="public" name="valueOf" fulltype="java.net.InetAddress.Cache.Type" type="InetAddress.Cache.Type">
						<params>
							<param name="name" fulltype="java.lang.String" type="String" />
						</params>
					</method>
				</methods>
			</jelclass>
		</jelclass>
	</jelclass>
	<jelclass final="true" superclass="Object" visibility="package-private" package="java.net" superclassfulltype="java.lang.Object" fulltype="java.net.InetAddress.CacheEntry" type="InetAddress.CacheEntry">
		<comment>
			<description>Represents a cache entry</description>
		</comment>
		<fields>
			<field visibility="package-private" name="address" fulltype="java.lang.Object" type="Object" />
			<field visibility="package-private" name="expiration" fulltype="long" type="long" />
		</fields>
		<methods>
			<constructor visibility="package-private" name="InetAddress.CacheEntry">
				<params>
					<param name="address" fulltype="java.lang.Object" type="Object" />
					<param name="expiration" fulltype="long" type="long" />
				</params>
			</constructor>
		</methods>
	</jelclass>
	<jelclass final="true" superclass="Object" visibility="package-private" package="java.net" superclassfulltype="java.lang.Object" fulltype="java.net.InetAddress.Cache" type="InetAddress.Cache">
		<comment>
			<description>A cache that manages entries based on a policy specified
 at creation time.</description>
		</comment>
		<fields>
			<field visibility="private" name="cache" fulltype="java.util.LinkedHashMap" type="LinkedHashMap" />
			<field visibility="private" name="type" fulltype="java.net.InetAddress.Cache.Type" type="InetAddress.Cache.Type" />
		</fields>
		<methods>
			<constructor visibility="public" name="InetAddress.Cache">
				<comment>
					<description>Create cache</description>
				</comment>
				<params>
					<param name="type" fulltype="java.net.InetAddress.Cache.Type" type="InetAddress.Cache.Type" />
				</params>
			</constructor>
			<method visibility="private" name="getPolicy" fulltype="int" type="int" />
			<method visibility="public" name="put" fulltype="java.net.InetAddress.Cache" type="InetAddress.Cache">
				<comment>
					<description>Add an entry to the cache. If there&apos;s already an
 entry then for this host then the entry will be
 replaced.</description>
				</comment>
				<params>
					<param name="host" fulltype="java.lang.String" type="String" />
					<param name="address" fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method visibility="public" name="get" fulltype="java.net.InetAddress.CacheEntry" type="InetAddress.CacheEntry">
				<comment>
					<description>Query the cache for the specific host. If found then
 return its CacheEntry, or null if not found.</description>
				</comment>
				<params>
					<param name="host" fulltype="java.lang.String" type="String" />
				</params>
			</method>
		</methods>
		<jelclass final="true" superclass="Enum" visibility="package-private" package="java.net" serializable="true" superclassfulltype="java.lang.Enum" fulltype="java.net.InetAddress.Cache.Type" type="InetAddress.Cache.Type">
			<fields>
				<field final="true" static="true" visibility="public" name="Positive" fulltype="java.net.InetAddress.Cache.Type" type="InetAddress.Cache.Type" />
				<field final="true" static="true" visibility="public" name="Negative" fulltype="java.net.InetAddress.Cache.Type" type="InetAddress.Cache.Type" />
			</fields>
			<methods>
				<constructor visibility="private" name="InetAddress.Cache.Type" />
				<method static="true" visibility="public" name="values" fulltype="java.net.InetAddress.Cache.Type[]" type="InetAddress.Cache.Type" />
				<method static="true" visibility="public" name="valueOf" fulltype="java.net.InetAddress.Cache.Type" type="InetAddress.Cache.Type">
					<params>
						<param name="name" fulltype="java.lang.String" type="String" />
					</params>
				</method>
			</methods>
		</jelclass>
	</jelclass>
	<jelclass final="true" superclass="Enum" visibility="package-private" package="java.net" serializable="true" superclassfulltype="java.lang.Enum" fulltype="java.net.InetAddress.Cache.Type" type="InetAddress.Cache.Type">
		<fields>
			<field final="true" static="true" visibility="public" name="Positive" fulltype="java.net.InetAddress.Cache.Type" type="InetAddress.Cache.Type" />
			<field final="true" static="true" visibility="public" name="Negative" fulltype="java.net.InetAddress.Cache.Type" type="InetAddress.Cache.Type" />
		</fields>
		<methods>
			<constructor visibility="private" name="InetAddress.Cache.Type" />
			<method static="true" visibility="public" name="values" fulltype="java.net.InetAddress.Cache.Type[]" type="InetAddress.Cache.Type" />
			<method static="true" visibility="public" name="valueOf" fulltype="java.net.InetAddress.Cache.Type" type="InetAddress.Cache.Type">
				<params>
					<param name="name" fulltype="java.lang.String" type="String" />
				</params>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="Object" visibility="package-private" package="java.net" superclassfulltype="java.lang.Object" fulltype="java.net.InetAddressImplFactory" type="InetAddressImplFactory">
		<methods>
			<constructor visibility="package-private" name="InetAddressImplFactory" />
			<method static="true" visibility="package-private" name="create" fulltype="java.net.InetAddressImpl" type="InetAddressImpl" />
			<method static="true" visibility="package-private" name="isIPv6Supported" fulltype="boolean" type="boolean" />
		</methods>
	</jelclass>
	<jelclass final="true" superclass="Permission" visibility="public" package="java.net" serializable="true" superclassfulltype="java.security.Permission" fulltype="java.net.SocketPermission" type="SocketPermission">
		<implements>
			<interface fulltype="java.io.Serializable" type="Serializable" />
		</implements>
		<comment>
			<description>This class represents access to a network via sockets.
 A SocketPermission consists of a
 host specification and a set of &quot;actions&quot; specifying ways to
 connect to that host. The host is specified as
 &lt;pre&gt;
    host = (hostname | IPv4address | iPv6reference) [:portrange]
    portrange = portnumber | -portnumber | portnumber-[portnumber]
 &lt;/pre&gt;
 The host is expressed as a DNS name, as a numerical IP address,
 or as &quot;localhost&quot; (for the local machine).
 The wildcard &quot;*&quot; may be included once in a DNS name host
 specification. If it is included, it must be in the leftmost
 position, as in &quot;*.sun.com&quot;.
 &lt;p&gt;
 The format of the IPv6reference should follow that specified in &lt;a
 href=&quot;http://www.ietf.org/rfc/rfc2732.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2732: Format
 for Literal IPv6 Addresses in URLs&lt;/i&gt;&lt;/a&gt;:
 &lt;pre&gt;
    ipv6reference = &quot;[&quot; IPv6address &quot;]&quot;
&lt;/pre&gt;
 For example, you can construct a SocketPermission instance
 as the following:
 &lt;pre&gt;
    String hostAddress = inetaddress.getHostAddress();
    if (inetaddress instanceof Inet6Address) {
        sp = new SocketPermission(&quot;[&quot; + hostAddress + &quot;]:&quot; + port, action);
    } else {
        sp = new SocketPermission(hostAddress + &quot;:&quot; + port, action);
    }
 &lt;/pre&gt;
 or
 &lt;pre&gt;
    String host = url.getHost();
    sp = new SocketPermission(host + &quot;:&quot; + port, action);
 &lt;/pre&gt;
 &lt;p&gt;
 The &lt;A HREF=&quot;Inet6Address.html#lform&quot;&gt;full uncompressed form&lt;/A&gt; of
 an IPv6 literal address is also valid.
 &lt;p&gt;
 The port or portrange is optional. A port specification of the
 form &quot;N-&quot;, where &lt;i&gt;N&lt;/i&gt; is a port number, signifies all ports
 numbered &lt;i&gt;N&lt;/i&gt; and above, while a specification of the
 form &quot;-N&quot; indicates all ports numbered &lt;i&gt;N&lt;/i&gt; and below.
 &lt;p&gt;
 The possible ways to connect to the host are
 &lt;pre&gt;
 accept
 connect
 listen
 resolve
 &lt;/pre&gt;
 The &quot;listen&quot; action is only meaningful when used with &quot;localhost&quot;.
 The &quot;resolve&quot; action is implied when any of the other actions are present.
 The action &quot;resolve&quot; refers to host/ip name service lookups.

 &lt;p&gt;As an example of the creation and meaning of SocketPermissions,
 note that if the following permission:

 &lt;pre&gt;
   p1 = new SocketPermission(&quot;puffin.eng.sun.com:7777&quot;, &quot;connect,accept&quot;);
 &lt;/pre&gt;

 is granted to some code, it allows that code to connect to port 7777 on
 &lt;code&gt;puffin.eng.sun.com&lt;/code&gt;, and to accept connections on that port.

 &lt;p&gt;Similarly, if the following permission:

 &lt;pre&gt;
   p1 = new SocketPermission(&quot;puffin.eng.sun.com:7777&quot;, &quot;connect,accept&quot;);
   p2 = new SocketPermission(&quot;localhost:1024-&quot;, &quot;accept,connect,listen&quot;);
 &lt;/pre&gt;

 is granted to some code, it allows that code to
 accept connections on, connect to, or listen on any port between
 1024 and 65535 on the local host.

 &lt;p&gt;Note: Granting code permission to accept or make connections to remote
 hosts may be dangerous because malevolent code can then more easily
 transfer and share confidential data among parties who may not
 otherwise have access to the data.</description>
			<attribute name="@see">
				<description>java.security.Permissions</description>
			</attribute>
			<attribute name="@see">
				<description>SocketPermission</description>
			</attribute>
			<attribute name="@author">
				<description>Marianne Mueller</description>
			</attribute>
			<attribute name="@author">
				<description>Roland Schemers</description>
			</attribute>
			<attribute name="@serial">
				<description>exclude</description>
			</attribute>
		</comment>
		<fields>
			<field final="true" static="true" const="-7204263841984476862" visibility="private" name="serialVersionUID" constexpr="-7204263841984476862L" fulltype="long" type="long" />
			<field final="true" static="true" const="1" visibility="private" name="CONNECT" constexpr="1" fulltype="int" type="int">
				<comment>
					<description>Connect to host:port</description>
				</comment>
			</field>
			<field final="true" static="true" const="2" visibility="private" name="LISTEN" constexpr="2" fulltype="int" type="int">
				<comment>
					<description>Listen on host:port</description>
				</comment>
			</field>
			<field final="true" static="true" const="4" visibility="private" name="ACCEPT" constexpr="4" fulltype="int" type="int">
				<comment>
					<description>Accept a connection from host:port</description>
				</comment>
			</field>
			<field final="true" static="true" const="8" visibility="private" name="RESOLVE" constexpr="8" fulltype="int" type="int">
				<comment>
					<description>Resolve DNS queries</description>
				</comment>
			</field>
			<field final="true" static="true" const="0" visibility="private" name="NONE" constexpr="0" fulltype="int" type="int">
				<comment>
					<description>No actions</description>
				</comment>
			</field>
			<field final="true" static="true" const="15" visibility="private" name="ALL" constexpr="15" fulltype="int" type="int">
				<comment>
					<description>All actions</description>
				</comment>
			</field>
			<field final="true" static="true" const="0" visibility="private" name="PORT_MIN" constexpr="0" fulltype="int" type="int" />
			<field final="true" static="true" const="65535" visibility="private" name="PORT_MAX" constexpr="65535" fulltype="int" type="int" />
			<field final="true" static="true" const="1023" visibility="private" name="PRIV_PORT_MAX" constexpr="1023" fulltype="int" type="int" />
			<field visibility="private" transient="true" name="mask" fulltype="int" type="int" />
			<field visibility="private" name="actions" fulltype="java.lang.String" type="String">
				<comment>
					<description>the actions string.</description>
					<attribute name="@serial" />
				</comment>
			</field>
			<field visibility="private" transient="true" name="hostname" fulltype="java.lang.String" type="String" />
			<field visibility="private" transient="true" name="cname" fulltype="java.lang.String" type="String" />
			<field visibility="private" transient="true" name="addresses" fulltype="java.net.InetAddress[]" type="InetAddress" />
			<field visibility="private" transient="true" name="wildcard" fulltype="boolean" type="boolean" />
			<field visibility="private" transient="true" name="init_with_ip" fulltype="boolean" type="boolean" />
			<field visibility="private" transient="true" name="invalid" fulltype="boolean" type="boolean" />
			<field visibility="private" transient="true" name="portrange" fulltype="int[]" type="int" />
			<field visibility="private" transient="true" name="defaultDeny" fulltype="boolean" type="boolean" />
			<field visibility="private" transient="true" name="untrusted" fulltype="boolean" type="boolean" />
			<field static="true" visibility="private" name="trustProxy" fulltype="boolean" type="boolean" />
			<field static="true" visibility="private" name="trustNameService" fulltype="boolean" type="boolean" />
			<field static="true" visibility="private" name="debug" fulltype="sun.security.util.Debug" type="Debug" />
			<field static="true" visibility="private" name="debugInit" fulltype="boolean" type="boolean" />
		</fields>
		<methods>
			<constructor visibility="public" name="SocketPermission">
				<comment>
					<description>Creates a new SocketPermission object with the specified actions.
 The host is expressed as a DNS name, or as a numerical IP address.
 Optionally, a port or a portrange may be supplied (separated
 from the DNS name or IP address by a colon).
 &lt;p&gt;
 To specify the local machine, use &quot;localhost&quot; as the &lt;i&gt;host&lt;/i&gt;.
 Also note: An empty &lt;i&gt;host&lt;/i&gt; String (&quot;&quot;) is equivalent to &quot;localhost&quot;.
 &lt;p&gt;
 The &lt;i&gt;actions&lt;/i&gt; parameter contains a comma-separated list of the
 actions granted for the specified host (and port(s)). Possible actions are
 &quot;connect&quot;, &quot;listen&quot;, &quot;accept&quot;, &quot;resolve&quot;, or
 any combination of those. &quot;resolve&quot; is automatically added
 when any of the other three are specified.
 &lt;p&gt;
 Examples of SocketPermission instantiation are the following:
 &lt;pre&gt;
    nr = new SocketPermission(&quot;www.catalog.com&quot;, &quot;connect&quot;);
    nr = new SocketPermission(&quot;www.sun.com:80&quot;, &quot;connect&quot;);
    nr = new SocketPermission(&quot;*.sun.com&quot;, &quot;connect&quot;);
    nr = new SocketPermission(&quot;*.edu&quot;, &quot;resolve&quot;);
    nr = new SocketPermission(&quot;204.160.241.0&quot;, &quot;connect&quot;);
    nr = new SocketPermission(&quot;localhost:1024-65535&quot;, &quot;listen&quot;);
    nr = new SocketPermission(&quot;204.160.241.0:1024-65535&quot;, &quot;connect&quot;);
 &lt;/pre&gt;</description>
					<attribute name="@param">
						<description>host the hostname or IPaddress of the computer, optionally
 including a colon followed by a port or port range.</description>
					</attribute>
					<attribute name="@param">
						<description>action the action string.</description>
					</attribute>
				</comment>
				<params>
					<param name="host" comment="the hostname or IPaddress of the computer, optionally
 including a colon followed by a port or port range." fulltype="java.lang.String" type="String" />
					<param name="action" comment="the action string." fulltype="java.lang.String" type="String" />
				</params>
			</constructor>
			<constructor visibility="package-private" name="SocketPermission">
				<params>
					<param name="host" fulltype="java.lang.String" type="String" />
					<param name="mask" fulltype="int" type="int" />
				</params>
			</constructor>
			<method static="true" synchronized="true" visibility="private" name="getDebug" fulltype="sun.security.util.Debug" type="Debug" />
			<method visibility="private" name="setDeny" fulltype="void" type="void" />
			<method static="true" visibility="private" name="getHost" fulltype="java.lang.String" type="String">
				<params>
					<param name="host" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="private" name="parsePort" fulltype="int[]" type="int">
				<params>
					<param name="port" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception fulltype="java.lang.Exception" type="Exception" />
				</exceptions>
			</method>
			<method visibility="private" name="init" fulltype="void" type="void">
				<comment>
					<description>Initialize the SocketPermission object. We don&apos;t do any DNS lookups
 as this point, instead we hold off until the implies method is
 called.</description>
				</comment>
				<params>
					<param name="host" fulltype="java.lang.String" type="String" />
					<param name="mask" fulltype="int" type="int" />
				</params>
			</method>
			<method static="true" visibility="private" name="getMask" returncomment="the action mask" fulltype="int" type="int">
				<comment>
					<description>Convert an action string to an integer actions mask.</description>
					<attribute name="@param">
						<description>action the action string</description>
					</attribute>
					<attribute name="@return">
						<description>the action mask</description>
					</attribute>
				</comment>
				<params>
					<param name="action" comment="the action string" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="package-private" name="getCanonName" fulltype="void" type="void">
				<comment>
					<description>attempt to get the fully qualified domain name</description>
				</comment>
				<exceptions>
					<exception fulltype="java.net.UnknownHostException" type="UnknownHostException" />
				</exceptions>
			</method>
			<method visibility="private" name="match" fulltype="boolean" type="boolean">
				<params>
					<param name="cname" fulltype="java.lang.String" type="String" />
					<param name="hname" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="private" name="fragment" fulltype="java.lang.String" type="String">
				<params>
					<param name="cname" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="private" name="authorized" fulltype="boolean" type="boolean">
				<params>
					<param name="cname" fulltype="java.lang.String" type="String" />
					<param name="addr" fulltype="byte[]" type="byte" />
				</params>
			</method>
			<method visibility="private" name="authorizedIPv4" fulltype="boolean" type="boolean">
				<params>
					<param name="cname" fulltype="java.lang.String" type="String" />
					<param name="addr" fulltype="byte[]" type="byte" />
				</params>
			</method>
			<method visibility="private" name="authorizedIPv6" fulltype="boolean" type="boolean">
				<params>
					<param name="cname" fulltype="java.lang.String" type="String" />
					<param name="addr" fulltype="byte[]" type="byte" />
				</params>
			</method>
			<method visibility="package-private" name="getIP" fulltype="void" type="void">
				<comment>
					<description>get IP addresses. Sets invalid to true if we can&apos;t get them.</description>
				</comment>
				<exceptions>
					<exception fulltype="java.net.UnknownHostException" type="UnknownHostException" />
				</exceptions>
			</method>
			<method visibility="public" name="implies" returncomment="true if the specified permission is implied by this object,
 false if not." fulltype="boolean" type="boolean">
				<comment>
					<description>Checks if this socket permission object &quot;implies&quot; the
 specified permission.
 &lt;P&gt;
 More specifically, this method first ensures that all of the following
 are true (and returns false if any of them are not):&lt;p&gt;
 &lt;ul&gt;
 &lt;li&gt; &lt;i&gt;p&lt;/i&gt; is an instanceof SocketPermission,&lt;p&gt;
 &lt;li&gt; &lt;i&gt;p&lt;/i&gt;&apos;s actions are a proper subset of this
 object&apos;s actions, and&lt;p&gt;
 &lt;li&gt; &lt;i&gt;p&lt;/i&gt;&apos;s port range is included in this port range. Note:
 port range is ignored when p only contains the action, &apos;resolve&apos;.&lt;p&gt;
 &lt;/ul&gt;

 Then &lt;code&gt;implies&lt;/code&gt; checks each of the following, in order,
 and for each returns true if the stated condition is true:&lt;p&gt;
 &lt;ul&gt;
 &lt;li&gt; If this object was initialized with a single IP address and one of &lt;i&gt;p&lt;/i&gt;&apos;s
 IP addresses is equal to this object&apos;s IP address.&lt;p&gt;
 &lt;li&gt;If this object is a wildcard domain (such as *.sun.com), and
 &lt;i&gt;p&lt;/i&gt;&apos;s canonical name (the name without any preceding *)
 ends with this object&apos;s canonical host name. For example, *.sun.com
 implies *.eng.sun.com..&lt;p&gt;
 &lt;li&gt;If this object was not initialized with a single IP address, and one of this
 object&apos;s IP addresses equals one of &lt;i&gt;p&lt;/i&gt;&apos;s IP addresses.&lt;p&gt;
 &lt;li&gt;If this canonical name equals &lt;i&gt;p&lt;/i&gt;&apos;s canonical name.&lt;p&gt;
 &lt;/ul&gt;

 If none of the above are true, &lt;code&gt;implies&lt;/code&gt; returns false.</description>
					<attribute name="@param">
						<description>p the permission to check against.</description>
					</attribute>
					<attribute name="@return">
						<description>true if the specified permission is implied by this object,
 false if not.</description>
					</attribute>
				</comment>
				<params>
					<param name="p" comment="the permission to check against." fulltype="java.security.Permission" type="Permission" />
				</params>
			</method>
			<method visibility="package-private" name="impliesIgnoreMask" returncomment="true if &quot;permission&quot; is a proper subset of the current object,
 false if not." fulltype="boolean" type="boolean">
				<comment>
					<description>Checks if the incoming Permission&apos;s action are a proper subset of
 the this object&apos;s actions.
 &lt;P&gt;
 Check, in the following order:
 &lt;ul&gt;
 &lt;li&gt; Checks that &quot;p&quot; is an instanceof a SocketPermission
 &lt;li&gt; Checks that &quot;p&quot;&apos;s actions are a proper subset of the
 current object&apos;s actions.
 &lt;li&gt; Checks that &quot;p&quot;&apos;s port range is included in this port range
 &lt;li&gt; If this object was initialized with an IP address, checks that
      one of &quot;p&quot;&apos;s IP addresses is equal to this object&apos;s IP address.
 &lt;li&gt; If either object is a wildcard domain (i.e., &quot;*.sun.com&quot;),
      attempt to match based on the wildcard.
 &lt;li&gt; If this object was not initialized with an IP address, attempt
      to find a match based on the IP addresses in both objects.
 &lt;li&gt; Attempt to match on the canonical hostnames of both objects.
 &lt;/ul&gt;</description>
					<attribute name="@param">
						<description>p the incoming permission request</description>
					</attribute>
					<attribute name="@return">
						<description>true if &quot;permission&quot; is a proper subset of the current object,
 false if not.</description>
					</attribute>
				</comment>
				<params>
					<param name="that" fulltype="java.net.SocketPermission" type="SocketPermission" />
				</params>
			</method>
			<method visibility="private" name="inProxyWeTrust" fulltype="boolean" type="boolean">
				<params>
					<param name="that" fulltype="java.net.SocketPermission" type="SocketPermission" />
				</params>
			</method>
			<method visibility="public" name="equals" returncomment="true if &lt;i&gt;obj&lt;/i&gt; is a SocketPermission, and has the
  same hostname, port range, and actions as this
  SocketPermission object. However, port range will be ignored
  in the comparison if &lt;i&gt;obj&lt;/i&gt; only contains the action, &apos;resolve&apos;." fulltype="boolean" type="boolean">
				<comment>
					<description>Checks two SocketPermission objects for equality.
 &lt;P&gt;</description>
					<attribute name="@param">
						<description>obj the object to test for equality with this object.</description>
					</attribute>
					<attribute name="@return">
						<description>true if &lt;i&gt;obj&lt;/i&gt; is a SocketPermission, and has the
  same hostname, port range, and actions as this
  SocketPermission object. However, port range will be ignored
  in the comparison if &lt;i&gt;obj&lt;/i&gt; only contains the action, &apos;resolve&apos;.</description>
					</attribute>
				</comment>
				<params>
					<param name="obj" comment="the object to test for equality with this object." fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method visibility="public" name="hashCode" returncomment="a hash code value for this object." fulltype="int" type="int">
				<comment>
					<description>Returns the hash code value for this object.</description>
					<attribute name="@return">
						<description>a hash code value for this object.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="package-private" name="getMask" returncomment="the actions mask." fulltype="int" type="int">
				<comment>
					<description>Return the current action mask.</description>
					<attribute name="@return">
						<description>the actions mask.</description>
					</attribute>
				</comment>
			</method>
			<method static="true" visibility="private" name="getActions" returncomment="the canonical string representation of the actions" fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the &quot;canonical string representation&quot; of the actions in the
 specified mask.
 Always returns present actions in the following order:
 connect, listen, accept, resolve.</description>
					<attribute name="@param">
						<description>mask a specific integer action mask to translate into a string</description>
					</attribute>
					<attribute name="@return">
						<description>the canonical string representation of the actions</description>
					</attribute>
				</comment>
				<params>
					<param name="mask" comment="a specific integer action mask to translate into a string" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="getActions" returncomment="the canonical string representation of the actions." fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the canonical string representation of the actions.
 Always returns present actions in the following order:
 connect, listen, accept, resolve.</description>
					<attribute name="@return">
						<description>the canonical string representation of the actions.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="newPermissionCollection" returncomment="a new PermissionCollection object suitable for storing SocketPermissions." fulltype="java.security.PermissionCollection" type="PermissionCollection">
				<comment>
					<description>Returns a new PermissionCollection object for storing SocketPermission
 objects.
 &lt;p&gt;
 SocketPermission objects must be stored in a manner that allows them
 to be inserted into the collection in any order, but that also enables the
 PermissionCollection &lt;code&gt;implies&lt;/code&gt;
 method to be implemented in an efficient (and consistent) manner.</description>
					<attribute name="@return">
						<description>a new PermissionCollection object suitable for storing SocketPermissions.</description>
					</attribute>
				</comment>
			</method>
			<method synchronized="true" visibility="private" name="writeObject" fulltype="void" type="void">
				<comment>
					<description>WriteObject is called to save the state of the SocketPermission
 to a stream. The actions are serialized, and the superclass
 takes care of the name.</description>
				</comment>
				<params>
					<param name="s" fulltype="java.io.ObjectOutputStream" type="ObjectOutputStream" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="private" name="readObject" fulltype="void" type="void">
				<comment>
					<description>readObject is called to restore the state of the SocketPermission from
 a stream.</description>
				</comment>
				<params>
					<param name="s" fulltype="java.io.ObjectInputStream" type="ObjectInputStream" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
					<exception fulltype="java.lang.ClassNotFoundException" type="ClassNotFoundException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass final="true" superclass="PermissionCollection" visibility="package-private" package="java.net" serializable="true" superclassfulltype="java.security.PermissionCollection" fulltype="java.net.SocketPermissionCollection" type="SocketPermissionCollection">
		<implements>
			<interface fulltype="java.io.Serializable" type="Serializable" />
		</implements>
		<comment>
			<description>if (init&apos;d with IP, key is IP as string)
if wildcard, its the wild card
else its the cname?</description>
			<attribute name="@see">
				<description>java.security.Permission</description>
			</attribute>
			<attribute name="@see">
				<description>java.security.Permissions</description>
			</attribute>
			<attribute name="@see">
				<description>java.security.PermissionCollection</description>
			</attribute>
			<attribute name="@author">
				<description>Roland Schemers</description>
			</attribute>
			<attribute name="@serial">
				<description>include</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="private" transient="true" name="perms" fulltype="java.util.List" type="List" />
			<field final="true" static="true" const="2787186408602843674" visibility="private" name="serialVersionUID" constexpr="2787186408602843674L" fulltype="long" type="long" />
			<field final="true" static="true" visibility="private" name="serialPersistentFields" fulltype="java.io.ObjectStreamField[]" type="ObjectStreamField">
				<comment>
					<attribute name="@serialField">
						<description>permissions java.util.Vector
     A list of the SocketPermissions for this set.</description>
					</attribute>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="public" name="SocketPermissionCollection">
				<comment>
					<description>Create an empty SocketPermissions object.</description>
				</comment>
			</constructor>
			<method visibility="public" name="add" fulltype="void" type="void">
				<comment>
					<description>Adds a permission to the SocketPermissions. The key for the hash is
 the name in the case of wildcards, or all the IP addresses.</description>
					<attribute name="@param">
						<description>permission the Permission object to add.</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException - if the permission is not a
                                       SocketPermission</description>
					</attribute>
					<attribute name="@exception">
						<description>SecurityException - if this SocketPermissionCollection object
                                has been marked readonly</description>
					</attribute>
				</comment>
				<params>
					<param name="permission" comment="the Permission object to add." fulltype="java.security.Permission" type="Permission" />
				</params>
			</method>
			<method visibility="public" name="implies" returncomment="true if &quot;permission&quot; is a proper subset of a permission in
 the collection, false if not." fulltype="boolean" type="boolean">
				<comment>
					<description>Check and see if this collection of permissions implies the permissions
 expressed in &quot;permission&quot;.</description>
					<attribute name="@param">
						<description>p the Permission object to compare</description>
					</attribute>
					<attribute name="@return">
						<description>true if &quot;permission&quot; is a proper subset of a permission in
 the collection, false if not.</description>
					</attribute>
				</comment>
				<params>
					<param name="permission" fulltype="java.security.Permission" type="Permission" />
				</params>
			</method>
			<method visibility="public" name="elements" returncomment="an enumeration of all the SocketPermission objects." fulltype="java.util.Enumeration" type="Enumeration">
				<comment>
					<description>Returns an enumeration of all the SocketPermission objects in the
 container.</description>
					<attribute name="@return">
						<description>an enumeration of all the SocketPermission objects.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="private" name="writeObject" fulltype="void" type="void">
				<comment>
					<attribute name="@serialData">
						<description>&quot;permissions&quot; field (a Vector containing the SocketPermissions).</description>
					</attribute>
				</comment>
				<params>
					<param name="out" fulltype="java.io.ObjectOutputStream" type="ObjectOutputStream" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="readObject" fulltype="void" type="void">
				<params>
					<param name="in" fulltype="java.io.ObjectInputStream" type="ObjectInputStream" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
					<exception fulltype="java.lang.ClassNotFoundException" type="ClassNotFoundException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass final="true" superclass="Object" visibility="public" package="java.net" serializable="true" superclassfulltype="java.lang.Object" fulltype="java.net.URI" type="URI">
		<implements>
			<interface fulltype="java.lang.Comparable" type="Comparable" />
			<interface fulltype="java.io.Serializable" type="Serializable" />
		</implements>
		<comment>
			<description>Represents a Uniform Resource Identifier (URI) reference.

 &lt;p&gt; Aside from some minor deviations noted below, an instance of this
 class represents a URI reference as defined by
 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2396: Uniform
 Resource Identifiers (URI): Generic Syntax&lt;/i&gt;&lt;/a&gt;, amended by &lt;a
 href=&quot;http://www.ietf.org/rfc/rfc2732.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2732: Format for
 Literal IPv6 Addresses in URLs&lt;/i&gt;&lt;/a&gt;. The Literal IPv6 address format
 also supports scope_ids. The syntax and usage of scope_ids is described
 &lt;a href=&quot;Inet6Address.html#scoped&quot;&gt;here&lt;/a&gt;.
 This class provides constructors for creating URI instances from
 their components or by parsing their string forms, methods for accessing the
 various components of an instance, and methods for normalizing, resolving,
 and relativizing URI instances.  Instances of this class are immutable.


 &lt;h4&gt; URI syntax and components &lt;/h4&gt;

 At the highest level a URI reference (hereinafter simply &quot;URI&quot;) in string
 form has the syntax

 &lt;blockquote&gt;
 [&lt;i&gt;scheme&lt;/i&gt;&lt;tt&gt;&lt;b&gt;:&lt;/b&gt;&lt;/tt&gt;&lt;i&gt;&lt;/i&gt;]&lt;i&gt;scheme-specific-part&lt;/i&gt;[&lt;tt&gt;&lt;b&gt;#&lt;/b&gt;&lt;/tt&gt;&lt;i&gt;fragment&lt;/i&gt;]
 &lt;/blockquote&gt;

 where square brackets [...] delineate optional components and the characters
 &lt;tt&gt;&lt;b&gt;:&lt;/b&gt;&lt;/tt&gt; and &lt;tt&gt;&lt;b&gt;#&lt;/b&gt;&lt;/tt&gt; stand for themselves.

 &lt;p&gt; An &lt;i&gt;absolute&lt;/i&gt; URI specifies a scheme; a URI that is not absolute is
 said to be &lt;i&gt;relative&lt;/i&gt;.  URIs are also classified according to whether
 they are &lt;i&gt;opaque&lt;/i&gt; or &lt;i&gt;hierarchical&lt;/i&gt;.

 &lt;p&gt; An &lt;i&gt;opaque&lt;/i&gt; URI is an absolute URI whose scheme-specific part does
 not begin with a slash character (&lt;tt&gt;&apos;/&apos;&lt;/tt&gt;).  Opaque URIs are not
 subject to further parsing.  Some examples of opaque URIs are:

 &lt;blockquote&gt;&lt;table cellpadding=0 cellspacing=0 summary=&quot;layout&quot;&gt;
 &lt;tr&gt;&lt;td&gt;&lt;tt&gt;mailto:java-net@java.sun.com&lt;/tt&gt;&lt;td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;&lt;tt&gt;news:comp.lang.java&lt;/tt&gt;&lt;td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;&lt;tt&gt;urn:isbn:096139210x&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;&lt;/blockquote&gt;

 &lt;p&gt; A &lt;i&gt;hierarchical&lt;/i&gt; URI is either an absolute URI whose
 scheme-specific part begins with a slash character, or a relative URI, that
 is, a URI that does not specify a scheme.  Some examples of hierarchical
 URIs are:

 &lt;blockquote&gt;
 &lt;tt&gt;http://java.sun.com/j2se/1.3/&lt;/tt&gt;&lt;br&gt;
 &lt;tt&gt;docs/guide/collections/designfaq.html#28&lt;/tt&gt;&lt;br&gt;
 &lt;tt&gt;../../../demo/jfc/SwingSet2/src/SwingSet2.java&lt;/tt&gt;&lt;br&gt;
 &lt;tt&gt;file:///~/calendar&lt;/tt&gt;
 &lt;/blockquote&gt;

 &lt;p&gt; A hierarchical URI is subject to further parsing according to the syntax

 &lt;blockquote&gt;
 [&lt;i&gt;scheme&lt;/i&gt;&lt;tt&gt;&lt;b&gt;:&lt;/b&gt;&lt;/tt&gt;][&lt;tt&gt;&lt;b&gt;//&lt;/b&gt;&lt;/tt&gt;&lt;i&gt;authority&lt;/i&gt;][&lt;i&gt;path&lt;/i&gt;][&lt;tt&gt;&lt;b&gt;?&lt;/b&gt;&lt;/tt&gt;&lt;i&gt;query&lt;/i&gt;][&lt;tt&gt;&lt;b&gt;#&lt;/b&gt;&lt;/tt&gt;&lt;i&gt;fragment&lt;/i&gt;]
 &lt;/blockquote&gt;

 where the characters &lt;tt&gt;&lt;b&gt;:&lt;/b&gt;&lt;/tt&gt;, &lt;tt&gt;&lt;b&gt;/&lt;/b&gt;&lt;/tt&gt;,
 &lt;tt&gt;&lt;b&gt;?&lt;/b&gt;&lt;/tt&gt;, and &lt;tt&gt;&lt;b&gt;#&lt;/b&gt;&lt;/tt&gt; stand for themselves.  The
 scheme-specific part of a hierarchical URI consists of the characters
 between the scheme and fragment components.

 &lt;p&gt; The authority component of a hierarchical URI is, if specified, either
 &lt;i&gt;server-based&lt;/i&gt; or &lt;i&gt;registry-based&lt;/i&gt;.  A server-based authority
 parses according to the familiar syntax

 &lt;blockquote&gt;
 [&lt;i&gt;user-info&lt;/i&gt;&lt;tt&gt;&lt;b&gt;@&lt;/b&gt;&lt;/tt&gt;]&lt;i&gt;host&lt;/i&gt;[&lt;tt&gt;&lt;b&gt;:&lt;/b&gt;&lt;/tt&gt;&lt;i&gt;port&lt;/i&gt;]
 &lt;/blockquote&gt;

 where the characters &lt;tt&gt;&lt;b&gt;@&lt;/b&gt;&lt;/tt&gt; and &lt;tt&gt;&lt;b&gt;:&lt;/b&gt;&lt;/tt&gt; stand for
 themselves.  Nearly all URI schemes currently in use are server-based.  An
 authority component that does not parse in this way is considered to be
 registry-based.

 &lt;p&gt; The path component of a hierarchical URI is itself said to be absolute
 if it begins with a slash character (&lt;tt&gt;&apos;/&apos;&lt;/tt&gt;); otherwise it is
 relative.  The path of a hierarchical URI that is either absolute or
 specifies an authority is always absolute.

 &lt;p&gt; All told, then, a URI instance has the following nine components:

 &lt;blockquote&gt;&lt;table summary=&quot;Describes the components of a URI:scheme,scheme-specific-part,authority,user-info,host,port,path,query,fragment&quot;&gt;
 &lt;tr&gt;&lt;th&gt;&lt;i&gt;Component&lt;/i&gt;&lt;/th&gt;&lt;th&gt;&lt;i&gt;Type&lt;/i&gt;&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;scheme&lt;/td&gt;&lt;td&gt;&lt;tt&gt;String&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;scheme-specific-part&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/td&gt;&lt;td&gt;&lt;tt&gt;String&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;authority&lt;/td&gt;&lt;td&gt;&lt;tt&gt;String&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;user-info&lt;/td&gt;&lt;td&gt;&lt;tt&gt;String&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;host&lt;/td&gt;&lt;td&gt;&lt;tt&gt;String&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;port&lt;/td&gt;&lt;td&gt;&lt;tt&gt;int&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;path&lt;/td&gt;&lt;td&gt;&lt;tt&gt;String&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;query&lt;/td&gt;&lt;td&gt;&lt;tt&gt;String&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;fragment&lt;/td&gt;&lt;td&gt;&lt;tt&gt;String&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;&lt;/blockquote&gt;

 In a given instance any particular component is either &lt;i&gt;undefined&lt;/i&gt; or
 &lt;i&gt;defined&lt;/i&gt; with a distinct value.  Undefined string components are
 represented by &lt;tt&gt;null&lt;/tt&gt;, while undefined integer components are
 represented by &lt;tt&gt;-1&lt;/tt&gt;.  A string component may be defined to have the
 empty string as its value; this is not equivalent to that component being
 undefined.

 &lt;p&gt; Whether a particular component is or is not defined in an instance
 depends upon the type of the URI being represented.  An absolute URI has a
 scheme component.  An opaque URI has a scheme, a scheme-specific part, and
 possibly a fragment, but has no other components.  A hierarchical URI always
 has a path (though it may be empty) and a scheme-specific-part (which at
 least contains the path), and may have any of the other components.  If the
 authority component is present and is server-based then the host component
 will be defined and the user-information and port components may be defined.


 &lt;h4&gt; Operations on URI instances &lt;/h4&gt;

 The key operations supported by this class are those of
 &lt;i&gt;normalization&lt;/i&gt;, &lt;i&gt;resolution&lt;/i&gt;, and &lt;i&gt;relativization&lt;/i&gt;.

 &lt;p&gt; &lt;i&gt;Normalization&lt;/i&gt; is the process of removing unnecessary &lt;tt&gt;&quot;.&quot;&lt;/tt&gt;
 and &lt;tt&gt;&quot;..&quot;&lt;/tt&gt; segments from the path component of a hierarchical URI.
 Each &lt;tt&gt;&quot;.&quot;&lt;/tt&gt; segment is simply removed.  A &lt;tt&gt;&quot;..&quot;&lt;/tt&gt; segment is
 removed only if it is preceded by a non-&lt;tt&gt;&quot;..&quot;&lt;/tt&gt; segment.
 Normalization has no effect upon opaque URIs.

 &lt;p&gt; &lt;i&gt;Resolution&lt;/i&gt; is the process of resolving one URI against another,
 &lt;i&gt;base&lt;/i&gt; URI.  The resulting URI is constructed from components of both
 URIs in the manner specified by RFC&amp;nbsp;2396, taking components from the
 base URI for those not specified in the original.  For hierarchical URIs,
 the path of the original is resolved against the path of the base and then
 normalized.  The result, for example, of resolving

 &lt;blockquote&gt;
 &lt;tt&gt;docs/guide/collections/designfaq.html#28&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/tt&gt;(1)
 &lt;/blockquote&gt;

 against the base URI &lt;tt&gt;http://java.sun.com/j2se/1.3/&lt;/tt&gt; is the result
 URI

 &lt;blockquote&gt;
 &lt;tt&gt;http://java.sun.com/j2se/1.3/docs/guide/collections/designfaq.html#28&lt;/tt&gt;
 &lt;/blockquote&gt;

 Resolving the relative URI

 &lt;blockquote&gt;
 &lt;tt&gt;../../../demo/jfc/SwingSet2/src/SwingSet2.java&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/tt&gt;(2)
 &lt;/blockquote&gt;

 against this result yields, in turn,

 &lt;blockquote&gt;
 &lt;tt&gt;http://java.sun.com/j2se/1.3/demo/jfc/SwingSet2/src/SwingSet2.java&lt;/tt&gt;
 &lt;/blockquote&gt;

 Resolution of both absolute and relative URIs, and of both absolute and
 relative paths in the case of hierarchical URIs, is supported.  Resolving
 the URI &lt;tt&gt;file:///~calendar&lt;/tt&gt; against any other URI simply yields the
 original URI, since it is absolute.  Resolving the relative URI (2) above
 against the relative base URI (1) yields the normalized, but still relative,
 URI

 &lt;blockquote&gt;
 &lt;tt&gt;demo/jfc/SwingSet2/src/SwingSet2.java&lt;/tt&gt;
 &lt;/blockquote&gt;

 &lt;p&gt; &lt;i&gt;Relativization&lt;/i&gt;, finally, is the inverse of resolution: For any
 two normalized URIs &lt;i&gt;u&lt;/i&gt; and&amp;nbsp;&lt;i&gt;v&lt;/i&gt;,

 &lt;blockquote&gt;
   &lt;i&gt;u&lt;/i&gt;&lt;tt&gt;.relativize(&lt;/tt&gt;&lt;i&gt;u&lt;/i&gt;&lt;tt&gt;.resolve(&lt;/tt&gt;&lt;i&gt;v&lt;/i&gt;&lt;tt&gt;)).equals(&lt;/tt&gt;&lt;i&gt;v&lt;/i&gt;&lt;tt&gt;)&lt;/tt&gt;&amp;nbsp;&amp;nbsp;and&lt;br&gt;
   &lt;i&gt;u&lt;/i&gt;&lt;tt&gt;.resolve(&lt;/tt&gt;&lt;i&gt;u&lt;/i&gt;&lt;tt&gt;.relativize(&lt;/tt&gt;&lt;i&gt;v&lt;/i&gt;&lt;tt&gt;)).equals(&lt;/tt&gt;&lt;i&gt;v&lt;/i&gt;&lt;tt&gt;)&lt;/tt&gt;&amp;nbsp;&amp;nbsp;.&lt;br&gt;
 &lt;/blockquote&gt;

 This operation is often useful when constructing a document containing URIs
 that must be made relative to the base URI of the document wherever
 possible.  For example, relativizing the URI

 &lt;blockquote&gt;
 &lt;tt&gt;http://java.sun.com/j2se/1.3/docs/guide/index.html&lt;/tt&gt;
 &lt;/blockquote&gt;

 against the base URI

 &lt;blockquote&gt;
 &lt;tt&gt;http://java.sun.com/j2se/1.3&lt;/tt&gt;
 &lt;/blockquote&gt;

 yields the relative URI &lt;tt&gt;docs/guide/index.html&lt;/tt&gt;.


 &lt;h4&gt; Character categories &lt;/h4&gt;

 RFC&amp;nbsp;2396 specifies precisely which characters are permitted in the
 various components of a URI reference.  The following categories, most of
 which are taken from that specification, are used below to describe these
 constraints:

 &lt;blockquote&gt;&lt;table cellspacing=2 summary=&quot;Describes categories alpha,digit,alphanum,unreserved,punct,reserved,escaped,and other&quot;&gt;
   &lt;tr&gt;&lt;th valign=top&gt;&lt;i&gt;alpha&lt;/i&gt;&lt;/th&gt;
       &lt;td&gt;The US-ASCII alphabetic characters,
        &lt;tt&gt;&apos;A&apos;&lt;/tt&gt;&amp;nbsp;through&amp;nbsp;&lt;tt&gt;&apos;Z&apos;&lt;/tt&gt;
        and &lt;tt&gt;&apos;a&apos;&lt;/tt&gt;&amp;nbsp;through&amp;nbsp;&lt;tt&gt;&apos;z&apos;&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;th valign=top&gt;&lt;i&gt;digit&lt;/i&gt;&lt;/th&gt;
       &lt;td&gt;The US-ASCII decimal digit characters,
       &lt;tt&gt;&apos;0&apos;&lt;/tt&gt;&amp;nbsp;through&amp;nbsp;&lt;tt&gt;&apos;9&apos;&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;th valign=top&gt;&lt;i&gt;alphanum&lt;/i&gt;&lt;/th&gt;
       &lt;td&gt;All &lt;i&gt;alpha&lt;/i&gt; and &lt;i&gt;digit&lt;/i&gt; characters&lt;/td&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;th valign=top&gt;&lt;i&gt;unreserved&lt;/i&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/th&gt;
       &lt;td&gt;All &lt;i&gt;alphanum&lt;/i&gt; characters together with those in the string
        &lt;tt&gt;&quot;_-!.~&apos;()*&quot;&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;th valign=top&gt;&lt;i&gt;punct&lt;/i&gt;&lt;/th&gt;
       &lt;td&gt;The characters in the string &lt;tt&gt;&quot;,;:$&amp;+=&quot;&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;th valign=top&gt;&lt;i&gt;reserved&lt;/i&gt;&lt;/th&gt;
       &lt;td&gt;All &lt;i&gt;punct&lt;/i&gt; characters together with those in the string
        &lt;tt&gt;&quot;?/[]@&quot;&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;th valign=top&gt;&lt;i&gt;escaped&lt;/i&gt;&lt;/th&gt;
       &lt;td&gt;Escaped octets, that is, triplets consisting of the percent
           character (&lt;tt&gt;&apos;%&apos;&lt;/tt&gt;) followed by two hexadecimal digits
           (&lt;tt&gt;&apos;0&apos;&lt;/tt&gt;-&lt;tt&gt;&apos;9&apos;&lt;/tt&gt;, &lt;tt&gt;&apos;A&apos;&lt;/tt&gt;-&lt;tt&gt;&apos;F&apos;&lt;/tt&gt;, and
           &lt;tt&gt;&apos;a&apos;&lt;/tt&gt;-&lt;tt&gt;&apos;f&apos;&lt;/tt&gt;)&lt;/td&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;th valign=top&gt;&lt;i&gt;other&lt;/i&gt;&lt;/th&gt;
       &lt;td&gt;The Unicode characters that are not in the US-ASCII character set,
           are not control characters (according to the {@link
           java.lang.Character#isISOControl(char) Character.isISOControl}
           method), and are not space characters (according to the {@link
           java.lang.Character#isSpaceChar(char) Character.isSpaceChar}
           method)&amp;nbsp;&amp;nbsp;&lt;i&gt;(&lt;b&gt;Deviation from RFC 2396&lt;/b&gt;, which is
           limited to US-ASCII)&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;&lt;/blockquote&gt;

 &lt;p&gt;&lt;a name=&quot;legal-chars&quot;&gt;&lt;/a&gt; The set of all legal URI characters consists of
 the &lt;i&gt;unreserved&lt;/i&gt;, &lt;i&gt;reserved&lt;/i&gt;, &lt;i&gt;escaped&lt;/i&gt;, and &lt;i&gt;other&lt;/i&gt;
 characters.


 &lt;h4&gt; Escaped octets, quotation, encoding, and decoding &lt;/h4&gt;

 RFC 2396 allows escaped octets to appear in the user-info, path, query, and
 fragment components.  Escaping serves two purposes in URIs:

 &lt;ul&gt;

   &lt;li&gt;&lt;p&gt; To &lt;i&gt;encode&lt;/i&gt; non-US-ASCII characters when a URI is required to
   conform strictly to RFC&amp;nbsp;2396 by not containing any &lt;i&gt;other&lt;/i&gt;
   characters.  &lt;/p&gt;&lt;/li&gt;

   &lt;li&gt;&lt;p&gt; To &lt;i&gt;quote&lt;/i&gt; characters that are otherwise illegal in a
   component.  The user-info, path, query, and fragment components differ
   slightly in terms of which characters are considered legal and illegal.
   &lt;/p&gt;&lt;/li&gt;

 &lt;/ul&gt;

 These purposes are served in this class by three related operations:

 &lt;ul&gt;

   &lt;li&gt;&lt;p&gt;&lt;a name=&quot;encode&quot;&gt;&lt;/a&gt; A character is &lt;i&gt;encoded&lt;/i&gt; by replacing it
   with the sequence of escaped octets that represent that character in the
   UTF-8 character set.  The Euro currency symbol (&lt;tt&gt;&apos;&amp;#92;u20AC&apos;&lt;/tt&gt;),
   for example, is encoded as &lt;tt&gt;&quot;%E2%82%AC&quot;&lt;/tt&gt;.  &lt;i&gt;(&lt;b&gt;Deviation from
   RFC&amp;nbsp;2396&lt;/b&gt;, which does not specify any particular character
   set.)&lt;/i&gt; &lt;/p&gt;&lt;/li&gt;

   &lt;li&gt;&lt;p&gt;&lt;a name=&quot;quote&quot;&gt;&lt;/a&gt; An illegal character is &lt;i&gt;quoted&lt;/i&gt; simply by
   encoding it.  The space character, for example, is quoted by replacing it
   with &lt;tt&gt;&quot;%20&quot;&lt;/tt&gt;.  UTF-8 contains US-ASCII, hence for US-ASCII
   characters this transformation has exactly the effect required by
   RFC&amp;nbsp;2396. &lt;/p&gt;&lt;/li&gt;

   &lt;li&gt;&lt;p&gt;&lt;a name=&quot;decode&quot;&gt;&lt;/a&gt;
   A sequence of escaped octets is &lt;i&gt;decoded&lt;/i&gt; by
   replacing it with the sequence of characters that it represents in the
   UTF-8 character set.  UTF-8 contains US-ASCII, hence decoding has the
   effect of de-quoting any quoted US-ASCII characters as well as that of
   decoding any encoded non-US-ASCII characters.  If a &lt;a
   href=&quot;../nio/charset/CharsetDecoder.html#ce&quot;&gt;decoding error&lt;/a&gt; occurs
   when decoding the escaped octets then the erroneous octets are replaced by
   &lt;tt&gt;&apos;&amp;#92;uFFFD&apos;&lt;/tt&gt;, the Unicode replacement character.  &lt;/p&gt;&lt;/li&gt;

 &lt;/ul&gt;

 These operations are exposed in the constructors and methods of this class
 as follows:

 &lt;ul&gt;

   &lt;li&gt;&lt;p&gt; The {@link #URI(java.lang.String) &lt;code&gt;single-argument
   constructor&lt;/code&gt;} requires any illegal characters in its argument to be
   quoted and preserves any escaped octets and &lt;i&gt;other&lt;/i&gt; characters that
   are present.  &lt;/p&gt;&lt;/li&gt;

   &lt;li&gt;&lt;p&gt; The {@link
   #URI(java.lang.String,java.lang.String,java.lang.String,int,java.lang.String,java.lang.String,java.lang.String)
   &lt;code&gt;multi-argument constructors&lt;/code&gt;} quote illegal characters as
   required by the components in which they appear.  The percent character
   (&lt;tt&gt;&apos;%&apos;&lt;/tt&gt;) is always quoted by these constructors.  Any &lt;i&gt;other&lt;/i&gt;
   characters are preserved.  &lt;/p&gt;&lt;/li&gt;

   &lt;li&gt;&lt;p&gt; The {@link #getRawUserInfo() getRawUserInfo}, {@link #getRawPath()
   getRawPath}, {@link #getRawQuery() getRawQuery}, {@link #getRawFragment()
   getRawFragment}, {@link #getRawAuthority() getRawAuthority}, and {@link
   #getRawSchemeSpecificPart() getRawSchemeSpecificPart} methods return the
   values of their corresponding components in raw form, without interpreting
   any escaped octets.  The strings returned by these methods may contain
   both escaped octets and &lt;i&gt;other&lt;/i&gt; characters, and will not contain any
   illegal characters.  &lt;/p&gt;&lt;/li&gt;

   &lt;li&gt;&lt;p&gt; The {@link #getUserInfo() getUserInfo}, {@link #getPath()
   getPath}, {@link #getQuery() getQuery}, {@link #getFragment()
   getFragment}, {@link #getAuthority() getAuthority}, and {@link
   #getSchemeSpecificPart() getSchemeSpecificPart} methods decode any escaped
   octets in their corresponding components.  The strings returned by these
   methods may contain both &lt;i&gt;other&lt;/i&gt; characters and illegal characters,
   and will not contain any escaped octets.  &lt;/p&gt;&lt;/li&gt;

   &lt;li&gt;&lt;p&gt; The {@link #toString() toString} method returns a URI string with
   all necessary quotation but which may contain &lt;i&gt;other&lt;/i&gt; characters.
   &lt;/p&gt;&lt;/li&gt;

   &lt;li&gt;&lt;p&gt; The {@link #toASCIIString() toASCIIString} method returns a fully
   quoted and encoded URI string that does not contain any &lt;i&gt;other&lt;/i&gt;
   characters.  &lt;/p&gt;&lt;/li&gt;

 &lt;/ul&gt;


 &lt;h4&gt; Identities &lt;/h4&gt;

 For any URI &lt;i&gt;u&lt;/i&gt;, it is always the case that

 &lt;blockquote&gt;
 &lt;tt&gt;new URI(&lt;/tt&gt;&lt;i&gt;u&lt;/i&gt;&lt;tt&gt;.toString()).equals(&lt;/tt&gt;&lt;i&gt;u&lt;/i&gt;&lt;tt&gt;)&lt;/tt&gt;&amp;nbsp;.
 &lt;/blockquote&gt;

 For any URI &lt;i&gt;u&lt;/i&gt; that does not contain redundant syntax such as two
 slashes before an empty authority (as in &lt;tt&gt;file:///tmp/&lt;/tt&gt;&amp;nbsp;) or a
 colon following a host name but no port (as in
 &lt;tt&gt;http://java.sun.com:&lt;/tt&gt;&amp;nbsp;), and that does not encode characters
 except those that must be quoted, the following identities also hold:

 &lt;blockquote&gt;
 &lt;tt&gt;new URI(&lt;/tt&gt;&lt;i&gt;u&lt;/i&gt;&lt;tt&gt;.getScheme(),&lt;br&gt;
 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/tt&gt;&lt;i&gt;u&lt;/i&gt;&lt;tt&gt;.getSchemeSpecificPart(),&lt;br&gt;
 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/tt&gt;&lt;i&gt;u&lt;/i&gt;&lt;tt&gt;.getFragment())&lt;br&gt;
 .equals(&lt;/tt&gt;&lt;i&gt;u&lt;/i&gt;&lt;tt&gt;)&lt;/tt&gt;
 &lt;/blockquote&gt;

 in all cases,

 &lt;blockquote&gt;
 &lt;tt&gt;new URI(&lt;/tt&gt;&lt;i&gt;u&lt;/i&gt;&lt;tt&gt;.getScheme(),&lt;br&gt;
 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/tt&gt;&lt;i&gt;u&lt;/i&gt;&lt;tt&gt;.getUserInfo(),&amp;nbsp;&lt;/tt&gt;&lt;i&gt;u&lt;/i&gt;&lt;tt&gt;.getAuthority(),&lt;br&gt;
 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/tt&gt;&lt;i&gt;u&lt;/i&gt;&lt;tt&gt;.getPath(),&amp;nbsp;&lt;/tt&gt;&lt;i&gt;u&lt;/i&gt;&lt;tt&gt;.getQuery(),&lt;br&gt;
 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/tt&gt;&lt;i&gt;u&lt;/i&gt;&lt;tt&gt;.getFragment())&lt;br&gt;
 .equals(&lt;/tt&gt;&lt;i&gt;u&lt;/i&gt;&lt;tt&gt;)&lt;/tt&gt;
 &lt;/blockquote&gt;

 if &lt;i&gt;u&lt;/i&gt; is hierarchical, and

 &lt;blockquote&gt;
 &lt;tt&gt;new URI(&lt;/tt&gt;&lt;i&gt;u&lt;/i&gt;&lt;tt&gt;.getScheme(),&lt;br&gt;
 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/tt&gt;&lt;i&gt;u&lt;/i&gt;&lt;tt&gt;.getUserInfo(),&amp;nbsp;&lt;/tt&gt;&lt;i&gt;u&lt;/i&gt;&lt;tt&gt;.getHost(),&amp;nbsp;&lt;/tt&gt;&lt;i&gt;u&lt;/i&gt;&lt;tt&gt;.getPort(),&lt;br&gt;
 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/tt&gt;&lt;i&gt;u&lt;/i&gt;&lt;tt&gt;.getPath(),&amp;nbsp;&lt;/tt&gt;&lt;i&gt;u&lt;/i&gt;&lt;tt&gt;.getQuery(),&lt;br&gt;
 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/tt&gt;&lt;i&gt;u&lt;/i&gt;&lt;tt&gt;.getFragment())&lt;br&gt;
 .equals(&lt;/tt&gt;&lt;i&gt;u&lt;/i&gt;&lt;tt&gt;)&lt;/tt&gt;
 &lt;/blockquote&gt;

 if &lt;i&gt;u&lt;/i&gt; is hierarchical and has either no authority or a server-based
 authority.


 &lt;h4&gt; URIs, URLs, and URNs &lt;/h4&gt;

 A URI is a uniform resource &lt;i&gt;identifier&lt;/i&gt; while a URL is a uniform
 resource &lt;i&gt;locator&lt;/i&gt;.  Hence every URL is a URI, abstractly speaking, but
 not every URI is a URL.  This is because there is another subcategory of
 URIs, uniform resource &lt;i&gt;names&lt;/i&gt; (URNs), which name resources but do not
 specify how to locate them.  The &lt;tt&gt;mailto&lt;/tt&gt;, &lt;tt&gt;news&lt;/tt&gt;, and
 &lt;tt&gt;isbn&lt;/tt&gt; URIs shown above are examples of URNs.

 &lt;p&gt; The conceptual distinction between URIs and URLs is reflected in the
 differences between this class and the {@link URL} class.

 &lt;p&gt; An instance of this class represents a URI reference in the syntactic
 sense defined by RFC&amp;nbsp;2396.  A URI may be either absolute or relative.
 A URI string is parsed according to the generic syntax without regard to the
 scheme, if any, that it specifies.  No lookup of the host, if any, is
 performed, and no scheme-dependent stream handler is constructed.  Equality,
 hashing, and comparison are defined strictly in terms of the character
 content of the instance.  In other words, a URI instance is little more than
 a structured string that supports the syntactic, scheme-independent
 operations of comparison, normalization, resolution, and relativization.

 &lt;p&gt; An instance of the {@link URL} class, by contrast, represents the
 syntactic components of a URL together with some of the information required
 to access the resource that it describes.  A URL must be absolute, that is,
 it must always specify a scheme.  A URL string is parsed according to its
 scheme.  A stream handler is always established for a URL, and in fact it is
 impossible to create a URL instance for a scheme for which no handler is
 available.  Equality and hashing depend upon both the scheme and the
 Internet address of the host, if any; comparison is not defined.  In other
 words, a URL is a structured string that supports the syntactic operation of
 resolution as well as the network I/O operations of looking up the host and
 opening a connection to the specified resource.</description>
			<attribute name="@author">
				<description>Mark Reinhold</description>
			</attribute>
			<attribute name="@since">
				<description>1.4</description>
			</attribute>
			<attribute name="@see">
				<description>&lt;a href=&quot;http://www.ietf.org/rfc/rfc2279.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2279: UTF-8, a
 transformation format of ISO 10646&lt;/i&gt;&lt;/a&gt;, &lt;br&gt;&lt;a
 href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2373: IPv6 Addressing
 Architecture&lt;/i&gt;&lt;/a&gt;, &lt;br&gt;&lt;a
 href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2396: Uniform
 Resource Identifiers (URI): Generic Syntax&lt;/i&gt;&lt;/a&gt;, &lt;br&gt;&lt;a
 href=&quot;http://www.ietf.org/rfc/rfc2732.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2732: Format for
 Literal IPv6 Addresses in URLs&lt;/i&gt;&lt;/a&gt;, &lt;br&gt;&lt;a
 href=&quot;URISyntaxException.html&quot;&gt;URISyntaxException&lt;/a&gt;</description>
			</attribute>
		</comment>
		<fields>
			<field final="true" static="true" const="-6052424284110960213" visibility="package-private" name="serialVersionUID" constexpr="-6052424284110960213L" fulltype="long" type="long" />
			<field visibility="private" transient="true" name="scheme" fulltype="java.lang.String" type="String" />
			<field visibility="private" transient="true" name="fragment" fulltype="java.lang.String" type="String" />
			<field visibility="private" transient="true" name="authority" fulltype="java.lang.String" type="String" />
			<field visibility="private" transient="true" name="userInfo" fulltype="java.lang.String" type="String" />
			<field visibility="private" transient="true" name="host" fulltype="java.lang.String" type="String" />
			<field visibility="private" transient="true" name="port" fulltype="int" type="int" />
			<field visibility="private" transient="true" name="path" fulltype="java.lang.String" type="String" />
			<field visibility="private" transient="true" name="query" fulltype="java.lang.String" type="String" />
			<field volatile="true" visibility="private" transient="true" name="schemeSpecificPart" fulltype="java.lang.String" type="String" />
			<field volatile="true" visibility="private" transient="true" name="hash" fulltype="int" type="int" />
			<field volatile="true" visibility="private" transient="true" name="decodedUserInfo" fulltype="java.lang.String" type="String" />
			<field volatile="true" visibility="private" transient="true" name="decodedAuthority" fulltype="java.lang.String" type="String" />
			<field volatile="true" visibility="private" transient="true" name="decodedPath" fulltype="java.lang.String" type="String" />
			<field volatile="true" visibility="private" transient="true" name="decodedQuery" fulltype="java.lang.String" type="String" />
			<field volatile="true" visibility="private" transient="true" name="decodedFragment" fulltype="java.lang.String" type="String" />
			<field volatile="true" visibility="private" transient="true" name="decodedSchemeSpecificPart" fulltype="java.lang.String" type="String" />
			<field volatile="true" visibility="private" name="string" fulltype="java.lang.String" type="String">
				<comment>
					<description>The string form of this URI.</description>
					<attribute name="@serial" />
				</comment>
			</field>
			<field final="true" static="true" visibility="private" name="L_DIGIT" fulltype="long" type="long" />
			<field final="true" static="true" const="0" visibility="private" name="H_DIGIT" constexpr="0L" fulltype="long" type="long" />
			<field final="true" static="true" const="0" visibility="private" name="L_UPALPHA" constexpr="0L" fulltype="long" type="long" />
			<field final="true" static="true" visibility="private" name="H_UPALPHA" fulltype="long" type="long" />
			<field final="true" static="true" const="0" visibility="private" name="L_LOWALPHA" constexpr="0L" fulltype="long" type="long" />
			<field final="true" static="true" visibility="private" name="H_LOWALPHA" fulltype="long" type="long" />
			<field final="true" static="true" const="0" visibility="private" name="L_ALPHA" constexpr="0L" fulltype="long" type="long" />
			<field final="true" static="true" visibility="private" name="H_ALPHA" fulltype="long" type="long" />
			<field final="true" static="true" visibility="private" name="L_ALPHANUM" fulltype="long" type="long" />
			<field final="true" static="true" visibility="private" name="H_ALPHANUM" fulltype="long" type="long" />
			<field final="true" static="true" visibility="private" name="L_HEX" fulltype="long" type="long" />
			<field final="true" static="true" visibility="private" name="H_HEX" fulltype="long" type="long" />
			<field final="true" static="true" visibility="private" name="L_MARK" fulltype="long" type="long" />
			<field final="true" static="true" visibility="private" name="H_MARK" fulltype="long" type="long" />
			<field final="true" static="true" visibility="private" name="L_UNRESERVED" fulltype="long" type="long" />
			<field final="true" static="true" visibility="private" name="H_UNRESERVED" fulltype="long" type="long" />
			<field final="true" static="true" visibility="private" name="L_RESERVED" fulltype="long" type="long" />
			<field final="true" static="true" visibility="private" name="H_RESERVED" fulltype="long" type="long" />
			<field final="true" static="true" const="1" visibility="private" name="L_ESCAPED" constexpr="1L" fulltype="long" type="long" />
			<field final="true" static="true" const="0" visibility="private" name="H_ESCAPED" constexpr="0L" fulltype="long" type="long" />
			<field final="true" static="true" visibility="private" name="L_URIC" fulltype="long" type="long" />
			<field final="true" static="true" visibility="private" name="H_URIC" fulltype="long" type="long" />
			<field final="true" static="true" visibility="private" name="L_PCHAR" fulltype="long" type="long" />
			<field final="true" static="true" visibility="private" name="H_PCHAR" fulltype="long" type="long" />
			<field final="true" static="true" visibility="private" name="L_PATH" fulltype="long" type="long" />
			<field final="true" static="true" visibility="private" name="H_PATH" fulltype="long" type="long" />
			<field final="true" static="true" visibility="private" name="L_DASH" fulltype="long" type="long" />
			<field final="true" static="true" visibility="private" name="H_DASH" fulltype="long" type="long" />
			<field final="true" static="true" visibility="private" name="L_DOT" fulltype="long" type="long" />
			<field final="true" static="true" visibility="private" name="H_DOT" fulltype="long" type="long" />
			<field final="true" static="true" visibility="private" name="L_USERINFO" fulltype="long" type="long" />
			<field final="true" static="true" visibility="private" name="H_USERINFO" fulltype="long" type="long" />
			<field final="true" static="true" visibility="private" name="L_REG_NAME" fulltype="long" type="long" />
			<field final="true" static="true" visibility="private" name="H_REG_NAME" fulltype="long" type="long" />
			<field final="true" static="true" visibility="private" name="L_SERVER" fulltype="long" type="long" />
			<field final="true" static="true" visibility="private" name="H_SERVER" fulltype="long" type="long" />
			<field final="true" static="true" visibility="private" name="L_SERVER_PERCENT" fulltype="long" type="long" />
			<field final="true" static="true" visibility="private" name="H_SERVER_PERCENT" fulltype="long" type="long" />
			<field final="true" static="true" visibility="private" name="L_LEFT_BRACKET" fulltype="long" type="long" />
			<field final="true" static="true" visibility="private" name="H_LEFT_BRACKET" fulltype="long" type="long" />
			<field final="true" static="true" visibility="private" name="L_SCHEME" fulltype="long" type="long" />
			<field final="true" static="true" visibility="private" name="H_SCHEME" fulltype="long" type="long" />
			<field final="true" static="true" visibility="private" name="L_URIC_NO_SLASH" fulltype="long" type="long" />
			<field final="true" static="true" visibility="private" name="H_URIC_NO_SLASH" fulltype="long" type="long" />
			<field final="true" static="true" visibility="private" name="hexDigits" fulltype="char[]" type="char" />
		</fields>
		<methods>
			<constructor visibility="private" name="URI" />
			<constructor visibility="public" name="URI">
				<comment>
					<description>Constructs a URI by parsing the given string.

 &lt;p&gt; This constructor parses the given string exactly as specified by the
 grammar in &lt;a
 href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;RFC&amp;nbsp;2396&lt;/a&gt;,
 Appendix&amp;nbsp;A, &lt;b&gt;&lt;i&gt;except for the following deviations:&lt;/i&gt;&lt;/b&gt; &lt;/p&gt;

 &lt;ul type=disc&gt;

   &lt;li&gt;&lt;p&gt; An empty authority component is permitted as long as it is
   followed by a non-empty path, a query component, or a fragment
   component.  This allows the parsing of URIs such as
   &lt;tt&gt;&quot;file:///foo/bar&quot;&lt;/tt&gt;, which seems to be the intent of
   RFC&amp;nbsp;2396 although the grammar does not permit it.  If the
   authority component is empty then the user-information, host, and port
   components are undefined. &lt;/p&gt;&lt;/li&gt;

   &lt;li&gt;&lt;p&gt; Empty relative paths are permitted; this seems to be the
   intent of RFC&amp;nbsp;2396 although the grammar does not permit it.  The
   primary consequence of this deviation is that a standalone fragment
   such as &lt;tt&gt;&quot;#foo&quot;&lt;/tt&gt; parses as a relative URI with an empty path
   and the given fragment, and can be usefully &lt;a
   href=&quot;#resolve-frag&quot;&gt;resolved&lt;/a&gt; against a base URI.

   &lt;li&gt;&lt;p&gt; IPv4 addresses in host components are parsed rigorously, as
   specified by &lt;a
   href=&quot;http://www.ietf.org/rfc/rfc2732.txt&quot;&gt;RFC&amp;nbsp;2732&lt;/a&gt;: Each
   element of a dotted-quad address must contain no more than three
   decimal digits.  Each element is further constrained to have a value
   no greater than 255. &lt;/p&gt;&lt;/li&gt;

   &lt;li&gt; &lt;p&gt; Hostnames in host components that comprise only a single
   domain label are permitted to start with an &lt;i&gt;alphanum&lt;/i&gt;
   character. This seems to be the intent of &lt;a
   href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;RFC&amp;nbsp;2396&lt;/a&gt;
   section&amp;nbsp;3.2.2 although the grammar does not permit it. The
   consequence of this deviation is that the authority component of a
   hierarchical URI such as &lt;tt&gt;s://123&lt;/tt&gt;, will parse as a server-based
   authority. &lt;/p&gt;&lt;/li&gt;

   &lt;li&gt;&lt;p&gt; IPv6 addresses are permitted for the host component.  An IPv6
   address must be enclosed in square brackets (&lt;tt&gt;&apos;[&apos;&lt;/tt&gt; and
   &lt;tt&gt;&apos;]&apos;&lt;/tt&gt;) as specified by &lt;a
   href=&quot;http://www.ietf.org/rfc/rfc2732.txt&quot;&gt;RFC&amp;nbsp;2732&lt;/a&gt;.  The
   IPv6 address itself must parse according to &lt;a
   href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;RFC&amp;nbsp;2373&lt;/a&gt;.  IPv6
   addresses are further constrained to describe no more than sixteen
   bytes of address information, a constraint implicit in RFC&amp;nbsp;2373
   but not expressible in the grammar. &lt;/p&gt;&lt;/li&gt;

   &lt;li&gt;&lt;p&gt; Characters in the &lt;i&gt;other&lt;/i&gt; category are permitted wherever
   RFC&amp;nbsp;2396 permits &lt;i&gt;escaped&lt;/i&gt; octets, that is, in the
   user-information, path, query, and fragment components, as well as in
   the authority component if the authority is registry-based.  This
   allows URIs to contain Unicode characters beyond those in the US-ASCII
   character set. &lt;/p&gt;&lt;/li&gt;

 &lt;/ul&gt;</description>
					<attribute name="@param">
						<description>str   The string to be parsed into a URI</description>
					</attribute>
					<attribute name="@throws">
						<description>NullPointerException
          If &lt;tt&gt;str&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;</description>
					</attribute>
					<attribute name="@throws">
						<description>URISyntaxException
          If the given string violates RFC&amp;nbsp;2396, as augmented
          by the above deviations</description>
					</attribute>
				</comment>
				<params>
					<param name="str" comment="The string to be parsed into a URI" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception comment="If the given string violates RFC&amp;nbsp;2396, as augmented
          by the above deviations" fulltype="java.net.URISyntaxException" type="URISyntaxException" />
				</exceptions>
			</constructor>
			<constructor visibility="public" name="URI">
				<comment>
					<description>Constructs a hierarchical URI from the given components.

 &lt;p&gt; If a scheme is given then the path, if also given, must either be
 empty or begin with a slash character (&lt;tt&gt;&apos;/&apos;&lt;/tt&gt;).  Otherwise a
 component of the new URI may be left undefined by passing &lt;tt&gt;null&lt;/tt&gt;
 for the corresponding parameter or, in the case of the &lt;tt&gt;port&lt;/tt&gt;
 parameter, by passing &lt;tt&gt;-1&lt;/tt&gt;.

 &lt;p&gt; This constructor first builds a URI string from the given components
 according to the rules specified in &lt;a
 href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;RFC&amp;nbsp;2396&lt;/a&gt;,
 section&amp;nbsp;5.2, step&amp;nbsp;7: &lt;/p&gt;

 &lt;ol&gt;

   &lt;li&gt;&lt;p&gt; Initially, the result string is empty. &lt;/p&gt;&lt;/li&gt;

   &lt;li&gt;&lt;p&gt; If a scheme is given then it is appended to the result,
   followed by a colon character (&lt;tt&gt;&apos;:&apos;&lt;/tt&gt;).  &lt;/p&gt;&lt;/li&gt;

   &lt;li&gt;&lt;p&gt; If user information, a host, or a port are given then the
   string &lt;tt&gt;&quot;//&quot;&lt;/tt&gt; is appended.  &lt;/p&gt;&lt;/li&gt;

   &lt;li&gt;&lt;p&gt; If user information is given then it is appended, followed by
   a commercial-at character (&lt;tt&gt;&apos;@&apos;&lt;/tt&gt;).  Any character not in the
   &lt;i&gt;unreserved&lt;/i&gt;, &lt;i&gt;punct&lt;/i&gt;, &lt;i&gt;escaped&lt;/i&gt;, or &lt;i&gt;other&lt;/i&gt;
   categories is &lt;a href=&quot;#quote&quot;&gt;quoted&lt;/a&gt;.  &lt;/p&gt;&lt;/li&gt;

   &lt;li&gt;&lt;p&gt; If a host is given then it is appended.  If the host is a
   literal IPv6 address but is not enclosed in square brackets
   (&lt;tt&gt;&apos;[&apos;&lt;/tt&gt; and &lt;tt&gt;&apos;]&apos;&lt;/tt&gt;) then the square brackets are added.
   &lt;/p&gt;&lt;/li&gt;

   &lt;li&gt;&lt;p&gt; If a port number is given then a colon character
   (&lt;tt&gt;&apos;:&apos;&lt;/tt&gt;) is appended, followed by the port number in decimal.
   &lt;/p&gt;&lt;/li&gt;

   &lt;li&gt;&lt;p&gt; If a path is given then it is appended.  Any character not in
   the &lt;i&gt;unreserved&lt;/i&gt;, &lt;i&gt;punct&lt;/i&gt;, &lt;i&gt;escaped&lt;/i&gt;, or &lt;i&gt;other&lt;/i&gt;
   categories, and not equal to the slash character (&lt;tt&gt;&apos;/&apos;&lt;/tt&gt;) or the
   commercial-at character (&lt;tt&gt;&apos;@&apos;&lt;/tt&gt;), is quoted.  &lt;/p&gt;&lt;/li&gt;

   &lt;li&gt;&lt;p&gt; If a query is given then a question-mark character
   (&lt;tt&gt;&apos;?&apos;&lt;/tt&gt;) is appended, followed by the query.  Any character that
   is not a &lt;a href=&quot;#legal-chars&quot;&gt;legal URI character&lt;/a&gt; is quoted.
   &lt;/p&gt;&lt;/li&gt;

   &lt;li&gt;&lt;p&gt; Finally, if a fragment is given then a hash character
   (&lt;tt&gt;&apos;#&apos;&lt;/tt&gt;) is appended, followed by the fragment.  Any character
   that is not a legal URI character is quoted.  &lt;/p&gt;&lt;/li&gt;

 &lt;/ol&gt;

 &lt;p&gt; The resulting URI string is then parsed as if by invoking the {@link
 #URI(String)} constructor and then invoking the {@link
 #parseServerAuthority()} method upon the result; this may cause a {@link
 URISyntaxException} to be thrown.  &lt;/p&gt;</description>
					<attribute name="@param">
						<description>scheme    Scheme name</description>
					</attribute>
					<attribute name="@param">
						<description>userInfo  User name and authorization information</description>
					</attribute>
					<attribute name="@param">
						<description>host      Host name</description>
					</attribute>
					<attribute name="@param">
						<description>port      Port number</description>
					</attribute>
					<attribute name="@param">
						<description>path      Path</description>
					</attribute>
					<attribute name="@param">
						<description>query     Query</description>
					</attribute>
					<attribute name="@param">
						<description>fragment  Fragment</description>
					</attribute>
					<attribute name="@throws">
						<description>URISyntaxException
         If both a scheme and a path are given but the path is relative,
         if the URI string constructed from the given components violates
         RFC&amp;nbsp;2396, or if the authority component of the string is
         present but cannot be parsed as a server-based authority</description>
					</attribute>
				</comment>
				<params>
					<param name="scheme" comment="Scheme name" fulltype="java.lang.String" type="String" />
					<param name="userInfo" comment="User name and authorization information" fulltype="java.lang.String" type="String" />
					<param name="host" comment="Host name" fulltype="java.lang.String" type="String" />
					<param name="port" comment="Port number" fulltype="int" type="int" />
					<param name="path" comment="Path" fulltype="java.lang.String" type="String" />
					<param name="query" comment="Query" fulltype="java.lang.String" type="String" />
					<param name="fragment" comment="Fragment" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception comment="If both a scheme and a path are given but the path is relative,
         if the URI string constructed from the given components violates
         RFC&amp;nbsp;2396, or if the authority component of the string is
         present but cannot be parsed as a server-based authority" fulltype="java.net.URISyntaxException" type="URISyntaxException" />
				</exceptions>
			</constructor>
			<constructor visibility="public" name="URI">
				<comment>
					<description>Constructs a hierarchical URI from the given components.

 &lt;p&gt; If a scheme is given then the path, if also given, must either be
 empty or begin with a slash character (&lt;tt&gt;&apos;/&apos;&lt;/tt&gt;).  Otherwise a
 component of the new URI may be left undefined by passing &lt;tt&gt;null&lt;/tt&gt;
 for the corresponding parameter.

 &lt;p&gt; This constructor first builds a URI string from the given components
 according to the rules specified in &lt;a
 href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;RFC&amp;nbsp;2396&lt;/a&gt;,
 section&amp;nbsp;5.2, step&amp;nbsp;7: &lt;/p&gt;

 &lt;ol&gt;

   &lt;li&gt;&lt;p&gt; Initially, the result string is empty.  &lt;/p&gt;&lt;/li&gt;

   &lt;li&gt;&lt;p&gt; If a scheme is given then it is appended to the result,
   followed by a colon character (&lt;tt&gt;&apos;:&apos;&lt;/tt&gt;).  &lt;/p&gt;&lt;/li&gt;

   &lt;li&gt;&lt;p&gt; If an authority is given then the string &lt;tt&gt;&quot;//&quot;&lt;/tt&gt; is
   appended, followed by the authority.  If the authority contains a
   literal IPv6 address then the address must be enclosed in square
   brackets (&lt;tt&gt;&apos;[&apos;&lt;/tt&gt; and &lt;tt&gt;&apos;]&apos;&lt;/tt&gt;).  Any character not in the
   &lt;i&gt;unreserved&lt;/i&gt;, &lt;i&gt;punct&lt;/i&gt;, &lt;i&gt;escaped&lt;/i&gt;, or &lt;i&gt;other&lt;/i&gt;
   categories, and not equal to the commercial-at character
   (&lt;tt&gt;&apos;@&apos;&lt;/tt&gt;), is &lt;a href=&quot;#quote&quot;&gt;quoted&lt;/a&gt;.  &lt;/p&gt;&lt;/li&gt;

   &lt;li&gt;&lt;p&gt; If a path is given then it is appended.  Any character not in
   the &lt;i&gt;unreserved&lt;/i&gt;, &lt;i&gt;punct&lt;/i&gt;, &lt;i&gt;escaped&lt;/i&gt;, or &lt;i&gt;other&lt;/i&gt;
   categories, and not equal to the slash character (&lt;tt&gt;&apos;/&apos;&lt;/tt&gt;) or the
   commercial-at character (&lt;tt&gt;&apos;@&apos;&lt;/tt&gt;), is quoted.  &lt;/p&gt;&lt;/li&gt;

   &lt;li&gt;&lt;p&gt; If a query is given then a question-mark character
   (&lt;tt&gt;&apos;?&apos;&lt;/tt&gt;) is appended, followed by the query.  Any character that
   is not a &lt;a href=&quot;#legal-chars&quot;&gt;legal URI character&lt;/a&gt; is quoted.
   &lt;/p&gt;&lt;/li&gt;

   &lt;li&gt;&lt;p&gt; Finally, if a fragment is given then a hash character
   (&lt;tt&gt;&apos;#&apos;&lt;/tt&gt;) is appended, followed by the fragment.  Any character
   that is not a legal URI character is quoted.  &lt;/p&gt;&lt;/li&gt;

 &lt;/ol&gt;

 &lt;p&gt; The resulting URI string is then parsed as if by invoking the {@link
 #URI(String)} constructor and then invoking the {@link
 #parseServerAuthority()} method upon the result; this may cause a {@link
 URISyntaxException} to be thrown.  &lt;/p&gt;</description>
					<attribute name="@param">
						<description>scheme     Scheme name</description>
					</attribute>
					<attribute name="@param">
						<description>authority  Authority</description>
					</attribute>
					<attribute name="@param">
						<description>path       Path</description>
					</attribute>
					<attribute name="@param">
						<description>query      Query</description>
					</attribute>
					<attribute name="@param">
						<description>fragment   Fragment</description>
					</attribute>
					<attribute name="@throws">
						<description>URISyntaxException
         If both a scheme and a path are given but the path is relative,
         if the URI string constructed from the given components violates
         RFC&amp;nbsp;2396, or if the authority component of the string is
         present but cannot be parsed as a server-based authority</description>
					</attribute>
				</comment>
				<params>
					<param name="scheme" comment="Scheme name" fulltype="java.lang.String" type="String" />
					<param name="authority" comment="Authority" fulltype="java.lang.String" type="String" />
					<param name="path" comment="Path" fulltype="java.lang.String" type="String" />
					<param name="query" comment="Query" fulltype="java.lang.String" type="String" />
					<param name="fragment" comment="Fragment" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception comment="If both a scheme and a path are given but the path is relative,
         if the URI string constructed from the given components violates
         RFC&amp;nbsp;2396, or if the authority component of the string is
         present but cannot be parsed as a server-based authority" fulltype="java.net.URISyntaxException" type="URISyntaxException" />
				</exceptions>
			</constructor>
			<constructor visibility="public" name="URI">
				<comment>
					<description>Constructs a hierarchical URI from the given components.

 &lt;p&gt; A component may be left undefined by passing &lt;tt&gt;null&lt;/tt&gt;.

 &lt;p&gt; This convenience constructor works as if by invoking the
 seven-argument constructor as follows:

 &lt;blockquote&gt;&lt;tt&gt;
 new&amp;nbsp;{@link #URI(String, String, String, int, String, String, String)
 URI}(scheme,&amp;nbsp;null,&amp;nbsp;host,&amp;nbsp;-1,&amp;nbsp;path,&amp;nbsp;null,&amp;nbsp;fragment);
 &lt;/tt&gt;&lt;/blockquote&gt;</description>
					<attribute name="@param">
						<description>scheme    Scheme name</description>
					</attribute>
					<attribute name="@param">
						<description>host      Host name</description>
					</attribute>
					<attribute name="@param">
						<description>path      Path</description>
					</attribute>
					<attribute name="@param">
						<description>fragment  Fragment</description>
					</attribute>
					<attribute name="@throws">
						<description>URISyntaxException
          If the URI string constructed from the given components
          violates RFC&amp;nbsp;2396</description>
					</attribute>
				</comment>
				<params>
					<param name="scheme" comment="Scheme name" fulltype="java.lang.String" type="String" />
					<param name="host" comment="Host name" fulltype="java.lang.String" type="String" />
					<param name="path" comment="Path" fulltype="java.lang.String" type="String" />
					<param name="fragment" comment="Fragment" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception comment="If the URI string constructed from the given components
          violates RFC&amp;nbsp;2396" fulltype="java.net.URISyntaxException" type="URISyntaxException" />
				</exceptions>
			</constructor>
			<constructor visibility="public" name="URI">
				<comment>
					<description>Constructs a URI from the given components.

 &lt;p&gt; A component may be left undefined by passing &lt;tt&gt;null&lt;/tt&gt;.

 &lt;p&gt; This constructor first builds a URI in string form using the given
 components as follows:  &lt;/p&gt;

 &lt;ol&gt;

   &lt;li&gt;&lt;p&gt; Initially, the result string is empty.  &lt;/p&gt;&lt;/li&gt;

   &lt;li&gt;&lt;p&gt; If a scheme is given then it is appended to the result,
   followed by a colon character (&lt;tt&gt;&apos;:&apos;&lt;/tt&gt;).  &lt;/p&gt;&lt;/li&gt;

   &lt;li&gt;&lt;p&gt; If a scheme-specific part is given then it is appended.  Any
   character that is not a &lt;a href=&quot;#legal-chars&quot;&gt;legal URI character&lt;/a&gt;
   is &lt;a href=&quot;#quote&quot;&gt;quoted&lt;/a&gt;.  &lt;/p&gt;&lt;/li&gt;

   &lt;li&gt;&lt;p&gt; Finally, if a fragment is given then a hash character
   (&lt;tt&gt;&apos;#&apos;&lt;/tt&gt;) is appended to the string, followed by the fragment.
   Any character that is not a legal URI character is quoted.  &lt;/p&gt;&lt;/li&gt;

 &lt;/ol&gt;

 &lt;p&gt; The resulting URI string is then parsed in order to create the new
 URI instance as if by invoking the {@link #URI(String)} constructor;
 this may cause a {@link URISyntaxException} to be thrown.  &lt;/p&gt;</description>
					<attribute name="@param">
						<description>scheme    Scheme name</description>
					</attribute>
					<attribute name="@param">
						<description>ssp       Scheme-specific part</description>
					</attribute>
					<attribute name="@param">
						<description>fragment  Fragment</description>
					</attribute>
					<attribute name="@throws">
						<description>URISyntaxException
          If the URI string constructed from the given components
          violates RFC&amp;nbsp;2396</description>
					</attribute>
				</comment>
				<params>
					<param name="scheme" comment="Scheme name" fulltype="java.lang.String" type="String" />
					<param name="ssp" comment="Scheme-specific part" fulltype="java.lang.String" type="String" />
					<param name="fragment" comment="Fragment" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception comment="If the URI string constructed from the given components
          violates RFC&amp;nbsp;2396" fulltype="java.net.URISyntaxException" type="URISyntaxException" />
				</exceptions>
			</constructor>
			<method static="true" visibility="public" name="create" returncomment="The new URI" fulltype="java.net.URI" type="URI">
				<comment>
					<description>Creates a URI by parsing the given string.

 &lt;p&gt; This convenience factory method works as if by invoking the {@link
 #URI(String)} constructor; any {@link URISyntaxException} thrown by the
 constructor is caught and wrapped in a new {@link
 IllegalArgumentException} object, which is then thrown.

 &lt;p&gt; This method is provided for use in situations where it is known that
 the given string is a legal URI, for example for URI constants declared
 within in a program, and so it would be considered a programming error
 for the string not to parse as such.  The constructors, which throw
 {@link URISyntaxException} directly, should be used situations where a
 URI is being constructed from user input or from some other source that
 may be prone to errors.  &lt;/p&gt;</description>
					<attribute name="@param">
						<description>str   The string to be parsed into a URI</description>
					</attribute>
					<attribute name="@return">
						<description>The new URI</description>
					</attribute>
					<attribute name="@throws">
						<description>NullPointerException
          If &lt;tt&gt;str&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException
          If the given string violates RFC&amp;nbsp;2396</description>
					</attribute>
				</comment>
				<params>
					<param name="str" comment="The string to be parsed into a URI" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="public" name="parseServerAuthority" returncomment="A URI whose authority field has been parsed
          as a server-based authority" fulltype="java.net.URI" type="URI">
				<comment>
					<description>Attempts to parse this URI&apos;s authority component, if defined, into
 user-information, host, and port components.

 &lt;p&gt; If this URI&apos;s authority component has already been recognized as
 being server-based then it will already have been parsed into
 user-information, host, and port components.  In this case, or if this
 URI has no authority component, this method simply returns this URI.

 &lt;p&gt; Otherwise this method attempts once more to parse the authority
 component into user-information, host, and port components, and throws
 an exception describing why the authority component could not be parsed
 in that way.

 &lt;p&gt; This method is provided because the generic URI syntax specified in
 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;RFC&amp;nbsp;2396&lt;/a&gt;
 cannot always distinguish a malformed server-based authority from a
 legitimate registry-based authority.  It must therefore treat some
 instances of the former as instances of the latter.  The authority
 component in the URI string &lt;tt&gt;&quot;//foo:bar&quot;&lt;/tt&gt;, for example, is not a
 legal server-based authority but it is legal as a registry-based
 authority.

 &lt;p&gt; In many common situations, for example when working URIs that are
 known to be either URNs or URLs, the hierarchical URIs being used will
 always be server-based.  They therefore must either be parsed as such or
 treated as an error.  In these cases a statement such as

 &lt;blockquote&gt;
 &lt;tt&gt;URI &lt;/tt&gt;&lt;i&gt;u&lt;/i&gt;&lt;tt&gt; = new URI(str).parseServerAuthority();&lt;/tt&gt;
 &lt;/blockquote&gt;

 &lt;p&gt; can be used to ensure that &lt;i&gt;u&lt;/i&gt; always refers to a URI that, if
 it has an authority component, has a server-based authority with proper
 user-information, host, and port components.  Invoking this method also
 ensures that if the authority could not be parsed in that way then an
 appropriate diagnostic message can be issued based upon the exception
 that is thrown. &lt;/p&gt;</description>
					<attribute name="@return">
						<description>A URI whose authority field has been parsed
          as a server-based authority</description>
					</attribute>
					<attribute name="@throws">
						<description>URISyntaxException
          If the authority component of this URI is defined
          but cannot be parsed as a server-based authority
          according to RFC&amp;nbsp;2396</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If the authority component of this URI is defined
          but cannot be parsed as a server-based authority
          according to RFC&amp;nbsp;2396" fulltype="java.net.URISyntaxException" type="URISyntaxException" />
				</exceptions>
			</method>
			<method visibility="public" name="normalize" returncomment="A URI equivalent to this URI,
          but whose path is in normal form" fulltype="java.net.URI" type="URI">
				<comment>
					<description>Normalizes this URI&apos;s path.

 &lt;p&gt; If this URI is opaque, or if its path is already in normal form,
 then this URI is returned.  Otherwise a new URI is constructed that is
 identical to this URI except that its path is computed by normalizing
 this URI&apos;s path in a manner consistent with &lt;a
 href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;RFC&amp;nbsp;2396&lt;/a&gt;,
 section&amp;nbsp;5.2, step&amp;nbsp;6, sub-steps&amp;nbsp;c through&amp;nbsp;f; that is:
 &lt;/p&gt;

 &lt;ol&gt;

   &lt;li&gt;&lt;p&gt; All &lt;tt&gt;&quot;.&quot;&lt;/tt&gt; segments are removed. &lt;/p&gt;&lt;/li&gt;

   &lt;li&gt;&lt;p&gt; If a &lt;tt&gt;&quot;..&quot;&lt;/tt&gt; segment is preceded by a non-&lt;tt&gt;&quot;..&quot;&lt;/tt&gt;
   segment then both of these segments are removed.  This step is
   repeated until it is no longer applicable. &lt;/p&gt;&lt;/li&gt;

   &lt;li&gt;&lt;p&gt; If the path is relative, and if its first segment contains a
   colon character (&lt;tt&gt;&apos;:&apos;&lt;/tt&gt;), then a &lt;tt&gt;&quot;.&quot;&lt;/tt&gt; segment is
   prepended.  This prevents a relative URI with a path such as
   &lt;tt&gt;&quot;a:b/c/d&quot;&lt;/tt&gt; from later being re-parsed as an opaque URI with a
   scheme of &lt;tt&gt;&quot;a&quot;&lt;/tt&gt; and a scheme-specific part of &lt;tt&gt;&quot;b/c/d&quot;&lt;/tt&gt;.
   &lt;b&gt;&lt;i&gt;(Deviation from RFC&amp;nbsp;2396)&lt;/i&gt;&lt;/b&gt; &lt;/p&gt;&lt;/li&gt;

 &lt;/ol&gt;

 &lt;p&gt; A normalized path will begin with one or more &lt;tt&gt;&quot;..&quot;&lt;/tt&gt; segments
 if there were insufficient non-&lt;tt&gt;&quot;..&quot;&lt;/tt&gt; segments preceding them to
 allow their removal.  A normalized path will begin with a &lt;tt&gt;&quot;.&quot;&lt;/tt&gt;
 segment if one was inserted by step 3 above.  Otherwise, a normalized
 path will not contain any &lt;tt&gt;&quot;.&quot;&lt;/tt&gt; or &lt;tt&gt;&quot;..&quot;&lt;/tt&gt; segments. &lt;/p&gt;</description>
					<attribute name="@return">
						<description>A URI equivalent to this URI,
          but whose path is in normal form</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="resolve" returncomment="The resulting URI" fulltype="java.net.URI" type="URI">
				<comment>
					<description>Resolves the given URI against this URI.

 &lt;p&gt; If the given URI is already absolute, or if this URI is opaque, then
 the given URI is returned.

 &lt;p&gt;&lt;a name=&quot;resolve-frag&quot;&gt;&lt;/a&gt; If the given URI&apos;s fragment component is
 defined, its path component is empty, and its scheme, authority, and
 query components are undefined, then a URI with the given fragment but
 with all other components equal to those of this URI is returned.  This
 allows a URI representing a standalone fragment reference, such as
 &lt;tt&gt;&quot;#foo&quot;&lt;/tt&gt;, to be usefully resolved against a base URI.

 &lt;p&gt; Otherwise this method constructs a new hierarchical URI in a manner
 consistent with &lt;a
 href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;RFC&amp;nbsp;2396&lt;/a&gt;,
 section&amp;nbsp;5.2; that is: &lt;/p&gt;

 &lt;ol&gt;

   &lt;li&gt;&lt;p&gt; A new URI is constructed with this URI&apos;s scheme and the given
   URI&apos;s query and fragment components. &lt;/p&gt;&lt;/li&gt;

   &lt;li&gt;&lt;p&gt; If the given URI has an authority component then the new URI&apos;s
   authority and path are taken from the given URI. &lt;/p&gt;&lt;/li&gt;

   &lt;li&gt;&lt;p&gt; Otherwise the new URI&apos;s authority component is copied from
   this URI, and its path is computed as follows: &lt;/p&gt;&lt;/li&gt;

   &lt;ol type=a&gt;

     &lt;li&gt;&lt;p&gt; If the given URI&apos;s path is absolute then the new URI&apos;s path
     is taken from the given URI. &lt;/p&gt;&lt;/li&gt;

     &lt;li&gt;&lt;p&gt; Otherwise the given URI&apos;s path is relative, and so the new
     URI&apos;s path is computed by resolving the path of the given URI
     against the path of this URI.  This is done by concatenating all but
     the last segment of this URI&apos;s path, if any, with the given URI&apos;s
     path and then normalizing the result as if by invoking the {@link
     #normalize() normalize} method. &lt;/p&gt;&lt;/li&gt;

   &lt;/ol&gt;

 &lt;/ol&gt;

 &lt;p&gt; The result of this method is absolute if, and only if, either this
 URI is absolute or the given URI is absolute.  &lt;/p&gt;</description>
					<attribute name="@param">
						<description>uri  The URI to be resolved against this URI</description>
					</attribute>
					<attribute name="@return">
						<description>The resulting URI</description>
					</attribute>
					<attribute name="@throws">
						<description>NullPointerException
          If &lt;tt&gt;uri&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;</description>
					</attribute>
				</comment>
				<params>
					<param name="uri" comment="The URI to be resolved against this URI" fulltype="java.net.URI" type="URI" />
				</params>
			</method>
			<method visibility="public" name="resolve" returncomment="The resulting URI" fulltype="java.net.URI" type="URI">
				<comment>
					<description>Constructs a new URI by parsing the given string and then resolving it
 against this URI.

 &lt;p&gt; This convenience method works as if invoking it were equivalent to
 evaluating the expression &lt;tt&gt;{@link #resolve(java.net.URI)
 resolve}(URI.{@link #create(String) create}(str))&lt;/tt&gt;. &lt;/p&gt;</description>
					<attribute name="@param">
						<description>str   The string to be parsed into a URI</description>
					</attribute>
					<attribute name="@return">
						<description>The resulting URI</description>
					</attribute>
					<attribute name="@throws">
						<description>NullPointerException
          If &lt;tt&gt;str&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException
          If the given string violates RFC&amp;nbsp;2396</description>
					</attribute>
				</comment>
				<params>
					<param name="str" comment="The string to be parsed into a URI" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="public" name="relativize" returncomment="The resulting URI" fulltype="java.net.URI" type="URI">
				<comment>
					<description>Relativizes the given URI against this URI.

 &lt;p&gt; The relativization of the given URI against this URI is computed as
 follows: &lt;/p&gt;

 &lt;ol&gt;

   &lt;li&gt;&lt;p&gt; If either this URI or the given URI are opaque, or if the
   scheme and authority components of the two URIs are not identical, or
   if the path of this URI is not a prefix of the path of the given URI,
   then the given URI is returned. &lt;/p&gt;&lt;/li&gt;

   &lt;li&gt;&lt;p&gt; Otherwise a new relative hierarchical URI is constructed with
   query and fragment components taken from the given URI and with a path
   component computed by removing this URI&apos;s path from the beginning of
   the given URI&apos;s path. &lt;/p&gt;&lt;/li&gt;

 &lt;/ol&gt;</description>
					<attribute name="@param">
						<description>uri  The URI to be relativized against this URI</description>
					</attribute>
					<attribute name="@return">
						<description>The resulting URI</description>
					</attribute>
					<attribute name="@throws">
						<description>NullPointerException
          If &lt;tt&gt;uri&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;</description>
					</attribute>
				</comment>
				<params>
					<param name="uri" comment="The URI to be relativized against this URI" fulltype="java.net.URI" type="URI" />
				</params>
			</method>
			<method visibility="public" name="toURL" returncomment="A URL constructed from this URI" fulltype="java.net.URL" type="URL">
				<comment>
					<description>Constructs a URL from this URI.

 &lt;p&gt; This convenience method works as if invoking it were equivalent to
 evaluating the expression &lt;tt&gt;new&amp;nbsp;URL(this.toString())&lt;/tt&gt; after
 first checking that this URI is absolute. &lt;/p&gt;</description>
					<attribute name="@return">
						<description>A URL constructed from this URI</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException
          If this URL is not absolute</description>
					</attribute>
					<attribute name="@throws">
						<description>MalformedURLException
          If a protocol handler for the URL could not be found,
          or if some other error occurred while constructing the URL</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If a protocol handler for the URL could not be found,
          or if some other error occurred while constructing the URL" fulltype="java.net.MalformedURLException" type="MalformedURLException" />
				</exceptions>
			</method>
			<method visibility="public" name="getScheme" returncomment="The scheme component of this URI,
          or &lt;tt&gt;null&lt;/tt&gt; if the scheme is undefined" fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the scheme component of this URI.

 &lt;p&gt; The scheme component of a URI, if defined, only contains characters
 in the &lt;i&gt;alphanum&lt;/i&gt; category and in the string &lt;tt&gt;&quot;-.+&quot;&lt;/tt&gt;.  A
 scheme always starts with an &lt;i&gt;alpha&lt;/i&gt; character. &lt;p&gt;

 The scheme component of a URI cannot contain escaped octets, hence this
 method does not perform any decoding.</description>
					<attribute name="@return">
						<description>The scheme component of this URI,
          or &lt;tt&gt;null&lt;/tt&gt; if the scheme is undefined</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="isAbsolute" returncomment="&lt;tt&gt;true&lt;/tt&gt; if, and only if, this URI is absolute" fulltype="boolean" type="boolean">
				<comment>
					<description>Tells whether or not this URI is absolute.

 &lt;p&gt; A URI is absolute if, and only if, it has a scheme component. &lt;/p&gt;</description>
					<attribute name="@return">
						<description>&lt;tt&gt;true&lt;/tt&gt; if, and only if, this URI is absolute</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="isOpaque" returncomment="&lt;tt&gt;true&lt;/tt&gt; if, and only if, this URI is opaque" fulltype="boolean" type="boolean">
				<comment>
					<description>Tells whether or not this URI is opaque.

 &lt;p&gt; A URI is opaque if, and only if, it is absolute and its
 scheme-specific part does not begin with a slash character (&apos;/&apos;).
 An opaque URI has a scheme, a scheme-specific part, and possibly
 a fragment; all other components are undefined. &lt;/p&gt;</description>
					<attribute name="@return">
						<description>&lt;tt&gt;true&lt;/tt&gt; if, and only if, this URI is opaque</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getRawSchemeSpecificPart" returncomment="The raw scheme-specific part of this URI
          (never &lt;tt&gt;null&lt;/tt&gt;)" fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the raw scheme-specific part of this URI.  The scheme-specific
 part is never undefined, though it may be empty.

 &lt;p&gt; The scheme-specific part of a URI only contains legal URI
 characters. &lt;/p&gt;</description>
					<attribute name="@return">
						<description>The raw scheme-specific part of this URI
          (never &lt;tt&gt;null&lt;/tt&gt;)</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getSchemeSpecificPart" returncomment="The decoded scheme-specific part of this URI
          (never &lt;tt&gt;null&lt;/tt&gt;)" fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the decoded scheme-specific part of this URI.

 &lt;p&gt; The string returned by this method is equal to that returned by the
 {@link #getRawSchemeSpecificPart() getRawSchemeSpecificPart} method
 except that all sequences of escaped octets are &lt;a
 href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.  &lt;/p&gt;</description>
					<attribute name="@return">
						<description>The decoded scheme-specific part of this URI
          (never &lt;tt&gt;null&lt;/tt&gt;)</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getRawAuthority" returncomment="The raw authority component of this URI,
          or &lt;tt&gt;null&lt;/tt&gt; if the authority is undefined" fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the raw authority component of this URI.

 &lt;p&gt; The authority component of a URI, if defined, only contains the
 commercial-at character (&lt;tt&gt;&apos;@&apos;&lt;/tt&gt;) and characters in the
 &lt;i&gt;unreserved&lt;/i&gt;, &lt;i&gt;punct&lt;/i&gt;, &lt;i&gt;escaped&lt;/i&gt;, and &lt;i&gt;other&lt;/i&gt;
 categories.  If the authority is server-based then it is further
 constrained to have valid user-information, host, and port
 components. &lt;/p&gt;</description>
					<attribute name="@return">
						<description>The raw authority component of this URI,
          or &lt;tt&gt;null&lt;/tt&gt; if the authority is undefined</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getAuthority" returncomment="The decoded authority component of this URI,
          or &lt;tt&gt;null&lt;/tt&gt; if the authority is undefined" fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the decoded authority component of this URI.

 &lt;p&gt; The string returned by this method is equal to that returned by the
 {@link #getRawAuthority() getRawAuthority} method except that all
 sequences of escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.  &lt;/p&gt;</description>
					<attribute name="@return">
						<description>The decoded authority component of this URI,
          or &lt;tt&gt;null&lt;/tt&gt; if the authority is undefined</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getRawUserInfo" returncomment="The raw user-information component of this URI,
          or &lt;tt&gt;null&lt;/tt&gt; if the user information is undefined" fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the raw user-information component of this URI.

 &lt;p&gt; The user-information component of a URI, if defined, only contains
 characters in the &lt;i&gt;unreserved&lt;/i&gt;, &lt;i&gt;punct&lt;/i&gt;, &lt;i&gt;escaped&lt;/i&gt;, and
 &lt;i&gt;other&lt;/i&gt; categories. &lt;/p&gt;</description>
					<attribute name="@return">
						<description>The raw user-information component of this URI,
          or &lt;tt&gt;null&lt;/tt&gt; if the user information is undefined</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getUserInfo" returncomment="The decoded user-information component of this URI,
          or &lt;tt&gt;null&lt;/tt&gt; if the user information is undefined" fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the decoded user-information component of this URI.

 &lt;p&gt; The string returned by this method is equal to that returned by the
 {@link #getRawUserInfo() getRawUserInfo} method except that all
 sequences of escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.  &lt;/p&gt;</description>
					<attribute name="@return">
						<description>The decoded user-information component of this URI,
          or &lt;tt&gt;null&lt;/tt&gt; if the user information is undefined</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getHost" returncomment="The host component of this URI,
          or &lt;tt&gt;null&lt;/tt&gt; if the host is undefined" fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the host component of this URI.

 &lt;p&gt; The host component of a URI, if defined, will have one of the
 following forms: &lt;/p&gt;

 &lt;ul type=disc&gt;

   &lt;li&gt;&lt;p&gt; A domain name consisting of one or more &lt;i&gt;labels&lt;/i&gt;
   separated by period characters (&lt;tt&gt;&apos;.&apos;&lt;/tt&gt;), optionally followed by
   a period character.  Each label consists of &lt;i&gt;alphanum&lt;/i&gt; characters
   as well as hyphen characters (&lt;tt&gt;&apos;-&apos;&lt;/tt&gt;), though hyphens never
   occur as the first or last characters in a label. The rightmost
   label of a domain name consisting of two or more labels, begins
   with an &lt;i&gt;alpha&lt;/i&gt; character. &lt;/li&gt;

   &lt;li&gt;&lt;p&gt; A dotted-quad IPv4 address of the form
   &lt;i&gt;digit&lt;/i&gt;&lt;tt&gt;+.&lt;/tt&gt;&lt;i&gt;digit&lt;/i&gt;&lt;tt&gt;+.&lt;/tt&gt;&lt;i&gt;digit&lt;/i&gt;&lt;tt&gt;+.&lt;/tt&gt;&lt;i&gt;digit&lt;/i&gt;&lt;tt&gt;+&lt;/tt&gt;,
   where no &lt;i&gt;digit&lt;/i&gt; sequence is longer than three characters and no
   sequence has a value larger than 255. &lt;/p&gt;&lt;/li&gt;

   &lt;li&gt;&lt;p&gt; An IPv6 address enclosed in square brackets (&lt;tt&gt;&apos;[&apos;&lt;/tt&gt; and
   &lt;tt&gt;&apos;]&apos;&lt;/tt&gt;) and consisting of hexadecimal digits, colon characters
   (&lt;tt&gt;&apos;:&apos;&lt;/tt&gt;), and possibly an embedded IPv4 address.  The full
   syntax of IPv6 addresses is specified in &lt;a
   href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2373: IPv6
   Addressing Architecture&lt;/i&gt;&lt;/a&gt;.  &lt;/p&gt;&lt;/li&gt;

 &lt;/ul&gt;

 The host component of a URI cannot contain escaped octets, hence this
 method does not perform any decoding.</description>
					<attribute name="@return">
						<description>The host component of this URI,
          or &lt;tt&gt;null&lt;/tt&gt; if the host is undefined</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getPort" returncomment="The port component of this URI,
          or &lt;tt&gt;-1&lt;/tt&gt; if the port is undefined" fulltype="int" type="int">
				<comment>
					<description>Returns the port number of this URI.

 &lt;p&gt; The port component of a URI, if defined, is a non-negative
 integer. &lt;/p&gt;</description>
					<attribute name="@return">
						<description>The port component of this URI,
          or &lt;tt&gt;-1&lt;/tt&gt; if the port is undefined</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getRawPath" returncomment="The path component of this URI,
          or &lt;tt&gt;null&lt;/tt&gt; if the path is undefined" fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the raw path component of this URI.

 &lt;p&gt; The path component of a URI, if defined, only contains the slash
 character (&lt;tt&gt;&apos;/&apos;&lt;/tt&gt;), the commercial-at character (&lt;tt&gt;&apos;@&apos;&lt;/tt&gt;),
 and characters in the &lt;i&gt;unreserved&lt;/i&gt;, &lt;i&gt;punct&lt;/i&gt;, &lt;i&gt;escaped&lt;/i&gt;,
 and &lt;i&gt;other&lt;/i&gt; categories. &lt;/p&gt;</description>
					<attribute name="@return">
						<description>The path component of this URI,
          or &lt;tt&gt;null&lt;/tt&gt; if the path is undefined</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getPath" returncomment="The decoded path component of this URI,
          or &lt;tt&gt;null&lt;/tt&gt; if the path is undefined" fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the decoded path component of this URI.

 &lt;p&gt; The string returned by this method is equal to that returned by the
 {@link #getRawPath() getRawPath} method except that all sequences of
 escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.  &lt;/p&gt;</description>
					<attribute name="@return">
						<description>The decoded path component of this URI,
          or &lt;tt&gt;null&lt;/tt&gt; if the path is undefined</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getRawQuery" returncomment="The raw query component of this URI,
          or &lt;tt&gt;null&lt;/tt&gt; if the query is undefined" fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the raw query component of this URI.

 &lt;p&gt; The query component of a URI, if defined, only contains legal URI
 characters. &lt;/p&gt;</description>
					<attribute name="@return">
						<description>The raw query component of this URI,
          or &lt;tt&gt;null&lt;/tt&gt; if the query is undefined</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getQuery" returncomment="The decoded query component of this URI,
          or &lt;tt&gt;null&lt;/tt&gt; if the query is undefined" fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the decoded query component of this URI.

 &lt;p&gt; The string returned by this method is equal to that returned by the
 {@link #getRawQuery() getRawQuery} method except that all sequences of
 escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.  &lt;/p&gt;</description>
					<attribute name="@return">
						<description>The decoded query component of this URI,
          or &lt;tt&gt;null&lt;/tt&gt; if the query is undefined</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getRawFragment" returncomment="The raw fragment component of this URI,
          or &lt;tt&gt;null&lt;/tt&gt; if the fragment is undefined" fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the raw fragment component of this URI.

 &lt;p&gt; The fragment component of a URI, if defined, only contains legal URI
 characters. &lt;/p&gt;</description>
					<attribute name="@return">
						<description>The raw fragment component of this URI,
          or &lt;tt&gt;null&lt;/tt&gt; if the fragment is undefined</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getFragment" returncomment="The decoded fragment component of this URI,
          or &lt;tt&gt;null&lt;/tt&gt; if the fragment is undefined" fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the decoded fragment component of this URI.

 &lt;p&gt; The string returned by this method is equal to that returned by the
 {@link #getRawFragment() getRawFragment} method except that all
 sequences of escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.  &lt;/p&gt;</description>
					<attribute name="@return">
						<description>The decoded fragment component of this URI,
          or &lt;tt&gt;null&lt;/tt&gt; if the fragment is undefined</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="equals" returncomment="&lt;tt&gt;true&lt;/tt&gt; if, and only if, the given object is a URI that
          is identical to this URI" fulltype="boolean" type="boolean">
				<comment>
					<description>Tests this URI for equality with another object.

 &lt;p&gt; If the given object is not a URI then this method immediately
 returns &lt;tt&gt;false&lt;/tt&gt;.

 &lt;p&gt; For two URIs to be considered equal requires that either both are
 opaque or both are hierarchical.  Their schemes must either both be
 undefined or else be equal without regard to case. Their fragments
 must either both be undefined or else be equal.

 &lt;p&gt; For two opaque URIs to be considered equal, their scheme-specific
 parts must be equal.

 &lt;p&gt; For two hierarchical URIs to be considered equal, their paths must
 be equal and their queries must either both be undefined or else be
 equal.  Their authorities must either both be undefined, or both be
 registry-based, or both be server-based.  If their authorities are
 defined and are registry-based, then they must be equal.  If their
 authorities are defined and are server-based, then their hosts must be
 equal without regard to case, their port numbers must be equal, and
 their user-information components must be equal.

 &lt;p&gt; When testing the user-information, path, query, fragment, authority,
 or scheme-specific parts of two URIs for equality, the raw forms rather
 than the encoded forms of these components are compared and the
 hexadecimal digits of escaped octets are compared without regard to
 case.

 &lt;p&gt; This method satisfies the general contract of the {@link
 java.lang.Object#equals(Object) Object.equals} method. &lt;/p&gt;</description>
					<attribute name="@param">
						<description>ob   The object to which this object is to be compared</description>
					</attribute>
					<attribute name="@return">
						<description>&lt;tt&gt;true&lt;/tt&gt; if, and only if, the given object is a URI that
          is identical to this URI</description>
					</attribute>
				</comment>
				<params>
					<param name="ob" comment="The object to which this object is to be compared" fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method visibility="public" name="hashCode" returncomment="A hash-code value for this URI" fulltype="int" type="int">
				<comment>
					<description>Returns a hash-code value for this URI.  The hash code is based upon all
 of the URI&apos;s components, and satisfies the general contract of the
 {@link java.lang.Object#hashCode() Object.hashCode} method.</description>
					<attribute name="@return">
						<description>A hash-code value for this URI</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="compareTo" returncomment="A negative integer, zero, or a positive integer as this URI is
          less than, equal to, or greater than the given URI" fulltype="int" type="int">
				<comment>
					<description>Compares this URI to another object, which must be a URI.

 &lt;p&gt; When comparing corresponding components of two URIs, if one
 component is undefined but the other is defined then the first is
 considered to be less than the second.  Unless otherwise noted, string
 components are ordered according to their natural, case-sensitive
 ordering as defined by the {@link java.lang.String#compareTo(Object)
 String.compareTo} method.  String components that are subject to
 encoding are compared by comparing their raw forms rather than their
 encoded forms.

 &lt;p&gt; The ordering of URIs is defined as follows: &lt;/p&gt;

 &lt;ul type=disc&gt;

   &lt;li&gt;&lt;p&gt; Two URIs with different schemes are ordered according the
   ordering of their schemes, without regard to case. &lt;/p&gt;&lt;/li&gt;

   &lt;li&gt;&lt;p&gt; A hierarchical URI is considered to be less than an opaque URI
   with an identical scheme. &lt;/p&gt;&lt;/li&gt;

   &lt;li&gt;&lt;p&gt; Two opaque URIs with identical schemes are ordered according
   to the ordering of their scheme-specific parts. &lt;/p&gt;&lt;/li&gt;

   &lt;li&gt;&lt;p&gt; Two opaque URIs with identical schemes and scheme-specific
   parts are ordered according to the ordering of their
   fragments. &lt;/p&gt;&lt;/li&gt;

   &lt;li&gt;&lt;p&gt; Two hierarchical URIs with identical schemes are ordered
   according to the ordering of their authority components: &lt;/p&gt;&lt;/li&gt;

   &lt;ul type=disc&gt;

     &lt;li&gt;&lt;p&gt; If both authority components are server-based then the URIs
     are ordered according to their user-information components; if these
     components are identical then the URIs are ordered according to the
     ordering of their hosts, without regard to case; if the hosts are
     identical then the URIs are ordered according to the ordering of
     their ports. &lt;/p&gt;&lt;/li&gt;

     &lt;li&gt;&lt;p&gt; If one or both authority components are registry-based then
     the URIs are ordered according to the ordering of their authority
     components. &lt;/p&gt;&lt;/li&gt;

   &lt;/ul&gt;

   &lt;li&gt;&lt;p&gt; Finally, two hierarchical URIs with identical schemes and
   authority components are ordered according to the ordering of their
   paths; if their paths are identical then they are ordered according to
   the ordering of their queries; if the queries are identical then they
   are ordered according to the order of their fragments. &lt;/p&gt;&lt;/li&gt;

 &lt;/ul&gt;

 &lt;p&gt; This method satisfies the general contract of the {@link
 java.lang.Comparable#compareTo(Object) Comparable.compareTo}
 method. &lt;/p&gt;</description>
					<attribute name="@param">
						<description>that
          The object to which this URI is to be compared</description>
					</attribute>
					<attribute name="@return">
						<description>A negative integer, zero, or a positive integer as this URI is
          less than, equal to, or greater than the given URI</description>
					</attribute>
					<attribute name="@throws">
						<description>ClassCastException
          If the given object is not a URI</description>
					</attribute>
				</comment>
				<params>
					<param name="that" comment="The object to which this URI is to be compared" fulltype="java.net.URI" type="URI" />
				</params>
			</method>
			<method visibility="public" name="toString" returncomment="The string form of this URI" fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the content of this URI as a string.

 &lt;p&gt; If this URI was created by invoking one of the constructors in this
 class then a string equivalent to the original input string, or to the
 string computed from the originally-given components, as appropriate, is
 returned.  Otherwise this URI was created by normalization, resolution,
 or relativization, and so a string is constructed from this URI&apos;s
 components according to the rules specified in &lt;a
 href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;RFC&amp;nbsp;2396&lt;/a&gt;,
 section&amp;nbsp;5.2, step&amp;nbsp;7. &lt;/p&gt;</description>
					<attribute name="@return">
						<description>The string form of this URI</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="toASCIIString" returncomment="The string form of this URI, encoded as needed
          so that it only contains characters in the US-ASCII
          charset" fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the content of this URI as a US-ASCII string.

 &lt;p&gt; If this URI does not contain any characters in the &lt;i&gt;other&lt;/i&gt;
 category then an invocation of this method will return the same value as
 an invocation of the {@link #toString() toString} method.  Otherwise
 this method works as if by invoking that method and then &lt;a
 href=&quot;#encode&quot;&gt;encoding&lt;/a&gt; the result.  &lt;/p&gt;</description>
					<attribute name="@return">
						<description>The string form of this URI, encoded as needed
          so that it only contains characters in the US-ASCII
          charset</description>
					</attribute>
				</comment>
			</method>
			<method visibility="private" name="writeObject" fulltype="void" type="void">
				<comment>
					<description>Saves the content of this URI to the given serial stream.

 &lt;p&gt; The only serializable field of a URI instance is its &lt;tt&gt;string&lt;/tt&gt;
 field.  That field is given a value, if it does not have one already,
 and then the {@link java.io.ObjectOutputStream#defaultWriteObject()}
 method of the given object-output stream is invoked. &lt;/p&gt;</description>
					<attribute name="@param">
						<description>os  The object-output stream to which this object
             is to be written</description>
					</attribute>
				</comment>
				<params>
					<param name="os" comment="The object-output stream to which this object
             is to be written" fulltype="java.io.ObjectOutputStream" type="ObjectOutputStream" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="readObject" fulltype="void" type="void">
				<comment>
					<description>Reconstitutes a URI from the given serial stream.

 &lt;p&gt; The {@link java.io.ObjectInputStream#defaultReadObject()} method is
 invoked to read the value of the &lt;tt&gt;string&lt;/tt&gt; field.  The result is
 then parsed in the usual way.</description>
					<attribute name="@param">
						<description>is  The object-input stream from which this object
             is being read</description>
					</attribute>
				</comment>
				<params>
					<param name="is" comment="The object-input stream from which this object
             is being read" fulltype="java.io.ObjectInputStream" type="ObjectInputStream" />
				</params>
				<exceptions>
					<exception fulltype="java.lang.ClassNotFoundException" type="ClassNotFoundException" />
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method static="true" visibility="private" name="toLower" fulltype="int" type="int">
				<params>
					<param name="c" fulltype="char" type="char" />
				</params>
			</method>
			<method static="true" visibility="private" name="equal" fulltype="boolean" type="boolean">
				<params>
					<param name="s" fulltype="java.lang.String" type="String" />
					<param name="t" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method static="true" visibility="private" name="equalIgnoringCase" fulltype="boolean" type="boolean">
				<params>
					<param name="s" fulltype="java.lang.String" type="String" />
					<param name="t" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method static="true" visibility="private" name="hash" fulltype="int" type="int">
				<params>
					<param name="hash" fulltype="int" type="int" />
					<param name="s" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method static="true" visibility="private" name="hashIgnoringCase" fulltype="int" type="int">
				<params>
					<param name="hash" fulltype="int" type="int" />
					<param name="s" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method static="true" visibility="private" name="compare" fulltype="int" type="int">
				<params>
					<param name="s" fulltype="java.lang.String" type="String" />
					<param name="t" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method static="true" visibility="private" name="compareIgnoringCase" fulltype="int" type="int">
				<params>
					<param name="s" fulltype="java.lang.String" type="String" />
					<param name="t" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method static="true" visibility="private" name="checkPath" fulltype="void" type="void">
				<params>
					<param name="s" fulltype="java.lang.String" type="String" />
					<param name="scheme" fulltype="java.lang.String" type="String" />
					<param name="path" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception fulltype="java.net.URISyntaxException" type="URISyntaxException" />
				</exceptions>
			</method>
			<method visibility="private" name="appendAuthority" fulltype="void" type="void">
				<params>
					<param name="sb" fulltype="java.lang.StringBuffer" type="StringBuffer" />
					<param name="authority" fulltype="java.lang.String" type="String" />
					<param name="userInfo" fulltype="java.lang.String" type="String" />
					<param name="host" fulltype="java.lang.String" type="String" />
					<param name="port" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="private" name="appendSchemeSpecificPart" fulltype="void" type="void">
				<params>
					<param name="sb" fulltype="java.lang.StringBuffer" type="StringBuffer" />
					<param name="opaquePart" fulltype="java.lang.String" type="String" />
					<param name="authority" fulltype="java.lang.String" type="String" />
					<param name="userInfo" fulltype="java.lang.String" type="String" />
					<param name="host" fulltype="java.lang.String" type="String" />
					<param name="port" fulltype="int" type="int" />
					<param name="path" fulltype="java.lang.String" type="String" />
					<param name="query" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="private" name="appendFragment" fulltype="void" type="void">
				<params>
					<param name="sb" fulltype="java.lang.StringBuffer" type="StringBuffer" />
					<param name="fragment" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="private" name="toString" fulltype="java.lang.String" type="String">
				<params>
					<param name="scheme" fulltype="java.lang.String" type="String" />
					<param name="opaquePart" fulltype="java.lang.String" type="String" />
					<param name="authority" fulltype="java.lang.String" type="String" />
					<param name="userInfo" fulltype="java.lang.String" type="String" />
					<param name="host" fulltype="java.lang.String" type="String" />
					<param name="port" fulltype="int" type="int" />
					<param name="path" fulltype="java.lang.String" type="String" />
					<param name="query" fulltype="java.lang.String" type="String" />
					<param name="fragment" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="private" name="defineSchemeSpecificPart" fulltype="void" type="void" />
			<method visibility="private" name="defineString" fulltype="void" type="void" />
			<method static="true" visibility="private" name="resolvePath" fulltype="java.lang.String" type="String">
				<params>
					<param name="base" fulltype="java.lang.String" type="String" />
					<param name="child" fulltype="java.lang.String" type="String" />
					<param name="absolute" fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method static="true" visibility="private" name="resolve" fulltype="java.net.URI" type="URI">
				<params>
					<param name="base" fulltype="java.net.URI" type="URI" />
					<param name="child" fulltype="java.net.URI" type="URI" />
				</params>
			</method>
			<method static="true" visibility="private" name="normalize" fulltype="java.net.URI" type="URI">
				<params>
					<param name="u" fulltype="java.net.URI" type="URI" />
				</params>
			</method>
			<method static="true" visibility="private" name="relativize" fulltype="java.net.URI" type="URI">
				<params>
					<param name="base" fulltype="java.net.URI" type="URI" />
					<param name="child" fulltype="java.net.URI" type="URI" />
				</params>
			</method>
			<method static="true" visibility="private" name="needsNormalization" fulltype="int" type="int">
				<params>
					<param name="path" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method static="true" visibility="private" name="split" fulltype="void" type="void">
				<params>
					<param name="path" fulltype="char[]" type="char" />
					<param name="segs" fulltype="int[]" type="int" />
				</params>
			</method>
			<method static="true" visibility="private" name="join" fulltype="int" type="int">
				<params>
					<param name="path" fulltype="char[]" type="char" />
					<param name="segs" fulltype="int[]" type="int" />
				</params>
			</method>
			<method static="true" visibility="private" name="removeDots" fulltype="void" type="void">
				<params>
					<param name="path" fulltype="char[]" type="char" />
					<param name="segs" fulltype="int[]" type="int" />
				</params>
			</method>
			<method static="true" visibility="private" name="maybeAddLeadingDot" fulltype="void" type="void">
				<params>
					<param name="path" fulltype="char[]" type="char" />
					<param name="segs" fulltype="int[]" type="int" />
				</params>
			</method>
			<method static="true" visibility="private" name="normalize" fulltype="java.lang.String" type="String">
				<params>
					<param name="ps" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method static="true" visibility="private" name="lowMask" fulltype="long" type="long">
				<params>
					<param name="chars" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method static="true" visibility="private" name="highMask" fulltype="long" type="long">
				<params>
					<param name="chars" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method static="true" visibility="private" name="lowMask" fulltype="long" type="long">
				<params>
					<param name="first" fulltype="char" type="char" />
					<param name="last" fulltype="char" type="char" />
				</params>
			</method>
			<method static="true" visibility="private" name="highMask" fulltype="long" type="long">
				<params>
					<param name="first" fulltype="char" type="char" />
					<param name="last" fulltype="char" type="char" />
				</params>
			</method>
			<method static="true" visibility="private" name="match" fulltype="boolean" type="boolean">
				<params>
					<param name="c" fulltype="char" type="char" />
					<param name="lowMask" fulltype="long" type="long" />
					<param name="highMask" fulltype="long" type="long" />
				</params>
			</method>
			<method static="true" visibility="private" name="appendEscape" fulltype="void" type="void">
				<params>
					<param name="sb" fulltype="java.lang.StringBuffer" type="StringBuffer" />
					<param name="b" fulltype="byte" type="byte" />
				</params>
			</method>
			<method static="true" visibility="private" name="appendEncoded" fulltype="void" type="void">
				<params>
					<param name="sb" fulltype="java.lang.StringBuffer" type="StringBuffer" />
					<param name="c" fulltype="char" type="char" />
				</params>
			</method>
			<method static="true" visibility="private" name="quote" fulltype="java.lang.String" type="String">
				<params>
					<param name="s" fulltype="java.lang.String" type="String" />
					<param name="lowMask" fulltype="long" type="long" />
					<param name="highMask" fulltype="long" type="long" />
				</params>
			</method>
			<method static="true" visibility="private" name="encode" fulltype="java.lang.String" type="String">
				<params>
					<param name="s" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method static="true" visibility="private" name="decode" fulltype="int" type="int">
				<params>
					<param name="c" fulltype="char" type="char" />
				</params>
			</method>
			<method static="true" visibility="private" name="decode" fulltype="byte" type="byte">
				<params>
					<param name="c1" fulltype="char" type="char" />
					<param name="c2" fulltype="char" type="char" />
				</params>
			</method>
			<method static="true" visibility="private" name="decode" fulltype="java.lang.String" type="String">
				<params>
					<param name="s" fulltype="java.lang.String" type="String" />
				</params>
			</method>
		</methods>
		<jelclass superclass="Object" visibility="private" package="java.net" superclassfulltype="java.lang.Object" fulltype="java.net.URI.Parser" type="URI.Parser">
			<fields>
				<field visibility="private" name="input" fulltype="java.lang.String" type="String" />
				<field visibility="private" name="requireServerAuthority" fulltype="boolean" type="boolean" />
				<field visibility="private" name="ipv6byteCount" fulltype="int" type="int" />
			</fields>
			<methods>
				<constructor visibility="package-private" name="URI.Parser">
					<params>
						<param name="s" fulltype="java.lang.String" type="String" />
					</params>
				</constructor>
				<method visibility="private" name="fail" fulltype="void" type="void">
					<params>
						<param name="reason" fulltype="java.lang.String" type="String" />
					</params>
					<exceptions>
						<exception fulltype="java.net.URISyntaxException" type="URISyntaxException" />
					</exceptions>
				</method>
				<method visibility="private" name="fail" fulltype="void" type="void">
					<params>
						<param name="reason" fulltype="java.lang.String" type="String" />
						<param name="p" fulltype="int" type="int" />
					</params>
					<exceptions>
						<exception fulltype="java.net.URISyntaxException" type="URISyntaxException" />
					</exceptions>
				</method>
				<method visibility="private" name="failExpecting" fulltype="void" type="void">
					<params>
						<param name="expected" fulltype="java.lang.String" type="String" />
						<param name="p" fulltype="int" type="int" />
					</params>
					<exceptions>
						<exception fulltype="java.net.URISyntaxException" type="URISyntaxException" />
					</exceptions>
				</method>
				<method visibility="private" name="failExpecting" fulltype="void" type="void">
					<params>
						<param name="expected" fulltype="java.lang.String" type="String" />
						<param name="prior" fulltype="java.lang.String" type="String" />
						<param name="p" fulltype="int" type="int" />
					</params>
					<exceptions>
						<exception fulltype="java.net.URISyntaxException" type="URISyntaxException" />
					</exceptions>
				</method>
				<method visibility="private" name="substring" fulltype="java.lang.String" type="String">
					<params>
						<param name="start" fulltype="int" type="int" />
						<param name="end" fulltype="int" type="int" />
					</params>
				</method>
				<method visibility="private" name="charAt" fulltype="char" type="char">
					<params>
						<param name="p" fulltype="int" type="int" />
					</params>
				</method>
				<method visibility="private" name="at" fulltype="boolean" type="boolean">
					<params>
						<param name="start" fulltype="int" type="int" />
						<param name="end" fulltype="int" type="int" />
						<param name="c" fulltype="char" type="char" />
					</params>
				</method>
				<method visibility="private" name="at" fulltype="boolean" type="boolean">
					<params>
						<param name="start" fulltype="int" type="int" />
						<param name="end" fulltype="int" type="int" />
						<param name="s" fulltype="java.lang.String" type="String" />
					</params>
				</method>
				<method visibility="private" name="scan" fulltype="int" type="int">
					<params>
						<param name="start" fulltype="int" type="int" />
						<param name="end" fulltype="int" type="int" />
						<param name="c" fulltype="char" type="char" />
					</params>
				</method>
				<method visibility="private" name="scan" fulltype="int" type="int">
					<params>
						<param name="start" fulltype="int" type="int" />
						<param name="end" fulltype="int" type="int" />
						<param name="err" fulltype="java.lang.String" type="String" />
						<param name="stop" fulltype="java.lang.String" type="String" />
					</params>
				</method>
				<method visibility="private" name="scanEscape" fulltype="int" type="int">
					<params>
						<param name="start" fulltype="int" type="int" />
						<param name="n" fulltype="int" type="int" />
						<param name="first" fulltype="char" type="char" />
					</params>
					<exceptions>
						<exception fulltype="java.net.URISyntaxException" type="URISyntaxException" />
					</exceptions>
				</method>
				<method visibility="private" name="scan" fulltype="int" type="int">
					<params>
						<param name="start" fulltype="int" type="int" />
						<param name="n" fulltype="int" type="int" />
						<param name="lowMask" fulltype="long" type="long" />
						<param name="highMask" fulltype="long" type="long" />
					</params>
					<exceptions>
						<exception fulltype="java.net.URISyntaxException" type="URISyntaxException" />
					</exceptions>
				</method>
				<method visibility="private" name="checkChars" fulltype="void" type="void">
					<params>
						<param name="start" fulltype="int" type="int" />
						<param name="end" fulltype="int" type="int" />
						<param name="lowMask" fulltype="long" type="long" />
						<param name="highMask" fulltype="long" type="long" />
						<param name="what" fulltype="java.lang.String" type="String" />
					</params>
					<exceptions>
						<exception fulltype="java.net.URISyntaxException" type="URISyntaxException" />
					</exceptions>
				</method>
				<method visibility="private" name="checkChar" fulltype="void" type="void">
					<params>
						<param name="p" fulltype="int" type="int" />
						<param name="lowMask" fulltype="long" type="long" />
						<param name="highMask" fulltype="long" type="long" />
						<param name="what" fulltype="java.lang.String" type="String" />
					</params>
					<exceptions>
						<exception fulltype="java.net.URISyntaxException" type="URISyntaxException" />
					</exceptions>
				</method>
				<method visibility="package-private" name="parse" fulltype="void" type="void">
					<params>
						<param name="rsa" fulltype="boolean" type="boolean" />
					</params>
					<exceptions>
						<exception fulltype="java.net.URISyntaxException" type="URISyntaxException" />
					</exceptions>
				</method>
				<method visibility="private" name="parseHierarchical" fulltype="int" type="int">
					<params>
						<param name="start" fulltype="int" type="int" />
						<param name="n" fulltype="int" type="int" />
					</params>
					<exceptions>
						<exception fulltype="java.net.URISyntaxException" type="URISyntaxException" />
					</exceptions>
				</method>
				<method visibility="private" name="parseAuthority" fulltype="int" type="int">
					<params>
						<param name="start" fulltype="int" type="int" />
						<param name="n" fulltype="int" type="int" />
					</params>
					<exceptions>
						<exception fulltype="java.net.URISyntaxException" type="URISyntaxException" />
					</exceptions>
				</method>
				<method visibility="private" name="parseServer" fulltype="int" type="int">
					<params>
						<param name="start" fulltype="int" type="int" />
						<param name="n" fulltype="int" type="int" />
					</params>
					<exceptions>
						<exception fulltype="java.net.URISyntaxException" type="URISyntaxException" />
					</exceptions>
				</method>
				<method visibility="private" name="scanByte" fulltype="int" type="int">
					<params>
						<param name="start" fulltype="int" type="int" />
						<param name="n" fulltype="int" type="int" />
					</params>
					<exceptions>
						<exception fulltype="java.net.URISyntaxException" type="URISyntaxException" />
					</exceptions>
				</method>
				<method visibility="private" name="scanIPv4Address" fulltype="int" type="int">
					<params>
						<param name="start" fulltype="int" type="int" />
						<param name="n" fulltype="int" type="int" />
						<param name="strict" fulltype="boolean" type="boolean" />
					</params>
					<exceptions>
						<exception fulltype="java.net.URISyntaxException" type="URISyntaxException" />
					</exceptions>
				</method>
				<method visibility="private" name="takeIPv4Address" fulltype="int" type="int">
					<params>
						<param name="start" fulltype="int" type="int" />
						<param name="n" fulltype="int" type="int" />
						<param name="expected" fulltype="java.lang.String" type="String" />
					</params>
					<exceptions>
						<exception fulltype="java.net.URISyntaxException" type="URISyntaxException" />
					</exceptions>
				</method>
				<method visibility="private" name="parseIPv4Address" fulltype="int" type="int">
					<params>
						<param name="start" fulltype="int" type="int" />
						<param name="n" fulltype="int" type="int" />
					</params>
				</method>
				<method visibility="private" name="parseHostname" fulltype="int" type="int">
					<params>
						<param name="start" fulltype="int" type="int" />
						<param name="n" fulltype="int" type="int" />
					</params>
					<exceptions>
						<exception fulltype="java.net.URISyntaxException" type="URISyntaxException" />
					</exceptions>
				</method>
				<method visibility="private" name="parseIPv6Reference" fulltype="int" type="int">
					<params>
						<param name="start" fulltype="int" type="int" />
						<param name="n" fulltype="int" type="int" />
					</params>
					<exceptions>
						<exception fulltype="java.net.URISyntaxException" type="URISyntaxException" />
					</exceptions>
				</method>
				<method visibility="private" name="scanHexPost" fulltype="int" type="int">
					<params>
						<param name="start" fulltype="int" type="int" />
						<param name="n" fulltype="int" type="int" />
					</params>
					<exceptions>
						<exception fulltype="java.net.URISyntaxException" type="URISyntaxException" />
					</exceptions>
				</method>
				<method visibility="private" name="scanHexSeq" fulltype="int" type="int">
					<params>
						<param name="start" fulltype="int" type="int" />
						<param name="n" fulltype="int" type="int" />
					</params>
					<exceptions>
						<exception fulltype="java.net.URISyntaxException" type="URISyntaxException" />
					</exceptions>
				</method>
			</methods>
		</jelclass>
	</jelclass>
	<jelclass superclass="Object" visibility="private" package="java.net" superclassfulltype="java.lang.Object" fulltype="java.net.URI.Parser" type="URI.Parser">
		<fields>
			<field visibility="private" name="input" fulltype="java.lang.String" type="String" />
			<field visibility="private" name="requireServerAuthority" fulltype="boolean" type="boolean" />
			<field visibility="private" name="ipv6byteCount" fulltype="int" type="int" />
		</fields>
		<methods>
			<constructor visibility="package-private" name="URI.Parser">
				<params>
					<param name="s" fulltype="java.lang.String" type="String" />
				</params>
			</constructor>
			<method visibility="private" name="fail" fulltype="void" type="void">
				<params>
					<param name="reason" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception fulltype="java.net.URISyntaxException" type="URISyntaxException" />
				</exceptions>
			</method>
			<method visibility="private" name="fail" fulltype="void" type="void">
				<params>
					<param name="reason" fulltype="java.lang.String" type="String" />
					<param name="p" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.net.URISyntaxException" type="URISyntaxException" />
				</exceptions>
			</method>
			<method visibility="private" name="failExpecting" fulltype="void" type="void">
				<params>
					<param name="expected" fulltype="java.lang.String" type="String" />
					<param name="p" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.net.URISyntaxException" type="URISyntaxException" />
				</exceptions>
			</method>
			<method visibility="private" name="failExpecting" fulltype="void" type="void">
				<params>
					<param name="expected" fulltype="java.lang.String" type="String" />
					<param name="prior" fulltype="java.lang.String" type="String" />
					<param name="p" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.net.URISyntaxException" type="URISyntaxException" />
				</exceptions>
			</method>
			<method visibility="private" name="substring" fulltype="java.lang.String" type="String">
				<params>
					<param name="start" fulltype="int" type="int" />
					<param name="end" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="private" name="charAt" fulltype="char" type="char">
				<params>
					<param name="p" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="private" name="at" fulltype="boolean" type="boolean">
				<params>
					<param name="start" fulltype="int" type="int" />
					<param name="end" fulltype="int" type="int" />
					<param name="c" fulltype="char" type="char" />
				</params>
			</method>
			<method visibility="private" name="at" fulltype="boolean" type="boolean">
				<params>
					<param name="start" fulltype="int" type="int" />
					<param name="end" fulltype="int" type="int" />
					<param name="s" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="private" name="scan" fulltype="int" type="int">
				<params>
					<param name="start" fulltype="int" type="int" />
					<param name="end" fulltype="int" type="int" />
					<param name="c" fulltype="char" type="char" />
				</params>
			</method>
			<method visibility="private" name="scan" fulltype="int" type="int">
				<params>
					<param name="start" fulltype="int" type="int" />
					<param name="end" fulltype="int" type="int" />
					<param name="err" fulltype="java.lang.String" type="String" />
					<param name="stop" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="private" name="scanEscape" fulltype="int" type="int">
				<params>
					<param name="start" fulltype="int" type="int" />
					<param name="n" fulltype="int" type="int" />
					<param name="first" fulltype="char" type="char" />
				</params>
				<exceptions>
					<exception fulltype="java.net.URISyntaxException" type="URISyntaxException" />
				</exceptions>
			</method>
			<method visibility="private" name="scan" fulltype="int" type="int">
				<params>
					<param name="start" fulltype="int" type="int" />
					<param name="n" fulltype="int" type="int" />
					<param name="lowMask" fulltype="long" type="long" />
					<param name="highMask" fulltype="long" type="long" />
				</params>
				<exceptions>
					<exception fulltype="java.net.URISyntaxException" type="URISyntaxException" />
				</exceptions>
			</method>
			<method visibility="private" name="checkChars" fulltype="void" type="void">
				<params>
					<param name="start" fulltype="int" type="int" />
					<param name="end" fulltype="int" type="int" />
					<param name="lowMask" fulltype="long" type="long" />
					<param name="highMask" fulltype="long" type="long" />
					<param name="what" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception fulltype="java.net.URISyntaxException" type="URISyntaxException" />
				</exceptions>
			</method>
			<method visibility="private" name="checkChar" fulltype="void" type="void">
				<params>
					<param name="p" fulltype="int" type="int" />
					<param name="lowMask" fulltype="long" type="long" />
					<param name="highMask" fulltype="long" type="long" />
					<param name="what" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception fulltype="java.net.URISyntaxException" type="URISyntaxException" />
				</exceptions>
			</method>
			<method visibility="package-private" name="parse" fulltype="void" type="void">
				<params>
					<param name="rsa" fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception fulltype="java.net.URISyntaxException" type="URISyntaxException" />
				</exceptions>
			</method>
			<method visibility="private" name="parseHierarchical" fulltype="int" type="int">
				<params>
					<param name="start" fulltype="int" type="int" />
					<param name="n" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.net.URISyntaxException" type="URISyntaxException" />
				</exceptions>
			</method>
			<method visibility="private" name="parseAuthority" fulltype="int" type="int">
				<params>
					<param name="start" fulltype="int" type="int" />
					<param name="n" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.net.URISyntaxException" type="URISyntaxException" />
				</exceptions>
			</method>
			<method visibility="private" name="parseServer" fulltype="int" type="int">
				<params>
					<param name="start" fulltype="int" type="int" />
					<param name="n" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.net.URISyntaxException" type="URISyntaxException" />
				</exceptions>
			</method>
			<method visibility="private" name="scanByte" fulltype="int" type="int">
				<params>
					<param name="start" fulltype="int" type="int" />
					<param name="n" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.net.URISyntaxException" type="URISyntaxException" />
				</exceptions>
			</method>
			<method visibility="private" name="scanIPv4Address" fulltype="int" type="int">
				<params>
					<param name="start" fulltype="int" type="int" />
					<param name="n" fulltype="int" type="int" />
					<param name="strict" fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception fulltype="java.net.URISyntaxException" type="URISyntaxException" />
				</exceptions>
			</method>
			<method visibility="private" name="takeIPv4Address" fulltype="int" type="int">
				<params>
					<param name="start" fulltype="int" type="int" />
					<param name="n" fulltype="int" type="int" />
					<param name="expected" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception fulltype="java.net.URISyntaxException" type="URISyntaxException" />
				</exceptions>
			</method>
			<method visibility="private" name="parseIPv4Address" fulltype="int" type="int">
				<params>
					<param name="start" fulltype="int" type="int" />
					<param name="n" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="private" name="parseHostname" fulltype="int" type="int">
				<params>
					<param name="start" fulltype="int" type="int" />
					<param name="n" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.net.URISyntaxException" type="URISyntaxException" />
				</exceptions>
			</method>
			<method visibility="private" name="parseIPv6Reference" fulltype="int" type="int">
				<params>
					<param name="start" fulltype="int" type="int" />
					<param name="n" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.net.URISyntaxException" type="URISyntaxException" />
				</exceptions>
			</method>
			<method visibility="private" name="scanHexPost" fulltype="int" type="int">
				<params>
					<param name="start" fulltype="int" type="int" />
					<param name="n" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.net.URISyntaxException" type="URISyntaxException" />
				</exceptions>
			</method>
			<method visibility="private" name="scanHexSeq" fulltype="int" type="int">
				<params>
					<param name="start" fulltype="int" type="int" />
					<param name="n" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.net.URISyntaxException" type="URISyntaxException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass abstract="true" superclass="Object" visibility="public" package="java.net" serializable="true" superclassfulltype="java.lang.Object" fulltype="java.net.SocketAddress" type="SocketAddress">
		<implements>
			<interface fulltype="java.io.Serializable" type="Serializable" />
		</implements>
		<comment>
			<description>This class represents a Socket Address with no protocol attachment.
 As an abstract class, it is meant to be subclassed with a specific,
 protocol dependent, implementation.
 &lt;p&gt;
 It provides an immutable object used by sockets for binding, connecting, or
 as returned values.</description>
			<attribute name="@see">
				<description>java.net.Socket</description>
			</attribute>
			<attribute name="@see">
				<description>java.net.ServerSocket</description>
			</attribute>
			<attribute name="@since">
				<description>1.4</description>
			</attribute>
		</comment>
		<methods>
			<constructor visibility="public" name="SocketAddress" />
		</methods>
	</jelclass>
	<jelclass superclass="SocketException" visibility="public" package="java.net" serializable="true" superclassfulltype="java.net.SocketException" fulltype="java.net.NoRouteToHostException" type="NoRouteToHostException">
		<comment>
			<description>Signals that an error occurred while attempting to connect a
 socket to a remote address and port.  Typically, the remote
 host cannot be reached because of an intervening firewall, or
 if an intermediate router is down.</description>
			<attribute name="@since">
				<description>JDK1.1</description>
			</attribute>
		</comment>
		<methods>
			<constructor visibility="public" name="NoRouteToHostException">
				<comment>
					<description>Constructs a new NoRouteToHostException with the specified detail
 message as to why the remote host cannot be reached.
 A detail message is a String that gives a specific
 description of this error.</description>
					<attribute name="@param">
						<description>msg the detail message</description>
					</attribute>
				</comment>
				<params>
					<param name="msg" comment="the detail message" fulltype="java.lang.String" type="String" />
				</params>
			</constructor>
			<constructor visibility="public" name="NoRouteToHostException">
				<comment>
					<description>Construct a new NoRouteToHostException with no detailed message.</description>
				</comment>
			</constructor>
		</methods>
	</jelclass>
	<jelclass final="true" superclass="Object" visibility="public" package="java.net" superclassfulltype="java.lang.Object" fulltype="java.net.PasswordAuthentication" type="PasswordAuthentication">
		<comment>
			<description>The class PasswordAuthentication is a data holder that is used by
 Authenticator.  It is simply a repository for a user name and a password.</description>
			<attribute name="@see">
				<description>java.net.Authenticator</description>
			</attribute>
			<attribute name="@see">
				<description>java.net.Authenticator#getPasswordAuthentication()</description>
			</attribute>
			<attribute name="@author">
				<description>Bill Foote</description>
			</attribute>
			<attribute name="@since">
				<description>1.2</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="private" name="userName" fulltype="java.lang.String" type="String" />
			<field visibility="private" name="password" fulltype="char[]" type="char" />
		</fields>
		<methods>
			<constructor visibility="public" name="PasswordAuthentication">
				<comment>
					<description>Creates a new &lt;code&gt;PasswordAuthentication&lt;/code&gt; object from the given
 user name and password.

 &lt;p&gt; Note that the given user password is cloned before it is stored in
 the new &lt;code&gt;PasswordAuthentication&lt;/code&gt; object.</description>
					<attribute name="@param">
						<description>userName the user name</description>
					</attribute>
					<attribute name="@param">
						<description>password the user&apos;s password</description>
					</attribute>
				</comment>
				<params>
					<param name="userName" comment="the user name" fulltype="java.lang.String" type="String" />
					<param name="password" comment="the user&apos;s password" fulltype="char[]" type="char" />
				</params>
			</constructor>
			<method visibility="public" name="getUserName" returncomment="the user name" fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the user name.</description>
					<attribute name="@return">
						<description>the user name</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getPassword" returncomment="the password" fulltype="char[]" type="char">
				<comment>
					<description>Returns the user password.

 &lt;p&gt; Note that this method returns a reference to the password. It is
 the caller&apos;s responsibility to zero out the password information after
 it is no longer needed.</description>
					<attribute name="@return">
						<description>the password</description>
					</attribute>
				</comment>
			</method>
		</methods>
	</jelclass>
	<jelclass abstract="true" superclass="Object" visibility="public" package="java.net" superclassfulltype="java.lang.Object" fulltype="java.net.ProxySelector" type="ProxySelector">
		<comment>
			<description>Selects the proxy server to use, if any, when connecting to the
 network resource referenced by a URL. A proxy selector is a
 concrete sub-class of this class and is registered by invoking the
 {@link java.net.ProxySelector#setDefault setDefault} method. The
 currently registered proxy selector can be retrieved by calling
 {@link java.net.ProxySelector#getDefault getDefault} method.

 &lt;p&gt; When a proxy selector is registered, for instance, a subclass
 of URLConnection class should call the {@link #select select}
 method for each URL request so that the proxy selector can decide
 if a direct, or proxied connection should be used. The {@link
 #select select} method returns an iterator over a collection with
 the preferred connection approach.

 &lt;p&gt; If a connection cannot be established to a proxy (PROXY or
 SOCKS) servers then the caller should call the proxy selector&apos;s
 {@link #connectFailed connectFailed} method to notify the proxy
 selector that the proxy server is unavailable. &lt;/p&gt;</description>
			<attribute name="@author">
				<description>Yingxian Wang</description>
			</attribute>
			<attribute name="@author">
				<description>Jean-Christophe Collet</description>
			</attribute>
			<attribute name="@since">
				<description>1.5</description>
			</attribute>
		</comment>
		<fields>
			<field static="true" visibility="private" name="theProxySelector" fulltype="java.net.ProxySelector" type="ProxySelector">
				<comment>
					<description>The system wide proxy selector that selects the proxy server to
 use, if any, when connecting to a remote object referenced by
 an URL.</description>
					<attribute name="@see">
						<description>#setDefault(ProxySelector)</description>
					</attribute>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="public" name="ProxySelector" />
			<method static="true" visibility="public" name="getDefault" returncomment="the system-wide &lt;code&gt;ProxySelector&lt;/code&gt;" fulltype="java.net.ProxySelector" type="ProxySelector">
				<comment>
					<description>Gets the system-wide proxy selector.</description>
					<attribute name="@throws">
						<description>SecurityException
          If a security manager has been installed and it denies
 {@link NetPermission}&lt;tt&gt;(&quot;getProxySelector&quot;)&lt;/tt&gt;</description>
					</attribute>
					<attribute name="@see">
						<description>#setDefault(ProxySelector)</description>
					</attribute>
					<attribute name="@return">
						<description>the system-wide &lt;code&gt;ProxySelector&lt;/code&gt;</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
			</method>
			<method static="true" visibility="public" name="setDefault" fulltype="void" type="void">
				<comment>
					<description>Sets (or unsets) the system-wide proxy selector.

 Note: non-standard protocol handlers may ignore this setting.</description>
					<attribute name="@param">
						<description>ps The HTTP proxy selector, or
          &lt;code&gt;null&lt;/code&gt; to unset the proxy selector.</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException
          If a security manager has been installed and it denies
 {@link NetPermission}&lt;tt&gt;(&quot;setProxySelector&quot;)&lt;/tt&gt;</description>
					</attribute>
					<attribute name="@see">
						<description>#getDefault()</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
				<params>
					<param name="ps" comment="The HTTP proxy selector, or
          &lt;code&gt;null&lt;/code&gt; to unset the proxy selector." fulltype="java.net.ProxySelector" type="ProxySelector" />
				</params>
			</method>
			<method abstract="true" visibility="public" name="select" returncomment="a List of Proxies. Each element in the
          the List is of type
          {@link java.net.Proxy Proxy};
          when no proxy is available, the list will
          contain one element of type
          {@link java.net.Proxy Proxy}
          that represents a direct connection." fulltype="java.util.List" type="List">
				<comment>
					<description>Selects all the applicable proxies based on the protocol to
 access the resource with and a destination address to access
 the resource at.
 The format of the URI is defined as follow:
 &lt;UL&gt;
 &lt;LI&gt;http URI for http connections&lt;/LI&gt;
 &lt;LI&gt;https URI for https connections
 &lt;LI&gt;ftp URI for ftp connections&lt;/LI&gt;
 &lt;LI&gt;&lt;code&gt;socket://host:port&lt;/code&gt;&lt;br&gt;
     for tcp client sockets connections&lt;/LI&gt;
 &lt;/UL&gt;</description>
					<attribute name="@param">
						<description>uri
          The URI that a connection is required to</description>
					</attribute>
					<attribute name="@return">
						<description>a List of Proxies. Each element in the
          the List is of type
          {@link java.net.Proxy Proxy};
          when no proxy is available, the list will
          contain one element of type
          {@link java.net.Proxy Proxy}
          that represents a direct connection.</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if the argument is null</description>
					</attribute>
				</comment>
				<params>
					<param name="uri" comment="The URI that a connection is required to" fulltype="java.net.URI" type="URI" />
				</params>
			</method>
			<method abstract="true" visibility="public" name="connectFailed" fulltype="void" type="void">
				<comment>
					<description>Called to indicate that a connection could not be established
 to a proxy/socks server. An implementation of this method can
 temporarily remove the proxies or reorder the sequence of
 proxies returned by {@link #select(URI)}, using the address
 and the IOException caught when trying to connect.</description>
					<attribute name="@param">
						<description>uri
          The URI that the proxy at sa failed to serve.</description>
					</attribute>
					<attribute name="@param">
						<description>sa
          The socket address of the proxy/SOCKS server</description>
					</attribute>
					<attribute name="@param">
						<description>ioe
          The I/O exception thrown when the connect failed.</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if either argument is null</description>
					</attribute>
				</comment>
				<params>
					<param name="uri" comment="The URI that the proxy at sa failed to serve." fulltype="java.net.URI" type="URI" />
					<param name="sa" comment="The socket address of the proxy/SOCKS server" fulltype="java.net.SocketAddress" type="SocketAddress" />
					<param name="ioe" comment="The I/O exception thrown when the connect failed." fulltype="java.io.IOException" type="IOException" />
				</params>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="Object" visibility="public" package="java.net" superclassfulltype="java.lang.Object" fulltype="java.net.InterfaceAddress" type="InterfaceAddress">
		<comment>
			<description>This class represents a Network Interface address. In short it&apos;s an
 IP address, a subnet mask and a broadcast address when the address is
 an IPv4 one. An IP address and a network prefix length in the case
 of IPv6 address.</description>
			<attribute name="@see">
				<description>java.net.NetworkInterface</description>
			</attribute>
			<attribute name="@since">
				<description>1.6</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="private" name="address" fulltype="java.net.InetAddress" type="InetAddress" />
			<field visibility="private" name="broadcast" fulltype="java.net.Inet4Address" type="Inet4Address" />
			<field visibility="private" name="maskLength" fulltype="short" type="short" />
		</fields>
		<methods>
			<constructor visibility="package-private" name="InterfaceAddress" />
			<method visibility="public" name="getAddress" returncomment="the &lt;code&gt;InetAddress&lt;/code&gt; for this address." fulltype="java.net.InetAddress" type="InetAddress">
				<comment>
					<description>Returns an &lt;code&gt;InetAddress&lt;/code&gt; for this address.</description>
					<attribute name="@return">
						<description>the &lt;code&gt;InetAddress&lt;/code&gt; for this address.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getBroadcast" returncomment="the &lt;code&gt;InetAddress&lt;/code&gt; representing the broadcast
         address or &lt;code&gt;null&lt;/code&gt; if there is no broadcast address." fulltype="java.net.InetAddress" type="InetAddress">
				<comment>
					<description>Returns an &lt;code&gt;InetAddress&lt;/code&gt; for the brodcast address
 for this InterfaceAddress.
 &lt;p&gt;
 Only IPv4 networks have broadcast address therefore, in the case
 of an IPv6 network, &lt;code&gt;null&lt;/code&gt; will be returned.</description>
					<attribute name="@return">
						<description>the &lt;code&gt;InetAddress&lt;/code&gt; representing the broadcast
         address or &lt;code&gt;null&lt;/code&gt; if there is no broadcast address.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getNetworkPrefixLength" returncomment="a &lt;code&gt;short&lt;/code&gt; representing the prefix length for the
         subnet of that address." fulltype="short" type="short">
				<comment>
					<description>Returns the network prefix length for this address. This is also known
 as the subnet mask in the context of IPv4 addresses.
 Typical IPv4 values would be 8 (255.0.0.0), 16 (255.255.0.0)
 or 24 (255.255.255.0). &lt;p&gt;
 Typical IPv6 values would be 128 (::1/128) or 10 (fe80::203:baff:fe27:1243/10)</description>
					<attribute name="@return">
						<description>a &lt;code&gt;short&lt;/code&gt; representing the prefix length for the
         subnet of that address.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="equals" returncomment="&lt;code&gt;true&lt;/code&gt; if the objects are the same;
          &lt;code&gt;false&lt;/code&gt; otherwise." fulltype="boolean" type="boolean">
				<comment>
					<description>Compares this object against the specified object.
 The result is &lt;code&gt;true&lt;/code&gt; if and only if the argument is
 not &lt;code&gt;null&lt;/code&gt; and it represents the same interface address as
 this object.
 &lt;p&gt;
 Two instances of &lt;code&gt;InterfaceAddress&lt;/code&gt; represent the same
 address if the InetAddress, the prefix length and the broadcast are
 the same for both.</description>
					<attribute name="@param">
						<description>obj   the object to compare against.</description>
					</attribute>
					<attribute name="@return">
						<description>&lt;code&gt;true&lt;/code&gt; if the objects are the same;
          &lt;code&gt;false&lt;/code&gt; otherwise.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.InterfaceAddress#hashCode()</description>
					</attribute>
				</comment>
				<params>
					<param name="obj" comment="the object to compare against." fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method visibility="public" name="hashCode" returncomment="a hash code value for this Interface address." fulltype="int" type="int">
				<comment>
					<description>Returns a hashcode for this Interface address.</description>
					<attribute name="@return">
						<description>a hash code value for this Interface address.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="toString" returncomment="a string representation of this Interface address." fulltype="java.lang.String" type="String">
				<comment>
					<description>Converts this Interface address to a &lt;code&gt;String&lt;/code&gt;. The
 string returned is of the form: InetAddress / prefix length [ broadcast address ].</description>
					<attribute name="@return">
						<description>a string representation of this Interface address.</description>
					</attribute>
				</comment>
			</method>
		</methods>
	</jelclass>
	<jelclass abstract="true" visibility="public" package="java.net" interface="true" fulltype="java.net.SocketImplFactory" type="SocketImplFactory">
		<comment>
			<description>This interface defines a factory for socket implementations. It
 is used by the classes &lt;code&gt;Socket&lt;/code&gt; and
 &lt;code&gt;ServerSocket&lt;/code&gt; to create actual socket
 implementations.</description>
			<attribute name="@author">
				<description>Arthur van Hoff</description>
			</attribute>
			<attribute name="@see">
				<description>java.net.Socket</description>
			</attribute>
			<attribute name="@see">
				<description>java.net.ServerSocket</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.0</description>
			</attribute>
		</comment>
		<methods>
			<method visibility="public" name="createSocketImpl" returncomment="a new instance of &lt;code&gt;SocketImpl&lt;/code&gt;." fulltype="java.net.SocketImpl" type="SocketImpl">
				<comment>
					<description>Creates a new &lt;code&gt;SocketImpl&lt;/code&gt; instance.</description>
					<attribute name="@return">
						<description>a new instance of &lt;code&gt;SocketImpl&lt;/code&gt;.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.SocketImpl</description>
					</attribute>
				</comment>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="FileOutputStream" visibility="package-private" package="java.net" superclassfulltype="java.io.FileOutputStream" fulltype="java.net.SocketOutputStream" type="SocketOutputStream">
		<comment>
			<description>This stream extends FileOutputStream to implement a
 SocketOutputStream. Note that this class should &lt;b&gt;NOT&lt;/b&gt; be
 public.</description>
			<attribute name="@author">
				<description>Jonathan Payne</description>
			</attribute>
			<attribute name="@author">
				<description>Arthur van Hoff</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="private" name="impl" fulltype="java.net.AbstractPlainSocketImpl" type="AbstractPlainSocketImpl" />
			<field visibility="private" name="temp" fulltype="byte[]" type="byte" />
			<field visibility="private" name="socket" fulltype="java.net.Socket" type="Socket" />
			<field visibility="private" name="closing" fulltype="boolean" type="boolean">
				<comment>
					<description>Closes the stream.</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="package-private" name="SocketOutputStream">
				<comment>
					<description>Creates a new SocketOutputStream. Can only be called
 by a Socket. This method needs to hang on to the owner Socket so
 that the fd will not be closed.</description>
					<attribute name="@param">
						<description>impl the socket output stream inplemented</description>
					</attribute>
				</comment>
				<params>
					<param name="impl" comment="the socket output stream inplemented" fulltype="java.net.AbstractPlainSocketImpl" type="AbstractPlainSocketImpl" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</constructor>
			<method final="true" visibility="public" name="getChannel" returncomment="the file channel associated with this file output stream" fulltype="java.nio.channels.FileChannel" type="FileChannel">
				<comment>
					<description>Returns the unique {@link java.nio.channels.FileChannel FileChannel}
 object associated with this file output stream. &lt;/p&gt;

 The &lt;code&gt;getChannel&lt;/code&gt; method of &lt;code&gt;SocketOutputStream&lt;/code&gt;
 returns &lt;code&gt;null&lt;/code&gt; since it is a socket based stream.&lt;/p&gt;</description>
					<attribute name="@return">
						<description>the file channel associated with this file output stream</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
					<attribute name="@spec">
						<description>JSR-51</description>
					</attribute>
				</comment>
			</method>
			<method visibility="private" name="socketWrite0" fulltype="void" type="void">
				<comment>
					<description>Writes to the socket.</description>
					<attribute name="@param">
						<description>fd the FileDescriptor</description>
					</attribute>
					<attribute name="@param">
						<description>b the data to be written</description>
					</attribute>
					<attribute name="@param">
						<description>off the start offset in the data</description>
					</attribute>
					<attribute name="@param">
						<description>len the number of bytes that are written</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException If an I/O error has occurred.</description>
					</attribute>
				</comment>
				<params>
					<param name="fd" comment="the FileDescriptor" fulltype="java.io.FileDescriptor" type="FileDescriptor" />
					<param name="b" comment="the data to be written" fulltype="byte[]" type="byte" />
					<param name="off" comment="the start offset in the data" fulltype="int" type="int" />
					<param name="len" comment="the number of bytes that are written" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="If an I/O error has occurred." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="socketWrite" fulltype="void" type="void">
				<comment>
					<description>Writes to the socket with appropriate locking of the
 FileDescriptor.</description>
					<attribute name="@param">
						<description>b the data to be written</description>
					</attribute>
					<attribute name="@param">
						<description>off the start offset in the data</description>
					</attribute>
					<attribute name="@param">
						<description>len the number of bytes that are written</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException If an I/O error has occurred.</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the data to be written" fulltype="byte[]" type="byte" />
					<param name="off" comment="the start offset in the data" fulltype="int" type="int" />
					<param name="len" comment="the number of bytes that are written" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="If an I/O error has occurred." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes a byte to the socket.</description>
					<attribute name="@param">
						<description>b the data to be written</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException If an I/O error has occurred.</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the data to be written" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="If an I/O error has occurred." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes the contents of the buffer &lt;i&gt;b&lt;/i&gt; to the socket.</description>
					<attribute name="@param">
						<description>b the data to be written</description>
					</attribute>
					<attribute name="@exception">
						<description>SocketException If an I/O error has occurred.</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the data to be written" fulltype="byte[]" type="byte" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes &lt;i&gt;length&lt;/i&gt; bytes from buffer &lt;i&gt;b&lt;/i&gt; starting at
 offset &lt;i&gt;len&lt;/i&gt;.</description>
					<attribute name="@param">
						<description>b the data to be written</description>
					</attribute>
					<attribute name="@param">
						<description>off the start offset in the data</description>
					</attribute>
					<attribute name="@param">
						<description>len the number of bytes that are written</description>
					</attribute>
					<attribute name="@exception">
						<description>SocketException If an I/O error has occurred.</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the data to be written" fulltype="byte[]" type="byte" />
					<param name="off" comment="the start offset in the data" fulltype="int" type="int" />
					<param name="len" comment="the number of bytes that are written" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="close" fulltype="void" type="void">
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="protected" name="finalize" fulltype="void" type="void">
				<comment>
					<description>Overrides finalize, the fd is closed by the Socket.</description>
				</comment>
			</method>
			<method static="true" visibility="private" name="init" fulltype="void" type="void">
				<comment>
					<description>Perform class load-time initializations.</description>
				</comment>
			</method>
		</methods>
	</jelclass>
	<jelclass abstract="true" superclass="CacheResponse" visibility="public" package="java.net" superclassfulltype="java.net.CacheResponse" fulltype="java.net.SecureCacheResponse" type="SecureCacheResponse">
		<comment>
			<description>Represents a cache response originally retrieved through secure
 means, such as TLS.</description>
			<attribute name="@since">
				<description>1.5</description>
			</attribute>
		</comment>
		<methods>
			<constructor visibility="public" name="SecureCacheResponse" />
			<method abstract="true" visibility="public" name="getCipherSuite" returncomment="a string representing the cipher suite" fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the cipher suite in use on the original connection that
 retrieved the network resource.</description>
					<attribute name="@return">
						<description>a string representing the cipher suite</description>
					</attribute>
				</comment>
			</method>
			<method abstract="true" visibility="public" name="getLocalCertificateChain" returncomment="an immutable List of Certificate representing the
           certificate chain that was sent to the server. If no
           certificate chain was sent, null will be returned." fulltype="java.util.List" type="List">
				<comment>
					<description>Returns the certificate chain that were sent to the server during
 handshaking of the original connection that retrieved the
 network resource.  Note: This method is useful only
 when using certificate-based cipher suites.</description>
					<attribute name="@return">
						<description>an immutable List of Certificate representing the
           certificate chain that was sent to the server. If no
           certificate chain was sent, null will be returned.</description>
					</attribute>
					<attribute name="@see">
						<description>#getLocalPrincipal()</description>
					</attribute>
				</comment>
			</method>
			<method abstract="true" visibility="public" name="getServerCertificateChain" returncomment="an immutable List of Certificate representing the server&apos;s
         certificate chain." fulltype="java.util.List" type="List">
				<comment>
					<description>Returns the server&apos;s certificate chain, which was established as
 part of defining the session in the original connection that
 retrieved the network resource, from cache.  Note: This method
 can be used only when using certificate-based cipher suites;
 using it with non-certificate-based cipher suites, such as
 Kerberos, will throw an SSLPeerUnverifiedException.</description>
					<attribute name="@return">
						<description>an immutable List of Certificate representing the server&apos;s
         certificate chain.</description>
					</attribute>
					<attribute name="@throws">
						<description>SSLPeerUnverifiedException if the peer is not verified.</description>
					</attribute>
					<attribute name="@see">
						<description>#getPeerPrincipal()</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if the peer is not verified." fulltype="javax.net.ssl.SSLPeerUnverifiedException" type="SSLPeerUnverifiedException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="public" name="getPeerPrincipal" returncomment="the server&apos;s principal. Returns an X500Principal of the
 end-entity certiticate for X509-based cipher suites, and
 KerberosPrincipal for Kerberos cipher suites." fulltype="java.security.Principal" type="Principal">
				<comment>
					<description>Returns the server&apos;s principal which was established as part of
 defining the session during the original connection that
 retrieved the network resource.</description>
					<attribute name="@return">
						<description>the server&apos;s principal. Returns an X500Principal of the
 end-entity certiticate for X509-based cipher suites, and
 KerberosPrincipal for Kerberos cipher suites.</description>
					</attribute>
					<attribute name="@throws">
						<description>SSLPeerUnverifiedException if the peer was not verified.</description>
					</attribute>
					<attribute name="@see">
						<description>#getServerCertificateChain()</description>
					</attribute>
					<attribute name="@see">
						<description>#getLocalPrincipal()</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if the peer was not verified." fulltype="javax.net.ssl.SSLPeerUnverifiedException" type="SSLPeerUnverifiedException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="public" name="getLocalPrincipal" returncomment="the principal sent to the server. Returns an X500Principal
 of the end-entity certificate for X509-based cipher suites, and
 KerberosPrincipal for Kerberos cipher suites. If no principal was
 sent, then null is returned." fulltype="java.security.Principal" type="Principal">
				<comment>
					<description>Returns the principal that was sent to the server during
 handshaking in the original connection that retrieved the
 network resource.</description>
					<attribute name="@return">
						<description>the principal sent to the server. Returns an X500Principal
 of the end-entity certificate for X509-based cipher suites, and
 KerberosPrincipal for Kerberos cipher suites. If no principal was
 sent, then null is returned.</description>
					</attribute>
					<attribute name="@see">
						<description>#getLocalCertificateChain()</description>
					</attribute>
					<attribute name="@see">
						<description>#getPeerPrincipal()</description>
					</attribute>
				</comment>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="FileInputStream" visibility="package-private" package="java.net" superclassfulltype="java.io.FileInputStream" fulltype="java.net.SocketInputStream" type="SocketInputStream">
		<comment>
			<description>This stream extends FileInputStream to implement a
 SocketInputStream. Note that this class should &lt;b&gt;NOT&lt;/b&gt; be
 public.</description>
			<attribute name="@author">
				<description>Jonathan Payne</description>
			</attribute>
			<attribute name="@author">
				<description>Arthur van Hoff</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="private" name="eof" fulltype="boolean" type="boolean" />
			<field visibility="private" name="impl" fulltype="java.net.AbstractPlainSocketImpl" type="AbstractPlainSocketImpl" />
			<field visibility="private" name="temp" fulltype="byte[]" type="byte" />
			<field visibility="private" name="socket" fulltype="java.net.Socket" type="Socket" />
			<field visibility="private" name="closing" fulltype="boolean" type="boolean">
				<comment>
					<description>Closes the stream.</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="package-private" name="SocketInputStream">
				<comment>
					<description>Creates a new SocketInputStream. Can only be called
 by a Socket. This method needs to hang on to the owner Socket so
 that the fd will not be closed.</description>
					<attribute name="@param">
						<description>impl the implemented socket input stream</description>
					</attribute>
				</comment>
				<params>
					<param name="impl" comment="the implemented socket input stream" fulltype="java.net.AbstractPlainSocketImpl" type="AbstractPlainSocketImpl" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</constructor>
			<method final="true" visibility="public" name="getChannel" returncomment="the file channel associated with this file input stream" fulltype="java.nio.channels.FileChannel" type="FileChannel">
				<comment>
					<description>Returns the unique {@link java.nio.channels.FileChannel FileChannel}
 object associated with this file input stream.&lt;/p&gt;

 The &lt;code&gt;getChannel&lt;/code&gt; method of &lt;code&gt;SocketInputStream&lt;/code&gt;
 returns &lt;code&gt;null&lt;/code&gt; since it is a socket based stream.&lt;/p&gt;</description>
					<attribute name="@return">
						<description>the file channel associated with this file input stream</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
					<attribute name="@spec">
						<description>JSR-51</description>
					</attribute>
				</comment>
			</method>
			<method visibility="private" name="socketRead0" returncomment="the actual number of bytes read, -1 is
          returned when the end of the stream is reached." fulltype="int" type="int">
				<comment>
					<description>Reads into an array of bytes at the specified offset using
 the received socket primitive.</description>
					<attribute name="@param">
						<description>fd the FileDescriptor</description>
					</attribute>
					<attribute name="@param">
						<description>b the buffer into which the data is read</description>
					</attribute>
					<attribute name="@param">
						<description>off the start offset of the data</description>
					</attribute>
					<attribute name="@param">
						<description>len the maximum number of bytes read</description>
					</attribute>
					<attribute name="@param">
						<description>timeout the read timeout in ms</description>
					</attribute>
					<attribute name="@return">
						<description>the actual number of bytes read, -1 is
          returned when the end of the stream is reached.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException If an I/O error has occurred.</description>
					</attribute>
				</comment>
				<params>
					<param name="fd" comment="the FileDescriptor" fulltype="java.io.FileDescriptor" type="FileDescriptor" />
					<param name="b" comment="the buffer into which the data is read" fulltype="byte[]" type="byte" />
					<param name="off" comment="the start offset of the data" fulltype="int" type="int" />
					<param name="len" comment="the maximum number of bytes read" fulltype="int" type="int" />
					<param name="timeout" comment="the read timeout in ms" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="If an I/O error has occurred." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="read" returncomment="the actual number of bytes read, -1 is
          returned when the end of the stream is reached." fulltype="int" type="int">
				<comment>
					<description>Reads into a byte array data from the socket.</description>
					<attribute name="@param">
						<description>b the buffer into which the data is read</description>
					</attribute>
					<attribute name="@return">
						<description>the actual number of bytes read, -1 is
          returned when the end of the stream is reached.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException If an I/O error has occurred.</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the buffer into which the data is read" fulltype="byte[]" type="byte" />
				</params>
				<exceptions>
					<exception comment="If an I/O error has occurred." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="read" returncomment="the actual number of bytes read, -1 is
          returned when the end of the stream is reached." fulltype="int" type="int">
				<comment>
					<description>Reads into a byte array &lt;i&gt;b&lt;/i&gt; at offset &lt;i&gt;off&lt;/i&gt;,
 &lt;i&gt;length&lt;/i&gt; bytes of data.</description>
					<attribute name="@param">
						<description>b the buffer into which the data is read</description>
					</attribute>
					<attribute name="@param">
						<description>off the start offset of the data</description>
					</attribute>
					<attribute name="@param">
						<description>len the maximum number of bytes read</description>
					</attribute>
					<attribute name="@return">
						<description>the actual number of bytes read, -1 is
          returned when the end of the stream is reached.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException If an I/O error has occurred.</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the buffer into which the data is read" fulltype="byte[]" type="byte" />
					<param name="off" comment="the start offset of the data" fulltype="int" type="int" />
					<param name="length" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="If an I/O error has occurred." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="read" fulltype="int" type="int">
				<comment>
					<description>Reads a single byte from the socket.</description>
				</comment>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="skip" returncomment="the actual number of bytes skipped." fulltype="long" type="long">
				<comment>
					<description>Skips n bytes of input.</description>
					<attribute name="@param">
						<description>n the number of bytes to skip</description>
					</attribute>
					<attribute name="@return">
						<description>the actual number of bytes skipped.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException If an I/O error has occurred.</description>
					</attribute>
				</comment>
				<params>
					<param name="numbytes" fulltype="long" type="long" />
				</params>
				<exceptions>
					<exception comment="If an I/O error has occurred." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="available" returncomment="the number of immediately available bytes" fulltype="int" type="int">
				<comment>
					<description>Returns the number of bytes that can be read without blocking.</description>
					<attribute name="@return">
						<description>the number of immediately available bytes</description>
					</attribute>
				</comment>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="close" fulltype="void" type="void">
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="package-private" name="setEOF" fulltype="void" type="void">
				<params>
					<param name="eof" fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method visibility="protected" name="finalize" fulltype="void" type="void">
				<comment>
					<description>Overrides finalize, the fd is closed by the Socket.</description>
				</comment>
			</method>
			<method static="true" visibility="private" name="init" fulltype="void" type="void">
				<comment>
					<description>Perform class load-time initializations.</description>
				</comment>
			</method>
		</methods>
	</jelclass>
	<jelclass final="true" superclass="InetAddress" visibility="public" package="java.net" serializable="true" superclassfulltype="java.net.InetAddress" fulltype="java.net.Inet4Address" type="Inet4Address">
		<comment>
			<description>This class represents an Internet Protocol version 4 (IPv4) address.
 Defined by &lt;a href=&quot;http://www.ietf.org/rfc/rfc790.txt&quot;&gt;
 &lt;i&gt;RFC&amp;nbsp;790: Assigned Numbers&lt;/i&gt;&lt;/a&gt;,
 &lt;a href=&quot;http://www.ietf.org/rfc/rfc1918.txt&quot;&gt;
 &lt;i&gt;RFC&amp;nbsp;1918: Address Allocation for Private Internets&lt;/i&gt;&lt;/a&gt;,
 and &lt;a href=&quot;http://www.ietf.org/rfc/rfc2365.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2365:
 Administratively Scoped IP Multicast&lt;/i&gt;&lt;/a&gt;

 &lt;h4&gt; &lt;A NAME=&quot;format&quot;&gt;Textual representation of IP addresses&lt;/a&gt; &lt;/h4&gt;

 Textual representation of IPv4 address used as input to methods
 takes one of the following forms:

 &lt;blockquote&gt;&lt;table cellpadding=0 cellspacing=0 summary=&quot;layout&quot;&gt;
 &lt;tr&gt;&lt;td&gt;&lt;tt&gt;d.d.d.d&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;&lt;tt&gt;d.d.d&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;&lt;tt&gt;d.d&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;&lt;tt&gt;d&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;&lt;/blockquote&gt;

 &lt;p&gt; When four parts are specified, each is interpreted as a byte of
 data and assigned, from left to right, to the four bytes of an IPv4
 address.

 &lt;p&gt; When a three part address is specified, the last part is
 interpreted as a 16-bit quantity and placed in the right most two
 bytes of the network address. This makes the three part address
 format convenient for specifying Class B net- work addresses as
 128.net.host.

 &lt;p&gt; When a two part address is supplied, the last part is
 interpreted as a 24-bit quantity and placed in the right most three
 bytes of the network address. This makes the two part address
 format convenient for specifying Class A network addresses as
 net.host.

 &lt;p&gt; When only one part is given, the value is stored directly in
 the network address without any byte rearrangement.

 &lt;p&gt; For methods that return a textual representation as output
 value, the first form, i.e. a dotted-quad string, is used.

 &lt;h4&gt; The Scope of a Multicast Address &lt;/h4&gt;

 Historically the IPv4 TTL field in the IP header has doubled as a
 multicast scope field: a TTL of 0 means node-local, 1 means
 link-local, up through 32 means site-local, up through 64 means
 region-local, up through 128 means continent-local, and up through
 255 are global. However, the administrative scoping is preferred.
 Please refer to &lt;a href=&quot;http://www.ietf.org/rfc/rfc2365.txt&quot;&gt;
 &lt;i&gt;RFC&amp;nbsp;2365: Administratively Scoped IP Multicast&lt;/i&gt;&lt;/a&gt;</description>
			<attribute name="@since">
				<description>1.4</description>
			</attribute>
		</comment>
		<fields>
			<field final="true" static="true" const="4" visibility="package-private" name="INADDRSZ" constexpr="4" fulltype="int" type="int" />
			<field final="true" static="true" const="3286316764910316507" visibility="private" name="serialVersionUID" constexpr="3286316764910316507L" fulltype="long" type="long">
				<comment>
					<description>use serialVersionUID from InetAddress, but Inet4Address instance
  is always replaced by an InetAddress instance before being
  serialized</description>
				</comment>
			</field>
			<field final="true" static="true" const="2130706433" visibility="private" name="loopback" constexpr="2130706433" fulltype="int" type="int">
				<comment>
					<description>Utility routine to check if the InetAddress is a loopback address.</description>
					<attribute name="@return">
						<description>a &lt;code&gt;boolean&lt;/code&gt; indicating if the InetAddress is
 a loopback address; or false otherwise.</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="package-private" name="Inet4Address" />
			<constructor visibility="package-private" name="Inet4Address">
				<params>
					<param name="hostName" fulltype="java.lang.String" type="String" />
					<param name="addr" fulltype="byte[]" type="byte" />
				</params>
			</constructor>
			<constructor visibility="package-private" name="Inet4Address">
				<params>
					<param name="hostName" fulltype="java.lang.String" type="String" />
					<param name="address" fulltype="int" type="int" />
				</params>
			</constructor>
			<method visibility="private" name="writeReplace" returncomment="the alternate object to be serialized." fulltype="java.lang.Object" type="Object">
				<comment>
					<description>Replaces the object to be serialized with an InetAddress object.</description>
					<attribute name="@return">
						<description>the alternate object to be serialized.</description>
					</attribute>
					<attribute name="@throws">
						<description>ObjectStreamException if a new object replacing this
 object could not be created</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if a new object replacing this
 object could not be created" fulltype="java.io.ObjectStreamException" type="ObjectStreamException" />
				</exceptions>
			</method>
			<method visibility="public" name="isMulticastAddress" returncomment="a &lt;code&gt;boolean&lt;/code&gt; indicating if the InetAddress is
 an IP multicast address" fulltype="boolean" type="boolean">
				<comment>
					<description>Utility routine to check if the InetAddress is an
 IP multicast address. IP multicast address is a Class D
 address i.e first four bits of the address are 1110.</description>
					<attribute name="@return">
						<description>a &lt;code&gt;boolean&lt;/code&gt; indicating if the InetAddress is
 an IP multicast address</description>
					</attribute>
					<attribute name="@since">
						<description>JDK1.1</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="isAnyLocalAddress" returncomment="a &lt;code&gt;boolean&lt;/code&gt; indicating if the Inetaddress is
         a wildcard address." fulltype="boolean" type="boolean">
				<comment>
					<description>Utility routine to check if the InetAddress in a wildcard address.</description>
					<attribute name="@return">
						<description>a &lt;code&gt;boolean&lt;/code&gt; indicating if the Inetaddress is
         a wildcard address.</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="isLoopbackAddress" fulltype="boolean" type="boolean" />
			<method visibility="public" name="isLinkLocalAddress" returncomment="a &lt;code&gt;boolean&lt;/code&gt; indicating if the InetAddress is
 a link local address; or false if address is not a link local unicast address." fulltype="boolean" type="boolean">
				<comment>
					<description>Utility routine to check if the InetAddress is an link local address.</description>
					<attribute name="@return">
						<description>a &lt;code&gt;boolean&lt;/code&gt; indicating if the InetAddress is
 a link local address; or false if address is not a link local unicast address.</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="isSiteLocalAddress" returncomment="a &lt;code&gt;boolean&lt;/code&gt; indicating if the InetAddress is
 a site local address; or false if address is not a site local unicast address." fulltype="boolean" type="boolean">
				<comment>
					<description>Utility routine to check if the InetAddress is a site local address.</description>
					<attribute name="@return">
						<description>a &lt;code&gt;boolean&lt;/code&gt; indicating if the InetAddress is
 a site local address; or false if address is not a site local unicast address.</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="isMCGlobal" returncomment="a &lt;code&gt;boolean&lt;/code&gt; indicating if the address has
         is a multicast address of global scope, false if it is not
         of global scope or it is not a multicast address" fulltype="boolean" type="boolean">
				<comment>
					<description>Utility routine to check if the multicast address has global scope.</description>
					<attribute name="@return">
						<description>a &lt;code&gt;boolean&lt;/code&gt; indicating if the address has
         is a multicast address of global scope, false if it is not
         of global scope or it is not a multicast address</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="isMCNodeLocal" returncomment="a &lt;code&gt;boolean&lt;/code&gt; indicating if the address has
         is a multicast address of node-local scope, false if it is not
         of node-local scope or it is not a multicast address" fulltype="boolean" type="boolean">
				<comment>
					<description>Utility routine to check if the multicast address has node scope.</description>
					<attribute name="@return">
						<description>a &lt;code&gt;boolean&lt;/code&gt; indicating if the address has
         is a multicast address of node-local scope, false if it is not
         of node-local scope or it is not a multicast address</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="isMCLinkLocal" returncomment="a &lt;code&gt;boolean&lt;/code&gt; indicating if the address has
         is a multicast address of link-local scope, false if it is not
         of link-local scope or it is not a multicast address" fulltype="boolean" type="boolean">
				<comment>
					<description>Utility routine to check if the multicast address has link scope.</description>
					<attribute name="@return">
						<description>a &lt;code&gt;boolean&lt;/code&gt; indicating if the address has
         is a multicast address of link-local scope, false if it is not
         of link-local scope or it is not a multicast address</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="isMCSiteLocal" returncomment="a &lt;code&gt;boolean&lt;/code&gt; indicating if the address has
         is a multicast address of site-local scope, false if it is not
         of site-local scope or it is not a multicast address" fulltype="boolean" type="boolean">
				<comment>
					<description>Utility routine to check if the multicast address has site scope.</description>
					<attribute name="@return">
						<description>a &lt;code&gt;boolean&lt;/code&gt; indicating if the address has
         is a multicast address of site-local scope, false if it is not
         of site-local scope or it is not a multicast address</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="isMCOrgLocal" returncomment="a &lt;code&gt;boolean&lt;/code&gt; indicating if the address has
         is a multicast address of organization-local scope,
         false if it is not of organization-local scope
         or it is not a multicast address" fulltype="boolean" type="boolean">
				<comment>
					<description>Utility routine to check if the multicast address has organization scope.</description>
					<attribute name="@return">
						<description>a &lt;code&gt;boolean&lt;/code&gt; indicating if the address has
         is a multicast address of organization-local scope,
         false if it is not of organization-local scope
         or it is not a multicast address</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getAddress" returncomment="the raw IP address of this object." fulltype="byte[]" type="byte">
				<comment>
					<description>Returns the raw IP address of this &lt;code&gt;InetAddress&lt;/code&gt;
 object. The result is in network byte order: the highest order
 byte of the address is in &lt;code&gt;getAddress()[0]&lt;/code&gt;.</description>
					<attribute name="@return">
						<description>the raw IP address of this object.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getHostAddress" returncomment="the raw IP address in a string format." fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the IP address string in textual presentation form.</description>
					<attribute name="@return">
						<description>the raw IP address in a string format.</description>
					</attribute>
					<attribute name="@since">
						<description>JDK1.0.2</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="hashCode" returncomment="a hash code value for this IP address." fulltype="int" type="int">
				<comment>
					<description>Returns a hashcode for this IP address.</description>
					<attribute name="@return">
						<description>a hash code value for this IP address.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="equals" returncomment="&lt;code&gt;true&lt;/code&gt; if the objects are the same;
          &lt;code&gt;false&lt;/code&gt; otherwise." fulltype="boolean" type="boolean">
				<comment>
					<description>Compares this object against the specified object.
 The result is &lt;code&gt;true&lt;/code&gt; if and only if the argument is
 not &lt;code&gt;null&lt;/code&gt; and it represents the same IP address as
 this object.
 &lt;p&gt;
 Two instances of &lt;code&gt;InetAddress&lt;/code&gt; represent the same IP
 address if the length of the byte arrays returned by
 &lt;code&gt;getAddress&lt;/code&gt; is the same for both, and each of the
 array components is the same for the byte arrays.</description>
					<attribute name="@param">
						<description>obj   the object to compare against.</description>
					</attribute>
					<attribute name="@return">
						<description>&lt;code&gt;true&lt;/code&gt; if the objects are the same;
          &lt;code&gt;false&lt;/code&gt; otherwise.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.InetAddress#getAddress()</description>
					</attribute>
				</comment>
				<params>
					<param name="obj" comment="the object to compare against." fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method static="true" visibility="package-private" name="numericToTextFormat" fulltype="java.lang.String" type="String">
				<params>
					<param name="src" fulltype="byte[]" type="byte" />
				</params>
			</method>
			<method static="true" visibility="private" name="init" fulltype="void" type="void">
				<comment>
					<description>Perform class load-time initializations.</description>
				</comment>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="SocketAddress" visibility="public" package="java.net" serializable="true" superclassfulltype="java.net.SocketAddress" fulltype="java.net.InetSocketAddress" type="InetSocketAddress">
		<comment>
			<description>This class implements an IP Socket Address (IP address + port number)
 It can also be a pair (hostname + port number), in which case an attempt
 will be made to resolve the hostname. If resolution fails then the address
 is said to be &lt;I&gt;unresolved&lt;/I&gt; but can still be used on some circumstances
 like connecting through a proxy.
 &lt;p&gt;
 It provides an immutable object used by sockets for binding, connecting, or
 as returned values.
 &lt;p&gt;
 The &lt;i&gt;wildcard&lt;/i&gt; is a special local IP address. It usually means &quot;any&quot;
 and can only be used for &lt;code&gt;bind&lt;/code&gt; operations.</description>
			<attribute name="@see">
				<description>java.net.Socket</description>
			</attribute>
			<attribute name="@see">
				<description>java.net.ServerSocket</description>
			</attribute>
			<attribute name="@since">
				<description>1.4</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="private" name="hostname" fulltype="java.lang.String" type="String" />
			<field visibility="private" name="addr" fulltype="java.net.InetAddress" type="InetAddress" />
			<field visibility="private" name="port" fulltype="int" type="int" />
			<field final="true" static="true" const="5076001401234631237" visibility="private" name="serialVersionUID" constexpr="5076001401234631237L" fulltype="long" type="long" />
		</fields>
		<methods>
			<constructor visibility="private" name="InetSocketAddress" />
			<constructor visibility="public" name="InetSocketAddress">
				<comment>
					<description>Creates a socket address where the IP address is the wildcard address
 and the port number a specified value.
 &lt;p&gt;
 A valid port value is between 0 and 65535.
 A port number of &lt;code&gt;zero&lt;/code&gt; will let the system pick up an
 ephemeral port in a &lt;code&gt;bind&lt;/code&gt; operation.
 &lt;p&gt;</description>
					<attribute name="@param">
						<description>port    The port number</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if the port parameter is outside the specified
 range of valid port values.</description>
					</attribute>
				</comment>
				<params>
					<param name="port" comment="The port number" fulltype="int" type="int" />
				</params>
			</constructor>
			<constructor visibility="public" name="InetSocketAddress">
				<comment>
					<description>Creates a socket address from an IP address and a port number.
 &lt;p&gt;
 A valid port value is between 0 and 65535.
 A port number of &lt;code&gt;zero&lt;/code&gt; will let the system pick up an
 ephemeral port in a &lt;code&gt;bind&lt;/code&gt; operation.
 &lt;P&gt;
 A &lt;code&gt;null&lt;/code&gt; address will assign the &lt;i&gt;wildcard&lt;/i&gt; address.
 &lt;p&gt;</description>
					<attribute name="@param">
						<description>addr    The IP address</description>
					</attribute>
					<attribute name="@param">
						<description>port    The port number</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if the port parameter is outside the specified
 range of valid port values.</description>
					</attribute>
				</comment>
				<params>
					<param name="addr" comment="The IP address" fulltype="java.net.InetAddress" type="InetAddress" />
					<param name="port" comment="The port number" fulltype="int" type="int" />
				</params>
			</constructor>
			<constructor visibility="public" name="InetSocketAddress">
				<comment>
					<description>Creates a socket address from a hostname and a port number.
 &lt;p&gt;
 An attempt will be made to resolve the hostname into an InetAddress.
 If that attempt fails, the address will be flagged as &lt;I&gt;unresolved&lt;/I&gt;.
 &lt;p&gt;
 If there is a security manager, its &lt;code&gt;checkConnect&lt;/code&gt; method
 is called with the host name as its argument to check the permissiom
 to resolve it. This could result in a SecurityException.
 &lt;P&gt;
 A valid port value is between 0 and 65535.
 A port number of &lt;code&gt;zero&lt;/code&gt; will let the system pick up an
 ephemeral port in a &lt;code&gt;bind&lt;/code&gt; operation.
 &lt;P&gt;</description>
					<attribute name="@param">
						<description>hostname the Host name</description>
					</attribute>
					<attribute name="@param">
						<description>port    The port number</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if the port parameter is outside the range
 of valid port values, or if the hostname parameter is &lt;TT&gt;null&lt;/TT&gt;.</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException if a security manager is present and
                           permission to resolve the host name is
                           denied.</description>
					</attribute>
					<attribute name="@see">
						<description>#isUnresolved()</description>
					</attribute>
				</comment>
				<params>
					<param name="hostname" comment="the Host name" fulltype="java.lang.String" type="String" />
					<param name="port" comment="The port number" fulltype="int" type="int" />
				</params>
			</constructor>
			<method static="true" visibility="public" name="createUnresolved" returncomment="a &lt;code&gt;InetSocketAddress&lt;/code&gt; representing the unresolved
          socket address" fulltype="java.net.InetSocketAddress" type="InetSocketAddress">
				<comment>
					<description>Creates an unresolved socket address from a hostname and a port number.
 &lt;p&gt;
 No attempt will be made to resolve the hostname into an InetAddress.
 The address will be flagged as &lt;I&gt;unresolved&lt;/I&gt;.
 &lt;p&gt;
 A valid port value is between 0 and 65535.
 A port number of &lt;code&gt;zero&lt;/code&gt; will let the system pick up an
 ephemeral port in a &lt;code&gt;bind&lt;/code&gt; operation.
 &lt;P&gt;</description>
					<attribute name="@param">
						<description>host    the Host name</description>
					</attribute>
					<attribute name="@param">
						<description>port    The port number</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if the port parameter is outside
                  the range of valid port values, or if the hostname
                  parameter is &lt;TT&gt;null&lt;/TT&gt;.</description>
					</attribute>
					<attribute name="@see">
						<description>#isUnresolved()</description>
					</attribute>
					<attribute name="@return">
						<description>a &lt;code&gt;InetSocketAddress&lt;/code&gt; representing the unresolved
          socket address</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
				<params>
					<param name="host" comment="the Host name" fulltype="java.lang.String" type="String" />
					<param name="port" comment="The port number" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="private" name="readObject" fulltype="void" type="void">
				<params>
					<param name="s" fulltype="java.io.ObjectInputStream" type="ObjectInputStream" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
					<exception fulltype="java.lang.ClassNotFoundException" type="ClassNotFoundException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="getPort" returncomment="the port number." fulltype="int" type="int">
				<comment>
					<description>Gets the port number.</description>
					<attribute name="@return">
						<description>the port number.</description>
					</attribute>
				</comment>
			</method>
			<method final="true" visibility="public" name="getAddress" returncomment="the InetAdress or &lt;code&gt;null&lt;/code&gt; if it is unresolved." fulltype="java.net.InetAddress" type="InetAddress">
				<comment>
					<description>Gets the &lt;code&gt;InetAddress&lt;/code&gt;.</description>
					<attribute name="@return">
						<description>the InetAdress or &lt;code&gt;null&lt;/code&gt; if it is unresolved.</description>
					</attribute>
				</comment>
			</method>
			<method final="true" visibility="public" name="getHostName" returncomment="the hostname part of the address." fulltype="java.lang.String" type="String">
				<comment>
					<description>Gets the &lt;code&gt;hostname&lt;/code&gt;.</description>
					<attribute name="@return">
						<description>the hostname part of the address.</description>
					</attribute>
				</comment>
			</method>
			<method final="true" visibility="package-private" name="getHostString" returncomment="the hostname, or String representation of the address." fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the hostname, or the String form of the address if it
 doesn&apos;t have a hostname (it was created using a literal).
 This has the benefit of &lt;b&gt;not&lt;/b&gt; attemptimg a reverse lookup.</description>
					<attribute name="@return">
						<description>the hostname, or String representation of the address.</description>
					</attribute>
					<attribute name="@since">
						<description>1.6</description>
					</attribute>
				</comment>
			</method>
			<method final="true" visibility="public" name="isUnresolved" returncomment="&lt;code&gt;true&lt;/code&gt; if the hostname couldn&apos;t be resolved into
          an &lt;code&gt;InetAddress&lt;/code&gt;." fulltype="boolean" type="boolean">
				<comment>
					<description>Checks whether the address has been resolved or not.</description>
					<attribute name="@return">
						<description>&lt;code&gt;true&lt;/code&gt; if the hostname couldn&apos;t be resolved into
          an &lt;code&gt;InetAddress&lt;/code&gt;.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="toString" returncomment="a string representation of this object." fulltype="java.lang.String" type="String">
				<comment>
					<description>Constructs a string representation of this InetSocketAddress.
 This String is constructed by calling toString() on the InetAddress
 and concatenating the port number (with a colon). If the address
 is unresolved then the part before the colon will only contain the hostname.</description>
					<attribute name="@return">
						<description>a string representation of this object.</description>
					</attribute>
				</comment>
			</method>
			<method final="true" visibility="public" name="equals" returncomment="&lt;code&gt;true&lt;/code&gt; if the objects are the same;
          &lt;code&gt;false&lt;/code&gt; otherwise." fulltype="boolean" type="boolean">
				<comment>
					<description>Compares this object against the specified object.
 The result is &lt;code&gt;true&lt;/code&gt; if and only if the argument is
 not &lt;code&gt;null&lt;/code&gt; and it represents the same address as
 this object.
 &lt;p&gt;
 Two instances of &lt;code&gt;InetSocketAddress&lt;/code&gt; represent the same
 address if both the InetAddresses (or hostnames if it is unresolved) and port
 numbers are equal.
 If both addresses are unresolved, then the hostname &amp; the port number
 are compared.</description>
					<attribute name="@param">
						<description>obj   the object to compare against.</description>
					</attribute>
					<attribute name="@return">
						<description>&lt;code&gt;true&lt;/code&gt; if the objects are the same;
          &lt;code&gt;false&lt;/code&gt; otherwise.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.InetAddress#equals(java.lang.Object)</description>
					</attribute>
				</comment>
				<params>
					<param name="obj" comment="the object to compare against." fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method final="true" visibility="public" name="hashCode" returncomment="a hash code value for this socket address." fulltype="int" type="int">
				<comment>
					<description>Returns a hashcode for this socket address.</description>
					<attribute name="@return">
						<description>a hash code value for this socket address.</description>
					</attribute>
				</comment>
			</method>
		</methods>
	</jelclass>
	<jelclass abstract="true" superclass="Object" visibility="public" package="java.net" superclassfulltype="java.lang.Object" fulltype="java.net.Authenticator" type="Authenticator">
		<comment>
			<description>The class Authenticator represents an object that knows how to obtain
 authentication for a network connection.  Usually, it will do this
 by prompting the user for information.
 &lt;p&gt;
 Applications use this class by overriding {@link
 #getPasswordAuthentication()} in a sub-class. This method will
 typically use the various getXXX() accessor methods to get information
 about the entity requesting authentication. It must then acquire a
 username and password either by interacting with the user or through
 some other non-interactive means. The credentials are then returned
 as a {@link PasswordAuthentication} return value.
 &lt;p&gt;
 An instance of this concrete sub-class is then registered
 with the system by calling {@link #setDefault(Authenticator)}.
 When authentication is required, the system will invoke one of the
 requestPasswordAuthentication() methods which in turn will call the
 getPasswordAuthentication() method of the registered object.
 &lt;p&gt;
 All methods that request authentication have a default implementation
 that fails.</description>
			<attribute name="@see">
				<description>java.net.Authenticator#setDefault(java.net.Authenticator)</description>
			</attribute>
			<attribute name="@see">
				<description>java.net.Authenticator#getPasswordAuthentication()</description>
			</attribute>
			<attribute name="@author">
				<description>Bill Foote</description>
			</attribute>
			<attribute name="@since">
				<description>1.2</description>
			</attribute>
		</comment>
		<fields>
			<field static="true" visibility="private" name="theAuthenticator" fulltype="java.net.Authenticator" type="Authenticator" />
			<field visibility="private" name="requestingHost" fulltype="java.lang.String" type="String" />
			<field visibility="private" name="requestingSite" fulltype="java.net.InetAddress" type="InetAddress" />
			<field visibility="private" name="requestingPort" fulltype="int" type="int" />
			<field visibility="private" name="requestingProtocol" fulltype="java.lang.String" type="String" />
			<field visibility="private" name="requestingPrompt" fulltype="java.lang.String" type="String" />
			<field visibility="private" name="requestingScheme" fulltype="java.lang.String" type="String" />
			<field visibility="private" name="requestingURL" fulltype="java.net.URL" type="URL" />
			<field visibility="private" name="requestingAuthType" fulltype="java.net.Authenticator.RequestorType" type="Authenticator.RequestorType" />
		</fields>
		<methods>
			<constructor visibility="public" name="Authenticator" />
			<method visibility="private" name="reset" fulltype="void" type="void" />
			<method static="true" synchronized="true" visibility="public" name="setDefault" fulltype="void" type="void">
				<comment>
					<description>Sets the authenticator that will be used by the networking code
 when a proxy or an HTTP server asks for authentication.
 &lt;p&gt;
 First, if there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt;
 method is called with a
 &lt;code&gt;NetPermission(&quot;setDefaultAuthenticator&quot;)&lt;/code&gt; permission.
 This may result in a java.lang.SecurityException.</description>
					<attribute name="@param">
						<description>a       The authenticator to be set. If a is &lt;code&gt;null&lt;/code&gt; then
                  any previously set authenticator is removed.</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException
        if a security manager exists and its
        &lt;code&gt;checkPermission&lt;/code&gt; method doesn&apos;t allow
        setting the default authenticator.</description>
					</attribute>
					<attribute name="@see">
						<description>SecurityManager#checkPermission</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.NetPermission</description>
					</attribute>
				</comment>
				<params>
					<param name="a" comment="The authenticator to be set. If a is &lt;code&gt;null&lt;/code&gt; then
                  any previously set authenticator is removed." fulltype="java.net.Authenticator" type="Authenticator" />
				</params>
			</method>
			<method static="true" visibility="public" name="requestPasswordAuthentication" returncomment="The username/password, or null if one can&apos;t be gotten." fulltype="java.net.PasswordAuthentication" type="PasswordAuthentication">
				<comment>
					<description>Ask the authenticator that has been registered with the system
 for a password.
 &lt;p&gt;
 First, if there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt;
 method is called with a
 &lt;code&gt;NetPermission(&quot;requestPasswordAuthentication&quot;)&lt;/code&gt; permission.
 This may result in a java.lang.SecurityException.</description>
					<attribute name="@param">
						<description>addr The InetAddress of the site requesting authorization,
             or null if not known.</description>
					</attribute>
					<attribute name="@param">
						<description>port the port for the requested connection</description>
					</attribute>
					<attribute name="@param">
						<description>protocol The protocol that&apos;s requesting the connection
          ({@link java.net.Authenticator#getRequestingProtocol()})</description>
					</attribute>
					<attribute name="@param">
						<description>prompt A prompt string for the user</description>
					</attribute>
					<attribute name="@param">
						<description>scheme The authentication scheme</description>
					</attribute>
					<attribute name="@return">
						<description>The username/password, or null if one can&apos;t be gotten.</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException
        if a security manager exists and its
        &lt;code&gt;checkPermission&lt;/code&gt; method doesn&apos;t allow
        the password authentication request.</description>
					</attribute>
					<attribute name="@see">
						<description>SecurityManager#checkPermission</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.NetPermission</description>
					</attribute>
				</comment>
				<params>
					<param name="addr" comment="The InetAddress of the site requesting authorization,
             or null if not known." fulltype="java.net.InetAddress" type="InetAddress" />
					<param name="port" comment="the port for the requested connection" fulltype="int" type="int" />
					<param name="protocol" comment="The protocol that&apos;s requesting the connection
          ({@link java.net.Authenticator#getRequestingProtocol()})" fulltype="java.lang.String" type="String" />
					<param name="prompt" comment="A prompt string for the user" fulltype="java.lang.String" type="String" />
					<param name="scheme" comment="The authentication scheme" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method static="true" visibility="public" name="requestPasswordAuthentication" returncomment="The username/password, or null if one can&apos;t be gotten." fulltype="java.net.PasswordAuthentication" type="PasswordAuthentication">
				<comment>
					<description>Ask the authenticator that has been registered with the system
 for a password. This is the preferred method for requesting a password
 because the hostname can be provided in cases where the InetAddress
 is not available.
 &lt;p&gt;
 First, if there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt;
 method is called with a
 &lt;code&gt;NetPermission(&quot;requestPasswordAuthentication&quot;)&lt;/code&gt; permission.
 This may result in a java.lang.SecurityException.</description>
					<attribute name="@param">
						<description>host The hostname of the site requesting authentication.</description>
					</attribute>
					<attribute name="@param">
						<description>addr The InetAddress of the site requesting authentication,
             or null if not known.</description>
					</attribute>
					<attribute name="@param">
						<description>port the port for the requested connection.</description>
					</attribute>
					<attribute name="@param">
						<description>protocol The protocol that&apos;s requesting the connection
          ({@link java.net.Authenticator#getRequestingProtocol()})</description>
					</attribute>
					<attribute name="@param">
						<description>prompt A prompt string for the user which identifies the authentication realm.</description>
					</attribute>
					<attribute name="@param">
						<description>scheme The authentication scheme</description>
					</attribute>
					<attribute name="@return">
						<description>The username/password, or null if one can&apos;t be gotten.</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException
        if a security manager exists and its
        &lt;code&gt;checkPermission&lt;/code&gt; method doesn&apos;t allow
        the password authentication request.</description>
					</attribute>
					<attribute name="@see">
						<description>SecurityManager#checkPermission</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.NetPermission</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
				<params>
					<param name="host" comment="The hostname of the site requesting authentication." fulltype="java.lang.String" type="String" />
					<param name="addr" comment="The InetAddress of the site requesting authentication,
             or null if not known." fulltype="java.net.InetAddress" type="InetAddress" />
					<param name="port" comment="the port for the requested connection." fulltype="int" type="int" />
					<param name="protocol" comment="The protocol that&apos;s requesting the connection
          ({@link java.net.Authenticator#getRequestingProtocol()})" fulltype="java.lang.String" type="String" />
					<param name="prompt" comment="A prompt string for the user which identifies the authentication realm." fulltype="java.lang.String" type="String" />
					<param name="scheme" comment="The authentication scheme" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method static="true" visibility="public" name="requestPasswordAuthentication" returncomment="The username/password, or null if one can&apos;t be gotten." fulltype="java.net.PasswordAuthentication" type="PasswordAuthentication">
				<comment>
					<description>Ask the authenticator that has been registered with the system
 for a password.
 &lt;p&gt;
 First, if there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt;
 method is called with a
 &lt;code&gt;NetPermission(&quot;requestPasswordAuthentication&quot;)&lt;/code&gt; permission.
 This may result in a java.lang.SecurityException.</description>
					<attribute name="@param">
						<description>host The hostname of the site requesting authentication.</description>
					</attribute>
					<attribute name="@param">
						<description>addr The InetAddress of the site requesting authorization,
             or null if not known.</description>
					</attribute>
					<attribute name="@param">
						<description>port the port for the requested connection</description>
					</attribute>
					<attribute name="@param">
						<description>protocol The protocol that&apos;s requesting the connection
          ({@link java.net.Authenticator#getRequestingProtocol()})</description>
					</attribute>
					<attribute name="@param">
						<description>prompt A prompt string for the user</description>
					</attribute>
					<attribute name="@param">
						<description>scheme The authentication scheme</description>
					</attribute>
					<attribute name="@param">
						<description>url The requesting URL that caused the authentication</description>
					</attribute>
					<attribute name="@param">
						<description>reqType The type (server or proxy) of the entity requesting
              authentication.</description>
					</attribute>
					<attribute name="@return">
						<description>The username/password, or null if one can&apos;t be gotten.</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException
        if a security manager exists and its
        &lt;code&gt;checkPermission&lt;/code&gt; method doesn&apos;t allow
        the password authentication request.</description>
					</attribute>
					<attribute name="@see">
						<description>SecurityManager#checkPermission</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.NetPermission</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
				<params>
					<param name="host" comment="The hostname of the site requesting authentication." fulltype="java.lang.String" type="String" />
					<param name="addr" comment="The InetAddress of the site requesting authorization,
             or null if not known." fulltype="java.net.InetAddress" type="InetAddress" />
					<param name="port" comment="the port for the requested connection" fulltype="int" type="int" />
					<param name="protocol" comment="The protocol that&apos;s requesting the connection
          ({@link java.net.Authenticator#getRequestingProtocol()})" fulltype="java.lang.String" type="String" />
					<param name="prompt" comment="A prompt string for the user" fulltype="java.lang.String" type="String" />
					<param name="scheme" comment="The authentication scheme" fulltype="java.lang.String" type="String" />
					<param name="url" comment="The requesting URL that caused the authentication" fulltype="java.net.URL" type="URL" />
					<param name="reqType" comment="The type (server or proxy) of the entity requesting
              authentication." fulltype="java.net.Authenticator.RequestorType" type="Authenticator.RequestorType" />
				</params>
			</method>
			<method final="true" visibility="protected" name="getRequestingHost" returncomment="the hostname of the connection requiring authentication, or null
          if it&apos;s not available." fulltype="java.lang.String" type="String">
				<comment>
					<description>Gets the &lt;code&gt;hostname&lt;/code&gt; of the
 site or proxy requesting authentication, or &lt;code&gt;null&lt;/code&gt;
 if not available.</description>
					<attribute name="@return">
						<description>the hostname of the connection requiring authentication, or null
          if it&apos;s not available.</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</method>
			<method final="true" visibility="protected" name="getRequestingSite" returncomment="the InetAddress of the site requesting authorization, or null
          if it&apos;s not available." fulltype="java.net.InetAddress" type="InetAddress">
				<comment>
					<description>Gets the &lt;code&gt;InetAddress&lt;/code&gt; of the
 site requesting authorization, or &lt;code&gt;null&lt;/code&gt;
 if not available.</description>
					<attribute name="@return">
						<description>the InetAddress of the site requesting authorization, or null
          if it&apos;s not available.</description>
					</attribute>
				</comment>
			</method>
			<method final="true" visibility="protected" name="getRequestingPort" returncomment="an &lt;code&gt;int&lt;/code&gt; indicating the
 port for the requested connection." fulltype="int" type="int">
				<comment>
					<description>Gets the port number for the requested connection.</description>
					<attribute name="@return">
						<description>an &lt;code&gt;int&lt;/code&gt; indicating the
 port for the requested connection.</description>
					</attribute>
				</comment>
			</method>
			<method final="true" visibility="protected" name="getRequestingProtocol" returncomment="the protcol, optionally followed by &quot;/version&quot;, where
          version is a version number." fulltype="java.lang.String" type="String">
				<comment>
					<description>Give the protocol that&apos;s requesting the connection.  Often this
 will be based on a URL, but in a future JDK it could be, for
 example, &quot;SOCKS&quot; for a password-protected SOCKS5 firewall.</description>
					<attribute name="@return">
						<description>the protcol, optionally followed by &quot;/version&quot;, where
          version is a version number.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URL#getProtocol()</description>
					</attribute>
				</comment>
			</method>
			<method final="true" visibility="protected" name="getRequestingPrompt" returncomment="the prompt string given by the requestor (realm for
          http requests)" fulltype="java.lang.String" type="String">
				<comment>
					<description>Gets the prompt string given by the requestor.</description>
					<attribute name="@return">
						<description>the prompt string given by the requestor (realm for
          http requests)</description>
					</attribute>
				</comment>
			</method>
			<method final="true" visibility="protected" name="getRequestingScheme" returncomment="the scheme of the requestor" fulltype="java.lang.String" type="String">
				<comment>
					<description>Gets the scheme of the requestor (the HTTP scheme
 for an HTTP firewall, for example).</description>
					<attribute name="@return">
						<description>the scheme of the requestor</description>
					</attribute>
				</comment>
			</method>
			<method visibility="protected" name="getPasswordAuthentication" returncomment="The PasswordAuthentication collected from the
          user, or null if none is provided." fulltype="java.net.PasswordAuthentication" type="PasswordAuthentication">
				<comment>
					<description>Called when password authorization is needed.  Subclasses should
 override the default implementation, which returns null.</description>
					<attribute name="@return">
						<description>The PasswordAuthentication collected from the
          user, or null if none is provided.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="protected" name="getRequestingURL" returncomment="the requesting URL" fulltype="java.net.URL" type="URL">
				<comment>
					<description>Returns the URL that resulted in this
 request for authentication.</description>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
					<attribute name="@return">
						<description>the requesting URL</description>
					</attribute>
				</comment>
			</method>
			<method visibility="protected" name="getRequestorType" returncomment="the authentication type of the requestor" fulltype="java.net.Authenticator.RequestorType" type="Authenticator.RequestorType">
				<comment>
					<description>Returns whether the requestor is a Proxy or a Server.</description>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
					<attribute name="@return">
						<description>the authentication type of the requestor</description>
					</attribute>
				</comment>
			</method>
		</methods>
		<jelclass final="true" superclass="Enum" visibility="public" package="java.net" serializable="true" superclassfulltype="java.lang.Enum" fulltype="java.net.Authenticator.RequestorType" type="Authenticator.RequestorType">
			<comment>
				<description>The type of the entity requesting authentication.</description>
				<attribute name="@since">
					<description>1.5</description>
				</attribute>
			</comment>
			<fields>
				<field final="true" static="true" visibility="public" name="PROXY" fulltype="java.net.Authenticator.RequestorType" type="Authenticator.RequestorType">
					<comment>
						<description>Entity requesting authentication is a HTTP proxy server.</description>
					</comment>
				</field>
				<field final="true" static="true" visibility="public" name="SERVER" fulltype="java.net.Authenticator.RequestorType" type="Authenticator.RequestorType">
					<comment>
						<description>Entity requesting authentication is a HTTP origin server.</description>
					</comment>
				</field>
			</fields>
			<methods>
				<constructor visibility="private" name="Authenticator.RequestorType" />
				<method static="true" visibility="public" name="values" fulltype="java.net.Authenticator.RequestorType[]" type="Authenticator.RequestorType" />
				<method static="true" visibility="public" name="valueOf" fulltype="java.net.Authenticator.RequestorType" type="Authenticator.RequestorType">
					<params>
						<param name="name" fulltype="java.lang.String" type="String" />
					</params>
				</method>
			</methods>
		</jelclass>
	</jelclass>
	<jelclass final="true" superclass="Enum" visibility="public" package="java.net" serializable="true" superclassfulltype="java.lang.Enum" fulltype="java.net.Authenticator.RequestorType" type="Authenticator.RequestorType">
		<comment>
			<description>The type of the entity requesting authentication.</description>
			<attribute name="@since">
				<description>1.5</description>
			</attribute>
		</comment>
		<fields>
			<field final="true" static="true" visibility="public" name="PROXY" fulltype="java.net.Authenticator.RequestorType" type="Authenticator.RequestorType">
				<comment>
					<description>Entity requesting authentication is a HTTP proxy server.</description>
				</comment>
			</field>
			<field final="true" static="true" visibility="public" name="SERVER" fulltype="java.net.Authenticator.RequestorType" type="Authenticator.RequestorType">
				<comment>
					<description>Entity requesting authentication is a HTTP origin server.</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="private" name="Authenticator.RequestorType" />
			<method static="true" visibility="public" name="values" fulltype="java.net.Authenticator.RequestorType[]" type="Authenticator.RequestorType" />
			<method static="true" visibility="public" name="valueOf" fulltype="java.net.Authenticator.RequestorType" type="Authenticator.RequestorType">
				<params>
					<param name="name" fulltype="java.lang.String" type="String" />
				</params>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="IOException" visibility="public" package="java.net" serializable="true" superclassfulltype="java.io.IOException" fulltype="java.net.ProtocolException" type="ProtocolException">
		<comment>
			<description>Thrown to indicate that there is an error in the underlying
 protocol, such as a TCP error.</description>
			<attribute name="@author">
				<description>Chris Warth</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.0</description>
			</attribute>
		</comment>
		<methods>
			<constructor visibility="public" name="ProtocolException">
				<comment>
					<description>Constructs a new &lt;code&gt;ProtocolException&lt;/code&gt; with the
 specified detail message.</description>
					<attribute name="@param">
						<description>host   the detail message.</description>
					</attribute>
				</comment>
				<params>
					<param name="host" comment="the detail message." fulltype="java.lang.String" type="String" />
				</params>
			</constructor>
			<constructor visibility="public" name="ProtocolException">
				<comment>
					<description>Constructs a new &lt;code&gt;ProtocolException&lt;/code&gt; with no detail message.</description>
				</comment>
			</constructor>
		</methods>
	</jelclass>
	<jelclass superclass="IOException" visibility="public" package="java.net" serializable="true" superclassfulltype="java.io.IOException" fulltype="java.net.MalformedURLException" type="MalformedURLException">
		<comment>
			<description>Thrown to indicate that a malformed URL has occurred. Either no
 legal protocol could be found in a specification string or the
 string could not be parsed.</description>
			<attribute name="@author">
				<description>Arthur van Hoff</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.0</description>
			</attribute>
		</comment>
		<methods>
			<constructor visibility="public" name="MalformedURLException">
				<comment>
					<description>Constructs a &lt;code&gt;MalformedURLException&lt;/code&gt; with no detail message.</description>
				</comment>
			</constructor>
			<constructor visibility="public" name="MalformedURLException">
				<comment>
					<description>Constructs a &lt;code&gt;MalformedURLException&lt;/code&gt; with the
 specified detail message.</description>
					<attribute name="@param">
						<description>msg   the detail message.</description>
					</attribute>
				</comment>
				<params>
					<param name="msg" comment="the detail message." fulltype="java.lang.String" type="String" />
				</params>
			</constructor>
		</methods>
	</jelclass>
	<jelclass superclass="IOException" visibility="public" package="java.net" serializable="true" superclassfulltype="java.io.IOException" fulltype="java.net.UnknownServiceException" type="UnknownServiceException">
		<comment>
			<description>Thrown to indicate that an unknown service exception has
 occurred. Either the MIME type returned by a URL connection does
 not make sense, or the application is attempting to write to a
 read-only URL connection.</description>
			<attribute name="@author">
				<description>unascribed</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.0</description>
			</attribute>
		</comment>
		<methods>
			<constructor visibility="public" name="UnknownServiceException">
				<comment>
					<description>Constructs a new &lt;code&gt;UnknownServiceException&lt;/code&gt; with no
 detail message.</description>
				</comment>
			</constructor>
			<constructor visibility="public" name="UnknownServiceException">
				<comment>
					<description>Constructs a new &lt;code&gt;UnknownServiceException&lt;/code&gt; with the
 specified detail message.</description>
					<attribute name="@param">
						<description>msg   the detail message.</description>
					</attribute>
				</comment>
				<params>
					<param name="msg" comment="the detail message." fulltype="java.lang.String" type="String" />
				</params>
			</constructor>
		</methods>
	</jelclass>
	<jelclass superclass="SocketException" visibility="public" package="java.net" serializable="true" superclassfulltype="java.net.SocketException" fulltype="java.net.ConnectException" type="ConnectException">
		<comment>
			<description>Signals that an error occurred while attempting to connect a
 socket to a remote address and port.  Typically, the connection
 was refused remotely (e.g., no process is listening on the
 remote address/port).</description>
			<attribute name="@since">
				<description>JDK1.1</description>
			</attribute>
		</comment>
		<methods>
			<constructor visibility="public" name="ConnectException">
				<comment>
					<description>Constructs a new ConnectException with the specified detail
 message as to why the connect error occurred.
 A detail message is a String that gives a specific
 description of this error.</description>
					<attribute name="@param">
						<description>msg the detail message</description>
					</attribute>
				</comment>
				<params>
					<param name="msg" comment="the detail message" fulltype="java.lang.String" type="String" />
				</params>
			</constructor>
			<constructor visibility="public" name="ConnectException">
				<comment>
					<description>Construct a new ConnectException with no detailed message.</description>
				</comment>
			</constructor>
		</methods>
	</jelclass>
	<jelclass superclass="Object" visibility="public" package="java.net" superclassfulltype="java.lang.Object" fulltype="java.net.DatagramSocket" type="DatagramSocket">
		<comment>
			<description>This class represents a socket for sending and receiving datagram packets.

 &lt;p&gt;A datagram socket is the sending or receiving point for a packet
 delivery service. Each packet sent or received on a datagram socket
 is individually addressed and routed. Multiple packets sent from
 one machine to another may be routed differently, and may arrive in
 any order.

 &lt;p&gt;UDP broadcasts sends are always enabled on a DatagramSocket.
 In order to receive broadcast packets a DatagramSocket
 should be bound to the wildcard address. In some
 implementations, broadcast packets may also be received when
 a DatagramSocket is bound to a more specific address.
 &lt;p&gt;
 Example:
 &lt;code&gt;
              DatagramSocket s = new DatagramSocket(null);
              s.bind(new InetSocketAddress(8888));
 &lt;/code&gt;
 Which is equivalent to:
 &lt;code&gt;
              DatagramSocket s = new DatagramSocket(8888);
 &lt;/code&gt;
 Both cases will create a DatagramSocket able to receive broadcasts on
 UDP port 8888.</description>
			<attribute name="@author">
				<description>Pavani Diwanji</description>
			</attribute>
			<attribute name="@see">
				<description>java.net.DatagramPacket</description>
			</attribute>
			<attribute name="@see">
				<description>java.nio.channels.DatagramChannel</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.0</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="private" name="created" fulltype="boolean" type="boolean">
				<comment>
					<description>Various states of this socket.</description>
				</comment>
			</field>
			<field visibility="private" name="bound" fulltype="boolean" type="boolean" />
			<field visibility="private" name="closed" fulltype="boolean" type="boolean" />
			<field visibility="private" name="closeLock" fulltype="java.lang.Object" type="Object" />
			<field visibility="package-private" name="impl" fulltype="java.net.DatagramSocketImpl" type="DatagramSocketImpl" />
			<field visibility="package-private" name="oldImpl" fulltype="boolean" type="boolean">
				<comment>
					<description>Are we using an older DatagramSocketImpl?</description>
				</comment>
			</field>
			<field final="true" static="true" const="0" visibility="package-private" name="ST_NOT_CONNECTED" constexpr="0" fulltype="int" type="int" />
			<field final="true" static="true" const="1" visibility="package-private" name="ST_CONNECTED" constexpr="1" fulltype="int" type="int" />
			<field final="true" static="true" const="2" visibility="package-private" name="ST_CONNECTED_NO_IMPL" constexpr="2" fulltype="int" type="int" />
			<field visibility="package-private" name="connectState" fulltype="int" type="int" />
			<field visibility="package-private" name="connectedAddress" fulltype="java.net.InetAddress" type="InetAddress" />
			<field visibility="package-private" name="connectedPort" fulltype="int" type="int" />
			<field static="true" visibility="package-private" name="implClass" fulltype="java.lang.Class" type="Class" />
			<field static="true" visibility="package-private" name="factory" fulltype="java.net.DatagramSocketImplFactory" type="DatagramSocketImplFactory">
				<comment>
					<description>User defined factory for all datagram sockets.</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="public" name="DatagramSocket">
				<comment>
					<description>Constructs a datagram socket and binds it to any available port
 on the local host machine.  The socket will be bound to the
 {@link InetAddress#isAnyLocalAddress wildcard} address,
 an IP address chosen by the kernel.

 &lt;p&gt;If there is a security manager,
 its &lt;code&gt;checkListen&lt;/code&gt; method is first called
 with 0 as its argument to ensure the operation is allowed.
 This could result in a SecurityException.</description>
					<attribute name="@exception">
						<description>SocketException  if the socket could not be opened,
               or the socket could not bind to the specified local port.</description>
					</attribute>
					<attribute name="@exception">
						<description>SecurityException  if a security manager exists and its
             &lt;code&gt;checkListen&lt;/code&gt; method doesn&apos;t allow the operation.</description>
					</attribute>
					<attribute name="@see">
						<description>SecurityManager#checkListen</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if the socket could not be opened,
               or the socket could not bind to the specified local port." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</constructor>
			<constructor visibility="protected" name="DatagramSocket">
				<comment>
					<description>Creates an unbound datagram socket with the specified
 DatagramSocketImpl.</description>
					<attribute name="@param">
						<description>impl an instance of a &lt;B&gt;DatagramSocketImpl&lt;/B&gt;
        the subclass wishes to use on the DatagramSocket.</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
				<params>
					<param name="impl" comment="an instance of a &lt;B&gt;DatagramSocketImpl&lt;/B&gt;
        the subclass wishes to use on the DatagramSocket." fulltype="java.net.DatagramSocketImpl" type="DatagramSocketImpl" />
				</params>
			</constructor>
			<constructor visibility="public" name="DatagramSocket">
				<comment>
					<description>Creates a datagram socket, bound to the specified local
 socket address.
 &lt;p&gt;
 If, if the address is &lt;code&gt;null&lt;/code&gt;, creates an unbound socket.
 &lt;p&gt;
 &lt;p&gt;If there is a security manager,
 its &lt;code&gt;checkListen&lt;/code&gt; method is first called
 with the port from the socket address
 as its argument to ensure the operation is allowed.
 This could result in a SecurityException.</description>
					<attribute name="@param">
						<description>bindaddr local socket address to bind, or &lt;code&gt;null&lt;/code&gt;
                 for an unbound socket.</description>
					</attribute>
					<attribute name="@exception">
						<description>SocketException  if the socket could not be opened,
               or the socket could not bind to the specified local port.</description>
					</attribute>
					<attribute name="@exception">
						<description>SecurityException  if a security manager exists and its
             &lt;code&gt;checkListen&lt;/code&gt; method doesn&apos;t allow the operation.</description>
					</attribute>
					<attribute name="@see">
						<description>SecurityManager#checkListen</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
				<params>
					<param name="bindaddr" comment="local socket address to bind, or &lt;code&gt;null&lt;/code&gt;
                 for an unbound socket." fulltype="java.net.SocketAddress" type="SocketAddress" />
				</params>
				<exceptions>
					<exception comment="if the socket could not be opened,
               or the socket could not bind to the specified local port." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</constructor>
			<constructor visibility="public" name="DatagramSocket">
				<comment>
					<description>Constructs a datagram socket and binds it to the specified port
 on the local host machine.  The socket will be bound to the
 {@link InetAddress#isAnyLocalAddress wildcard} address,
 an IP address chosen by the kernel.

 &lt;p&gt;If there is a security manager,
 its &lt;code&gt;checkListen&lt;/code&gt; method is first called
 with the &lt;code&gt;port&lt;/code&gt; argument
 as its argument to ensure the operation is allowed.
 This could result in a SecurityException.</description>
					<attribute name="@param">
						<description>port port to use.</description>
					</attribute>
					<attribute name="@exception">
						<description>SocketException  if the socket could not be opened,
               or the socket could not bind to the specified local port.</description>
					</attribute>
					<attribute name="@exception">
						<description>SecurityException  if a security manager exists and its
             &lt;code&gt;checkListen&lt;/code&gt; method doesn&apos;t allow the operation.</description>
					</attribute>
					<attribute name="@see">
						<description>SecurityManager#checkListen</description>
					</attribute>
				</comment>
				<params>
					<param name="port" comment="port to use." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if the socket could not be opened,
               or the socket could not bind to the specified local port." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</constructor>
			<constructor visibility="public" name="DatagramSocket">
				<comment>
					<description>Creates a datagram socket, bound to the specified local
 address.  The local port must be between 0 and 65535 inclusive.
 If the IP address is 0.0.0.0, the socket will be bound to the
 {@link InetAddress#isAnyLocalAddress wildcard} address,
 an IP address chosen by the kernel.

 &lt;p&gt;If there is a security manager,
 its &lt;code&gt;checkListen&lt;/code&gt; method is first called
 with the &lt;code&gt;port&lt;/code&gt; argument
 as its argument to ensure the operation is allowed.
 This could result in a SecurityException.</description>
					<attribute name="@param">
						<description>port local port to use</description>
					</attribute>
					<attribute name="@param">
						<description>laddr local address to bind</description>
					</attribute>
					<attribute name="@exception">
						<description>SocketException  if the socket could not be opened,
               or the socket could not bind to the specified local port.</description>
					</attribute>
					<attribute name="@exception">
						<description>SecurityException  if a security manager exists and its
             &lt;code&gt;checkListen&lt;/code&gt; method doesn&apos;t allow the operation.</description>
					</attribute>
					<attribute name="@see">
						<description>SecurityManager#checkListen</description>
					</attribute>
					<attribute name="@since">
						<description>JDK1.1</description>
					</attribute>
				</comment>
				<params>
					<param name="port" comment="local port to use" fulltype="int" type="int" />
					<param name="laddr" comment="local address to bind" fulltype="java.net.InetAddress" type="InetAddress" />
				</params>
				<exceptions>
					<exception comment="if the socket could not be opened,
               or the socket could not bind to the specified local port." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</constructor>
			<method synchronized="true" visibility="private" name="connectInternal" fulltype="void" type="void">
				<comment>
					<description>Connects this socket to a remote socket address (IP address + port number).
 Binds socket if not already bound.
 &lt;p&gt;</description>
					<attribute name="@param">
						<description>addr    The remote address.</description>
					</attribute>
					<attribute name="@param">
						<description>port    The remote port</description>
					</attribute>
					<attribute name="@throws">
						<description>SocketException if binding the socket fails.</description>
					</attribute>
				</comment>
				<params>
					<param name="address" fulltype="java.net.InetAddress" type="InetAddress" />
					<param name="port" comment="The remote port" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if binding the socket fails." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method visibility="private" name="checkOldImpl" fulltype="void" type="void" />
			<method visibility="package-private" name="createImpl" fulltype="void" type="void">
				<exceptions>
					<exception fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method visibility="package-private" name="getImpl" returncomment="the &lt;code&gt;DatagramSocketImpl&lt;/code&gt; attached to that
          DatagramSocket" fulltype="java.net.DatagramSocketImpl" type="DatagramSocketImpl">
				<comment>
					<description>Get the &lt;code&gt;DatagramSocketImpl&lt;/code&gt; attached to this socket,
 creating it if necessary.</description>
					<attribute name="@return">
						<description>the &lt;code&gt;DatagramSocketImpl&lt;/code&gt; attached to that
          DatagramSocket</description>
					</attribute>
					<attribute name="@throws">
						<description>SocketException if creation fails.</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if creation fails." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="public" name="bind" fulltype="void" type="void">
				<comment>
					<description>Binds this DatagramSocket to a specific address &amp; port.
 &lt;p&gt;
 If the address is &lt;code&gt;null&lt;/code&gt;, then the system will pick up
 an ephemeral port and a valid local address to bind the socket.
&lt;p&gt;</description>
					<attribute name="@param">
						<description>addr The address &amp; port to bind to.</description>
					</attribute>
					<attribute name="@throws">
						<description>SocketException if any error happens during the bind, or if the
          socket is already bound.</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException  if a security manager exists and its
             &lt;code&gt;checkListen&lt;/code&gt; method doesn&apos;t allow the operation.</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if addr is a SocketAddress subclass
         not supported by this socket.</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
				<params>
					<param name="addr" comment="The address &amp; port to bind to." fulltype="java.net.SocketAddress" type="SocketAddress" />
				</params>
				<exceptions>
					<exception comment="if any error happens during the bind, or if the
          socket is already bound." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method visibility="package-private" name="checkAddress" fulltype="void" type="void">
				<params>
					<param name="addr" fulltype="java.net.InetAddress" type="InetAddress" />
					<param name="op" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="public" name="connect" fulltype="void" type="void">
				<comment>
					<description>Connects the socket to a remote address for this socket. When a
 socket is connected to a remote address, packets may only be
 sent to or received from that address. By default a datagram
 socket is not connected.

 &lt;p&gt;If the remote destination to which the socket is connected does not
 exist, or is otherwise unreachable, and if an ICMP destination unreachable
 packet has been received for that address, then a subsequent call to
 send or receive may throw a PortUnreachableException. Note, there is no
 guarantee that the exception will be thrown.

 &lt;p&gt;A caller&apos;s permission to send and receive datagrams to a
 given host and port are checked at connect time. When a socket
 is connected, receive and send &lt;b&gt;will not
 perform any security checks&lt;/b&gt; on incoming and outgoing
 packets, other than matching the packet&apos;s and the socket&apos;s
 address and port. On a send operation, if the packet&apos;s address
 is set and the packet&apos;s address and the socket&apos;s address do not
 match, an IllegalArgumentException will be thrown. A socket
 connected to a multicast address may only be used to send packets.</description>
					<attribute name="@param">
						<description>address the remote address for the socket</description>
					</attribute>
					<attribute name="@param">
						<description>port the remote port for the socket.</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if the address is null,
 or the port is out of range.</description>
					</attribute>
					<attribute name="@exception">
						<description>SecurityException if the caller is not allowed to
 send datagrams to and receive datagrams from the address and port.</description>
					</attribute>
					<attribute name="@see">
						<description>#disconnect</description>
					</attribute>
					<attribute name="@see">
						<description>#send</description>
					</attribute>
					<attribute name="@see">
						<description>#receive</description>
					</attribute>
				</comment>
				<params>
					<param name="address" comment="the remote address for the socket" fulltype="java.net.InetAddress" type="InetAddress" />
					<param name="port" comment="the remote port for the socket." fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="connect" fulltype="void" type="void">
				<comment>
					<description>Connects this socket to a remote socket address (IP address + port number).
 &lt;p&gt;</description>
					<attribute name="@param">
						<description>addr    The remote address.</description>
					</attribute>
					<attribute name="@throws">
						<description>SocketException if the connect fails</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if addr is null or addr is a SocketAddress
          subclass not supported by this socket</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
					<attribute name="@see">
						<description>#connect</description>
					</attribute>
				</comment>
				<params>
					<param name="addr" comment="The remote address." fulltype="java.net.SocketAddress" type="SocketAddress" />
				</params>
				<exceptions>
					<exception comment="if the connect fails" fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method visibility="public" name="disconnect" fulltype="void" type="void">
				<comment>
					<description>Disconnects the socket. This does nothing if the socket is not
 connected.</description>
					<attribute name="@see">
						<description>#connect</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="isBound" returncomment="true if the socket successfully bound to an address" fulltype="boolean" type="boolean">
				<comment>
					<description>Returns the binding state of the socket.</description>
					<attribute name="@return">
						<description>true if the socket successfully bound to an address</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="isConnected" returncomment="true if the socket successfully connected to a server" fulltype="boolean" type="boolean">
				<comment>
					<description>Returns the connection state of the socket.</description>
					<attribute name="@return">
						<description>true if the socket successfully connected to a server</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getInetAddress" returncomment="the address to which this socket is connected." fulltype="java.net.InetAddress" type="InetAddress">
				<comment>
					<description>Returns the address to which this socket is connected. Returns
 &lt;code&gt;null&lt;/code&gt; if the socket is not connected.</description>
					<attribute name="@return">
						<description>the address to which this socket is connected.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getPort" returncomment="the port number to which this socket is connected." fulltype="int" type="int">
				<comment>
					<description>Returns the port number to which this socket is connected.
 Returns &lt;code&gt;-1&lt;/code&gt; if the socket is not connected.</description>
					<attribute name="@return">
						<description>the port number to which this socket is connected.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getRemoteSocketAddress" returncomment="a &lt;code&gt;SocketAddress&lt;/code&gt; representing the remote
         endpoint of this socket, or &lt;code&gt;null&lt;/code&gt; if it is
         not connected yet." fulltype="java.net.SocketAddress" type="SocketAddress">
				<comment>
					<description>Returns the address of the endpoint this socket is connected to, or
 &lt;code&gt;null&lt;/code&gt; if it is unconnected.</description>
					<attribute name="@return">
						<description>a &lt;code&gt;SocketAddress&lt;/code&gt; representing the remote
         endpoint of this socket, or &lt;code&gt;null&lt;/code&gt; if it is
         not connected yet.</description>
					</attribute>
					<attribute name="@see">
						<description>#getInetAddress()</description>
					</attribute>
					<attribute name="@see">
						<description>#getPort()</description>
					</attribute>
					<attribute name="@see">
						<description>#connect(SocketAddress)</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getLocalSocketAddress" returncomment="a &lt;code&gt;SocketAddress&lt;/code&gt; representing the local endpoint of this
         socket, or &lt;code&gt;null&lt;/code&gt; if it is not bound yet." fulltype="java.net.SocketAddress" type="SocketAddress">
				<comment>
					<description>Returns the address of the endpoint this socket is bound to, or
 &lt;code&gt;null&lt;/code&gt; if it is not bound yet.</description>
					<attribute name="@return">
						<description>a &lt;code&gt;SocketAddress&lt;/code&gt; representing the local endpoint of this
         socket, or &lt;code&gt;null&lt;/code&gt; if it is not bound yet.</description>
					</attribute>
					<attribute name="@see">
						<description>#getLocalAddress()</description>
					</attribute>
					<attribute name="@see">
						<description>#getLocalPort()</description>
					</attribute>
					<attribute name="@see">
						<description>#bind(SocketAddress)</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="send" fulltype="void" type="void">
				<comment>
					<description>Sends a datagram packet from this socket. The
 &lt;code&gt;DatagramPacket&lt;/code&gt; includes information indicating the
 data to be sent, its length, the IP address of the remote host,
 and the port number on the remote host.

 &lt;p&gt;If there is a security manager, and the socket is not currently
 connected to a remote address, this method first performs some
 security checks. First, if &lt;code&gt;p.getAddress().isMulticastAddress()&lt;/code&gt;
 is true, this method calls the
 security manager&apos;s &lt;code&gt;checkMulticast&lt;/code&gt; method
 with &lt;code&gt;p.getAddress()&lt;/code&gt; as its argument.
 If the evaluation of that expression is false,
 this method instead calls the security manager&apos;s
 &lt;code&gt;checkConnect&lt;/code&gt; method with arguments
 &lt;code&gt;p.getAddress().getHostAddress()&lt;/code&gt; and
 &lt;code&gt;p.getPort()&lt;/code&gt;. Each call to a security manager method
 could result in a SecurityException if the operation is not allowed.</description>
					<attribute name="@param">
						<description>p   the &lt;code&gt;DatagramPacket&lt;/code&gt; to be sent.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
					<attribute name="@exception">
						<description>SecurityException  if a security manager exists and its
             &lt;code&gt;checkMulticast&lt;/code&gt; or &lt;code&gt;checkConnect&lt;/code&gt;
             method doesn&apos;t allow the send.</description>
					</attribute>
					<attribute name="@exception">
						<description>PortUnreachableException may be thrown if the socket is connected
             to a currently unreachable destination. Note, there is no
             guarantee that the exception will be thrown.</description>
					</attribute>
					<attribute name="@exception">
						<description>java.nio.channels.IllegalBlockingModeException
             if this socket has an associated channel,
             and the channel is in non-blocking mode.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.DatagramPacket</description>
					</attribute>
					<attribute name="@see">
						<description>SecurityManager#checkMulticast(InetAddress)</description>
					</attribute>
					<attribute name="@see">
						<description>SecurityManager#checkConnect</description>
					</attribute>
					<attribute name="@revised">
						<description>1.4</description>
					</attribute>
					<attribute name="@spec">
						<description>JSR-51</description>
					</attribute>
				</comment>
				<params>
					<param name="p" comment="the &lt;code&gt;DatagramPacket&lt;/code&gt; to be sent." fulltype="java.net.DatagramPacket" type="DatagramPacket" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="public" name="receive" fulltype="void" type="void">
				<comment>
					<description>Receives a datagram packet from this socket. When this method
 returns, the &lt;code&gt;DatagramPacket&lt;/code&gt;&apos;s buffer is filled with
 the data received. The datagram packet also contains the sender&apos;s
 IP address, and the port number on the sender&apos;s machine.
 &lt;p&gt;
 This method blocks until a datagram is received. The
 &lt;code&gt;length&lt;/code&gt; field of the datagram packet object contains
 the length of the received message. If the message is longer than
 the packet&apos;s length, the message is truncated.
 &lt;p&gt;
 If there is a security manager, a packet cannot be received if the
 security manager&apos;s &lt;code&gt;checkAccept&lt;/code&gt; method
 does not allow it.</description>
					<attribute name="@param">
						<description>p   the &lt;code&gt;DatagramPacket&lt;/code&gt; into which to place
                 the incoming data.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
					<attribute name="@exception">
						<description>SocketTimeoutException  if setSoTimeout was previously called
                 and the timeout has expired.</description>
					</attribute>
					<attribute name="@exception">
						<description>PortUnreachableException may be thrown if the socket is connected
             to a currently unreachable destination. Note, there is no guarantee that the
             exception will be thrown.</description>
					</attribute>
					<attribute name="@exception">
						<description>java.nio.channels.IllegalBlockingModeException
             if this socket has an associated channel,
             and the channel is in non-blocking mode.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.DatagramPacket</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.DatagramSocket</description>
					</attribute>
					<attribute name="@revised">
						<description>1.4</description>
					</attribute>
					<attribute name="@spec">
						<description>JSR-51</description>
					</attribute>
				</comment>
				<params>
					<param name="p" comment="the &lt;code&gt;DatagramPacket&lt;/code&gt; into which to place
                 the incoming data." fulltype="java.net.DatagramPacket" type="DatagramPacket" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="getLocalAddress" returncomment="the local address to which the socket is bound, or
          an &lt;code&gt;InetAddress&lt;/code&gt; representing any local
          address if either the socket is not bound, or
          the security manager &lt;code&gt;checkConnect&lt;/code&gt;
          method does not allow the operation" fulltype="java.net.InetAddress" type="InetAddress">
				<comment>
					<description>Gets the local address to which the socket is bound.

 &lt;p&gt;If there is a security manager, its
 &lt;code&gt;checkConnect&lt;/code&gt; method is first called
 with the host address and &lt;code&gt;-1&lt;/code&gt;
 as its arguments to see if the operation is allowed.</description>
					<attribute name="@see">
						<description>SecurityManager#checkConnect</description>
					</attribute>
					<attribute name="@return">
						<description>the local address to which the socket is bound, or
          an &lt;code&gt;InetAddress&lt;/code&gt; representing any local
          address if either the socket is not bound, or
          the security manager &lt;code&gt;checkConnect&lt;/code&gt;
          method does not allow the operation</description>
					</attribute>
					<attribute name="@since">
						<description>1.1</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getLocalPort" returncomment="the port number on the local host to which this socket is bound." fulltype="int" type="int">
				<comment>
					<description>Returns the port number on the local host to which this socket
 is bound.</description>
					<attribute name="@return">
						<description>the port number on the local host to which this socket is bound.</description>
					</attribute>
				</comment>
			</method>
			<method synchronized="true" visibility="public" name="setSoTimeout" fulltype="void" type="void">
				<comment>
					<description>Enable/disable SO_TIMEOUT with the specified timeout, in
  milliseconds. With this option set to a non-zero timeout,
  a call to receive() for this DatagramSocket
  will block for only this amount of time.  If the timeout expires,
  a &lt;B&gt;java.net.SocketTimeoutException&lt;/B&gt; is raised, though the
  DatagramSocket is still valid.  The option &lt;B&gt;must&lt;/B&gt; be enabled
  prior to entering the blocking operation to have effect.  The
  timeout must be &gt; 0.
  A timeout of zero is interpreted as an infinite timeout.</description>
					<attribute name="@param">
						<description>timeout the specified timeout in milliseconds.</description>
					</attribute>
					<attribute name="@throws">
						<description>SocketException if there is an error in the underlying protocol, such as an UDP error.</description>
					</attribute>
					<attribute name="@since">
						<description>JDK1.1</description>
					</attribute>
					<attribute name="@see">
						<description>#getSoTimeout()</description>
					</attribute>
				</comment>
				<params>
					<param name="timeout" comment="the specified timeout in milliseconds." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if there is an error in the underlying protocol, such as an UDP error." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="public" name="getSoTimeout" returncomment="the setting for SO_TIMEOUT" fulltype="int" type="int">
				<comment>
					<description>Retrieve setting for SO_TIMEOUT.  0 returns implies that the
 option is disabled (i.e., timeout of infinity).</description>
					<attribute name="@return">
						<description>the setting for SO_TIMEOUT</description>
					</attribute>
					<attribute name="@throws">
						<description>SocketException if there is an error in the underlying protocol, such as an UDP error.</description>
					</attribute>
					<attribute name="@since">
						<description>JDK1.1</description>
					</attribute>
					<attribute name="@see">
						<description>#setSoTimeout(int)</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if there is an error in the underlying protocol, such as an UDP error." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="public" name="setSendBufferSize" fulltype="void" type="void">
				<comment>
					<description>Sets the SO_SNDBUF option to the specified value for this
 &lt;tt&gt;DatagramSocket&lt;/tt&gt;. The SO_SNDBUF option is used by the
 network implementation as a hint to size the underlying
 network I/O buffers. The SO_SNDBUF setting may also be used
 by the network implementation to determine the maximum size
 of the packet that can be sent on this socket.
 &lt;p&gt;
 As SO_SNDBUF is a hint, applications that want to verify
 what size the buffer is should call {@link #getSendBufferSize()}.
 &lt;p&gt;
 Increasing the buffer size may allow multiple outgoing packets
 to be queued by the network implementation when the send rate
 is high.
 &lt;p&gt;
 Note: If {@link #send(DatagramPacket)} is used to send a
 &lt;code&gt;DatagramPacket&lt;/code&gt; that is larger than the setting
 of SO_SNDBUF then it is implementation specific if the
 packet is sent or discarded.</description>
					<attribute name="@param">
						<description>size the size to which to set the send buffer
 size. This value must be greater than 0.</description>
					</attribute>
					<attribute name="@exception">
						<description>SocketException if there is an error
 in the underlying protocol, such as an UDP error.</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if the value is 0 or is
 negative.</description>
					</attribute>
					<attribute name="@see">
						<description>#getSendBufferSize()</description>
					</attribute>
				</comment>
				<params>
					<param name="size" comment="the size to which to set the send buffer
 size. This value must be greater than 0." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if there is an error
 in the underlying protocol, such as an UDP error." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="public" name="getSendBufferSize" returncomment="the value of the SO_SNDBUF option for this &lt;tt&gt;DatagramSocket&lt;/tt&gt;" fulltype="int" type="int">
				<comment>
					<description>Get value of the SO_SNDBUF option for this &lt;tt&gt;DatagramSocket&lt;/tt&gt;, that is the
 buffer size used by the platform for output on this &lt;tt&gt;DatagramSocket&lt;/tt&gt;.</description>
					<attribute name="@return">
						<description>the value of the SO_SNDBUF option for this &lt;tt&gt;DatagramSocket&lt;/tt&gt;</description>
					</attribute>
					<attribute name="@exception">
						<description>SocketException if there is an error in
 the underlying protocol, such as an UDP error.</description>
					</attribute>
					<attribute name="@see">
						<description>#setSendBufferSize</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if there is an error in
 the underlying protocol, such as an UDP error." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="public" name="setReceiveBufferSize" fulltype="void" type="void">
				<comment>
					<description>Sets the SO_RCVBUF option to the specified value for this
 &lt;tt&gt;DatagramSocket&lt;/tt&gt;. The SO_RCVBUF option is used by the
 the network implementation as a hint to size the underlying
 network I/O buffers. The SO_RCVBUF setting may also be used
 by the network implementation to determine the maximum size
 of the packet that can be received on this socket.
 &lt;p&gt;
 Because SO_RCVBUF is a hint, applications that want to
 verify what size the buffers were set to should call
 {@link #getReceiveBufferSize()}.
 &lt;p&gt;
 Increasing SO_RCVBUF may allow the network implementation
 to buffer multiple packets when packets arrive faster than
 are being received using {@link #receive(DatagramPacket)}.
 &lt;p&gt;
 Note: It is implementation specific if a packet larger
 than SO_RCVBUF can be received.</description>
					<attribute name="@param">
						<description>size the size to which to set the receive buffer
 size. This value must be greater than 0.</description>
					</attribute>
					<attribute name="@exception">
						<description>SocketException if there is an error in
 the underlying protocol, such as an UDP error.</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if the value is 0 or is
 negative.</description>
					</attribute>
					<attribute name="@see">
						<description>#getReceiveBufferSize()</description>
					</attribute>
				</comment>
				<params>
					<param name="size" comment="the size to which to set the receive buffer
 size. This value must be greater than 0." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if there is an error in
 the underlying protocol, such as an UDP error." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="public" name="getReceiveBufferSize" returncomment="the value of the SO_RCVBUF option for this &lt;tt&gt;DatagramSocket&lt;/tt&gt;" fulltype="int" type="int">
				<comment>
					<description>Get value of the SO_RCVBUF option for this &lt;tt&gt;DatagramSocket&lt;/tt&gt;, that is the
 buffer size used by the platform for input on this &lt;tt&gt;DatagramSocket&lt;/tt&gt;.</description>
					<attribute name="@return">
						<description>the value of the SO_RCVBUF option for this &lt;tt&gt;DatagramSocket&lt;/tt&gt;</description>
					</attribute>
					<attribute name="@exception">
						<description>SocketException if there is an error in the underlying protocol, such as an UDP error.</description>
					</attribute>
					<attribute name="@see">
						<description>#setReceiveBufferSize(int)</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if there is an error in the underlying protocol, such as an UDP error." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="public" name="setReuseAddress" fulltype="void" type="void">
				<comment>
					<description>Enable/disable the SO_REUSEADDR socket option.
 &lt;p&gt;
 For UDP sockets it may be necessary to bind more than one
 socket to the same socket address. This is typically for the
 purpose of receiving multicast packets
 (See {@link java.net.MulticastSocket}). The
 &lt;tt&gt;SO_REUSEADDR&lt;/tt&gt; socket option allows multiple
 sockets to be bound to the same socket address if the
 &lt;tt&gt;SO_REUSEADDR&lt;/tt&gt; socket option is enabled prior
 to binding the socket using {@link #bind(SocketAddress)}.
 &lt;p&gt;
 Note: This functionality is not supported by all existing platforms,
 so it is implementation specific whether this option will be ignored
 or not. However, if it is not supported then
 {@link #getReuseAddress()} will always return &lt;code&gt;false&lt;/code&gt;.
 &lt;p&gt;
 When a &lt;tt&gt;DatagramSocket&lt;/tt&gt; is created the initial setting
 of &lt;tt&gt;SO_REUSEADDR&lt;/tt&gt; is disabled.
 &lt;p&gt;
 The behaviour when &lt;tt&gt;SO_REUSEADDR&lt;/tt&gt; is enabled or
 disabled after a socket is bound (See {@link #isBound()})
 is not defined.</description>
					<attribute name="@param">
						<description>on  whether to enable or disable the</description>
					</attribute>
					<attribute name="@exception">
						<description>SocketException if an error occurs enabling or
            disabling the &lt;tt&gt;SO_RESUEADDR&lt;/tt&gt; socket option,
            or the socket is closed.</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
					<attribute name="@see">
						<description>#getReuseAddress()</description>
					</attribute>
					<attribute name="@see">
						<description>#bind(SocketAddress)</description>
					</attribute>
					<attribute name="@see">
						<description>#isBound()</description>
					</attribute>
					<attribute name="@see">
						<description>#isClosed()</description>
					</attribute>
				</comment>
				<params>
					<param name="on" comment="whether to enable or disable the" fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception comment="if an error occurs enabling or
            disabling the &lt;tt&gt;SO_RESUEADDR&lt;/tt&gt; socket option,
            or the socket is closed." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="public" name="getReuseAddress" returncomment="a &lt;code&gt;boolean&lt;/code&gt; indicating whether or not SO_REUSEADDR is enabled." fulltype="boolean" type="boolean">
				<comment>
					<description>Tests if SO_REUSEADDR is enabled.</description>
					<attribute name="@return">
						<description>a &lt;code&gt;boolean&lt;/code&gt; indicating whether or not SO_REUSEADDR is enabled.</description>
					</attribute>
					<attribute name="@exception">
						<description>SocketException if there is an error
 in the underlying protocol, such as an UDP error.</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
					<attribute name="@see">
						<description>#setReuseAddress(boolean)</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if there is an error
 in the underlying protocol, such as an UDP error." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="public" name="setBroadcast" fulltype="void" type="void">
				<comment>
					<description>Enable/disable SO_BROADCAST.</description>
					<attribute name="@param">
						<description>on     whether or not to have broadcast turned on.</description>
					</attribute>
					<attribute name="@exception">
						<description>SocketException if there is an error
 in the underlying protocol, such as an UDP error.</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
					<attribute name="@see">
						<description>#getBroadcast()</description>
					</attribute>
				</comment>
				<params>
					<param name="on" comment="whether or not to have broadcast turned on." fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception comment="if there is an error
 in the underlying protocol, such as an UDP error." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="public" name="getBroadcast" returncomment="a &lt;code&gt;boolean&lt;/code&gt; indicating whether or not SO_BROADCAST is enabled." fulltype="boolean" type="boolean">
				<comment>
					<description>Tests if SO_BROADCAST is enabled.</description>
					<attribute name="@return">
						<description>a &lt;code&gt;boolean&lt;/code&gt; indicating whether or not SO_BROADCAST is enabled.</description>
					</attribute>
					<attribute name="@exception">
						<description>SocketException if there is an error
 in the underlying protocol, such as an UDP error.</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
					<attribute name="@see">
						<description>#setBroadcast(boolean)</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if there is an error
 in the underlying protocol, such as an UDP error." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="public" name="setTrafficClass" fulltype="void" type="void">
				<comment>
					<description>Sets traffic class or type-of-service octet in the IP
 datagram header for datagrams sent from this DatagramSocket.
 As the underlying network implementation may ignore this
 value applications should consider it a hint.

 &lt;P&gt; The tc &lt;B&gt;must&lt;/B&gt; be in the range &lt;code&gt; 0 &lt;= tc &lt;=
 255&lt;/code&gt; or an IllegalArgumentException will be thrown.
 &lt;p&gt;Notes:
 &lt;p&gt; for Internet Protocol v4 the value consists of an octet
 with precedence and TOS fields as detailed in RFC 1349. The
 TOS field is bitset created by bitwise-or&apos;ing values such
 the following :-
 &lt;p&gt;
 &lt;UL&gt;
 &lt;LI&gt;&lt;CODE&gt;IPTOS_LOWCOST (0x02)&lt;/CODE&gt;&lt;/LI&gt;
 &lt;LI&gt;&lt;CODE&gt;IPTOS_RELIABILITY (0x04)&lt;/CODE&gt;&lt;/LI&gt;
 &lt;LI&gt;&lt;CODE&gt;IPTOS_THROUGHPUT (0x08)&lt;/CODE&gt;&lt;/LI&gt;
 &lt;LI&gt;&lt;CODE&gt;IPTOS_LOWDELAY (0x10)&lt;/CODE&gt;&lt;/LI&gt;
 &lt;/UL&gt;
 The last low order bit is always ignored as this
 corresponds to the MBZ (must be zero) bit.
 &lt;p&gt;
 Setting bits in the precedence field may result in a
 SocketException indicating that the operation is not
 permitted.
 &lt;p&gt;
 for Internet Protocol v6 &lt;code&gt;tc&lt;/code&gt; is the value that
 would be placed into the sin6_flowinfo field of the IP header.</description>
					<attribute name="@param">
						<description>tc        an &lt;code&gt;int&lt;/code&gt; value for the bitset.</description>
					</attribute>
					<attribute name="@throws">
						<description>SocketException if there is an error setting the
 traffic class or type-of-service</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
					<attribute name="@see">
						<description>#getTrafficClass</description>
					</attribute>
				</comment>
				<params>
					<param name="tc" comment="an &lt;code&gt;int&lt;/code&gt; value for the bitset." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if there is an error setting the
 traffic class or type-of-service" fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="public" name="getTrafficClass" returncomment="the traffic class or type-of-service already set" fulltype="int" type="int">
				<comment>
					<description>Gets traffic class or type-of-service in the IP datagram
 header for packets sent from this DatagramSocket.
 &lt;p&gt;
 As the underlying network implementation may ignore the
 traffic class or type-of-service set using {@link #setTrafficClass(int)}
 this method may return a different value than was previously
 set using the {@link #setTrafficClass(int)} method on this
 DatagramSocket.</description>
					<attribute name="@return">
						<description>the traffic class or type-of-service already set</description>
					</attribute>
					<attribute name="@throws">
						<description>SocketException if there is an error obtaining the
 traffic class or type-of-service value.</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
					<attribute name="@see">
						<description>#setTrafficClass(int)</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if there is an error obtaining the
 traffic class or type-of-service value." fulltype="java.net.SocketException" type="SocketException" />
				</exceptions>
			</method>
			<method visibility="public" name="close" fulltype="void" type="void">
				<comment>
					<description>Closes this datagram socket.
 &lt;p&gt;
 Any thread currently blocked in {@link #receive} upon this socket
 will throw a {@link SocketException}.

 &lt;p&gt; If this socket has an associated channel then the channel is closed
 as well.</description>
					<attribute name="@revised">
						<description>1.4</description>
					</attribute>
					<attribute name="@spec">
						<description>JSR-51</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="isClosed" returncomment="true if the socket has been closed" fulltype="boolean" type="boolean">
				<comment>
					<description>Returns whether the socket is closed or not.</description>
					<attribute name="@return">
						<description>true if the socket has been closed</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getChannel" returncomment="the datagram channel associated with this datagram socket,
          or &lt;tt&gt;null&lt;/tt&gt; if this socket was not created for a channel" fulltype="java.nio.channels.DatagramChannel" type="DatagramChannel">
				<comment>
					<description>Returns the unique {@link java.nio.channels.DatagramChannel} object
 associated with this datagram socket, if any.

 &lt;p&gt; A datagram socket will have a channel if, and only if, the channel
 itself was created via the {@link java.nio.channels.DatagramChannel#open
 DatagramChannel.open} method.</description>
					<attribute name="@return">
						<description>the datagram channel associated with this datagram socket,
          or &lt;tt&gt;null&lt;/tt&gt; if this socket was not created for a channel</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
					<attribute name="@spec">
						<description>JSR-51</description>
					</attribute>
				</comment>
			</method>
			<method static="true" synchronized="true" visibility="public" name="setDatagramSocketImplFactory" fulltype="void" type="void">
				<comment>
					<description>Sets the datagram socket implementation factory for the
 application. The factory can be specified only once.
 &lt;p&gt;
 When an application creates a new datagram socket, the socket
 implementation factory&apos;s &lt;code&gt;createDatagramSocketImpl&lt;/code&gt; method is
 called to create the actual datagram socket implementation.
 &lt;p&gt;
 Passing &lt;code&gt;null&lt;/code&gt; to the method is a no-op unless the factory
 was already set.

 &lt;p&gt;If there is a security manager, this method first calls
 the security manager&apos;s &lt;code&gt;checkSetFactory&lt;/code&gt; method
 to ensure the operation is allowed.
 This could result in a SecurityException.</description>
					<attribute name="@param">
						<description>fac   the desired factory.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs when setting the
              datagram socket factory.</description>
					</attribute>
					<attribute name="@exception">
						<description>SocketException  if the factory is already defined.</description>
					</attribute>
					<attribute name="@exception">
						<description>SecurityException  if a security manager exists and its
             &lt;code&gt;checkSetFactory&lt;/code&gt; method doesn&apos;t allow the
     operation.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.DatagramSocketImplFactory#createDatagramSocketImpl()</description>
					</attribute>
					<attribute name="@see">
						<description>SecurityManager#checkSetFactory</description>
					</attribute>
					<attribute name="@since">
						<description>1.3</description>
					</attribute>
				</comment>
				<params>
					<param name="fac" comment="the desired factory." fulltype="java.net.DatagramSocketImplFactory" type="DatagramSocketImplFactory" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs when setting the
              datagram socket factory." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="Object" visibility="public" package="java.net" superclassfulltype="java.lang.Object" fulltype="java.net.URLDecoder" type="URLDecoder">
		<comment>
			<description>Utility class for HTML form decoding. This class contains static methods
 for decoding a String from the &lt;CODE&gt;application/x-www-form-urlencoded&lt;/CODE&gt;
 MIME format.
 &lt;p&gt;
 The conversion process is the reverse of that used by the URLEncoder class. It is assumed
 that all characters in the encoded string are one of the following:
 &amp;quot;&lt;code&gt;a&lt;/code&gt;&amp;quot; through &amp;quot;&lt;code&gt;z&lt;/code&gt;&amp;quot;,
 &amp;quot;&lt;code&gt;A&lt;/code&gt;&amp;quot; through &amp;quot;&lt;code&gt;Z&lt;/code&gt;&amp;quot;,
 &amp;quot;&lt;code&gt;0&lt;/code&gt;&amp;quot; through &amp;quot;&lt;code&gt;9&lt;/code&gt;&amp;quot;, and
 &amp;quot;&lt;code&gt;-&lt;/code&gt;&amp;quot;, &amp;quot;&lt;code&gt;_&lt;/code&gt;&amp;quot;,
 &amp;quot;&lt;code&gt;.&lt;/code&gt;&amp;quot;, and &amp;quot;&lt;code&gt;*&lt;/code&gt;&amp;quot;. The
 character &amp;quot;&lt;code&gt;%&lt;/code&gt;&amp;quot; is allowed but is interpreted
 as the start of a special escaped sequence.
 &lt;p&gt;
 The following rules are applied in the conversion:
 &lt;p&gt;
 &lt;ul&gt;
 &lt;li&gt;The alphanumeric characters &amp;quot;&lt;code&gt;a&lt;/code&gt;&amp;quot; through
     &amp;quot;&lt;code&gt;z&lt;/code&gt;&amp;quot;, &amp;quot;&lt;code&gt;A&lt;/code&gt;&amp;quot; through
     &amp;quot;&lt;code&gt;Z&lt;/code&gt;&amp;quot; and &amp;quot;&lt;code&gt;0&lt;/code&gt;&amp;quot;
     through &amp;quot;&lt;code&gt;9&lt;/code&gt;&amp;quot; remain the same.
 &lt;li&gt;The special characters &amp;quot;&lt;code&gt;.&lt;/code&gt;&amp;quot;,
     &amp;quot;&lt;code&gt;-&lt;/code&gt;&amp;quot;, &amp;quot;&lt;code&gt;*&lt;/code&gt;&amp;quot;, and
     &amp;quot;&lt;code&gt;_&lt;/code&gt;&amp;quot; remain the same.
 &lt;li&gt;The plus sign &amp;quot;&lt;code&gt;+&lt;/code&gt;&amp;quot; is converted into a
     space character &amp;quot;&lt;code&gt;&amp;nbsp;&lt;/code&gt;&amp;quot; .
 &lt;li&gt;A sequence of the form &quot;&lt;code&gt;%&lt;i&gt;xy&lt;/i&gt;&lt;/code&gt;&quot; will be
     treated as representing a byte where &lt;i&gt;xy&lt;/i&gt; is the two-digit
     hexadecimal representation of the 8 bits. Then, all substrings
     that contain one or more of these byte sequences consecutively
     will be replaced by the character(s) whose encoding would result
     in those consecutive bytes.
     The encoding scheme used to decode these characters may be specified,
     or if unspecified, the default encoding of the platform will be used.
 &lt;/ul&gt;
 &lt;p&gt;
 There are two possible ways in which this decoder could deal with
 illegal strings.  It could either leave illegal characters alone or
 it could throw an &lt;tt&gt;{@link java.lang.IllegalArgumentException}&lt;/tt&gt;.
 Which approach the decoder takes is left to the
 implementation.</description>
			<attribute name="@author">
				<description>Mark Chamness</description>
			</attribute>
			<attribute name="@author">
				<description>Michael McCloskey</description>
			</attribute>
			<attribute name="@since">
				<description>1.2</description>
			</attribute>
		</comment>
		<fields>
			<field static="true" visibility="package-private" name="dfltEncName" fulltype="java.lang.String" type="String" />
		</fields>
		<methods>
			<constructor visibility="public" name="URLDecoder" />
			<method static="true" visibility="public" name="decode" returncomment="the newly decoded &lt;code&gt;String&lt;/code&gt;" fulltype="java.lang.String" type="String">
				<comment>
					<description>Decodes a &lt;code&gt;x-www-form-urlencoded&lt;/code&gt; string.
 The platform&apos;s default encoding is used to determine what characters
 are represented by any consecutive sequences of the form
 &quot;&lt;code&gt;%&lt;i&gt;xy&lt;/i&gt;&lt;/code&gt;&quot;.</description>
					<attribute name="@param">
						<description>s the &lt;code&gt;String&lt;/code&gt; to decode</description>
					</attribute>
					<attribute name="@deprecated">
						<description>The resulting string may vary depending on the platform&apos;s
          default encoding. Instead, use the decode(String,String) method
          to specify the encoding.</description>
					</attribute>
					<attribute name="@return">
						<description>the newly decoded &lt;code&gt;String&lt;/code&gt;</description>
					</attribute>
				</comment>
				<params>
					<param name="s" comment="the &lt;code&gt;String&lt;/code&gt; to decode" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method static="true" visibility="public" name="decode" returncomment="the newly decoded &lt;code&gt;String&lt;/code&gt;" fulltype="java.lang.String" type="String">
				<comment>
					<description>Decodes a &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt; string using a specific
 encoding scheme.
 The supplied encoding is used to determine
 what characters are represented by any consecutive sequences of the
 form &quot;&lt;code&gt;%&lt;i&gt;xy&lt;/i&gt;&lt;/code&gt;&quot;.
 &lt;p&gt;
 &lt;em&gt;&lt;strong&gt;Note:&lt;/strong&gt; The &lt;a href=
 &quot;http://www.w3.org/TR/html40/appendix/notes.html#non-ascii-chars&quot;&gt;
 World Wide Web Consortium Recommendation&lt;/a&gt; states that
 UTF-8 should be used. Not doing so may introduce
 incompatibilites.&lt;/em&gt;</description>
					<attribute name="@param">
						<description>s the &lt;code&gt;String&lt;/code&gt; to decode</description>
					</attribute>
					<attribute name="@param">
						<description>enc   The name of a supported
    &lt;a href=&quot;../lang/package-summary.html#charenc&quot;&gt;character
    encoding&lt;/a&gt;.</description>
					</attribute>
					<attribute name="@return">
						<description>the newly decoded &lt;code&gt;String&lt;/code&gt;</description>
					</attribute>
					<attribute name="@exception">
						<description>UnsupportedEncodingException
             If character encoding needs to be consulted, but
             named character encoding is not supported</description>
					</attribute>
					<attribute name="@see">
						<description>URLEncoder#encode(java.lang.String, java.lang.String)</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
				<params>
					<param name="s" comment="the &lt;code&gt;String&lt;/code&gt; to decode" fulltype="java.lang.String" type="String" />
					<param name="enc" comment="The name of a supported
    &lt;a href=&quot;../lang/package-summary.html#charenc&quot;&gt;character
    encoding&lt;/a&gt;." fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception comment="If character encoding needs to be consulted, but
             named character encoding is not supported" fulltype="java.io.UnsupportedEncodingException" type="UnsupportedEncodingException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass abstract="true" superclass="Object" visibility="public" package="java.net" superclassfulltype="java.lang.Object" fulltype="java.net.URLConnection" type="URLConnection">
		<comment>
			<description>The abstract class &lt;code&gt;URLConnection&lt;/code&gt; is the superclass
 of all classes that represent a communications link between the
 application and a URL. Instances of this class can be used both to
 read from and to write to the resource referenced by the URL. In
 general, creating a connection to a URL is a multistep process:
 &lt;p&gt;
 &lt;center&gt;&lt;table border=2 summary=&quot;Describes the process of creating a connection to a URL: openConnection() and connect() over time.&quot;&gt;
 &lt;tr&gt;&lt;th&gt;&lt;code&gt;openConnection()&lt;/code&gt;&lt;/th&gt;
     &lt;th&gt;&lt;code&gt;connect()&lt;/code&gt;&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;Manipulate parameters that affect the connection to the remote
         resource.&lt;/td&gt;
     &lt;td&gt;Interact with the resource; query header fields and
         contents.&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 ----------------------------&amp;gt;
 &lt;br&gt;time&lt;/center&gt;

 &lt;ol&gt;
 &lt;li&gt;The connection object is created by invoking the
     &lt;code&gt;openConnection&lt;/code&gt; method on a URL.
 &lt;li&gt;The setup parameters and general request properties are manipulated.
 &lt;li&gt;The actual connection to the remote object is made, using the
    &lt;code&gt;connect&lt;/code&gt; method.
 &lt;li&gt;The remote object becomes available. The header fields and the contents
     of the remote object can be accessed.
 &lt;/ol&gt;
 &lt;p&gt;
 The setup parameters are modified using the following methods:
 &lt;ul&gt;
   &lt;li&gt;&lt;code&gt;setAllowUserInteraction&lt;/code&gt;
   &lt;li&gt;&lt;code&gt;setDoInput&lt;/code&gt;
   &lt;li&gt;&lt;code&gt;setDoOutput&lt;/code&gt;
   &lt;li&gt;&lt;code&gt;setIfModifiedSince&lt;/code&gt;
   &lt;li&gt;&lt;code&gt;setUseCaches&lt;/code&gt;
 &lt;/ul&gt;
 &lt;p&gt;
 and the general request properties are modified using the method:
 &lt;ul&gt;
   &lt;li&gt;&lt;code&gt;setRequestProperty&lt;/code&gt;
 &lt;/ul&gt;
 &lt;p&gt;
 Default values for the &lt;code&gt;AllowUserInteraction&lt;/code&gt; and
 &lt;code&gt;UseCaches&lt;/code&gt; parameters can be set using the methods
 &lt;code&gt;setDefaultAllowUserInteraction&lt;/code&gt; and
 &lt;code&gt;setDefaultUseCaches&lt;/code&gt;.
 &lt;p&gt;
 Each of the above &lt;code&gt;set&lt;/code&gt; methods has a corresponding
 &lt;code&gt;get&lt;/code&gt; method to retrieve the value of the parameter or
 general request property. The specific parameters and general
 request properties that are applicable are protocol specific.
 &lt;p&gt;
 The following methods are used to access the header fields and
 the contents after the connection is made to the remote object:
 &lt;ul&gt;
   &lt;li&gt;&lt;code&gt;getContent&lt;/code&gt;
   &lt;li&gt;&lt;code&gt;getHeaderField&lt;/code&gt;
   &lt;li&gt;&lt;code&gt;getInputStream&lt;/code&gt;
   &lt;li&gt;&lt;code&gt;getOutputStream&lt;/code&gt;
 &lt;/ul&gt;
 &lt;p&gt;
 Certain header fields are accessed frequently. The methods:
 &lt;ul&gt;
   &lt;li&gt;&lt;code&gt;getContentEncoding&lt;/code&gt;
   &lt;li&gt;&lt;code&gt;getContentLength&lt;/code&gt;
   &lt;li&gt;&lt;code&gt;getContentType&lt;/code&gt;
   &lt;li&gt;&lt;code&gt;getDate&lt;/code&gt;
   &lt;li&gt;&lt;code&gt;getExpiration&lt;/code&gt;
   &lt;li&gt;&lt;code&gt;getLastModifed&lt;/code&gt;
 &lt;/ul&gt;
 &lt;p&gt;
 provide convenient access to these fields. The
 &lt;code&gt;getContentType&lt;/code&gt; method is used by the
 &lt;code&gt;getContent&lt;/code&gt; method to determine the type of the remote
 object; subclasses may find it convenient to override the
 &lt;code&gt;getContentType&lt;/code&gt; method.
 &lt;p&gt;
 In the common case, all of the pre-connection parameters and
 general request properties can be ignored: the pre-connection
 parameters and request properties default to sensible values. For
 most clients of this interface, there are only two interesting
 methods: &lt;code&gt;getInputStream&lt;/code&gt; and &lt;code&gt;getContent&lt;/code&gt;,
 which are mirrored in the &lt;code&gt;URL&lt;/code&gt; class by convenience methods.
 &lt;p&gt;
 More information on the request properties and header fields of
 an &lt;code&gt;http&lt;/code&gt; connection can be found at:
 &lt;blockquote&gt;&lt;pre&gt;
 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&gt;http://www.ietf.org/rfc/rfc2616.txt&lt;/a&gt;
 &lt;/pre&gt;&lt;/blockquote&gt;

 Note about &lt;code&gt;fileNameMap&lt;/code&gt;: In versions prior to JDK 1.1.6,
 field &lt;code&gt;fileNameMap&lt;/code&gt; of &lt;code&gt;URLConnection&lt;/code&gt; was public.
 In JDK 1.1.6 and later, &lt;code&gt;fileNameMap&lt;/code&gt; is private; accessor
 and mutator methods {@link #getFileNameMap() getFileNameMap} and
 {@link #setFileNameMap(java.net.FileNameMap) setFileNameMap} are added
 to access it.  This change is also described on the &lt;a href=
 &quot;http://java.sun.com/products/jdk/1.2/compatibility.html&quot;&gt;
 Compatibility&lt;/a&gt; page.

 Invoking the &lt;tt&gt;close()&lt;/tt&gt; methods on the &lt;tt&gt;InputStream&lt;/tt&gt; or &lt;tt&gt;OutputStream&lt;/tt&gt; of an
 &lt;tt&gt;URLConnection&lt;/tt&gt; after a request may free network resources associated with this
 instance, unless particular protocol specifications specify different behaviours
 for it.</description>
			<attribute name="@author">
				<description>James Gosling</description>
			</attribute>
			<attribute name="@see">
				<description>java.net.URL#openConnection()</description>
			</attribute>
			<attribute name="@see">
				<description>java.net.URLConnection#connect()</description>
			</attribute>
			<attribute name="@see">
				<description>java.net.URLConnection#getContent()</description>
			</attribute>
			<attribute name="@see">
				<description>java.net.URLConnection#getContentEncoding()</description>
			</attribute>
			<attribute name="@see">
				<description>java.net.URLConnection#getContentLength()</description>
			</attribute>
			<attribute name="@see">
				<description>java.net.URLConnection#getContentType()</description>
			</attribute>
			<attribute name="@see">
				<description>java.net.URLConnection#getDate()</description>
			</attribute>
			<attribute name="@see">
				<description>java.net.URLConnection#getExpiration()</description>
			</attribute>
			<attribute name="@see">
				<description>java.net.URLConnection#getHeaderField(int)</description>
			</attribute>
			<attribute name="@see">
				<description>java.net.URLConnection#getHeaderField(java.lang.String)</description>
			</attribute>
			<attribute name="@see">
				<description>java.net.URLConnection#getInputStream()</description>
			</attribute>
			<attribute name="@see">
				<description>java.net.URLConnection#getLastModified()</description>
			</attribute>
			<attribute name="@see">
				<description>java.net.URLConnection#getOutputStream()</description>
			</attribute>
			<attribute name="@see">
				<description>java.net.URLConnection#setAllowUserInteraction(boolean)</description>
			</attribute>
			<attribute name="@see">
				<description>java.net.URLConnection#setDefaultUseCaches(boolean)</description>
			</attribute>
			<attribute name="@see">
				<description>java.net.URLConnection#setDoInput(boolean)</description>
			</attribute>
			<attribute name="@see">
				<description>java.net.URLConnection#setDoOutput(boolean)</description>
			</attribute>
			<attribute name="@see">
				<description>java.net.URLConnection#setIfModifiedSince(long)</description>
			</attribute>
			<attribute name="@see">
				<description>java.net.URLConnection#setRequestProperty(java.lang.String, java.lang.String)</description>
			</attribute>
			<attribute name="@see">
				<description>java.net.URLConnection#setUseCaches(boolean)</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.0</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="protected" name="url" fulltype="java.net.URL" type="URL">
				<comment>
					<description>The URL represents the remote object on the World Wide Web to
 which this connection is opened.
 &lt;p&gt;
 The value of this field can be accessed by the
 &lt;code&gt;getURL&lt;/code&gt; method.
 &lt;p&gt;
 The default value of this variable is the value of the URL
 argument in the &lt;code&gt;URLConnection&lt;/code&gt; constructor.</description>
					<attribute name="@see">
						<description>java.net.URLConnection#getURL()</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URLConnection#url</description>
					</attribute>
				</comment>
			</field>
			<field visibility="protected" name="doInput" fulltype="boolean" type="boolean">
				<comment>
					<description>This variable is set by the &lt;code&gt;setDoInput&lt;/code&gt; method. Its
 value is returned by the &lt;code&gt;getDoInput&lt;/code&gt; method.
 &lt;p&gt;
 A URL connection can be used for input and/or output. Setting the
 &lt;code&gt;doInput&lt;/code&gt; flag to &lt;code&gt;true&lt;/code&gt; indicates that
 the application intends to read data from the URL connection.
 &lt;p&gt;
 The default value of this field is &lt;code&gt;true&lt;/code&gt;.</description>
					<attribute name="@see">
						<description>java.net.URLConnection#getDoInput()</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URLConnection#setDoInput(boolean)</description>
					</attribute>
				</comment>
			</field>
			<field visibility="protected" name="doOutput" fulltype="boolean" type="boolean">
				<comment>
					<description>This variable is set by the &lt;code&gt;setDoOutput&lt;/code&gt; method. Its
 value is returned by the &lt;code&gt;getDoOutput&lt;/code&gt; method.
 &lt;p&gt;
 A URL connection can be used for input and/or output. Setting the
 &lt;code&gt;doOutput&lt;/code&gt; flag to &lt;code&gt;true&lt;/code&gt; indicates
 that the application intends to write data to the URL connection.
 &lt;p&gt;
 The default value of this field is &lt;code&gt;false&lt;/code&gt;.</description>
					<attribute name="@see">
						<description>java.net.URLConnection#getDoOutput()</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URLConnection#setDoOutput(boolean)</description>
					</attribute>
				</comment>
			</field>
			<field static="true" visibility="private" name="defaultAllowUserInteraction" fulltype="boolean" type="boolean" />
			<field visibility="protected" name="allowUserInteraction" fulltype="boolean" type="boolean">
				<comment>
					<description>If &lt;code&gt;true&lt;/code&gt;, this &lt;code&gt;URL&lt;/code&gt; is being examined in
 a context in which it makes sense to allow user interactions such
 as popping up an authentication dialog. If &lt;code&gt;false&lt;/code&gt;,
 then no user interaction is allowed.
 &lt;p&gt;
 The value of this field can be set by the
 &lt;code&gt;setAllowUserInteraction&lt;/code&gt; method.
 Its value is returned by the
 &lt;code&gt;getAllowUserInteraction&lt;/code&gt; method.
 Its default value is the value of the argument in the last invocation
 of the &lt;code&gt;setDefaultAllowUserInteraction&lt;/code&gt; method.</description>
					<attribute name="@see">
						<description>java.net.URLConnection#getAllowUserInteraction()</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URLConnection#setAllowUserInteraction(boolean)</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URLConnection#setDefaultAllowUserInteraction(boolean)</description>
					</attribute>
				</comment>
			</field>
			<field static="true" visibility="private" name="defaultUseCaches" fulltype="boolean" type="boolean" />
			<field visibility="protected" name="useCaches" fulltype="boolean" type="boolean">
				<comment>
					<description>If &lt;code&gt;true&lt;/code&gt;, the protocol is allowed to use caching
 whenever it can. If &lt;code&gt;false&lt;/code&gt;, the protocol must always
 try to get a fresh copy of the object.
 &lt;p&gt;
 This field is set by the &lt;code&gt;setUseCaches&lt;/code&gt; method. Its
 value is returned by the &lt;code&gt;getUseCaches&lt;/code&gt; method.
 &lt;p&gt;
 Its default value is the value given in the last invocation of the
 &lt;code&gt;setDefaultUseCaches&lt;/code&gt; method.</description>
					<attribute name="@see">
						<description>java.net.URLConnection#setUseCaches(boolean)</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URLConnection#getUseCaches()</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URLConnection#setDefaultUseCaches(boolean)</description>
					</attribute>
				</comment>
			</field>
			<field visibility="protected" name="ifModifiedSince" fulltype="long" type="long">
				<comment>
					<description>Some protocols support skipping the fetching of the object unless
 the object has been modified more recently than a certain time.
 &lt;p&gt;
 A nonzero value gives a time as the number of milliseconds since
 January 1, 1970, GMT. The object is fetched only if it has been
 modified more recently than that time.
 &lt;p&gt;
 This variable is set by the &lt;code&gt;setIfModifiedSince&lt;/code&gt;
 method. Its value is returned by the
 &lt;code&gt;getIfModifiedSince&lt;/code&gt; method.
 &lt;p&gt;
 The default value of this field is &lt;code&gt;0&lt;/code&gt;, indicating
 that the fetching must always occur.</description>
					<attribute name="@see">
						<description>java.net.URLConnection#getIfModifiedSince()</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URLConnection#setIfModifiedSince(long)</description>
					</attribute>
				</comment>
			</field>
			<field visibility="protected" name="connected" fulltype="boolean" type="boolean">
				<comment>
					<description>If &lt;code&gt;false&lt;/code&gt;, this connection object has not created a
 communications link to the specified URL. If &lt;code&gt;true&lt;/code&gt;,
 the communications link has been established.</description>
				</comment>
			</field>
			<field visibility="private" name="connectTimeout" fulltype="int" type="int">
				<comment>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
			</field>
			<field visibility="private" name="readTimeout" fulltype="int" type="int" />
			<field visibility="private" name="requests" fulltype="sun.net.www.MessageHeader" type="MessageHeader">
				<comment>
					<attribute name="@since">
						<description>1.6</description>
					</attribute>
				</comment>
			</field>
			<field static="true" visibility="private" name="fileNameMap" fulltype="java.net.FileNameMap" type="FileNameMap">
				<comment>
					<attribute name="@since">
						<description>JDK1.1</description>
					</attribute>
				</comment>
			</field>
			<field static="true" visibility="private" name="fileNameMapLoaded" fulltype="boolean" type="boolean">
				<comment>
					<attribute name="@since">
						<description>1.2.2</description>
					</attribute>
				</comment>
			</field>
			<field static="true" visibility="package-private" name="factory" fulltype="java.net.ContentHandlerFactory" type="ContentHandlerFactory">
				<comment>
					<description>The ContentHandler factory.</description>
				</comment>
			</field>
			<field static="true" visibility="private" name="handlers" fulltype="java.util.Hashtable" type="Hashtable" />
			<field final="true" static="true" visibility="private" name="UnknownContentHandlerP" fulltype="java.net.ContentHandler" type="ContentHandler" />
			<field final="true" static="true" const="sun.net.www.content" visibility="private" name="contentClassPrefix" constexpr="&quot;sun.net.www.content&quot;" fulltype="java.lang.String" type="String" />
			<field final="true" static="true" const="java.content.handler.pkgs" visibility="private" name="contentPathProp" constexpr="&quot;java.content.handler.pkgs&quot;" fulltype="java.lang.String" type="String" />
		</fields>
		<methods>
			<constructor visibility="protected" name="URLConnection">
				<comment>
					<description>Constructs a URL connection to the specified URL. A connection to
 the object referenced by the URL is not created.</description>
					<attribute name="@param">
						<description>url   the specified URL.</description>
					</attribute>
				</comment>
				<params>
					<param name="url" comment="the specified URL." fulltype="java.net.URL" type="URL" />
				</params>
			</constructor>
			<method static="true" synchronized="true" visibility="public" name="getFileNameMap" returncomment="the FileNameMap" fulltype="java.net.FileNameMap" type="FileNameMap">
				<comment>
					<description>Loads filename map (a mimetable) from a data file. It will
 first try to load the user-specific table, defined
 by &amp;quot;content.types.user.table&amp;quot; property. If that fails,
 it tries to load the default built-in table at
 lib/content-types.properties under java home.</description>
					<attribute name="@return">
						<description>the FileNameMap</description>
					</attribute>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
					<attribute name="@see">
						<description>#setFileNameMap(java.net.FileNameMap)</description>
					</attribute>
				</comment>
			</method>
			<method static="true" visibility="public" name="setFileNameMap" fulltype="void" type="void">
				<comment>
					<description>Sets the FileNameMap.
 &lt;p&gt;
 If there is a security manager, this method first calls
 the security manager&apos;s &lt;code&gt;checkSetFactory&lt;/code&gt; method
 to ensure the operation is allowed.
 This could result in a SecurityException.</description>
					<attribute name="@param">
						<description>map the FileNameMap to be set</description>
					</attribute>
					<attribute name="@exception">
						<description>SecurityException  if a security manager exists and its
             &lt;code&gt;checkSetFactory&lt;/code&gt; method doesn&apos;t allow the operation.</description>
					</attribute>
					<attribute name="@see">
						<description>SecurityManager#checkSetFactory</description>
					</attribute>
					<attribute name="@see">
						<description>#getFileNameMap()</description>
					</attribute>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
				<params>
					<param name="map" comment="the FileNameMap to be set" fulltype="java.net.FileNameMap" type="FileNameMap" />
				</params>
			</method>
			<method abstract="true" visibility="public" name="connect" fulltype="void" type="void">
				<comment>
					<description>Opens a communications link to the resource referenced by this
 URL, if such a connection has not already been established.
 &lt;p&gt;
 If the &lt;code&gt;connect&lt;/code&gt; method is called when the connection
 has already been opened (indicated by the &lt;code&gt;connected&lt;/code&gt;
 field having the value &lt;code&gt;true&lt;/code&gt;), the call is ignored.
 &lt;p&gt;
 URLConnection objects go through two phases: first they are
 created, then they are connected.  After being created, and
 before being connected, various options can be specified
 (e.g., doInput and UseCaches).  After connecting, it is an
 error to try to set them.  Operations that depend on being
 connected, like getContentLength, will implicitly perform the
 connection, if necessary.</description>
					<attribute name="@throws">
						<description>SocketTimeoutException if the timeout expires before
               the connection can be established</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs while opening the
               connection.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URLConnection#connected</description>
					</attribute>
					<attribute name="@see">
						<description>#getConnectTimeout()</description>
					</attribute>
					<attribute name="@see">
						<description>#setConnectTimeout(int)</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs while opening the
               connection." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="setConnectTimeout" fulltype="void" type="void">
				<comment>
					<description>Sets a specified timeout value, in milliseconds, to be used
 when opening a communications link to the resource referenced
 by this URLConnection.  If the timeout expires before the
 connection can be established, a
 java.net.SocketTimeoutException is raised. A timeout of zero is
 interpreted as an infinite timeout.

 &lt;p&gt; Some non-standard implmentation of this method may ignore
 the specified timeout. To see the connect timeout set, please
 call getConnectTimeout().</description>
					<attribute name="@param">
						<description>timeout an &lt;code&gt;int&lt;/code&gt; that specifies the connect
               timeout value in milliseconds</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if the timeout parameter is negative</description>
					</attribute>
					<attribute name="@see">
						<description>#getConnectTimeout()</description>
					</attribute>
					<attribute name="@see">
						<description>#connect()</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
				<params>
					<param name="timeout" comment="an &lt;code&gt;int&lt;/code&gt; that specifies the connect
               timeout value in milliseconds" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="getConnectTimeout" returncomment="an &lt;code&gt;int&lt;/code&gt; that indicates the connect timeout
         value in milliseconds" fulltype="int" type="int">
				<comment>
					<description>Returns setting for connect timeout.
 &lt;p&gt;
 0 return implies that the option is disabled
 (i.e., timeout of infinity).</description>
					<attribute name="@return">
						<description>an &lt;code&gt;int&lt;/code&gt; that indicates the connect timeout
         value in milliseconds</description>
					</attribute>
					<attribute name="@see">
						<description>#setConnectTimeout(int)</description>
					</attribute>
					<attribute name="@see">
						<description>#connect()</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="setReadTimeout" fulltype="void" type="void">
				<comment>
					<description>Sets the read timeout to a specified timeout, in
 milliseconds. A non-zero value specifies the timeout when
 reading from Input stream when a connection is established to a
 resource. If the timeout expires before there is data available
 for read, a java.net.SocketTimeoutException is raised. A
 timeout of zero is interpreted as an infinite timeout.

&lt;p&gt; Some non-standard implementation of this method ignores the
 specified timeout. To see the read timeout set, please call
 getReadTimeout().</description>
					<attribute name="@param">
						<description>timeout an &lt;code&gt;int&lt;/code&gt; that specifies the timeout
 value to be used in milliseconds</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if the timeout parameter is negative</description>
					</attribute>
					<attribute name="@see">
						<description>#getReadTimeout()</description>
					</attribute>
					<attribute name="@see">
						<description>InputStream#read()</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
				<params>
					<param name="timeout" comment="an &lt;code&gt;int&lt;/code&gt; that specifies the timeout
 value to be used in milliseconds" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="getReadTimeout" returncomment="an &lt;code&gt;int&lt;/code&gt; that indicates the read timeout
         value in milliseconds" fulltype="int" type="int">
				<comment>
					<description>Returns setting for read timeout. 0 return implies that the
 option is disabled (i.e., timeout of infinity).</description>
					<attribute name="@return">
						<description>an &lt;code&gt;int&lt;/code&gt; that indicates the read timeout
         value in milliseconds</description>
					</attribute>
					<attribute name="@see">
						<description>#setReadTimeout(int)</description>
					</attribute>
					<attribute name="@see">
						<description>InputStream#read()</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getURL" returncomment="the value of this &lt;code&gt;URLConnection&lt;/code&gt;&apos;s &lt;code&gt;URL&lt;/code&gt;
          field." fulltype="java.net.URL" type="URL">
				<comment>
					<description>Returns the value of this &lt;code&gt;URLConnection&lt;/code&gt;&apos;s &lt;code&gt;URL&lt;/code&gt;
 field.</description>
					<attribute name="@return">
						<description>the value of this &lt;code&gt;URLConnection&lt;/code&gt;&apos;s &lt;code&gt;URL&lt;/code&gt;
          field.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URLConnection#url</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getContentLength" returncomment="the content length of the resource that this connection&apos;s URL
          references, or &lt;code&gt;-1&lt;/code&gt; if the content length is
          not known." fulltype="int" type="int">
				<comment>
					<description>Returns the value of the &lt;code&gt;content-length&lt;/code&gt; header field.</description>
					<attribute name="@return">
						<description>the content length of the resource that this connection&apos;s URL
          references, or &lt;code&gt;-1&lt;/code&gt; if the content length is
          not known.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getContentType" returncomment="the content type of the resource that the URL references,
          or &lt;code&gt;null&lt;/code&gt; if not known." fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the value of the &lt;code&gt;content-type&lt;/code&gt; header field.</description>
					<attribute name="@return">
						<description>the content type of the resource that the URL references,
          or &lt;code&gt;null&lt;/code&gt; if not known.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URLConnection#getHeaderField(java.lang.String)</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getContentEncoding" returncomment="the content encoding of the resource that the URL references,
          or &lt;code&gt;null&lt;/code&gt; if not known." fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the value of the &lt;code&gt;content-encoding&lt;/code&gt; header field.</description>
					<attribute name="@return">
						<description>the content encoding of the resource that the URL references,
          or &lt;code&gt;null&lt;/code&gt; if not known.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URLConnection#getHeaderField(java.lang.String)</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getExpiration" returncomment="the expiration date of the resource that this URL references,
          or 0 if not known. The value is the number of milliseconds since
          January 1, 1970 GMT." fulltype="long" type="long">
				<comment>
					<description>Returns the value of the &lt;code&gt;expires&lt;/code&gt; header field.</description>
					<attribute name="@return">
						<description>the expiration date of the resource that this URL references,
          or 0 if not known. The value is the number of milliseconds since
          January 1, 1970 GMT.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URLConnection#getHeaderField(java.lang.String)</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getDate" returncomment="the sending date of the resource that the URL references,
          or &lt;code&gt;0&lt;/code&gt; if not known. The value returned is the
          number of milliseconds since January 1, 1970 GMT." fulltype="long" type="long">
				<comment>
					<description>Returns the value of the &lt;code&gt;date&lt;/code&gt; header field.</description>
					<attribute name="@return">
						<description>the sending date of the resource that the URL references,
          or &lt;code&gt;0&lt;/code&gt; if not known. The value returned is the
          number of milliseconds since January 1, 1970 GMT.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URLConnection#getHeaderField(java.lang.String)</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getLastModified" returncomment="the date the resource referenced by this
          &lt;code&gt;URLConnection&lt;/code&gt; was last modified, or 0 if not known." fulltype="long" type="long">
				<comment>
					<description>Returns the value of the &lt;code&gt;last-modified&lt;/code&gt; header field.
 The result is the number of milliseconds since January 1, 1970 GMT.</description>
					<attribute name="@return">
						<description>the date the resource referenced by this
          &lt;code&gt;URLConnection&lt;/code&gt; was last modified, or 0 if not known.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URLConnection#getHeaderField(java.lang.String)</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getHeaderField" returncomment="the value of the named header field, or &lt;code&gt;null&lt;/code&gt;
          if there is no such field in the header." fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the value of the named header field.
 &lt;p&gt;
 If called on a connection that sets the same header multiple times
 with possibly different values, only the last value is returned.</description>
					<attribute name="@param">
						<description>name   the name of a header field.</description>
					</attribute>
					<attribute name="@return">
						<description>the value of the named header field, or &lt;code&gt;null&lt;/code&gt;
          if there is no such field in the header.</description>
					</attribute>
				</comment>
				<params>
					<param name="name" comment="the name of a header field." fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="public" name="getHeaderFields" returncomment="a Map of header fields" fulltype="java.util.Map" type="Map">
				<comment>
					<description>Returns an unmodifiable Map of the header fields.
 The Map keys are Strings that represent the
 response-header field names. Each Map value is an
 unmodifiable List of Strings that represents
 the corresponding field values.</description>
					<attribute name="@return">
						<description>a Map of header fields</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getHeaderFieldInt" returncomment="the value of the named field, parsed as an integer. The
          &lt;code&gt;Default&lt;/code&gt; value is returned if the field is
          missing or malformed." fulltype="int" type="int">
				<comment>
					<description>Returns the value of the named field parsed as a number.
 &lt;p&gt;
 This form of &lt;code&gt;getHeaderField&lt;/code&gt; exists because some
 connection types (e.g., &lt;code&gt;http-ng&lt;/code&gt;) have pre-parsed
 headers. Classes for that connection type can override this method
 and short-circuit the parsing.</description>
					<attribute name="@param">
						<description>name      the name of the header field.</description>
					</attribute>
					<attribute name="@param">
						<description>Default   the default value.</description>
					</attribute>
					<attribute name="@return">
						<description>the value of the named field, parsed as an integer. The
          &lt;code&gt;Default&lt;/code&gt; value is returned if the field is
          missing or malformed.</description>
					</attribute>
				</comment>
				<params>
					<param name="name" comment="the name of the header field." fulltype="java.lang.String" type="String" />
					<param name="Default" comment="the default value." fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="getHeaderFieldDate" returncomment="the value of the field, parsed as a date. The value of the
          &lt;code&gt;Default&lt;/code&gt; argument is returned if the field is
          missing or malformed." fulltype="long" type="long">
				<comment>
					<description>Returns the value of the named field parsed as date.
 The result is the number of milliseconds since January 1, 1970 GMT
 represented by the named field.
 &lt;p&gt;
 This form of &lt;code&gt;getHeaderField&lt;/code&gt; exists because some
 connection types (e.g., &lt;code&gt;http-ng&lt;/code&gt;) have pre-parsed
 headers. Classes for that connection type can override this method
 and short-circuit the parsing.</description>
					<attribute name="@param">
						<description>name     the name of the header field.</description>
					</attribute>
					<attribute name="@param">
						<description>Default   a default value.</description>
					</attribute>
					<attribute name="@return">
						<description>the value of the field, parsed as a date. The value of the
          &lt;code&gt;Default&lt;/code&gt; argument is returned if the field is
          missing or malformed.</description>
					</attribute>
				</comment>
				<params>
					<param name="name" comment="the name of the header field." fulltype="java.lang.String" type="String" />
					<param name="Default" comment="a default value." fulltype="long" type="long" />
				</params>
			</method>
			<method visibility="public" name="getHeaderFieldKey" returncomment="the key for the &lt;code&gt;n&lt;/code&gt;&lt;sup&gt;th&lt;/sup&gt; header field,
          or &lt;code&gt;null&lt;/code&gt; if there are fewer than &lt;code&gt;n+1&lt;/code&gt;
          fields." fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the key for the &lt;code&gt;n&lt;/code&gt;&lt;sup&gt;th&lt;/sup&gt; header field.
 It returns &lt;code&gt;null&lt;/code&gt; if there are fewer than &lt;code&gt;n+1&lt;/code&gt; fields.</description>
					<attribute name="@param">
						<description>n   an index, where n&gt;=0</description>
					</attribute>
					<attribute name="@return">
						<description>the key for the &lt;code&gt;n&lt;/code&gt;&lt;sup&gt;th&lt;/sup&gt; header field,
          or &lt;code&gt;null&lt;/code&gt; if there are fewer than &lt;code&gt;n+1&lt;/code&gt;
          fields.</description>
					</attribute>
				</comment>
				<params>
					<param name="n" comment="an index, where n&gt;=0" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="getHeaderField" returncomment="the value of the &lt;code&gt;n&lt;/code&gt;&lt;sup&gt;th&lt;/sup&gt; header field
          or &lt;code&gt;null&lt;/code&gt; if there are fewer than &lt;code&gt;n+1&lt;/code&gt; fields" fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the value for the &lt;code&gt;n&lt;/code&gt;&lt;sup&gt;th&lt;/sup&gt; header field.
 It returns &lt;code&gt;null&lt;/code&gt; if there are fewer than
 &lt;code&gt;n+1&lt;/code&gt;fields.
 &lt;p&gt;
 This method can be used in conjunction with the
 {@link #getHeaderFieldKey(int) getHeaderFieldKey} method to iterate through all
 the headers in the message.</description>
					<attribute name="@param">
						<description>n   an index, where n&gt;=0</description>
					</attribute>
					<attribute name="@return">
						<description>the value of the &lt;code&gt;n&lt;/code&gt;&lt;sup&gt;th&lt;/sup&gt; header field
          or &lt;code&gt;null&lt;/code&gt; if there are fewer than &lt;code&gt;n+1&lt;/code&gt; fields</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URLConnection#getHeaderFieldKey(int)</description>
					</attribute>
				</comment>
				<params>
					<param name="n" comment="an index, where n&gt;=0" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="getContent" returncomment="the object fetched. The &lt;code&gt;instanceof&lt;/code&gt; operator
               should be used to determine the specific kind of object
               returned." fulltype="java.lang.Object" type="Object">
				<comment>
					<description>Retrieves the contents of this URL connection.
 &lt;p&gt;
 This method first determines the content type of the object by
 calling the &lt;code&gt;getContentType&lt;/code&gt; method. If this is
 the first time that the application has seen that specific content
 type, a content handler for that content type is created:
 &lt;ol&gt;
 &lt;li&gt;If the application has set up a content handler factory instance
     using the &lt;code&gt;setContentHandlerFactory&lt;/code&gt; method, the
     &lt;code&gt;createContentHandler&lt;/code&gt; method of that instance is called
     with the content type as an argument; the result is a content
     handler for that content type.
 &lt;li&gt;If no content handler factory has yet been set up, or if the
     factory&apos;s &lt;code&gt;createContentHandler&lt;/code&gt; method returns
     &lt;code&gt;null&lt;/code&gt;, then the application loads the class named:
     &lt;blockquote&gt;&lt;pre&gt;
         sun.net.www.content.&amp;lt;&lt;i&gt;contentType&lt;/i&gt;&amp;gt;
     &lt;/pre&gt;&lt;/blockquote&gt;
     where &amp;lt;&lt;i&gt;contentType&lt;/i&gt;&amp;gt; is formed by taking the
     content-type string, replacing all slash characters with a
     &lt;code&gt;period&lt;/code&gt; (&apos;.&apos;), and all other non-alphanumeric characters
     with the underscore character &apos;&lt;code&gt;_&lt;/code&gt;&apos;. The alphanumeric
     characters are specifically the 26 uppercase ASCII letters
     &apos;&lt;code&gt;A&lt;/code&gt;&apos; through &apos;&lt;code&gt;Z&lt;/code&gt;&apos;, the 26 lowercase ASCII
     letters &apos;&lt;code&gt;a&lt;/code&gt;&apos; through &apos;&lt;code&gt;z&lt;/code&gt;&apos;, and the 10 ASCII
     digits &apos;&lt;code&gt;0&lt;/code&gt;&apos; through &apos;&lt;code&gt;9&lt;/code&gt;&apos;. If the specified
     class does not exist, or is not a subclass of
     &lt;code&gt;ContentHandler&lt;/code&gt;, then an
     &lt;code&gt;UnknownServiceException&lt;/code&gt; is thrown.
 &lt;/ol&gt;</description>
					<attribute name="@return">
						<description>the object fetched. The &lt;code&gt;instanceof&lt;/code&gt; operator
               should be used to determine the specific kind of object
               returned.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException              if an I/O error occurs while
               getting the content.</description>
					</attribute>
					<attribute name="@exception">
						<description>UnknownServiceException  if the protocol does not support
               the content type.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.ContentHandlerFactory#createContentHandler(java.lang.String)</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URLConnection#getContentType()</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URLConnection#setContentHandlerFactory(java.net.ContentHandlerFactory)</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs while
               getting the content." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="getContent" returncomment="the object fetched that is the first match of the type
               specified in the classes array. null if none of
               the requested types are supported.
               The &lt;code&gt;instanceof&lt;/code&gt; operator should be used to
               determine the specific kind of object returned." fulltype="java.lang.Object" type="Object">
				<comment>
					<description>Retrieves the contents of this URL connection.</description>
					<attribute name="@param">
						<description>classes the &lt;code&gt;Class&lt;/code&gt; array
 indicating the requested types</description>
					</attribute>
					<attribute name="@return">
						<description>the object fetched that is the first match of the type
               specified in the classes array. null if none of
               the requested types are supported.
               The &lt;code&gt;instanceof&lt;/code&gt; operator should be used to
               determine the specific kind of object returned.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException              if an I/O error occurs while
               getting the content.</description>
					</attribute>
					<attribute name="@exception">
						<description>UnknownServiceException  if the protocol does not support
               the content type.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URLConnection#getContent()</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.ContentHandlerFactory#createContentHandler(java.lang.String)</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URLConnection#getContent(java.lang.Class[])</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URLConnection#setContentHandlerFactory(java.net.ContentHandlerFactory)</description>
					</attribute>
					<attribute name="@since">
						<description>1.3</description>
					</attribute>
				</comment>
				<params>
					<param name="classes" comment="the &lt;code&gt;Class&lt;/code&gt; array
 indicating the requested types" fulltype="java.lang.Class[]" type="Class" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs while
               getting the content." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="getPermission" returncomment="the permission object representing the permission
 necessary to make the connection represented by this
 URLConnection." fulltype="java.security.Permission" type="Permission">
				<comment>
					<description>Returns a permission object representing the permission
 necessary to make the connection represented by this
 object. This method returns null if no permission is
 required to make the connection. By default, this method
 returns &lt;code&gt;java.security.AllPermission&lt;/code&gt;. Subclasses
 should override this method and return the permission
 that best represents the permission required to make a
 a connection to the URL. For example, a &lt;code&gt;URLConnection&lt;/code&gt;
 representing a &lt;code&gt;file:&lt;/code&gt; URL would return a
 &lt;code&gt;java.io.FilePermission&lt;/code&gt; object.

 &lt;p&gt;The permission returned may dependent upon the state of the
 connection. For example, the permission before connecting may be
 different from that after connecting. For example, an HTTP
 sever, say foo.com, may redirect the connection to a different
 host, say bar.com. Before connecting the permission returned by
 the connection will represent the permission needed to connect
 to foo.com, while the permission returned after connecting will
 be to bar.com.

 &lt;p&gt;Permissions are generally used for two purposes: to protect
 caches of objects obtained through URLConnections, and to check
 the right of a recipient to learn about a particular URL. In
 the first case, the permission should be obtained
 &lt;em&gt;after&lt;/em&gt; the object has been obtained. For example, in an
 HTTP connection, this will represent the permission to connect
 to the host from which the data was ultimately fetched. In the
 second case, the permission should be obtained and tested
 &lt;em&gt;before&lt;/em&gt; connecting.</description>
					<attribute name="@return">
						<description>the permission object representing the permission
 necessary to make the connection represented by this
 URLConnection.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException if the computation of the permission
 requires network or file I/O and an exception occurs while
 computing it.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if the computation of the permission
 requires network or file I/O and an exception occurs while
 computing it." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="getInputStream" returncomment="an input stream that reads from this open connection." fulltype="java.io.InputStream" type="InputStream">
				<comment>
					<description>Returns an input stream that reads from this open connection.

 A SocketTimeoutException can be thrown when reading from the
 returned input stream if the read timeout expires before data
 is available for read.</description>
					<attribute name="@return">
						<description>an input stream that reads from this open connection.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException              if an I/O error occurs while
               creating the input stream.</description>
					</attribute>
					<attribute name="@exception">
						<description>UnknownServiceException  if the protocol does not support
               input.</description>
					</attribute>
					<attribute name="@see">
						<description>#setReadTimeout(int)</description>
					</attribute>
					<attribute name="@see">
						<description>#getReadTimeout()</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs while
               creating the input stream." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="getOutputStream" returncomment="an output stream that writes to this connection." fulltype="java.io.OutputStream" type="OutputStream">
				<comment>
					<description>Returns an output stream that writes to this connection.</description>
					<attribute name="@return">
						<description>an output stream that writes to this connection.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException              if an I/O error occurs while
               creating the output stream.</description>
					</attribute>
					<attribute name="@exception">
						<description>UnknownServiceException  if the protocol does not support
               output.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs while
               creating the output stream." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="toString" returncomment="a string representation of this &lt;code&gt;URLConnection&lt;/code&gt;." fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns a &lt;code&gt;String&lt;/code&gt; representation of this URL connection.</description>
					<attribute name="@return">
						<description>a string representation of this &lt;code&gt;URLConnection&lt;/code&gt;.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="setDoInput" fulltype="void" type="void">
				<comment>
					<description>Sets the value of the &lt;code&gt;doInput&lt;/code&gt; field for this
 &lt;code&gt;URLConnection&lt;/code&gt; to the specified value.
 &lt;p&gt;
 A URL connection can be used for input and/or output.  Set the DoInput
 flag to true if you intend to use the URL connection for input,
 false if not.  The default is true.</description>
					<attribute name="@param">
						<description>doinput   the new value.</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalStateException if already connected</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URLConnection#doInput</description>
					</attribute>
					<attribute name="@see">
						<description>#getDoInput()</description>
					</attribute>
				</comment>
				<params>
					<param name="doinput" comment="the new value." fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method visibility="public" name="getDoInput" returncomment="the value of this &lt;code&gt;URLConnection&lt;/code&gt;&apos;s
          &lt;code&gt;doInput&lt;/code&gt; flag." fulltype="boolean" type="boolean">
				<comment>
					<description>Returns the value of this &lt;code&gt;URLConnection&lt;/code&gt;&apos;s
 &lt;code&gt;doInput&lt;/code&gt; flag.</description>
					<attribute name="@return">
						<description>the value of this &lt;code&gt;URLConnection&lt;/code&gt;&apos;s
          &lt;code&gt;doInput&lt;/code&gt; flag.</description>
					</attribute>
					<attribute name="@see">
						<description>#setDoInput(boolean)</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="setDoOutput" fulltype="void" type="void">
				<comment>
					<description>Sets the value of the &lt;code&gt;doOutput&lt;/code&gt; field for this
 &lt;code&gt;URLConnection&lt;/code&gt; to the specified value.
 &lt;p&gt;
 A URL connection can be used for input and/or output.  Set the DoOutput
 flag to true if you intend to use the URL connection for output,
 false if not.  The default is false.</description>
					<attribute name="@param">
						<description>dooutput   the new value.</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalStateException if already connected</description>
					</attribute>
					<attribute name="@see">
						<description>#getDoOutput()</description>
					</attribute>
				</comment>
				<params>
					<param name="dooutput" comment="the new value." fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method visibility="public" name="getDoOutput" returncomment="the value of this &lt;code&gt;URLConnection&lt;/code&gt;&apos;s
          &lt;code&gt;doOutput&lt;/code&gt; flag." fulltype="boolean" type="boolean">
				<comment>
					<description>Returns the value of this &lt;code&gt;URLConnection&lt;/code&gt;&apos;s
 &lt;code&gt;doOutput&lt;/code&gt; flag.</description>
					<attribute name="@return">
						<description>the value of this &lt;code&gt;URLConnection&lt;/code&gt;&apos;s
          &lt;code&gt;doOutput&lt;/code&gt; flag.</description>
					</attribute>
					<attribute name="@see">
						<description>#setDoOutput(boolean)</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="setAllowUserInteraction" fulltype="void" type="void">
				<comment>
					<description>Set the value of the &lt;code&gt;allowUserInteraction&lt;/code&gt; field of
 this &lt;code&gt;URLConnection&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>allowuserinteraction   the new value.</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalStateException if already connected</description>
					</attribute>
					<attribute name="@see">
						<description>#getAllowUserInteraction()</description>
					</attribute>
				</comment>
				<params>
					<param name="allowuserinteraction" comment="the new value." fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method visibility="public" name="getAllowUserInteraction" returncomment="the value of the &lt;code&gt;allowUserInteraction&lt;/code&gt; field for
          this object." fulltype="boolean" type="boolean">
				<comment>
					<description>Returns the value of the &lt;code&gt;allowUserInteraction&lt;/code&gt; field for
 this object.</description>
					<attribute name="@return">
						<description>the value of the &lt;code&gt;allowUserInteraction&lt;/code&gt; field for
          this object.</description>
					</attribute>
					<attribute name="@see">
						<description>#setAllowUserInteraction(boolean)</description>
					</attribute>
				</comment>
			</method>
			<method static="true" visibility="public" name="setDefaultAllowUserInteraction" fulltype="void" type="void">
				<comment>
					<description>Sets the default value of the
 &lt;code&gt;allowUserInteraction&lt;/code&gt; field for all future
 &lt;code&gt;URLConnection&lt;/code&gt; objects to the specified value.</description>
					<attribute name="@param">
						<description>defaultallowuserinteraction   the new value.</description>
					</attribute>
					<attribute name="@see">
						<description>#getDefaultAllowUserInteraction()</description>
					</attribute>
				</comment>
				<params>
					<param name="defaultallowuserinteraction" comment="the new value." fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method static="true" visibility="public" name="getDefaultAllowUserInteraction" returncomment="the default value of the &lt;code&gt;allowUserInteraction&lt;/code&gt;
          field." fulltype="boolean" type="boolean">
				<comment>
					<description>Returns the default value of the &lt;code&gt;allowUserInteraction&lt;/code&gt;
 field.
 &lt;p&gt;
 Ths default is &quot;sticky&quot;, being a part of the static state of all
 URLConnections.  This flag applies to the next, and all following
 URLConnections that are created.</description>
					<attribute name="@return">
						<description>the default value of the &lt;code&gt;allowUserInteraction&lt;/code&gt;
          field.</description>
					</attribute>
					<attribute name="@see">
						<description>#setDefaultAllowUserInteraction(boolean)</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="setUseCaches" fulltype="void" type="void">
				<comment>
					<description>Sets the value of the &lt;code&gt;useCaches&lt;/code&gt; field of this
 &lt;code&gt;URLConnection&lt;/code&gt; to the specified value.
 &lt;p&gt;
 Some protocols do caching of documents.  Occasionally, it is important
 to be able to &quot;tunnel through&quot; and ignore the caches (e.g., the
 &quot;reload&quot; button in a browser).  If the UseCaches flag on a connection
 is true, the connection is allowed to use whatever caches it can.
  If false, caches are to be ignored.
  The default value comes from DefaultUseCaches, which defaults to
 true.</description>
					<attribute name="@param">
						<description>usecaches a &lt;code&gt;boolean&lt;/code&gt; indicating whether
 or not to allow caching</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalStateException if already connected</description>
					</attribute>
					<attribute name="@see">
						<description>#getUseCaches()</description>
					</attribute>
				</comment>
				<params>
					<param name="usecaches" comment="a &lt;code&gt;boolean&lt;/code&gt; indicating whether
 or not to allow caching" fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method visibility="public" name="getUseCaches" returncomment="the value of this &lt;code&gt;URLConnection&lt;/code&gt;&apos;s
          &lt;code&gt;useCaches&lt;/code&gt; field." fulltype="boolean" type="boolean">
				<comment>
					<description>Returns the value of this &lt;code&gt;URLConnection&lt;/code&gt;&apos;s
 &lt;code&gt;useCaches&lt;/code&gt; field.</description>
					<attribute name="@return">
						<description>the value of this &lt;code&gt;URLConnection&lt;/code&gt;&apos;s
          &lt;code&gt;useCaches&lt;/code&gt; field.</description>
					</attribute>
					<attribute name="@see">
						<description>#setUseCaches(boolean)</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="setIfModifiedSince" fulltype="void" type="void">
				<comment>
					<description>Sets the value of the &lt;code&gt;ifModifiedSince&lt;/code&gt; field of
 this &lt;code&gt;URLConnection&lt;/code&gt; to the specified value.</description>
					<attribute name="@param">
						<description>ifmodifiedsince   the new value.</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalStateException if already connected</description>
					</attribute>
					<attribute name="@see">
						<description>#getIfModifiedSince()</description>
					</attribute>
				</comment>
				<params>
					<param name="ifmodifiedsince" comment="the new value." fulltype="long" type="long" />
				</params>
			</method>
			<method visibility="public" name="getIfModifiedSince" returncomment="the value of this object&apos;s &lt;code&gt;ifModifiedSince&lt;/code&gt; field." fulltype="long" type="long">
				<comment>
					<description>Returns the value of this object&apos;s &lt;code&gt;ifModifiedSince&lt;/code&gt; field.</description>
					<attribute name="@return">
						<description>the value of this object&apos;s &lt;code&gt;ifModifiedSince&lt;/code&gt; field.</description>
					</attribute>
					<attribute name="@see">
						<description>#setIfModifiedSince(long)</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getDefaultUseCaches" returncomment="the default value of a &lt;code&gt;URLConnection&lt;/code&gt;&apos;s
          &lt;code&gt;useCaches&lt;/code&gt; flag." fulltype="boolean" type="boolean">
				<comment>
					<description>Returns the default value of a &lt;code&gt;URLConnection&lt;/code&gt;&apos;s
 &lt;code&gt;useCaches&lt;/code&gt; flag.
 &lt;p&gt;
 Ths default is &quot;sticky&quot;, being a part of the static state of all
 URLConnections.  This flag applies to the next, and all following
 URLConnections that are created.</description>
					<attribute name="@return">
						<description>the default value of a &lt;code&gt;URLConnection&lt;/code&gt;&apos;s
          &lt;code&gt;useCaches&lt;/code&gt; flag.</description>
					</attribute>
					<attribute name="@see">
						<description>#setDefaultUseCaches(boolean)</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="setDefaultUseCaches" fulltype="void" type="void">
				<comment>
					<description>Sets the default value of the &lt;code&gt;useCaches&lt;/code&gt; field to the
 specified value.</description>
					<attribute name="@param">
						<description>defaultusecaches   the new value.</description>
					</attribute>
					<attribute name="@see">
						<description>#getDefaultUseCaches()</description>
					</attribute>
				</comment>
				<params>
					<param name="defaultusecaches" comment="the new value." fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method visibility="public" name="setRequestProperty" fulltype="void" type="void">
				<comment>
					<description>Sets the general request property. If a property with the key already
 exists, overwrite its value with the new value.

 &lt;p&gt; NOTE: HTTP requires all request properties which can
 legally have multiple instances with the same key
 to use a comma-seperated list syntax which enables multiple
 properties to be appended into a single property.</description>
					<attribute name="@param">
						<description>key     the keyword by which the request is known
                  (e.g., &quot;&lt;code&gt;accept&lt;/code&gt;&quot;).</description>
					</attribute>
					<attribute name="@param">
						<description>value   the value associated with it.</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalStateException if already connected</description>
					</attribute>
					<attribute name="@throws">
						<description>NullPointerException if key is &lt;CODE&gt;null&lt;/CODE&gt;</description>
					</attribute>
					<attribute name="@see">
						<description>#getRequestProperty(java.lang.String)</description>
					</attribute>
				</comment>
				<params>
					<param name="key" comment="the keyword by which the request is known
                  (e.g., &quot;&lt;code&gt;accept&lt;/code&gt;&quot;)." fulltype="java.lang.String" type="String" />
					<param name="value" comment="the value associated with it." fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="public" name="addRequestProperty" fulltype="void" type="void">
				<comment>
					<description>Adds a general request property specified by a
 key-value pair.  This method will not overwrite
 existing values associated with the same key.</description>
					<attribute name="@param">
						<description>key     the keyword by which the request is known
                  (e.g., &quot;&lt;code&gt;accept&lt;/code&gt;&quot;).</description>
					</attribute>
					<attribute name="@param">
						<description>value  the value associated with it.</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalStateException if already connected</description>
					</attribute>
					<attribute name="@throws">
						<description>NullPointerException if key is null</description>
					</attribute>
					<attribute name="@see">
						<description>#getRequestProperties()</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
				<params>
					<param name="key" comment="the keyword by which the request is known
                  (e.g., &quot;&lt;code&gt;accept&lt;/code&gt;&quot;)." fulltype="java.lang.String" type="String" />
					<param name="value" comment="the value associated with it." fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="public" name="getRequestProperty" returncomment="the value of the named general request property for this
           connection. If key is null, then null is returned." fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the value of the named general request property for this
 connection.</description>
					<attribute name="@param">
						<description>key the keyword by which the request is known (e.g., &quot;accept&quot;).</description>
					</attribute>
					<attribute name="@return">
						<description>the value of the named general request property for this
           connection. If key is null, then null is returned.</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalStateException if already connected</description>
					</attribute>
					<attribute name="@see">
						<description>#setRequestProperty(java.lang.String, java.lang.String)</description>
					</attribute>
				</comment>
				<params>
					<param name="key" comment="the keyword by which the request is known (e.g., &quot;accept&quot;)." fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="public" name="getRequestProperties" returncomment="a Map of the general request properties for this connection." fulltype="java.util.Map" type="Map">
				<comment>
					<description>Returns an unmodifiable Map of general request
 properties for this connection. The Map keys
 are Strings that represent the request-header
 field names. Each Map value is a unmodifiable List
 of Strings that represents the corresponding
 field values.</description>
					<attribute name="@return">
						<description>a Map of the general request properties for this connection.</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalStateException if already connected</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</method>
			<method static="true" visibility="public" name="setDefaultRequestProperty" fulltype="void" type="void">
				<comment>
					<description>Sets the default value of a general request property. When a
 &lt;code&gt;URLConnection&lt;/code&gt; is created, it is initialized with
 these properties.</description>
					<attribute name="@param">
						<description>key     the keyword by which the request is known
                  (e.g., &quot;&lt;code&gt;accept&lt;/code&gt;&quot;).</description>
					</attribute>
					<attribute name="@param">
						<description>value   the value associated with the key.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URLConnection#setRequestProperty(java.lang.String,java.lang.String)</description>
					</attribute>
					<attribute name="@deprecated">
						<description>The instance specific setRequestProperty method
 should be used after an appropriate instance of URLConnection
 is obtained. Invoking this method will have no effect.</description>
					</attribute>
					<attribute name="@see">
						<description>#getDefaultRequestProperty(java.lang.String)</description>
					</attribute>
				</comment>
				<params>
					<param name="key" comment="the keyword by which the request is known
                  (e.g., &quot;&lt;code&gt;accept&lt;/code&gt;&quot;)." fulltype="java.lang.String" type="String" />
					<param name="value" comment="the value associated with the key." fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method static="true" visibility="public" name="getDefaultRequestProperty" returncomment="the value of the default request property
 for the specified key." fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the value of the default request property. Default request
 properties are set for every connection.</description>
					<attribute name="@param">
						<description>key the keyword by which the request is known (e.g., &quot;accept&quot;).</description>
					</attribute>
					<attribute name="@return">
						<description>the value of the default request property
 for the specified key.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URLConnection#getRequestProperty(java.lang.String)</description>
					</attribute>
					<attribute name="@deprecated">
						<description>The instance specific getRequestProperty method
 should be used after an appropriate instance of URLConnection
 is obtained.</description>
					</attribute>
					<attribute name="@see">
						<description>#setDefaultRequestProperty(java.lang.String, java.lang.String)</description>
					</attribute>
				</comment>
				<params>
					<param name="key" comment="the keyword by which the request is known (e.g., &quot;accept&quot;)." fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method static="true" synchronized="true" visibility="public" name="setContentHandlerFactory" fulltype="void" type="void">
				<comment>
					<description>Sets the &lt;code&gt;ContentHandlerFactory&lt;/code&gt; of an
 application. It can be called at most once by an application.
 &lt;p&gt;
 The &lt;code&gt;ContentHandlerFactory&lt;/code&gt; instance is used to
 construct a content handler from a content type
 &lt;p&gt;
 If there is a security manager, this method first calls
 the security manager&apos;s &lt;code&gt;checkSetFactory&lt;/code&gt; method
 to ensure the operation is allowed.
 This could result in a SecurityException.</description>
					<attribute name="@param">
						<description>fac   the desired factory.</description>
					</attribute>
					<attribute name="@exception">
						<description>Error  if the factory has already been defined.</description>
					</attribute>
					<attribute name="@exception">
						<description>SecurityException  if a security manager exists and its
             &lt;code&gt;checkSetFactory&lt;/code&gt; method doesn&apos;t allow the operation.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.ContentHandlerFactory</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URLConnection#getContent()</description>
					</attribute>
					<attribute name="@see">
						<description>SecurityManager#checkSetFactory</description>
					</attribute>
				</comment>
				<params>
					<param name="fac" comment="the desired factory." fulltype="java.net.ContentHandlerFactory" type="ContentHandlerFactory" />
				</params>
			</method>
			<method synchronized="true" visibility="package-private" name="getContentHandler" fulltype="java.net.ContentHandler" type="ContentHandler">
				<comment>
					<description>Gets the Content Handler appropriate for this connection.</description>
					<attribute name="@param">
						<description>connection the connection to use.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception fulltype="java.net.UnknownServiceException" type="UnknownServiceException" />
				</exceptions>
			</method>
			<method visibility="private" name="stripOffParameters" fulltype="java.lang.String" type="String">
				<params>
					<param name="contentType" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="private" name="lookupContentHandlerClassFor" fulltype="java.net.ContentHandler" type="ContentHandler">
				<comment>
					<description>Looks for a content handler in a user-defineable set of places.
 By default it looks in sun.net.www.content, but users can define a
 vertical-bar delimited set of class prefixes to search through in
 addition by defining the java.content.handler.pkgs property.
 The class name must be of the form:
 &lt;pre&gt;
     {package-prefix}.{major}.{minor}
 e.g.
     YoyoDyne.experimental.text.plain
 &lt;/pre&gt;</description>
				</comment>
				<params>
					<param name="contentType" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception fulltype="java.lang.InstantiationException" type="InstantiationException" />
					<exception fulltype="java.lang.IllegalAccessException" type="IllegalAccessException" />
					<exception fulltype="java.lang.ClassNotFoundException" type="ClassNotFoundException" />
				</exceptions>
			</method>
			<method visibility="private" name="typeToPackageName" fulltype="java.lang.String" type="String">
				<comment>
					<description>Utility function to map a MIME content type into an equivalent
 pair of class name components.  For example: &quot;text/html&quot; would
 be returned as &quot;text.html&quot;</description>
				</comment>
				<params>
					<param name="contentType" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="private" name="getContentHandlerPkgPrefixes" fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns a vertical bar separated list of package prefixes for potential
 content handlers.  Tries to get the java.content.handler.pkgs property
 to use as a set of package prefixes to search.  Whether or not
 that property has been defined, the sun.net.www.content is always
 the last one on the returned package list.</description>
				</comment>
			</method>
			<method static="true" visibility="public" name="guessContentTypeFromName" returncomment="a guess as to what the content type of the object is,
          based upon its file name." fulltype="java.lang.String" type="String">
				<comment>
					<description>Tries to determine the content type of an object, based
 on the specified &quot;file&quot; component of a URL.
 This is a convenience method that can be used by
 subclasses that override the &lt;code&gt;getContentType&lt;/code&gt; method.</description>
					<attribute name="@param">
						<description>fname   a filename.</description>
					</attribute>
					<attribute name="@return">
						<description>a guess as to what the content type of the object is,
          based upon its file name.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URLConnection#getContentType()</description>
					</attribute>
				</comment>
				<params>
					<param name="fname" comment="a filename." fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method static="true" visibility="public" name="guessContentTypeFromStream" returncomment="a guess at the content type, or &lt;code&gt;null&lt;/code&gt; if none
             can be determined." fulltype="java.lang.String" type="String">
				<comment>
					<description>Tries to determine the type of an input stream based on the
 characters at the beginning of the input stream. This method can
 be used by subclasses that override the
 &lt;code&gt;getContentType&lt;/code&gt; method.
 &lt;p&gt;
 Ideally, this routine would not be needed. But many
 &lt;code&gt;http&lt;/code&gt; servers return the incorrect content type; in
 addition, there are many nonstandard extensions. Direct inspection
 of the bytes to determine the content type is often more accurate
 than believing the content type claimed by the &lt;code&gt;http&lt;/code&gt; server.</description>
					<attribute name="@param">
						<description>is   an input stream that supports marks.</description>
					</attribute>
					<attribute name="@return">
						<description>a guess at the content type, or &lt;code&gt;null&lt;/code&gt; if none
             can be determined.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs while reading the
               input stream.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.InputStream#mark(int)</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.InputStream#markSupported()</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URLConnection#getContentType()</description>
					</attribute>
				</comment>
				<params>
					<param name="is" comment="an input stream that supports marks." fulltype="java.io.InputStream" type="InputStream" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs while reading the
               input stream." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method static="true" visibility="private" name="checkfpx" fulltype="boolean" type="boolean">
				<comment>
					<description>Check for FlashPix image data in InputStream is.  Return true if
 the stream has FlashPix data, false otherwise.  Before calling this
 method, the stream should have already been checked to be sure it
 contains Microsoft Structured Storage data.</description>
				</comment>
				<params>
					<param name="is" fulltype="java.io.InputStream" type="InputStream" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method static="true" visibility="private" name="readBytes" fulltype="int" type="int">
				<comment>
					<description>Tries to read the specified number of bytes from the stream
 Returns -1, If EOF is reached before len bytes are read, returns 0
 otherwise</description>
				</comment>
				<params>
					<param name="c" fulltype="int[]" type="int" />
					<param name="len" fulltype="int" type="int" />
					<param name="is" fulltype="java.io.InputStream" type="InputStream" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method static="true" visibility="private" name="skipForward" fulltype="long" type="long">
				<comment>
					<description>Skips through the specified number of bytes from the stream
 until either EOF is reached, or the specified
 number of bytes have been skipped</description>
				</comment>
				<params>
					<param name="is" fulltype="java.io.InputStream" type="InputStream" />
					<param name="toSkip" fulltype="long" type="long" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="ContentHandler" visibility="package-private" package="java.net" superclassfulltype="java.net.ContentHandler" fulltype="java.net.UnknownContentHandler" type="UnknownContentHandler">
		<methods>
			<constructor visibility="package-private" name="UnknownContentHandler" />
			<method visibility="public" name="getContent" fulltype="java.lang.Object" type="Object">
				<params>
					<param name="uc" fulltype="java.net.URLConnection" type="URLConnection" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass final="true" superclass="BasicPermission" visibility="public" package="java.net" serializable="true" superclassfulltype="java.security.BasicPermission" fulltype="java.net.NetPermission" type="NetPermission">
		<comment>
			<description>This class is for various network permissions.
 A NetPermission contains a name (also referred to as a &quot;target name&quot;) but
 no actions list; you either have the named permission
 or you don&apos;t.
 &lt;P&gt;
 The target name is the name of the network permission (see below). The naming
 convention follows the  hierarchical property naming convention.
 Also, an asterisk
 may appear at the end of the name, following a &quot;.&quot;, or by itself, to
 signify a wildcard match. For example: &quot;foo.*&quot; or &quot;*&quot; is valid,
 &quot;*foo&quot; or &quot;a*b&quot; is not valid.
 &lt;P&gt;
 The following table lists all the possible NetPermission target names,
 and for each provides a description of what the permission allows
 and a discussion of the risks of granting code the permission.
 &lt;P&gt;

 &lt;table border=1 cellpadding=5 summary=&quot;Permission target name, what the permission allows, and associated risks&quot;&gt;
 &lt;tr&gt;
 &lt;th&gt;Permission Target Name&lt;/th&gt;
 &lt;th&gt;What the Permission Allows&lt;/th&gt;
 &lt;th&gt;Risks of Allowing this Permission&lt;/th&gt;
 &lt;/tr&gt;

 &lt;tr&gt;
   &lt;td&gt;setDefaultAuthenticator&lt;/td&gt;
   &lt;td&gt;The ability to set the
 way authentication information is retrieved when
 a proxy or HTTP server asks for authentication&lt;/td&gt;
   &lt;td&gt;Malicious
 code can set an authenticator that monitors and steals user
 authentication input as it retrieves the input from the user.&lt;/td&gt;
 &lt;/tr&gt;

 &lt;tr&gt;
   &lt;td&gt;requestPasswordAuthentication&lt;/td&gt;
   &lt;td&gt;The ability
 to ask the authenticator registered with the system for
 a password&lt;/td&gt;
   &lt;td&gt;Malicious code may steal this password.&lt;/td&gt;
 &lt;/tr&gt;

 &lt;tr&gt;
   &lt;td&gt;specifyStreamHandler&lt;/td&gt;
   &lt;td&gt;The ability
 to specify a stream handler when constructing a URL&lt;/td&gt;
   &lt;td&gt;Malicious code may create a URL with resources that it would
normally not have access to (like file:/foo/fum/), specifying a
stream handler that gets the actual bytes from someplace it does
have access to. Thus it might be able to trick the system into
creating a ProtectionDomain/CodeSource for a class even though
that class really didn&apos;t come from that location.&lt;/td&gt;
 &lt;/tr&gt;

 &lt;tr&gt;
   &lt;td&gt;setProxySelector&lt;/td&gt;
   &lt;td&gt;The ability to set the proxy selector used to make decisions
   on which proxies to use when making network connections.&lt;/td&gt;
   &lt;td&gt;Malicious code can set a ProxySelector that directs network
   traffic to an arbitrary network host.&lt;/td&gt;
 &lt;/tr&gt;

 &lt;tr&gt;
   &lt;td&gt;getProxySelector&lt;/td&gt;
   &lt;td&gt;The ability to get the proxy selector used to make decisions
   on which proxies to use when making network connections.&lt;/td&gt;
   &lt;td&gt;Malicious code can get a ProxySelector to discover proxy
   hosts and ports on internal networks, which could then become
   targets for attack.&lt;/td&gt;
 &lt;/tr&gt;

 &lt;tr&gt;
   &lt;td&gt;setCookieHandler&lt;/td&gt;
   &lt;td&gt;The ability to set the cookie handler that processes highly
   security sensitive cookie information for an Http session.&lt;/td&gt;
   &lt;td&gt;Malicious code can set a cookie handler to obtain access to
   highly security sensitive cookie information. Some web servers
   use cookies to save user private information such as access
   control information, or to track user browsing habit.&lt;/td&gt;
   &lt;/tr&gt;

 &lt;tr&gt;
   &lt;td&gt;getCookieHandler&lt;/td&gt;
   &lt;td&gt;The ability to get the cookie handler that processes highly
   security sensitive cookie information for an Http session.&lt;/td&gt;
   &lt;td&gt;Malicious code can get a cookie handler to obtain access to
   highly security sensitive cookie information. Some web servers
   use cookies to save user private information such as access
   control information, or to track user browsing habit.&lt;/td&gt;
   &lt;/tr&gt;

 &lt;tr&gt;
   &lt;td&gt;setResponseCache&lt;/td&gt;
   &lt;td&gt;The ability to set the response cache that provides access to
   a local response cache.&lt;/td&gt;
   &lt;td&gt;Malicious code getting access to the local response cache
   could access security sensitive information, or create false
   entries in the response cache.&lt;/td&gt;
   &lt;/tr&gt;

 &lt;tr&gt;
   &lt;td&gt;getResponseCache&lt;/td&gt;
   &lt;td&gt;The ability to get the response cache that provides
   access to a local response cache.&lt;/td&gt;
   &lt;td&gt;Malicious code getting access to the local response cache
   could access security sensitive information.&lt;/td&gt;
   &lt;/tr&gt;

 &lt;/table&gt;</description>
			<attribute name="@see">
				<description>java.security.BasicPermission</description>
			</attribute>
			<attribute name="@see">
				<description>java.security.Permission</description>
			</attribute>
			<attribute name="@see">
				<description>java.security.Permissions</description>
			</attribute>
			<attribute name="@see">
				<description>java.security.PermissionCollection</description>
			</attribute>
			<attribute name="@see">
				<description>java.lang.SecurityManager</description>
			</attribute>
			<attribute name="@author">
				<description>Marianne Mueller</description>
			</attribute>
			<attribute name="@author">
				<description>Roland Schemers</description>
			</attribute>
		</comment>
		<fields>
			<field final="true" static="true" const="-8343910153355041693" visibility="private" name="serialVersionUID" constexpr="-8343910153355041693L" fulltype="long" type="long" />
		</fields>
		<methods>
			<constructor visibility="public" name="NetPermission">
				<comment>
					<description>Creates a new NetPermission with the specified name.
 The name is the symbolic name of the NetPermission, such as
 &quot;setDefaultAuthenticator&quot;, etc. An asterisk
 may appear at the end of the name, following a &quot;.&quot;, or by itself, to
 signify a wildcard match.</description>
					<attribute name="@param">
						<description>name the name of the NetPermission.</description>
					</attribute>
					<attribute name="@throws">
						<description>NullPointerException if &lt;code&gt;name&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; is empty.</description>
					</attribute>
				</comment>
				<params>
					<param name="name" comment="the name of the NetPermission." fulltype="java.lang.String" type="String" />
				</params>
			</constructor>
			<constructor visibility="public" name="NetPermission">
				<comment>
					<description>Creates a new NetPermission object with the specified name.
 The name is the symbolic name of the NetPermission, and the
 actions String is currently unused and should be null.</description>
					<attribute name="@param">
						<description>name the name of the NetPermission.</description>
					</attribute>
					<attribute name="@param">
						<description>actions should be null.</description>
					</attribute>
					<attribute name="@throws">
						<description>NullPointerException if &lt;code&gt;name&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; is empty.</description>
					</attribute>
				</comment>
				<params>
					<param name="name" comment="the name of the NetPermission." fulltype="java.lang.String" type="String" />
					<param name="actions" comment="should be null." fulltype="java.lang.String" type="String" />
				</params>
			</constructor>
		</methods>
	</jelclass>
	<jelclass superclass="Object" visibility="public" package="java.net" superclassfulltype="java.lang.Object" fulltype="java.net.URLEncoder" type="URLEncoder">
		<comment>
			<description>Utility class for HTML form encoding. This class contains static methods
 for converting a String to the &lt;CODE&gt;application/x-www-form-urlencoded&lt;/CODE&gt; MIME
 format. For more information about HTML form encoding, consult the HTML
 &lt;A HREF=&quot;http://www.w3.org/TR/html4/&quot;&gt;specification&lt;/A&gt;.

 &lt;p&gt;
 When encoding a String, the following rules apply:

 &lt;p&gt;
 &lt;ul&gt;
 &lt;li&gt;The alphanumeric characters &amp;quot;&lt;code&gt;a&lt;/code&gt;&amp;quot; through
     &amp;quot;&lt;code&gt;z&lt;/code&gt;&amp;quot;, &amp;quot;&lt;code&gt;A&lt;/code&gt;&amp;quot; through
     &amp;quot;&lt;code&gt;Z&lt;/code&gt;&amp;quot; and &amp;quot;&lt;code&gt;0&lt;/code&gt;&amp;quot;
     through &amp;quot;&lt;code&gt;9&lt;/code&gt;&amp;quot; remain the same.
 &lt;li&gt;The special characters &amp;quot;&lt;code&gt;.&lt;/code&gt;&amp;quot;,
     &amp;quot;&lt;code&gt;-&lt;/code&gt;&amp;quot;, &amp;quot;&lt;code&gt;*&lt;/code&gt;&amp;quot;, and
     &amp;quot;&lt;code&gt;_&lt;/code&gt;&amp;quot; remain the same.
 &lt;li&gt;The space character &amp;quot;&lt;code&gt;&amp;nbsp;&lt;/code&gt;&amp;quot; is
     converted into a plus sign &amp;quot;&lt;code&gt;+&lt;/code&gt;&amp;quot;.
 &lt;li&gt;All other characters are unsafe and are first converted into
     one or more bytes using some encoding scheme. Then each byte is
     represented by the 3-character string
     &amp;quot;&lt;code&gt;%&lt;i&gt;xy&lt;/i&gt;&lt;/code&gt;&amp;quot;, where &lt;i&gt;xy&lt;/i&gt; is the
     two-digit hexadecimal representation of the byte.
     The recommended encoding scheme to use is UTF-8. However,
     for compatibility reasons, if an encoding is not specified,
     then the default encoding of the platform is used.
 &lt;/ul&gt;

 &lt;p&gt;
 For example using UTF-8 as the encoding scheme the string &amp;quot;The
 string &amp;#252;@foo-bar&amp;quot; would get converted to
 &amp;quot;The+string+%C3%BC%40foo-bar&amp;quot; because in UTF-8 the character
 &amp;#252; is encoded as two bytes C3 (hex) and BC (hex), and the
 character @ is encoded as one byte 40 (hex).</description>
			<attribute name="@author">
				<description>Herb Jellinek</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.0</description>
			</attribute>
		</comment>
		<fields>
			<field static="true" visibility="package-private" name="dontNeedEncoding" fulltype="java.util.BitSet" type="BitSet" />
			<field final="true" static="true" const="32" visibility="package-private" name="caseDiff" constexpr="32" fulltype="int" type="int" />
			<field static="true" visibility="package-private" name="dfltEncName" fulltype="java.lang.String" type="String" />
		</fields>
		<methods>
			<constructor visibility="private" name="URLEncoder">
				<comment>
					<description>You can&apos;t call the constructor.</description>
				</comment>
			</constructor>
			<method static="true" visibility="public" name="encode" returncomment="the translated &lt;code&gt;String&lt;/code&gt;." fulltype="java.lang.String" type="String">
				<comment>
					<description>Translates a string into &lt;code&gt;x-www-form-urlencoded&lt;/code&gt;
 format. This method uses the platform&apos;s default encoding
 as the encoding scheme to obtain the bytes for unsafe characters.</description>
					<attribute name="@param">
						<description>s   &lt;code&gt;String&lt;/code&gt; to be translated.</description>
					</attribute>
					<attribute name="@deprecated">
						<description>The resulting string may vary depending on the platform&apos;s
             default encoding. Instead, use the encode(String,String)
             method to specify the encoding.</description>
					</attribute>
					<attribute name="@return">
						<description>the translated &lt;code&gt;String&lt;/code&gt;.</description>
					</attribute>
				</comment>
				<params>
					<param name="s" comment="&lt;code&gt;String&lt;/code&gt; to be translated." fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method static="true" visibility="public" name="encode" returncomment="the translated &lt;code&gt;String&lt;/code&gt;." fulltype="java.lang.String" type="String">
				<comment>
					<description>Translates a string into &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;
 format using a specific encoding scheme. This method uses the
 supplied encoding scheme to obtain the bytes for unsafe
 characters.
 &lt;p&gt;
 &lt;em&gt;&lt;strong&gt;Note:&lt;/strong&gt; The &lt;a href=
 &quot;http://www.w3.org/TR/html40/appendix/notes.html#non-ascii-chars&quot;&gt;
 World Wide Web Consortium Recommendation&lt;/a&gt; states that
 UTF-8 should be used. Not doing so may introduce
 incompatibilites.&lt;/em&gt;</description>
					<attribute name="@param">
						<description>s   &lt;code&gt;String&lt;/code&gt; to be translated.</description>
					</attribute>
					<attribute name="@param">
						<description>enc   The name of a supported
    &lt;a href=&quot;../lang/package-summary.html#charenc&quot;&gt;character
    encoding&lt;/a&gt;.</description>
					</attribute>
					<attribute name="@return">
						<description>the translated &lt;code&gt;String&lt;/code&gt;.</description>
					</attribute>
					<attribute name="@exception">
						<description>UnsupportedEncodingException
             If the named encoding is not supported</description>
					</attribute>
					<attribute name="@see">
						<description>URLDecoder#decode(java.lang.String, java.lang.String)</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
				<params>
					<param name="s" comment="&lt;code&gt;String&lt;/code&gt; to be translated." fulltype="java.lang.String" type="String" />
					<param name="enc" comment="The name of a supported
    &lt;a href=&quot;../lang/package-summary.html#charenc&quot;&gt;character
    encoding&lt;/a&gt;." fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception comment="If the named encoding is not supported" fulltype="java.io.UnsupportedEncodingException" type="UnsupportedEncodingException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass abstract="true" superclass="Object" visibility="public" package="java.net" superclassfulltype="java.lang.Object" fulltype="java.net.ContentHandler" type="ContentHandler">
		<comment>
			<description>The abstract class &lt;code&gt;ContentHandler&lt;/code&gt; is the superclass
 of all classes that read an &lt;code&gt;Object&lt;/code&gt; from a
 &lt;code&gt;URLConnection&lt;/code&gt;.
 &lt;p&gt;
 An application does not generally call the
 &lt;code&gt;getContent&lt;/code&gt; method in this class directly. Instead, an
 application calls the &lt;code&gt;getContent&lt;/code&gt; method in class
 &lt;code&gt;URL&lt;/code&gt; or in &lt;code&gt;URLConnection&lt;/code&gt;.
 The application&apos;s content handler factory (an instance of a class that
 implements the interface &lt;code&gt;ContentHandlerFactory&lt;/code&gt; set
 up by a call to &lt;code&gt;setContentHandler&lt;/code&gt;) is
 called with a &lt;code&gt;String&lt;/code&gt; giving the MIME type of the
 object being received on the socket. The factory returns an
 instance of a subclass of &lt;code&gt;ContentHandler&lt;/code&gt;, and its
 &lt;code&gt;getContent&lt;/code&gt; method is called to create the object.
 &lt;p&gt;
 If no content handler could be found, URLConnection will
 look for a content handler in a user-defineable set of places.
 By default it looks in sun.net.www.content, but users can define a
 vertical-bar delimited set of class prefixes to search through in
 addition by defining the java.content.handler.pkgs property.
 The class name must be of the form:
 &lt;pre&gt;
     {package-prefix}.{major}.{minor}
 e.g.
     YoyoDyne.experimental.text.plain
 &lt;/pre&gt;
 If the loading of the content handler class would be performed by
 a classloader that is outside of the delegation chain of the caller,
 the JVM will need the RuntimePermission &quot;getClassLoader&quot;.</description>
			<attribute name="@author">
				<description>James Gosling</description>
			</attribute>
			<attribute name="@see">
				<description>java.net.ContentHandler#getContent(java.net.URLConnection)</description>
			</attribute>
			<attribute name="@see">
				<description>java.net.ContentHandlerFactory</description>
			</attribute>
			<attribute name="@see">
				<description>java.net.URL#getContent()</description>
			</attribute>
			<attribute name="@see">
				<description>java.net.URLConnection</description>
			</attribute>
			<attribute name="@see">
				<description>java.net.URLConnection#getContent()</description>
			</attribute>
			<attribute name="@see">
				<description>java.net.URLConnection#setContentHandlerFactory(java.net.ContentHandlerFactory)</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.0</description>
			</attribute>
		</comment>
		<methods>
			<constructor visibility="public" name="ContentHandler" />
			<method abstract="true" visibility="public" name="getContent" returncomment="the object read by the &lt;code&gt;ContentHandler&lt;/code&gt;." fulltype="java.lang.Object" type="Object">
				<comment>
					<description>Given a URL connect stream positioned at the beginning of the
 representation of an object, this method reads that stream and
 creates an object from it.</description>
					<attribute name="@param">
						<description>urlc   a URL connection.</description>
					</attribute>
					<attribute name="@return">
						<description>the object read by the &lt;code&gt;ContentHandler&lt;/code&gt;.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs while reading the object.</description>
					</attribute>
				</comment>
				<params>
					<param name="urlc" comment="a URL connection." fulltype="java.net.URLConnection" type="URLConnection" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs while reading the object." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="getContent" returncomment="the object read by the &lt;code&gt;ContentHandler&lt;/code&gt; that is
                 the first match of the suggested types.
                 null if none of the requested  are supported." fulltype="java.lang.Object" type="Object">
				<comment>
					<description>Given a URL connect stream positioned at the beginning of the
 representation of an object, this method reads that stream and
 creates an object that matches one of the types specified.

 The default implementation of this method should call getContent()
 and screen the return type for a match of the suggested types.</description>
					<attribute name="@param">
						<description>urlc   a URL connection.</description>
					</attribute>
					<attribute name="@param">
						<description>classes      an array of types requested</description>
					</attribute>
					<attribute name="@return">
						<description>the object read by the &lt;code&gt;ContentHandler&lt;/code&gt; that is
                 the first match of the suggested types.
                 null if none of the requested  are supported.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs while reading the object.</description>
					</attribute>
					<attribute name="@since">
						<description>1.3</description>
					</attribute>
				</comment>
				<params>
					<param name="urlc" comment="a URL connection." fulltype="java.net.URLConnection" type="URLConnection" />
					<param name="classes" comment="an array of types requested" fulltype="java.lang.Class[]" type="Class" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs while reading the object." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass final="true" superclass="InetAddress" visibility="public" package="java.net" serializable="true" superclassfulltype="java.net.InetAddress" fulltype="java.net.Inet6Address" type="Inet6Address">
		<comment>
			<description>This class represents an Internet Protocol version 6 (IPv6) address.
 Defined by &lt;a href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;
 &lt;i&gt;RFC&amp;nbsp;2373: IP Version 6 Addressing Architecture&lt;/i&gt;&lt;/a&gt;.

 &lt;h4&gt; &lt;A NAME=&quot;format&quot;&gt;Textual representation of IP addresses&lt;/a&gt; &lt;/h4&gt;

 Textual representation of IPv6 address used as input to methods
 takes one of the following forms:

 &lt;ol&gt;
   &lt;li&gt;&lt;p&gt; &lt;A NAME=&quot;lform&quot;&gt;The preferred form&lt;/a&gt; is x:x:x:x:x:x:x:x,
   where the &apos;x&apos;s are
   the hexadecimal values of the eight 16-bit pieces of the
   address. This is the full form.  For example,

   &lt;blockquote&gt;&lt;table cellpadding=0 cellspacing=0 summary=&quot;layout&quot;&gt;
   &lt;tr&gt;&lt;td&gt;&lt;tt&gt;1080:0:0:0:8:800:200C:417A&lt;/tt&gt;&lt;td&gt;&lt;/tr&gt;
   &lt;/table&gt;&lt;/blockquote&gt;

   &lt;p&gt; Note that it is not necessary to write the leading zeros in
   an individual field. However, there must be at least one numeral
   in every field, except as described below.&lt;/li&gt;

   &lt;li&gt;&lt;p&gt; Due to some methods of allocating certain styles of IPv6
   addresses, it will be common for addresses to contain long
   strings of zero bits. In order to make writing addresses
   containing zero bits easier, a special syntax is available to
   compress the zeros. The use of &quot;::&quot; indicates multiple groups
   of 16-bits of zeros. The &quot;::&quot; can only appear once in an address.
   The &quot;::&quot; can also be used to compress the leading and/or trailing
   zeros in an address. For example,

   &lt;blockquote&gt;&lt;table cellpadding=0 cellspacing=0 summary=&quot;layout&quot;&gt;
   &lt;tr&gt;&lt;td&gt;&lt;tt&gt;1080::8:800:200C:417A&lt;/tt&gt;&lt;td&gt;&lt;/tr&gt;
   &lt;/table&gt;&lt;/blockquote&gt;

   &lt;li&gt;&lt;p&gt; An alternative form that is sometimes more convenient
   when dealing with a mixed environment of IPv4 and IPv6 nodes is
   x:x:x:x:x:x:d.d.d.d, where the &apos;x&apos;s are the hexadecimal values
   of the six high-order 16-bit pieces of the address, and the &apos;d&apos;s
   are the decimal values of the four low-order 8-bit pieces of the
   standard IPv4 representation address, for example,

   &lt;blockquote&gt;&lt;table cellpadding=0 cellspacing=0 summary=&quot;layout&quot;&gt;
   &lt;tr&gt;&lt;td&gt;&lt;tt&gt;::FFFF:129.144.52.38&lt;/tt&gt;&lt;td&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;&lt;tt&gt;::129.144.52.38&lt;/tt&gt;&lt;td&gt;&lt;/tr&gt;
   &lt;/table&gt;&lt;/blockquote&gt;

   &lt;p&gt; where &quot;::FFFF:d.d.d.d&quot; and &quot;::d.d.d.d&quot; are, respectively, the
   general forms of an IPv4-mapped IPv6 address and an
   IPv4-compatible IPv6 address. Note that the IPv4 portion must be
   in the &quot;d.d.d.d&quot; form. The following forms are invalid:

   &lt;blockquote&gt;&lt;table cellpadding=0 cellspacing=0 summary=&quot;layout&quot;&gt;
   &lt;tr&gt;&lt;td&gt;&lt;tt&gt;::FFFF:d.d.d&lt;/tt&gt;&lt;td&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;&lt;tt&gt;::FFFF:d.d&lt;/tt&gt;&lt;td&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;&lt;tt&gt;::d.d.d&lt;/tt&gt;&lt;td&gt;&lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;&lt;tt&gt;::d.d&lt;/tt&gt;&lt;td&gt;&lt;/tr&gt;
   &lt;/table&gt;&lt;/blockquote&gt;

   &lt;p&gt; The following form:

   &lt;blockquote&gt;&lt;table cellpadding=0 cellspacing=0 summary=&quot;layout&quot;&gt;
   &lt;tr&gt;&lt;td&gt;&lt;tt&gt;::FFFF:d&lt;/tt&gt;&lt;td&gt;&lt;/tr&gt;
   &lt;/table&gt;&lt;/blockquote&gt;

   &lt;p&gt; is valid, however it is an unconventional representation of
   the IPv4-compatible IPv6 address,

   &lt;blockquote&gt;&lt;table cellpadding=0 cellspacing=0 summary=&quot;layout&quot;&gt;
   &lt;tr&gt;&lt;td&gt;&lt;tt&gt;::255.255.0.d&lt;/tt&gt;&lt;td&gt;&lt;/tr&gt;
   &lt;/table&gt;&lt;/blockquote&gt;

   &lt;p&gt; while &quot;::d&quot; corresponds to the general IPv6 address
   &quot;0:0:0:0:0:0:0:d&quot;.&lt;/li&gt;
 &lt;/ol&gt;

 &lt;p&gt; For methods that return a textual representation as output
 value, the full form is used. Inet6Address will return the full
 form because it is unambiguous when used in combination with other
 textual data.

 &lt;h4&gt; Special IPv6 address &lt;/h4&gt;

 &lt;blockquote&gt;
 &lt;table cellspacing=2 summary=&quot;Description of IPv4-mapped address&quot;&gt; &lt;tr&gt;&lt;th valign=top&gt;&lt;i&gt;IPv4-mapped address&lt;/i&gt;&lt;/th&gt;
         &lt;td&gt;Of the form::ffff:w.x.y.z, this IPv6 address is used to
         represent an IPv4 address. It allows the native program to
         use the same address data structure and also the same
         socket when communicating with both IPv4 and IPv6 nodes.

         &lt;p&gt;In InetAddress and Inet6Address, it is used for internal
         representation; it has no functional role. Java will never
         return an IPv4-mapped address.  These classes can take an
         IPv4-mapped address as input, both in byte array and text
         representation. However, it will be converted into an IPv4
         address.&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;&lt;/blockquote&gt;
 &lt;p&gt;
 &lt;h4&gt; &lt;A NAME=&quot;scoped&quot;&gt;Textual representation of IPv6 scoped addresses&lt;/a&gt; &lt;/h4&gt;
 &lt;p&gt;
 The textual representation of IPv6 addresses as described above can be extended
 to specify IPv6 scoped addresses. This extension to the basic addressing architecture
 is described in [draft-ietf-ipngwg-scoping-arch-04.txt].
 &lt;p&gt;
 Because link-local and site-local addresses are non-global, it is possible that different hosts
 may have the same destination address and may be reachable through different interfaces on the
 same originating system. In this case, the originating system is said to be connected
 to multiple zones of the same scope. In order to disambiguate which is the intended destination
 zone, it is possible to append a zone identifier (or &lt;i&gt;scope_id&lt;/i&gt;) to an IPv6 address.
 &lt;p&gt;
 The general format for specifying the &lt;i&gt;scope_id&lt;/i&gt; is the following:
 &lt;p&gt;&lt;blockquote&gt;&lt;i&gt;IPv6-address&lt;/i&gt;%&lt;i&gt;scope_id&lt;/i&gt;&lt;/blockquote&gt;
 &lt;p&gt; The IPv6-address is a literal IPv6 address as described above.
 The &lt;i&gt;scope_id&lt;/i&gt; refers to an interface on the local system, and it can be specified
 in two ways.
 &lt;p&gt;&lt;ol&gt;&lt;li&gt;&lt;i&gt;As a numeric identifier.&lt;/i&gt; This must be a positive integer that identifies the
 particular interface and scope as understood by the system. Usually, the numeric
 values can be determined through administration tools on the system. Each interface may
 have multiple values, one for each scope. If the scope is unspecified, then the default value
 used is zero.&lt;/li&gt;&lt;p&gt;
 &lt;li&gt;&lt;i&gt;As a string.&lt;/i&gt; This must be the exact string that is returned by
 {@link java.net.NetworkInterface#getName()} for the particular interface in question.
 When an Inet6Address is created in this way, the numeric scope-id is determined at the time
 the object is created by querying the relevant NetworkInterface.&lt;/li&gt;
 &lt;/ol&gt;&lt;p&gt;
 Note also, that the numeric &lt;i&gt;scope_id&lt;/i&gt; can be retrieved from Inet6Address instances returned from the
 NetworkInterface class. This can be used to find out the current scope ids configured on the system.</description>
			<attribute name="@since">
				<description>1.4</description>
			</attribute>
		</comment>
		<fields>
			<field final="true" static="true" const="16" visibility="package-private" name="INADDRSZ" constexpr="16" fulltype="int" type="int" />
			<field visibility="private" transient="true" name="cached_scope_id" fulltype="int" type="int" />
			<field visibility="package-private" name="ipaddress" fulltype="byte[]" type="byte">
				<comment>
					<description>Holds a 128-bit (16 bytes) IPv6 address.</description>
					<attribute name="@serial" />
				</comment>
			</field>
			<field visibility="private" name="scope_id" fulltype="int" type="int">
				<comment>
					<description>scope_id. The scope specified when the object is created. If the object is created
 with an interface name, then the scope_id is not determined until the time it is needed.</description>
				</comment>
			</field>
			<field visibility="private" name="scope_id_set" fulltype="boolean" type="boolean">
				<comment>
					<description>This will be set to true when the scope_id field contains a valid
 integer scope_id.</description>
				</comment>
			</field>
			<field visibility="private" transient="true" name="scope_ifname" fulltype="java.net.NetworkInterface" type="NetworkInterface">
				<comment>
					<description>scoped interface. scope_id is derived from this as the scope_id of the first
 address whose scope is the same as this address for the named interface.</description>
				</comment>
			</field>
			<field visibility="private" name="scope_ifname_set" fulltype="boolean" type="boolean">
				<comment>
					<description>set if the object is constructed with a scoped interface instead of a
 numeric scope id.</description>
				</comment>
			</field>
			<field final="true" static="true" const="6880410070516793377" visibility="private" name="serialVersionUID" constexpr="6880410070516793377L" fulltype="long" type="long" />
			<field final="true" static="true" const="2" visibility="private" name="INT16SZ" constexpr="2" fulltype="int" type="int" />
			<field visibility="private" name="ifname" fulltype="java.lang.String" type="String">
				<comment>
					<description>Following field is only used during (de)/serialization</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="package-private" name="Inet6Address" />
			<constructor visibility="package-private" name="Inet6Address">
				<params>
					<param name="hostName" fulltype="java.lang.String" type="String" />
					<param name="addr" fulltype="byte[]" type="byte" />
					<param name="scope_id" fulltype="int" type="int" />
				</params>
			</constructor>
			<constructor visibility="package-private" name="Inet6Address">
				<params>
					<param name="hostName" fulltype="java.lang.String" type="String" />
					<param name="addr" fulltype="byte[]" type="byte" />
				</params>
			</constructor>
			<constructor visibility="package-private" name="Inet6Address">
				<params>
					<param name="hostName" fulltype="java.lang.String" type="String" />
					<param name="addr" fulltype="byte[]" type="byte" />
					<param name="nif" fulltype="java.net.NetworkInterface" type="NetworkInterface" />
				</params>
				<exceptions>
					<exception fulltype="java.net.UnknownHostException" type="UnknownHostException" />
				</exceptions>
			</constructor>
			<constructor visibility="package-private" name="Inet6Address">
				<params>
					<param name="hostName" fulltype="java.lang.String" type="String" />
					<param name="addr" fulltype="byte[]" type="byte" />
					<param name="ifname" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception fulltype="java.net.UnknownHostException" type="UnknownHostException" />
				</exceptions>
			</constructor>
			<method static="true" visibility="public" name="getByAddress" returncomment="an Inet6Address object created from the raw IP address." fulltype="java.net.Inet6Address" type="Inet6Address">
				<comment>
					<description>Create an Inet6Address in the exact manner of {@link InetAddress#getByAddress(String,byte[])}
 except that the IPv6 scope_id is set to the value corresponding to the given interface
 for the address type specified in &lt;code&gt;addr&lt;/code&gt;.
 The call will fail with an UnknownHostException if the given interface does not have a numeric
 scope_id assigned for the given address type (eg. link-local or site-local).
 See &lt;a href=&quot;Inet6Address.html#scoped&quot;&gt;here&lt;/a&gt; for a description of IPv6
 scoped addresses.</description>
					<attribute name="@param">
						<description>host the specified host</description>
					</attribute>
					<attribute name="@param">
						<description>addr the raw IP address in network byte order</description>
					</attribute>
					<attribute name="@param">
						<description>nif an interface this address must be associated with.</description>
					</attribute>
					<attribute name="@return">
						<description>an Inet6Address object created from the raw IP address.</description>
					</attribute>
					<attribute name="@exception">
						<description>UnknownHostException  if IP address is of illegal length, or if the interface
          does not have a numeric scope_id assigned for the given address type.</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
				<params>
					<param name="host" comment="the specified host" fulltype="java.lang.String" type="String" />
					<param name="addr" comment="the raw IP address in network byte order" fulltype="byte[]" type="byte" />
					<param name="nif" comment="an interface this address must be associated with." fulltype="java.net.NetworkInterface" type="NetworkInterface" />
				</params>
				<exceptions>
					<exception comment="if IP address is of illegal length, or if the interface
          does not have a numeric scope_id assigned for the given address type." fulltype="java.net.UnknownHostException" type="UnknownHostException" />
				</exceptions>
			</method>
			<method static="true" visibility="public" name="getByAddress" returncomment="an Inet6Address object created from the raw IP address." fulltype="java.net.Inet6Address" type="Inet6Address">
				<comment>
					<description>Create an Inet6Address in the exact manner of {@link InetAddress#getByAddress(String,byte[])}
 except that the IPv6 scope_id is set to the given numeric value.
 The scope_id is not checked to determine if it corresponds to any interface on the system.
 See &lt;a href=&quot;Inet6Address.html#scoped&quot;&gt;here&lt;/a&gt; for a description of IPv6
 scoped addresses.</description>
					<attribute name="@param">
						<description>host the specified host</description>
					</attribute>
					<attribute name="@param">
						<description>addr the raw IP address in network byte order</description>
					</attribute>
					<attribute name="@param">
						<description>scope_id the numeric scope_id for the address.</description>
					</attribute>
					<attribute name="@return">
						<description>an Inet6Address object created from the raw IP address.</description>
					</attribute>
					<attribute name="@exception">
						<description>UnknownHostException  if IP address is of illegal length.</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
				<params>
					<param name="host" comment="the specified host" fulltype="java.lang.String" type="String" />
					<param name="addr" comment="the raw IP address in network byte order" fulltype="byte[]" type="byte" />
					<param name="scope_id" comment="the numeric scope_id for the address." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if IP address is of illegal length." fulltype="java.net.UnknownHostException" type="UnknownHostException" />
				</exceptions>
			</method>
			<method visibility="private" name="initstr" fulltype="void" type="void">
				<params>
					<param name="hostName" fulltype="java.lang.String" type="String" />
					<param name="addr" fulltype="byte[]" type="byte" />
					<param name="ifname" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception fulltype="java.net.UnknownHostException" type="UnknownHostException" />
				</exceptions>
			</method>
			<method visibility="private" name="initif" fulltype="void" type="void">
				<params>
					<param name="hostName" fulltype="java.lang.String" type="String" />
					<param name="addr" fulltype="byte[]" type="byte" />
					<param name="nif" fulltype="java.net.NetworkInterface" type="NetworkInterface" />
				</params>
				<exceptions>
					<exception fulltype="java.net.UnknownHostException" type="UnknownHostException" />
				</exceptions>
			</method>
			<method visibility="private" name="differentLocalAddressTypes" fulltype="boolean" type="boolean">
				<params>
					<param name="other" fulltype="java.net.Inet6Address" type="Inet6Address" />
				</params>
			</method>
			<method visibility="private" name="deriveNumericScope" fulltype="int" type="int">
				<params>
					<param name="ifc" fulltype="java.net.NetworkInterface" type="NetworkInterface" />
				</params>
				<exceptions>
					<exception fulltype="java.net.UnknownHostException" type="UnknownHostException" />
				</exceptions>
			</method>
			<method visibility="private" name="deriveNumericScope" fulltype="int" type="int">
				<params>
					<param name="ifname" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception fulltype="java.net.UnknownHostException" type="UnknownHostException" />
				</exceptions>
			</method>
			<method visibility="private" name="readObject" fulltype="void" type="void">
				<comment>
					<description>restore the state of this object from stream
 including the scope information, only if the
 scoped interface name is valid on this system</description>
				</comment>
				<params>
					<param name="s" fulltype="java.io.ObjectInputStream" type="ObjectInputStream" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
					<exception fulltype="java.lang.ClassNotFoundException" type="ClassNotFoundException" />
				</exceptions>
			</method>
			<method visibility="public" name="isMulticastAddress" returncomment="a &lt;code&gt;boolean&lt;/code&gt; indicating if the InetAddress is
 an IP multicast address" fulltype="boolean" type="boolean">
				<comment>
					<description>Utility routine to check if the InetAddress is an IP multicast
 address. 11111111 at the start of the address identifies the
 address as being a multicast address.</description>
					<attribute name="@return">
						<description>a &lt;code&gt;boolean&lt;/code&gt; indicating if the InetAddress is
 an IP multicast address</description>
					</attribute>
					<attribute name="@since">
						<description>JDK1.1</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="isAnyLocalAddress" returncomment="a &lt;code&gt;boolean&lt;/code&gt; indicating if the Inetaddress is
         a wildcard address." fulltype="boolean" type="boolean">
				<comment>
					<description>Utility routine to check if the InetAddress in a wildcard address.</description>
					<attribute name="@return">
						<description>a &lt;code&gt;boolean&lt;/code&gt; indicating if the Inetaddress is
         a wildcard address.</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="isLoopbackAddress" returncomment="a &lt;code&gt;boolean&lt;/code&gt; indicating if the InetAddress is
 a loopback address; or false otherwise." fulltype="boolean" type="boolean">
				<comment>
					<description>Utility routine to check if the InetAddress is a loopback address.</description>
					<attribute name="@return">
						<description>a &lt;code&gt;boolean&lt;/code&gt; indicating if the InetAddress is
 a loopback address; or false otherwise.</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="isLinkLocalAddress" returncomment="a &lt;code&gt;boolean&lt;/code&gt; indicating if the InetAddress is
 a link local address; or false if address is not a link local unicast address." fulltype="boolean" type="boolean">
				<comment>
					<description>Utility routine to check if the InetAddress is an link local address.</description>
					<attribute name="@return">
						<description>a &lt;code&gt;boolean&lt;/code&gt; indicating if the InetAddress is
 a link local address; or false if address is not a link local unicast address.</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="isSiteLocalAddress" returncomment="a &lt;code&gt;boolean&lt;/code&gt; indicating if the InetAddress is
 a site local address; or false if address is not a site local unicast address." fulltype="boolean" type="boolean">
				<comment>
					<description>Utility routine to check if the InetAddress is a site local address.</description>
					<attribute name="@return">
						<description>a &lt;code&gt;boolean&lt;/code&gt; indicating if the InetAddress is
 a site local address; or false if address is not a site local unicast address.</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="isMCGlobal" returncomment="a &lt;code&gt;boolean&lt;/code&gt; indicating if the address has
         is a multicast address of global scope, false if it is not
         of global scope or it is not a multicast address" fulltype="boolean" type="boolean">
				<comment>
					<description>Utility routine to check if the multicast address has global scope.</description>
					<attribute name="@return">
						<description>a &lt;code&gt;boolean&lt;/code&gt; indicating if the address has
         is a multicast address of global scope, false if it is not
         of global scope or it is not a multicast address</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="isMCNodeLocal" returncomment="a &lt;code&gt;boolean&lt;/code&gt; indicating if the address has
         is a multicast address of node-local scope, false if it is not
         of node-local scope or it is not a multicast address" fulltype="boolean" type="boolean">
				<comment>
					<description>Utility routine to check if the multicast address has node scope.</description>
					<attribute name="@return">
						<description>a &lt;code&gt;boolean&lt;/code&gt; indicating if the address has
         is a multicast address of node-local scope, false if it is not
         of node-local scope or it is not a multicast address</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="isMCLinkLocal" returncomment="a &lt;code&gt;boolean&lt;/code&gt; indicating if the address has
         is a multicast address of link-local scope, false if it is not
         of link-local scope or it is not a multicast address" fulltype="boolean" type="boolean">
				<comment>
					<description>Utility routine to check if the multicast address has link scope.</description>
					<attribute name="@return">
						<description>a &lt;code&gt;boolean&lt;/code&gt; indicating if the address has
         is a multicast address of link-local scope, false if it is not
         of link-local scope or it is not a multicast address</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="isMCSiteLocal" returncomment="a &lt;code&gt;boolean&lt;/code&gt; indicating if the address has
         is a multicast address of site-local scope, false if it is not
         of site-local scope or it is not a multicast address" fulltype="boolean" type="boolean">
				<comment>
					<description>Utility routine to check if the multicast address has site scope.</description>
					<attribute name="@return">
						<description>a &lt;code&gt;boolean&lt;/code&gt; indicating if the address has
         is a multicast address of site-local scope, false if it is not
         of site-local scope or it is not a multicast address</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="isMCOrgLocal" returncomment="a &lt;code&gt;boolean&lt;/code&gt; indicating if the address has
         is a multicast address of organization-local scope,
         false if it is not of organization-local scope
         or it is not a multicast address" fulltype="boolean" type="boolean">
				<comment>
					<description>Utility routine to check if the multicast address has organization scope.</description>
					<attribute name="@return">
						<description>a &lt;code&gt;boolean&lt;/code&gt; indicating if the address has
         is a multicast address of organization-local scope,
         false if it is not of organization-local scope
         or it is not a multicast address</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getAddress" returncomment="the raw IP address of this object." fulltype="byte[]" type="byte">
				<comment>
					<description>Returns the raw IP address of this &lt;code&gt;InetAddress&lt;/code&gt;
 object. The result is in network byte order: the highest order
 byte of the address is in &lt;code&gt;getAddress()[0]&lt;/code&gt;.</description>
					<attribute name="@return">
						<description>the raw IP address of this object.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getScopeId" returncomment="the scopeId, or zero if not set." fulltype="int" type="int">
				<comment>
					<description>Returns the numeric scopeId, if this instance is associated with
 an interface. If no scoped_id is set, the returned value is zero.</description>
					<attribute name="@return">
						<description>the scopeId, or zero if not set.</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getScopedInterface" returncomment="the scoped interface, or null if not set." fulltype="java.net.NetworkInterface" type="NetworkInterface">
				<comment>
					<description>Returns the scoped interface, if this instance was created with
 with a scoped interface.</description>
					<attribute name="@return">
						<description>the scoped interface, or null if not set.</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getHostAddress" returncomment="the raw IP address in a string format." fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the IP address string in textual presentation. If the instance was created
 specifying a scope identifier then the scope id is appended to the IP address preceded by
 a &quot;%&quot; (per-cent) character. This can be either a numeric value or a string, depending on which
 was used to createthe instance.</description>
					<attribute name="@return">
						<description>the raw IP address in a string format.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="hashCode" returncomment="a hash code value for this IP address." fulltype="int" type="int">
				<comment>
					<description>Returns a hashcode for this IP address.</description>
					<attribute name="@return">
						<description>a hash code value for this IP address.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="equals" returncomment="&lt;code&gt;true&lt;/code&gt; if the objects are the same;
          &lt;code&gt;false&lt;/code&gt; otherwise." fulltype="boolean" type="boolean">
				<comment>
					<description>Compares this object against the specified object.
 The result is &lt;code&gt;true&lt;/code&gt; if and only if the argument is
 not &lt;code&gt;null&lt;/code&gt; and it represents the same IP address as
 this object.
 &lt;p&gt;
 Two instances of &lt;code&gt;InetAddress&lt;/code&gt; represent the same IP
 address if the length of the byte arrays returned by
 &lt;code&gt;getAddress&lt;/code&gt; is the same for both, and each of the
 array components is the same for the byte arrays.</description>
					<attribute name="@param">
						<description>obj   the object to compare against.</description>
					</attribute>
					<attribute name="@return">
						<description>&lt;code&gt;true&lt;/code&gt; if the objects are the same;
          &lt;code&gt;false&lt;/code&gt; otherwise.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.InetAddress#getAddress()</description>
					</attribute>
				</comment>
				<params>
					<param name="obj" comment="the object to compare against." fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method visibility="public" name="isIPv4CompatibleAddress" returncomment="a &lt;code&gt;boolean&lt;/code&gt; indicating if the InetAddress is
 an IPv4 compatible IPv6 address; or false if address is IPv4 address." fulltype="boolean" type="boolean">
				<comment>
					<description>Utility routine to check if the InetAddress is an
 IPv4 compatible IPv6 address.</description>
					<attribute name="@return">
						<description>a &lt;code&gt;boolean&lt;/code&gt; indicating if the InetAddress is
 an IPv4 compatible IPv6 address; or false if address is IPv4 address.</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</method>
			<method static="true" visibility="package-private" name="numericToTextFormat" fulltype="java.lang.String" type="String">
				<params>
					<param name="src" fulltype="byte[]" type="byte" />
				</params>
			</method>
			<method static="true" visibility="private" name="init" fulltype="void" type="void">
				<comment>
					<description>Perform class load-time initializations.</description>
				</comment>
			</method>
			<method synchronized="true" visibility="private" name="writeObject" fulltype="void" type="void">
				<comment>
					<description>default behavior is overridden in order to write the
 scope_ifname field as a String, rather than a NetworkInterface
 which is not serializable</description>
				</comment>
				<params>
					<param name="s" fulltype="java.io.ObjectOutputStream" type="ObjectOutputStream" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass abstract="true" superclass="Object" visibility="public" package="java.net" superclassfulltype="java.lang.Object" fulltype="java.net.ResponseCache" type="ResponseCache">
		<comment>
			<description>Represents implementations of URLConnection caches. An instance of
 such a class can be registered with the system by doing
 ResponseCache.setDefault(ResponseCache), and the system will call
 this object in order to:

    &lt;ul&gt;&lt;li&gt;store resource data which has been retrieved from an
            external source into the cache&lt;/li&gt;
         &lt;li&gt;try to fetch a requested resource that may have been
            stored in the cache&lt;/li&gt;
    &lt;/ul&gt;

 The ResponseCache implementation decides which resources
 should be cached, and for how long they should be cached. If a
 request resource cannot be retrieved from the cache, then the
 protocol handlers will fetch the resource from its original
 location.

 The settings for URLConnection#useCaches controls whether the
 protocol is allowed to use a cached response.

 For more information on HTTP caching, see &lt;a
 href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2616: Hypertext
 Transfer Protocol -- HTTP/1.1&lt;/i&gt;&lt;/a&gt;</description>
			<attribute name="@author">
				<description>Yingxian Wang</description>
			</attribute>
			<attribute name="@since">
				<description>1.5</description>
			</attribute>
		</comment>
		<fields>
			<field static="true" visibility="private" name="theResponseCache" fulltype="java.net.ResponseCache" type="ResponseCache">
				<comment>
					<description>The system wide cache that provides access to a url
 caching mechanism.</description>
					<attribute name="@see">
						<description>#setDefault(ResponseCache)</description>
					</attribute>
					<attribute name="@see">
						<description>#getDefault()</description>
					</attribute>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="public" name="ResponseCache" />
			<method static="true" synchronized="true" visibility="public" name="getDefault" returncomment="the system-wide &lt;code&gt;ResponseCache&lt;/code&gt;" fulltype="java.net.ResponseCache" type="ResponseCache">
				<comment>
					<description>Gets the system-wide response cache.</description>
					<attribute name="@throws">
						<description>SecurityException
          If a security manager has been installed and it denies
 {@link NetPermission}&lt;tt&gt;(&quot;getResponseCache&quot;)&lt;/tt&gt;</description>
					</attribute>
					<attribute name="@see">
						<description>#setDefault(ResponseCache)</description>
					</attribute>
					<attribute name="@return">
						<description>the system-wide &lt;code&gt;ResponseCache&lt;/code&gt;</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
			</method>
			<method static="true" synchronized="true" visibility="public" name="setDefault" fulltype="void" type="void">
				<comment>
					<description>Sets (or unsets) the system-wide cache.

 Note: non-standard procotol handlers may ignore this setting.</description>
					<attribute name="@param">
						<description>responseCache The response cache, or
          &lt;code&gt;null&lt;/code&gt; to unset the cache.</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException
          If a security manager has been installed and it denies
 {@link NetPermission}&lt;tt&gt;(&quot;setResponseCache&quot;)&lt;/tt&gt;</description>
					</attribute>
					<attribute name="@see">
						<description>#getDefault()</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
				<params>
					<param name="responseCache" comment="The response cache, or
          &lt;code&gt;null&lt;/code&gt; to unset the cache." fulltype="java.net.ResponseCache" type="ResponseCache" />
				</params>
			</method>
			<method abstract="true" visibility="public" name="get" returncomment="a &lt;code&gt;CacheResponse&lt;/code&gt; instance if available
          from cache, or null otherwise" fulltype="java.net.CacheResponse" type="CacheResponse">
				<comment>
					<description>Retrieve the cached response based on the requesting uri,
 request method and request headers. Typically this method is
 called by the protocol handler before it sends out the request
 to get the network resource. If a cached response is returned,
 that resource is used instead.</description>
					<attribute name="@param">
						<description>uri a &lt;code&gt;URI&lt;/code&gt; used to reference the requested
            network resource</description>
					</attribute>
					<attribute name="@param">
						<description>rqstMethod a &lt;code&gt;String&lt;/code&gt; representing the request
            method</description>
					</attribute>
					<attribute name="@param">
						<description>rqstHeaders - a Map from request header
            field names to lists of field values representing
            the current request headers</description>
					</attribute>
					<attribute name="@return">
						<description>a &lt;code&gt;CacheResponse&lt;/code&gt; instance if available
          from cache, or null otherwise</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException if an I/O error occurs</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if any one of the arguments is null</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URLConnection#setUseCaches(boolean)</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URLConnection#getUseCaches()</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URLConnection#setDefaultUseCaches(boolean)</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URLConnection#getDefaultUseCaches()</description>
					</attribute>
				</comment>
				<params>
					<param name="uri" comment="a &lt;code&gt;URI&lt;/code&gt; used to reference the requested
            network resource" fulltype="java.net.URI" type="URI" />
					<param name="rqstMethod" comment="a &lt;code&gt;String&lt;/code&gt; representing the request
            method" fulltype="java.lang.String" type="String" />
					<param name="rqstHeaders" comment="- a Map from request header
            field names to lists of field values representing
            the current request headers" fulltype="java.util.Map" type="Map" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="public" name="put" returncomment="a &lt;code&gt;CacheRequest&lt;/code&gt; for recording the
            response to be cached. Null return indicates that
            the caller does not intend to cache the response." fulltype="java.net.CacheRequest" type="CacheRequest">
				<comment>
					<description>The protocol handler calls this method after a resource has
 been retrieved, and the ResponseCache must decide whether or
 not to store the resource in its cache. If the resource is to
 be cached, then put() must return a CacheRequest object which
 contains an OutputStream that the protocol handler will
 use to write the resource into the cache. If the resource is
 not to be cached, then put must return null.</description>
					<attribute name="@param">
						<description>uri a &lt;code&gt;URI&lt;/code&gt; used to reference the requested
            network resource</description>
					</attribute>
					<attribute name="@param">
						<description>conn - a URLConnection instance that is used to fetch
            the response to be cached</description>
					</attribute>
					<attribute name="@return">
						<description>a &lt;code&gt;CacheRequest&lt;/code&gt; for recording the
            response to be cached. Null return indicates that
            the caller does not intend to cache the response.</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException if an I/O error occurs</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if any one of the arguments is
            null</description>
					</attribute>
				</comment>
				<params>
					<param name="uri" comment="a &lt;code&gt;URI&lt;/code&gt; used to reference the requested
            network resource" fulltype="java.net.URI" type="URI" />
					<param name="conn" comment="- a URLConnection instance that is used to fetch
            the response to be cached" fulltype="java.net.URLConnection" type="URLConnection" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass abstract="true" visibility="public" package="java.net" interface="true" fulltype="java.net.URLStreamHandlerFactory" type="URLStreamHandlerFactory">
		<comment>
			<description>This interface defines a factory for &lt;code&gt;URL&lt;/code&gt; stream
 protocol handlers.
 &lt;p&gt;
 It is used by the &lt;code&gt;URL&lt;/code&gt; class to create a
 &lt;code&gt;URLStreamHandler&lt;/code&gt; for a specific protocol.</description>
			<attribute name="@author">
				<description>Arthur van Hoff</description>
			</attribute>
			<attribute name="@see">
				<description>java.net.URL</description>
			</attribute>
			<attribute name="@see">
				<description>java.net.URLStreamHandler</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.0</description>
			</attribute>
		</comment>
		<methods>
			<method visibility="public" name="createURLStreamHandler" returncomment="a &lt;code&gt;URLStreamHandler&lt;/code&gt; for the specific protocol." fulltype="java.net.URLStreamHandler" type="URLStreamHandler">
				<comment>
					<description>Creates a new &lt;code&gt;URLStreamHandler&lt;/code&gt; instance with the specified
 protocol.</description>
					<attribute name="@param">
						<description>protocol   the protocol (&quot;&lt;code&gt;ftp&lt;/code&gt;&quot;,
                     &quot;&lt;code&gt;http&lt;/code&gt;&quot;, &quot;&lt;code&gt;nntp&lt;/code&gt;&quot;, etc.).</description>
					</attribute>
					<attribute name="@return">
						<description>a &lt;code&gt;URLStreamHandler&lt;/code&gt; for the specific protocol.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URLStreamHandler</description>
					</attribute>
				</comment>
				<params>
					<param name="protocol" comment="the protocol (&quot;&lt;code&gt;ftp&lt;/code&gt;&quot;,
                     &quot;&lt;code&gt;http&lt;/code&gt;&quot;, &quot;&lt;code&gt;nntp&lt;/code&gt;&quot;, etc.)." fulltype="java.lang.String" type="String" />
				</params>
			</method>
		</methods>
	</jelclass>
	<jelclass final="true" superclass="Object" visibility="public" package="java.net" superclassfulltype="java.lang.Object" fulltype="java.net.HttpCookie" type="HttpCookie">
		<implements>
			<interface fulltype="java.lang.Cloneable" type="Cloneable" />
		</implements>
		<comment>
			<description>An HttpCookie object represents an http cookie, which carries state
 information between server and user agent. Cookie is widely adopted
 to create stateful sessions.

 &lt;p&gt;There are 3 http cookie specifications:
 &lt;blockquote&gt;
   Netscape draft&lt;br&gt;
   RFC 2109 - &lt;a href=&quot;http://www.ietf.org/rfc/rfc2109.txt&quot;&gt;
 &lt;i&gt;http://www.ietf.org/rfc/rfc2109.txt&lt;/i&gt;&lt;/a&gt;&lt;br&gt;
   RFC 2965 - &lt;a href=&quot;http://www.ietf.org/rfc/rfc2965.txt&quot;&gt;
 &lt;i&gt;http://www.ietf.org/rfc/rfc2965.txt&lt;/i&gt;&lt;/a&gt;
 &lt;/blockquote&gt;

 &lt;p&gt;HttpCookie class can accept all these 3 forms of syntax.</description>
			<attribute name="@author">
				<description>Edward Wang</description>
			</attribute>
			<attribute name="@since">
				<description>1.6</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="private" name="name" fulltype="java.lang.String" type="String" />
			<field visibility="private" name="value" fulltype="java.lang.String" type="String" />
			<field visibility="private" name="comment" fulltype="java.lang.String" type="String" />
			<field visibility="private" name="commentURL" fulltype="java.lang.String" type="String" />
			<field visibility="private" name="toDiscard" fulltype="boolean" type="boolean" />
			<field visibility="private" name="domain" fulltype="java.lang.String" type="String" />
			<field visibility="private" name="maxAge" fulltype="long" type="long" />
			<field visibility="private" name="path" fulltype="java.lang.String" type="String" />
			<field visibility="private" name="portlist" fulltype="java.lang.String" type="String" />
			<field visibility="private" name="secure" fulltype="boolean" type="boolean" />
			<field visibility="private" name="version" fulltype="int" type="int" />
			<field visibility="private" name="whenCreated" fulltype="long" type="long" />
			<field final="true" static="true" const="-1" visibility="private" name="MAX_AGE_UNSPECIFIED" constexpr="-1L" fulltype="long" type="long" />
			<field final="true" static="true" const="EEE&apos;,&apos; dd-MMM-yyyy HH:mm:ss &apos;GMT&apos;" visibility="private" name="NETSCAPE_COOKIE_DATE_FORMAT" constexpr="&quot;EEE\&apos;,\&apos; dd-MMM-yyyy HH:mm:ss \&apos;GMT\&apos;&quot;" fulltype="java.lang.String" type="String" />
			<field final="true" static="true" const="set-cookie:" visibility="private" name="SET_COOKIE" constexpr="&quot;set-cookie:&quot;" fulltype="java.lang.String" type="String" />
			<field final="true" static="true" const="set-cookie2:" visibility="private" name="SET_COOKIE2" constexpr="&quot;set-cookie2:&quot;" fulltype="java.lang.String" type="String" />
			<field final="true" static="true" const=",;" visibility="private" name="tspecials" constexpr="&quot;,;&quot;" fulltype="java.lang.String" type="String" />
			<field static="true" visibility="package-private" name="assignors" fulltype="java.util.Map" type="Map" />
		</fields>
		<methods>
			<constructor visibility="public" name="HttpCookie">
				<comment>
					<description>Constructs a cookie with a specified name and value.

 &lt;p&gt;The name must conform to RFC 2965. That means it can contain
 only ASCII alphanumeric characters and cannot contain commas,
 semicolons, or white space or begin with a $ character. The cookie&apos;s
 name cannot be changed after creation.

 &lt;p&gt;The value can be anything the server chooses to send. Its
 value is probably of interest only to the server. The cookie&apos;s
 value can be changed after creation with the
 &lt;code&gt;setValue&lt;/code&gt; method.

 &lt;p&gt;By default, cookies are created according to the RFC 2965
 cookie specification. The version can be changed with the
 &lt;code&gt;setVersion&lt;/code&gt; method.</description>
					<attribute name="@param">
						<description>name                      a &lt;code&gt;String&lt;/code&gt; specifying the name of the cookie</description>
					</attribute>
					<attribute name="@param">
						<description>value                     a &lt;code&gt;String&lt;/code&gt; specifying the value of the cookie</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if the cookie name contains illegal characters
                                  or it is one of the tokens reserved for use
                                  by the cookie protocol</description>
					</attribute>
					<attribute name="@throws">
						<description>NullPointerException     if &lt;tt&gt;name&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;</description>
					</attribute>
					<attribute name="@see">
						<description>#setValue</description>
					</attribute>
					<attribute name="@see">
						<description>#setVersion</description>
					</attribute>
				</comment>
				<params>
					<param name="name" comment="a &lt;code&gt;String&lt;/code&gt; specifying the name of the cookie" fulltype="java.lang.String" type="String" />
					<param name="value" comment="a &lt;code&gt;String&lt;/code&gt; specifying the value of the cookie" fulltype="java.lang.String" type="String" />
				</params>
			</constructor>
			<method static="true" visibility="public" name="parse" returncomment="a List of cookie parsed from header line string" fulltype="java.util.List" type="List">
				<comment>
					<description>Constructs cookies from set-cookie or set-cookie2 header string.
 RFC 2965 section 3.2.2 set-cookie2 syntax indicates that one header line
 may contain more than one cookie definitions, so this is a static
 utility method instead of another constructor.</description>
					<attribute name="@param">
						<description>header    a &lt;tt&gt;String&lt;/tt&gt; specifying the set-cookie header.
                  The header should start with &quot;set-cookie&quot;, or &quot;set-cookie2&quot;
                  token; or it should have no leading token at all.</description>
					</attribute>
					<attribute name="@return">
						<description>a List of cookie parsed from header line string</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if header string violates the cookie
                                  specification&apos;s syntax, or the cookie
                                  name contains llegal characters, or
                                  the cookie name is one of the tokens
                                  reserved for use by the cookie protocol</description>
					</attribute>
					<attribute name="@throws">
						<description>NullPointerException     if the header string is &lt;tt&gt;null&lt;/tt&gt;</description>
					</attribute>
				</comment>
				<params>
					<param name="header" comment="a &lt;tt&gt;String&lt;/tt&gt; specifying the set-cookie header.
                  The header should start with &quot;set-cookie&quot;, or &quot;set-cookie2&quot;
                  token; or it should have no leading token at all." fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="public" name="hasExpired" returncomment="&lt;tt&gt;true&lt;/tt&gt; to indicate this http cookie has expired;
          otherwise, &lt;tt&gt;false&lt;/tt&gt;" fulltype="boolean" type="boolean">
				<comment>
					<description>Reports whether this http cookie has expired or not.</description>
					<attribute name="@return">
						<description>&lt;tt&gt;true&lt;/tt&gt; to indicate this http cookie has expired;
          otherwise, &lt;tt&gt;false&lt;/tt&gt;</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="setComment" fulltype="void" type="void">
				<comment>
					<description>Specifies a comment that describes a cookie&apos;s purpose.
 The comment is useful if the browser presents the cookie
 to the user. Comments
 are not supported by Netscape Version 0 cookies.</description>
					<attribute name="@param">
						<description>purpose           a &lt;code&gt;String&lt;/code&gt; specifying the comment
                          to display to the user</description>
					</attribute>
					<attribute name="@see">
						<description>#getComment</description>
					</attribute>
				</comment>
				<params>
					<param name="purpose" comment="a &lt;code&gt;String&lt;/code&gt; specifying the comment
                          to display to the user" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="public" name="getComment" returncomment="a &lt;code&gt;String&lt;/code&gt; containing the comment,
                          or &lt;code&gt;null&lt;/code&gt; if none" fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the comment describing the purpose of this cookie, or
 &lt;code&gt;null&lt;/code&gt; if the cookie has no comment.</description>
					<attribute name="@return">
						<description>a &lt;code&gt;String&lt;/code&gt; containing the comment,
                          or &lt;code&gt;null&lt;/code&gt; if none</description>
					</attribute>
					<attribute name="@see">
						<description>#setComment</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="setCommentURL" fulltype="void" type="void">
				<comment>
					<description>Specifies a comment url that describes a cookie&apos;s purpose.
 The comment url is useful if the browser presents the cookie
 to the user. Comment url is RFC 2965 only.</description>
					<attribute name="@param">
						<description>purpose           a &lt;code&gt;String&lt;/code&gt; specifying the comment url
                          to display to the user</description>
					</attribute>
					<attribute name="@see">
						<description>#getCommentURL</description>
					</attribute>
				</comment>
				<params>
					<param name="purpose" comment="a &lt;code&gt;String&lt;/code&gt; specifying the comment url
                          to display to the user" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="public" name="getCommentURL" returncomment="a &lt;code&gt;String&lt;/code&gt; containing the comment url,
                          or &lt;code&gt;null&lt;/code&gt; if none" fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the comment url describing the purpose of this cookie, or
 &lt;code&gt;null&lt;/code&gt; if the cookie has no comment url.</description>
					<attribute name="@return">
						<description>a &lt;code&gt;String&lt;/code&gt; containing the comment url,
                          or &lt;code&gt;null&lt;/code&gt; if none</description>
					</attribute>
					<attribute name="@see">
						<description>#setCommentURL</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="setDiscard" fulltype="void" type="void">
				<comment>
					<description>Specify whether user agent should discard the cookie unconditionally.
 This is RFC 2965 only attribute.</description>
					<attribute name="@param">
						<description>discard   &lt;tt&gt;true&lt;/tt&gt; indicates to discard cookie unconditionally</description>
					</attribute>
					<attribute name="@see">
						<description>#getDiscard</description>
					</attribute>
				</comment>
				<params>
					<param name="discard" comment="&lt;tt&gt;true&lt;/tt&gt; indicates to discard cookie unconditionally" fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method visibility="public" name="getDiscard" returncomment="a &lt;tt&gt;boolean&lt;/tt&gt; to represent this cookie&apos;s discard attribute" fulltype="boolean" type="boolean">
				<comment>
					<description>Return the discard attribute of the cookie</description>
					<attribute name="@return">
						<description>a &lt;tt&gt;boolean&lt;/tt&gt; to represent this cookie&apos;s discard attribute</description>
					</attribute>
					<attribute name="@see">
						<description>#setDiscard</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="setPortlist" fulltype="void" type="void">
				<comment>
					<description>Specify the portlist of the cookie, which restricts the port(s)
 to which a cookie may be sent back in a Cookie header.</description>
					<attribute name="@param">
						<description>ports     a &lt;tt&gt;String&lt;/tt&gt; specify the port list, which is
                  comma seperated series of digits</description>
					</attribute>
					<attribute name="@see">
						<description>#getPortlist</description>
					</attribute>
				</comment>
				<params>
					<param name="ports" comment="a &lt;tt&gt;String&lt;/tt&gt; specify the port list, which is
                  comma seperated series of digits" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="public" name="getPortlist" returncomment="a &lt;tt&gt;String&lt;/tt&gt; contains the port list
          or &lt;tt&gt;null&lt;/tt&gt; if none" fulltype="java.lang.String" type="String">
				<comment>
					<description>Return the port list attribute of the cookie</description>
					<attribute name="@return">
						<description>a &lt;tt&gt;String&lt;/tt&gt; contains the port list
          or &lt;tt&gt;null&lt;/tt&gt; if none</description>
					</attribute>
					<attribute name="@see">
						<description>#setPortlist</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="setDomain" fulltype="void" type="void">
				<comment>
					<description>Specifies the domain within which this cookie should be presented.

 &lt;p&gt;The form of the domain name is specified by RFC 2965. A domain
 name begins with a dot (&lt;code&gt;.foo.com&lt;/code&gt;) and means that
 the cookie is visible to servers in a specified Domain Name System
 (DNS) zone (for example, &lt;code&gt;www.foo.com&lt;/code&gt;, but not
 &lt;code&gt;a.b.foo.com&lt;/code&gt;). By default, cookies are only returned
 to the server that sent them.</description>
					<attribute name="@param">
						<description>pattern           a &lt;code&gt;String&lt;/code&gt; containing the domain name
                          within which this cookie is visible;
                          form is according to RFC 2965</description>
					</attribute>
					<attribute name="@see">
						<description>#getDomain</description>
					</attribute>
				</comment>
				<params>
					<param name="pattern" comment="a &lt;code&gt;String&lt;/code&gt; containing the domain name
                          within which this cookie is visible;
                          form is according to RFC 2965" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="public" name="getDomain" returncomment="a &lt;code&gt;String&lt;/code&gt; containing the domain name" fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the domain name set for this cookie. The form of
 the domain name is set by RFC 2965.</description>
					<attribute name="@return">
						<description>a &lt;code&gt;String&lt;/code&gt; containing the domain name</description>
					</attribute>
					<attribute name="@see">
						<description>#setDomain</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="setMaxAge" fulltype="void" type="void">
				<comment>
					<description>Sets the maximum age of the cookie in seconds.

 &lt;p&gt;A positive value indicates that the cookie will expire
 after that many seconds have passed. Note that the value is
 the &lt;i&gt;maximum&lt;/i&gt; age when the cookie will expire, not the cookie&apos;s
 current age.

 &lt;p&gt;A negative value means
 that the cookie is not stored persistently and will be deleted
 when the Web browser exits. A zero value causes the cookie
 to be deleted.</description>
					<attribute name="@param">
						<description>expiry            an integer specifying the maximum age of the
                          cookie in seconds; if zero, the cookie
                          should be discarded immediately;
                          otherwise, the cookie&apos;s max age is unspecified.</description>
					</attribute>
					<attribute name="@see">
						<description>#getMaxAge</description>
					</attribute>
				</comment>
				<params>
					<param name="expiry" comment="an integer specifying the maximum age of the
                          cookie in seconds; if zero, the cookie
                          should be discarded immediately;
                          otherwise, the cookie&apos;s max age is unspecified." fulltype="long" type="long" />
				</params>
			</method>
			<method visibility="public" name="getMaxAge" returncomment="an integer specifying the maximum age of the
                          cookie in seconds" fulltype="long" type="long">
				<comment>
					<description>Returns the maximum age of the cookie, specified in seconds.
 By default, &lt;code&gt;-1&lt;/code&gt; indicating the cookie will persist
 until browser shutdown.</description>
					<attribute name="@return">
						<description>an integer specifying the maximum age of the
                          cookie in seconds</description>
					</attribute>
					<attribute name="@see">
						<description>#setMaxAge</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="setPath" fulltype="void" type="void">
				<comment>
					<description>Specifies a path for the cookie
 to which the client should return the cookie.

 &lt;p&gt;The cookie is visible to all the pages in the directory
 you specify, and all the pages in that directory&apos;s subdirectories.
 A cookie&apos;s path must include the servlet that set the cookie,
 for example, &lt;i&gt;/catalog&lt;/i&gt;, which makes the cookie
 visible to all directories on the server under &lt;i&gt;/catalog&lt;/i&gt;.

 &lt;p&gt;Consult RFC 2965 (available on the Internet) for more
 information on setting path names for cookies.</description>
					<attribute name="@param">
						<description>uri               a &lt;code&gt;String&lt;/code&gt; specifying a path</description>
					</attribute>
					<attribute name="@see">
						<description>#getPath</description>
					</attribute>
				</comment>
				<params>
					<param name="uri" comment="a &lt;code&gt;String&lt;/code&gt; specifying a path" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="public" name="getPath" returncomment="a &lt;code&gt;String&lt;/code&gt; specifying a path that contains
                  a servlet name, for example, &lt;i&gt;/catalog&lt;/i&gt;" fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the path on the server
 to which the browser returns this cookie. The
 cookie is visible to all subpaths on the server.</description>
					<attribute name="@return">
						<description>a &lt;code&gt;String&lt;/code&gt; specifying a path that contains
                  a servlet name, for example, &lt;i&gt;/catalog&lt;/i&gt;</description>
					</attribute>
					<attribute name="@see">
						<description>#setPath</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="setSecure" fulltype="void" type="void">
				<comment>
					<description>Indicates to the browser whether the cookie should only be sent
 using a secure protocol, such as HTTPS or SSL.

 &lt;p&gt;The default value is &lt;code&gt;false&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>flag      if &lt;code&gt;true&lt;/code&gt;, sends the cookie from the browser
                  to the server using only when using a secure protocol;
                  if &lt;code&gt;false&lt;/code&gt;, sent on any protocol</description>
					</attribute>
					<attribute name="@see">
						<description>#getSecure</description>
					</attribute>
				</comment>
				<params>
					<param name="flag" comment="if &lt;code&gt;true&lt;/code&gt;, sends the cookie from the browser
                  to the server using only when using a secure protocol;
                  if &lt;code&gt;false&lt;/code&gt;, sent on any protocol" fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method visibility="public" name="getSecure" returncomment="&lt;code&gt;true&lt;/code&gt; if the browser can use
                  any standard protocol; otherwise, &lt;code&gt;false&lt;/code&gt;" fulltype="boolean" type="boolean">
				<comment>
					<description>Returns &lt;code&gt;true&lt;/code&gt; if the browser is sending cookies
 only over a secure protocol, or &lt;code&gt;false&lt;/code&gt; if the
 browser can send cookies using any protocol.</description>
					<attribute name="@return">
						<description>&lt;code&gt;true&lt;/code&gt; if the browser can use
                  any standard protocol; otherwise, &lt;code&gt;false&lt;/code&gt;</description>
					</attribute>
					<attribute name="@see">
						<description>#setSecure</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getName" returncomment="a &lt;code&gt;String&lt;/code&gt; specifying the cookie&apos;s name" fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the name of the cookie. The name cannot be changed after
 creation.</description>
					<attribute name="@return">
						<description>a &lt;code&gt;String&lt;/code&gt; specifying the cookie&apos;s name</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="setValue" fulltype="void" type="void">
				<comment>
					<description>Assigns a new value to a cookie after the cookie is created.
 If you use a binary value, you may want to use BASE64 encoding.

 &lt;p&gt;With Version 0 cookies, values should not contain white
 space, brackets, parentheses, equals signs, commas,
 double quotes, slashes, question marks, at signs, colons,
 and semicolons. Empty values may not behave the same way
 on all browsers.</description>
					<attribute name="@param">
						<description>newValue          a &lt;code&gt;String&lt;/code&gt; specifying the new value</description>
					</attribute>
					<attribute name="@see">
						<description>#getValue</description>
					</attribute>
				</comment>
				<params>
					<param name="newValue" comment="a &lt;code&gt;String&lt;/code&gt; specifying the new value" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="public" name="getValue" returncomment="a &lt;code&gt;String&lt;/code&gt; containing the cookie&apos;s
                          present value" fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the value of the cookie.</description>
					<attribute name="@return">
						<description>a &lt;code&gt;String&lt;/code&gt; containing the cookie&apos;s
                          present value</description>
					</attribute>
					<attribute name="@see">
						<description>#setValue</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getVersion" returncomment="0 if the cookie complies with the
                          original Netscape specification; 1
                          if the cookie complies with RFC 2965/2109" fulltype="int" type="int">
				<comment>
					<description>Returns the version of the protocol this cookie complies
 with. Version 1 complies with RFC 2965/2109,
 and version 0 complies with the original
 cookie specification drafted by Netscape. Cookies provided
 by a browser use and identify the browser&apos;s cookie version.</description>
					<attribute name="@return">
						<description>0 if the cookie complies with the
                          original Netscape specification; 1
                          if the cookie complies with RFC 2965/2109</description>
					</attribute>
					<attribute name="@see">
						<description>#setVersion</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="setVersion" fulltype="void" type="void">
				<comment>
					<description>Sets the version of the cookie protocol this cookie complies
 with. Version 0 complies with the original Netscape cookie
 specification. Version 1 complies with RFC 2965/2109.</description>
					<attribute name="@param">
						<description>v                 0 if the cookie should comply with
                          the original Netscape specification;
                          1 if the cookie should comply with RFC 2965/2109</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if &lt;tt&gt;v&lt;/tt&gt; is neither 0 nor 1</description>
					</attribute>
					<attribute name="@see">
						<description>#getVersion</description>
					</attribute>
				</comment>
				<params>
					<param name="v" comment="0 if the cookie should comply with
                          the original Netscape specification;
                          1 if the cookie should comply with RFC 2965/2109" fulltype="int" type="int" />
				</params>
			</method>
			<method static="true" visibility="public" name="domainMatches" returncomment="&lt;tt&gt;true&lt;/tt&gt; if they domain-matches; &lt;tt&gt;false&lt;/tt&gt; if not" fulltype="boolean" type="boolean">
				<comment>
					<description>The utility method to check whether a host name is in a domain
 or not.

 &lt;p&gt;This concept is described in the cookie specification.
 To understand the concept, some terminologies need to be defined first:
 &lt;blockquote&gt;
 effective host name = hostname if host name contains dot&lt;br&gt;
 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;or = hostname.local if not
 &lt;/blockquote&gt;
 &lt;p&gt;Host A&apos;s name domain-matches host B&apos;s if:
 &lt;blockquote&gt;&lt;ul&gt;
   &lt;li&gt;their host name strings string-compare equal; or&lt;/li&gt;
   &lt;li&gt;A is a HDN string and has the form NB, where N is a non-empty
   name string, B has the form .B&apos;, and B&apos; is a HDN string.  (So,
   x.y.com domain-matches .Y.com but not Y.com.)&lt;/li&gt;
 &lt;/ul&gt;&lt;/blockquote&gt;

 &lt;p&gt;A host isn&apos;t in a domain (RFC 2965 sec. 3.3.2) if:
 &lt;blockquote&gt;&lt;ul&gt;
   &lt;li&gt;The value for the Domain attribute contains no embedded dots,
   and the value is not .local.&lt;/li&gt;
   &lt;li&gt;The effective host name that derives from the request-host does
   not domain-match the Domain attribute.&lt;/li&gt;
   &lt;li&gt;The request-host is a HDN (not IP address) and has the form HD,
   where D is the value of the Domain attribute, and H is a string
   that contains one or more dots.&lt;/li&gt;
 &lt;/ul&gt;&lt;/blockquote&gt;

 &lt;p&gt;Examples:
 &lt;blockquote&gt;&lt;ul&gt;
   &lt;li&gt;A Set-Cookie2 from request-host y.x.foo.com for Domain=.foo.com
   would be rejected, because H is y.x and contains a dot.&lt;/li&gt;
   &lt;li&gt;A Set-Cookie2 from request-host x.foo.com for Domain=.foo.com
   would be accepted.&lt;/li&gt;
   &lt;li&gt;A Set-Cookie2 with Domain=.com or Domain=.com., will always be
   rejected, because there is no embedded dot.&lt;/li&gt;
   &lt;li&gt;A Set-Cookie2 with Domain=ajax.com will be accepted, and the
   value for Domain will be taken to be .ajax.com, because a dot
   gets prepended to the value.&lt;/li&gt;
   &lt;li&gt;A Set-Cookie2 from request-host example for Domain=.local will
   be accepted, because the effective host name for the request-
   host is example.local, and example.local domain-matches .local.&lt;/li&gt;
 &lt;/ul&gt;&lt;/blockquote&gt;</description>
					<attribute name="@param">
						<description>domain    the domain name to check host name with</description>
					</attribute>
					<attribute name="@param">
						<description>host      the host name in question</description>
					</attribute>
					<attribute name="@return">
						<description>&lt;tt&gt;true&lt;/tt&gt; if they domain-matches; &lt;tt&gt;false&lt;/tt&gt; if not</description>
					</attribute>
				</comment>
				<params>
					<param name="domain" comment="the domain name to check host name with" fulltype="java.lang.String" type="String" />
					<param name="host" comment="the host name in question" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="public" name="toString" returncomment="a string form of the cookie. The string has the defined format" fulltype="java.lang.String" type="String">
				<comment>
					<description>Constructs a cookie header string representation of this cookie,
 which is in the format defined by corresponding cookie specification,
 but without the leading &quot;Cookie:&quot; token.</description>
					<attribute name="@return">
						<description>a string form of the cookie. The string has the defined format</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="equals" returncomment="&lt;tt&gt;true&lt;/tt&gt; if 2 http cookies equal to each other;
                  otherwise, &lt;tt&gt;false&lt;/tt&gt;" fulltype="boolean" type="boolean">
				<comment>
					<description>Test the equality of two http cookies.

 &lt;p&gt; The result is &lt;tt&gt;true&lt;/tt&gt; only if two cookies
 come from same domain (case-insensitive),
 have same name (case-insensitive),
 and have same path (case-sensitive).</description>
					<attribute name="@return">
						<description>&lt;tt&gt;true&lt;/tt&gt; if 2 http cookies equal to each other;
                  otherwise, &lt;tt&gt;false&lt;/tt&gt;</description>
					</attribute>
				</comment>
				<params>
					<param name="obj" fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method visibility="public" name="hashCode" returncomment="this http cookie&apos;s hash code" fulltype="int" type="int">
				<comment>
					<description>Return hash code of this http cookie. The result is the sum of
 hash code value of three significant components of this cookie:
 name, domain, and path.
 That is, the hash code is the value of the expression:
 &lt;blockquote&gt;
 getName().toLowerCase().hashCode()&lt;br&gt;
 + getDomain().toLowerCase().hashCode()&lt;br&gt;
 + getPath().hashCode()
 &lt;/blockquote&gt;</description>
					<attribute name="@return">
						<description>this http cookie&apos;s hash code</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="clone" returncomment="a clone of this http cookie" fulltype="java.lang.Object" type="Object">
				<comment>
					<description>Create and return a copy of this object.</description>
					<attribute name="@return">
						<description>a clone of this http cookie</description>
					</attribute>
				</comment>
			</method>
			<method static="true" visibility="private" name="isToken" fulltype="boolean" type="boolean">
				<params>
					<param name="value" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method static="true" visibility="private" name="isReserved" fulltype="boolean" type="boolean">
				<params>
					<param name="name" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method static="true" visibility="private" name="parseInternal" fulltype="java.net.HttpCookie" type="HttpCookie">
				<params>
					<param name="header" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method static="true" visibility="private" name="assignAttribute" fulltype="void" type="void">
				<params>
					<param name="cookie" fulltype="java.net.HttpCookie" type="HttpCookie" />
					<param name="attrName" fulltype="java.lang.String" type="String" />
					<param name="attrValue" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="private" name="toNetscapeHeaderString" fulltype="java.lang.String" type="String" />
			<method visibility="private" name="toRFC2965HeaderString" fulltype="java.lang.String" type="String" />
			<method visibility="private" name="expiryDate2DeltaSeconds" fulltype="long" type="long">
				<params>
					<param name="dateString" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method static="true" visibility="private" name="guessCookieVersion" fulltype="int" type="int">
				<params>
					<param name="header" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method static="true" visibility="private" name="stripOffSurroundingQuote" fulltype="java.lang.String" type="String">
				<params>
					<param name="str" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method static="true" visibility="private" name="equalsIgnoreCase" fulltype="boolean" type="boolean">
				<params>
					<param name="s" fulltype="java.lang.String" type="String" />
					<param name="t" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method static="true" visibility="private" name="equals" fulltype="boolean" type="boolean">
				<params>
					<param name="s" fulltype="java.lang.String" type="String" />
					<param name="t" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method static="true" visibility="private" name="startsWithIgnoreCase" fulltype="boolean" type="boolean">
				<params>
					<param name="s" fulltype="java.lang.String" type="String" />
					<param name="start" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method static="true" visibility="private" name="splitMultiCookies" fulltype="java.util.List" type="List">
				<params>
					<param name="header" fulltype="java.lang.String" type="String" />
				</params>
			</method>
		</methods>
		<jelclass abstract="true" visibility="package-private" package="java.net" interface="true" fulltype="java.net.HttpCookie.CookieAttributeAssignor" type="HttpCookie.CookieAttributeAssignor">
			<methods>
				<method visibility="public" name="assign" fulltype="void" type="void">
					<params>
						<param name="cookie" fulltype="java.net.HttpCookie" type="HttpCookie" />
						<param name="attrName" fulltype="java.lang.String" type="String" />
						<param name="attrValue" fulltype="java.lang.String" type="String" />
					</params>
				</method>
			</methods>
		</jelclass>
	</jelclass>
	<jelclass abstract="true" visibility="package-private" package="java.net" interface="true" fulltype="java.net.HttpCookie.CookieAttributeAssignor" type="HttpCookie.CookieAttributeAssignor">
		<methods>
			<method visibility="public" name="assign" fulltype="void" type="void">
				<params>
					<param name="cookie" fulltype="java.net.HttpCookie" type="HttpCookie" />
					<param name="attrName" fulltype="java.lang.String" type="String" />
					<param name="attrValue" fulltype="java.lang.String" type="String" />
				</params>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="PlainSocketImpl" visibility="package-private" package="java.net" superclassfulltype="java.net.PlainSocketImpl" fulltype="java.net.SocksSocketImpl" type="SocksSocketImpl">
		<implements>
			<interface fulltype="java.net.SocksConsts" type="SocksConsts" />
		</implements>
		<comment>
			<description>SOCKS (V4 &amp; V5) TCP socket implementation (RFC 1928).
 This is a subclass of PlainSocketImpl.
 Note this class should &lt;b&gt;NOT&lt;/b&gt; be public.</description>
		</comment>
		<fields>
			<field visibility="private" name="server" fulltype="java.lang.String" type="String" />
			<field visibility="private" name="port" fulltype="int" type="int" />
			<field visibility="private" name="external_address" fulltype="java.net.InetSocketAddress" type="InetSocketAddress" />
			<field visibility="private" name="useV4" fulltype="boolean" type="boolean" />
			<field visibility="private" name="cmdsock" fulltype="java.net.Socket" type="Socket" />
			<field visibility="private" name="cmdIn" fulltype="java.io.InputStream" type="InputStream" />
			<field visibility="private" name="cmdOut" fulltype="java.io.OutputStream" type="OutputStream" />
			<field visibility="private" name="applicationSetProxy" fulltype="boolean" type="boolean" />
		</fields>
		<methods>
			<constructor visibility="package-private" name="SocksSocketImpl" />
			<constructor visibility="package-private" name="SocksSocketImpl">
				<params>
					<param name="server" fulltype="java.lang.String" type="String" />
					<param name="port" fulltype="int" type="int" />
				</params>
			</constructor>
			<constructor visibility="package-private" name="SocksSocketImpl">
				<params>
					<param name="proxy" fulltype="java.net.Proxy" type="Proxy" />
				</params>
			</constructor>
			<method visibility="package-private" name="setV4" fulltype="void" type="void" />
			<method synchronized="true" visibility="private" name="privilegedConnect" fulltype="void" type="void">
				<params>
					<param name="host" fulltype="java.lang.String" type="String" />
					<param name="port" fulltype="int" type="int" />
					<param name="timeout" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="superConnectServer" fulltype="void" type="void">
				<params>
					<param name="host" fulltype="java.lang.String" type="String" />
					<param name="port" fulltype="int" type="int" />
					<param name="timeout" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="readSocksReply" fulltype="int" type="int">
				<params>
					<param name="in" fulltype="java.io.InputStream" type="InputStream" />
					<param name="data" fulltype="byte[]" type="byte" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="authenticate" fulltype="boolean" type="boolean">
				<comment>
					<description>Provides the authentication machanism required by the proxy.</description>
				</comment>
				<params>
					<param name="method" fulltype="byte" type="byte" />
					<param name="in" fulltype="java.io.InputStream" type="InputStream" />
					<param name="out" fulltype="java.io.BufferedOutputStream" type="BufferedOutputStream" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="connectV4" fulltype="void" type="void">
				<params>
					<param name="in" fulltype="java.io.InputStream" type="InputStream" />
					<param name="out" fulltype="java.io.OutputStream" type="OutputStream" />
					<param name="endpoint" fulltype="java.net.InetSocketAddress" type="InetSocketAddress" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="protected" name="connect" fulltype="void" type="void">
				<comment>
					<description>Connects the Socks Socket to the specified endpoint. It will first
 connect to the SOCKS proxy and negotiate the access. If the proxy
 grants the connections, then the connect is successful and all
 further traffic will go to the &quot;real&quot; endpoint.</description>
					<attribute name="@param">
						<description>endpoint        the &lt;code&gt;SocketAddress&lt;/code&gt; to connect to.</description>
					</attribute>
					<attribute name="@param">
						<description>timeout         the timeout value in milliseconds</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException     if the connection can&apos;t be established.</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException if there is a security manager and it
                          doesn&apos;t allow the connection</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if endpoint is null or a
          SocketAddress subclass not supported by this socket</description>
					</attribute>
				</comment>
				<params>
					<param name="endpoint" comment="the &lt;code&gt;SocketAddress&lt;/code&gt; to connect to." fulltype="java.net.SocketAddress" type="SocketAddress" />
					<param name="timeout" comment="the timeout value in milliseconds" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if the connection can&apos;t be established." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="bindV4" fulltype="void" type="void">
				<params>
					<param name="in" fulltype="java.io.InputStream" type="InputStream" />
					<param name="out" fulltype="java.io.OutputStream" type="OutputStream" />
					<param name="baddr" fulltype="java.net.InetAddress" type="InetAddress" />
					<param name="lport" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="protected" name="socksBind" fulltype="void" type="void">
				<comment>
					<description>Sends the Bind request to the SOCKS proxy. In the SOCKS protocol, bind
 means &quot;accept incoming connection from&quot;, so the SocketAddress is the
 the one of the host we do accept connection from.</description>
					<attribute name="@param">
						<description>addr   the Socket address of the remote host.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs when binding this socket.</description>
					</attribute>
				</comment>
				<params>
					<param name="saddr" fulltype="java.net.InetSocketAddress" type="InetSocketAddress" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs when binding this socket." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="protected" name="acceptFrom" fulltype="void" type="void">
				<comment>
					<description>Accepts a connection from a specific host.</description>
					<attribute name="@param">
						<description>s   the accepted connection.</description>
					</attribute>
					<attribute name="@param">
						<description>saddr the socket address of the host we do accept
               connection from</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs when accepting the
               connection.</description>
					</attribute>
				</comment>
				<params>
					<param name="s" comment="the accepted connection." fulltype="java.net.SocketImpl" type="SocketImpl" />
					<param name="saddr" comment="the socket address of the host we do accept
               connection from" fulltype="java.net.InetSocketAddress" type="InetSocketAddress" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs when accepting the
               connection." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="protected" name="getInetAddress" returncomment="the value of this socket&apos;s &lt;code&gt;address&lt;/code&gt; field." fulltype="java.net.InetAddress" type="InetAddress">
				<comment>
					<description>Returns the value of this socket&apos;s &lt;code&gt;address&lt;/code&gt; field.</description>
					<attribute name="@return">
						<description>the value of this socket&apos;s &lt;code&gt;address&lt;/code&gt; field.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.SocketImpl#address</description>
					</attribute>
				</comment>
			</method>
			<method visibility="protected" name="getPort" returncomment="the value of this socket&apos;s &lt;code&gt;port&lt;/code&gt; field." fulltype="int" type="int">
				<comment>
					<description>Returns the value of this socket&apos;s &lt;code&gt;port&lt;/code&gt; field.</description>
					<attribute name="@return">
						<description>the value of this socket&apos;s &lt;code&gt;port&lt;/code&gt; field.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.SocketImpl#port</description>
					</attribute>
				</comment>
			</method>
			<method visibility="protected" name="getLocalPort" fulltype="int" type="int" />
			<method visibility="protected" name="close" fulltype="void" type="void">
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="getUserName" fulltype="java.lang.String" type="String" />
		</methods>
	</jelclass>
	<jelclass abstract="true" superclass="Object" visibility="public" package="java.net" superclassfulltype="java.lang.Object" fulltype="java.net.SocketImpl" type="SocketImpl">
		<implements>
			<interface fulltype="java.net.SocketOptions" type="SocketOptions" />
		</implements>
		<comment>
			<description>The abstract class &lt;code&gt;SocketImpl&lt;/code&gt; is a common superclass
 of all classes that actually implement sockets. It is used to
 create both client and server sockets.
 &lt;p&gt;
 A &quot;plain&quot; socket implements these methods exactly as
 described, without attempting to go through a firewall or proxy.</description>
			<attribute name="@author">
				<description>unascribed</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.0</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="package-private" name="socket" fulltype="java.net.Socket" type="Socket">
				<comment>
					<description>The actual Socket object.</description>
				</comment>
			</field>
			<field visibility="package-private" name="serverSocket" fulltype="java.net.ServerSocket" type="ServerSocket" />
			<field visibility="protected" name="fd" fulltype="java.io.FileDescriptor" type="FileDescriptor">
				<comment>
					<description>The file descriptor object for this socket.</description>
				</comment>
			</field>
			<field visibility="protected" name="address" fulltype="java.net.InetAddress" type="InetAddress">
				<comment>
					<description>The IP address of the remote end of this socket.</description>
				</comment>
			</field>
			<field visibility="protected" name="port" fulltype="int" type="int">
				<comment>
					<description>The port number on the remote host to which this socket is connected.</description>
				</comment>
			</field>
			<field visibility="protected" name="localport" fulltype="int" type="int">
				<comment>
					<description>The local port number to which this socket is connected.</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="public" name="SocketImpl" />
			<method abstract="true" visibility="protected" name="create" fulltype="void" type="void">
				<comment>
					<description>Creates either a stream or a datagram socket.</description>
					<attribute name="@param">
						<description>stream   if &lt;code&gt;true&lt;/code&gt;, create a stream socket;
                      otherwise, create a datagram socket.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs while creating the
               socket.</description>
					</attribute>
				</comment>
				<params>
					<param name="stream" comment="if &lt;code&gt;true&lt;/code&gt;, create a stream socket;
                      otherwise, create a datagram socket." fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs while creating the
               socket." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="protected" name="connect" fulltype="void" type="void">
				<comment>
					<description>Connects this socket to the specified port on the named host.</description>
					<attribute name="@param">
						<description>host   the name of the remote host.</description>
					</attribute>
					<attribute name="@param">
						<description>port   the port number.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs when connecting to the
               remote host.</description>
					</attribute>
				</comment>
				<params>
					<param name="host" comment="the name of the remote host." fulltype="java.lang.String" type="String" />
					<param name="port" comment="the port number." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs when connecting to the
               remote host." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="protected" name="connect" fulltype="void" type="void">
				<comment>
					<description>Connects this socket to the specified port number on the specified host.</description>
					<attribute name="@param">
						<description>address   the IP address of the remote host.</description>
					</attribute>
					<attribute name="@param">
						<description>port      the port number.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs when attempting a
               connection.</description>
					</attribute>
				</comment>
				<params>
					<param name="address" comment="the IP address of the remote host." fulltype="java.net.InetAddress" type="InetAddress" />
					<param name="port" comment="the port number." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs when attempting a
               connection." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="protected" name="connect" fulltype="void" type="void">
				<comment>
					<description>Connects this socket to the specified port number on the specified host.
 A timeout of zero is interpreted as an infinite timeout. The connection
 will then block until established or an error occurs.</description>
					<attribute name="@param">
						<description>address   the Socket address of the remote host.</description>
					</attribute>
					<attribute name="@param">
						<description>timeout  the timeout value, in milliseconds, or zero for no timeout.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs when attempting a
               connection.</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
				<params>
					<param name="address" comment="the Socket address of the remote host." fulltype="java.net.SocketAddress" type="SocketAddress" />
					<param name="timeout" comment="the timeout value, in milliseconds, or zero for no timeout." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs when attempting a
               connection." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="protected" name="bind" fulltype="void" type="void">
				<comment>
					<description>Binds this socket to the specified local IP address and port number.</description>
					<attribute name="@param">
						<description>host   an IP address that belongs to a local interface.</description>
					</attribute>
					<attribute name="@param">
						<description>port   the port number.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs when binding this socket.</description>
					</attribute>
				</comment>
				<params>
					<param name="host" comment="an IP address that belongs to a local interface." fulltype="java.net.InetAddress" type="InetAddress" />
					<param name="port" comment="the port number." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs when binding this socket." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="protected" name="listen" fulltype="void" type="void">
				<comment>
					<description>Sets the maximum queue length for incoming connection indications
 (a request to connect) to the &lt;code&gt;count&lt;/code&gt; argument. If a
 connection indication arrives when the queue is full, the
 connection is refused.</description>
					<attribute name="@param">
						<description>backlog   the maximum length of the queue.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs when creating the queue.</description>
					</attribute>
				</comment>
				<params>
					<param name="backlog" comment="the maximum length of the queue." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs when creating the queue." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="protected" name="accept" fulltype="void" type="void">
				<comment>
					<description>Accepts a connection.</description>
					<attribute name="@param">
						<description>s   the accepted connection.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs when accepting the
               connection.</description>
					</attribute>
				</comment>
				<params>
					<param name="s" comment="the accepted connection." fulltype="java.net.SocketImpl" type="SocketImpl" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs when accepting the
               connection." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="protected" name="getInputStream" returncomment="a stream for reading from this socket." fulltype="java.io.InputStream" type="InputStream">
				<comment>
					<description>Returns an input stream for this socket.</description>
					<attribute name="@return">
						<description>a stream for reading from this socket.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs when creating the
               input stream.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs when creating the
               input stream." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="protected" name="getOutputStream" returncomment="an output stream for writing to this socket." fulltype="java.io.OutputStream" type="OutputStream">
				<comment>
					<description>Returns an output stream for this socket.</description>
					<attribute name="@return">
						<description>an output stream for writing to this socket.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs when creating the
               output stream.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs when creating the
               output stream." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="protected" name="available" returncomment="the number of bytes that can be read from this socket
             without blocking." fulltype="int" type="int">
				<comment>
					<description>Returns the number of bytes that can be read from this socket
 without blocking.</description>
					<attribute name="@return">
						<description>the number of bytes that can be read from this socket
             without blocking.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs when determining the
               number of bytes available.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs when determining the
               number of bytes available." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="protected" name="close" fulltype="void" type="void">
				<comment>
					<description>Closes this socket.</description>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs when closing this socket.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs when closing this socket." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="protected" name="shutdownInput" fulltype="void" type="void">
				<comment>
					<description>Places the input stream for this socket at &quot;end of stream&quot;.
 Any data sent to this socket is acknowledged and then
 silently discarded.

 If you read from a socket input stream after invoking
 shutdownInput() on the socket, the stream will return EOF.</description>
					<attribute name="@exception">
						<description>IOException if an I/O error occurs when shutting down this
 socket.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.Socket#shutdownOutput()</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.Socket#close()</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.Socket#setSoLinger(boolean, int)</description>
					</attribute>
					<attribute name="@since">
						<description>1.3</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs when shutting down this
 socket." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="protected" name="shutdownOutput" fulltype="void" type="void">
				<comment>
					<description>Disables the output stream for this socket.
 For a TCP socket, any previously written data will be sent
 followed by TCP&apos;s normal connection termination sequence.

 If you write to a socket output stream after invoking
 shutdownOutput() on the socket, the stream will throw
 an IOException.</description>
					<attribute name="@exception">
						<description>IOException if an I/O error occurs when shutting down this
 socket.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.Socket#shutdownInput()</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.Socket#close()</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.Socket#setSoLinger(boolean, int)</description>
					</attribute>
					<attribute name="@since">
						<description>1.3</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs when shutting down this
 socket." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="protected" name="getFileDescriptor" returncomment="the value of this socket&apos;s &lt;code&gt;fd&lt;/code&gt; field." fulltype="java.io.FileDescriptor" type="FileDescriptor">
				<comment>
					<description>Returns the value of this socket&apos;s &lt;code&gt;fd&lt;/code&gt; field.</description>
					<attribute name="@return">
						<description>the value of this socket&apos;s &lt;code&gt;fd&lt;/code&gt; field.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.SocketImpl#fd</description>
					</attribute>
				</comment>
			</method>
			<method visibility="protected" name="getInetAddress" returncomment="the value of this socket&apos;s &lt;code&gt;address&lt;/code&gt; field." fulltype="java.net.InetAddress" type="InetAddress">
				<comment>
					<description>Returns the value of this socket&apos;s &lt;code&gt;address&lt;/code&gt; field.</description>
					<attribute name="@return">
						<description>the value of this socket&apos;s &lt;code&gt;address&lt;/code&gt; field.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.SocketImpl#address</description>
					</attribute>
				</comment>
			</method>
			<method visibility="protected" name="getPort" returncomment="the value of this socket&apos;s &lt;code&gt;port&lt;/code&gt; field." fulltype="int" type="int">
				<comment>
					<description>Returns the value of this socket&apos;s &lt;code&gt;port&lt;/code&gt; field.</description>
					<attribute name="@return">
						<description>the value of this socket&apos;s &lt;code&gt;port&lt;/code&gt; field.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.SocketImpl#port</description>
					</attribute>
				</comment>
			</method>
			<method visibility="protected" name="supportsUrgentData" returncomment="true if urgent data supported" fulltype="boolean" type="boolean">
				<comment>
					<description>Returns whether or not this SocketImpl supports sending
 urgent data. By default, false is returned
 unless the method is overridden in a sub-class</description>
					<attribute name="@return">
						<description>true if urgent data supported</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.SocketImpl#address</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</method>
			<method abstract="true" visibility="protected" name="sendUrgentData" fulltype="void" type="void">
				<comment>
					<description>Send one byte of urgent data on the socket.
 The byte to be sent is the low eight bits of the parameter</description>
					<attribute name="@param">
						<description>data The byte of data to send</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException if there is an error
  sending the data.</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
				<params>
					<param name="data" comment="The byte of data to send" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if there is an error
  sending the data." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="protected" name="getLocalPort" returncomment="the value of this socket&apos;s &lt;code&gt;localport&lt;/code&gt; field." fulltype="int" type="int">
				<comment>
					<description>Returns the value of this socket&apos;s &lt;code&gt;localport&lt;/code&gt; field.</description>
					<attribute name="@return">
						<description>the value of this socket&apos;s &lt;code&gt;localport&lt;/code&gt; field.</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.SocketImpl#localport</description>
					</attribute>
				</comment>
			</method>
			<method visibility="package-private" name="setSocket" fulltype="void" type="void">
				<params>
					<param name="soc" fulltype="java.net.Socket" type="Socket" />
				</params>
			</method>
			<method visibility="package-private" name="getSocket" fulltype="java.net.Socket" type="Socket" />
			<method visibility="package-private" name="setServerSocket" fulltype="void" type="void">
				<params>
					<param name="soc" fulltype="java.net.ServerSocket" type="ServerSocket" />
				</params>
			</method>
			<method visibility="package-private" name="getServerSocket" fulltype="java.net.ServerSocket" type="ServerSocket" />
			<method visibility="public" name="toString" returncomment="a string representation of this socket." fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the address and port of this socket as a &lt;code&gt;String&lt;/code&gt;.</description>
					<attribute name="@return">
						<description>a string representation of this socket.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="package-private" name="reset" fulltype="void" type="void">
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="protected" name="setPerformancePreferences" fulltype="void" type="void">
				<comment>
					<description>Sets performance preferences for this socket.

 &lt;p&gt; Sockets use the TCP/IP protocol by default.  Some implementations
 may offer alternative protocols which have different performance
 characteristics than TCP/IP.  This method allows the application to
 express its own preferences as to how these tradeoffs should be made
 when the implementation chooses from the available protocols.

 &lt;p&gt; Performance preferences are described by three integers
 whose values indicate the relative importance of short connection time,
 low latency, and high bandwidth.  The absolute values of the integers
 are irrelevant; in order to choose a protocol the values are simply
 compared, with larger values indicating stronger preferences. Negative
 values represent a lower priority than positive values. If the
 application prefers short connection time over both low latency and high
 bandwidth, for example, then it could invoke this method with the values
 &lt;tt&gt;(1, 0, 0)&lt;/tt&gt;.  If the application prefers high bandwidth above low
 latency, and low latency above short connection time, then it could
 invoke this method with the values &lt;tt&gt;(0, 1, 2)&lt;/tt&gt;.

 By default, this method does nothing, unless it is overridden in a
 a sub-class.</description>
					<attribute name="@param">
						<description>connectionTime
         An &lt;tt&gt;int&lt;/tt&gt; expressing the relative importance of a short
         connection time</description>
					</attribute>
					<attribute name="@param">
						<description>latency
         An &lt;tt&gt;int&lt;/tt&gt; expressing the relative importance of low
         latency</description>
					</attribute>
					<attribute name="@param">
						<description>bandwidth
         An &lt;tt&gt;int&lt;/tt&gt; expressing the relative importance of high
         bandwidth</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
				<params>
					<param name="connectionTime" comment="An &lt;tt&gt;int&lt;/tt&gt; expressing the relative importance of a short
         connection time" fulltype="int" type="int" />
					<param name="latency" comment="An &lt;tt&gt;int&lt;/tt&gt; expressing the relative importance of low
         latency" fulltype="int" type="int" />
					<param name="bandwidth" comment="An &lt;tt&gt;int&lt;/tt&gt; expressing the relative importance of high
         bandwidth" fulltype="int" type="int" />
				</params>
			</method>
		</methods>
	</jelclass>
</jel>
