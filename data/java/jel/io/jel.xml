<?xml version="1.0" encoding="UTF-8"?>
<jel>
	<admin creation="Fri Aug 17 15:41:07 CEST 2012" xsdversion="1.0.0" version="1.0.0" />
	<jelclass abstract="true" superclass="Reader" visibility="public" package="java.io" superclassfulltype="java.io.Reader" fulltype="java.io.FilterReader" type="FilterReader">
		<comment>
			<description>Abstract class for reading filtered character streams.
 The abstract class &lt;code&gt;FilterReader&lt;/code&gt; itself
 provides default methods that pass all requests to
 the contained stream. Subclasses of &lt;code&gt;FilterReader&lt;/code&gt;
 should override some of these methods and may also provide
 additional methods and fields.</description>
			<attribute name="@author">
				<description>Mark Reinhold</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.1</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="protected" name="in" fulltype="java.io.Reader" type="Reader">
				<comment>
					<description>The underlying character-input stream.</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="protected" name="FilterReader">
				<comment>
					<description>Creates a new filtered reader.</description>
					<attribute name="@param">
						<description>in  a Reader object providing the underlying stream.</description>
					</attribute>
					<attribute name="@throws">
						<description>NullPointerException if &lt;code&gt;in&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</description>
					</attribute>
				</comment>
				<params>
					<param name="in" comment="a Reader object providing the underlying stream." fulltype="java.io.Reader" type="Reader" />
				</params>
			</constructor>
			<method visibility="public" name="read" fulltype="int" type="int">
				<comment>
					<description>Reads a single character.</description>
					<attribute name="@exception">
						<description>IOException  If an I/O error occurs</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="read" fulltype="int" type="int">
				<comment>
					<description>Reads characters into a portion of an array.</description>
					<attribute name="@exception">
						<description>IOException  If an I/O error occurs</description>
					</attribute>
				</comment>
				<params>
					<param name="cbuf" fulltype="char[]" type="char" />
					<param name="off" fulltype="int" type="int" />
					<param name="len" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="skip" fulltype="long" type="long">
				<comment>
					<description>Skips characters.</description>
					<attribute name="@exception">
						<description>IOException  If an I/O error occurs</description>
					</attribute>
				</comment>
				<params>
					<param name="n" fulltype="long" type="long" />
				</params>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="ready" fulltype="boolean" type="boolean">
				<comment>
					<description>Tells whether this stream is ready to be read.</description>
					<attribute name="@exception">
						<description>IOException  If an I/O error occurs</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="markSupported" fulltype="boolean" type="boolean">
				<comment>
					<description>Tells whether this stream supports the mark() operation.</description>
				</comment>
			</method>
			<method visibility="public" name="mark" fulltype="void" type="void">
				<comment>
					<description>Marks the present position in the stream.</description>
					<attribute name="@exception">
						<description>IOException  If an I/O error occurs</description>
					</attribute>
				</comment>
				<params>
					<param name="readAheadLimit" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="reset" fulltype="void" type="void">
				<comment>
					<description>Resets the stream.</description>
					<attribute name="@exception">
						<description>IOException  If an I/O error occurs</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="close" fulltype="void" type="void">
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass abstract="true" visibility="public" package="java.io" interface="true" fulltype="java.io.Closeable" type="Closeable">
		<comment>
			<description>A &lt;tt&gt;Closeable&lt;/tt&gt; is a source or destination of data that can be closed.
 The close method is invoked to release resources that the object is
 holding (such as open files).</description>
			<attribute name="@since">
				<description>1.5</description>
			</attribute>
		</comment>
		<methods>
			<method visibility="public" name="close" fulltype="void" type="void">
				<comment>
					<description>Closes this stream and releases any system resources associated
 with it. If the stream is already closed then invoking this
 method has no effect.</description>
					<attribute name="@throws">
						<description>IOException if an I/O error occurs</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="FilterInputStream" visibility="public" package="java.io" superclassfulltype="java.io.FilterInputStream" fulltype="java.io.BufferedInputStream" type="BufferedInputStream">
		<comment>
			<description>A &lt;code&gt;BufferedInputStream&lt;/code&gt; adds
 functionality to another input stream-namely,
 the ability to buffer the input and to
 support the &lt;code&gt;mark&lt;/code&gt; and &lt;code&gt;reset&lt;/code&gt;
 methods. When  the &lt;code&gt;BufferedInputStream&lt;/code&gt;
 is created, an internal buffer array is
 created. As bytes  from the stream are read
 or skipped, the internal buffer is refilled
 as necessary  from the contained input stream,
 many bytes at a time. The &lt;code&gt;mark&lt;/code&gt;
 operation  remembers a point in the input
 stream and the &lt;code&gt;reset&lt;/code&gt; operation
 causes all the  bytes read since the most
 recent &lt;code&gt;mark&lt;/code&gt; operation to be
 reread before new bytes are  taken from
 the contained input stream.</description>
			<attribute name="@author">
				<description>Arthur van Hoff</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.0</description>
			</attribute>
		</comment>
		<fields>
			<field static="true" visibility="private" name="defaultBufferSize" fulltype="int" type="int" />
			<field volatile="true" visibility="protected" name="buf" fulltype="byte[]" type="byte">
				<comment>
					<description>The internal buffer array where the data is stored. When necessary,
 it may be replaced by another array of
 a different size.</description>
				</comment>
			</field>
			<field final="true" static="true" visibility="private" name="bufUpdater" fulltype="java.util.concurrent.atomic.AtomicReferenceFieldUpdater" type="AtomicReferenceFieldUpdater">
				<comment>
					<description>Atomic updater to provide compareAndSet for buf. This is
 necessary because closes can be asynchronous. We use nullness
 of buf[] as primary indicator that this stream is closed. (The
 &quot;in&quot; field is also nulled out on close.)</description>
				</comment>
			</field>
			<field visibility="protected" name="count" fulltype="int" type="int">
				<comment>
					<description>The index one greater than the index of the last valid byte in
 the buffer.
 This value is always
 in the range &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;buf.length&lt;/code&gt;;
 elements &lt;code&gt;buf[0]&lt;/code&gt;  through &lt;code&gt;buf[count-1]
 &lt;/code&gt;contain buffered input data obtained
 from the underlying  input stream.</description>
				</comment>
			</field>
			<field visibility="protected" name="pos" fulltype="int" type="int">
				<comment>
					<description>The current position in the buffer. This is the index of the next
 character to be read from the &lt;code&gt;buf&lt;/code&gt; array.
 &lt;p&gt;
 This value is always in the range &lt;code&gt;0&lt;/code&gt;
 through &lt;code&gt;count&lt;/code&gt;. If it is less
 than &lt;code&gt;count&lt;/code&gt;, then  &lt;code&gt;buf[pos]&lt;/code&gt;
 is the next byte to be supplied as input;
 if it is equal to &lt;code&gt;count&lt;/code&gt;, then
 the  next &lt;code&gt;read&lt;/code&gt; or &lt;code&gt;skip&lt;/code&gt;
 operation will require more bytes to be
 read from the contained  input stream.</description>
					<attribute name="@see">
						<description>java.io.BufferedInputStream#buf</description>
					</attribute>
				</comment>
			</field>
			<field visibility="protected" name="markpos" fulltype="int" type="int">
				<comment>
					<description>The value of the &lt;code&gt;pos&lt;/code&gt; field at the time the last
 &lt;code&gt;mark&lt;/code&gt; method was called.
 &lt;p&gt;
 This value is always
 in the range &lt;code&gt;-1&lt;/code&gt; through &lt;code&gt;pos&lt;/code&gt;.
 If there is no marked position in  the input
 stream, this field is &lt;code&gt;-1&lt;/code&gt;. If
 there is a marked position in the input
 stream,  then &lt;code&gt;buf[markpos]&lt;/code&gt;
 is the first byte to be supplied as input
 after a &lt;code&gt;reset&lt;/code&gt; operation. If
 &lt;code&gt;markpos&lt;/code&gt; is not &lt;code&gt;-1&lt;/code&gt;,
 then all bytes from positions &lt;code&gt;buf[markpos]&lt;/code&gt;
 through  &lt;code&gt;buf[pos-1]&lt;/code&gt; must remain
 in the buffer array (though they may be
 moved to  another place in the buffer array,
 with suitable adjustments to the values
 of &lt;code&gt;count&lt;/code&gt;,  &lt;code&gt;pos&lt;/code&gt;,
 and &lt;code&gt;markpos&lt;/code&gt;); they may not
 be discarded unless and until the difference
 between &lt;code&gt;pos&lt;/code&gt; and &lt;code&gt;markpos&lt;/code&gt;
 exceeds &lt;code&gt;marklimit&lt;/code&gt;.</description>
					<attribute name="@see">
						<description>java.io.BufferedInputStream#mark(int)</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.BufferedInputStream#pos</description>
					</attribute>
				</comment>
			</field>
			<field visibility="protected" name="marklimit" fulltype="int" type="int">
				<comment>
					<description>The maximum read ahead allowed after a call to the
 &lt;code&gt;mark&lt;/code&gt; method before subsequent calls to the
 &lt;code&gt;reset&lt;/code&gt; method fail.
 Whenever the difference between &lt;code&gt;pos&lt;/code&gt;
 and &lt;code&gt;markpos&lt;/code&gt; exceeds &lt;code&gt;marklimit&lt;/code&gt;,
 then the  mark may be dropped by setting
 &lt;code&gt;markpos&lt;/code&gt; to &lt;code&gt;-1&lt;/code&gt;.</description>
					<attribute name="@see">
						<description>java.io.BufferedInputStream#mark(int)</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.BufferedInputStream#reset()</description>
					</attribute>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="public" name="BufferedInputStream">
				<comment>
					<description>Creates a &lt;code&gt;BufferedInputStream&lt;/code&gt;
 and saves its  argument, the input stream
 &lt;code&gt;in&lt;/code&gt;, for later use. An internal
 buffer array is created and  stored in &lt;code&gt;buf&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>in   the underlying input stream.</description>
					</attribute>
				</comment>
				<params>
					<param name="in" comment="the underlying input stream." fulltype="java.io.InputStream" type="InputStream" />
				</params>
			</constructor>
			<constructor visibility="public" name="BufferedInputStream">
				<comment>
					<description>Creates a &lt;code&gt;BufferedInputStream&lt;/code&gt;
 with the specified buffer size,
 and saves its  argument, the input stream
 &lt;code&gt;in&lt;/code&gt;, for later use.  An internal
 buffer array of length  &lt;code&gt;size&lt;/code&gt;
 is created and stored in &lt;code&gt;buf&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>in     the underlying input stream.</description>
					</attribute>
					<attribute name="@param">
						<description>size   the buffer size.</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if size &lt;= 0.</description>
					</attribute>
				</comment>
				<params>
					<param name="in" comment="the underlying input stream." fulltype="java.io.InputStream" type="InputStream" />
					<param name="size" comment="the buffer size." fulltype="int" type="int" />
				</params>
			</constructor>
			<method visibility="private" name="getInIfOpen" fulltype="java.io.InputStream" type="InputStream">
				<comment>
					<description>Check to make sure that underlying input stream has not been
 nulled out due to close; if not return it;</description>
				</comment>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="getBufIfOpen" fulltype="byte[]" type="byte">
				<comment>
					<description>Check to make sure that buffer has not been nulled out due to
 close; if not return it;</description>
				</comment>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="fill" fulltype="void" type="void">
				<comment>
					<description>Fills the buffer with more data, taking into account
 shuffling and other tricks for dealing with marks.
 Assumes that it is being called by a synchronized method.
 This method also assumes that all data has already been read in,
 hence pos &gt; count.</description>
				</comment>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="public" name="read" returncomment="the next byte of data, or &lt;code&gt;-1&lt;/code&gt; if the end of the
             stream is reached." fulltype="int" type="int">
				<comment>
					<description>See
 the general contract of the &lt;code&gt;read&lt;/code&gt;
 method of &lt;code&gt;InputStream&lt;/code&gt;.</description>
					<attribute name="@return">
						<description>the next byte of data, or &lt;code&gt;-1&lt;/code&gt; if the end of the
             stream is reached.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if this input stream has been closed by
                          invoking its {@link #close()} method,
                          or an I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.FilterInputStream#in</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if this input stream has been closed by
                          invoking its {@link #close()} method,
                          or an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="read1" fulltype="int" type="int">
				<comment>
					<description>Read characters into a portion of an array, reading from the underlying
 stream at most once if necessary.</description>
				</comment>
				<params>
					<param name="b" fulltype="byte[]" type="byte" />
					<param name="off" fulltype="int" type="int" />
					<param name="len" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="public" name="read" returncomment="the number of bytes read, or &lt;code&gt;-1&lt;/code&gt; if the end of
             the stream has been reached." fulltype="int" type="int">
				<comment>
					<description>Reads bytes from this byte-input stream into the specified byte array,
 starting at the given offset.

 &lt;p&gt; This method implements the general contract of the corresponding
 &lt;code&gt;{@link InputStream#read(byte[], int, int) read}&lt;/code&gt; method of
 the &lt;code&gt;{@link InputStream}&lt;/code&gt; class.  As an additional
 convenience, it attempts to read as many bytes as possible by repeatedly
 invoking the &lt;code&gt;read&lt;/code&gt; method of the underlying stream.  This
 iterated &lt;code&gt;read&lt;/code&gt; continues until one of the following
 conditions becomes true: &lt;ul&gt;

   &lt;li&gt; The specified number of bytes have been read,

   &lt;li&gt; The &lt;code&gt;read&lt;/code&gt; method of the underlying stream returns
   &lt;code&gt;-1&lt;/code&gt;, indicating end-of-file, or

   &lt;li&gt; The &lt;code&gt;available&lt;/code&gt; method of the underlying stream
   returns zero, indicating that further input requests would block.

 &lt;/ul&gt; If the first &lt;code&gt;read&lt;/code&gt; on the underlying stream returns
 &lt;code&gt;-1&lt;/code&gt; to indicate end-of-file then this method returns
 &lt;code&gt;-1&lt;/code&gt;.  Otherwise this method returns the number of bytes
 actually read.

 &lt;p&gt; Subclasses of this class are encouraged, but not required, to
 attempt to read as many bytes as possible in the same fashion.</description>
					<attribute name="@param">
						<description>b     destination buffer.</description>
					</attribute>
					<attribute name="@param">
						<description>off   offset at which to start storing bytes.</description>
					</attribute>
					<attribute name="@param">
						<description>len   maximum number of bytes to read.</description>
					</attribute>
					<attribute name="@return">
						<description>the number of bytes read, or &lt;code&gt;-1&lt;/code&gt; if the end of
             the stream has been reached.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if this input stream has been closed by
                          invoking its {@link #close()} method,
                          or an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="destination buffer." fulltype="byte[]" type="byte" />
					<param name="off" comment="offset at which to start storing bytes." fulltype="int" type="int" />
					<param name="len" comment="maximum number of bytes to read." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if this input stream has been closed by
                          invoking its {@link #close()} method,
                          or an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="public" name="skip" fulltype="long" type="long">
				<comment>
					<description>See the general contract of the &lt;code&gt;skip&lt;/code&gt;
 method of &lt;code&gt;InputStream&lt;/code&gt;.</description>
					<attribute name="@exception">
						<description>IOException  if the stream does not support seek,
                          or if this input stream has been closed by
                          invoking its {@link #close()} method, or an
                          I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="n" fulltype="long" type="long" />
				</params>
				<exceptions>
					<exception comment="if the stream does not support seek,
                          or if this input stream has been closed by
                          invoking its {@link #close()} method, or an
                          I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="public" name="available" returncomment="an estimate of the number of bytes that can be read (or skipped
             over) from this input stream without blocking." fulltype="int" type="int">
				<comment>
					<description>Returns an estimate of the number of bytes that can be read (or
 skipped over) from this input stream without blocking by the next
 invocation of a method for this input stream. The next invocation might be
 the same thread or another thread.  A single read or skip of this
 many bytes will not block, but may read or skip fewer bytes.
 &lt;p&gt;
 This method returns the sum of the number of bytes remaining to be read in
 the buffer (&lt;code&gt;count&amp;nbsp;- pos&lt;/code&gt;) and the result of calling the
 {@link java.io.FilterInputStream#in in}.available().</description>
					<attribute name="@return">
						<description>an estimate of the number of bytes that can be read (or skipped
             over) from this input stream without blocking.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if this input stream has been closed by
                          invoking its {@link #close()} method,
                          or an I/O error occurs.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if this input stream has been closed by
                          invoking its {@link #close()} method,
                          or an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="public" name="mark" fulltype="void" type="void">
				<comment>
					<description>See the general contract of the &lt;code&gt;mark&lt;/code&gt;
 method of &lt;code&gt;InputStream&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>readlimit   the maximum limit of bytes that can be read before
                      the mark position becomes invalid.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.BufferedInputStream#reset()</description>
					</attribute>
				</comment>
				<params>
					<param name="readlimit" comment="the maximum limit of bytes that can be read before
                      the mark position becomes invalid." fulltype="int" type="int" />
				</params>
			</method>
			<method synchronized="true" visibility="public" name="reset" fulltype="void" type="void">
				<comment>
					<description>See the general contract of the &lt;code&gt;reset&lt;/code&gt;
 method of &lt;code&gt;InputStream&lt;/code&gt;.
 &lt;p&gt;
 If &lt;code&gt;markpos&lt;/code&gt; is &lt;code&gt;-1&lt;/code&gt;
 (no mark has been set or the mark has been
 invalidated), an &lt;code&gt;IOException&lt;/code&gt;
 is thrown. Otherwise, &lt;code&gt;pos&lt;/code&gt; is
 set equal to &lt;code&gt;markpos&lt;/code&gt;.</description>
					<attribute name="@exception">
						<description>IOException  if this stream has not been marked or,
                  if the mark has been invalidated, or the stream
                  has been closed by invoking its {@link #close()}
                  method, or an I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.BufferedInputStream#mark(int)</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if this stream has not been marked or,
                  if the mark has been invalidated, or the stream
                  has been closed by invoking its {@link #close()}
                  method, or an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="markSupported" returncomment="a &lt;code&gt;boolean&lt;/code&gt; indicating if this stream type supports
          the &lt;code&gt;mark&lt;/code&gt; and &lt;code&gt;reset&lt;/code&gt; methods." fulltype="boolean" type="boolean">
				<comment>
					<description>Tests if this input stream supports the &lt;code&gt;mark&lt;/code&gt;
 and &lt;code&gt;reset&lt;/code&gt; methods. The &lt;code&gt;markSupported&lt;/code&gt;
 method of &lt;code&gt;BufferedInputStream&lt;/code&gt; returns
 &lt;code&gt;true&lt;/code&gt;.</description>
					<attribute name="@return">
						<description>a &lt;code&gt;boolean&lt;/code&gt; indicating if this stream type supports
          the &lt;code&gt;mark&lt;/code&gt; and &lt;code&gt;reset&lt;/code&gt; methods.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.InputStream#mark(int)</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.InputStream#reset()</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="close" fulltype="void" type="void">
				<comment>
					<description>Closes this input stream and releases any system resources
 associated with the stream.
 Once the stream has been closed, further read(), available(), reset(),
 or skip() invocations will throw an IOException.
 Closing a previously closed stream has no effect.</description>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="Writer" visibility="public" package="java.io" superclassfulltype="java.io.Writer" fulltype="java.io.PrintWriter" type="PrintWriter">
		<comment>
			<description>Prints formatted representations of objects to a text-output stream.  This
 class implements all of the &lt;tt&gt;print&lt;/tt&gt; methods found in {@link
 PrintStream}.  It does not contain methods for writing raw bytes, for which
 a program should use unencoded byte streams.

 &lt;p&gt; Unlike the {@link PrintStream} class, if automatic flushing is enabled
 it will be done only when one of the &lt;tt&gt;println&lt;/tt&gt;, &lt;tt&gt;printf&lt;/tt&gt;, or
 &lt;tt&gt;format&lt;/tt&gt; methods is invoked, rather than whenever a newline character
 happens to be output.  These methods use the platform&apos;s own notion of line
 separator rather than the newline character.

 &lt;p&gt; Methods in this class never throw I/O exceptions, although some of its
 constructors may.  The client may inquire as to whether any errors have
 occurred by invoking {@link #checkError checkError()}.</description>
			<attribute name="@author">
				<description>Frank Yellin</description>
			</attribute>
			<attribute name="@author">
				<description>Mark Reinhold</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.1</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="protected" name="out" fulltype="java.io.Writer" type="Writer">
				<comment>
					<description>The underlying character-output stream of this
 &lt;code&gt;PrintWriter&lt;/code&gt;.</description>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
			</field>
			<field visibility="private" name="autoFlush" fulltype="boolean" type="boolean" />
			<field visibility="private" name="trouble" fulltype="boolean" type="boolean" />
			<field visibility="private" name="formatter" fulltype="java.util.Formatter" type="Formatter" />
			<field visibility="private" name="psOut" fulltype="java.io.PrintStream" type="PrintStream" />
			<field visibility="private" name="lineSeparator" fulltype="java.lang.String" type="String">
				<comment>
					<description>Line separator string.  This is the value of the line.separator
 property at the moment that the stream was created.</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="public" name="PrintWriter">
				<comment>
					<description>Creates a new PrintWriter, without automatic line flushing.</description>
					<attribute name="@param">
						<description>out        A character-output stream</description>
					</attribute>
				</comment>
				<params>
					<param name="out" comment="A character-output stream" fulltype="java.io.Writer" type="Writer" />
				</params>
			</constructor>
			<constructor visibility="public" name="PrintWriter">
				<comment>
					<description>Creates a new PrintWriter.</description>
					<attribute name="@param">
						<description>out        A character-output stream</description>
					</attribute>
					<attribute name="@param">
						<description>autoFlush  A boolean; if true, the &lt;tt&gt;println&lt;/tt&gt;,
                    &lt;tt&gt;printf&lt;/tt&gt;, or &lt;tt&gt;format&lt;/tt&gt; methods will
                    flush the output buffer</description>
					</attribute>
				</comment>
				<params>
					<param name="out" comment="A character-output stream" fulltype="java.io.Writer" type="Writer" />
					<param name="autoFlush" comment="A boolean; if true, the &lt;tt&gt;println&lt;/tt&gt;,
                    &lt;tt&gt;printf&lt;/tt&gt;, or &lt;tt&gt;format&lt;/tt&gt; methods will
                    flush the output buffer" fulltype="boolean" type="boolean" />
				</params>
			</constructor>
			<constructor visibility="public" name="PrintWriter">
				<comment>
					<description>Creates a new PrintWriter, without automatic line flushing, from an
 existing OutputStream.  This convenience constructor creates the
 necessary intermediate OutputStreamWriter, which will convert characters
 into bytes using the default character encoding.</description>
					<attribute name="@param">
						<description>out        An output stream</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.OutputStreamWriter#OutputStreamWriter(java.io.OutputStream)</description>
					</attribute>
				</comment>
				<params>
					<param name="out" comment="An output stream" fulltype="java.io.OutputStream" type="OutputStream" />
				</params>
			</constructor>
			<constructor visibility="public" name="PrintWriter">
				<comment>
					<description>Creates a new PrintWriter from an existing OutputStream.  This
 convenience constructor creates the necessary intermediate
 OutputStreamWriter, which will convert characters into bytes using the
 default character encoding.</description>
					<attribute name="@param">
						<description>out        An output stream</description>
					</attribute>
					<attribute name="@param">
						<description>autoFlush  A boolean; if true, the &lt;tt&gt;println&lt;/tt&gt;,
                    &lt;tt&gt;printf&lt;/tt&gt;, or &lt;tt&gt;format&lt;/tt&gt; methods will
                    flush the output buffer</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.OutputStreamWriter#OutputStreamWriter(java.io.OutputStream)</description>
					</attribute>
				</comment>
				<params>
					<param name="out" comment="An output stream" fulltype="java.io.OutputStream" type="OutputStream" />
					<param name="autoFlush" comment="A boolean; if true, the &lt;tt&gt;println&lt;/tt&gt;,
                    &lt;tt&gt;printf&lt;/tt&gt;, or &lt;tt&gt;format&lt;/tt&gt; methods will
                    flush the output buffer" fulltype="boolean" type="boolean" />
				</params>
			</constructor>
			<constructor visibility="public" name="PrintWriter">
				<comment>
					<description>Creates a new PrintWriter, without automatic line flushing, with the
 specified file name.  This convenience constructor creates the necessary
 intermediate {@link java.io.OutputStreamWriter OutputStreamWriter},
 which will encode characters using the {@linkplain
 java.nio.charset.Charset#defaultCharset() default charset} for this
 instance of the Java virtual machine.</description>
					<attribute name="@param">
						<description>fileName
         The name of the file to use as the destination of this writer.
         If the file exists then it will be truncated to zero size;
         otherwise, a new file will be created.  The output will be
         written to the file and is buffered.</description>
					</attribute>
					<attribute name="@throws">
						<description>FileNotFoundException
          If the given string does not denote an existing, writable
          regular file and a new regular file of that name cannot be
          created, or if some other error occurs while opening or
          creating the file</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException
          If a security manager is present and {@link
          SecurityManager#checkWrite checkWrite(fileName)} denies write
          access to the file</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
				<params>
					<param name="fileName" comment="The name of the file to use as the destination of this writer.
         If the file exists then it will be truncated to zero size;
         otherwise, a new file will be created.  The output will be
         written to the file and is buffered." fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception comment="If the given string does not denote an existing, writable
          regular file and a new regular file of that name cannot be
          created, or if some other error occurs while opening or
          creating the file" fulltype="java.io.FileNotFoundException" type="FileNotFoundException" />
				</exceptions>
			</constructor>
			<constructor visibility="public" name="PrintWriter">
				<comment>
					<description>Creates a new PrintWriter, without automatic line flushing, with the
 specified file name and charset.  This convenience constructor creates
 the necessary intermediate {@link java.io.OutputStreamWriter
 OutputStreamWriter}, which will encode characters using the provided
 charset.</description>
					<attribute name="@param">
						<description>fileName
         The name of the file to use as the destination of this writer.
         If the file exists then it will be truncated to zero size;
         otherwise, a new file will be created.  The output will be
         written to the file and is buffered.</description>
					</attribute>
					<attribute name="@param">
						<description>csn
         The name of a supported {@linkplain java.nio.charset.Charset
         charset}</description>
					</attribute>
					<attribute name="@throws">
						<description>FileNotFoundException
          If the given string does not denote an existing, writable
          regular file and a new regular file of that name cannot be
          created, or if some other error occurs while opening or
          creating the file</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException
          If a security manager is present and {@link
          SecurityManager#checkWrite checkWrite(fileName)} denies write
          access to the file</description>
					</attribute>
					<attribute name="@throws">
						<description>UnsupportedEncodingException
          If the named charset is not supported</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
				<params>
					<param name="fileName" comment="The name of the file to use as the destination of this writer.
         If the file exists then it will be truncated to zero size;
         otherwise, a new file will be created.  The output will be
         written to the file and is buffered." fulltype="java.lang.String" type="String" />
					<param name="csn" comment="The name of a supported {@linkplain java.nio.charset.Charset
         charset}" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception comment="If the given string does not denote an existing, writable
          regular file and a new regular file of that name cannot be
          created, or if some other error occurs while opening or
          creating the file" fulltype="java.io.FileNotFoundException" type="FileNotFoundException" />
					<exception comment="If the named charset is not supported" fulltype="java.io.UnsupportedEncodingException" type="UnsupportedEncodingException" />
				</exceptions>
			</constructor>
			<constructor visibility="public" name="PrintWriter">
				<comment>
					<description>Creates a new PrintWriter, without automatic line flushing, with the
 specified file.  This convenience constructor creates the necessary
 intermediate {@link java.io.OutputStreamWriter OutputStreamWriter},
 which will encode characters using the {@linkplain
 java.nio.charset.Charset#defaultCharset() default charset} for this
 instance of the Java virtual machine.</description>
					<attribute name="@param">
						<description>file
         The file to use as the destination of this writer.  If the file
         exists then it will be truncated to zero size; otherwise, a new
         file will be created.  The output will be written to the file
         and is buffered.</description>
					</attribute>
					<attribute name="@throws">
						<description>FileNotFoundException
          If the given file object does not denote an existing, writable
          regular file and a new regular file of that name cannot be
          created, or if some other error occurs while opening or
          creating the file</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException
          If a security manager is present and {@link
          SecurityManager#checkWrite checkWrite(file.getPath())}
          denies write access to the file</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
				<params>
					<param name="file" comment="The file to use as the destination of this writer.  If the file
         exists then it will be truncated to zero size; otherwise, a new
         file will be created.  The output will be written to the file
         and is buffered." fulltype="java.io.File" type="File" />
				</params>
				<exceptions>
					<exception comment="If the given file object does not denote an existing, writable
          regular file and a new regular file of that name cannot be
          created, or if some other error occurs while opening or
          creating the file" fulltype="java.io.FileNotFoundException" type="FileNotFoundException" />
				</exceptions>
			</constructor>
			<constructor visibility="public" name="PrintWriter">
				<comment>
					<description>Creates a new PrintWriter, without automatic line flushing, with the
 specified file and charset.  This convenience constructor creates the
 necessary intermediate {@link java.io.OutputStreamWriter
 OutputStreamWriter}, which will encode characters using the provided
 charset.</description>
					<attribute name="@param">
						<description>file
         The file to use as the destination of this writer.  If the file
         exists then it will be truncated to zero size; otherwise, a new
         file will be created.  The output will be written to the file
         and is buffered.</description>
					</attribute>
					<attribute name="@param">
						<description>csn
         The name of a supported {@linkplain java.nio.charset.Charset
         charset}</description>
					</attribute>
					<attribute name="@throws">
						<description>FileNotFoundException
          If the given file object does not denote an existing, writable
          regular file and a new regular file of that name cannot be
          created, or if some other error occurs while opening or
          creating the file</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException
          If a security manager is present and {@link
          SecurityManager#checkWrite checkWrite(file.getPath())}
          denies write access to the file</description>
					</attribute>
					<attribute name="@throws">
						<description>UnsupportedEncodingException
          If the named charset is not supported</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
				<params>
					<param name="file" comment="The file to use as the destination of this writer.  If the file
         exists then it will be truncated to zero size; otherwise, a new
         file will be created.  The output will be written to the file
         and is buffered." fulltype="java.io.File" type="File" />
					<param name="csn" comment="The name of a supported {@linkplain java.nio.charset.Charset
         charset}" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception comment="If the given file object does not denote an existing, writable
          regular file and a new regular file of that name cannot be
          created, or if some other error occurs while opening or
          creating the file" fulltype="java.io.FileNotFoundException" type="FileNotFoundException" />
					<exception comment="If the named charset is not supported" fulltype="java.io.UnsupportedEncodingException" type="UnsupportedEncodingException" />
				</exceptions>
			</constructor>
			<method visibility="private" name="ensureOpen" fulltype="void" type="void">
				<comment>
					<description>Checks to make sure that the stream has not been closed</description>
				</comment>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="flush" fulltype="void" type="void">
				<comment>
					<description>Flushes the stream.</description>
					<attribute name="@see">
						<description>#checkError()</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="close" fulltype="void" type="void">
				<comment>
					<description>Closes the stream and releases any system resources associated
 with it. Closing a previously closed stream has no effect.</description>
					<attribute name="@see">
						<description>#checkError()</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="checkError" returncomment="&lt;code&gt;true&lt;/code&gt; if the print stream has encountered an error,
          either on the underlying output stream or during a format
          conversion." fulltype="boolean" type="boolean">
				<comment>
					<description>Flushes the stream if it&apos;s not closed and checks its error state.</description>
					<attribute name="@return">
						<description>&lt;code&gt;true&lt;/code&gt; if the print stream has encountered an error,
          either on the underlying output stream or during a format
          conversion.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="protected" name="setError" fulltype="void" type="void">
				<comment>
					<description>Indicates that an error has occurred.

 &lt;p&gt; This method will cause subsequent invocations of {@link
 #checkError()} to return &lt;tt&gt;true&lt;/tt&gt; until {@link
 #clearError()} is invoked.</description>
				</comment>
			</method>
			<method visibility="protected" name="clearError" fulltype="void" type="void">
				<comment>
					<description>Clears the error state of this stream.

 &lt;p&gt; This method will cause subsequent invocations of {@link
 #checkError()} to return &lt;tt&gt;false&lt;/tt&gt; until another write
 operation fails and invokes {@link #setError()}.</description>
					<attribute name="@since">
						<description>1.6</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes a single character.</description>
					<attribute name="@param">
						<description>c int specifying a character to be written.</description>
					</attribute>
				</comment>
				<params>
					<param name="c" comment="int specifying a character to be written." fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes A Portion of an array of characters.</description>
					<attribute name="@param">
						<description>buf Array of characters</description>
					</attribute>
					<attribute name="@param">
						<description>off Offset from which to start writing characters</description>
					</attribute>
					<attribute name="@param">
						<description>len Number of characters to write</description>
					</attribute>
				</comment>
				<params>
					<param name="buf" comment="Array of characters" fulltype="char[]" type="char" />
					<param name="off" comment="Offset from which to start writing characters" fulltype="int" type="int" />
					<param name="len" comment="Number of characters to write" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes an array of characters.  This method cannot be inherited from the
 Writer class because it must suppress I/O exceptions.</description>
					<attribute name="@param">
						<description>buf Array of characters to be written</description>
					</attribute>
				</comment>
				<params>
					<param name="buf" comment="Array of characters to be written" fulltype="char[]" type="char" />
				</params>
			</method>
			<method visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes a portion of a string.</description>
					<attribute name="@param">
						<description>s A String</description>
					</attribute>
					<attribute name="@param">
						<description>off Offset from which to start writing characters</description>
					</attribute>
					<attribute name="@param">
						<description>len Number of characters to write</description>
					</attribute>
				</comment>
				<params>
					<param name="s" comment="A String" fulltype="java.lang.String" type="String" />
					<param name="off" comment="Offset from which to start writing characters" fulltype="int" type="int" />
					<param name="len" comment="Number of characters to write" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes a string.  This method cannot be inherited from the Writer class
 because it must suppress I/O exceptions.</description>
					<attribute name="@param">
						<description>s String to be written</description>
					</attribute>
				</comment>
				<params>
					<param name="s" comment="String to be written" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="private" name="newLine" fulltype="void" type="void" />
			<method visibility="public" name="print" fulltype="void" type="void">
				<comment>
					<description>Prints a boolean value.  The string produced by &lt;code&gt;{@link
 java.lang.String#valueOf(boolean)}&lt;/code&gt; is translated into bytes
 according to the platform&apos;s default character encoding, and these bytes
 are written in exactly the manner of the &lt;code&gt;{@link
 #write(int)}&lt;/code&gt; method.</description>
					<attribute name="@param">
						<description>b   The &lt;code&gt;boolean&lt;/code&gt; to be printed</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="The &lt;code&gt;boolean&lt;/code&gt; to be printed" fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method visibility="public" name="print" fulltype="void" type="void">
				<comment>
					<description>Prints a character.  The character is translated into one or more bytes
 according to the platform&apos;s default character encoding, and these bytes
 are written in exactly the manner of the &lt;code&gt;{@link
 #write(int)}&lt;/code&gt; method.</description>
					<attribute name="@param">
						<description>c   The &lt;code&gt;char&lt;/code&gt; to be printed</description>
					</attribute>
				</comment>
				<params>
					<param name="c" comment="The &lt;code&gt;char&lt;/code&gt; to be printed" fulltype="char" type="char" />
				</params>
			</method>
			<method visibility="public" name="print" fulltype="void" type="void">
				<comment>
					<description>Prints an integer.  The string produced by &lt;code&gt;{@link
 java.lang.String#valueOf(int)}&lt;/code&gt; is translated into bytes according
 to the platform&apos;s default character encoding, and these bytes are
 written in exactly the manner of the &lt;code&gt;{@link #write(int)}&lt;/code&gt;
 method.</description>
					<attribute name="@param">
						<description>i   The &lt;code&gt;int&lt;/code&gt; to be printed</description>
					</attribute>
					<attribute name="@see">
						<description>java.lang.Integer#toString(int)</description>
					</attribute>
				</comment>
				<params>
					<param name="i" comment="The &lt;code&gt;int&lt;/code&gt; to be printed" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="print" fulltype="void" type="void">
				<comment>
					<description>Prints a long integer.  The string produced by &lt;code&gt;{@link
 java.lang.String#valueOf(long)}&lt;/code&gt; is translated into bytes
 according to the platform&apos;s default character encoding, and these bytes
 are written in exactly the manner of the &lt;code&gt;{@link #write(int)}&lt;/code&gt;
 method.</description>
					<attribute name="@param">
						<description>l   The &lt;code&gt;long&lt;/code&gt; to be printed</description>
					</attribute>
					<attribute name="@see">
						<description>java.lang.Long#toString(long)</description>
					</attribute>
				</comment>
				<params>
					<param name="l" comment="The &lt;code&gt;long&lt;/code&gt; to be printed" fulltype="long" type="long" />
				</params>
			</method>
			<method visibility="public" name="print" fulltype="void" type="void">
				<comment>
					<description>Prints a floating-point number.  The string produced by &lt;code&gt;{@link
 java.lang.String#valueOf(float)}&lt;/code&gt; is translated into bytes
 according to the platform&apos;s default character encoding, and these bytes
 are written in exactly the manner of the &lt;code&gt;{@link #write(int)}&lt;/code&gt;
 method.</description>
					<attribute name="@param">
						<description>f   The &lt;code&gt;float&lt;/code&gt; to be printed</description>
					</attribute>
					<attribute name="@see">
						<description>java.lang.Float#toString(float)</description>
					</attribute>
				</comment>
				<params>
					<param name="f" comment="The &lt;code&gt;float&lt;/code&gt; to be printed" fulltype="float" type="float" />
				</params>
			</method>
			<method visibility="public" name="print" fulltype="void" type="void">
				<comment>
					<description>Prints a double-precision floating-point number.  The string produced by
 &lt;code&gt;{@link java.lang.String#valueOf(double)}&lt;/code&gt; is translated into
 bytes according to the platform&apos;s default character encoding, and these
 bytes are written in exactly the manner of the &lt;code&gt;{@link
 #write(int)}&lt;/code&gt; method.</description>
					<attribute name="@param">
						<description>d   The &lt;code&gt;double&lt;/code&gt; to be printed</description>
					</attribute>
					<attribute name="@see">
						<description>java.lang.Double#toString(double)</description>
					</attribute>
				</comment>
				<params>
					<param name="d" comment="The &lt;code&gt;double&lt;/code&gt; to be printed" fulltype="double" type="double" />
				</params>
			</method>
			<method visibility="public" name="print" fulltype="void" type="void">
				<comment>
					<description>Prints an array of characters.  The characters are converted into bytes
 according to the platform&apos;s default character encoding, and these bytes
 are written in exactly the manner of the &lt;code&gt;{@link #write(int)}&lt;/code&gt;
 method.</description>
					<attribute name="@param">
						<description>s   The array of chars to be printed</description>
					</attribute>
					<attribute name="@throws">
						<description>NullPointerException  If &lt;code&gt;s&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</description>
					</attribute>
				</comment>
				<params>
					<param name="s" comment="The array of chars to be printed" fulltype="char[]" type="char" />
				</params>
			</method>
			<method visibility="public" name="print" fulltype="void" type="void">
				<comment>
					<description>Prints a string.  If the argument is &lt;code&gt;null&lt;/code&gt; then the string
 &lt;code&gt;&quot;null&quot;&lt;/code&gt; is printed.  Otherwise, the string&apos;s characters are
 converted into bytes according to the platform&apos;s default character
 encoding, and these bytes are written in exactly the manner of the
 &lt;code&gt;{@link #write(int)}&lt;/code&gt; method.</description>
					<attribute name="@param">
						<description>s   The &lt;code&gt;String&lt;/code&gt; to be printed</description>
					</attribute>
				</comment>
				<params>
					<param name="s" comment="The &lt;code&gt;String&lt;/code&gt; to be printed" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="public" name="print" fulltype="void" type="void">
				<comment>
					<description>Prints an object.  The string produced by the &lt;code&gt;{@link
 java.lang.String#valueOf(Object)}&lt;/code&gt; method is translated into bytes
 according to the platform&apos;s default character encoding, and these bytes
 are written in exactly the manner of the &lt;code&gt;{@link #write(int)}&lt;/code&gt;
 method.</description>
					<attribute name="@param">
						<description>obj   The &lt;code&gt;Object&lt;/code&gt; to be printed</description>
					</attribute>
					<attribute name="@see">
						<description>java.lang.Object#toString()</description>
					</attribute>
				</comment>
				<params>
					<param name="obj" comment="The &lt;code&gt;Object&lt;/code&gt; to be printed" fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method visibility="public" name="println" fulltype="void" type="void">
				<comment>
					<description>Terminates the current line by writing the line separator string.  The
 line separator string is defined by the system property
 &lt;code&gt;line.separator&lt;/code&gt;, and is not necessarily a single newline
 character (&lt;code&gt;&apos;\n&apos;&lt;/code&gt;).</description>
				</comment>
			</method>
			<method visibility="public" name="println" fulltype="void" type="void">
				<comment>
					<description>Prints a boolean value and then terminates the line.  This method behaves
 as though it invokes &lt;code&gt;{@link #print(boolean)}&lt;/code&gt; and then
 &lt;code&gt;{@link #println()}&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>x the &lt;code&gt;boolean&lt;/code&gt; value to be printed</description>
					</attribute>
				</comment>
				<params>
					<param name="x" comment="the &lt;code&gt;boolean&lt;/code&gt; value to be printed" fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method visibility="public" name="println" fulltype="void" type="void">
				<comment>
					<description>Prints a character and then terminates the line.  This method behaves as
 though it invokes &lt;code&gt;{@link #print(char)}&lt;/code&gt; and then &lt;code&gt;{@link
 #println()}&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>x the &lt;code&gt;char&lt;/code&gt; value to be printed</description>
					</attribute>
				</comment>
				<params>
					<param name="x" comment="the &lt;code&gt;char&lt;/code&gt; value to be printed" fulltype="char" type="char" />
				</params>
			</method>
			<method visibility="public" name="println" fulltype="void" type="void">
				<comment>
					<description>Prints an integer and then terminates the line.  This method behaves as
 though it invokes &lt;code&gt;{@link #print(int)}&lt;/code&gt; and then &lt;code&gt;{@link
 #println()}&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>x the &lt;code&gt;int&lt;/code&gt; value to be printed</description>
					</attribute>
				</comment>
				<params>
					<param name="x" comment="the &lt;code&gt;int&lt;/code&gt; value to be printed" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="println" fulltype="void" type="void">
				<comment>
					<description>Prints a long integer and then terminates the line.  This method behaves
 as though it invokes &lt;code&gt;{@link #print(long)}&lt;/code&gt; and then
 &lt;code&gt;{@link #println()}&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>x the &lt;code&gt;long&lt;/code&gt; value to be printed</description>
					</attribute>
				</comment>
				<params>
					<param name="x" comment="the &lt;code&gt;long&lt;/code&gt; value to be printed" fulltype="long" type="long" />
				</params>
			</method>
			<method visibility="public" name="println" fulltype="void" type="void">
				<comment>
					<description>Prints a floating-point number and then terminates the line.  This method
 behaves as though it invokes &lt;code&gt;{@link #print(float)}&lt;/code&gt; and then
 &lt;code&gt;{@link #println()}&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>x the &lt;code&gt;float&lt;/code&gt; value to be printed</description>
					</attribute>
				</comment>
				<params>
					<param name="x" comment="the &lt;code&gt;float&lt;/code&gt; value to be printed" fulltype="float" type="float" />
				</params>
			</method>
			<method visibility="public" name="println" fulltype="void" type="void">
				<comment>
					<description>Prints a double-precision floating-point number and then terminates the
 line.  This method behaves as though it invokes &lt;code&gt;{@link
 #print(double)}&lt;/code&gt; and then &lt;code&gt;{@link #println()}&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>x the &lt;code&gt;double&lt;/code&gt; value to be printed</description>
					</attribute>
				</comment>
				<params>
					<param name="x" comment="the &lt;code&gt;double&lt;/code&gt; value to be printed" fulltype="double" type="double" />
				</params>
			</method>
			<method visibility="public" name="println" fulltype="void" type="void">
				<comment>
					<description>Prints an array of characters and then terminates the line.  This method
 behaves as though it invokes &lt;code&gt;{@link #print(char[])}&lt;/code&gt; and then
 &lt;code&gt;{@link #println()}&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>x the array of &lt;code&gt;char&lt;/code&gt; values to be printed</description>
					</attribute>
				</comment>
				<params>
					<param name="x" comment="the array of &lt;code&gt;char&lt;/code&gt; values to be printed" fulltype="char[]" type="char" />
				</params>
			</method>
			<method visibility="public" name="println" fulltype="void" type="void">
				<comment>
					<description>Prints a String and then terminates the line.  This method behaves as
 though it invokes &lt;code&gt;{@link #print(String)}&lt;/code&gt; and then
 &lt;code&gt;{@link #println()}&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>x the &lt;code&gt;String&lt;/code&gt; value to be printed</description>
					</attribute>
				</comment>
				<params>
					<param name="x" comment="the &lt;code&gt;String&lt;/code&gt; value to be printed" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="public" name="println" fulltype="void" type="void">
				<comment>
					<description>Prints an Object and then terminates the line.  This method calls
 at first String.valueOf(x) to get the printed object&apos;s string value,
 then behaves as
 though it invokes &lt;code&gt;{@link #print(String)}&lt;/code&gt; and then
 &lt;code&gt;{@link #println()}&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>x  The &lt;code&gt;Object&lt;/code&gt; to be printed.</description>
					</attribute>
				</comment>
				<params>
					<param name="x" comment="The &lt;code&gt;Object&lt;/code&gt; to be printed." fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method visibility="public" name="printf" returncomment="This writer" fulltype="java.io.PrintWriter" type="PrintWriter">
				<comment>
					<description>A convenience method to write a formatted string to this writer using
 the specified format string and arguments.  If automatic flushing is
 enabled, calls to this method will flush the output buffer.

 &lt;p&gt; An invocation of this method of the form &lt;tt&gt;out.printf(format,
 args)&lt;/tt&gt; behaves in exactly the same way as the invocation

 &lt;pre&gt;
     out.format(format, args) &lt;/pre&gt;</description>
					<attribute name="@param">
						<description>format
         A format string as described in &lt;a
         href=&quot;../util/Formatter.html#syntax&quot;&gt;Format string syntax&lt;/a&gt;.</description>
					</attribute>
					<attribute name="@param">
						<description>args
         Arguments referenced by the format specifiers in the format
         string.  If there are more arguments than format specifiers, the
         extra arguments are ignored.  The number of arguments is
         variable and may be zero.  The maximum number of arguments is
         limited by the maximum dimension of a Java array as defined by
         the &lt;a href=&quot;http://java.sun.com/docs/books/vmspec/&quot;&gt;Java
         Virtual Machine Specification&lt;/a&gt;.  The behaviour on a
         &lt;tt&gt;null&lt;/tt&gt; argument depends on the &lt;a
         href=&quot;../util/Formatter.html#syntax&quot;&gt;conversion&lt;/a&gt;.</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalFormatException
          If a format string contains an illegal syntax, a format
          specifier that is incompatible with the given arguments,
          insufficient arguments given the format string, or other
          illegal conditions.  For specification of all possible
          formatting errors, see the &lt;a
          href=&quot;../util/Formatter.html#detail&quot;&gt;Details&lt;/a&gt; section of the
          formatter class specification.</description>
					</attribute>
					<attribute name="@throws">
						<description>NullPointerException
          If the &lt;tt&gt;format&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;</description>
					</attribute>
					<attribute name="@return">
						<description>This writer</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
				<params>
					<param name="format" comment="A format string as described in &lt;a
         href=&quot;../util/Formatter.html#syntax&quot;&gt;Format string syntax&lt;/a&gt;." fulltype="java.lang.String" type="String" />
					<param name="args" comment="Arguments referenced by the format specifiers in the format
         string.  If there are more arguments than format specifiers, the
         extra arguments are ignored.  The number of arguments is
         variable and may be zero.  The maximum number of arguments is
         limited by the maximum dimension of a Java array as defined by
         the &lt;a href=&quot;http://java.sun.com/docs/books/vmspec/&quot;&gt;Java
         Virtual Machine Specification&lt;/a&gt;.  The behaviour on a
         &lt;tt&gt;null&lt;/tt&gt; argument depends on the &lt;a
         href=&quot;../util/Formatter.html#syntax&quot;&gt;conversion&lt;/a&gt;." fulltype="java.lang.Object[]" type="Object" />
				</params>
			</method>
			<method visibility="public" name="printf" returncomment="This writer" fulltype="java.io.PrintWriter" type="PrintWriter">
				<comment>
					<description>A convenience method to write a formatted string to this writer using
 the specified format string and arguments.  If automatic flushing is
 enabled, calls to this method will flush the output buffer.

 &lt;p&gt; An invocation of this method of the form &lt;tt&gt;out.printf(l, format,
 args)&lt;/tt&gt; behaves in exactly the same way as the invocation

 &lt;pre&gt;
     out.format(l, format, args) &lt;/pre&gt;</description>
					<attribute name="@param">
						<description>l
         The {@linkplain java.util.Locale locale} to apply during
         formatting.  If &lt;tt&gt;l&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt; then no localization
         is applied.</description>
					</attribute>
					<attribute name="@param">
						<description>format
         A format string as described in &lt;a
         href=&quot;../util/Formatter.html#syntax&quot;&gt;Format string syntax&lt;/a&gt;.</description>
					</attribute>
					<attribute name="@param">
						<description>args
         Arguments referenced by the format specifiers in the format
         string.  If there are more arguments than format specifiers, the
         extra arguments are ignored.  The number of arguments is
         variable and may be zero.  The maximum number of arguments is
         limited by the maximum dimension of a Java array as defined by
         the &lt;a href=&quot;http://java.sun.com/docs/books/vmspec/&quot;&gt;Java
         Virtual Machine Specification&lt;/a&gt;.  The behaviour on a
         &lt;tt&gt;null&lt;/tt&gt; argument depends on the &lt;a
         href=&quot;../util/Formatter.html#syntax&quot;&gt;conversion&lt;/a&gt;.</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalFormatException
          If a format string contains an illegal syntax, a format
          specifier that is incompatible with the given arguments,
          insufficient arguments given the format string, or other
          illegal conditions.  For specification of all possible
          formatting errors, see the &lt;a
          href=&quot;../util/Formatter.html#detail&quot;&gt;Details&lt;/a&gt; section of the
          formatter class specification.</description>
					</attribute>
					<attribute name="@throws">
						<description>NullPointerException
          If the &lt;tt&gt;format&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;</description>
					</attribute>
					<attribute name="@return">
						<description>This writer</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
				<params>
					<param name="l" comment="The {@linkplain java.util.Locale locale} to apply during
         formatting.  If &lt;tt&gt;l&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt; then no localization
         is applied." fulltype="java.util.Locale" type="Locale" />
					<param name="format" comment="A format string as described in &lt;a
         href=&quot;../util/Formatter.html#syntax&quot;&gt;Format string syntax&lt;/a&gt;." fulltype="java.lang.String" type="String" />
					<param name="args" comment="Arguments referenced by the format specifiers in the format
         string.  If there are more arguments than format specifiers, the
         extra arguments are ignored.  The number of arguments is
         variable and may be zero.  The maximum number of arguments is
         limited by the maximum dimension of a Java array as defined by
         the &lt;a href=&quot;http://java.sun.com/docs/books/vmspec/&quot;&gt;Java
         Virtual Machine Specification&lt;/a&gt;.  The behaviour on a
         &lt;tt&gt;null&lt;/tt&gt; argument depends on the &lt;a
         href=&quot;../util/Formatter.html#syntax&quot;&gt;conversion&lt;/a&gt;." fulltype="java.lang.Object[]" type="Object" />
				</params>
			</method>
			<method visibility="public" name="format" returncomment="This writer" fulltype="java.io.PrintWriter" type="PrintWriter">
				<comment>
					<description>Writes a formatted string to this writer using the specified format
 string and arguments.  If automatic flushing is enabled, calls to this
 method will flush the output buffer.

 &lt;p&gt; The locale always used is the one returned by {@link
 java.util.Locale#getDefault() Locale.getDefault()}, regardless of any
 previous invocations of other formatting methods on this object.</description>
					<attribute name="@param">
						<description>format
         A format string as described in &lt;a
         href=&quot;../util/Formatter.html#syntax&quot;&gt;Format string syntax&lt;/a&gt;.</description>
					</attribute>
					<attribute name="@param">
						<description>args
         Arguments referenced by the format specifiers in the format
         string.  If there are more arguments than format specifiers, the
         extra arguments are ignored.  The number of arguments is
         variable and may be zero.  The maximum number of arguments is
         limited by the maximum dimension of a Java array as defined by
         the &lt;a href=&quot;http://java.sun.com/docs/books/vmspec/&quot;&gt;Java
         Virtual Machine Specification&lt;/a&gt;.  The behaviour on a
         &lt;tt&gt;null&lt;/tt&gt; argument depends on the &lt;a
         href=&quot;../util/Formatter.html#syntax&quot;&gt;conversion&lt;/a&gt;.</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalFormatException
          If a format string contains an illegal syntax, a format
          specifier that is incompatible with the given arguments,
          insufficient arguments given the format string, or other
          illegal conditions.  For specification of all possible
          formatting errors, see the &lt;a
          href=&quot;../util/Formatter.html#detail&quot;&gt;Details&lt;/a&gt; section of the
          Formatter class specification.</description>
					</attribute>
					<attribute name="@throws">
						<description>NullPointerException
          If the &lt;tt&gt;format&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;</description>
					</attribute>
					<attribute name="@return">
						<description>This writer</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
				<params>
					<param name="format" comment="A format string as described in &lt;a
         href=&quot;../util/Formatter.html#syntax&quot;&gt;Format string syntax&lt;/a&gt;." fulltype="java.lang.String" type="String" />
					<param name="args" comment="Arguments referenced by the format specifiers in the format
         string.  If there are more arguments than format specifiers, the
         extra arguments are ignored.  The number of arguments is
         variable and may be zero.  The maximum number of arguments is
         limited by the maximum dimension of a Java array as defined by
         the &lt;a href=&quot;http://java.sun.com/docs/books/vmspec/&quot;&gt;Java
         Virtual Machine Specification&lt;/a&gt;.  The behaviour on a
         &lt;tt&gt;null&lt;/tt&gt; argument depends on the &lt;a
         href=&quot;../util/Formatter.html#syntax&quot;&gt;conversion&lt;/a&gt;." fulltype="java.lang.Object[]" type="Object" />
				</params>
			</method>
			<method visibility="public" name="format" returncomment="This writer" fulltype="java.io.PrintWriter" type="PrintWriter">
				<comment>
					<description>Writes a formatted string to this writer using the specified format
 string and arguments.  If automatic flushing is enabled, calls to this
 method will flush the output buffer.</description>
					<attribute name="@param">
						<description>l
         The {@linkplain java.util.Locale locale} to apply during
         formatting.  If &lt;tt&gt;l&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt; then no localization
         is applied.</description>
					</attribute>
					<attribute name="@param">
						<description>format
         A format string as described in &lt;a
         href=&quot;../util/Formatter.html#syntax&quot;&gt;Format string syntax&lt;/a&gt;.</description>
					</attribute>
					<attribute name="@param">
						<description>args
         Arguments referenced by the format specifiers in the format
         string.  If there are more arguments than format specifiers, the
         extra arguments are ignored.  The number of arguments is
         variable and may be zero.  The maximum number of arguments is
         limited by the maximum dimension of a Java array as defined by
         the &lt;a href=&quot;http://java.sun.com/docs/books/vmspec/&quot;&gt;Java
         Virtual Machine Specification&lt;/a&gt;.  The behaviour on a
         &lt;tt&gt;null&lt;/tt&gt; argument depends on the &lt;a
         href=&quot;../util/Formatter.html#syntax&quot;&gt;conversion&lt;/a&gt;.</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalFormatException
          If a format string contains an illegal syntax, a format
          specifier that is incompatible with the given arguments,
          insufficient arguments given the format string, or other
          illegal conditions.  For specification of all possible
          formatting errors, see the &lt;a
          href=&quot;../util/Formatter.html#detail&quot;&gt;Details&lt;/a&gt; section of the
          formatter class specification.</description>
					</attribute>
					<attribute name="@throws">
						<description>NullPointerException
          If the &lt;tt&gt;format&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;</description>
					</attribute>
					<attribute name="@return">
						<description>This writer</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
				<params>
					<param name="l" comment="The {@linkplain java.util.Locale locale} to apply during
         formatting.  If &lt;tt&gt;l&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt; then no localization
         is applied." fulltype="java.util.Locale" type="Locale" />
					<param name="format" comment="A format string as described in &lt;a
         href=&quot;../util/Formatter.html#syntax&quot;&gt;Format string syntax&lt;/a&gt;." fulltype="java.lang.String" type="String" />
					<param name="args" comment="Arguments referenced by the format specifiers in the format
         string.  If there are more arguments than format specifiers, the
         extra arguments are ignored.  The number of arguments is
         variable and may be zero.  The maximum number of arguments is
         limited by the maximum dimension of a Java array as defined by
         the &lt;a href=&quot;http://java.sun.com/docs/books/vmspec/&quot;&gt;Java
         Virtual Machine Specification&lt;/a&gt;.  The behaviour on a
         &lt;tt&gt;null&lt;/tt&gt; argument depends on the &lt;a
         href=&quot;../util/Formatter.html#syntax&quot;&gt;conversion&lt;/a&gt;." fulltype="java.lang.Object[]" type="Object" />
				</params>
			</method>
			<method visibility="public" name="append" returncomment="This writer" fulltype="java.io.PrintWriter" type="PrintWriter">
				<comment>
					<description>Appends the specified character sequence to this writer.

 &lt;p&gt; An invocation of this method of the form &lt;tt&gt;out.append(csq)&lt;/tt&gt;
 behaves in exactly the same way as the invocation

 &lt;pre&gt;
     out.write(csq.toString()) &lt;/pre&gt;

 &lt;p&gt; Depending on the specification of &lt;tt&gt;toString&lt;/tt&gt; for the
 character sequence &lt;tt&gt;csq&lt;/tt&gt;, the entire sequence may not be
 appended. For instance, invoking the &lt;tt&gt;toString&lt;/tt&gt; method of a
 character buffer will return a subsequence whose content depends upon
 the buffer&apos;s position and limit.</description>
					<attribute name="@param">
						<description>csq
         The character sequence to append.  If &lt;tt&gt;csq&lt;/tt&gt; is
         &lt;tt&gt;null&lt;/tt&gt;, then the four characters &lt;tt&gt;&quot;null&quot;&lt;/tt&gt; are
         appended to this writer.</description>
					</attribute>
					<attribute name="@return">
						<description>This writer</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
				<params>
					<param name="csq" comment="The character sequence to append.  If &lt;tt&gt;csq&lt;/tt&gt; is
         &lt;tt&gt;null&lt;/tt&gt;, then the four characters &lt;tt&gt;&quot;null&quot;&lt;/tt&gt; are
         appended to this writer." fulltype="java.lang.CharSequence" type="CharSequence" />
				</params>
			</method>
			<method visibility="public" name="append" returncomment="This writer" fulltype="java.io.PrintWriter" type="PrintWriter">
				<comment>
					<description>Appends a subsequence of the specified character sequence to this writer.

 &lt;p&gt; An invocation of this method of the form &lt;tt&gt;out.append(csq, start,
 end)&lt;/tt&gt; when &lt;tt&gt;csq&lt;/tt&gt; is not &lt;tt&gt;null&lt;/tt&gt;, behaves in
 exactly the same way as the invocation

 &lt;pre&gt;
     out.write(csq.subSequence(start, end).toString()) &lt;/pre&gt;</description>
					<attribute name="@param">
						<description>csq
         The character sequence from which a subsequence will be
         appended.  If &lt;tt&gt;csq&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;, then characters
         will be appended as if &lt;tt&gt;csq&lt;/tt&gt; contained the four
         characters &lt;tt&gt;&quot;null&quot;&lt;/tt&gt;.</description>
					</attribute>
					<attribute name="@param">
						<description>start
         The index of the first character in the subsequence</description>
					</attribute>
					<attribute name="@param">
						<description>end
         The index of the character following the last character in the
         subsequence</description>
					</attribute>
					<attribute name="@return">
						<description>This writer</description>
					</attribute>
					<attribute name="@throws">
						<description>IndexOutOfBoundsException
          If &lt;tt&gt;start&lt;/tt&gt; or &lt;tt&gt;end&lt;/tt&gt; are negative, &lt;tt&gt;start&lt;/tt&gt;
          is greater than &lt;tt&gt;end&lt;/tt&gt;, or &lt;tt&gt;end&lt;/tt&gt; is greater than
          &lt;tt&gt;csq.length()&lt;/tt&gt;</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
				<params>
					<param name="csq" comment="The character sequence from which a subsequence will be
         appended.  If &lt;tt&gt;csq&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;, then characters
         will be appended as if &lt;tt&gt;csq&lt;/tt&gt; contained the four
         characters &lt;tt&gt;&quot;null&quot;&lt;/tt&gt;." fulltype="java.lang.CharSequence" type="CharSequence" />
					<param name="start" comment="The index of the first character in the subsequence" fulltype="int" type="int" />
					<param name="end" comment="The index of the character following the last character in the
         subsequence" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="append" returncomment="This writer" fulltype="java.io.PrintWriter" type="PrintWriter">
				<comment>
					<description>Appends the specified character to this writer.

 &lt;p&gt; An invocation of this method of the form &lt;tt&gt;out.append(c)&lt;/tt&gt;
 behaves in exactly the same way as the invocation

 &lt;pre&gt;
     out.write(c) &lt;/pre&gt;</description>
					<attribute name="@param">
						<description>c
         The 16-bit character to append</description>
					</attribute>
					<attribute name="@return">
						<description>This writer</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
				<params>
					<param name="c" comment="The 16-bit character to append" fulltype="char" type="char" />
				</params>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="Object" visibility="public" package="java.io" serializable="true" superclassfulltype="java.lang.Object" fulltype="java.io.ObjectStreamClass" type="ObjectStreamClass">
		<implements>
			<interface fulltype="java.io.Serializable" type="Serializable" />
		</implements>
		<comment>
			<description>Serialization&apos;s descriptor for classes.  It contains the name and
 serialVersionUID of the class.  The ObjectStreamClass for a specific class
 loaded in this Java VM can be found/created using the lookup method.

 &lt;p&gt;The algorithm to compute the SerialVersionUID is described in
 &lt;a href=&quot;../../../platform/serialization/spec/class.html#4100&quot;&gt;Object
 Serialization Specification, Section 4.6, Stream Unique Identifiers&lt;/a&gt;.</description>
			<attribute name="@author">
				<description>Mike Warres</description>
			</attribute>
			<attribute name="@author">
				<description>Roger Riggs</description>
			</attribute>
			<attribute name="@see">
				<description>ObjectStreamField</description>
			</attribute>
			<attribute name="@see">
				<description>&lt;a href=&quot;../../../platform/serialization/spec/class.html&quot;&gt;Object Serialization Specification, Section 4, Class Descriptors&lt;/a&gt;</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.1</description>
			</attribute>
		</comment>
		<fields>
			<field final="true" static="true" visibility="public" name="NO_FIELDS" fulltype="java.io.ObjectStreamField[]" type="ObjectStreamField">
				<comment>
					<description>serialPersistentFields value indicating no serializable fields</description>
				</comment>
			</field>
			<field final="true" static="true" const="-6120832682080437368" visibility="private" name="serialVersionUID" constexpr="-6120832682080437368L" fulltype="long" type="long" />
			<field final="true" static="true" visibility="private" name="serialPersistentFields" fulltype="java.io.ObjectStreamField[]" type="ObjectStreamField" />
			<field final="true" static="true" visibility="private" name="reflFactory" fulltype="sun.reflect.ReflectionFactory" type="ReflectionFactory">
				<comment>
					<description>reflection factory for obtaining serialization constructors</description>
				</comment>
			</field>
			<field visibility="private" name="cl" fulltype="java.lang.Class" type="Class">
				<comment>
					<description>class associated with this descriptor (if any)</description>
				</comment>
			</field>
			<field visibility="private" name="name" fulltype="java.lang.String" type="String">
				<comment>
					<description>name of class represented by this descriptor</description>
				</comment>
			</field>
			<field volatile="true" visibility="private" name="suid" fulltype="java.lang.Long" type="Long">
				<comment>
					<description>serialVersionUID of represented class (null if not computed yet)</description>
				</comment>
			</field>
			<field visibility="private" name="isProxy" fulltype="boolean" type="boolean">
				<comment>
					<description>true if represents dynamic proxy class</description>
				</comment>
			</field>
			<field visibility="private" name="isEnum" fulltype="boolean" type="boolean">
				<comment>
					<description>true if represents enum type</description>
				</comment>
			</field>
			<field visibility="private" name="serializable" fulltype="boolean" type="boolean">
				<comment>
					<description>true if represented class implements Serializable</description>
				</comment>
			</field>
			<field visibility="private" name="externalizable" fulltype="boolean" type="boolean">
				<comment>
					<description>true if represented class implements Externalizable</description>
				</comment>
			</field>
			<field visibility="private" name="hasWriteObjectData" fulltype="boolean" type="boolean">
				<comment>
					<description>true if desc has data written by class-defined writeObject method</description>
				</comment>
			</field>
			<field visibility="private" name="hasBlockExternalData" fulltype="boolean" type="boolean">
				<comment>
					<description>true if desc has externalizable data written in block data format; this
 must be true by default to accommodate ObjectInputStream subclasses which
 override readClassDescriptor() to return class descriptors obtained from
 ObjectStreamClass.lookup() (see 4461737)</description>
				</comment>
			</field>
			<field visibility="private" name="resolveEx" fulltype="java.lang.ClassNotFoundException" type="ClassNotFoundException">
				<comment>
					<description>exception (if any) thrown while attempting to resolve class</description>
				</comment>
			</field>
			<field visibility="private" name="deserializeEx" fulltype="java.io.InvalidClassException" type="InvalidClassException">
				<comment>
					<description>exception (if any) to throw if non-enum deserialization attempted</description>
				</comment>
			</field>
			<field visibility="private" name="serializeEx" fulltype="java.io.InvalidClassException" type="InvalidClassException">
				<comment>
					<description>exception (if any) to throw if non-enum serialization attempted</description>
				</comment>
			</field>
			<field visibility="private" name="defaultSerializeEx" fulltype="java.io.InvalidClassException" type="InvalidClassException">
				<comment>
					<description>exception (if any) to throw if default serialization attempted</description>
				</comment>
			</field>
			<field visibility="private" name="fields" fulltype="java.io.ObjectStreamField[]" type="ObjectStreamField">
				<comment>
					<description>serializable fields</description>
				</comment>
			</field>
			<field visibility="private" name="primDataSize" fulltype="int" type="int">
				<comment>
					<description>aggregate marshalled size of primitive fields</description>
				</comment>
			</field>
			<field visibility="private" name="numObjFields" fulltype="int" type="int">
				<comment>
					<description>number of non-primitive fields</description>
				</comment>
			</field>
			<field visibility="private" name="fieldRefl" fulltype="java.io.ObjectStreamClass.FieldReflector" type="ObjectStreamClass.FieldReflector">
				<comment>
					<description>reflector for setting/getting serializable field values</description>
				</comment>
			</field>
			<field volatile="true" visibility="private" name="dataLayout" fulltype="java.io.ObjectStreamClass.ClassDataSlot[]" type="ObjectStreamClass.ClassDataSlot">
				<comment>
					<description>data layout of serialized objects described by this class desc</description>
				</comment>
			</field>
			<field visibility="private" name="cons" fulltype="java.lang.reflect.Constructor" type="Constructor">
				<comment>
					<description>serialization-appropriate constructor, or null if none</description>
				</comment>
			</field>
			<field visibility="private" name="writeObjectMethod" fulltype="java.lang.reflect.Method" type="Method">
				<comment>
					<description>class-defined writeObject method, or null if none</description>
				</comment>
			</field>
			<field visibility="private" name="readObjectMethod" fulltype="java.lang.reflect.Method" type="Method">
				<comment>
					<description>class-defined readObject method, or null if none</description>
				</comment>
			</field>
			<field visibility="private" name="readObjectNoDataMethod" fulltype="java.lang.reflect.Method" type="Method">
				<comment>
					<description>class-defined readObjectNoData method, or null if none</description>
				</comment>
			</field>
			<field visibility="private" name="writeReplaceMethod" fulltype="java.lang.reflect.Method" type="Method">
				<comment>
					<description>class-defined writeReplace method, or null if none</description>
				</comment>
			</field>
			<field visibility="private" name="readResolveMethod" fulltype="java.lang.reflect.Method" type="Method">
				<comment>
					<description>class-defined readResolve method, or null if none</description>
				</comment>
			</field>
			<field visibility="private" name="localDesc" fulltype="java.io.ObjectStreamClass" type="ObjectStreamClass">
				<comment>
					<description>local class descriptor for represented class (may point to self)</description>
				</comment>
			</field>
			<field visibility="private" name="superDesc" fulltype="java.io.ObjectStreamClass" type="ObjectStreamClass">
				<comment>
					<description>superclass descriptor appearing in stream</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="private" name="ObjectStreamClass">
				<comment>
					<description>Creates local class descriptor representing given class.</description>
				</comment>
				<params>
					<param name="cl" fulltype="java.lang.Class" type="Class" />
				</params>
			</constructor>
			<constructor visibility="package-private" name="ObjectStreamClass">
				<comment>
					<description>Creates blank class descriptor which should be initialized via a
 subsequent call to initProxy(), initNonProxy() or readNonProxy().</description>
				</comment>
			</constructor>
			<method static="true" visibility="private" name="initNative" fulltype="void" type="void">
				<comment>
					<description>Initializes native code.</description>
				</comment>
			</method>
			<method static="true" visibility="public" name="lookup" returncomment="the class descriptor for the specified class" fulltype="java.io.ObjectStreamClass" type="ObjectStreamClass">
				<comment>
					<description>Find the descriptor for a class that can be serialized.  Creates an
 ObjectStreamClass instance if one does not exist yet for class. Null is
 returned if the specified class does not implement java.io.Serializable
 or java.io.Externalizable.</description>
					<attribute name="@param">
						<description>cl class for which to get the descriptor</description>
					</attribute>
					<attribute name="@return">
						<description>the class descriptor for the specified class</description>
					</attribute>
				</comment>
				<params>
					<param name="cl" comment="class for which to get the descriptor" fulltype="java.lang.Class" type="Class" />
				</params>
			</method>
			<method static="true" visibility="public" name="lookupAny" returncomment="the class descriptor for the specified class" fulltype="java.io.ObjectStreamClass" type="ObjectStreamClass">
				<comment>
					<description>Returns the descriptor for any class, regardless of whether it
 implements {@link Serializable}.</description>
					<attribute name="@param">
						<description>cl class for which to get the descriptor</description>
					</attribute>
					<attribute name="@return">
						<description>the class descriptor for the specified class</description>
					</attribute>
					<attribute name="@since">
						<description>1.6</description>
					</attribute>
				</comment>
				<params>
					<param name="cl" comment="class for which to get the descriptor" fulltype="java.lang.Class" type="Class" />
				</params>
			</method>
			<method visibility="public" name="getName" returncomment="a string representing the name of the class" fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the name of the class described by this descriptor.
 This method returns the name of the class in the format that
 is used by the {@link Class#getName} method.</description>
					<attribute name="@return">
						<description>a string representing the name of the class</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getSerialVersionUID" returncomment="the SUID of the class described by this descriptor" fulltype="long" type="long">
				<comment>
					<description>Return the serialVersionUID for this class.  The serialVersionUID
 defines a set of classes all with the same name that have evolved from a
 common root class and agree to be serialized and deserialized using a
 common format.  NonSerializable classes have a serialVersionUID of 0L.</description>
					<attribute name="@return">
						<description>the SUID of the class described by this descriptor</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="forClass" returncomment="the &lt;code&gt;Class&lt;/code&gt; instance that this descriptor represents" fulltype="java.lang.Class" type="Class">
				<comment>
					<description>Return the class in the local VM that this version is mapped to.  Null
 is returned if there is no corresponding local class.</description>
					<attribute name="@return">
						<description>the &lt;code&gt;Class&lt;/code&gt; instance that this descriptor represents</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getFields" returncomment="an array containing an element for each persistent field of
          this class. Returns an array of length zero if there are no
          fields." fulltype="java.io.ObjectStreamField[]" type="ObjectStreamField">
				<comment>
					<description>Return an array of the fields of this serializable class.</description>
					<attribute name="@return">
						<description>an array containing an element for each persistent field of
          this class. Returns an array of length zero if there are no
          fields.</description>
					</attribute>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getField" returncomment="The ObjectStreamField object of the named field or null if
          there is no such named field." fulltype="java.io.ObjectStreamField" type="ObjectStreamField">
				<comment>
					<description>Get the field of this class by name.</description>
					<attribute name="@param">
						<description>name the name of the data field to look for</description>
					</attribute>
					<attribute name="@return">
						<description>The ObjectStreamField object of the named field or null if
          there is no such named field.</description>
					</attribute>
				</comment>
				<params>
					<param name="name" comment="the name of the data field to look for" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="public" name="toString" fulltype="java.lang.String" type="String">
				<comment>
					<description>Return a string describing this ObjectStreamClass.</description>
				</comment>
			</method>
			<method static="true" visibility="package-private" name="lookup" fulltype="java.io.ObjectStreamClass" type="ObjectStreamClass">
				<comment>
					<description>Looks up and returns class descriptor for given class, or null if class
 is non-serializable and &quot;all&quot; is set to false.</description>
					<attribute name="@param">
						<description>cl class to look up</description>
					</attribute>
					<attribute name="@param">
						<description>all if true, return descriptors for all classes; if false, only
          return descriptors for serializable classes</description>
					</attribute>
				</comment>
				<params>
					<param name="cl" comment="class to look up" fulltype="java.lang.Class" type="Class" />
					<param name="all" comment="if true, return descriptors for all classes; if false, only
          return descriptors for serializable classes" fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method visibility="package-private" name="initProxy" fulltype="void" type="void">
				<comment>
					<description>Initializes class descriptor representing a proxy class.</description>
				</comment>
				<params>
					<param name="cl" fulltype="java.lang.Class" type="Class" />
					<param name="resolveEx" fulltype="java.lang.ClassNotFoundException" type="ClassNotFoundException" />
					<param name="superDesc" fulltype="java.io.ObjectStreamClass" type="ObjectStreamClass" />
				</params>
				<exceptions>
					<exception fulltype="java.io.InvalidClassException" type="InvalidClassException" />
				</exceptions>
			</method>
			<method visibility="package-private" name="initNonProxy" fulltype="void" type="void">
				<comment>
					<description>Initializes class descriptor representing a non-proxy class.</description>
				</comment>
				<params>
					<param name="model" fulltype="java.io.ObjectStreamClass" type="ObjectStreamClass" />
					<param name="cl" fulltype="java.lang.Class" type="Class" />
					<param name="resolveEx" fulltype="java.lang.ClassNotFoundException" type="ClassNotFoundException" />
					<param name="superDesc" fulltype="java.io.ObjectStreamClass" type="ObjectStreamClass" />
				</params>
				<exceptions>
					<exception fulltype="java.io.InvalidClassException" type="InvalidClassException" />
				</exceptions>
			</method>
			<method visibility="package-private" name="readNonProxy" fulltype="void" type="void">
				<comment>
					<description>Reads non-proxy class descriptor information from given input stream.
 The resulting class descriptor is not fully functional; it can only be
 used as input to the ObjectInputStream.resolveClass() and
 ObjectStreamClass.initNonProxy() methods.</description>
				</comment>
				<params>
					<param name="in" fulltype="java.io.ObjectInputStream" type="ObjectInputStream" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
					<exception fulltype="java.lang.ClassNotFoundException" type="ClassNotFoundException" />
				</exceptions>
			</method>
			<method visibility="package-private" name="writeNonProxy" fulltype="void" type="void">
				<comment>
					<description>Writes non-proxy class descriptor information to given output stream.</description>
				</comment>
				<params>
					<param name="out" fulltype="java.io.ObjectOutputStream" type="ObjectOutputStream" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="package-private" name="getResolveException" fulltype="java.lang.ClassNotFoundException" type="ClassNotFoundException">
				<comment>
					<description>Returns ClassNotFoundException (if any) thrown while attempting to
 resolve local class corresponding to this class descriptor.</description>
				</comment>
			</method>
			<method visibility="package-private" name="checkDeserialize" fulltype="void" type="void">
				<comment>
					<description>Throws an InvalidClassException if object instances referencing this
 class descriptor should not be allowed to deserialize.  This method does
 not apply to deserialization of enum constants.</description>
				</comment>
				<exceptions>
					<exception fulltype="java.io.InvalidClassException" type="InvalidClassException" />
				</exceptions>
			</method>
			<method visibility="package-private" name="checkSerialize" fulltype="void" type="void">
				<comment>
					<description>Throws an InvalidClassException if objects whose class is represented by
 this descriptor should not be allowed to serialize.  This method does
 not apply to serialization of enum constants.</description>
				</comment>
				<exceptions>
					<exception fulltype="java.io.InvalidClassException" type="InvalidClassException" />
				</exceptions>
			</method>
			<method visibility="package-private" name="checkDefaultSerialize" fulltype="void" type="void">
				<comment>
					<description>Throws an InvalidClassException if objects whose class is represented by
 this descriptor should not be permitted to use default serialization
 (e.g., if the class declares serializable fields that do not correspond
 to actual fields, and hence must use the GetField API).  This method
 does not apply to deserialization of enum constants.</description>
				</comment>
				<exceptions>
					<exception fulltype="java.io.InvalidClassException" type="InvalidClassException" />
				</exceptions>
			</method>
			<method visibility="package-private" name="getSuperDesc" fulltype="java.io.ObjectStreamClass" type="ObjectStreamClass">
				<comment>
					<description>Returns superclass descriptor.  Note that on the receiving side, the
 superclass descriptor may be bound to a class that is not a superclass
 of the subclass descriptor&apos;s bound class.</description>
				</comment>
			</method>
			<method visibility="package-private" name="getLocalDesc" fulltype="java.io.ObjectStreamClass" type="ObjectStreamClass">
				<comment>
					<description>Returns the &quot;local&quot; class descriptor for the class associated with this
 class descriptor (i.e., the result of
 ObjectStreamClass.lookup(this.forClass())) or null if there is no class
 associated with this descriptor.</description>
				</comment>
			</method>
			<method visibility="package-private" name="getFields" fulltype="java.io.ObjectStreamField[]" type="ObjectStreamField">
				<comment>
					<description>Returns arrays of ObjectStreamFields representing the serializable
 fields of the represented class.  If copy is true, a clone of this class
 descriptor&apos;s field array is returned, otherwise the array itself is
 returned.</description>
				</comment>
				<params>
					<param name="copy" fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method visibility="package-private" name="getField" fulltype="java.io.ObjectStreamField" type="ObjectStreamField">
				<comment>
					<description>Looks up a serializable field of the represented class by name and type.
 A specified type of null matches all types, Object.class matches all
 non-primitive types, and any other non-null type matches assignable
 types only.  Returns matching field, or null if no match found.</description>
				</comment>
				<params>
					<param name="name" fulltype="java.lang.String" type="String" />
					<param name="type" fulltype="java.lang.Class" type="Class" />
				</params>
			</method>
			<method visibility="package-private" name="isProxy" fulltype="boolean" type="boolean">
				<comment>
					<description>Returns true if class descriptor represents a dynamic proxy class, false
 otherwise.</description>
				</comment>
			</method>
			<method visibility="package-private" name="isEnum" fulltype="boolean" type="boolean">
				<comment>
					<description>Returns true if class descriptor represents an enum type, false
 otherwise.</description>
				</comment>
			</method>
			<method visibility="package-private" name="isExternalizable" fulltype="boolean" type="boolean">
				<comment>
					<description>Returns true if represented class implements Externalizable, false
 otherwise.</description>
				</comment>
			</method>
			<method visibility="package-private" name="isSerializable" fulltype="boolean" type="boolean">
				<comment>
					<description>Returns true if represented class implements Serializable, false
 otherwise.</description>
				</comment>
			</method>
			<method visibility="package-private" name="hasBlockExternalData" fulltype="boolean" type="boolean">
				<comment>
					<description>Returns true if class descriptor represents externalizable class that
 has written its data in 1.2 (block data) format, false otherwise.</description>
				</comment>
			</method>
			<method visibility="package-private" name="hasWriteObjectData" fulltype="boolean" type="boolean">
				<comment>
					<description>Returns true if class descriptor represents serializable (but not
 externalizable) class which has written its data via a custom
 writeObject() method, false otherwise.</description>
				</comment>
			</method>
			<method visibility="package-private" name="isInstantiable" fulltype="boolean" type="boolean">
				<comment>
					<description>Returns true if represented class is serializable/externalizable and can
 be instantiated by the serialization runtime--i.e., if it is
 externalizable and defines a public no-arg constructor, or if it is
 non-externalizable and its first non-serializable superclass defines an
 accessible no-arg constructor.  Otherwise, returns false.</description>
				</comment>
			</method>
			<method visibility="package-private" name="hasWriteObjectMethod" fulltype="boolean" type="boolean">
				<comment>
					<description>Returns true if represented class is serializable (but not
 externalizable) and defines a conformant writeObject method.  Otherwise,
 returns false.</description>
				</comment>
			</method>
			<method visibility="package-private" name="hasReadObjectMethod" fulltype="boolean" type="boolean">
				<comment>
					<description>Returns true if represented class is serializable (but not
 externalizable) and defines a conformant readObject method.  Otherwise,
 returns false.</description>
				</comment>
			</method>
			<method visibility="package-private" name="hasReadObjectNoDataMethod" fulltype="boolean" type="boolean">
				<comment>
					<description>Returns true if represented class is serializable (but not
 externalizable) and defines a conformant readObjectNoData method.
 Otherwise, returns false.</description>
				</comment>
			</method>
			<method visibility="package-private" name="hasWriteReplaceMethod" fulltype="boolean" type="boolean">
				<comment>
					<description>Returns true if represented class is serializable or externalizable and
 defines a conformant writeReplace method.  Otherwise, returns false.</description>
				</comment>
			</method>
			<method visibility="package-private" name="hasReadResolveMethod" fulltype="boolean" type="boolean">
				<comment>
					<description>Returns true if represented class is serializable or externalizable and
 defines a conformant readResolve method.  Otherwise, returns false.</description>
				</comment>
			</method>
			<method visibility="package-private" name="newInstance" fulltype="java.lang.Object" type="Object">
				<comment>
					<description>Creates a new instance of the represented class.  If the class is
 externalizable, invokes its public no-arg constructor; otherwise, if the
 class is serializable, invokes the no-arg constructor of the first
 non-serializable superclass.  Throws UnsupportedOperationException if
 this class descriptor is not associated with a class, if the associated
 class is non-serializable or if the appropriate no-arg constructor is
 inaccessible/unavailable.</description>
				</comment>
				<exceptions>
					<exception fulltype="java.lang.InstantiationException" type="InstantiationException" />
					<exception fulltype="java.lang.reflect.InvocationTargetException" type="InvocationTargetException" />
					<exception fulltype="java.lang.UnsupportedOperationException" type="UnsupportedOperationException" />
				</exceptions>
			</method>
			<method visibility="package-private" name="invokeWriteObject" fulltype="void" type="void">
				<comment>
					<description>Invokes the writeObject method of the represented serializable class.
 Throws UnsupportedOperationException if this class descriptor is not
 associated with a class, or if the class is externalizable,
 non-serializable or does not define writeObject.</description>
				</comment>
				<params>
					<param name="obj" fulltype="java.lang.Object" type="Object" />
					<param name="out" fulltype="java.io.ObjectOutputStream" type="ObjectOutputStream" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
					<exception fulltype="java.lang.UnsupportedOperationException" type="UnsupportedOperationException" />
				</exceptions>
			</method>
			<method visibility="package-private" name="invokeReadObject" fulltype="void" type="void">
				<comment>
					<description>Invokes the readObject method of the represented serializable class.
 Throws UnsupportedOperationException if this class descriptor is not
 associated with a class, or if the class is externalizable,
 non-serializable or does not define readObject.</description>
				</comment>
				<params>
					<param name="obj" fulltype="java.lang.Object" type="Object" />
					<param name="in" fulltype="java.io.ObjectInputStream" type="ObjectInputStream" />
				</params>
				<exceptions>
					<exception fulltype="java.lang.ClassNotFoundException" type="ClassNotFoundException" />
					<exception fulltype="java.io.IOException" type="IOException" />
					<exception fulltype="java.lang.UnsupportedOperationException" type="UnsupportedOperationException" />
				</exceptions>
			</method>
			<method visibility="package-private" name="invokeReadObjectNoData" fulltype="void" type="void">
				<comment>
					<description>Invokes the readObjectNoData method of the represented serializable
 class.  Throws UnsupportedOperationException if this class descriptor is
 not associated with a class, or if the class is externalizable,
 non-serializable or does not define readObjectNoData.</description>
				</comment>
				<params>
					<param name="obj" fulltype="java.lang.Object" type="Object" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
					<exception fulltype="java.lang.UnsupportedOperationException" type="UnsupportedOperationException" />
				</exceptions>
			</method>
			<method visibility="package-private" name="invokeWriteReplace" fulltype="java.lang.Object" type="Object">
				<comment>
					<description>Invokes the writeReplace method of the represented serializable class and
 returns the result.  Throws UnsupportedOperationException if this class
 descriptor is not associated with a class, or if the class is
 non-serializable or does not define writeReplace.</description>
				</comment>
				<params>
					<param name="obj" fulltype="java.lang.Object" type="Object" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
					<exception fulltype="java.lang.UnsupportedOperationException" type="UnsupportedOperationException" />
				</exceptions>
			</method>
			<method visibility="package-private" name="invokeReadResolve" fulltype="java.lang.Object" type="Object">
				<comment>
					<description>Invokes the readResolve method of the represented serializable class and
 returns the result.  Throws UnsupportedOperationException if this class
 descriptor is not associated with a class, or if the class is
 non-serializable or does not define readResolve.</description>
				</comment>
				<params>
					<param name="obj" fulltype="java.lang.Object" type="Object" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
					<exception fulltype="java.lang.UnsupportedOperationException" type="UnsupportedOperationException" />
				</exceptions>
			</method>
			<method visibility="package-private" name="getClassDataLayout" fulltype="java.io.ObjectStreamClass.ClassDataSlot[]" type="ObjectStreamClass.ClassDataSlot">
				<comment>
					<description>Returns array of ClassDataSlot instances representing the data layout
 (including superclass data) for serialized objects described by this
 class descriptor.  ClassDataSlots are ordered by inheritance with those
 containing &quot;higher&quot; superclasses appearing first.  The final
 ClassDataSlot contains a reference to this descriptor.</description>
				</comment>
				<exceptions>
					<exception fulltype="java.io.InvalidClassException" type="InvalidClassException" />
				</exceptions>
			</method>
			<method visibility="private" name="getClassDataLayout0" fulltype="java.io.ObjectStreamClass.ClassDataSlot[]" type="ObjectStreamClass.ClassDataSlot">
				<exceptions>
					<exception fulltype="java.io.InvalidClassException" type="InvalidClassException" />
				</exceptions>
			</method>
			<method visibility="package-private" name="getPrimDataSize" fulltype="int" type="int">
				<comment>
					<description>Returns aggregate size (in bytes) of marshalled primitive field values
 for represented class.</description>
				</comment>
			</method>
			<method visibility="package-private" name="getNumObjFields" fulltype="int" type="int">
				<comment>
					<description>Returns number of non-primitive serializable fields of represented
 class.</description>
				</comment>
			</method>
			<method visibility="package-private" name="getPrimFieldValues" fulltype="void" type="void">
				<comment>
					<description>Fetches the serializable primitive field values of object obj and
 marshals them into byte array buf starting at offset 0.  It is the
 responsibility of the caller to ensure that obj is of the proper type if
 non-null.</description>
				</comment>
				<params>
					<param name="obj" fulltype="java.lang.Object" type="Object" />
					<param name="buf" fulltype="byte[]" type="byte" />
				</params>
			</method>
			<method visibility="package-private" name="setPrimFieldValues" fulltype="void" type="void">
				<comment>
					<description>Sets the serializable primitive fields of object obj using values
 unmarshalled from byte array buf starting at offset 0.  It is the
 responsibility of the caller to ensure that obj is of the proper type if
 non-null.</description>
				</comment>
				<params>
					<param name="obj" fulltype="java.lang.Object" type="Object" />
					<param name="buf" fulltype="byte[]" type="byte" />
				</params>
			</method>
			<method visibility="package-private" name="getObjFieldValues" fulltype="void" type="void">
				<comment>
					<description>Fetches the serializable object field values of object obj and stores
 them in array vals starting at offset 0.  It is the responsibility of
 the caller to ensure that obj is of the proper type if non-null.</description>
				</comment>
				<params>
					<param name="obj" fulltype="java.lang.Object" type="Object" />
					<param name="vals" fulltype="java.lang.Object[]" type="Object" />
				</params>
			</method>
			<method visibility="package-private" name="setObjFieldValues" fulltype="void" type="void">
				<comment>
					<description>Sets the serializable object fields of object obj using values from
 array vals starting at offset 0.  It is the responsibility of the caller
 to ensure that obj is of the proper type if non-null.</description>
				</comment>
				<params>
					<param name="obj" fulltype="java.lang.Object" type="Object" />
					<param name="vals" fulltype="java.lang.Object[]" type="Object" />
				</params>
			</method>
			<method visibility="private" name="computeFieldOffsets" fulltype="void" type="void">
				<comment>
					<description>Calculates and sets serializable field offsets, as well as primitive
 data size and object field count totals.  Throws InvalidClassException
 if fields are illegally ordered.</description>
				</comment>
				<exceptions>
					<exception fulltype="java.io.InvalidClassException" type="InvalidClassException" />
				</exceptions>
			</method>
			<method visibility="private" name="getVariantFor" fulltype="java.io.ObjectStreamClass" type="ObjectStreamClass">
				<comment>
					<description>If given class is the same as the class associated with this class
 descriptor, returns reference to this class descriptor.  Otherwise,
 returns variant of this class descriptor bound to given class.</description>
				</comment>
				<params>
					<param name="cl" fulltype="java.lang.Class" type="Class" />
				</params>
				<exceptions>
					<exception fulltype="java.io.InvalidClassException" type="InvalidClassException" />
				</exceptions>
			</method>
			<method static="true" visibility="private" name="getExternalizableConstructor" fulltype="java.lang.reflect.Constructor" type="Constructor">
				<comment>
					<description>Returns public no-arg constructor of given class, or null if none found.
 Access checks are disabled on the returned constructor (if any), since
 the defining class may still be non-public.</description>
				</comment>
				<params>
					<param name="cl" fulltype="java.lang.Class" type="Class" />
				</params>
			</method>
			<method static="true" visibility="private" name="getSerializableConstructor" fulltype="java.lang.reflect.Constructor" type="Constructor">
				<comment>
					<description>Returns subclass-accessible no-arg constructor of first non-serializable
 superclass, or null if none found.  Access checks are disabled on the
 returned constructor (if any).</description>
				</comment>
				<params>
					<param name="cl" fulltype="java.lang.Class" type="Class" />
				</params>
			</method>
			<method static="true" visibility="private" name="getInheritableMethod" fulltype="java.lang.reflect.Method" type="Method">
				<comment>
					<description>Returns non-static, non-abstract method with given signature provided it
 is defined by or accessible (via inheritance) by the given class, or
 null if no match found.  Access checks are disabled on the returned
 method (if any).</description>
				</comment>
				<params>
					<param name="cl" fulltype="java.lang.Class" type="Class" />
					<param name="name" fulltype="java.lang.String" type="String" />
					<param name="argTypes" fulltype="java.lang.Class[]" type="Class" />
					<param name="returnType" fulltype="java.lang.Class" type="Class" />
				</params>
			</method>
			<method static="true" visibility="private" name="getPrivateMethod" fulltype="java.lang.reflect.Method" type="Method">
				<comment>
					<description>Returns non-static private method with given signature defined by given
 class, or null if none found.  Access checks are disabled on the
 returned method (if any).</description>
				</comment>
				<params>
					<param name="cl" fulltype="java.lang.Class" type="Class" />
					<param name="name" fulltype="java.lang.String" type="String" />
					<param name="argTypes" fulltype="java.lang.Class[]" type="Class" />
					<param name="returnType" fulltype="java.lang.Class" type="Class" />
				</params>
			</method>
			<method static="true" visibility="private" name="packageEquals" fulltype="boolean" type="boolean">
				<comment>
					<description>Returns true if classes are defined in the same runtime package, false
 otherwise.</description>
				</comment>
				<params>
					<param name="cl1" fulltype="java.lang.Class" type="Class" />
					<param name="cl2" fulltype="java.lang.Class" type="Class" />
				</params>
			</method>
			<method static="true" visibility="private" name="getPackageName" fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns package name of given class.</description>
				</comment>
				<params>
					<param name="cl" fulltype="java.lang.Class" type="Class" />
				</params>
			</method>
			<method static="true" visibility="private" name="classNamesEqual" fulltype="boolean" type="boolean">
				<comment>
					<description>Compares class names for equality, ignoring package names.  Returns true
 if class names equal, false otherwise.</description>
				</comment>
				<params>
					<param name="name1" fulltype="java.lang.String" type="String" />
					<param name="name2" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method static="true" visibility="package-private" name="getClassSignature" fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns JVM type signature for given class.</description>
				</comment>
				<params>
					<param name="cl" fulltype="java.lang.Class" type="Class" />
				</params>
			</method>
			<method static="true" visibility="private" name="getMethodSignature" fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns JVM type signature for given list of parameters and return type.</description>
				</comment>
				<params>
					<param name="paramTypes" fulltype="java.lang.Class[]" type="Class" />
					<param name="retType" fulltype="java.lang.Class" type="Class" />
				</params>
			</method>
			<method static="true" visibility="private" name="throwMiscException" fulltype="void" type="void">
				<comment>
					<description>Convenience method for throwing an exception that is either a
 RuntimeException, Error, or of some unexpected type (in which case it is
 wrapped inside an IOException).</description>
				</comment>
				<params>
					<param name="th" fulltype="java.lang.Throwable" type="Throwable" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method static="true" visibility="private" name="getSerialFields" fulltype="java.io.ObjectStreamField[]" type="ObjectStreamField">
				<comment>
					<description>Returns ObjectStreamField array describing the serializable fields of
 the given class.  Serializable fields backed by an actual field of the
 class are represented by ObjectStreamFields with corresponding non-null
 Field objects.  Throws InvalidClassException if the (explicitly
 declared) serializable fields are invalid.</description>
				</comment>
				<params>
					<param name="cl" fulltype="java.lang.Class" type="Class" />
				</params>
				<exceptions>
					<exception fulltype="java.io.InvalidClassException" type="InvalidClassException" />
				</exceptions>
			</method>
			<method static="true" visibility="private" name="getDeclaredSerialFields" fulltype="java.io.ObjectStreamField[]" type="ObjectStreamField">
				<comment>
					<description>Returns serializable fields of given class as defined explicitly by a
 &quot;serialPersistentFields&quot; field, or null if no appropriate
 &quot;serialPersistentFields&quot; field is defined.  Serializable fields backed
 by an actual field of the class are represented by ObjectStreamFields
 with corresponding non-null Field objects.  For compatibility with past
 releases, a &quot;serialPersistentFields&quot; field with a null value is
 considered equivalent to not declaring &quot;serialPersistentFields&quot;.  Throws
 InvalidClassException if the declared serializable fields are
 invalid--e.g., if multiple fields share the same name.</description>
				</comment>
				<params>
					<param name="cl" fulltype="java.lang.Class" type="Class" />
				</params>
				<exceptions>
					<exception fulltype="java.io.InvalidClassException" type="InvalidClassException" />
				</exceptions>
			</method>
			<method static="true" visibility="private" name="getDefaultSerialFields" fulltype="java.io.ObjectStreamField[]" type="ObjectStreamField">
				<comment>
					<description>Returns array of ObjectStreamFields corresponding to all non-static
 non-transient fields declared by given class.  Each ObjectStreamField
 contains a Field object for the field it represents.  If no default
 serializable fields exist, NO_FIELDS is returned.</description>
				</comment>
				<params>
					<param name="cl" fulltype="java.lang.Class" type="Class" />
				</params>
			</method>
			<method static="true" visibility="private" name="getDeclaredSUID" fulltype="java.lang.Long" type="Long">
				<comment>
					<description>Returns explicit serial version UID value declared by given class, or
 null if none.</description>
				</comment>
				<params>
					<param name="cl" fulltype="java.lang.Class" type="Class" />
				</params>
			</method>
			<method static="true" visibility="private" name="computeDefaultSUID" fulltype="long" type="long">
				<comment>
					<description>Computes the default serial version UID value for the given class.</description>
				</comment>
				<params>
					<param name="cl" fulltype="java.lang.Class" type="Class" />
				</params>
			</method>
			<method static="true" visibility="private" name="hasStaticInitializer" fulltype="boolean" type="boolean">
				<comment>
					<description>Returns true if the given class defines a static initializer method,
 false otherwise.</description>
				</comment>
				<params>
					<param name="cl" fulltype="java.lang.Class" type="Class" />
				</params>
			</method>
			<method static="true" visibility="private" name="getReflector" fulltype="java.io.ObjectStreamClass.FieldReflector" type="ObjectStreamClass.FieldReflector">
				<comment>
					<description>Matches given set of serializable fields with serializable fields
 described by the given local class descriptor, and returns a
 FieldReflector instance capable of setting/getting values from the
 subset of fields that match (non-matching fields are treated as filler,
 for which get operations return default values and set operations
 discard given values).  Throws InvalidClassException if unresolvable
 type conflicts exist between the two sets of fields.</description>
				</comment>
				<params>
					<param name="fields" fulltype="java.io.ObjectStreamField[]" type="ObjectStreamField" />
					<param name="localDesc" fulltype="java.io.ObjectStreamClass" type="ObjectStreamClass" />
				</params>
				<exceptions>
					<exception fulltype="java.io.InvalidClassException" type="InvalidClassException" />
				</exceptions>
			</method>
			<method static="true" visibility="private" name="matchFields" fulltype="java.io.ObjectStreamField[]" type="ObjectStreamField">
				<comment>
					<description>Matches given set of serializable fields with serializable fields
 obtained from the given local class descriptor (which contain bindings
 to reflective Field objects).  Returns list of ObjectStreamFields in
 which each ObjectStreamField whose signature matches that of a local
 field contains a Field object for that field; unmatched
 ObjectStreamFields contain null Field objects.  Shared/unshared settings
 of the returned ObjectStreamFields also reflect those of matched local
 ObjectStreamFields.  Throws InvalidClassException if unresolvable type
 conflicts exist between the two sets of fields.</description>
				</comment>
				<params>
					<param name="fields" fulltype="java.io.ObjectStreamField[]" type="ObjectStreamField" />
					<param name="localDesc" fulltype="java.io.ObjectStreamClass" type="ObjectStreamClass" />
				</params>
				<exceptions>
					<exception fulltype="java.io.InvalidClassException" type="InvalidClassException" />
				</exceptions>
			</method>
			<method static="true" visibility="package-private" name="processQueue" fulltype="void" type="void">
				<comment>
					<description>Removes from the specified map any keys that have been enqueued
 on the specified reference queue.</description>
				</comment>
				<params>
					<param name="queue" fulltype="java.lang.ref.ReferenceQueue" type="ReferenceQueue" />
					<param name="map" fulltype="java.util.concurrent.ConcurrentMap" type="ConcurrentMap" />
				</params>
			</method>
		</methods>
		<jelclass superclass="Object" visibility="private" package="java.io" superclassfulltype="java.lang.Object" fulltype="java.io.ObjectStreamClass.Caches" type="ObjectStreamClass.Caches">
			<fields>
				<field final="true" static="true" visibility="package-private" name="localDescs" fulltype="java.util.concurrent.ConcurrentMap" type="ConcurrentMap">
					<comment>
						<description>cache mapping local classes -&gt; descriptors</description>
					</comment>
				</field>
				<field final="true" static="true" visibility="package-private" name="reflectors" fulltype="java.util.concurrent.ConcurrentMap" type="ConcurrentMap">
					<comment>
						<description>cache mapping field group/local desc pairs -&gt; field reflectors</description>
					</comment>
				</field>
				<field final="true" static="true" visibility="private" name="localDescsQueue" fulltype="java.lang.ref.ReferenceQueue" type="ReferenceQueue">
					<comment>
						<description>queue for WeakReferences to local classes</description>
					</comment>
				</field>
				<field final="true" static="true" visibility="private" name="reflectorsQueue" fulltype="java.lang.ref.ReferenceQueue" type="ReferenceQueue">
					<comment>
						<description>queue for WeakReferences to field reflectors keys</description>
					</comment>
				</field>
			</fields>
			<methods>
				<constructor visibility="private" name="ObjectStreamClass.Caches" />
			</methods>
		</jelclass>
		<jelclass superclass="Object" visibility="private" package="java.io" superclassfulltype="java.lang.Object" fulltype="java.io.ObjectStreamClass.EntryFuture" type="ObjectStreamClass.EntryFuture">
			<comment>
				<description>Placeholder used in class descriptor and field reflector lookup tables
 for an entry in the process of being initialized.  (Internal) callers
 which receive an EntryFuture belonging to another thread as the result
 of a lookup should call the get() method of the EntryFuture; this will
 return the actual entry once it is ready for use and has been set().  To
 conserve objects, EntryFutures synchronize on themselves.</description>
			</comment>
			<fields>
				<field final="true" static="true" visibility="private" name="unset" fulltype="java.lang.Object" type="Object" />
				<field final="true" visibility="private" name="owner" fulltype="java.lang.Thread" type="Thread" />
				<field visibility="private" name="entry" fulltype="java.lang.Object" type="Object" />
			</fields>
			<methods>
				<constructor visibility="private" name="ObjectStreamClass.EntryFuture" />
				<method synchronized="true" visibility="package-private" name="set" fulltype="boolean" type="boolean">
					<comment>
						<description>Attempts to set the value contained by this EntryFuture.  If the
 EntryFuture&apos;s value has not been set already, then the value is
 saved, any callers blocked in the get() method are notified, and
 true is returned.  If the value has already been set, then no saving
 or notification occurs, and false is returned.</description>
					</comment>
					<params>
						<param name="entry" fulltype="java.lang.Object" type="Object" />
					</params>
				</method>
				<method synchronized="true" visibility="package-private" name="get" fulltype="java.lang.Object" type="Object">
					<comment>
						<description>Returns the value contained by this EntryFuture, blocking if
 necessary until a value is set.</description>
					</comment>
				</method>
				<method visibility="package-private" name="getOwner" fulltype="java.lang.Thread" type="Thread">
					<comment>
						<description>Returns the thread that created this EntryFuture.</description>
					</comment>
				</method>
			</methods>
		</jelclass>
		<jelclass superclass="Object" visibility="package-private" package="java.io" superclassfulltype="java.lang.Object" fulltype="java.io.ObjectStreamClass.ClassDataSlot" type="ObjectStreamClass.ClassDataSlot">
			<comment>
				<description>Class representing the portion of an object&apos;s serialized form allotted
 to data described by a given class descriptor.  If &quot;hasData&quot; is false,
 the object&apos;s serialized form does not contain data associated with the
 class descriptor.</description>
			</comment>
			<fields>
				<field final="true" visibility="package-private" name="desc" fulltype="java.io.ObjectStreamClass" type="ObjectStreamClass">
					<comment>
						<description>class descriptor &quot;occupying&quot; this slot</description>
					</comment>
				</field>
				<field final="true" visibility="package-private" name="hasData" fulltype="boolean" type="boolean">
					<comment>
						<description>true if serialized form includes data for this slot&apos;s descriptor</description>
					</comment>
				</field>
			</fields>
			<methods>
				<constructor visibility="package-private" name="ObjectStreamClass.ClassDataSlot">
					<params>
						<param name="desc" fulltype="java.io.ObjectStreamClass" type="ObjectStreamClass" />
						<param name="hasData" fulltype="boolean" type="boolean" />
					</params>
				</constructor>
			</methods>
		</jelclass>
		<jelclass superclass="Object" visibility="private" package="java.io" superclassfulltype="java.lang.Object" fulltype="java.io.ObjectStreamClass.MemberSignature" type="ObjectStreamClass.MemberSignature">
			<comment>
				<description>Class for computing and caching field/constructor/method signatures
 during serialVersionUID calculation.</description>
			</comment>
			<fields>
				<field final="true" visibility="public" name="member" fulltype="java.lang.reflect.Member" type="Member" />
				<field final="true" visibility="public" name="name" fulltype="java.lang.String" type="String" />
				<field final="true" visibility="public" name="signature" fulltype="java.lang.String" type="String" />
			</fields>
			<methods>
				<constructor visibility="public" name="ObjectStreamClass.MemberSignature">
					<params>
						<param name="field" fulltype="java.lang.reflect.Field" type="Field" />
					</params>
				</constructor>
				<constructor visibility="public" name="ObjectStreamClass.MemberSignature">
					<params>
						<param name="cons" fulltype="java.lang.reflect.Constructor" type="Constructor" />
					</params>
				</constructor>
				<constructor visibility="public" name="ObjectStreamClass.MemberSignature">
					<params>
						<param name="meth" fulltype="java.lang.reflect.Method" type="Method" />
					</params>
				</constructor>
			</methods>
		</jelclass>
		<jelclass superclass="Object" visibility="private" package="java.io" superclassfulltype="java.lang.Object" fulltype="java.io.ObjectStreamClass.FieldReflector" type="ObjectStreamClass.FieldReflector">
			<comment>
				<description>Class for setting and retrieving serializable field values in batch.</description>
			</comment>
			<fields>
				<field final="true" static="true" visibility="private" name="unsafe" fulltype="sun.misc.Unsafe" type="Unsafe">
					<comment>
						<description>handle for performing unsafe operations</description>
					</comment>
				</field>
				<field final="true" visibility="private" name="fields" fulltype="java.io.ObjectStreamField[]" type="ObjectStreamField">
					<comment>
						<description>fields to operate on</description>
					</comment>
				</field>
				<field final="true" visibility="private" name="numPrimFields" fulltype="int" type="int">
					<comment>
						<description>number of primitive fields</description>
					</comment>
				</field>
				<field final="true" visibility="private" name="readKeys" fulltype="long[]" type="long">
					<comment>
						<description>unsafe field keys for reading fields - may contain dupes</description>
					</comment>
				</field>
				<field final="true" visibility="private" name="writeKeys" fulltype="long[]" type="long">
					<comment>
						<description>unsafe fields keys for writing fields - no dupes</description>
					</comment>
				</field>
				<field final="true" visibility="private" name="offsets" fulltype="int[]" type="int">
					<comment>
						<description>field data offsets</description>
					</comment>
				</field>
				<field final="true" visibility="private" name="typeCodes" fulltype="char[]" type="char">
					<comment>
						<description>field type codes</description>
					</comment>
				</field>
				<field final="true" visibility="private" name="types" fulltype="java.lang.Class[]" type="Class">
					<comment>
						<description>field types</description>
					</comment>
				</field>
			</fields>
			<methods>
				<constructor visibility="package-private" name="ObjectStreamClass.FieldReflector">
					<comment>
						<description>Constructs FieldReflector capable of setting/getting values from the
 subset of fields whose ObjectStreamFields contain non-null
 reflective Field objects.  ObjectStreamFields with null Fields are
 treated as filler, for which get operations return default values
 and set operations discard given values.</description>
					</comment>
					<params>
						<param name="fields" fulltype="java.io.ObjectStreamField[]" type="ObjectStreamField" />
					</params>
				</constructor>
				<method visibility="package-private" name="getFields" fulltype="java.io.ObjectStreamField[]" type="ObjectStreamField">
					<comment>
						<description>Returns list of ObjectStreamFields representing fields operated on
 by this reflector.  The shared/unshared values and Field objects
 contained by ObjectStreamFields in the list reflect their bindings
 to locally defined serializable fields.</description>
					</comment>
				</method>
				<method visibility="package-private" name="getPrimFieldValues" fulltype="void" type="void">
					<comment>
						<description>Fetches the serializable primitive field values of object obj and
 marshals them into byte array buf starting at offset 0.  The caller
 is responsible for ensuring that obj is of the proper type.</description>
					</comment>
					<params>
						<param name="obj" fulltype="java.lang.Object" type="Object" />
						<param name="buf" fulltype="byte[]" type="byte" />
					</params>
				</method>
				<method visibility="package-private" name="setPrimFieldValues" fulltype="void" type="void">
					<comment>
						<description>Sets the serializable primitive fields of object obj using values
 unmarshalled from byte array buf starting at offset 0.  The caller
 is responsible for ensuring that obj is of the proper type.</description>
					</comment>
					<params>
						<param name="obj" fulltype="java.lang.Object" type="Object" />
						<param name="buf" fulltype="byte[]" type="byte" />
					</params>
				</method>
				<method visibility="package-private" name="getObjFieldValues" fulltype="void" type="void">
					<comment>
						<description>Fetches the serializable object field values of object obj and
 stores them in array vals starting at offset 0.  The caller is
 responsible for ensuring that obj is of the proper type.</description>
					</comment>
					<params>
						<param name="obj" fulltype="java.lang.Object" type="Object" />
						<param name="vals" fulltype="java.lang.Object[]" type="Object" />
					</params>
				</method>
				<method visibility="package-private" name="setObjFieldValues" fulltype="void" type="void">
					<comment>
						<description>Sets the serializable object fields of object obj using values from
 array vals starting at offset 0.  The caller is responsible for
 ensuring that obj is of the proper type; however, attempts to set a
 field with a value of the wrong type will trigger an appropriate
 ClassCastException.</description>
					</comment>
					<params>
						<param name="obj" fulltype="java.lang.Object" type="Object" />
						<param name="vals" fulltype="java.lang.Object[]" type="Object" />
					</params>
				</method>
			</methods>
		</jelclass>
		<jelclass superclass="WeakReference" visibility="private" package="java.io" superclassfulltype="java.lang.ref.WeakReference" fulltype="java.io.ObjectStreamClass.FieldReflectorKey" type="ObjectStreamClass.FieldReflectorKey">
			<comment>
				<description>FieldReflector cache lookup key.  Keys are considered equal if they
 refer to the same class and equivalent field formats.</description>
			</comment>
			<fields>
				<field final="true" visibility="private" name="sigs" fulltype="java.lang.String" type="String" />
				<field final="true" visibility="private" name="hash" fulltype="int" type="int" />
				<field final="true" visibility="private" name="nullClass" fulltype="boolean" type="boolean" />
			</fields>
			<methods>
				<constructor visibility="package-private" name="ObjectStreamClass.FieldReflectorKey">
					<params>
						<param name="cl" fulltype="java.lang.Class" type="Class" />
						<param name="fields" fulltype="java.io.ObjectStreamField[]" type="ObjectStreamField" />
						<param name="queue" fulltype="java.lang.ref.ReferenceQueue" type="ReferenceQueue" />
					</params>
				</constructor>
				<method visibility="public" name="hashCode" fulltype="int" type="int" />
				<method visibility="public" name="equals" fulltype="boolean" type="boolean">
					<params>
						<param name="obj" fulltype="java.lang.Object" type="Object" />
					</params>
				</method>
			</methods>
		</jelclass>
		<jelclass superclass="WeakReference" visibility="package-private" package="java.io" superclassfulltype="java.lang.ref.WeakReference" fulltype="java.io.ObjectStreamClass.WeakClassKey" type="ObjectStreamClass.WeakClassKey">
			<comment>
				<description>Weak key for Class objects.</description>
			</comment>
			<fields>
				<field final="true" visibility="private" name="hash" fulltype="int" type="int">
					<comment>
						<description>saved value of the referent&apos;s identity hash code, to maintain
 a consistent hash code after the referent has been cleared</description>
					</comment>
				</field>
			</fields>
			<methods>
				<constructor visibility="package-private" name="ObjectStreamClass.WeakClassKey">
					<comment>
						<description>Create a new WeakClassKey to the given object, registered
 with a queue.</description>
					</comment>
					<params>
						<param name="cl" fulltype="java.lang.Class" type="Class" />
						<param name="refQueue" fulltype="java.lang.ref.ReferenceQueue" type="ReferenceQueue" />
					</params>
				</constructor>
				<method visibility="public" name="hashCode" fulltype="int" type="int">
					<comment>
						<description>Returns the identity hash code of the original referent.</description>
					</comment>
				</method>
				<method visibility="public" name="equals" fulltype="boolean" type="boolean">
					<comment>
						<description>Returns true if the given object is this identical
 WeakClassKey instance, or, if this object&apos;s referent has not
 been cleared, if the given object is another WeakClassKey
 instance with the identical non-null referent as this one.</description>
					</comment>
					<params>
						<param name="obj" fulltype="java.lang.Object" type="Object" />
					</params>
				</method>
			</methods>
		</jelclass>
	</jelclass>
	<jelclass superclass="Object" visibility="private" package="java.io" superclassfulltype="java.lang.Object" fulltype="java.io.ObjectStreamClass.Caches" type="ObjectStreamClass.Caches">
		<fields>
			<field final="true" static="true" visibility="package-private" name="localDescs" fulltype="java.util.concurrent.ConcurrentMap" type="ConcurrentMap">
				<comment>
					<description>cache mapping local classes -&gt; descriptors</description>
				</comment>
			</field>
			<field final="true" static="true" visibility="package-private" name="reflectors" fulltype="java.util.concurrent.ConcurrentMap" type="ConcurrentMap">
				<comment>
					<description>cache mapping field group/local desc pairs -&gt; field reflectors</description>
				</comment>
			</field>
			<field final="true" static="true" visibility="private" name="localDescsQueue" fulltype="java.lang.ref.ReferenceQueue" type="ReferenceQueue">
				<comment>
					<description>queue for WeakReferences to local classes</description>
				</comment>
			</field>
			<field final="true" static="true" visibility="private" name="reflectorsQueue" fulltype="java.lang.ref.ReferenceQueue" type="ReferenceQueue">
				<comment>
					<description>queue for WeakReferences to field reflectors keys</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="private" name="ObjectStreamClass.Caches" />
		</methods>
	</jelclass>
	<jelclass superclass="Object" visibility="private" package="java.io" superclassfulltype="java.lang.Object" fulltype="java.io.ObjectStreamClass.EntryFuture" type="ObjectStreamClass.EntryFuture">
		<comment>
			<description>Placeholder used in class descriptor and field reflector lookup tables
 for an entry in the process of being initialized.  (Internal) callers
 which receive an EntryFuture belonging to another thread as the result
 of a lookup should call the get() method of the EntryFuture; this will
 return the actual entry once it is ready for use and has been set().  To
 conserve objects, EntryFutures synchronize on themselves.</description>
		</comment>
		<fields>
			<field final="true" static="true" visibility="private" name="unset" fulltype="java.lang.Object" type="Object" />
			<field final="true" visibility="private" name="owner" fulltype="java.lang.Thread" type="Thread" />
			<field visibility="private" name="entry" fulltype="java.lang.Object" type="Object" />
		</fields>
		<methods>
			<constructor visibility="private" name="ObjectStreamClass.EntryFuture" />
			<method synchronized="true" visibility="package-private" name="set" fulltype="boolean" type="boolean">
				<comment>
					<description>Attempts to set the value contained by this EntryFuture.  If the
 EntryFuture&apos;s value has not been set already, then the value is
 saved, any callers blocked in the get() method are notified, and
 true is returned.  If the value has already been set, then no saving
 or notification occurs, and false is returned.</description>
				</comment>
				<params>
					<param name="entry" fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method synchronized="true" visibility="package-private" name="get" fulltype="java.lang.Object" type="Object">
				<comment>
					<description>Returns the value contained by this EntryFuture, blocking if
 necessary until a value is set.</description>
				</comment>
			</method>
			<method visibility="package-private" name="getOwner" fulltype="java.lang.Thread" type="Thread">
				<comment>
					<description>Returns the thread that created this EntryFuture.</description>
				</comment>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="Object" visibility="package-private" package="java.io" superclassfulltype="java.lang.Object" fulltype="java.io.ObjectStreamClass.ClassDataSlot" type="ObjectStreamClass.ClassDataSlot">
		<comment>
			<description>Class representing the portion of an object&apos;s serialized form allotted
 to data described by a given class descriptor.  If &quot;hasData&quot; is false,
 the object&apos;s serialized form does not contain data associated with the
 class descriptor.</description>
		</comment>
		<fields>
			<field final="true" visibility="package-private" name="desc" fulltype="java.io.ObjectStreamClass" type="ObjectStreamClass">
				<comment>
					<description>class descriptor &quot;occupying&quot; this slot</description>
				</comment>
			</field>
			<field final="true" visibility="package-private" name="hasData" fulltype="boolean" type="boolean">
				<comment>
					<description>true if serialized form includes data for this slot&apos;s descriptor</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="package-private" name="ObjectStreamClass.ClassDataSlot">
				<params>
					<param name="desc" fulltype="java.io.ObjectStreamClass" type="ObjectStreamClass" />
					<param name="hasData" fulltype="boolean" type="boolean" />
				</params>
			</constructor>
		</methods>
	</jelclass>
	<jelclass superclass="Object" visibility="private" package="java.io" superclassfulltype="java.lang.Object" fulltype="java.io.ObjectStreamClass.MemberSignature" type="ObjectStreamClass.MemberSignature">
		<comment>
			<description>Class for computing and caching field/constructor/method signatures
 during serialVersionUID calculation.</description>
		</comment>
		<fields>
			<field final="true" visibility="public" name="member" fulltype="java.lang.reflect.Member" type="Member" />
			<field final="true" visibility="public" name="name" fulltype="java.lang.String" type="String" />
			<field final="true" visibility="public" name="signature" fulltype="java.lang.String" type="String" />
		</fields>
		<methods>
			<constructor visibility="public" name="ObjectStreamClass.MemberSignature">
				<params>
					<param name="field" fulltype="java.lang.reflect.Field" type="Field" />
				</params>
			</constructor>
			<constructor visibility="public" name="ObjectStreamClass.MemberSignature">
				<params>
					<param name="cons" fulltype="java.lang.reflect.Constructor" type="Constructor" />
				</params>
			</constructor>
			<constructor visibility="public" name="ObjectStreamClass.MemberSignature">
				<params>
					<param name="meth" fulltype="java.lang.reflect.Method" type="Method" />
				</params>
			</constructor>
		</methods>
	</jelclass>
	<jelclass superclass="Object" visibility="private" package="java.io" superclassfulltype="java.lang.Object" fulltype="java.io.ObjectStreamClass.FieldReflector" type="ObjectStreamClass.FieldReflector">
		<comment>
			<description>Class for setting and retrieving serializable field values in batch.</description>
		</comment>
		<fields>
			<field final="true" static="true" visibility="private" name="unsafe" fulltype="sun.misc.Unsafe" type="Unsafe">
				<comment>
					<description>handle for performing unsafe operations</description>
				</comment>
			</field>
			<field final="true" visibility="private" name="fields" fulltype="java.io.ObjectStreamField[]" type="ObjectStreamField">
				<comment>
					<description>fields to operate on</description>
				</comment>
			</field>
			<field final="true" visibility="private" name="numPrimFields" fulltype="int" type="int">
				<comment>
					<description>number of primitive fields</description>
				</comment>
			</field>
			<field final="true" visibility="private" name="readKeys" fulltype="long[]" type="long">
				<comment>
					<description>unsafe field keys for reading fields - may contain dupes</description>
				</comment>
			</field>
			<field final="true" visibility="private" name="writeKeys" fulltype="long[]" type="long">
				<comment>
					<description>unsafe fields keys for writing fields - no dupes</description>
				</comment>
			</field>
			<field final="true" visibility="private" name="offsets" fulltype="int[]" type="int">
				<comment>
					<description>field data offsets</description>
				</comment>
			</field>
			<field final="true" visibility="private" name="typeCodes" fulltype="char[]" type="char">
				<comment>
					<description>field type codes</description>
				</comment>
			</field>
			<field final="true" visibility="private" name="types" fulltype="java.lang.Class[]" type="Class">
				<comment>
					<description>field types</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="package-private" name="ObjectStreamClass.FieldReflector">
				<comment>
					<description>Constructs FieldReflector capable of setting/getting values from the
 subset of fields whose ObjectStreamFields contain non-null
 reflective Field objects.  ObjectStreamFields with null Fields are
 treated as filler, for which get operations return default values
 and set operations discard given values.</description>
				</comment>
				<params>
					<param name="fields" fulltype="java.io.ObjectStreamField[]" type="ObjectStreamField" />
				</params>
			</constructor>
			<method visibility="package-private" name="getFields" fulltype="java.io.ObjectStreamField[]" type="ObjectStreamField">
				<comment>
					<description>Returns list of ObjectStreamFields representing fields operated on
 by this reflector.  The shared/unshared values and Field objects
 contained by ObjectStreamFields in the list reflect their bindings
 to locally defined serializable fields.</description>
				</comment>
			</method>
			<method visibility="package-private" name="getPrimFieldValues" fulltype="void" type="void">
				<comment>
					<description>Fetches the serializable primitive field values of object obj and
 marshals them into byte array buf starting at offset 0.  The caller
 is responsible for ensuring that obj is of the proper type.</description>
				</comment>
				<params>
					<param name="obj" fulltype="java.lang.Object" type="Object" />
					<param name="buf" fulltype="byte[]" type="byte" />
				</params>
			</method>
			<method visibility="package-private" name="setPrimFieldValues" fulltype="void" type="void">
				<comment>
					<description>Sets the serializable primitive fields of object obj using values
 unmarshalled from byte array buf starting at offset 0.  The caller
 is responsible for ensuring that obj is of the proper type.</description>
				</comment>
				<params>
					<param name="obj" fulltype="java.lang.Object" type="Object" />
					<param name="buf" fulltype="byte[]" type="byte" />
				</params>
			</method>
			<method visibility="package-private" name="getObjFieldValues" fulltype="void" type="void">
				<comment>
					<description>Fetches the serializable object field values of object obj and
 stores them in array vals starting at offset 0.  The caller is
 responsible for ensuring that obj is of the proper type.</description>
				</comment>
				<params>
					<param name="obj" fulltype="java.lang.Object" type="Object" />
					<param name="vals" fulltype="java.lang.Object[]" type="Object" />
				</params>
			</method>
			<method visibility="package-private" name="setObjFieldValues" fulltype="void" type="void">
				<comment>
					<description>Sets the serializable object fields of object obj using values from
 array vals starting at offset 0.  The caller is responsible for
 ensuring that obj is of the proper type; however, attempts to set a
 field with a value of the wrong type will trigger an appropriate
 ClassCastException.</description>
				</comment>
				<params>
					<param name="obj" fulltype="java.lang.Object" type="Object" />
					<param name="vals" fulltype="java.lang.Object[]" type="Object" />
				</params>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="WeakReference" visibility="private" package="java.io" superclassfulltype="java.lang.ref.WeakReference" fulltype="java.io.ObjectStreamClass.FieldReflectorKey" type="ObjectStreamClass.FieldReflectorKey">
		<comment>
			<description>FieldReflector cache lookup key.  Keys are considered equal if they
 refer to the same class and equivalent field formats.</description>
		</comment>
		<fields>
			<field final="true" visibility="private" name="sigs" fulltype="java.lang.String" type="String" />
			<field final="true" visibility="private" name="hash" fulltype="int" type="int" />
			<field final="true" visibility="private" name="nullClass" fulltype="boolean" type="boolean" />
		</fields>
		<methods>
			<constructor visibility="package-private" name="ObjectStreamClass.FieldReflectorKey">
				<params>
					<param name="cl" fulltype="java.lang.Class" type="Class" />
					<param name="fields" fulltype="java.io.ObjectStreamField[]" type="ObjectStreamField" />
					<param name="queue" fulltype="java.lang.ref.ReferenceQueue" type="ReferenceQueue" />
				</params>
			</constructor>
			<method visibility="public" name="hashCode" fulltype="int" type="int" />
			<method visibility="public" name="equals" fulltype="boolean" type="boolean">
				<params>
					<param name="obj" fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="WeakReference" visibility="package-private" package="java.io" superclassfulltype="java.lang.ref.WeakReference" fulltype="java.io.ObjectStreamClass.WeakClassKey" type="ObjectStreamClass.WeakClassKey">
		<comment>
			<description>Weak key for Class objects.</description>
		</comment>
		<fields>
			<field final="true" visibility="private" name="hash" fulltype="int" type="int">
				<comment>
					<description>saved value of the referent&apos;s identity hash code, to maintain
 a consistent hash code after the referent has been cleared</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="package-private" name="ObjectStreamClass.WeakClassKey">
				<comment>
					<description>Create a new WeakClassKey to the given object, registered
 with a queue.</description>
				</comment>
				<params>
					<param name="cl" fulltype="java.lang.Class" type="Class" />
					<param name="refQueue" fulltype="java.lang.ref.ReferenceQueue" type="ReferenceQueue" />
				</params>
			</constructor>
			<method visibility="public" name="hashCode" fulltype="int" type="int">
				<comment>
					<description>Returns the identity hash code of the original referent.</description>
				</comment>
			</method>
			<method visibility="public" name="equals" fulltype="boolean" type="boolean">
				<comment>
					<description>Returns true if the given object is this identical
 WeakClassKey instance, or, if this object&apos;s referent has not
 been cleared, if the given object is another WeakClassKey
 instance with the identical non-null referent as this one.</description>
				</comment>
				<params>
					<param name="obj" fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
		</methods>
	</jelclass>
	<jelclass abstract="true" superclass="Object" visibility="public" package="java.io" superclassfulltype="java.lang.Object" fulltype="java.io.OutputStream" type="OutputStream">
		<implements>
			<interface fulltype="java.io.Closeable" type="Closeable" />
			<interface fulltype="java.io.Flushable" type="Flushable" />
		</implements>
		<comment>
			<description>This abstract class is the superclass of all classes representing
 an output stream of bytes. An output stream accepts output bytes
 and sends them to some sink.
 &lt;p&gt;
 Applications that need to define a subclass of
 &lt;code&gt;OutputStream&lt;/code&gt; must always provide at least a method
 that writes one byte of output.</description>
			<attribute name="@author">
				<description>Arthur van Hoff</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.BufferedOutputStream</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.ByteArrayOutputStream</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.DataOutputStream</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.FilterOutputStream</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.InputStream</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.OutputStream#write(int)</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.0</description>
			</attribute>
		</comment>
		<methods>
			<constructor visibility="public" name="OutputStream" />
			<method abstract="true" visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes the specified byte to this output stream. The general
 contract for &lt;code&gt;write&lt;/code&gt; is that one byte is written
 to the output stream. The byte to be written is the eight
 low-order bits of the argument &lt;code&gt;b&lt;/code&gt;. The 24
 high-order bits of &lt;code&gt;b&lt;/code&gt; are ignored.
 &lt;p&gt;
 Subclasses of &lt;code&gt;OutputStream&lt;/code&gt; must provide an
 implementation for this method.</description>
					<attribute name="@param">
						<description>b   the &lt;code&gt;byte&lt;/code&gt;.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs. In particular,
             an &lt;code&gt;IOException&lt;/code&gt; may be thrown if the
             output stream has been closed.</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the &lt;code&gt;byte&lt;/code&gt;." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs. In particular,
             an &lt;code&gt;IOException&lt;/code&gt; may be thrown if the
             output stream has been closed." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes &lt;code&gt;b.length&lt;/code&gt; bytes from the specified byte array
 to this output stream. The general contract for &lt;code&gt;write(b)&lt;/code&gt;
 is that it should have exactly the same effect as the call
 &lt;code&gt;write(b, 0, b.length)&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>b   the data.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.OutputStream#write(byte[], int, int)</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the data." fulltype="byte[]" type="byte" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes &lt;code&gt;len&lt;/code&gt; bytes from the specified byte array
 starting at offset &lt;code&gt;off&lt;/code&gt; to this output stream.
 The general contract for &lt;code&gt;write(b, off, len)&lt;/code&gt; is that
 some of the bytes in the array &lt;code&gt;b&lt;/code&gt; are written to the
 output stream in order; element &lt;code&gt;b[off]&lt;/code&gt; is the first
 byte written and &lt;code&gt;b[off+len-1]&lt;/code&gt; is the last byte written
 by this operation.
 &lt;p&gt;
 The &lt;code&gt;write&lt;/code&gt; method of &lt;code&gt;OutputStream&lt;/code&gt; calls
 the write method of one argument on each of the bytes to be
 written out. Subclasses are encouraged to override this method and
 provide a more efficient implementation.
 &lt;p&gt;
 If &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, a
 &lt;code&gt;NullPointerException&lt;/code&gt; is thrown.
 &lt;p&gt;
 If &lt;code&gt;off&lt;/code&gt; is negative, or &lt;code&gt;len&lt;/code&gt; is negative, or
 &lt;code&gt;off+len&lt;/code&gt; is greater than the length of the array
 &lt;code&gt;b&lt;/code&gt;, then an &lt;tt&gt;IndexOutOfBoundsException&lt;/tt&gt; is thrown.</description>
					<attribute name="@param">
						<description>b     the data.</description>
					</attribute>
					<attribute name="@param">
						<description>off   the start offset in the data.</description>
					</attribute>
					<attribute name="@param">
						<description>len   the number of bytes to write.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs. In particular,
             an &lt;code&gt;IOException&lt;/code&gt; is thrown if the output
             stream is closed.</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the data." fulltype="byte[]" type="byte" />
					<param name="off" comment="the start offset in the data." fulltype="int" type="int" />
					<param name="len" comment="the number of bytes to write." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs. In particular,
             an &lt;code&gt;IOException&lt;/code&gt; is thrown if the output
             stream is closed." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="flush" fulltype="void" type="void">
				<comment>
					<description>Flushes this output stream and forces any buffered output bytes
 to be written out. The general contract of &lt;code&gt;flush&lt;/code&gt; is
 that calling it is an indication that, if any bytes previously
 written have been buffered by the implementation of the output
 stream, such bytes should immediately be written to their
 intended destination.
 &lt;p&gt;
 If the intended destination of this stream is an abstraction provided by
 the underlying operating system, for example a file, then flushing the
 stream guarantees only that bytes previously written to the stream are
 passed to the operating system for writing; it does not guarantee that
 they are actually written to a physical device such as a disk drive.
 &lt;p&gt;
 The &lt;code&gt;flush&lt;/code&gt; method of &lt;code&gt;OutputStream&lt;/code&gt; does nothing.</description>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="close" fulltype="void" type="void">
				<comment>
					<description>Closes this output stream and releases any system resources
 associated with this stream. The general contract of &lt;code&gt;close&lt;/code&gt;
 is that it closes the output stream. A closed stream cannot perform
 output operations and cannot be reopened.
 &lt;p&gt;
 The &lt;code&gt;close&lt;/code&gt; method of &lt;code&gt;OutputStream&lt;/code&gt; does nothing.</description>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="ObjectStreamException" visibility="public" package="java.io" serializable="true" superclassfulltype="java.io.ObjectStreamException" fulltype="java.io.InvalidObjectException" type="InvalidObjectException">
		<comment>
			<description>Indicates that one or more deserialized objects failed validation
 tests.  The argument should provide the reason for the failure.</description>
			<attribute name="@see">
				<description>ObjectInputValidation</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.1</description>
			</attribute>
			<attribute name="@author">
				<description>unascribed</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.1</description>
			</attribute>
		</comment>
		<fields>
			<field final="true" static="true" const="3233174318281839583" visibility="private" name="serialVersionUID" constexpr="3233174318281839583L" fulltype="long" type="long" />
		</fields>
		<methods>
			<constructor visibility="public" name="InvalidObjectException">
				<comment>
					<description>Constructs an &lt;code&gt;InvalidObjectException&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>reason Detailed message explaining the reason for the failure.</description>
					</attribute>
					<attribute name="@see">
						<description>ObjectInputValidation</description>
					</attribute>
				</comment>
				<params>
					<param name="reason" comment="Detailed message explaining the reason for the failure." fulltype="java.lang.String" type="String" />
				</params>
			</constructor>
		</methods>
	</jelclass>
	<jelclass final="true" superclass="Permission" visibility="public" package="java.io" serializable="true" superclassfulltype="java.security.Permission" fulltype="java.io.FilePermission" type="FilePermission">
		<implements>
			<interface fulltype="java.io.Serializable" type="Serializable" />
		</implements>
		<comment>
			<description>This class represents access to a file or directory.  A FilePermission consists
 of a pathname and a set of actions valid for that pathname.
 &lt;P&gt;
 Pathname is the pathname of the file or directory granted the specified
 actions. A pathname that ends in &quot;/*&quot; (where &quot;/&quot; is
 the file separator character, &lt;code&gt;File.separatorChar&lt;/code&gt;) indicates
 all the files and directories contained in that directory. A pathname
 that ends with &quot;/-&quot; indicates (recursively) all files
 and subdirectories contained in that directory. A pathname consisting of
 the special token &quot;&amp;lt;&amp;lt;ALL FILES&amp;gt;&amp;gt;&quot; matches &lt;b&gt;any&lt;/b&gt; file.
 &lt;P&gt;
 Note: A pathname consisting of a single &quot;*&quot; indicates all the files
 in the current directory, while a pathname consisting of a single &quot;-&quot;
 indicates all the files in the current directory and
 (recursively) all files and subdirectories contained in the current
 directory.
 &lt;P&gt;
 The actions to be granted are passed to the constructor in a string containing
 a list of one or more comma-separated keywords. The possible keywords are
 &quot;read&quot;, &quot;write&quot;, &quot;execute&quot;, and &quot;delete&quot;. Their meaning is defined as follows:
 &lt;P&gt;
 &lt;DL&gt;
    &lt;DT&gt; read &lt;DD&gt; read permission
    &lt;DT&gt; write &lt;DD&gt; write permission
    &lt;DT&gt; execute
    &lt;DD&gt; execute permission. Allows &lt;code&gt;Runtime.exec&lt;/code&gt; to
         be called. Corresponds to &lt;code&gt;SecurityManager.checkExec&lt;/code&gt;.
    &lt;DT&gt; delete
    &lt;DD&gt; delete permission. Allows &lt;code&gt;File.delete&lt;/code&gt; to
         be called. Corresponds to &lt;code&gt;SecurityManager.checkDelete&lt;/code&gt;.
 &lt;/DL&gt;
 &lt;P&gt;
 The actions string is converted to lowercase before processing.
 &lt;P&gt;
 Be careful when granting FilePermissions. Think about the implications
 of granting read and especially write access to various files and
 directories. The &quot;&amp;lt;&amp;lt;ALL FILES&gt;&gt;&quot; permission with write action is
 especially dangerous. This grants permission to write to the entire
 file system. One thing this effectively allows is replacement of the
 system binary, including the JVM runtime environment.

 &lt;p&gt;Please note: Code can always read a file from the same
 directory it&apos;s in (or a subdirectory of that directory); it does not
 need explicit permission to do so.</description>
			<attribute name="@see">
				<description>java.security.Permission</description>
			</attribute>
			<attribute name="@see">
				<description>java.security.Permissions</description>
			</attribute>
			<attribute name="@see">
				<description>java.security.PermissionCollection</description>
			</attribute>
			<attribute name="@author">
				<description>Marianne Mueller</description>
			</attribute>
			<attribute name="@author">
				<description>Roland Schemers</description>
			</attribute>
			<attribute name="@since">
				<description>1.2</description>
			</attribute>
			<attribute name="@serial">
				<description>exclude</description>
			</attribute>
		</comment>
		<fields>
			<field final="true" static="true" const="1" visibility="private" name="EXECUTE" constexpr="1" fulltype="int" type="int">
				<comment>
					<description>Execute action.</description>
				</comment>
			</field>
			<field final="true" static="true" const="2" visibility="private" name="WRITE" constexpr="2" fulltype="int" type="int">
				<comment>
					<description>Write action.</description>
				</comment>
			</field>
			<field final="true" static="true" const="4" visibility="private" name="READ" constexpr="4" fulltype="int" type="int">
				<comment>
					<description>Read action.</description>
				</comment>
			</field>
			<field final="true" static="true" const="8" visibility="private" name="DELETE" constexpr="8" fulltype="int" type="int">
				<comment>
					<description>Delete action.</description>
				</comment>
			</field>
			<field final="true" static="true" const="15" visibility="private" name="ALL" constexpr="15" fulltype="int" type="int">
				<comment>
					<description>All actions (read,write,execute,delete)</description>
				</comment>
			</field>
			<field final="true" static="true" const="0" visibility="private" name="NONE" constexpr="0" fulltype="int" type="int">
				<comment>
					<description>No actions.</description>
				</comment>
			</field>
			<field visibility="private" transient="true" name="mask" fulltype="int" type="int" />
			<field visibility="private" transient="true" name="directory" fulltype="boolean" type="boolean" />
			<field visibility="private" transient="true" name="recursive" fulltype="boolean" type="boolean" />
			<field visibility="private" name="actions" fulltype="java.lang.String" type="String">
				<comment>
					<description>the actions string.</description>
					<attribute name="@serial" />
				</comment>
			</field>
			<field visibility="private" transient="true" name="cpath" fulltype="java.lang.String" type="String" />
			<field final="true" static="true" const="45" visibility="private" name="RECURSIVE_CHAR" constexpr="45" fulltype="char" type="char" />
			<field final="true" static="true" const="42" visibility="private" name="WILD_CHAR" constexpr="42" fulltype="char" type="char" />
			<field final="true" static="true" const="7930732926638008763" visibility="private" name="serialVersionUID" constexpr="7930732926638008763L" fulltype="long" type="long" />
		</fields>
		<methods>
			<constructor visibility="public" name="FilePermission">
				<comment>
					<description>Creates a new FilePermission object with the specified actions.
 &lt;i&gt;path&lt;/i&gt; is the pathname of a file or directory, and &lt;i&gt;actions&lt;/i&gt;
 contains a comma-separated list of the desired actions granted on the
 file or directory. Possible actions are
 &quot;read&quot;, &quot;write&quot;, &quot;execute&quot;, and &quot;delete&quot;.

 &lt;p&gt;A pathname that ends in &quot;/*&quot; (where &quot;/&quot; is
 the file separator character, &lt;code&gt;File.separatorChar&lt;/code&gt;)
 indicates all the files and directories contained in that directory.
 A pathname that ends with &quot;/-&quot; indicates (recursively) all files and
 subdirectories contained in that directory. The special pathname
 &quot;&amp;lt;&amp;lt;ALL FILES&amp;gt;&amp;gt;&quot; matches any file.

 &lt;p&gt;A pathname consisting of a single &quot;*&quot; indicates all the files
 in the current directory, while a pathname consisting of a single &quot;-&quot;
 indicates all the files in the current directory and
 (recursively) all files and subdirectories contained in the current
 directory.

 &lt;p&gt;A pathname containing an empty string represents an empty path.</description>
					<attribute name="@param">
						<description>path the pathname of the file/directory.</description>
					</attribute>
					<attribute name="@param">
						<description>actions the action string.</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException
          If actions is &lt;code&gt;null&lt;/code&gt;, empty or contains an action
          other than the specified possible actions.</description>
					</attribute>
				</comment>
				<params>
					<param name="path" comment="the pathname of the file/directory." fulltype="java.lang.String" type="String" />
					<param name="actions" comment="the action string." fulltype="java.lang.String" type="String" />
				</params>
			</constructor>
			<constructor visibility="package-private" name="FilePermission">
				<comment>
					<description>Creates a new FilePermission object using an action mask.
 More efficient than the FilePermission(String, String) constructor.
 Can be used from within
 code that needs to create a FilePermission object to pass into the
 &lt;code&gt;implies&lt;/code&gt; method.</description>
					<attribute name="@param">
						<description>path the pathname of the file/directory.</description>
					</attribute>
					<attribute name="@param">
						<description>mask the action mask to use.</description>
					</attribute>
				</comment>
				<params>
					<param name="path" comment="the pathname of the file/directory." fulltype="java.lang.String" type="String" />
					<param name="mask" comment="the action mask to use." fulltype="int" type="int" />
				</params>
			</constructor>
			<method visibility="private" name="init" fulltype="void" type="void">
				<comment>
					<description>initialize a FilePermission object. Common to all constructors.
 Also called during de-serialization.</description>
					<attribute name="@param">
						<description>mask the actions mask to use.</description>
					</attribute>
				</comment>
				<params>
					<param name="mask" comment="the actions mask to use." fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="implies" returncomment="&lt;code&gt;true&lt;/code&gt; if the specified permission is not
                  &lt;code&gt;null&lt;/code&gt; and is implied by this object,
                  &lt;code&gt;false&lt;/code&gt; otherwise." fulltype="boolean" type="boolean">
				<comment>
					<description>Checks if this FilePermission object &quot;implies&quot; the specified permission.
 &lt;P&gt;
 More specifically, this method returns true if:&lt;p&gt;
 &lt;ul&gt;
 &lt;li&gt; &lt;i&gt;p&lt;/i&gt; is an instanceof FilePermission,&lt;p&gt;
 &lt;li&gt; &lt;i&gt;p&lt;/i&gt;&apos;s actions are a proper subset of this
 object&apos;s actions, and &lt;p&gt;
 &lt;li&gt; &lt;i&gt;p&lt;/i&gt;&apos;s pathname is implied by this object&apos;s
      pathname. For example, &quot;/tmp/*&quot; implies &quot;/tmp/foo&quot;, since
      &quot;/tmp/*&quot; encompasses all files in the &quot;/tmp&quot; directory,
      including the one named &quot;foo&quot;.
 &lt;/ul&gt;</description>
					<attribute name="@param">
						<description>p the permission to check against.</description>
					</attribute>
					<attribute name="@return">
						<description>&lt;code&gt;true&lt;/code&gt; if the specified permission is not
                  &lt;code&gt;null&lt;/code&gt; and is implied by this object,
                  &lt;code&gt;false&lt;/code&gt; otherwise.</description>
					</attribute>
				</comment>
				<params>
					<param name="p" comment="the permission to check against." fulltype="java.security.Permission" type="Permission" />
				</params>
			</method>
			<method visibility="package-private" name="impliesIgnoreMask" returncomment="the effective mask" fulltype="boolean" type="boolean">
				<comment>
					<description>Checks if the Permission&apos;s actions are a proper subset of the
 this object&apos;s actions. Returns the effective mask iff the
 this FilePermission&apos;s path also implies that FilePermission&apos;s path.</description>
					<attribute name="@param">
						<description>that the FilePermission to check against.</description>
					</attribute>
					<attribute name="@param">
						<description>exact return immediately if the masks are not equal</description>
					</attribute>
					<attribute name="@return">
						<description>the effective mask</description>
					</attribute>
				</comment>
				<params>
					<param name="that" comment="the FilePermission to check against." fulltype="java.io.FilePermission" type="FilePermission" />
				</params>
			</method>
			<method visibility="public" name="equals" returncomment="&lt;code&gt;true&lt;/code&gt; if obj is a FilePermission, and has the same
          pathname and actions as this FilePermission object,
          &lt;code&gt;false&lt;/code&gt; otherwise." fulltype="boolean" type="boolean">
				<comment>
					<description>Checks two FilePermission objects for equality. Checks that &lt;i&gt;obj&lt;/i&gt; is
 a FilePermission, and has the same pathname and actions as this object.
 &lt;P&gt;</description>
					<attribute name="@param">
						<description>obj the object we are testing for equality with this object.</description>
					</attribute>
					<attribute name="@return">
						<description>&lt;code&gt;true&lt;/code&gt; if obj is a FilePermission, and has the same
          pathname and actions as this FilePermission object,
          &lt;code&gt;false&lt;/code&gt; otherwise.</description>
					</attribute>
				</comment>
				<params>
					<param name="obj" comment="the object we are testing for equality with this object." fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method visibility="public" name="hashCode" returncomment="a hash code value for this object." fulltype="int" type="int">
				<comment>
					<description>Returns the hash code value for this object.</description>
					<attribute name="@return">
						<description>a hash code value for this object.</description>
					</attribute>
				</comment>
			</method>
			<method static="true" visibility="private" name="getMask" returncomment="the actions mask." fulltype="int" type="int">
				<comment>
					<description>Converts an actions String to an actions mask.</description>
					<attribute name="@param">
						<description>action the action string.</description>
					</attribute>
					<attribute name="@return">
						<description>the actions mask.</description>
					</attribute>
				</comment>
				<params>
					<param name="actions" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="package-private" name="getMask" returncomment="the actions mask." fulltype="int" type="int">
				<comment>
					<description>Return the current action mask. Used by the FilePermissionCollection.</description>
					<attribute name="@return">
						<description>the actions mask.</description>
					</attribute>
				</comment>
			</method>
			<method static="true" visibility="private" name="getActions" returncomment="the canonical string representation of the actions." fulltype="java.lang.String" type="String">
				<comment>
					<description>Return the canonical string representation of the actions.
 Always returns present actions in the following order:
 read, write, execute, delete.</description>
					<attribute name="@return">
						<description>the canonical string representation of the actions.</description>
					</attribute>
				</comment>
				<params>
					<param name="mask" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="getActions" returncomment="the canonical string representation of the actions." fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the &quot;canonical string representation&quot; of the actions.
 That is, this method always returns present actions in the following order:
 read, write, execute, delete. For example, if this FilePermission object
 allows both write and read actions, a call to &lt;code&gt;getActions&lt;/code&gt;
 will return the string &quot;read,write&quot;.</description>
					<attribute name="@return">
						<description>the canonical string representation of the actions.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="newPermissionCollection" returncomment="a new PermissionCollection object suitable for storing
 FilePermissions." fulltype="java.security.PermissionCollection" type="PermissionCollection">
				<comment>
					<description>Returns a new PermissionCollection object for storing FilePermission
 objects.
 &lt;p&gt;
 FilePermission objects must be stored in a manner that allows them
 to be inserted into the collection in any order, but that also enables the
 PermissionCollection &lt;code&gt;implies&lt;/code&gt;
 method to be implemented in an efficient (and consistent) manner.

 &lt;p&gt;For example, if you have two FilePermissions:
 &lt;OL&gt;
 &lt;LI&gt;  &lt;code&gt;&quot;/tmp/-&quot;, &quot;read&quot;&lt;/code&gt;
 &lt;LI&gt;  &lt;code&gt;&quot;/tmp/scratch/foo&quot;, &quot;write&quot;&lt;/code&gt;
 &lt;/OL&gt;

 &lt;p&gt;and you are calling the &lt;code&gt;implies&lt;/code&gt; method with the FilePermission:

 &lt;pre&gt;
   &quot;/tmp/scratch/foo&quot;, &quot;read,write&quot;,
 &lt;/pre&gt;

 then the &lt;code&gt;implies&lt;/code&gt; function must
 take into account both the &quot;/tmp/-&quot; and &quot;/tmp/scratch/foo&quot;
 permissions, so the effective permission is &quot;read,write&quot;,
 and &lt;code&gt;implies&lt;/code&gt; returns true. The &quot;implies&quot; semantics for
 FilePermissions are handled properly by the PermissionCollection object
 returned by this &lt;code&gt;newPermissionCollection&lt;/code&gt; method.</description>
					<attribute name="@return">
						<description>a new PermissionCollection object suitable for storing
 FilePermissions.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="private" name="writeObject" fulltype="void" type="void">
				<comment>
					<description>WriteObject is called to save the state of the FilePermission
 to a stream. The actions are serialized, and the superclass
 takes care of the name.</description>
				</comment>
				<params>
					<param name="s" fulltype="java.io.ObjectOutputStream" type="ObjectOutputStream" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="readObject" fulltype="void" type="void">
				<comment>
					<description>readObject is called to restore the state of the FilePermission from
 a stream.</description>
				</comment>
				<params>
					<param name="s" fulltype="java.io.ObjectInputStream" type="ObjectInputStream" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
					<exception fulltype="java.lang.ClassNotFoundException" type="ClassNotFoundException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass final="true" superclass="PermissionCollection" visibility="package-private" package="java.io" serializable="true" superclassfulltype="java.security.PermissionCollection" fulltype="java.io.FilePermissionCollection" type="FilePermissionCollection">
		<implements>
			<interface fulltype="java.io.Serializable" type="Serializable" />
		</implements>
		<comment>
			<description>A FilePermissionCollection stores a set of FilePermission permissions.
 FilePermission objects
 must be stored in a manner that allows them to be inserted in any
 order, but enable the implies function to evaluate the implies
 method.
 For example, if you have two FilePermissions:
 &lt;OL&gt;
 &lt;LI&gt; &quot;/tmp/-&quot;, &quot;read&quot;
 &lt;LI&gt; &quot;/tmp/scratch/foo&quot;, &quot;write&quot;
 &lt;/OL&gt;
 And you are calling the implies function with the FilePermission:
 &quot;/tmp/scratch/foo&quot;, &quot;read,write&quot;, then the implies function must
 take into account both the /tmp/- and /tmp/scratch/foo
 permissions, so the effective permission is &quot;read,write&quot;.</description>
			<attribute name="@see">
				<description>java.security.Permission</description>
			</attribute>
			<attribute name="@see">
				<description>java.security.Permissions</description>
			</attribute>
			<attribute name="@see">
				<description>java.security.PermissionCollection</description>
			</attribute>
			<attribute name="@author">
				<description>Marianne Mueller</description>
			</attribute>
			<attribute name="@author">
				<description>Roland Schemers</description>
			</attribute>
			<attribute name="@serial">
				<description>include</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="private" transient="true" name="perms" fulltype="java.util.List" type="List" />
			<field final="true" static="true" const="2202956749081564585" visibility="private" name="serialVersionUID" constexpr="2202956749081564585L" fulltype="long" type="long" />
			<field final="true" static="true" visibility="private" name="serialPersistentFields" fulltype="java.io.ObjectStreamField[]" type="ObjectStreamField">
				<comment>
					<attribute name="@serialField">
						<description>permissions java.util.Vector
     A list of FilePermission objects.</description>
					</attribute>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="public" name="FilePermissionCollection">
				<comment>
					<description>Create an empty FilePermissions object.</description>
				</comment>
			</constructor>
			<method visibility="public" name="add" fulltype="void" type="void">
				<comment>
					<description>Adds a permission to the FilePermissions. The key for the hash is
 permission.path.</description>
					<attribute name="@param">
						<description>permission the Permission object to add.</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException - if the permission is not a
                                       FilePermission</description>
					</attribute>
					<attribute name="@exception">
						<description>SecurityException - if this FilePermissionCollection object
                                has been marked readonly</description>
					</attribute>
				</comment>
				<params>
					<param name="permission" comment="the Permission object to add." fulltype="java.security.Permission" type="Permission" />
				</params>
			</method>
			<method visibility="public" name="implies" returncomment="true if &quot;permission&quot; is a proper subset of a permission in
 the set, false if not." fulltype="boolean" type="boolean">
				<comment>
					<description>Check and see if this set of permissions implies the permissions
 expressed in &quot;permission&quot;.</description>
					<attribute name="@param">
						<description>p the Permission object to compare</description>
					</attribute>
					<attribute name="@return">
						<description>true if &quot;permission&quot; is a proper subset of a permission in
 the set, false if not.</description>
					</attribute>
				</comment>
				<params>
					<param name="permission" fulltype="java.security.Permission" type="Permission" />
				</params>
			</method>
			<method visibility="public" name="elements" returncomment="an enumeration of all the FilePermission objects." fulltype="java.util.Enumeration" type="Enumeration">
				<comment>
					<description>Returns an enumeration of all the FilePermission objects in the
 container.</description>
					<attribute name="@return">
						<description>an enumeration of all the FilePermission objects.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="private" name="writeObject" fulltype="void" type="void">
				<comment>
					<attribute name="@serialData">
						<description>&quot;permissions&quot; field (a Vector containing the FilePermissions).</description>
					</attribute>
				</comment>
				<params>
					<param name="out" fulltype="java.io.ObjectOutputStream" type="ObjectOutputStream" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="readObject" fulltype="void" type="void">
				<params>
					<param name="in" fulltype="java.io.ObjectInputStream" type="ObjectInputStream" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
					<exception fulltype="java.lang.ClassNotFoundException" type="ClassNotFoundException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="InputStream" visibility="public" package="java.io" superclassfulltype="java.io.InputStream" fulltype="java.io.StringBufferInputStream" type="StringBufferInputStream">
		<comment>
			<description>This class allows an application to create an input stream in
 which the bytes read are supplied by the contents of a string.
 Applications can also read bytes from a byte array by using a
 &lt;code&gt;ByteArrayInputStream&lt;/code&gt;.
 &lt;p&gt;
 Only the low eight bits of each character in the string are used by
 this class.</description>
			<attribute name="@author">
				<description>Arthur van Hoff</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.ByteArrayInputStream</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.StringReader</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.0</description>
			</attribute>
			<attribute name="@deprecated">
				<description>This class does not properly convert characters into bytes.  As
             of JDK&amp;nbsp;1.1, the preferred way to create a stream from a
             string is via the &lt;code&gt;StringReader&lt;/code&gt; class.</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="protected" name="buffer" fulltype="java.lang.String" type="String">
				<comment>
					<description>The string from which bytes are read.</description>
				</comment>
			</field>
			<field visibility="protected" name="pos" fulltype="int" type="int">
				<comment>
					<description>The index of the next character to read from the input stream buffer.</description>
					<attribute name="@see">
						<description>java.io.StringBufferInputStream#buffer</description>
					</attribute>
				</comment>
			</field>
			<field visibility="protected" name="count" fulltype="int" type="int">
				<comment>
					<description>The number of valid characters in the input stream buffer.</description>
					<attribute name="@see">
						<description>java.io.StringBufferInputStream#buffer</description>
					</attribute>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="public" name="StringBufferInputStream">
				<comment>
					<description>Creates a string input stream to read data from the specified string.</description>
					<attribute name="@param">
						<description>s   the underlying input buffer.</description>
					</attribute>
				</comment>
				<params>
					<param name="s" comment="the underlying input buffer." fulltype="java.lang.String" type="String" />
				</params>
			</constructor>
			<method synchronized="true" visibility="public" name="read" returncomment="the next byte of data, or &lt;code&gt;-1&lt;/code&gt; if the end of the
             stream is reached." fulltype="int" type="int">
				<comment>
					<description>Reads the next byte of data from this input stream. The value
 byte is returned as an &lt;code&gt;int&lt;/code&gt; in the range
 &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;255&lt;/code&gt;. If no byte is available
 because the end of the stream has been reached, the value
 &lt;code&gt;-1&lt;/code&gt; is returned.
 &lt;p&gt;
 The &lt;code&gt;read&lt;/code&gt; method of
 &lt;code&gt;StringBufferInputStream&lt;/code&gt; cannot block. It returns the
 low eight bits of the next character in this input stream&apos;s buffer.</description>
					<attribute name="@return">
						<description>the next byte of data, or &lt;code&gt;-1&lt;/code&gt; if the end of the
             stream is reached.</description>
					</attribute>
				</comment>
			</method>
			<method synchronized="true" visibility="public" name="read" returncomment="the total number of bytes read into the buffer, or
             &lt;code&gt;-1&lt;/code&gt; if there is no more data because the end of
             the stream has been reached." fulltype="int" type="int">
				<comment>
					<description>Reads up to &lt;code&gt;len&lt;/code&gt; bytes of data from this input stream
 into an array of bytes.
 &lt;p&gt;
 The &lt;code&gt;read&lt;/code&gt; method of
 &lt;code&gt;StringBufferInputStream&lt;/code&gt; cannot block. It copies the
 low eight bits from the characters in this input stream&apos;s buffer into
 the byte array argument.</description>
					<attribute name="@param">
						<description>b     the buffer into which the data is read.</description>
					</attribute>
					<attribute name="@param">
						<description>off   the start offset of the data.</description>
					</attribute>
					<attribute name="@param">
						<description>len   the maximum number of bytes read.</description>
					</attribute>
					<attribute name="@return">
						<description>the total number of bytes read into the buffer, or
             &lt;code&gt;-1&lt;/code&gt; if there is no more data because the end of
             the stream has been reached.</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the buffer into which the data is read." fulltype="byte[]" type="byte" />
					<param name="off" comment="the start offset of the data." fulltype="int" type="int" />
					<param name="len" comment="the maximum number of bytes read." fulltype="int" type="int" />
				</params>
			</method>
			<method synchronized="true" visibility="public" name="skip" returncomment="the actual number of bytes skipped." fulltype="long" type="long">
				<comment>
					<description>Skips &lt;code&gt;n&lt;/code&gt; bytes of input from this input stream. Fewer
 bytes might be skipped if the end of the input stream is reached.</description>
					<attribute name="@param">
						<description>n   the number of bytes to be skipped.</description>
					</attribute>
					<attribute name="@return">
						<description>the actual number of bytes skipped.</description>
					</attribute>
				</comment>
				<params>
					<param name="n" comment="the number of bytes to be skipped." fulltype="long" type="long" />
				</params>
			</method>
			<method synchronized="true" visibility="public" name="available" returncomment="the value of &lt;code&gt;count&amp;nbsp;-&amp;nbsp;pos&lt;/code&gt;, which is the
             number of bytes remaining to be read from the input buffer." fulltype="int" type="int">
				<comment>
					<description>Returns the number of bytes that can be read from the input
 stream without blocking.</description>
					<attribute name="@return">
						<description>the value of &lt;code&gt;count&amp;nbsp;-&amp;nbsp;pos&lt;/code&gt;, which is the
             number of bytes remaining to be read from the input buffer.</description>
					</attribute>
				</comment>
			</method>
			<method synchronized="true" visibility="public" name="reset" fulltype="void" type="void">
				<comment>
					<description>Resets the input stream to begin reading from the first character
 of this input stream&apos;s underlying buffer.</description>
				</comment>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="Object" visibility="package-private" package="java.io" superclassfulltype="java.lang.Object" fulltype="java.io.DeleteOnExitHook" type="DeleteOnExitHook">
		<comment>
			<description>This class holds a set of filenames to be deleted on VM exit through a shutdown hook.
 A set is used both to prevent double-insertion of the same file as well as offer
 quick removal.</description>
		</comment>
		<fields>
			<field static="true" visibility="private" name="instance" fulltype="java.io.DeleteOnExitHook" type="DeleteOnExitHook" />
			<field static="true" visibility="private" name="files" fulltype="java.util.LinkedHashSet" type="LinkedHashSet" />
		</fields>
		<methods>
			<constructor visibility="private" name="DeleteOnExitHook" />
			<method static="true" visibility="package-private" name="hook" fulltype="java.io.DeleteOnExitHook" type="DeleteOnExitHook" />
			<method static="true" synchronized="true" visibility="package-private" name="add" fulltype="void" type="void">
				<params>
					<param name="file" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="package-private" name="run" fulltype="void" type="void" />
		</methods>
	</jelclass>
	<jelclass superclass="IOException" visibility="public" package="java.io" serializable="true" superclassfulltype="java.io.IOException" fulltype="java.io.EOFException" type="EOFException">
		<comment>
			<description>Signals that an end of file or end of stream has been reached
 unexpectedly during input.
 &lt;p&gt;
 This exception is mainly used by data input streams to signal end of
 stream. Note that many other input operations return a special value on
 end of stream rather than throwing an exception.
 &lt;p&gt;</description>
			<attribute name="@author">
				<description>Frank Yellin</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.DataInputStream</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.IOException</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.0</description>
			</attribute>
		</comment>
		<methods>
			<constructor visibility="public" name="EOFException">
				<comment>
					<description>Constructs an &lt;code&gt;EOFException&lt;/code&gt; with &lt;code&gt;null&lt;/code&gt;
 as its error detail message.</description>
				</comment>
			</constructor>
			<constructor visibility="public" name="EOFException">
				<comment>
					<description>Constructs an &lt;code&gt;EOFException&lt;/code&gt; with the specified detail
 message. The string &lt;code&gt;s&lt;/code&gt; may later be retrieved by the
 &lt;code&gt;{@link java.lang.Throwable#getMessage}&lt;/code&gt; method of class
 &lt;code&gt;java.lang.Throwable&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>s   the detail message.</description>
					</attribute>
				</comment>
				<params>
					<param name="s" comment="the detail message." fulltype="java.lang.String" type="String" />
				</params>
			</constructor>
		</methods>
	</jelclass>
	<jelclass superclass="OutputStream" visibility="public" package="java.io" superclassfulltype="java.io.OutputStream" fulltype="java.io.PipedOutputStream" type="PipedOutputStream">
		<comment>
			<description>A piped output stream can be connected to a piped input stream
 to create a communications pipe. The piped output stream is the
 sending end of the pipe. Typically, data is written to a
 &lt;code&gt;PipedOutputStream&lt;/code&gt; object by one thread and data is
 read from the connected &lt;code&gt;PipedInputStream&lt;/code&gt; by some
 other thread. Attempting to use both objects from a single thread
 is not recommended as it may deadlock the thread.
 The pipe is said to be &lt;a name=BROKEN&gt; &lt;i&gt;broken&lt;/i&gt; &lt;/a&gt; if a
 thread that was reading data bytes from the connected piped input
 stream is no longer alive.</description>
			<attribute name="@author">
				<description>James Gosling</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.PipedInputStream</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.0</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="private" name="sink" fulltype="java.io.PipedInputStream" type="PipedInputStream" />
		</fields>
		<methods>
			<constructor visibility="public" name="PipedOutputStream">
				<comment>
					<description>Creates a piped output stream connected to the specified piped
 input stream. Data bytes written to this stream will then be
 available as input from &lt;code&gt;snk&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>snk   The piped input stream to connect to.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="snk" comment="The piped input stream to connect to." fulltype="java.io.PipedInputStream" type="PipedInputStream" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</constructor>
			<constructor visibility="public" name="PipedOutputStream">
				<comment>
					<description>Creates a piped output stream that is not yet connected to a
 piped input stream. It must be connected to a piped input stream,
 either by the receiver or the sender, before being used.</description>
					<attribute name="@see">
						<description>java.io.PipedInputStream#connect(java.io.PipedOutputStream)</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.PipedOutputStream#connect(java.io.PipedInputStream)</description>
					</attribute>
				</comment>
			</constructor>
			<method synchronized="true" visibility="public" name="connect" fulltype="void" type="void">
				<comment>
					<description>Connects this piped output stream to a receiver. If this object
 is already connected to some other piped input stream, an
 &lt;code&gt;IOException&lt;/code&gt; is thrown.
 &lt;p&gt;
 If &lt;code&gt;snk&lt;/code&gt; is an unconnected piped input stream and
 &lt;code&gt;src&lt;/code&gt; is an unconnected piped output stream, they may
 be connected by either the call:
 &lt;blockquote&gt;&lt;pre&gt;
 src.connect(snk)&lt;/pre&gt;&lt;/blockquote&gt;
 or the call:
 &lt;blockquote&gt;&lt;pre&gt;
 snk.connect(src)&lt;/pre&gt;&lt;/blockquote&gt;
 The two calls have the same effect.</description>
					<attribute name="@param">
						<description>snk   the piped input stream to connect to.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="snk" comment="the piped input stream to connect to." fulltype="java.io.PipedInputStream" type="PipedInputStream" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes the specified &lt;code&gt;byte&lt;/code&gt; to the piped output stream.
 &lt;p&gt;
 Implements the &lt;code&gt;write&lt;/code&gt; method of &lt;code&gt;OutputStream&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>b   the &lt;code&gt;byte&lt;/code&gt; to be written.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException if the pipe is &lt;a href=#BROKEN&gt; broken&lt;/a&gt;,
          {@link #connect(java.io.PipedInputStream) unconnected},
          closed, or if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the &lt;code&gt;byte&lt;/code&gt; to be written." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if the pipe is &lt;a href=#BROKEN&gt; broken&lt;/a&gt;,
          {@link #connect(java.io.PipedInputStream) unconnected},
          closed, or if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes &lt;code&gt;len&lt;/code&gt; bytes from the specified byte array
 starting at offset &lt;code&gt;off&lt;/code&gt; to this piped output stream.
 This method blocks until all the bytes are written to the output
 stream.</description>
					<attribute name="@param">
						<description>b     the data.</description>
					</attribute>
					<attribute name="@param">
						<description>off   the start offset in the data.</description>
					</attribute>
					<attribute name="@param">
						<description>len   the number of bytes to write.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException if the pipe is &lt;a href=#BROKEN&gt; broken&lt;/a&gt;,
          {@link #connect(java.io.PipedInputStream) unconnected},
          closed, or if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the data." fulltype="byte[]" type="byte" />
					<param name="off" comment="the start offset in the data." fulltype="int" type="int" />
					<param name="len" comment="the number of bytes to write." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if the pipe is &lt;a href=#BROKEN&gt; broken&lt;/a&gt;,
          {@link #connect(java.io.PipedInputStream) unconnected},
          closed, or if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="public" name="flush" fulltype="void" type="void">
				<comment>
					<description>Flushes this output stream and forces any buffered output bytes
 to be written out.
 This will notify any readers that bytes are waiting in the pipe.</description>
					<attribute name="@exception">
						<description>IOException if an I/O error occurs.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="close" fulltype="void" type="void">
				<comment>
					<description>Closes this piped output stream and releases any system resources
 associated with this stream. This stream may no longer be used for
 writing bytes.</description>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass abstract="true" visibility="public" package="java.io" interface="true" fulltype="java.io.ObjectInput" type="ObjectInput">
		<implements>
			<interface fulltype="java.io.DataInput" type="DataInput" />
		</implements>
		<comment>
			<description>ObjectInput extends the DataInput interface to include the reading of
 objects. DataInput includes methods for the input of primitive types,
 ObjectInput extends that interface to include objects, arrays, and Strings.</description>
			<attribute name="@author">
				<description>unascribed</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.InputStream</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.ObjectOutputStream</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.ObjectInputStream</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.1</description>
			</attribute>
		</comment>
		<methods>
			<method visibility="public" name="readObject" returncomment="the object read from the stream" fulltype="java.lang.Object" type="Object">
				<comment>
					<description>Read and return an object. The class that implements this interface
 defines where the object is &quot;read&quot; from.</description>
					<attribute name="@return">
						<description>the object read from the stream</description>
					</attribute>
					<attribute name="@exception">
						<description>java.lang.ClassNotFoundException If the class of a serialized
      object cannot be found.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException If any of the usual Input/Output
 related exceptions occur.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception fulltype="java.lang.ClassNotFoundException" type="ClassNotFoundException" />
					<exception comment="If any of the usual Input/Output
 related exceptions occur." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="read" returncomment="the byte read, or -1 if the end of the
          stream is reached." fulltype="int" type="int">
				<comment>
					<description>Reads a byte of data. This method will block if no input is
 available.</description>
					<attribute name="@return">
						<description>the byte read, or -1 if the end of the
          stream is reached.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException If an I/O error has occurred.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If an I/O error has occurred." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="read" returncomment="the actual number of bytes read, -1 is
          returned when the end of the stream is reached." fulltype="int" type="int">
				<comment>
					<description>Reads into an array of bytes.  This method will
 block until some input is available.</description>
					<attribute name="@param">
						<description>b the buffer into which the data is read</description>
					</attribute>
					<attribute name="@return">
						<description>the actual number of bytes read, -1 is
          returned when the end of the stream is reached.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException If an I/O error has occurred.</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the buffer into which the data is read" fulltype="byte[]" type="byte" />
				</params>
				<exceptions>
					<exception comment="If an I/O error has occurred." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="read" returncomment="the actual number of bytes read, -1 is
          returned when the end of the stream is reached." fulltype="int" type="int">
				<comment>
					<description>Reads into an array of bytes.  This method will
 block until some input is available.</description>
					<attribute name="@param">
						<description>b the buffer into which the data is read</description>
					</attribute>
					<attribute name="@param">
						<description>off the start offset of the data</description>
					</attribute>
					<attribute name="@param">
						<description>len the maximum number of bytes read</description>
					</attribute>
					<attribute name="@return">
						<description>the actual number of bytes read, -1 is
          returned when the end of the stream is reached.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException If an I/O error has occurred.</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the buffer into which the data is read" fulltype="byte[]" type="byte" />
					<param name="off" comment="the start offset of the data" fulltype="int" type="int" />
					<param name="len" comment="the maximum number of bytes read" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="If an I/O error has occurred." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="skip" returncomment="the actual number of bytes skipped." fulltype="long" type="long">
				<comment>
					<description>Skips n bytes of input.</description>
					<attribute name="@param">
						<description>n the number of bytes to be skipped</description>
					</attribute>
					<attribute name="@return">
						<description>the actual number of bytes skipped.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException If an I/O error has occurred.</description>
					</attribute>
				</comment>
				<params>
					<param name="n" comment="the number of bytes to be skipped" fulltype="long" type="long" />
				</params>
				<exceptions>
					<exception comment="If an I/O error has occurred." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="available" returncomment="the number of available bytes." fulltype="int" type="int">
				<comment>
					<description>Returns the number of bytes that can be read
 without blocking.</description>
					<attribute name="@return">
						<description>the number of available bytes.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException If an I/O error has occurred.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If an I/O error has occurred." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="close" fulltype="void" type="void">
				<comment>
					<description>Closes the input stream. Must be called
 to release any resources associated with
 the stream.</description>
					<attribute name="@exception">
						<description>IOException If an I/O error has occurred.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If an I/O error has occurred." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="Object" visibility="package-private" package="java.io" superclassfulltype="java.lang.Object" fulltype="java.io.Bits" type="Bits">
		<comment>
			<description>Utility methods for packing/unpacking primitive values in/out of byte arrays
 using big-endian byte ordering.</description>
		</comment>
		<methods>
			<constructor visibility="package-private" name="Bits" />
			<method static="true" visibility="package-private" name="getBoolean" fulltype="boolean" type="boolean">
				<params>
					<param name="b" fulltype="byte[]" type="byte" />
					<param name="off" fulltype="int" type="int" />
				</params>
			</method>
			<method static="true" visibility="package-private" name="getChar" fulltype="char" type="char">
				<params>
					<param name="b" fulltype="byte[]" type="byte" />
					<param name="off" fulltype="int" type="int" />
				</params>
			</method>
			<method static="true" visibility="package-private" name="getShort" fulltype="short" type="short">
				<params>
					<param name="b" fulltype="byte[]" type="byte" />
					<param name="off" fulltype="int" type="int" />
				</params>
			</method>
			<method static="true" visibility="package-private" name="getInt" fulltype="int" type="int">
				<params>
					<param name="b" fulltype="byte[]" type="byte" />
					<param name="off" fulltype="int" type="int" />
				</params>
			</method>
			<method static="true" visibility="package-private" name="getFloat" fulltype="float" type="float">
				<params>
					<param name="b" fulltype="byte[]" type="byte" />
					<param name="off" fulltype="int" type="int" />
				</params>
			</method>
			<method static="true" visibility="package-private" name="getLong" fulltype="long" type="long">
				<params>
					<param name="b" fulltype="byte[]" type="byte" />
					<param name="off" fulltype="int" type="int" />
				</params>
			</method>
			<method static="true" visibility="package-private" name="getDouble" fulltype="double" type="double">
				<params>
					<param name="b" fulltype="byte[]" type="byte" />
					<param name="off" fulltype="int" type="int" />
				</params>
			</method>
			<method static="true" visibility="package-private" name="putBoolean" fulltype="void" type="void">
				<params>
					<param name="b" fulltype="byte[]" type="byte" />
					<param name="off" fulltype="int" type="int" />
					<param name="val" fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method static="true" visibility="package-private" name="putChar" fulltype="void" type="void">
				<params>
					<param name="b" fulltype="byte[]" type="byte" />
					<param name="off" fulltype="int" type="int" />
					<param name="val" fulltype="char" type="char" />
				</params>
			</method>
			<method static="true" visibility="package-private" name="putShort" fulltype="void" type="void">
				<params>
					<param name="b" fulltype="byte[]" type="byte" />
					<param name="off" fulltype="int" type="int" />
					<param name="val" fulltype="short" type="short" />
				</params>
			</method>
			<method static="true" visibility="package-private" name="putInt" fulltype="void" type="void">
				<params>
					<param name="b" fulltype="byte[]" type="byte" />
					<param name="off" fulltype="int" type="int" />
					<param name="val" fulltype="int" type="int" />
				</params>
			</method>
			<method static="true" visibility="package-private" name="putFloat" fulltype="void" type="void">
				<params>
					<param name="b" fulltype="byte[]" type="byte" />
					<param name="off" fulltype="int" type="int" />
					<param name="val" fulltype="float" type="float" />
				</params>
			</method>
			<method static="true" visibility="package-private" name="putLong" fulltype="void" type="void">
				<params>
					<param name="b" fulltype="byte[]" type="byte" />
					<param name="off" fulltype="int" type="int" />
					<param name="val" fulltype="long" type="long" />
				</params>
			</method>
			<method static="true" visibility="package-private" name="putDouble" fulltype="void" type="void">
				<params>
					<param name="b" fulltype="byte[]" type="byte" />
					<param name="off" fulltype="int" type="int" />
					<param name="val" fulltype="double" type="double" />
				</params>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="Reader" visibility="public" package="java.io" superclassfulltype="java.io.Reader" fulltype="java.io.BufferedReader" type="BufferedReader">
		<comment>
			<description>Reads text from a character-input stream, buffering characters so as to
 provide for the efficient reading of characters, arrays, and lines.

 &lt;p&gt; The buffer size may be specified, or the default size may be used.  The
 default is large enough for most purposes.

 &lt;p&gt; In general, each read request made of a Reader causes a corresponding
 read request to be made of the underlying character or byte stream.  It is
 therefore advisable to wrap a BufferedReader around any Reader whose read()
 operations may be costly, such as FileReaders and InputStreamReaders.  For
 example,

 &lt;pre&gt;
 BufferedReader in
   = new BufferedReader(new FileReader(&quot;foo.in&quot;));
 &lt;/pre&gt;

 will buffer the input from the specified file.  Without buffering, each
 invocation of read() or readLine() could cause bytes to be read from the
 file, converted into characters, and then returned, which can be very
 inefficient.

 &lt;p&gt; Programs that use DataInputStreams for textual input can be localized by
 replacing each DataInputStream with an appropriate BufferedReader.</description>
			<attribute name="@see">
				<description>FileReader</description>
			</attribute>
			<attribute name="@see">
				<description>InputStreamReader</description>
			</attribute>
			<attribute name="@author">
				<description>Mark Reinhold</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.1</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="private" name="in" fulltype="java.io.Reader" type="Reader" />
			<field visibility="private" name="cb" fulltype="char[]" type="char" />
			<field visibility="private" name="nChars" fulltype="int" type="int" />
			<field visibility="private" name="nextChar" fulltype="int" type="int" />
			<field final="true" static="true" const="-2" visibility="private" name="INVALIDATED" constexpr="-2" fulltype="int" type="int" />
			<field final="true" static="true" const="-1" visibility="private" name="UNMARKED" constexpr="-1" fulltype="int" type="int" />
			<field visibility="private" name="markedChar" fulltype="int" type="int" />
			<field visibility="private" name="readAheadLimit" fulltype="int" type="int" />
			<field visibility="private" name="skipLF" fulltype="boolean" type="boolean">
				<comment>
					<description>If the next character is a line feed, skip it</description>
				</comment>
			</field>
			<field visibility="private" name="markedSkipLF" fulltype="boolean" type="boolean">
				<comment>
					<description>The skipLF flag when the mark was set</description>
				</comment>
			</field>
			<field static="true" visibility="private" name="defaultCharBufferSize" fulltype="int" type="int" />
			<field static="true" visibility="private" name="defaultExpectedLineLength" fulltype="int" type="int" />
		</fields>
		<methods>
			<constructor visibility="public" name="BufferedReader">
				<comment>
					<description>Creates a buffering character-input stream that uses an input buffer of
 the specified size.</description>
					<attribute name="@param">
						<description>in   A Reader</description>
					</attribute>
					<attribute name="@param">
						<description>sz   Input-buffer size</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException  If sz is &lt;= 0</description>
					</attribute>
				</comment>
				<params>
					<param name="in" comment="A Reader" fulltype="java.io.Reader" type="Reader" />
					<param name="sz" comment="Input-buffer size" fulltype="int" type="int" />
				</params>
			</constructor>
			<constructor visibility="public" name="BufferedReader">
				<comment>
					<description>Creates a buffering character-input stream that uses a default-sized
 input buffer.</description>
					<attribute name="@param">
						<description>in   A Reader</description>
					</attribute>
				</comment>
				<params>
					<param name="in" comment="A Reader" fulltype="java.io.Reader" type="Reader" />
				</params>
			</constructor>
			<method visibility="private" name="ensureOpen" fulltype="void" type="void">
				<comment>
					<description>Checks to make sure that the stream has not been closed</description>
				</comment>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="fill" fulltype="void" type="void">
				<comment>
					<description>Fills the input buffer, taking the mark into account if it is valid.</description>
				</comment>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="read" returncomment="The character read, as an integer in the range
         0 to 65535 (&lt;tt&gt;0x00-0xffff&lt;/tt&gt;), or -1 if the
         end of the stream has been reached" fulltype="int" type="int">
				<comment>
					<description>Reads a single character.</description>
					<attribute name="@return">
						<description>The character read, as an integer in the range
         0 to 65535 (&lt;tt&gt;0x00-0xffff&lt;/tt&gt;), or -1 if the
         end of the stream has been reached</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  If an I/O error occurs</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="read1" fulltype="int" type="int">
				<comment>
					<description>Reads characters into a portion of an array, reading from the underlying
 stream if necessary.</description>
				</comment>
				<params>
					<param name="cbuf" fulltype="char[]" type="char" />
					<param name="off" fulltype="int" type="int" />
					<param name="len" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="read" returncomment="The number of characters read, or -1 if the end of the
             stream has been reached" fulltype="int" type="int">
				<comment>
					<description>Reads characters into a portion of an array.

 &lt;p&gt; This method implements the general contract of the corresponding
 &lt;code&gt;{@link Reader#read(char[], int, int) read}&lt;/code&gt; method of the
 &lt;code&gt;{@link Reader}&lt;/code&gt; class.  As an additional convenience, it
 attempts to read as many characters as possible by repeatedly invoking
 the &lt;code&gt;read&lt;/code&gt; method of the underlying stream.  This iterated
 &lt;code&gt;read&lt;/code&gt; continues until one of the following conditions becomes
 true: &lt;ul&gt;

   &lt;li&gt; The specified number of characters have been read,

   &lt;li&gt; The &lt;code&gt;read&lt;/code&gt; method of the underlying stream returns
   &lt;code&gt;-1&lt;/code&gt;, indicating end-of-file, or

   &lt;li&gt; The &lt;code&gt;ready&lt;/code&gt; method of the underlying stream
   returns &lt;code&gt;false&lt;/code&gt;, indicating that further input requests
   would block.

 &lt;/ul&gt; If the first &lt;code&gt;read&lt;/code&gt; on the underlying stream returns
 &lt;code&gt;-1&lt;/code&gt; to indicate end-of-file then this method returns
 &lt;code&gt;-1&lt;/code&gt;.  Otherwise this method returns the number of characters
 actually read.

 &lt;p&gt; Subclasses of this class are encouraged, but not required, to
 attempt to read as many characters as possible in the same fashion.

 &lt;p&gt; Ordinarily this method takes characters from this stream&apos;s character
 buffer, filling it from the underlying stream as necessary.  If,
 however, the buffer is empty, the mark is not valid, and the requested
 length is at least as large as the buffer, then this method will read
 characters directly from the underlying stream into the given array.
 Thus redundant &lt;code&gt;BufferedReader&lt;/code&gt;s will not copy data
 unnecessarily.</description>
					<attribute name="@param">
						<description>cbuf  Destination buffer</description>
					</attribute>
					<attribute name="@param">
						<description>off   Offset at which to start storing characters</description>
					</attribute>
					<attribute name="@param">
						<description>len   Maximum number of characters to read</description>
					</attribute>
					<attribute name="@return">
						<description>The number of characters read, or -1 if the end of the
             stream has been reached</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  If an I/O error occurs</description>
					</attribute>
				</comment>
				<params>
					<param name="cbuf" comment="Destination buffer" fulltype="char[]" type="char" />
					<param name="off" comment="Offset at which to start storing characters" fulltype="int" type="int" />
					<param name="len" comment="Maximum number of characters to read" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="package-private" name="readLine" returncomment="A String containing the contents of the line, not including
             any line-termination characters, or null if the end of the
             stream has been reached" fulltype="java.lang.String" type="String">
				<comment>
					<description>Reads a line of text.  A line is considered to be terminated by any one
 of a line feed (&apos;\n&apos;), a carriage return (&apos;\r&apos;), or a carriage return
 followed immediately by a linefeed.</description>
					<attribute name="@param">
						<description>ignoreLF  If true, the next &apos;\n&apos; will be skipped</description>
					</attribute>
					<attribute name="@return">
						<description>A String containing the contents of the line, not including
             any line-termination characters, or null if the end of the
             stream has been reached</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.LineNumberReader#readLine()</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  If an I/O error occurs</description>
					</attribute>
				</comment>
				<params>
					<param name="ignoreLF" comment="If true, the next &apos;\n&apos; will be skipped" fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="readLine" returncomment="A String containing the contents of the line, not including
             any line-termination characters, or null if the end of the
             stream has been reached" fulltype="java.lang.String" type="String">
				<comment>
					<description>Reads a line of text.  A line is considered to be terminated by any one
 of a line feed (&apos;\n&apos;), a carriage return (&apos;\r&apos;), or a carriage return
 followed immediately by a linefeed.</description>
					<attribute name="@return">
						<description>A String containing the contents of the line, not including
             any line-termination characters, or null if the end of the
             stream has been reached</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  If an I/O error occurs</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="skip" returncomment="The number of characters actually skipped" fulltype="long" type="long">
				<comment>
					<description>Skips characters.</description>
					<attribute name="@param">
						<description>n  The number of characters to skip</description>
					</attribute>
					<attribute name="@return">
						<description>The number of characters actually skipped</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException  If &lt;code&gt;n&lt;/code&gt; is negative.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  If an I/O error occurs</description>
					</attribute>
				</comment>
				<params>
					<param name="n" comment="The number of characters to skip" fulltype="long" type="long" />
				</params>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="ready" fulltype="boolean" type="boolean">
				<comment>
					<description>Tells whether this stream is ready to be read.  A buffered character
 stream is ready if the buffer is not empty, or if the underlying
 character stream is ready.</description>
					<attribute name="@exception">
						<description>IOException  If an I/O error occurs</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="markSupported" fulltype="boolean" type="boolean">
				<comment>
					<description>Tells whether this stream supports the mark() operation, which it does.</description>
				</comment>
			</method>
			<method visibility="public" name="mark" fulltype="void" type="void">
				<comment>
					<description>Marks the present position in the stream.  Subsequent calls to reset()
 will attempt to reposition the stream to this point.</description>
					<attribute name="@param">
						<description>readAheadLimit   Limit on the number of characters that may be
                         read while still preserving the mark. An attempt
                         to reset the stream after reading characters
                         up to this limit or beyond may fail.
                         A limit value larger than the size of the input
                         buffer will cause a new buffer to be allocated
                         whose size is no smaller than limit.
                         Therefore large values should be used with care.</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException  If readAheadLimit is &lt; 0</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  If an I/O error occurs</description>
					</attribute>
				</comment>
				<params>
					<param name="readAheadLimit" comment="Limit on the number of characters that may be
                         read while still preserving the mark. An attempt
                         to reset the stream after reading characters
                         up to this limit or beyond may fail.
                         A limit value larger than the size of the input
                         buffer will cause a new buffer to be allocated
                         whose size is no smaller than limit.
                         Therefore large values should be used with care." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="reset" fulltype="void" type="void">
				<comment>
					<description>Resets the stream to the most recent mark.</description>
					<attribute name="@exception">
						<description>IOException  If the stream has never been marked,
                          or if the mark has been invalidated</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If the stream has never been marked,
                          or if the mark has been invalidated" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="close" fulltype="void" type="void">
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="IOException" visibility="public" package="java.io" serializable="true" superclassfulltype="java.io.IOException" fulltype="java.io.UnsupportedEncodingException" type="UnsupportedEncodingException">
		<comment>
			<description>The Character Encoding is not supported.</description>
			<attribute name="@author">
				<description>Asmus Freytag</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.1</description>
			</attribute>
		</comment>
		<methods>
			<constructor visibility="public" name="UnsupportedEncodingException">
				<comment>
					<description>Constructs an UnsupportedEncodingException without a detail message.</description>
				</comment>
			</constructor>
			<constructor visibility="public" name="UnsupportedEncodingException">
				<comment>
					<description>Constructs an UnsupportedEncodingException with a detail message.</description>
					<attribute name="@param">
						<description>s Describes the reason for the exception.</description>
					</attribute>
				</comment>
				<params>
					<param name="s" comment="Describes the reason for the exception." fulltype="java.lang.String" type="String" />
				</params>
			</constructor>
		</methods>
	</jelclass>
	<jelclass superclass="FilterInputStream" visibility="public" package="java.io" superclassfulltype="java.io.FilterInputStream" fulltype="java.io.LineNumberInputStream" type="LineNumberInputStream">
		<comment>
			<description>This class is an input stream filter that provides the added
 functionality of keeping track of the current line number.
 &lt;p&gt;
 A line is a sequence of bytes ending with a carriage return
 character (&lt;code&gt;&apos;&amp;#92;r&apos;&lt;/code&gt;), a newline character
 (&lt;code&gt;&apos;&amp;#92;n&apos;&lt;/code&gt;), or a carriage return character followed
 immediately by a linefeed character. In all three cases, the line
 terminating character(s) are returned as a single newline character.
 &lt;p&gt;
 The line number begins at &lt;code&gt;0&lt;/code&gt;, and is incremented by
 &lt;code&gt;1&lt;/code&gt; when a &lt;code&gt;read&lt;/code&gt; returns a newline character.</description>
			<attribute name="@author">
				<description>Arthur van Hoff</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.LineNumberReader</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.0</description>
			</attribute>
			<attribute name="@deprecated">
				<description>This class incorrectly assumes that bytes adequately represent
             characters.  As of JDK&amp;nbsp;1.1, the preferred way to operate on
             character streams is via the new character-stream classes, which
             include a class for counting line numbers.</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="package-private" name="pushBack" fulltype="int" type="int" />
			<field visibility="package-private" name="lineNumber" fulltype="int" type="int" />
			<field visibility="package-private" name="markLineNumber" fulltype="int" type="int" />
			<field visibility="package-private" name="markPushBack" fulltype="int" type="int" />
		</fields>
		<methods>
			<constructor visibility="public" name="LineNumberInputStream">
				<comment>
					<description>Constructs a newline number input stream that reads its input
 from the specified input stream.</description>
					<attribute name="@param">
						<description>in   the underlying input stream.</description>
					</attribute>
				</comment>
				<params>
					<param name="in" comment="the underlying input stream." fulltype="java.io.InputStream" type="InputStream" />
				</params>
			</constructor>
			<method visibility="public" name="read" returncomment="the next byte of data, or &lt;code&gt;-1&lt;/code&gt; if the end of this
             stream is reached." fulltype="int" type="int">
				<comment>
					<description>Reads the next byte of data from this input stream. The value
 byte is returned as an &lt;code&gt;int&lt;/code&gt; in the range
 &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;255&lt;/code&gt;. If no byte is available
 because the end of the stream has been reached, the value
 &lt;code&gt;-1&lt;/code&gt; is returned. This method blocks until input data
 is available, the end of the stream is detected, or an exception
 is thrown.
 &lt;p&gt;
 The &lt;code&gt;read&lt;/code&gt; method of
 &lt;code&gt;LineNumberInputStream&lt;/code&gt; calls the &lt;code&gt;read&lt;/code&gt;
 method of the underlying input stream. It checks for carriage
 returns and newline characters in the input, and modifies the
 current line number as appropriate. A carriage-return character or
 a carriage return followed by a newline character are both
 converted into a single newline character.</description>
					<attribute name="@return">
						<description>the next byte of data, or &lt;code&gt;-1&lt;/code&gt; if the end of this
             stream is reached.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.FilterInputStream#in</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.LineNumberInputStream#getLineNumber()</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="read" returncomment="the total number of bytes read into the buffer, or
             &lt;code&gt;-1&lt;/code&gt; if there is no more data because the end of
             this stream has been reached." fulltype="int" type="int">
				<comment>
					<description>Reads up to &lt;code&gt;len&lt;/code&gt; bytes of data from this input stream
 into an array of bytes. This method blocks until some input is available.
 &lt;p&gt;
 The &lt;code&gt;read&lt;/code&gt; method of
 &lt;code&gt;LineNumberInputStream&lt;/code&gt; repeatedly calls the
 &lt;code&gt;read&lt;/code&gt; method of zero arguments to fill in the byte array.</description>
					<attribute name="@param">
						<description>b     the buffer into which the data is read.</description>
					</attribute>
					<attribute name="@param">
						<description>off   the start offset of the data.</description>
					</attribute>
					<attribute name="@param">
						<description>len   the maximum number of bytes read.</description>
					</attribute>
					<attribute name="@return">
						<description>the total number of bytes read into the buffer, or
             &lt;code&gt;-1&lt;/code&gt; if there is no more data because the end of
             this stream has been reached.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.LineNumberInputStream#read()</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the buffer into which the data is read." fulltype="byte[]" type="byte" />
					<param name="off" comment="the start offset of the data." fulltype="int" type="int" />
					<param name="len" comment="the maximum number of bytes read." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="skip" returncomment="the actual number of bytes skipped." fulltype="long" type="long">
				<comment>
					<description>Skips over and discards &lt;code&gt;n&lt;/code&gt; bytes of data from this
 input stream. The &lt;code&gt;skip&lt;/code&gt; method may, for a variety of
 reasons, end up skipping over some smaller number of bytes,
 possibly &lt;code&gt;0&lt;/code&gt;. The actual number of bytes skipped is
 returned.  If &lt;code&gt;n&lt;/code&gt; is negative, no bytes are skipped.
 &lt;p&gt;
 The &lt;code&gt;skip&lt;/code&gt; method of &lt;code&gt;LineNumberInputStream&lt;/code&gt; creates
 a byte array and then repeatedly reads into it until
 &lt;code&gt;n&lt;/code&gt; bytes have been read or the end of the stream has
 been reached.</description>
					<attribute name="@param">
						<description>n   the number of bytes to be skipped.</description>
					</attribute>
					<attribute name="@return">
						<description>the actual number of bytes skipped.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.FilterInputStream#in</description>
					</attribute>
				</comment>
				<params>
					<param name="n" comment="the number of bytes to be skipped." fulltype="long" type="long" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="setLineNumber" fulltype="void" type="void">
				<comment>
					<description>Sets the line number to the specified argument.</description>
					<attribute name="@param">
						<description>lineNumber   the new line number.</description>
					</attribute>
					<attribute name="@see">
						<description>#getLineNumber</description>
					</attribute>
				</comment>
				<params>
					<param name="lineNumber" comment="the new line number." fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="getLineNumber" returncomment="the current line number." fulltype="int" type="int">
				<comment>
					<description>Returns the current line number.</description>
					<attribute name="@return">
						<description>the current line number.</description>
					</attribute>
					<attribute name="@see">
						<description>#setLineNumber</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="available" returncomment="the number of bytes that can be read from this input stream
             without blocking." fulltype="int" type="int">
				<comment>
					<description>Returns the number of bytes that can be read from this input
 stream without blocking.
 &lt;p&gt;
 Note that if the underlying input stream is able to supply
 &lt;i&gt;k&lt;/i&gt; input characters without blocking, the
 &lt;code&gt;LineNumberInputStream&lt;/code&gt; can guarantee only to provide
 &lt;i&gt;k&lt;/i&gt;/2 characters without blocking, because the
 &lt;i&gt;k&lt;/i&gt; characters from the underlying input stream might
 consist of &lt;i&gt;k&lt;/i&gt;/2 pairs of &lt;code&gt;&apos;&amp;#92;r&apos;&lt;/code&gt; and
 &lt;code&gt;&apos;&amp;#92;n&apos;&lt;/code&gt;, which are converted to just
 &lt;i&gt;k&lt;/i&gt;/2 &lt;code&gt;&apos;&amp;#92;n&apos;&lt;/code&gt; characters.</description>
					<attribute name="@return">
						<description>the number of bytes that can be read from this input stream
             without blocking.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.FilterInputStream#in</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="mark" fulltype="void" type="void">
				<comment>
					<description>Marks the current position in this input stream. A subsequent
 call to the &lt;code&gt;reset&lt;/code&gt; method repositions this stream at
 the last marked position so that subsequent reads re-read the same bytes.
 &lt;p&gt;
 The &lt;code&gt;mark&lt;/code&gt; method of
 &lt;code&gt;LineNumberInputStream&lt;/code&gt; remembers the current line
 number in a private variable, and then calls the &lt;code&gt;mark&lt;/code&gt;
 method of the underlying input stream.</description>
					<attribute name="@param">
						<description>readlimit   the maximum limit of bytes that can be read before
                      the mark position becomes invalid.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.FilterInputStream#in</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.LineNumberInputStream#reset()</description>
					</attribute>
				</comment>
				<params>
					<param name="readlimit" comment="the maximum limit of bytes that can be read before
                      the mark position becomes invalid." fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="reset" fulltype="void" type="void">
				<comment>
					<description>Repositions this stream to the position at the time the
 &lt;code&gt;mark&lt;/code&gt; method was last called on this input stream.
 &lt;p&gt;
 The &lt;code&gt;reset&lt;/code&gt; method of
 &lt;code&gt;LineNumberInputStream&lt;/code&gt; resets the line number to be
 the line number at the time the &lt;code&gt;mark&lt;/code&gt; method was
 called, and then calls the &lt;code&gt;reset&lt;/code&gt; method of the
 underlying input stream.
 &lt;p&gt;
 Stream marks are intended to be used in
 situations where you need to read ahead a little to see what&apos;s in
 the stream. Often this is most easily done by invoking some
 general parser. If the stream is of the type handled by the
 parser, it just chugs along happily. If the stream is not of
 that type, the parser should toss an exception when it fails,
 which, if it happens within readlimit bytes, allows the outer
 code to reset the stream and try another parser.</description>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.FilterInputStream#in</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.LineNumberInputStream#mark(int)</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="FilterReader" visibility="public" package="java.io" superclassfulltype="java.io.FilterReader" fulltype="java.io.PushbackReader" type="PushbackReader">
		<comment>
			<description>A character-stream reader that allows characters to be pushed back into the
 stream.</description>
			<attribute name="@author">
				<description>Mark Reinhold</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.1</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="private" name="buf" fulltype="char[]" type="char">
				<comment>
					<description>Pushback buffer</description>
				</comment>
			</field>
			<field visibility="private" name="pos" fulltype="int" type="int">
				<comment>
					<description>Current position in buffer</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="public" name="PushbackReader">
				<comment>
					<description>Creates a new pushback reader with a pushback buffer of the given size.</description>
					<attribute name="@param">
						<description>in   The reader from which characters will be read</description>
					</attribute>
					<attribute name="@param">
						<description>size The size of the pushback buffer</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if size is &lt;= 0</description>
					</attribute>
				</comment>
				<params>
					<param name="in" comment="The reader from which characters will be read" fulltype="java.io.Reader" type="Reader" />
					<param name="size" comment="The size of the pushback buffer" fulltype="int" type="int" />
				</params>
			</constructor>
			<constructor visibility="public" name="PushbackReader">
				<comment>
					<description>Creates a new pushback reader with a one-character pushback buffer.</description>
					<attribute name="@param">
						<description>in  The reader from which characters will be read</description>
					</attribute>
				</comment>
				<params>
					<param name="in" comment="The reader from which characters will be read" fulltype="java.io.Reader" type="Reader" />
				</params>
			</constructor>
			<method visibility="private" name="ensureOpen" fulltype="void" type="void">
				<comment>
					<description>Checks to make sure that the stream has not been closed.</description>
				</comment>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="read" returncomment="The character read, or -1 if the end of the stream has been
             reached" fulltype="int" type="int">
				<comment>
					<description>Reads a single character.</description>
					<attribute name="@return">
						<description>The character read, or -1 if the end of the stream has been
             reached</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  If an I/O error occurs</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="read" returncomment="The number of characters read, or -1 if the end of the
             stream has been reached" fulltype="int" type="int">
				<comment>
					<description>Reads characters into a portion of an array.</description>
					<attribute name="@param">
						<description>cbuf  Destination buffer</description>
					</attribute>
					<attribute name="@param">
						<description>off   Offset at which to start writing characters</description>
					</attribute>
					<attribute name="@param">
						<description>len   Maximum number of characters to read</description>
					</attribute>
					<attribute name="@return">
						<description>The number of characters read, or -1 if the end of the
             stream has been reached</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  If an I/O error occurs</description>
					</attribute>
				</comment>
				<params>
					<param name="cbuf" comment="Destination buffer" fulltype="char[]" type="char" />
					<param name="off" comment="Offset at which to start writing characters" fulltype="int" type="int" />
					<param name="len" comment="Maximum number of characters to read" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="unread" fulltype="void" type="void">
				<comment>
					<description>Pushes back a single character by copying it to the front of the
 pushback buffer. After this method returns, the next character to be read
 will have the value &lt;code&gt;(char)c&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>c  The int value representing a character to be pushed back</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  If the pushback buffer is full,
                          or if some other I/O error occurs</description>
					</attribute>
				</comment>
				<params>
					<param name="c" comment="The int value representing a character to be pushed back" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="If the pushback buffer is full,
                          or if some other I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="unread" fulltype="void" type="void">
				<comment>
					<description>Pushes back a portion of an array of characters by copying it to the
 front of the pushback buffer.  After this method returns, the next
 character to be read will have the value &lt;code&gt;cbuf[off]&lt;/code&gt;, the
 character after that will have the value &lt;code&gt;cbuf[off+1]&lt;/code&gt;, and
 so forth.</description>
					<attribute name="@param">
						<description>cbuf  Character array</description>
					</attribute>
					<attribute name="@param">
						<description>off   Offset of first character to push back</description>
					</attribute>
					<attribute name="@param">
						<description>len   Number of characters to push back</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  If there is insufficient room in the pushback
                          buffer, or if some other I/O error occurs</description>
					</attribute>
				</comment>
				<params>
					<param name="cbuf" comment="Character array" fulltype="char[]" type="char" />
					<param name="off" comment="Offset of first character to push back" fulltype="int" type="int" />
					<param name="len" comment="Number of characters to push back" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="If there is insufficient room in the pushback
                          buffer, or if some other I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="unread" fulltype="void" type="void">
				<comment>
					<description>Pushes back an array of characters by copying it to the front of the
 pushback buffer.  After this method returns, the next character to be
 read will have the value &lt;code&gt;cbuf[0]&lt;/code&gt;, the character after that
 will have the value &lt;code&gt;cbuf[1]&lt;/code&gt;, and so forth.</description>
					<attribute name="@param">
						<description>cbuf  Character array to push back</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  If there is insufficient room in the pushback
                          buffer, or if some other I/O error occurs</description>
					</attribute>
				</comment>
				<params>
					<param name="cbuf" comment="Character array to push back" fulltype="char[]" type="char" />
				</params>
				<exceptions>
					<exception comment="If there is insufficient room in the pushback
                          buffer, or if some other I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="ready" fulltype="boolean" type="boolean">
				<comment>
					<description>Tells whether this stream is ready to be read.</description>
					<attribute name="@exception">
						<description>IOException  If an I/O error occurs</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="mark" fulltype="void" type="void">
				<comment>
					<description>Marks the present position in the stream. The &lt;code&gt;mark&lt;/code&gt;
 for class &lt;code&gt;PushbackReader&lt;/code&gt; always throws an exception.</description>
					<attribute name="@exception">
						<description>IOException  Always, since mark is not supported</description>
					</attribute>
				</comment>
				<params>
					<param name="readAheadLimit" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="Always, since mark is not supported" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="reset" fulltype="void" type="void">
				<comment>
					<description>Resets the stream. The &lt;code&gt;reset&lt;/code&gt; method of
 &lt;code&gt;PushbackReader&lt;/code&gt; always throws an exception.</description>
					<attribute name="@exception">
						<description>IOException  Always, since reset is not supported</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="Always, since reset is not supported" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="markSupported" fulltype="boolean" type="boolean">
				<comment>
					<description>Tells whether this stream supports the mark() operation, which it does
 not.</description>
				</comment>
			</method>
			<method visibility="public" name="close" fulltype="void" type="void">
				<comment>
					<description>Closes the stream and releases any system resources associated with
 it. Once the stream has been closed, further read(),
 unread(), ready(), or skip() invocations will throw an IOException.
 Closing a previously closed stream has no effect.</description>
					<attribute name="@exception">
						<description>IOException  If an I/O error occurs</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="skip" returncomment="The number of characters actually skipped" fulltype="long" type="long">
				<comment>
					<description>Skips characters.  This method will block until some characters are
 available, an I/O error occurs, or the end of the stream is reached.</description>
					<attribute name="@param">
						<description>n  The number of characters to skip</description>
					</attribute>
					<attribute name="@return">
						<description>The number of characters actually skipped</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException  If &lt;code&gt;n&lt;/code&gt; is negative.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  If an I/O error occurs</description>
					</attribute>
				</comment>
				<params>
					<param name="n" comment="The number of characters to skip" fulltype="long" type="long" />
				</params>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass abstract="true" visibility="public" package="java.io" interface="true" fulltype="java.io.FilenameFilter" type="FilenameFilter">
		<comment>
			<description>Instances of classes that implement this interface are used to
 filter filenames. These instances are used to filter directory
 listings in the &lt;code&gt;list&lt;/code&gt; method of class
 &lt;code&gt;File&lt;/code&gt;, and by the Abstract Window Toolkit&apos;s file
 dialog component.</description>
			<attribute name="@author">
				<description>Arthur van Hoff</description>
			</attribute>
			<attribute name="@author">
				<description>Jonathan Payne</description>
			</attribute>
			<attribute name="@see">
				<description>java.awt.FileDialog#setFilenameFilter(java.io.FilenameFilter)</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.File</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.File#list(java.io.FilenameFilter)</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.0</description>
			</attribute>
		</comment>
		<methods>
			<method visibility="public" name="accept" returncomment="&lt;code&gt;true&lt;/code&gt; if and only if the name should be
 included in the file list; &lt;code&gt;false&lt;/code&gt; otherwise." fulltype="boolean" type="boolean">
				<comment>
					<description>Tests if a specified file should be included in a file list.</description>
					<attribute name="@param">
						<description>dir    the directory in which the file was found.</description>
					</attribute>
					<attribute name="@param">
						<description>name   the name of the file.</description>
					</attribute>
					<attribute name="@return">
						<description>&lt;code&gt;true&lt;/code&gt; if and only if the name should be
 included in the file list; &lt;code&gt;false&lt;/code&gt; otherwise.</description>
					</attribute>
				</comment>
				<params>
					<param name="dir" comment="the directory in which the file was found." fulltype="java.io.File" type="File" />
					<param name="name" comment="the name of the file." fulltype="java.lang.String" type="String" />
				</params>
			</method>
		</methods>
	</jelclass>
	<jelclass final="true" superclass="Object" visibility="package-private" package="java.io" superclassfulltype="java.lang.Object" fulltype="java.io.SerialCallbackContext" type="SerialCallbackContext">
		<comment>
			<description>Context during upcalls from object stream to class-defined
 readObject/writeObject methods. 
 Holds object currently being deserialized and descriptor for current class. 

 This context keeps track of the thread it was constructed on, and allows
 only a single call of defaultReadObject, readFields, defaultWriteObject 
 or writeFields which must be invoked on the same thread before the class&apos;s
 readObject/writeObject method has returned.
 If not set to the current thread, the getObj method throws NotActiveException.</description>
		</comment>
		<fields>
			<field final="true" visibility="private" name="obj" fulltype="java.lang.Object" type="Object" />
			<field final="true" visibility="private" name="desc" fulltype="java.io.ObjectStreamClass" type="ObjectStreamClass" />
			<field visibility="private" name="thread" fulltype="java.lang.Thread" type="Thread">
				<comment>
					<description>Thread this context is in use by.
 As this only works in one thread, we do not need to worry about thread-safety.</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="public" name="SerialCallbackContext">
				<params>
					<param name="obj" fulltype="java.lang.Object" type="Object" />
					<param name="desc" fulltype="java.io.ObjectStreamClass" type="ObjectStreamClass" />
				</params>
			</constructor>
			<method visibility="public" name="getObj" fulltype="java.lang.Object" type="Object">
				<exceptions>
					<exception fulltype="java.io.NotActiveException" type="NotActiveException" />
				</exceptions>
			</method>
			<method visibility="public" name="getDesc" fulltype="java.io.ObjectStreamClass" type="ObjectStreamClass" />
			<method visibility="private" name="checkAndSetUsed" fulltype="void" type="void">
				<exceptions>
					<exception fulltype="java.io.NotActiveException" type="NotActiveException" />
				</exceptions>
			</method>
			<method visibility="public" name="setUsed" fulltype="void" type="void" />
		</methods>
	</jelclass>
	<jelclass superclass="OutputStream" visibility="public" package="java.io" superclassfulltype="java.io.OutputStream" fulltype="java.io.ByteArrayOutputStream" type="ByteArrayOutputStream">
		<comment>
			<description>This class implements an output stream in which the data is
 written into a byte array. The buffer automatically grows as data
 is written to it.
 The data can be retrieved using &lt;code&gt;toByteArray()&lt;/code&gt; and
 &lt;code&gt;toString()&lt;/code&gt;.
 &lt;p&gt;
 Closing a &lt;tt&gt;ByteArrayOutputStream&lt;/tt&gt; has no effect. The methods in
 this class can be called after the stream has been closed without
 generating an &lt;tt&gt;IOException&lt;/tt&gt;.</description>
			<attribute name="@author">
				<description>Arthur van Hoff</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.0</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="protected" name="buf" fulltype="byte[]" type="byte">
				<comment>
					<description>The buffer where data is stored.</description>
				</comment>
			</field>
			<field visibility="protected" name="count" fulltype="int" type="int">
				<comment>
					<description>The number of valid bytes in the buffer.</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="public" name="ByteArrayOutputStream">
				<comment>
					<description>Creates a new byte array output stream. The buffer capacity is
 initially 32 bytes, though its size increases if necessary.</description>
				</comment>
			</constructor>
			<constructor visibility="public" name="ByteArrayOutputStream">
				<comment>
					<description>Creates a new byte array output stream, with a buffer capacity of
 the specified size, in bytes.</description>
					<attribute name="@param">
						<description>size   the initial size.</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if size is negative.</description>
					</attribute>
				</comment>
				<params>
					<param name="size" comment="the initial size." fulltype="int" type="int" />
				</params>
			</constructor>
			<method synchronized="true" visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes the specified byte to this byte array output stream.</description>
					<attribute name="@param">
						<description>b   the byte to be written.</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the byte to be written." fulltype="int" type="int" />
				</params>
			</method>
			<method synchronized="true" visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes &lt;code&gt;len&lt;/code&gt; bytes from the specified byte array
 starting at offset &lt;code&gt;off&lt;/code&gt; to this byte array output stream.</description>
					<attribute name="@param">
						<description>b     the data.</description>
					</attribute>
					<attribute name="@param">
						<description>off   the start offset in the data.</description>
					</attribute>
					<attribute name="@param">
						<description>len   the number of bytes to write.</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the data." fulltype="byte[]" type="byte" />
					<param name="off" comment="the start offset in the data." fulltype="int" type="int" />
					<param name="len" comment="the number of bytes to write." fulltype="int" type="int" />
				</params>
			</method>
			<method synchronized="true" visibility="public" name="writeTo" fulltype="void" type="void">
				<comment>
					<description>Writes the complete contents of this byte array output stream to
 the specified output stream argument, as if by calling the output
 stream&apos;s write method using &lt;code&gt;out.write(buf, 0, count)&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>out   the output stream to which to write the data.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="out" comment="the output stream to which to write the data." fulltype="java.io.OutputStream" type="OutputStream" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="public" name="reset" fulltype="void" type="void">
				<comment>
					<description>Resets the &lt;code&gt;count&lt;/code&gt; field of this byte array output
 stream to zero, so that all currently accumulated output in the
 output stream is discarded. The output stream can be used again,
 reusing the already allocated buffer space.</description>
					<attribute name="@see">
						<description>java.io.ByteArrayInputStream#count</description>
					</attribute>
				</comment>
			</method>
			<method synchronized="true" visibility="public" name="toByteArray" returncomment="the current contents of this output stream, as a byte array." fulltype="byte[]" type="byte">
				<comment>
					<description>Creates a newly allocated byte array. Its size is the current
 size of this output stream and the valid contents of the buffer
 have been copied into it.</description>
					<attribute name="@return">
						<description>the current contents of this output stream, as a byte array.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.ByteArrayOutputStream#size()</description>
					</attribute>
				</comment>
			</method>
			<method synchronized="true" visibility="public" name="size" returncomment="the value of the &lt;code&gt;count&lt;/code&gt; field, which is the number
          of valid bytes in this output stream." fulltype="int" type="int">
				<comment>
					<description>Returns the current size of the buffer.</description>
					<attribute name="@return">
						<description>the value of the &lt;code&gt;count&lt;/code&gt; field, which is the number
          of valid bytes in this output stream.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.ByteArrayOutputStream#count</description>
					</attribute>
				</comment>
			</method>
			<method synchronized="true" visibility="public" name="toString" returncomment="String decoded from the buffer&apos;s contents." fulltype="java.lang.String" type="String">
				<comment>
					<description>Converts the buffer&apos;s contents into a string decoding bytes using the
 platform&apos;s default character set. The length of the new &lt;tt&gt;String&lt;/tt&gt;
 is a function of the character set, and hence may not be equal to the
 size of the buffer.

 &lt;p&gt; This method always replaces malformed-input and unmappable-character
 sequences with the default replacement string for the platform&apos;s
 default character set. The {@linkplain java.nio.charset.CharsetDecoder}
 class should be used when more control over the decoding process is
 required.</description>
					<attribute name="@return">
						<description>String decoded from the buffer&apos;s contents.</description>
					</attribute>
					<attribute name="@since">
						<description>JDK1.1</description>
					</attribute>
				</comment>
			</method>
			<method synchronized="true" visibility="public" name="toString" returncomment="String decoded from the buffer&apos;s contents." fulltype="java.lang.String" type="String">
				<comment>
					<description>Converts the buffer&apos;s contents into a string by decoding the bytes using
 the specified {@link java.nio.charset.Charset charsetName}. The length of
 the new &lt;tt&gt;String&lt;/tt&gt; is a function of the charset, and hence may not be
 equal to the length of the byte array.

 &lt;p&gt; This method always replaces malformed-input and unmappable-character
 sequences with this charset&apos;s default replacement string. The {@link
 java.nio.charset.CharsetDecoder} class should be used when more control
 over the decoding process is required.</description>
					<attribute name="@param">
						<description>charsetName  the name of a supported
              {@linkplain java.nio.charset.Charset &lt;/code&gt;charset&lt;code&gt;}</description>
					</attribute>
					<attribute name="@return">
						<description>String decoded from the buffer&apos;s contents.</description>
					</attribute>
					<attribute name="@exception">
						<description>UnsupportedEncodingException
             If the named charset is not supported</description>
					</attribute>
					<attribute name="@since">
						<description>JDK1.1</description>
					</attribute>
				</comment>
				<params>
					<param name="charsetName" comment="the name of a supported
              {@linkplain java.nio.charset.Charset &lt;/code&gt;charset&lt;code&gt;}" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception comment="If the named charset is not supported" fulltype="java.io.UnsupportedEncodingException" type="UnsupportedEncodingException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="public" name="toString" returncomment="the current contents of the output stream, as a string." fulltype="java.lang.String" type="String">
				<comment>
					<description>Creates a newly allocated string. Its size is the current size of
 the output stream and the valid contents of the buffer have been
 copied into it. Each character &lt;i&gt;c&lt;/i&gt; in the resulting string is
 constructed from the corresponding element &lt;i&gt;b&lt;/i&gt; in the byte
 array such that:
 &lt;blockquote&gt;&lt;pre&gt;
     c == (char)(((hibyte &amp;amp; 0xff) &amp;lt;&amp;lt; 8) | (b &amp;amp; 0xff))
 &lt;/pre&gt;&lt;/blockquote&gt;</description>
					<attribute name="@deprecated">
						<description>This method does not properly convert bytes into characters.
 As of JDK&amp;nbsp;1.1, the preferred way to do this is via the
 &lt;code&gt;toString(String enc)&lt;/code&gt; method, which takes an encoding-name
 argument, or the &lt;code&gt;toString()&lt;/code&gt; method, which uses the
 platform&apos;s default character encoding.</description>
					</attribute>
					<attribute name="@param">
						<description>hibyte    the high byte of each resulting Unicode character.</description>
					</attribute>
					<attribute name="@return">
						<description>the current contents of the output stream, as a string.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.ByteArrayOutputStream#size()</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.ByteArrayOutputStream#toString(String)</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.ByteArrayOutputStream#toString()</description>
					</attribute>
				</comment>
				<params>
					<param name="hibyte" comment="the high byte of each resulting Unicode character." fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="close" fulltype="void" type="void">
				<comment>
					<description>Closing a &lt;tt&gt;ByteArrayOutputStream&lt;/tt&gt; has no effect. The methods in
 this class can be called after the stream has been closed without
 generating an &lt;tt&gt;IOException&lt;/tt&gt;.
 &lt;p&gt;</description>
				</comment>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass abstract="true" visibility="public" package="java.io" interface="true" fulltype="java.io.ObjectStreamConstants" type="ObjectStreamConstants">
		<comment>
			<description>Constants written into the Object Serialization Stream.</description>
			<attribute name="@author">
				<description>unascribed</description>
			</attribute>
			<attribute name="@since">
				<description>JDK 1.1</description>
			</attribute>
		</comment>
		<fields>
			<field final="true" static="true" const="-21267" visibility="public" name="STREAM_MAGIC" constexpr="-21267" fulltype="short" type="short">
				<comment>
					<description>Magic number that is written to the stream header.</description>
				</comment>
			</field>
			<field final="true" static="true" const="5" visibility="public" name="STREAM_VERSION" constexpr="5" fulltype="short" type="short">
				<comment>
					<description>Version number that is written to the stream header.</description>
				</comment>
			</field>
			<field final="true" static="true" const="112" visibility="public" name="TC_BASE" constexpr="112" fulltype="byte" type="byte">
				<comment>
					<description>First tag value.</description>
				</comment>
			</field>
			<field final="true" static="true" const="112" visibility="public" name="TC_NULL" constexpr="112" fulltype="byte" type="byte">
				<comment>
					<description>Null object reference.</description>
				</comment>
			</field>
			<field final="true" static="true" const="113" visibility="public" name="TC_REFERENCE" constexpr="113" fulltype="byte" type="byte">
				<comment>
					<description>Reference to an object already written into the stream.</description>
				</comment>
			</field>
			<field final="true" static="true" const="114" visibility="public" name="TC_CLASSDESC" constexpr="114" fulltype="byte" type="byte">
				<comment>
					<description>new Class Descriptor.</description>
				</comment>
			</field>
			<field final="true" static="true" const="115" visibility="public" name="TC_OBJECT" constexpr="115" fulltype="byte" type="byte">
				<comment>
					<description>new Object.</description>
				</comment>
			</field>
			<field final="true" static="true" const="116" visibility="public" name="TC_STRING" constexpr="116" fulltype="byte" type="byte">
				<comment>
					<description>new String.</description>
				</comment>
			</field>
			<field final="true" static="true" const="117" visibility="public" name="TC_ARRAY" constexpr="117" fulltype="byte" type="byte">
				<comment>
					<description>new Array.</description>
				</comment>
			</field>
			<field final="true" static="true" const="118" visibility="public" name="TC_CLASS" constexpr="118" fulltype="byte" type="byte">
				<comment>
					<description>Reference to Class.</description>
				</comment>
			</field>
			<field final="true" static="true" const="119" visibility="public" name="TC_BLOCKDATA" constexpr="119" fulltype="byte" type="byte">
				<comment>
					<description>Block of optional data. Byte following tag indicates number
 of bytes in this block data.</description>
				</comment>
			</field>
			<field final="true" static="true" const="120" visibility="public" name="TC_ENDBLOCKDATA" constexpr="120" fulltype="byte" type="byte">
				<comment>
					<description>End of optional block data blocks for an object.</description>
				</comment>
			</field>
			<field final="true" static="true" const="121" visibility="public" name="TC_RESET" constexpr="121" fulltype="byte" type="byte">
				<comment>
					<description>Reset stream context. All handles written into stream are reset.</description>
				</comment>
			</field>
			<field final="true" static="true" const="122" visibility="public" name="TC_BLOCKDATALONG" constexpr="122" fulltype="byte" type="byte">
				<comment>
					<description>long Block data. The long following the tag indicates the
 number of bytes in this block data.</description>
				</comment>
			</field>
			<field final="true" static="true" const="123" visibility="public" name="TC_EXCEPTION" constexpr="123" fulltype="byte" type="byte">
				<comment>
					<description>Exception during write.</description>
				</comment>
			</field>
			<field final="true" static="true" const="124" visibility="public" name="TC_LONGSTRING" constexpr="124" fulltype="byte" type="byte">
				<comment>
					<description>Long string.</description>
				</comment>
			</field>
			<field final="true" static="true" const="125" visibility="public" name="TC_PROXYCLASSDESC" constexpr="125" fulltype="byte" type="byte">
				<comment>
					<description>new Proxy Class Descriptor.</description>
				</comment>
			</field>
			<field final="true" static="true" const="126" visibility="public" name="TC_ENUM" constexpr="126" fulltype="byte" type="byte">
				<comment>
					<description>new Enum constant.</description>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
			</field>
			<field final="true" static="true" const="126" visibility="public" name="TC_MAX" constexpr="126" fulltype="byte" type="byte">
				<comment>
					<description>Last tag value.</description>
				</comment>
			</field>
			<field final="true" static="true" const="8257536" visibility="public" name="baseWireHandle" constexpr="8257536" fulltype="int" type="int">
				<comment>
					<description>First wire handle to be assigned.</description>
				</comment>
			</field>
			<field final="true" static="true" const="1" visibility="public" name="SC_WRITE_METHOD" constexpr="1" fulltype="byte" type="byte">
				<comment>
					<description>Bit mask for ObjectStreamClass flag. Indicates a Serializable class
 defines its own writeObject method.</description>
				</comment>
			</field>
			<field final="true" static="true" const="8" visibility="public" name="SC_BLOCK_DATA" constexpr="8" fulltype="byte" type="byte">
				<comment>
					<description>Bit mask for ObjectStreamClass flag. Indicates Externalizable data
 written in Block Data mode.
 Added for PROTOCOL_VERSION_2.</description>
					<attribute name="@see">
						<description>#PROTOCOL_VERSION_2</description>
					</attribute>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
			</field>
			<field final="true" static="true" const="2" visibility="public" name="SC_SERIALIZABLE" constexpr="2" fulltype="byte" type="byte">
				<comment>
					<description>Bit mask for ObjectStreamClass flag. Indicates class is Serializable.</description>
				</comment>
			</field>
			<field final="true" static="true" const="4" visibility="public" name="SC_EXTERNALIZABLE" constexpr="4" fulltype="byte" type="byte">
				<comment>
					<description>Bit mask for ObjectStreamClass flag. Indicates class is Externalizable.</description>
				</comment>
			</field>
			<field final="true" static="true" const="16" visibility="public" name="SC_ENUM" constexpr="16" fulltype="byte" type="byte">
				<comment>
					<description>Bit mask for ObjectStreamClass flag. Indicates class is an enum type.</description>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
			</field>
			<field final="true" static="true" visibility="public" name="SUBSTITUTION_PERMISSION" fulltype="java.io.SerializablePermission" type="SerializablePermission">
				<comment>
					<description>Enable substitution of one object for another during
 serialization/deserialization.</description>
					<attribute name="@see">
						<description>java.io.ObjectOutputStream#enableReplaceObject(boolean)</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.ObjectInputStream#enableResolveObject(boolean)</description>
					</attribute>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
			</field>
			<field final="true" static="true" visibility="public" name="SUBCLASS_IMPLEMENTATION_PERMISSION" fulltype="java.io.SerializablePermission" type="SerializablePermission">
				<comment>
					<description>Enable overriding of readObject and writeObject.</description>
					<attribute name="@see">
						<description>java.io.ObjectOutputStream#writeObjectOverride(Object)</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.ObjectInputStream#readObjectOverride()</description>
					</attribute>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
			</field>
			<field final="true" static="true" const="1" visibility="public" name="PROTOCOL_VERSION_1" constexpr="1" fulltype="int" type="int">
				<comment>
					<description>A Stream Protocol Version. &lt;p&gt;

 All externalizable data is written in JDK 1.1 external data
 format after calling this method. This version is needed to write
 streams containing Externalizable data that can be read by
 pre-JDK 1.1.6 JVMs.</description>
					<attribute name="@see">
						<description>java.io.ObjectOutputStream#useProtocolVersion(int)</description>
					</attribute>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
			</field>
			<field final="true" static="true" const="2" visibility="public" name="PROTOCOL_VERSION_2" constexpr="2" fulltype="int" type="int">
				<comment>
					<description>A Stream Protocol Version. &lt;p&gt;

 This protocol is written by JVM 1.2.

 Externalizable data is written in block data mode and is
 terminated with TC_ENDBLOCKDATA. Externalizable classdescriptor
 flags has SC_BLOCK_DATA enabled. JVM 1.1.6 and greater can
 read this format change.

 Enables writing a nonSerializable class descriptor into the
 stream. The serialVersionUID of a nonSerializable class is
 set to 0L.</description>
					<attribute name="@see">
						<description>java.io.ObjectOutputStream#useProtocolVersion(int)</description>
					</attribute>
					<attribute name="@see">
						<description>#SC_BLOCK_DATA</description>
					</attribute>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
			</field>
		</fields>
	</jelclass>
	<jelclass superclass="ObjectStreamException" visibility="public" package="java.io" serializable="true" superclassfulltype="java.io.ObjectStreamException" fulltype="java.io.WriteAbortedException" type="WriteAbortedException">
		<comment>
			<description>Signals that one of the ObjectStreamExceptions was thrown during a
 write operation.  Thrown during a read operation when one of the
 ObjectStreamExceptions was thrown during a write operation.  The
 exception that terminated the write can be found in the detail
 field. The stream is reset to it&apos;s initial state and all references
 to objects already deserialized are discarded.

 &lt;p&gt;As of release 1.4, this exception has been retrofitted to conform to
 the general purpose exception-chaining mechanism.  The &quot;exception causing
 the abort&quot; that is provided at construction time and
 accessed via the public {@link #detail} field is now known as the
 &lt;i&gt;cause&lt;/i&gt;, and may be accessed via the {@link Throwable#getCause()}
 method, as well as the aforementioned &quot;legacy field.&quot;</description>
			<attribute name="@author">
				<description>unascribed</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.1</description>
			</attribute>
		</comment>
		<fields>
			<field final="true" static="true" const="-3326426625597282442" visibility="private" name="serialVersionUID" constexpr="-3326426625597282442L" fulltype="long" type="long" />
			<field visibility="public" name="detail" fulltype="java.lang.Exception" type="Exception">
				<comment>
					<description>Exception that was caught while writing the ObjectStream.

 &lt;p&gt;This field predates the general-purpose exception chaining facility.
 The {@link Throwable#getCause()} method is now the preferred means of
 obtaining this information.</description>
					<attribute name="@serial" />
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="public" name="WriteAbortedException">
				<comment>
					<description>Constructs a WriteAbortedException with a string describing
 the exception and the exception causing the abort.</description>
					<attribute name="@param">
						<description>s   String describing the exception.</description>
					</attribute>
					<attribute name="@param">
						<description>ex  Exception causing the abort.</description>
					</attribute>
				</comment>
				<params>
					<param name="s" comment="String describing the exception." fulltype="java.lang.String" type="String" />
					<param name="ex" comment="Exception causing the abort." fulltype="java.lang.Exception" type="Exception" />
				</params>
			</constructor>
			<method visibility="public" name="getMessage" fulltype="java.lang.String" type="String">
				<comment>
					<description>Produce the message and include the message from the nested
 exception, if there is one.</description>
				</comment>
			</method>
			<method visibility="public" name="getCause" returncomment="the exception that terminated the operation (the &lt;i&gt;cause&lt;/i&gt;),
          which may be null." fulltype="java.lang.Throwable" type="Throwable">
				<comment>
					<description>Returns the exception that terminated the operation (the &lt;i&gt;cause&lt;/i&gt;).</description>
					<attribute name="@return">
						<description>the exception that terminated the operation (the &lt;i&gt;cause&lt;/i&gt;),
          which may be null.</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</method>
		</methods>
	</jelclass>
	<jelclass abstract="true" visibility="public" package="java.io" interface="true" fulltype="java.io.Flushable" type="Flushable">
		<comment>
			<description>A &lt;tt&gt;Flushable&lt;/tt&gt; is a destination of data that can be flushed.  The
 flush method is invoked to write any buffered output to the underlying
 stream.</description>
			<attribute name="@since">
				<description>1.5</description>
			</attribute>
		</comment>
		<methods>
			<method visibility="public" name="flush" fulltype="void" type="void">
				<comment>
					<description>Flushes this stream by writing any buffered output to the underlying
 stream.</description>
					<attribute name="@throws">
						<description>IOException If an I/O error occurs</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass abstract="true" superclass="Object" visibility="package-private" package="java.io" superclassfulltype="java.lang.Object" fulltype="java.io.FileSystem" type="FileSystem">
		<comment>
			<description>Package-private abstract class for the local filesystem abstraction.</description>
		</comment>
		<fields>
			<field final="true" static="true" const="1" visibility="public" name="BA_EXISTS" constexpr="1" fulltype="int" type="int" />
			<field final="true" static="true" const="2" visibility="public" name="BA_REGULAR" constexpr="2" fulltype="int" type="int" />
			<field final="true" static="true" const="4" visibility="public" name="BA_DIRECTORY" constexpr="4" fulltype="int" type="int" />
			<field final="true" static="true" const="8" visibility="public" name="BA_HIDDEN" constexpr="8" fulltype="int" type="int" />
			<field final="true" static="true" const="4" visibility="public" name="ACCESS_READ" constexpr="4" fulltype="int" type="int" />
			<field final="true" static="true" const="2" visibility="public" name="ACCESS_WRITE" constexpr="2" fulltype="int" type="int" />
			<field final="true" static="true" const="1" visibility="public" name="ACCESS_EXECUTE" constexpr="1" fulltype="int" type="int" />
			<field final="true" static="true" const="0" visibility="public" name="SPACE_TOTAL" constexpr="0" fulltype="int" type="int" />
			<field final="true" static="true" const="1" visibility="public" name="SPACE_FREE" constexpr="1" fulltype="int" type="int" />
			<field final="true" static="true" const="2" visibility="public" name="SPACE_USABLE" constexpr="2" fulltype="int" type="int" />
			<field static="true" visibility="package-private" name="useCanonCaches" fulltype="boolean" type="boolean" />
			<field static="true" visibility="package-private" name="useCanonPrefixCache" fulltype="boolean" type="boolean" />
		</fields>
		<methods>
			<constructor visibility="package-private" name="FileSystem" />
			<method static="true" visibility="public" name="getFileSystem" fulltype="java.io.FileSystem" type="FileSystem">
				<comment>
					<description>Return the FileSystem object representing this platform&apos;s local
 filesystem.</description>
				</comment>
			</method>
			<method abstract="true" visibility="public" name="getSeparator" fulltype="char" type="char">
				<comment>
					<description>Return the local filesystem&apos;s name-separator character.</description>
				</comment>
			</method>
			<method abstract="true" visibility="public" name="getPathSeparator" fulltype="char" type="char">
				<comment>
					<description>Return the local filesystem&apos;s path-separator character.</description>
				</comment>
			</method>
			<method abstract="true" visibility="public" name="normalize" fulltype="java.lang.String" type="String">
				<comment>
					<description>Convert the given pathname string to normal form.  If the string is
 already in normal form then it is simply returned.</description>
				</comment>
				<params>
					<param name="path" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method abstract="true" visibility="public" name="prefixLength" fulltype="int" type="int">
				<comment>
					<description>Compute the length of this pathname string&apos;s prefix.  The pathname
 string must be in normal form.</description>
				</comment>
				<params>
					<param name="path" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method abstract="true" visibility="public" name="resolve" fulltype="java.lang.String" type="String">
				<comment>
					<description>Resolve the child pathname string against the parent.
 Both strings must be in normal form, and the result
 will be in normal form.</description>
				</comment>
				<params>
					<param name="parent" fulltype="java.lang.String" type="String" />
					<param name="child" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method abstract="true" visibility="public" name="getDefaultParent" fulltype="java.lang.String" type="String">
				<comment>
					<description>Return the parent pathname string to be used when the parent-directory
 argument in one of the two-argument File constructors is the empty
 pathname.</description>
				</comment>
			</method>
			<method abstract="true" visibility="public" name="fromURIPath" fulltype="java.lang.String" type="String">
				<comment>
					<description>Post-process the given URI path string if necessary.  This is used on
 win32, e.g., to transform &quot;/c:/foo&quot; into &quot;c:/foo&quot;.  The path string
 still has slash separators; code in the File class will translate them
 after this method returns.</description>
				</comment>
				<params>
					<param name="path" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method abstract="true" visibility="public" name="isAbsolute" fulltype="boolean" type="boolean">
				<comment>
					<description>Tell whether or not the given abstract pathname is absolute.</description>
				</comment>
				<params>
					<param name="f" fulltype="java.io.File" type="File" />
				</params>
			</method>
			<method abstract="true" visibility="public" name="resolve" fulltype="java.lang.String" type="String">
				<comment>
					<description>Resolve the given abstract pathname into absolute form.  Invoked by the
 getAbsolutePath and getCanonicalPath methods in the File class.</description>
				</comment>
				<params>
					<param name="f" fulltype="java.io.File" type="File" />
				</params>
			</method>
			<method abstract="true" visibility="public" name="canonicalize" fulltype="java.lang.String" type="String">
				<params>
					<param name="path" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="public" name="getBooleanAttributes" fulltype="int" type="int">
				<comment>
					<description>Return the simple boolean attributes for the file or directory denoted
 by the given abstract pathname, or zero if it does not exist or some
 other I/O error occurs.</description>
				</comment>
				<params>
					<param name="f" fulltype="java.io.File" type="File" />
				</params>
			</method>
			<method abstract="true" visibility="public" name="checkAccess" fulltype="boolean" type="boolean">
				<comment>
					<description>Check whether the file or directory denoted by the given abstract
 pathname may be accessed by this process.  The second argument specifies
 which access, ACCESS_READ, ACCESS_WRITE or ACCESS_EXECUTE, to check.
 Return false if access is denied or an I/O error occurs</description>
				</comment>
				<params>
					<param name="f" fulltype="java.io.File" type="File" />
					<param name="access" fulltype="int" type="int" />
				</params>
			</method>
			<method abstract="true" visibility="public" name="setPermission" fulltype="boolean" type="boolean">
				<comment>
					<description>Set on or off the access permission (to owner only or to all) to the file
 or directory denoted by the given abstract pathname, based on the parameters
 enable, access and oweronly.</description>
				</comment>
				<params>
					<param name="f" fulltype="java.io.File" type="File" />
					<param name="access" fulltype="int" type="int" />
					<param name="enable" fulltype="boolean" type="boolean" />
					<param name="owneronly" fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method abstract="true" visibility="public" name="getLastModifiedTime" fulltype="long" type="long">
				<comment>
					<description>Return the time at which the file or directory denoted by the given
 abstract pathname was last modified, or zero if it does not exist or
 some other I/O error occurs.</description>
				</comment>
				<params>
					<param name="f" fulltype="java.io.File" type="File" />
				</params>
			</method>
			<method abstract="true" visibility="public" name="getLength" fulltype="long" type="long">
				<comment>
					<description>Return the length in bytes of the file denoted by the given abstract
 pathname, or zero if it does not exist, is a directory, or some other
 I/O error occurs.</description>
				</comment>
				<params>
					<param name="f" fulltype="java.io.File" type="File" />
				</params>
			</method>
			<method abstract="true" visibility="public" name="createFileExclusively" fulltype="boolean" type="boolean">
				<comment>
					<description>Create a new empty file with the given pathname.  Return
 &lt;code&gt;true&lt;/code&gt; if the file was created and &lt;code&gt;false&lt;/code&gt; if a
 file or directory with the given pathname already exists.  Throw an
 IOException if an I/O error occurs.</description>
				</comment>
				<params>
					<param name="pathname" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="public" name="delete" fulltype="boolean" type="boolean">
				<comment>
					<description>Delete the file or directory denoted by the given abstract pathname,
 returning &lt;code&gt;true&lt;/code&gt; if and only if the operation succeeds.</description>
				</comment>
				<params>
					<param name="f" fulltype="java.io.File" type="File" />
				</params>
			</method>
			<method abstract="true" visibility="public" name="list" fulltype="java.lang.String[]" type="String">
				<comment>
					<description>List the elements of the directory denoted by the given abstract
 pathname.  Return an array of strings naming the elements of the
 directory if successful; otherwise, return &lt;code&gt;null&lt;/code&gt;.</description>
				</comment>
				<params>
					<param name="f" fulltype="java.io.File" type="File" />
				</params>
			</method>
			<method abstract="true" visibility="public" name="createDirectory" fulltype="boolean" type="boolean">
				<comment>
					<description>Create a new directory denoted by the given abstract pathname,
 returning &lt;code&gt;true&lt;/code&gt; if and only if the operation succeeds.</description>
				</comment>
				<params>
					<param name="f" fulltype="java.io.File" type="File" />
				</params>
			</method>
			<method abstract="true" visibility="public" name="rename" fulltype="boolean" type="boolean">
				<comment>
					<description>Rename the file or directory denoted by the first abstract pathname to
 the second abstract pathname, returning &lt;code&gt;true&lt;/code&gt; if and only if
 the operation succeeds.</description>
				</comment>
				<params>
					<param name="f1" fulltype="java.io.File" type="File" />
					<param name="f2" fulltype="java.io.File" type="File" />
				</params>
			</method>
			<method abstract="true" visibility="public" name="setLastModifiedTime" fulltype="boolean" type="boolean">
				<comment>
					<description>Set the last-modified time of the file or directory denoted by the
 given abstract pathname, returning &lt;code&gt;true&lt;/code&gt; if and only if the
 operation succeeds.</description>
				</comment>
				<params>
					<param name="f" fulltype="java.io.File" type="File" />
					<param name="time" fulltype="long" type="long" />
				</params>
			</method>
			<method abstract="true" visibility="public" name="setReadOnly" fulltype="boolean" type="boolean">
				<comment>
					<description>Mark the file or directory denoted by the given abstract pathname as
 read-only, returning &lt;code&gt;true&lt;/code&gt; if and only if the operation
 succeeds.</description>
				</comment>
				<params>
					<param name="f" fulltype="java.io.File" type="File" />
				</params>
			</method>
			<method abstract="true" visibility="public" name="listRoots" fulltype="java.io.File[]" type="File">
				<comment>
					<description>List the available filesystem roots.</description>
				</comment>
			</method>
			<method abstract="true" visibility="public" name="getSpace" fulltype="long" type="long">
				<params>
					<param name="f" fulltype="java.io.File" type="File" />
					<param name="t" fulltype="int" type="int" />
				</params>
			</method>
			<method abstract="true" visibility="public" name="compare" fulltype="int" type="int">
				<comment>
					<description>Compare two abstract pathnames lexicographically.</description>
				</comment>
				<params>
					<param name="f1" fulltype="java.io.File" type="File" />
					<param name="f2" fulltype="java.io.File" type="File" />
				</params>
			</method>
			<method abstract="true" visibility="public" name="hashCode" fulltype="int" type="int">
				<comment>
					<description>Compute the hash code of an abstract pathname.</description>
				</comment>
				<params>
					<param name="f" fulltype="java.io.File" type="File" />
				</params>
			</method>
			<method static="true" visibility="private" name="getBooleanProperty" fulltype="boolean" type="boolean">
				<params>
					<param name="prop" fulltype="java.lang.String" type="String" />
					<param name="defaultVal" fulltype="boolean" type="boolean" />
				</params>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="Exception" visibility="public" package="java.io" serializable="true" superclassfulltype="java.lang.Exception" fulltype="java.io.IOException" type="IOException">
		<comment>
			<description>Signals that an I/O exception of some sort has occurred. This
 class is the general class of exceptions produced by failed or
 interrupted I/O operations.</description>
			<attribute name="@author">
				<description>unascribed</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.InputStream</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.OutputStream</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.0</description>
			</attribute>
		</comment>
		<fields>
			<field final="true" static="true" const="7818375828146090155" visibility="package-private" name="serialVersionUID" constexpr="7818375828146090155L" fulltype="long" type="long" />
		</fields>
		<methods>
			<constructor visibility="public" name="IOException">
				<comment>
					<description>Constructs an {@code IOException} with {@code null}
 as its error detail message.</description>
				</comment>
			</constructor>
			<constructor visibility="public" name="IOException">
				<comment>
					<description>Constructs an {@code IOException} with the specified detail message.</description>
					<attribute name="@param">
						<description>message
        The detail message (which is saved for later retrieval
        by the {@link #getMessage()} method)</description>
					</attribute>
				</comment>
				<params>
					<param name="message" comment="The detail message (which is saved for later retrieval
        by the {@link #getMessage()} method)" fulltype="java.lang.String" type="String" />
				</params>
			</constructor>
			<constructor visibility="public" name="IOException">
				<comment>
					<description>Constructs an {@code IOException} with the specified detail message
 and cause.

 &lt;p&gt; Note that the detail message associated with {@code cause} is
 &lt;i&gt;not&lt;/i&gt; automatically incorporated into this exception&apos;s detail
 message.</description>
					<attribute name="@param">
						<description>message
        The detail message (which is saved for later retrieval
        by the {@link #getMessage()} method)</description>
					</attribute>
					<attribute name="@param">
						<description>cause
        The cause (which is saved for later retrieval by the
        {@link #getCause()} method).  (A null value is permitted,
        and indicates that the cause is nonexistent or unknown.)</description>
					</attribute>
					<attribute name="@since">
						<description>1.6</description>
					</attribute>
				</comment>
				<params>
					<param name="message" comment="The detail message (which is saved for later retrieval
        by the {@link #getMessage()} method)" fulltype="java.lang.String" type="String" />
					<param name="cause" comment="The cause (which is saved for later retrieval by the
        {@link #getCause()} method).  (A null value is permitted,
        and indicates that the cause is nonexistent or unknown.)" fulltype="java.lang.Throwable" type="Throwable" />
				</params>
			</constructor>
			<constructor visibility="public" name="IOException">
				<comment>
					<description>Constructs an {@code IOException} with the specified cause and a
 detail message of {@code (cause==null ? null : cause.toString())}
 (which typically contains the class and detail message of {@code cause}).
 This constructor is useful for IO exceptions that are little more
 than wrappers for other throwables.</description>
					<attribute name="@param">
						<description>cause
        The cause (which is saved for later retrieval by the
        {@link #getCause()} method).  (A null value is permitted,
        and indicates that the cause is nonexistent or unknown.)</description>
					</attribute>
					<attribute name="@since">
						<description>1.6</description>
					</attribute>
				</comment>
				<params>
					<param name="cause" comment="The cause (which is saved for later retrieval by the
        {@link #getCause()} method).  (A null value is permitted,
        and indicates that the cause is nonexistent or unknown.)" fulltype="java.lang.Throwable" type="Throwable" />
				</params>
			</constructor>
		</methods>
	</jelclass>
	<jelclass abstract="true" superclass="Writer" visibility="public" package="java.io" superclassfulltype="java.io.Writer" fulltype="java.io.FilterWriter" type="FilterWriter">
		<comment>
			<description>Abstract class for writing filtered character streams.
 The abstract class &lt;code&gt;FilterWriter&lt;/code&gt; itself
 provides default methods that pass all requests to the
 contained stream. Subclasses of &lt;code&gt;FilterWriter&lt;/code&gt;
 should override some of these methods and may also
 provide additional methods and fields.</description>
			<attribute name="@author">
				<description>Mark Reinhold</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.1</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="protected" name="out" fulltype="java.io.Writer" type="Writer">
				<comment>
					<description>The underlying character-output stream.</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="protected" name="FilterWriter">
				<comment>
					<description>Create a new filtered writer.</description>
					<attribute name="@param">
						<description>out  a Writer object to provide the underlying stream.</description>
					</attribute>
					<attribute name="@throws">
						<description>NullPointerException if &lt;code&gt;out&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</description>
					</attribute>
				</comment>
				<params>
					<param name="out" comment="a Writer object to provide the underlying stream." fulltype="java.io.Writer" type="Writer" />
				</params>
			</constructor>
			<method visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes a single character.</description>
					<attribute name="@exception">
						<description>IOException  If an I/O error occurs</description>
					</attribute>
				</comment>
				<params>
					<param name="c" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes a portion of an array of characters.</description>
					<attribute name="@param">
						<description>cbuf  Buffer of characters to be written</description>
					</attribute>
					<attribute name="@param">
						<description>off   Offset from which to start reading characters</description>
					</attribute>
					<attribute name="@param">
						<description>len   Number of characters to be written</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  If an I/O error occurs</description>
					</attribute>
				</comment>
				<params>
					<param name="cbuf" comment="Buffer of characters to be written" fulltype="char[]" type="char" />
					<param name="off" comment="Offset from which to start reading characters" fulltype="int" type="int" />
					<param name="len" comment="Number of characters to be written" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes a portion of a string.</description>
					<attribute name="@param">
						<description>str  String to be written</description>
					</attribute>
					<attribute name="@param">
						<description>off  Offset from which to start reading characters</description>
					</attribute>
					<attribute name="@param">
						<description>len  Number of characters to be written</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  If an I/O error occurs</description>
					</attribute>
				</comment>
				<params>
					<param name="str" comment="String to be written" fulltype="java.lang.String" type="String" />
					<param name="off" comment="Offset from which to start reading characters" fulltype="int" type="int" />
					<param name="len" comment="Number of characters to be written" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="flush" fulltype="void" type="void">
				<comment>
					<description>Flushes the stream.</description>
					<attribute name="@exception">
						<description>IOException  If an I/O error occurs</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="close" fulltype="void" type="void">
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="IOException" visibility="public" package="java.io" serializable="true" superclassfulltype="java.io.IOException" fulltype="java.io.InterruptedIOException" type="InterruptedIOException">
		<comment>
			<description>Signals that an I/O operation has been interrupted. An
 &lt;code&gt;InterruptedIOException&lt;/code&gt; is thrown to indicate that an
 input or output transfer has been terminated because the thread
 performing it was interrupted. The field {@link #bytesTransferred}
 indicates how many bytes were successfully transferred before
 the interruption occurred.</description>
			<attribute name="@author">
				<description>unascribed</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.InputStream</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.OutputStream</description>
			</attribute>
			<attribute name="@see">
				<description>java.lang.Thread#interrupt()</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.0</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="public" name="bytesTransferred" fulltype="int" type="int">
				<comment>
					<description>Reports how many bytes had been transferred as part of the I/O
 operation before it was interrupted.</description>
					<attribute name="@serial" />
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="public" name="InterruptedIOException">
				<comment>
					<description>Constructs an &lt;code&gt;InterruptedIOException&lt;/code&gt; with
 &lt;code&gt;null&lt;/code&gt; as its error detail message.</description>
				</comment>
			</constructor>
			<constructor visibility="public" name="InterruptedIOException">
				<comment>
					<description>Constructs an &lt;code&gt;InterruptedIOException&lt;/code&gt; with the
 specified detail message. The string &lt;code&gt;s&lt;/code&gt; can be
 retrieved later by the
 &lt;code&gt;{@link java.lang.Throwable#getMessage}&lt;/code&gt;
 method of class &lt;code&gt;java.lang.Throwable&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>s   the detail message.</description>
					</attribute>
				</comment>
				<params>
					<param name="s" comment="the detail message." fulltype="java.lang.String" type="String" />
				</params>
			</constructor>
		</methods>
	</jelclass>
	<jelclass superclass="IOException" visibility="public" package="java.io" serializable="true" superclassfulltype="java.io.IOException" fulltype="java.io.SyncFailedException" type="SyncFailedException">
		<comment>
			<description>Signals that a sync operation has failed.</description>
			<attribute name="@author">
				<description>Ken Arnold</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.FileDescriptor#sync</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.IOException</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.1</description>
			</attribute>
		</comment>
		<methods>
			<constructor visibility="public" name="SyncFailedException">
				<comment>
					<description>Constructs an SyncFailedException with a detail message.
 A detail message is a String that describes this particular exception.</description>
					<attribute name="@param">
						<description>desc  a String describing the exception.</description>
					</attribute>
				</comment>
				<params>
					<param name="desc" comment="a String describing the exception." fulltype="java.lang.String" type="String" />
				</params>
			</constructor>
		</methods>
	</jelclass>
	<jelclass superclass="InputStream" visibility="public" package="java.io" superclassfulltype="java.io.InputStream" fulltype="java.io.ByteArrayInputStream" type="ByteArrayInputStream">
		<comment>
			<description>A &lt;code&gt;ByteArrayInputStream&lt;/code&gt; contains
 an internal buffer that contains bytes that
 may be read from the stream. An internal
 counter keeps track of the next byte to
 be supplied by the &lt;code&gt;read&lt;/code&gt; method.
 &lt;p&gt;
 Closing a &lt;tt&gt;ByteArrayInputStream&lt;/tt&gt; has no effect. The methods in
 this class can be called after the stream has been closed without
 generating an &lt;tt&gt;IOException&lt;/tt&gt;.</description>
			<attribute name="@author">
				<description>Arthur van Hoff</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.StringBufferInputStream</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.0</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="protected" name="buf" fulltype="byte[]" type="byte">
				<comment>
					<description>An array of bytes that was provided
 by the creator of the stream. Elements &lt;code&gt;buf[0]&lt;/code&gt;
 through &lt;code&gt;buf[count-1]&lt;/code&gt; are the
 only bytes that can ever be read from the
 stream;  element &lt;code&gt;buf[pos]&lt;/code&gt; is
 the next byte to be read.</description>
				</comment>
			</field>
			<field visibility="protected" name="pos" fulltype="int" type="int">
				<comment>
					<description>The index of the next character to read from the input stream buffer.
 This value should always be nonnegative
 and not larger than the value of &lt;code&gt;count&lt;/code&gt;.
 The next byte to be read from the input stream buffer
 will be &lt;code&gt;buf[pos]&lt;/code&gt;.</description>
				</comment>
			</field>
			<field visibility="protected" name="mark" fulltype="int" type="int">
				<comment>
					<description>The currently marked position in the stream.
 ByteArrayInputStream objects are marked at position zero by
 default when constructed.  They may be marked at another
 position within the buffer by the &lt;code&gt;mark()&lt;/code&gt; method.
 The current buffer position is set to this point by the
 &lt;code&gt;reset()&lt;/code&gt; method.
 &lt;p&gt;
 If no mark has been set, then the value of mark is the offset
 passed to the constructor (or 0 if the offset was not supplied).</description>
					<attribute name="@since">
						<description>JDK1.1</description>
					</attribute>
				</comment>
			</field>
			<field visibility="protected" name="count" fulltype="int" type="int">
				<comment>
					<description>The index one greater than the last valid character in the input
 stream buffer.
 This value should always be nonnegative
 and not larger than the length of &lt;code&gt;buf&lt;/code&gt;.
 It  is one greater than the position of
 the last byte within &lt;code&gt;buf&lt;/code&gt; that
 can ever be read  from the input stream buffer.</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="public" name="ByteArrayInputStream">
				<comment>
					<description>Creates a &lt;code&gt;ByteArrayInputStream&lt;/code&gt;
 so that it  uses &lt;code&gt;buf&lt;/code&gt; as its
 buffer array.
 The buffer array is not copied.
 The initial value of &lt;code&gt;pos&lt;/code&gt;
 is &lt;code&gt;0&lt;/code&gt; and the initial value
 of  &lt;code&gt;count&lt;/code&gt; is the length of
 &lt;code&gt;buf&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>buf   the input buffer.</description>
					</attribute>
				</comment>
				<params>
					<param name="buf" comment="the input buffer." fulltype="byte[]" type="byte" />
				</params>
			</constructor>
			<constructor visibility="public" name="ByteArrayInputStream">
				<comment>
					<description>Creates &lt;code&gt;ByteArrayInputStream&lt;/code&gt;
 that uses &lt;code&gt;buf&lt;/code&gt; as its
 buffer array. The initial value of &lt;code&gt;pos&lt;/code&gt;
 is &lt;code&gt;offset&lt;/code&gt; and the initial value
 of &lt;code&gt;count&lt;/code&gt; is the minimum of &lt;code&gt;offset+length&lt;/code&gt;
 and &lt;code&gt;buf.length&lt;/code&gt;.
 The buffer array is not copied. The buffer&apos;s mark is
 set to the specified offset.</description>
					<attribute name="@param">
						<description>buf      the input buffer.</description>
					</attribute>
					<attribute name="@param">
						<description>offset   the offset in the buffer of the first byte to read.</description>
					</attribute>
					<attribute name="@param">
						<description>length   the maximum number of bytes to read from the buffer.</description>
					</attribute>
				</comment>
				<params>
					<param name="buf" comment="the input buffer." fulltype="byte[]" type="byte" />
					<param name="offset" comment="the offset in the buffer of the first byte to read." fulltype="int" type="int" />
					<param name="length" comment="the maximum number of bytes to read from the buffer." fulltype="int" type="int" />
				</params>
			</constructor>
			<method synchronized="true" visibility="public" name="read" returncomment="the next byte of data, or &lt;code&gt;-1&lt;/code&gt; if the end of the
          stream has been reached." fulltype="int" type="int">
				<comment>
					<description>Reads the next byte of data from this input stream. The value
 byte is returned as an &lt;code&gt;int&lt;/code&gt; in the range
 &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;255&lt;/code&gt;. If no byte is available
 because the end of the stream has been reached, the value
 &lt;code&gt;-1&lt;/code&gt; is returned.
 &lt;p&gt;
 This &lt;code&gt;read&lt;/code&gt; method
 cannot block.</description>
					<attribute name="@return">
						<description>the next byte of data, or &lt;code&gt;-1&lt;/code&gt; if the end of the
          stream has been reached.</description>
					</attribute>
				</comment>
			</method>
			<method synchronized="true" visibility="public" name="read" returncomment="the total number of bytes read into the buffer, or
          &lt;code&gt;-1&lt;/code&gt; if there is no more data because the end of
          the stream has been reached." fulltype="int" type="int">
				<comment>
					<description>Reads up to &lt;code&gt;len&lt;/code&gt; bytes of data into an array of bytes
 from this input stream.
 If &lt;code&gt;pos&lt;/code&gt; equals &lt;code&gt;count&lt;/code&gt;,
 then &lt;code&gt;-1&lt;/code&gt; is returned to indicate
 end of file. Otherwise, the  number &lt;code&gt;k&lt;/code&gt;
 of bytes read is equal to the smaller of
 &lt;code&gt;len&lt;/code&gt; and &lt;code&gt;count-pos&lt;/code&gt;.
 If &lt;code&gt;k&lt;/code&gt; is positive, then bytes
 &lt;code&gt;buf[pos]&lt;/code&gt; through &lt;code&gt;buf[pos+k-1]&lt;/code&gt;
 are copied into &lt;code&gt;b[off]&lt;/code&gt;  through
 &lt;code&gt;b[off+k-1]&lt;/code&gt; in the manner performed
 by &lt;code&gt;System.arraycopy&lt;/code&gt;. The
 value &lt;code&gt;k&lt;/code&gt; is added into &lt;code&gt;pos&lt;/code&gt;
 and &lt;code&gt;k&lt;/code&gt; is returned.
 &lt;p&gt;
 This &lt;code&gt;read&lt;/code&gt; method cannot block.</description>
					<attribute name="@param">
						<description>b     the buffer into which the data is read.</description>
					</attribute>
					<attribute name="@param">
						<description>off   the start offset in the destination array &lt;code&gt;b&lt;/code&gt;</description>
					</attribute>
					<attribute name="@param">
						<description>len   the maximum number of bytes read.</description>
					</attribute>
					<attribute name="@return">
						<description>the total number of bytes read into the buffer, or
          &lt;code&gt;-1&lt;/code&gt; if there is no more data because the end of
          the stream has been reached.</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException If &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.</description>
					</attribute>
					<attribute name="@exception">
						<description>IndexOutOfBoundsException If &lt;code&gt;off&lt;/code&gt; is negative,
 &lt;code&gt;len&lt;/code&gt; is negative, or &lt;code&gt;len&lt;/code&gt; is greater than
 &lt;code&gt;b.length - off&lt;/code&gt;</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the buffer into which the data is read." fulltype="byte[]" type="byte" />
					<param name="off" comment="the start offset in the destination array &lt;code&gt;b&lt;/code&gt;" fulltype="int" type="int" />
					<param name="len" comment="the maximum number of bytes read." fulltype="int" type="int" />
				</params>
			</method>
			<method synchronized="true" visibility="public" name="skip" returncomment="the actual number of bytes skipped." fulltype="long" type="long">
				<comment>
					<description>Skips &lt;code&gt;n&lt;/code&gt; bytes of input from this input stream. Fewer
 bytes might be skipped if the end of the input stream is reached.
 The actual number &lt;code&gt;k&lt;/code&gt;
 of bytes to be skipped is equal to the smaller
 of &lt;code&gt;n&lt;/code&gt; and  &lt;code&gt;count-pos&lt;/code&gt;.
 The value &lt;code&gt;k&lt;/code&gt; is added into &lt;code&gt;pos&lt;/code&gt;
 and &lt;code&gt;k&lt;/code&gt; is returned.</description>
					<attribute name="@param">
						<description>n   the number of bytes to be skipped.</description>
					</attribute>
					<attribute name="@return">
						<description>the actual number of bytes skipped.</description>
					</attribute>
				</comment>
				<params>
					<param name="n" comment="the number of bytes to be skipped." fulltype="long" type="long" />
				</params>
			</method>
			<method synchronized="true" visibility="public" name="available" returncomment="the number of remaining bytes that can be read (or skipped
          over) from this input stream without blocking." fulltype="int" type="int">
				<comment>
					<description>Returns the number of remaining bytes that can be read (or skipped over)
 from this input stream.
 &lt;p&gt;
 The value returned is &lt;code&gt;count&amp;nbsp;- pos&lt;/code&gt;,
 which is the number of bytes remaining to be read from the input buffer.</description>
					<attribute name="@return">
						<description>the number of remaining bytes that can be read (or skipped
          over) from this input stream without blocking.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="markSupported" fulltype="boolean" type="boolean">
				<comment>
					<description>Tests if this &lt;code&gt;InputStream&lt;/code&gt; supports mark/reset. The
 &lt;code&gt;markSupported&lt;/code&gt; method of &lt;code&gt;ByteArrayInputStream&lt;/code&gt;
 always returns &lt;code&gt;true&lt;/code&gt;.</description>
					<attribute name="@since">
						<description>JDK1.1</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="mark" fulltype="void" type="void">
				<comment>
					<description>Set the current marked position in the stream.
 ByteArrayInputStream objects are marked at position zero by
 default when constructed.  They may be marked at another
 position within the buffer by this method.
 &lt;p&gt;
 If no mark has been set, then the value of the mark is the
 offset passed to the constructor (or 0 if the offset was not
 supplied).

 &lt;p&gt; Note: The &lt;code&gt;readAheadLimit&lt;/code&gt; for this class
  has no meaning.</description>
					<attribute name="@since">
						<description>JDK1.1</description>
					</attribute>
				</comment>
				<params>
					<param name="readAheadLimit" fulltype="int" type="int" />
				</params>
			</method>
			<method synchronized="true" visibility="public" name="reset" fulltype="void" type="void">
				<comment>
					<description>Resets the buffer to the marked position.  The marked position
 is 0 unless another position was marked or an offset was specified
 in the constructor.</description>
				</comment>
			</method>
			<method visibility="public" name="close" fulltype="void" type="void">
				<comment>
					<description>Closing a &lt;tt&gt;ByteArrayInputStream&lt;/tt&gt; has no effect. The methods in
 this class can be called after the stream has been closed without
 generating an &lt;tt&gt;IOException&lt;/tt&gt;.
 &lt;p&gt;</description>
				</comment>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="Error" visibility="public" package="java.io" serializable="true" superclassfulltype="java.lang.Error" fulltype="java.io.IOError" type="IOError">
		<comment>
			<description>Thrown when a serious I/O error has occurred.</description>
			<attribute name="@author">
				<description>Xueming Shen</description>
			</attribute>
			<attribute name="@since">
				<description>1.6</description>
			</attribute>
		</comment>
		<fields>
			<field final="true" static="true" const="67100927991680413" visibility="private" name="serialVersionUID" constexpr="67100927991680413L" fulltype="long" type="long" />
		</fields>
		<methods>
			<constructor visibility="public" name="IOError">
				<comment>
					<description>Constructs a new instance of IOError with the specified cause. The
 IOError is created with the detail message of
 &lt;tt&gt;(cause==null ? null : cause.toString())&lt;/tt&gt; (which typically
 contains the class and detail message of cause).</description>
					<attribute name="@param">
						<description>cause
         The cause of this error, or &lt;tt&gt;null&lt;/tt&gt; if the cause
         is not known</description>
					</attribute>
				</comment>
				<params>
					<param name="cause" comment="The cause of this error, or &lt;tt&gt;null&lt;/tt&gt; if the cause
         is not known" fulltype="java.lang.Throwable" type="Throwable" />
				</params>
			</constructor>
		</methods>
	</jelclass>
	<jelclass abstract="true" visibility="public" package="java.io" interface="true" fulltype="java.io.DataOutput" type="DataOutput">
		<comment>
			<description>The &lt;code&gt;DataOutput&lt;/code&gt; interface provides
 for converting data from any of the Java
 primitive types to a series of bytes and
 writing these bytes to a binary stream.
 There is  also a facility for converting
 a &lt;code&gt;String&lt;/code&gt; into
 &lt;a href=&quot;DataInput.html#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt;
 format and writing the resulting series
 of bytes.
 &lt;p&gt;
 For all the methods in this interface that
 write bytes, it is generally true that if
 a byte cannot be written for any reason,
 an &lt;code&gt;IOException&lt;/code&gt; is thrown.</description>
			<attribute name="@author">
				<description>Frank Yellin</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.DataInput</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.DataOutputStream</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.0</description>
			</attribute>
		</comment>
		<methods>
			<method visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes to the output stream the eight
 low-order bits of the argument &lt;code&gt;b&lt;/code&gt;.
 The 24 high-order  bits of &lt;code&gt;b&lt;/code&gt;
 are ignored.</description>
					<attribute name="@param">
						<description>b   the byte to be written.</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the byte to be written." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes to the output stream all the bytes in array &lt;code&gt;b&lt;/code&gt;.
 If &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
 a &lt;code&gt;NullPointerException&lt;/code&gt; is thrown.
 If &lt;code&gt;b.length&lt;/code&gt; is zero, then
 no bytes are written. Otherwise, the byte
 &lt;code&gt;b[0]&lt;/code&gt; is written first, then
 &lt;code&gt;b[1]&lt;/code&gt;, and so on; the last byte
 written is &lt;code&gt;b[b.length-1]&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>b   the data.</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the data." fulltype="byte[]" type="byte" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes &lt;code&gt;len&lt;/code&gt; bytes from array
 &lt;code&gt;b&lt;/code&gt;, in order,  to
 the output stream.  If &lt;code&gt;b&lt;/code&gt;
 is &lt;code&gt;null&lt;/code&gt;, a &lt;code&gt;NullPointerException&lt;/code&gt;
 is thrown.  If &lt;code&gt;off&lt;/code&gt; is negative,
 or &lt;code&gt;len&lt;/code&gt; is negative, or &lt;code&gt;off+len&lt;/code&gt;
 is greater than the length of the array
 &lt;code&gt;b&lt;/code&gt;, then an &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt;
 is thrown.  If &lt;code&gt;len&lt;/code&gt; is zero,
 then no bytes are written. Otherwise, the
 byte &lt;code&gt;b[off]&lt;/code&gt; is written first,
 then &lt;code&gt;b[off+1]&lt;/code&gt;, and so on; the
 last byte written is &lt;code&gt;b[off+len-1]&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>b     the data.</description>
					</attribute>
					<attribute name="@param">
						<description>off   the start offset in the data.</description>
					</attribute>
					<attribute name="@param">
						<description>len   the number of bytes to write.</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the data." fulltype="byte[]" type="byte" />
					<param name="off" comment="the start offset in the data." fulltype="int" type="int" />
					<param name="len" comment="the number of bytes to write." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="writeBoolean" fulltype="void" type="void">
				<comment>
					<description>Writes a &lt;code&gt;boolean&lt;/code&gt; value to this output stream.
 If the argument &lt;code&gt;v&lt;/code&gt;
 is &lt;code&gt;true&lt;/code&gt;, the value &lt;code&gt;(byte)1&lt;/code&gt;
 is written; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;,
 the  value &lt;code&gt;(byte)0&lt;/code&gt; is written.
 The byte written by this method may
 be read by the &lt;code&gt;readBoolean&lt;/code&gt;
 method of interface &lt;code&gt;DataInput&lt;/code&gt;,
 which will then return a &lt;code&gt;boolean&lt;/code&gt;
 equal to &lt;code&gt;v&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>v   the boolean to be written.</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="v" comment="the boolean to be written." fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="writeByte" fulltype="void" type="void">
				<comment>
					<description>Writes to the output stream the eight low-
 order bits of the argument &lt;code&gt;v&lt;/code&gt;.
 The 24 high-order bits of &lt;code&gt;v&lt;/code&gt;
 are ignored. (This means  that &lt;code&gt;writeByte&lt;/code&gt;
 does exactly the same thing as &lt;code&gt;write&lt;/code&gt;
 for an integer argument.) The byte written
 by this method may be read by the &lt;code&gt;readByte&lt;/code&gt;
 method of interface &lt;code&gt;DataInput&lt;/code&gt;,
 which will then return a &lt;code&gt;byte&lt;/code&gt;
 equal to &lt;code&gt;(byte)v&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>v   the byte value to be written.</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="v" comment="the byte value to be written." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="writeShort" fulltype="void" type="void">
				<comment>
					<description>Writes two bytes to the output
 stream to represent the value of the argument.
 The byte values to be written, in the  order
 shown, are: &lt;p&gt;
 &lt;pre&gt;&lt;code&gt;
 (byte)(0xff &amp;amp; (v &amp;gt;&amp;gt; 8))
 (byte)(0xff &amp;amp; v)
 &lt;/code&gt; &lt;/pre&gt; &lt;p&gt;
 The bytes written by this method may be
 read by the &lt;code&gt;readShort&lt;/code&gt; method
 of interface &lt;code&gt;DataInput&lt;/code&gt; , which
 will then return a &lt;code&gt;short&lt;/code&gt; equal
 to &lt;code&gt;(short)v&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>v   the &lt;code&gt;short&lt;/code&gt; value to be written.</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="v" comment="the &lt;code&gt;short&lt;/code&gt; value to be written." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="writeChar" fulltype="void" type="void">
				<comment>
					<description>Writes a &lt;code&gt;char&lt;/code&gt; value, which
 is comprised of two bytes, to the
 output stream.
 The byte values to be written, in the  order
 shown, are:
 &lt;p&gt;&lt;pre&gt;&lt;code&gt;
 (byte)(0xff &amp;amp; (v &amp;gt;&amp;gt; 8))
 (byte)(0xff &amp;amp; v)
 &lt;/code&gt;&lt;/pre&gt;&lt;p&gt;
 The bytes written by this method may be
 read by the &lt;code&gt;readChar&lt;/code&gt; method
 of interface &lt;code&gt;DataInput&lt;/code&gt; , which
 will then return a &lt;code&gt;char&lt;/code&gt; equal
 to &lt;code&gt;(char)v&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>v   the &lt;code&gt;char&lt;/code&gt; value to be written.</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="v" comment="the &lt;code&gt;char&lt;/code&gt; value to be written." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="writeInt" fulltype="void" type="void">
				<comment>
					<description>Writes an &lt;code&gt;int&lt;/code&gt; value, which is
 comprised of four bytes, to the output stream.
 The byte values to be written, in the  order
 shown, are:
 &lt;p&gt;&lt;pre&gt;&lt;code&gt;
 (byte)(0xff &amp;amp; (v &amp;gt;&amp;gt; 24))
 (byte)(0xff &amp;amp; (v &amp;gt;&amp;gt; 16))
 (byte)(0xff &amp;amp; (v &amp;gt;&amp;gt; &amp;#32; &amp;#32;8))
 (byte)(0xff &amp;amp; v)
 &lt;/code&gt;&lt;/pre&gt;&lt;p&gt;
 The bytes written by this method may be read
 by the &lt;code&gt;readInt&lt;/code&gt; method of interface
 &lt;code&gt;DataInput&lt;/code&gt; , which will then
 return an &lt;code&gt;int&lt;/code&gt; equal to &lt;code&gt;v&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>v   the &lt;code&gt;int&lt;/code&gt; value to be written.</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="v" comment="the &lt;code&gt;int&lt;/code&gt; value to be written." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="writeLong" fulltype="void" type="void">
				<comment>
					<description>Writes a &lt;code&gt;long&lt;/code&gt; value, which is
 comprised of eight bytes, to the output stream.
 The byte values to be written, in the  order
 shown, are:
 &lt;p&gt;&lt;pre&gt;&lt;code&gt;
 (byte)(0xff &amp;amp; (v &amp;gt;&amp;gt; 56))
 (byte)(0xff &amp;amp; (v &amp;gt;&amp;gt; 48))
 (byte)(0xff &amp;amp; (v &amp;gt;&amp;gt; 40))
 (byte)(0xff &amp;amp; (v &amp;gt;&amp;gt; 32))
 (byte)(0xff &amp;amp; (v &amp;gt;&amp;gt; 24))
 (byte)(0xff &amp;amp; (v &amp;gt;&amp;gt; 16))
 (byte)(0xff &amp;amp; (v &amp;gt;&amp;gt;  8))
 (byte)(0xff &amp;amp; v)
 &lt;/code&gt;&lt;/pre&gt;&lt;p&gt;
 The bytes written by this method may be
 read by the &lt;code&gt;readLong&lt;/code&gt; method
 of interface &lt;code&gt;DataInput&lt;/code&gt; , which
 will then return a &lt;code&gt;long&lt;/code&gt; equal
 to &lt;code&gt;v&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>v   the &lt;code&gt;long&lt;/code&gt; value to be written.</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="v" comment="the &lt;code&gt;long&lt;/code&gt; value to be written." fulltype="long" type="long" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="writeFloat" fulltype="void" type="void">
				<comment>
					<description>Writes a &lt;code&gt;float&lt;/code&gt; value,
 which is comprised of four bytes, to the output stream.
 It does this as if it first converts this
 &lt;code&gt;float&lt;/code&gt; value to an &lt;code&gt;int&lt;/code&gt;
 in exactly the manner of the &lt;code&gt;Float.floatToIntBits&lt;/code&gt;
 method  and then writes the &lt;code&gt;int&lt;/code&gt;
 value in exactly the manner of the  &lt;code&gt;writeInt&lt;/code&gt;
 method.  The bytes written by this method
 may be read by the &lt;code&gt;readFloat&lt;/code&gt;
 method of interface &lt;code&gt;DataInput&lt;/code&gt;,
 which will then return a &lt;code&gt;float&lt;/code&gt;
 equal to &lt;code&gt;v&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>v   the &lt;code&gt;float&lt;/code&gt; value to be written.</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="v" comment="the &lt;code&gt;float&lt;/code&gt; value to be written." fulltype="float" type="float" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="writeDouble" fulltype="void" type="void">
				<comment>
					<description>Writes a &lt;code&gt;double&lt;/code&gt; value,
 which is comprised of eight bytes, to the output stream.
 It does this as if it first converts this
 &lt;code&gt;double&lt;/code&gt; value to a &lt;code&gt;long&lt;/code&gt;
 in exactly the manner of the &lt;code&gt;Double.doubleToLongBits&lt;/code&gt;
 method  and then writes the &lt;code&gt;long&lt;/code&gt;
 value in exactly the manner of the  &lt;code&gt;writeLong&lt;/code&gt;
 method. The bytes written by this method
 may be read by the &lt;code&gt;readDouble&lt;/code&gt;
 method of interface &lt;code&gt;DataInput&lt;/code&gt;,
 which will then return a &lt;code&gt;double&lt;/code&gt;
 equal to &lt;code&gt;v&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>v   the &lt;code&gt;double&lt;/code&gt; value to be written.</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="v" comment="the &lt;code&gt;double&lt;/code&gt; value to be written." fulltype="double" type="double" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="writeBytes" fulltype="void" type="void">
				<comment>
					<description>Writes a string to the output stream.
 For every character in the string
 &lt;code&gt;s&lt;/code&gt;,  taken in order, one byte
 is written to the output stream.  If
 &lt;code&gt;s&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, a &lt;code&gt;NullPointerException&lt;/code&gt;
 is thrown.&lt;p&gt;  If &lt;code&gt;s.length&lt;/code&gt;
 is zero, then no bytes are written. Otherwise,
 the character &lt;code&gt;s[0]&lt;/code&gt; is written
 first, then &lt;code&gt;s[1]&lt;/code&gt;, and so on;
 the last character written is &lt;code&gt;s[s.length-1]&lt;/code&gt;.
 For each character, one byte is written,
 the low-order byte, in exactly the manner
 of the &lt;code&gt;writeByte&lt;/code&gt; method . The
 high-order eight bits of each character
 in the string are ignored.</description>
					<attribute name="@param">
						<description>s   the string of bytes to be written.</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="s" comment="the string of bytes to be written." fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="writeChars" fulltype="void" type="void">
				<comment>
					<description>Writes every character in the string &lt;code&gt;s&lt;/code&gt;,
 to the output stream, in order,
 two bytes per character. If &lt;code&gt;s&lt;/code&gt;
 is &lt;code&gt;null&lt;/code&gt;, a &lt;code&gt;NullPointerException&lt;/code&gt;
 is thrown.  If &lt;code&gt;s.length&lt;/code&gt;
 is zero, then no characters are written.
 Otherwise, the character &lt;code&gt;s[0]&lt;/code&gt;
 is written first, then &lt;code&gt;s[1]&lt;/code&gt;,
 and so on; the last character written is
 &lt;code&gt;s[s.length-1]&lt;/code&gt;. For each character,
 two bytes are actually written, high-order
 byte first, in exactly the manner of the
 &lt;code&gt;writeChar&lt;/code&gt; method.</description>
					<attribute name="@param">
						<description>s   the string value to be written.</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="s" comment="the string value to be written." fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="writeUTF" fulltype="void" type="void">
				<comment>
					<description>Writes two bytes of length information
 to the output stream, followed
 by the
 &lt;a href=&quot;DataInput.html#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt;
 representation
 of  every character in the string &lt;code&gt;s&lt;/code&gt;.
 If &lt;code&gt;s&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
 a &lt;code&gt;NullPointerException&lt;/code&gt; is thrown.
 Each character in the string &lt;code&gt;s&lt;/code&gt;
 is converted to a group of one, two, or
 three bytes, depending on the value of the
 character.&lt;p&gt;
 If a character &lt;code&gt;c&lt;/code&gt;
 is in the range &lt;code&gt;&amp;#92;u0001&lt;/code&gt; through
 &lt;code&gt;&amp;#92;u007f&lt;/code&gt;, it is represented
 by one byte:&lt;p&gt;
 &lt;pre&gt;(byte)c &lt;/pre&gt;  &lt;p&gt;
 If a character &lt;code&gt;c&lt;/code&gt; is &lt;code&gt;&amp;#92;u0000&lt;/code&gt;
 or is in the range &lt;code&gt;&amp;#92;u0080&lt;/code&gt;
 through &lt;code&gt;&amp;#92;u07ff&lt;/code&gt;, then it is
 represented by two bytes, to be written
 in the order shown:&lt;p&gt; &lt;pre&gt;&lt;code&gt;
 (byte)(0xc0 | (0x1f &amp;amp; (c &amp;gt;&amp;gt; 6)))
 (byte)(0x80 | (0x3f &amp;amp; c))
  &lt;/code&gt;&lt;/pre&gt;  &lt;p&gt; If a character
 &lt;code&gt;c&lt;/code&gt; is in the range &lt;code&gt;&amp;#92;u0800&lt;/code&gt;
 through &lt;code&gt;uffff&lt;/code&gt;, then it is
 represented by three bytes, to be written
 in the order shown:&lt;p&gt; &lt;pre&gt;&lt;code&gt;
 (byte)(0xe0 | (0x0f &amp;amp; (c &amp;gt;&amp;gt; 12)))
 (byte)(0x80 | (0x3f &amp;amp; (c &amp;gt;&amp;gt;  6)))
 (byte)(0x80 | (0x3f &amp;amp; c))
  &lt;/code&gt;&lt;/pre&gt;  &lt;p&gt; First,
 the total number of bytes needed to represent
 all the characters of &lt;code&gt;s&lt;/code&gt; is
 calculated. If this number is larger than
 &lt;code&gt;65535&lt;/code&gt;, then a &lt;code&gt;UTFDataFormatException&lt;/code&gt;
 is thrown. Otherwise, this length is written
 to the output stream in exactly the manner
 of the &lt;code&gt;writeShort&lt;/code&gt; method;
 after this, the one-, two-, or three-byte
 representation of each character in the
 string &lt;code&gt;s&lt;/code&gt; is written.&lt;p&gt;  The
 bytes written by this method may be read
 by the &lt;code&gt;readUTF&lt;/code&gt; method of interface
 &lt;code&gt;DataInput&lt;/code&gt; , which will then
 return a &lt;code&gt;String&lt;/code&gt; equal to &lt;code&gt;s&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>s   the string value to be written.</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="s" comment="the string value to be written." fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass abstract="true" superclass="Object" visibility="public" package="java.io" superclassfulltype="java.lang.Object" fulltype="java.io.Writer" type="Writer">
		<implements>
			<interface fulltype="java.lang.Appendable" type="Appendable" />
			<interface fulltype="java.io.Closeable" type="Closeable" />
			<interface fulltype="java.io.Flushable" type="Flushable" />
		</implements>
		<comment>
			<description>Abstract class for writing to character streams.  The only methods that a
 subclass must implement are write(char[], int, int), flush(), and close().
 Most subclasses, however, will override some of the methods defined here in
 order to provide higher efficiency, additional functionality, or both.</description>
			<attribute name="@see">
				<description>Writer</description>
			</attribute>
			<attribute name="@see">
				<description>BufferedWriter</description>
			</attribute>
			<attribute name="@see">
				<description>CharArrayWriter</description>
			</attribute>
			<attribute name="@see">
				<description>FilterWriter</description>
			</attribute>
			<attribute name="@see">
				<description>OutputStreamWriter</description>
			</attribute>
			<attribute name="@see">
				<description>FileWriter</description>
			</attribute>
			<attribute name="@see">
				<description>PipedWriter</description>
			</attribute>
			<attribute name="@see">
				<description>PrintWriter</description>
			</attribute>
			<attribute name="@see">
				<description>StringWriter</description>
			</attribute>
			<attribute name="@see">
				<description>Reader</description>
			</attribute>
			<attribute name="@author">
				<description>Mark Reinhold</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.1</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="private" name="writeBuffer" fulltype="char[]" type="char">
				<comment>
					<description>Temporary buffer used to hold writes of strings and single characters</description>
				</comment>
			</field>
			<field final="true" const="1024" visibility="private" name="writeBufferSize" constexpr="1024" fulltype="int" type="int">
				<comment>
					<description>Size of writeBuffer, must be &gt;= 1</description>
				</comment>
			</field>
			<field visibility="protected" name="lock" fulltype="java.lang.Object" type="Object">
				<comment>
					<description>The object used to synchronize operations on this stream.  For
 efficiency, a character-stream object may use an object other than
 itself to protect critical sections.  A subclass should therefore use
 the object in this field rather than &lt;tt&gt;this&lt;/tt&gt; or a synchronized
 method.</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="protected" name="Writer">
				<comment>
					<description>Creates a new character-stream writer whose critical sections will
 synchronize on the writer itself.</description>
				</comment>
			</constructor>
			<constructor visibility="protected" name="Writer">
				<comment>
					<description>Creates a new character-stream writer whose critical sections will
 synchronize on the given object.</description>
					<attribute name="@param">
						<description>lock
         Object to synchronize on</description>
					</attribute>
				</comment>
				<params>
					<param name="lock" comment="Object to synchronize on" fulltype="java.lang.Object" type="Object" />
				</params>
			</constructor>
			<method visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes a single character.  The character to be written is contained in
 the 16 low-order bits of the given integer value; the 16 high-order bits
 are ignored.

 &lt;p&gt; Subclasses that intend to support efficient single-character output
 should override this method.</description>
					<attribute name="@param">
						<description>c
         int specifying a character to be written</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException
          If an I/O error occurs</description>
					</attribute>
				</comment>
				<params>
					<param name="c" comment="int specifying a character to be written" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes an array of characters.</description>
					<attribute name="@param">
						<description>cbuf
         Array of characters to be written</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException
          If an I/O error occurs</description>
					</attribute>
				</comment>
				<params>
					<param name="cbuf" comment="Array of characters to be written" fulltype="char[]" type="char" />
				</params>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes a portion of an array of characters.</description>
					<attribute name="@param">
						<description>cbuf
         Array of characters</description>
					</attribute>
					<attribute name="@param">
						<description>off
         Offset from which to start writing characters</description>
					</attribute>
					<attribute name="@param">
						<description>len
         Number of characters to write</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException
          If an I/O error occurs</description>
					</attribute>
				</comment>
				<params>
					<param name="cbuf" comment="Array of characters" fulltype="char[]" type="char" />
					<param name="off" comment="Offset from which to start writing characters" fulltype="int" type="int" />
					<param name="len" comment="Number of characters to write" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes a string.</description>
					<attribute name="@param">
						<description>str
         String to be written</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException
          If an I/O error occurs</description>
					</attribute>
				</comment>
				<params>
					<param name="str" comment="String to be written" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes a portion of a string.</description>
					<attribute name="@param">
						<description>str
         A String</description>
					</attribute>
					<attribute name="@param">
						<description>off
         Offset from which to start writing characters</description>
					</attribute>
					<attribute name="@param">
						<description>len
         Number of characters to write</description>
					</attribute>
					<attribute name="@throws">
						<description>IndexOutOfBoundsException
          If &lt;tt&gt;off&lt;/tt&gt; is negative, or &lt;tt&gt;len&lt;/tt&gt; is negative,
          or &lt;tt&gt;off+len&lt;/tt&gt; is negative or greater than the length
          of the given string</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException
          If an I/O error occurs</description>
					</attribute>
				</comment>
				<params>
					<param name="str" comment="A String" fulltype="java.lang.String" type="String" />
					<param name="off" comment="Offset from which to start writing characters" fulltype="int" type="int" />
					<param name="len" comment="Number of characters to write" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="append" returncomment="This writer" fulltype="java.io.Writer" type="Writer">
				<comment>
					<description>Appends the specified character sequence to this writer.

 &lt;p&gt; An invocation of this method of the form &lt;tt&gt;out.append(csq)&lt;/tt&gt;
 behaves in exactly the same way as the invocation

 &lt;pre&gt;
     out.write(csq.toString()) &lt;/pre&gt;

 &lt;p&gt; Depending on the specification of &lt;tt&gt;toString&lt;/tt&gt; for the
 character sequence &lt;tt&gt;csq&lt;/tt&gt;, the entire sequence may not be
 appended. For instance, invoking the &lt;tt&gt;toString&lt;/tt&gt; method of a
 character buffer will return a subsequence whose content depends upon
 the buffer&apos;s position and limit.</description>
					<attribute name="@param">
						<description>csq
         The character sequence to append.  If &lt;tt&gt;csq&lt;/tt&gt; is
         &lt;tt&gt;null&lt;/tt&gt;, then the four characters &lt;tt&gt;&quot;null&quot;&lt;/tt&gt; are
         appended to this writer.</description>
					</attribute>
					<attribute name="@return">
						<description>This writer</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException
          If an I/O error occurs</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
				<params>
					<param name="csq" comment="The character sequence to append.  If &lt;tt&gt;csq&lt;/tt&gt; is
         &lt;tt&gt;null&lt;/tt&gt;, then the four characters &lt;tt&gt;&quot;null&quot;&lt;/tt&gt; are
         appended to this writer." fulltype="java.lang.CharSequence" type="CharSequence" />
				</params>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="append" returncomment="This writer" fulltype="java.io.Writer" type="Writer">
				<comment>
					<description>Appends a subsequence of the specified character sequence to this writer.
 &lt;tt&gt;Appendable&lt;/tt&gt;.

 &lt;p&gt; An invocation of this method of the form &lt;tt&gt;out.append(csq, start,
 end)&lt;/tt&gt; when &lt;tt&gt;csq&lt;/tt&gt; is not &lt;tt&gt;null&lt;/tt&gt; behaves in exactly the
 same way as the invocation

 &lt;pre&gt;
     out.write(csq.subSequence(start, end).toString()) &lt;/pre&gt;</description>
					<attribute name="@param">
						<description>csq
         The character sequence from which a subsequence will be
         appended.  If &lt;tt&gt;csq&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;, then characters
         will be appended as if &lt;tt&gt;csq&lt;/tt&gt; contained the four
         characters &lt;tt&gt;&quot;null&quot;&lt;/tt&gt;.</description>
					</attribute>
					<attribute name="@param">
						<description>start
         The index of the first character in the subsequence</description>
					</attribute>
					<attribute name="@param">
						<description>end
         The index of the character following the last character in the
         subsequence</description>
					</attribute>
					<attribute name="@return">
						<description>This writer</description>
					</attribute>
					<attribute name="@throws">
						<description>IndexOutOfBoundsException
          If &lt;tt&gt;start&lt;/tt&gt; or &lt;tt&gt;end&lt;/tt&gt; are negative, &lt;tt&gt;start&lt;/tt&gt;
          is greater than &lt;tt&gt;end&lt;/tt&gt;, or &lt;tt&gt;end&lt;/tt&gt; is greater than
          &lt;tt&gt;csq.length()&lt;/tt&gt;</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException
          If an I/O error occurs</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
				<params>
					<param name="csq" comment="The character sequence from which a subsequence will be
         appended.  If &lt;tt&gt;csq&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;, then characters
         will be appended as if &lt;tt&gt;csq&lt;/tt&gt; contained the four
         characters &lt;tt&gt;&quot;null&quot;&lt;/tt&gt;." fulltype="java.lang.CharSequence" type="CharSequence" />
					<param name="start" comment="The index of the first character in the subsequence" fulltype="int" type="int" />
					<param name="end" comment="The index of the character following the last character in the
         subsequence" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="append" returncomment="This writer" fulltype="java.io.Writer" type="Writer">
				<comment>
					<description>Appends the specified character to this writer.

 &lt;p&gt; An invocation of this method of the form &lt;tt&gt;out.append(c)&lt;/tt&gt;
 behaves in exactly the same way as the invocation

 &lt;pre&gt;
     out.write(c) &lt;/pre&gt;</description>
					<attribute name="@param">
						<description>c
         The 16-bit character to append</description>
					</attribute>
					<attribute name="@return">
						<description>This writer</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException
          If an I/O error occurs</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
				<params>
					<param name="c" comment="The 16-bit character to append" fulltype="char" type="char" />
				</params>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="public" name="flush" fulltype="void" type="void">
				<comment>
					<description>Flushes the stream.  If the stream has saved any characters from the
 various write() methods in a buffer, write them immediately to their
 intended destination.  Then, if that destination is another character or
 byte stream, flush it.  Thus one flush() invocation will flush all the
 buffers in a chain of Writers and OutputStreams.

 &lt;p&gt; If the intended destination of this stream is an abstraction provided
 by the underlying operating system, for example a file, then flushing the
 stream guarantees only that bytes previously written to the stream are
 passed to the operating system for writing; it does not guarantee that
 they are actually written to a physical device such as a disk drive.</description>
					<attribute name="@throws">
						<description>IOException
          If an I/O error occurs</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="public" name="close" fulltype="void" type="void">
				<comment>
					<description>Closes the stream, flushing it first. Once the stream has been closed,
 further write() or flush() invocations will cause an IOException to be
 thrown. Closing a previously closed stream has no effect.</description>
					<attribute name="@throws">
						<description>IOException
          If an I/O error occurs</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="ObjectStreamException" visibility="public" package="java.io" serializable="true" superclassfulltype="java.io.ObjectStreamException" fulltype="java.io.StreamCorruptedException" type="StreamCorruptedException">
		<comment>
			<description>Thrown when control information that was read from an object stream
 violates internal consistency checks.</description>
			<attribute name="@author">
				<description>unascribed</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.1</description>
			</attribute>
		</comment>
		<fields>
			<field final="true" static="true" const="8983558202217591746" visibility="private" name="serialVersionUID" constexpr="8983558202217591746L" fulltype="long" type="long" />
		</fields>
		<methods>
			<constructor visibility="public" name="StreamCorruptedException">
				<comment>
					<description>Create a StreamCorruptedException and list a reason why thrown.</description>
					<attribute name="@param">
						<description>reason  String describing the reason for the exception.</description>
					</attribute>
				</comment>
				<params>
					<param name="reason" comment="String describing the reason for the exception." fulltype="java.lang.String" type="String" />
				</params>
			</constructor>
			<constructor visibility="public" name="StreamCorruptedException">
				<comment>
					<description>Create a StreamCorruptedException and list no reason why thrown.</description>
				</comment>
			</constructor>
		</methods>
	</jelclass>
	<jelclass superclass="FilterOutputStream" visibility="public" package="java.io" superclassfulltype="java.io.FilterOutputStream" fulltype="java.io.DataOutputStream" type="DataOutputStream">
		<implements>
			<interface fulltype="java.io.DataOutput" type="DataOutput" />
		</implements>
		<comment>
			<description>A data output stream lets an application write primitive Java data
 types to an output stream in a portable way. An application can
 then use a data input stream to read the data back in.</description>
			<attribute name="@author">
				<description>unascribed</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.DataInputStream</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.0</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="protected" name="written" fulltype="int" type="int">
				<comment>
					<description>The number of bytes written to the data output stream so far.
 If this counter overflows, it will be wrapped to Integer.MAX_VALUE.</description>
				</comment>
			</field>
			<field visibility="private" name="bytearr" fulltype="byte[]" type="byte">
				<comment>
					<description>bytearr is initialized on demand by writeUTF</description>
				</comment>
			</field>
			<field visibility="private" name="writeBuffer" fulltype="byte[]" type="byte" />
		</fields>
		<methods>
			<constructor visibility="public" name="DataOutputStream">
				<comment>
					<description>Creates a new data output stream to write data to the specified
 underlying output stream. The counter &lt;code&gt;written&lt;/code&gt; is
 set to zero.</description>
					<attribute name="@param">
						<description>out   the underlying output stream, to be saved for later
                use.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.FilterOutputStream#out</description>
					</attribute>
				</comment>
				<params>
					<param name="out" comment="the underlying output stream, to be saved for later
                use." fulltype="java.io.OutputStream" type="OutputStream" />
				</params>
			</constructor>
			<method visibility="private" name="incCount" fulltype="void" type="void">
				<comment>
					<description>Increases the written counter by the specified value
 until it reaches Integer.MAX_VALUE.</description>
				</comment>
				<params>
					<param name="value" fulltype="int" type="int" />
				</params>
			</method>
			<method synchronized="true" visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes the specified byte (the low eight bits of the argument
 &lt;code&gt;b&lt;/code&gt;) to the underlying output stream. If no exception
 is thrown, the counter &lt;code&gt;written&lt;/code&gt; is incremented by
 &lt;code&gt;1&lt;/code&gt;.
 &lt;p&gt;
 Implements the &lt;code&gt;write&lt;/code&gt; method of &lt;code&gt;OutputStream&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>b   the &lt;code&gt;byte&lt;/code&gt; to be written.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.FilterOutputStream#out</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the &lt;code&gt;byte&lt;/code&gt; to be written." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes &lt;code&gt;len&lt;/code&gt; bytes from the specified byte array
 starting at offset &lt;code&gt;off&lt;/code&gt; to the underlying output stream.
 If no exception is thrown, the counter &lt;code&gt;written&lt;/code&gt; is
 incremented by &lt;code&gt;len&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>b     the data.</description>
					</attribute>
					<attribute name="@param">
						<description>off   the start offset in the data.</description>
					</attribute>
					<attribute name="@param">
						<description>len   the number of bytes to write.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.FilterOutputStream#out</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the data." fulltype="byte[]" type="byte" />
					<param name="off" comment="the start offset in the data." fulltype="int" type="int" />
					<param name="len" comment="the number of bytes to write." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="flush" fulltype="void" type="void">
				<comment>
					<description>Flushes this data output stream. This forces any buffered output
 bytes to be written out to the stream.
 &lt;p&gt;
 The &lt;code&gt;flush&lt;/code&gt; method of &lt;code&gt;DataOutputStream&lt;/code&gt;
 calls the &lt;code&gt;flush&lt;/code&gt; method of its underlying output stream.</description>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.FilterOutputStream#out</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.OutputStream#flush()</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="writeBoolean" fulltype="void" type="void">
				<comment>
					<description>Writes a &lt;code&gt;boolean&lt;/code&gt; to the underlying output stream as
 a 1-byte value. The value &lt;code&gt;true&lt;/code&gt; is written out as the
 value &lt;code&gt;(byte)1&lt;/code&gt;; the value &lt;code&gt;false&lt;/code&gt; is
 written out as the value &lt;code&gt;(byte)0&lt;/code&gt;. If no exception is
 thrown, the counter &lt;code&gt;written&lt;/code&gt; is incremented by
 &lt;code&gt;1&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>v   a &lt;code&gt;boolean&lt;/code&gt; value to be written.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.FilterOutputStream#out</description>
					</attribute>
				</comment>
				<params>
					<param name="v" comment="a &lt;code&gt;boolean&lt;/code&gt; value to be written." fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="writeByte" fulltype="void" type="void">
				<comment>
					<description>Writes out a &lt;code&gt;byte&lt;/code&gt; to the underlying output stream as
 a 1-byte value. If no exception is thrown, the counter
 &lt;code&gt;written&lt;/code&gt; is incremented by &lt;code&gt;1&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>v   a &lt;code&gt;byte&lt;/code&gt; value to be written.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.FilterOutputStream#out</description>
					</attribute>
				</comment>
				<params>
					<param name="v" comment="a &lt;code&gt;byte&lt;/code&gt; value to be written." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="writeShort" fulltype="void" type="void">
				<comment>
					<description>Writes a &lt;code&gt;short&lt;/code&gt; to the underlying output stream as two
 bytes, high byte first. If no exception is thrown, the counter
 &lt;code&gt;written&lt;/code&gt; is incremented by &lt;code&gt;2&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>v   a &lt;code&gt;short&lt;/code&gt; to be written.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.FilterOutputStream#out</description>
					</attribute>
				</comment>
				<params>
					<param name="v" comment="a &lt;code&gt;short&lt;/code&gt; to be written." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="writeChar" fulltype="void" type="void">
				<comment>
					<description>Writes a &lt;code&gt;char&lt;/code&gt; to the underlying output stream as a
 2-byte value, high byte first. If no exception is thrown, the
 counter &lt;code&gt;written&lt;/code&gt; is incremented by &lt;code&gt;2&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>v   a &lt;code&gt;char&lt;/code&gt; value to be written.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.FilterOutputStream#out</description>
					</attribute>
				</comment>
				<params>
					<param name="v" comment="a &lt;code&gt;char&lt;/code&gt; value to be written." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="writeInt" fulltype="void" type="void">
				<comment>
					<description>Writes an &lt;code&gt;int&lt;/code&gt; to the underlying output stream as four
 bytes, high byte first. If no exception is thrown, the counter
 &lt;code&gt;written&lt;/code&gt; is incremented by &lt;code&gt;4&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>v   an &lt;code&gt;int&lt;/code&gt; to be written.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.FilterOutputStream#out</description>
					</attribute>
				</comment>
				<params>
					<param name="v" comment="an &lt;code&gt;int&lt;/code&gt; to be written." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="writeLong" fulltype="void" type="void">
				<comment>
					<description>Writes a &lt;code&gt;long&lt;/code&gt; to the underlying output stream as eight
 bytes, high byte first. In no exception is thrown, the counter
 &lt;code&gt;written&lt;/code&gt; is incremented by &lt;code&gt;8&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>v   a &lt;code&gt;long&lt;/code&gt; to be written.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.FilterOutputStream#out</description>
					</attribute>
				</comment>
				<params>
					<param name="v" comment="a &lt;code&gt;long&lt;/code&gt; to be written." fulltype="long" type="long" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="writeFloat" fulltype="void" type="void">
				<comment>
					<description>Converts the float argument to an &lt;code&gt;int&lt;/code&gt; using the
 &lt;code&gt;floatToIntBits&lt;/code&gt; method in class &lt;code&gt;Float&lt;/code&gt;,
 and then writes that &lt;code&gt;int&lt;/code&gt; value to the underlying
 output stream as a 4-byte quantity, high byte first. If no
 exception is thrown, the counter &lt;code&gt;written&lt;/code&gt; is
 incremented by &lt;code&gt;4&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>v   a &lt;code&gt;float&lt;/code&gt; value to be written.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.FilterOutputStream#out</description>
					</attribute>
					<attribute name="@see">
						<description>java.lang.Float#floatToIntBits(float)</description>
					</attribute>
				</comment>
				<params>
					<param name="v" comment="a &lt;code&gt;float&lt;/code&gt; value to be written." fulltype="float" type="float" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="writeDouble" fulltype="void" type="void">
				<comment>
					<description>Converts the double argument to a &lt;code&gt;long&lt;/code&gt; using the
 &lt;code&gt;doubleToLongBits&lt;/code&gt; method in class &lt;code&gt;Double&lt;/code&gt;,
 and then writes that &lt;code&gt;long&lt;/code&gt; value to the underlying
 output stream as an 8-byte quantity, high byte first. If no
 exception is thrown, the counter &lt;code&gt;written&lt;/code&gt; is
 incremented by &lt;code&gt;8&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>v   a &lt;code&gt;double&lt;/code&gt; value to be written.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.FilterOutputStream#out</description>
					</attribute>
					<attribute name="@see">
						<description>java.lang.Double#doubleToLongBits(double)</description>
					</attribute>
				</comment>
				<params>
					<param name="v" comment="a &lt;code&gt;double&lt;/code&gt; value to be written." fulltype="double" type="double" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="writeBytes" fulltype="void" type="void">
				<comment>
					<description>Writes out the string to the underlying output stream as a
 sequence of bytes. Each character in the string is written out, in
 sequence, by discarding its high eight bits. If no exception is
 thrown, the counter &lt;code&gt;written&lt;/code&gt; is incremented by the
 length of &lt;code&gt;s&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>s   a string of bytes to be written.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.FilterOutputStream#out</description>
					</attribute>
				</comment>
				<params>
					<param name="s" comment="a string of bytes to be written." fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="writeChars" fulltype="void" type="void">
				<comment>
					<description>Writes a string to the underlying output stream as a sequence of
 characters. Each character is written to the data output stream as
 if by the &lt;code&gt;writeChar&lt;/code&gt; method. If no exception is
 thrown, the counter &lt;code&gt;written&lt;/code&gt; is incremented by twice
 the length of &lt;code&gt;s&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>s   a &lt;code&gt;String&lt;/code&gt; value to be written.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.DataOutputStream#writeChar(int)</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.FilterOutputStream#out</description>
					</attribute>
				</comment>
				<params>
					<param name="s" comment="a &lt;code&gt;String&lt;/code&gt; value to be written." fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="writeUTF" fulltype="void" type="void">
				<comment>
					<description>Writes a string to the underlying output stream using
 &lt;a href=&quot;DataInput.html#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt;
 encoding in a machine-independent manner.
 &lt;p&gt;
 First, two bytes are written to the output stream as if by the
 &lt;code&gt;writeShort&lt;/code&gt; method giving the number of bytes to
 follow. This value is the number of bytes actually written out,
 not the length of the string. Following the length, each character
 of the string is output, in sequence, using the modified UTF-8 encoding
 for the character. If no exception is thrown, the counter
 &lt;code&gt;written&lt;/code&gt; is incremented by the total number of
 bytes written to the output stream. This will be at least two
 plus the length of &lt;code&gt;str&lt;/code&gt;, and at most two plus
 thrice the length of &lt;code&gt;str&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>str   a string to be written.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="str" comment="a string to be written." fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method static="true" visibility="package-private" name="writeUTF" returncomment="The number of bytes written out." fulltype="int" type="int">
				<comment>
					<description>Writes a string to the specified DataOutput using
 &lt;a href=&quot;DataInput.html#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt;
 encoding in a machine-independent manner.
 &lt;p&gt;
 First, two bytes are written to out as if by the &lt;code&gt;writeShort&lt;/code&gt;
 method giving the number of bytes to follow. This value is the number of
 bytes actually written out, not the length of the string. Following the
 length, each character of the string is output, in sequence, using the
 modified UTF-8 encoding for the character. If no exception is thrown, the
 counter &lt;code&gt;written&lt;/code&gt; is incremented by the total number of
 bytes written to the output stream. This will be at least two
 plus the length of &lt;code&gt;str&lt;/code&gt;, and at most two plus
 thrice the length of &lt;code&gt;str&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>str   a string to be written.</description>
					</attribute>
					<attribute name="@param">
						<description>out   destination to write to</description>
					</attribute>
					<attribute name="@return">
						<description>The number of bytes written out.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="str" comment="a string to be written." fulltype="java.lang.String" type="String" />
					<param name="out" comment="destination to write to" fulltype="java.io.DataOutput" type="DataOutput" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="size" returncomment="the value of the &lt;code&gt;written&lt;/code&gt; field." fulltype="int" type="int">
				<comment>
					<description>Returns the current value of the counter &lt;code&gt;written&lt;/code&gt;,
 the number of bytes written to this data output stream so far.
 If the counter overflows, it will be wrapped to Integer.MAX_VALUE.</description>
					<attribute name="@return">
						<description>the value of the &lt;code&gt;written&lt;/code&gt; field.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.DataOutputStream#written</description>
					</attribute>
				</comment>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="InputStreamReader" visibility="public" package="java.io" superclassfulltype="java.io.InputStreamReader" fulltype="java.io.FileReader" type="FileReader">
		<comment>
			<description>Convenience class for reading character files.  The constructors of this
 class assume that the default character encoding and the default byte-buffer
 size are appropriate.  To specify these values yourself, construct an
 InputStreamReader on a FileInputStream.

 &lt;p&gt;&lt;code&gt;FileReader&lt;/code&gt; is meant for reading streams of characters.
 For reading streams of raw bytes, consider using a
 &lt;code&gt;FileInputStream&lt;/code&gt;.</description>
			<attribute name="@see">
				<description>InputStreamReader</description>
			</attribute>
			<attribute name="@see">
				<description>FileInputStream</description>
			</attribute>
			<attribute name="@author">
				<description>Mark Reinhold</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.1</description>
			</attribute>
		</comment>
		<methods>
			<constructor visibility="public" name="FileReader">
				<comment>
					<description>Creates a new &lt;tt&gt;FileReader&lt;/tt&gt;, given the name of the
 file to read from.</description>
					<attribute name="@param">
						<description>fileName the name of the file to read from</description>
					</attribute>
					<attribute name="@exception">
						<description>FileNotFoundException  if the named file does not exist,
                   is a directory rather than a regular file,
                   or for some other reason cannot be opened for
                   reading.</description>
					</attribute>
				</comment>
				<params>
					<param name="fileName" comment="the name of the file to read from" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception comment="if the named file does not exist,
                   is a directory rather than a regular file,
                   or for some other reason cannot be opened for
                   reading." fulltype="java.io.FileNotFoundException" type="FileNotFoundException" />
				</exceptions>
			</constructor>
			<constructor visibility="public" name="FileReader">
				<comment>
					<description>Creates a new &lt;tt&gt;FileReader&lt;/tt&gt;, given the &lt;tt&gt;File&lt;/tt&gt;
 to read from.</description>
					<attribute name="@param">
						<description>file the &lt;tt&gt;File&lt;/tt&gt; to read from</description>
					</attribute>
					<attribute name="@exception">
						<description>FileNotFoundException  if the file does not exist,
                   is a directory rather than a regular file,
                   or for some other reason cannot be opened for
                   reading.</description>
					</attribute>
				</comment>
				<params>
					<param name="file" comment="the &lt;tt&gt;File&lt;/tt&gt; to read from" fulltype="java.io.File" type="File" />
				</params>
				<exceptions>
					<exception comment="if the file does not exist,
                   is a directory rather than a regular file,
                   or for some other reason cannot be opened for
                   reading." fulltype="java.io.FileNotFoundException" type="FileNotFoundException" />
				</exceptions>
			</constructor>
			<constructor visibility="public" name="FileReader">
				<comment>
					<description>Creates a new &lt;tt&gt;FileReader&lt;/tt&gt;, given the
 &lt;tt&gt;FileDescriptor&lt;/tt&gt; to read from.</description>
					<attribute name="@param">
						<description>fd the FileDescriptor to read from</description>
					</attribute>
				</comment>
				<params>
					<param name="fd" comment="the FileDescriptor to read from" fulltype="java.io.FileDescriptor" type="FileDescriptor" />
				</params>
			</constructor>
		</methods>
	</jelclass>
	<jelclass abstract="true" visibility="public" package="java.io" interface="true" fulltype="java.io.ObjectOutput" type="ObjectOutput">
		<implements>
			<interface fulltype="java.io.DataOutput" type="DataOutput" />
		</implements>
		<comment>
			<description>ObjectOutput extends the DataOutput interface to include writing of objects.
 DataOutput includes methods for output of primitive types, ObjectOutput
 extends that interface to include objects, arrays, and Strings.</description>
			<attribute name="@author">
				<description>unascribed</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.InputStream</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.ObjectOutputStream</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.ObjectInputStream</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.1</description>
			</attribute>
		</comment>
		<methods>
			<method visibility="public" name="writeObject" fulltype="void" type="void">
				<comment>
					<description>Write an object to the underlying storage or stream.  The
 class that implements this interface defines how the object is
 written.</description>
					<attribute name="@param">
						<description>obj the object to be written</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException Any of the usual Input/Output related exceptions.</description>
					</attribute>
				</comment>
				<params>
					<param name="obj" comment="the object to be written" fulltype="java.lang.Object" type="Object" />
				</params>
				<exceptions>
					<exception comment="Any of the usual Input/Output related exceptions." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes a byte. This method will block until the byte is actually
 written.</description>
					<attribute name="@param">
						<description>b the byte</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException If an I/O error has occurred.</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the byte" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="If an I/O error has occurred." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes an array of bytes. This method will block until the bytes
 are actually written.</description>
					<attribute name="@param">
						<description>b the data to be written</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException If an I/O error has occurred.</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the data to be written" fulltype="byte[]" type="byte" />
				</params>
				<exceptions>
					<exception comment="If an I/O error has occurred." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes a sub array of bytes.</description>
					<attribute name="@param">
						<description>b the data to be written</description>
					</attribute>
					<attribute name="@param">
						<description>off       the start offset in the data</description>
					</attribute>
					<attribute name="@param">
						<description>len       the number of bytes that are written</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException If an I/O error has occurred.</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the data to be written" fulltype="byte[]" type="byte" />
					<param name="off" comment="the start offset in the data" fulltype="int" type="int" />
					<param name="len" comment="the number of bytes that are written" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="If an I/O error has occurred." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="flush" fulltype="void" type="void">
				<comment>
					<description>Flushes the stream. This will write any buffered
 output bytes.</description>
					<attribute name="@exception">
						<description>IOException If an I/O error has occurred.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If an I/O error has occurred." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="close" fulltype="void" type="void">
				<comment>
					<description>Closes the stream. This method must be called
 to release any resources associated with the
 stream.</description>
					<attribute name="@exception">
						<description>IOException If an I/O error has occurred.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If an I/O error has occurred." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="Writer" visibility="public" package="java.io" superclassfulltype="java.io.Writer" fulltype="java.io.BufferedWriter" type="BufferedWriter">
		<comment>
			<description>Writes text to a character-output stream, buffering characters so as to
 provide for the efficient writing of single characters, arrays, and strings.

 &lt;p&gt; The buffer size may be specified, or the default size may be accepted.
 The default is large enough for most purposes.

 &lt;p&gt; A newLine() method is provided, which uses the platform&apos;s own notion of
 line separator as defined by the system property &lt;tt&gt;line.separator&lt;/tt&gt;.
 Not all platforms use the newline character (&apos;\n&apos;) to terminate lines.
 Calling this method to terminate each output line is therefore preferred to
 writing a newline character directly.

 &lt;p&gt; In general, a Writer sends its output immediately to the underlying
 character or byte stream.  Unless prompt output is required, it is advisable
 to wrap a BufferedWriter around any Writer whose write() operations may be
 costly, such as FileWriters and OutputStreamWriters.  For example,

 &lt;pre&gt;
 PrintWriter out
   = new PrintWriter(new BufferedWriter(new FileWriter(&quot;foo.out&quot;)));
 &lt;/pre&gt;

 will buffer the PrintWriter&apos;s output to the file.  Without buffering, each
 invocation of a print() method would cause characters to be converted into
 bytes that would then be written immediately to the file, which can be very
 inefficient.</description>
			<attribute name="@see">
				<description>PrintWriter</description>
			</attribute>
			<attribute name="@see">
				<description>FileWriter</description>
			</attribute>
			<attribute name="@see">
				<description>OutputStreamWriter</description>
			</attribute>
			<attribute name="@author">
				<description>Mark Reinhold</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.1</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="private" name="out" fulltype="java.io.Writer" type="Writer" />
			<field visibility="private" name="cb" fulltype="char[]" type="char" />
			<field visibility="private" name="nChars" fulltype="int" type="int" />
			<field visibility="private" name="nextChar" fulltype="int" type="int" />
			<field static="true" visibility="private" name="defaultCharBufferSize" fulltype="int" type="int" />
			<field visibility="private" name="lineSeparator" fulltype="java.lang.String" type="String">
				<comment>
					<description>Line separator string.  This is the value of the line.separator
 property at the moment that the stream was created.</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="public" name="BufferedWriter">
				<comment>
					<description>Creates a buffered character-output stream that uses a default-sized
 output buffer.</description>
					<attribute name="@param">
						<description>out  A Writer</description>
					</attribute>
				</comment>
				<params>
					<param name="out" comment="A Writer" fulltype="java.io.Writer" type="Writer" />
				</params>
			</constructor>
			<constructor visibility="public" name="BufferedWriter">
				<comment>
					<description>Creates a new buffered character-output stream that uses an output
 buffer of the given size.</description>
					<attribute name="@param">
						<description>out  A Writer</description>
					</attribute>
					<attribute name="@param">
						<description>sz   Output-buffer size, a positive integer</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException  If sz is &lt;= 0</description>
					</attribute>
				</comment>
				<params>
					<param name="out" comment="A Writer" fulltype="java.io.Writer" type="Writer" />
					<param name="sz" comment="Output-buffer size, a positive integer" fulltype="int" type="int" />
				</params>
			</constructor>
			<method visibility="private" name="ensureOpen" fulltype="void" type="void">
				<comment>
					<description>Checks to make sure that the stream has not been closed</description>
				</comment>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="package-private" name="flushBuffer" fulltype="void" type="void">
				<comment>
					<description>Flushes the output buffer to the underlying character stream, without
 flushing the stream itself.  This method is non-private only so that it
 may be invoked by PrintStream.</description>
				</comment>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes a single character.</description>
					<attribute name="@exception">
						<description>IOException  If an I/O error occurs</description>
					</attribute>
				</comment>
				<params>
					<param name="c" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="min" fulltype="int" type="int">
				<comment>
					<description>Our own little min method, to avoid loading java.lang.Math if we&apos;ve run
 out of file descriptors and we&apos;re trying to print a stack trace.</description>
				</comment>
				<params>
					<param name="a" fulltype="int" type="int" />
					<param name="b" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes a portion of an array of characters.

 &lt;p&gt; Ordinarily this method stores characters from the given array into
 this stream&apos;s buffer, flushing the buffer to the underlying stream as
 needed.  If the requested length is at least as large as the buffer,
 however, then this method will flush the buffer and write the characters
 directly to the underlying stream.  Thus redundant
 &lt;code&gt;BufferedWriter&lt;/code&gt;s will not copy data unnecessarily.</description>
					<attribute name="@param">
						<description>cbuf  A character array</description>
					</attribute>
					<attribute name="@param">
						<description>off   Offset from which to start reading characters</description>
					</attribute>
					<attribute name="@param">
						<description>len   Number of characters to write</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  If an I/O error occurs</description>
					</attribute>
				</comment>
				<params>
					<param name="cbuf" comment="A character array" fulltype="char[]" type="char" />
					<param name="off" comment="Offset from which to start reading characters" fulltype="int" type="int" />
					<param name="len" comment="Number of characters to write" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes a portion of a String.

 &lt;p&gt; If the value of the &lt;tt&gt;len&lt;/tt&gt; parameter is negative then no
 characters are written.  This is contrary to the specification of this
 method in the {@linkplain java.io.Writer#write(java.lang.String,int,int)
 superclass}, which requires that an {@link IndexOutOfBoundsException} be
 thrown.</description>
					<attribute name="@param">
						<description>s     String to be written</description>
					</attribute>
					<attribute name="@param">
						<description>off   Offset from which to start reading characters</description>
					</attribute>
					<attribute name="@param">
						<description>len   Number of characters to be written</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  If an I/O error occurs</description>
					</attribute>
				</comment>
				<params>
					<param name="s" comment="String to be written" fulltype="java.lang.String" type="String" />
					<param name="off" comment="Offset from which to start reading characters" fulltype="int" type="int" />
					<param name="len" comment="Number of characters to be written" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="newLine" fulltype="void" type="void">
				<comment>
					<description>Writes a line separator.  The line separator string is defined by the
 system property &lt;tt&gt;line.separator&lt;/tt&gt;, and is not necessarily a single
 newline (&apos;\n&apos;) character.</description>
					<attribute name="@exception">
						<description>IOException  If an I/O error occurs</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="flush" fulltype="void" type="void">
				<comment>
					<description>Flushes the stream.</description>
					<attribute name="@exception">
						<description>IOException  If an I/O error occurs</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="close" fulltype="void" type="void">
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="Reader" visibility="public" package="java.io" superclassfulltype="java.io.Reader" fulltype="java.io.PipedReader" type="PipedReader">
		<comment>
			<description>Piped character-input streams.</description>
			<attribute name="@author">
				<description>Mark Reinhold</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.1</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="package-private" name="closedByWriter" fulltype="boolean" type="boolean" />
			<field visibility="package-private" name="closedByReader" fulltype="boolean" type="boolean" />
			<field visibility="package-private" name="connected" fulltype="boolean" type="boolean" />
			<field visibility="package-private" name="readSide" fulltype="java.lang.Thread" type="Thread" />
			<field visibility="package-private" name="writeSide" fulltype="java.lang.Thread" type="Thread" />
			<field final="true" static="true" const="1024" visibility="private" name="DEFAULT_PIPE_SIZE" constexpr="1024" fulltype="int" type="int">
				<comment>
					<description>The size of the pipe&apos;s circular input buffer.</description>
				</comment>
			</field>
			<field visibility="package-private" name="buffer" fulltype="char[]" type="char">
				<comment>
					<description>The circular buffer into which incoming data is placed.</description>
				</comment>
			</field>
			<field visibility="package-private" name="in" fulltype="int" type="int">
				<comment>
					<description>The index of the position in the circular buffer at which the
 next character of data will be stored when received from the connected
 piped writer. &lt;code&gt;in&amp;lt;0&lt;/code&gt; implies the buffer is empty,
 &lt;code&gt;in==out&lt;/code&gt; implies the buffer is full</description>
				</comment>
			</field>
			<field visibility="package-private" name="out" fulltype="int" type="int">
				<comment>
					<description>The index of the position in the circular buffer at which the next
 character of data will be read by this piped reader.</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="public" name="PipedReader">
				<comment>
					<description>Creates a &lt;code&gt;PipedReader&lt;/code&gt; so
 that it is connected to the piped writer
 &lt;code&gt;src&lt;/code&gt;. Data written to &lt;code&gt;src&lt;/code&gt;
 will then be available as input from this stream.</description>
					<attribute name="@param">
						<description>src   the stream to connect to.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="src" comment="the stream to connect to." fulltype="java.io.PipedWriter" type="PipedWriter" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</constructor>
			<constructor visibility="public" name="PipedReader">
				<comment>
					<description>Creates a &lt;code&gt;PipedReader&lt;/code&gt; so that it is connected
 to the piped writer &lt;code&gt;src&lt;/code&gt; and uses the specified
 pipe size for the pipe&apos;s buffer. Data written to &lt;code&gt;src&lt;/code&gt;
 will then be  available as input from this stream.</description>
					<attribute name="@param">
						<description>src       the stream to connect to.</description>
					</attribute>
					<attribute name="@param">
						<description>pipeSize  the size of the pipe&apos;s buffer.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if &lt;code&gt;pipeSize &lt;= 0&lt;/code&gt;.</description>
					</attribute>
					<attribute name="@since">
						<description>1.6</description>
					</attribute>
				</comment>
				<params>
					<param name="src" comment="the stream to connect to." fulltype="java.io.PipedWriter" type="PipedWriter" />
					<param name="pipeSize" comment="the size of the pipe&apos;s buffer." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</constructor>
			<constructor visibility="public" name="PipedReader">
				<comment>
					<description>Creates a &lt;code&gt;PipedReader&lt;/code&gt; so
 that it is not yet {@linkplain #connect(java.io.PipedWriter)
 connected}. It must be {@linkplain java.io.PipedWriter#connect(
 java.io.PipedReader) connected} to a &lt;code&gt;PipedWriter&lt;/code&gt;
 before being used.</description>
				</comment>
			</constructor>
			<constructor visibility="public" name="PipedReader">
				<comment>
					<description>Creates a &lt;code&gt;PipedReader&lt;/code&gt; so that it is not yet
 {@link #connect(java.io.PipedWriter) connected} and uses
 the specified pipe size for the pipe&apos;s buffer.
 It must be  {@linkplain java.io.PipedWriter#connect(
 java.io.PipedReader) connected} to a &lt;code&gt;PipedWriter&lt;/code&gt;
 before being used.</description>
					<attribute name="@param">
						<description>pipeSize the size of the pipe&apos;s buffer.</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if &lt;code&gt;pipeSize &lt;= 0&lt;/code&gt;.</description>
					</attribute>
					<attribute name="@since">
						<description>1.6</description>
					</attribute>
				</comment>
				<params>
					<param name="pipeSize" comment="the size of the pipe&apos;s buffer." fulltype="int" type="int" />
				</params>
			</constructor>
			<method visibility="private" name="initPipe" fulltype="void" type="void">
				<params>
					<param name="pipeSize" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="connect" fulltype="void" type="void">
				<comment>
					<description>Causes this piped reader to be connected
 to the piped  writer &lt;code&gt;src&lt;/code&gt;.
 If this object is already connected to some
 other piped writer, an &lt;code&gt;IOException&lt;/code&gt;
 is thrown.
 &lt;p&gt;
 If &lt;code&gt;src&lt;/code&gt; is an
 unconnected piped writer and &lt;code&gt;snk&lt;/code&gt;
 is an unconnected piped reader, they
 may be connected by either the call:
 &lt;p&gt;
 &lt;pre&gt;&lt;code&gt;snk.connect(src)&lt;/code&gt; &lt;/pre&gt;
 &lt;p&gt;
 or the call:
 &lt;p&gt;
 &lt;pre&gt;&lt;code&gt;src.connect(snk)&lt;/code&gt; &lt;/pre&gt;
 &lt;p&gt;
 The two
 calls have the same effect.</description>
					<attribute name="@param">
						<description>src   The piped writer to connect to.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="src" comment="The piped writer to connect to." fulltype="java.io.PipedWriter" type="PipedWriter" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="package-private" name="receive" fulltype="void" type="void">
				<comment>
					<description>Receives a char of data. This method will block if no input is
 available.</description>
				</comment>
				<params>
					<param name="c" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="package-private" name="receive" fulltype="void" type="void">
				<comment>
					<description>Receives data into an array of characters.  This method will
 block until some input is available.</description>
				</comment>
				<params>
					<param name="c" fulltype="char[]" type="char" />
					<param name="off" fulltype="int" type="int" />
					<param name="len" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="package-private" name="receivedLast" fulltype="void" type="void">
				<comment>
					<description>Notifies all waiting threads that the last character of data has been
 received.</description>
				</comment>
			</method>
			<method synchronized="true" visibility="public" name="read" returncomment="the next character of data, or &lt;code&gt;-1&lt;/code&gt; if the end of the
             stream is reached." fulltype="int" type="int">
				<comment>
					<description>Reads the next character of data from this piped stream.
 If no character is available because the end of the stream
 has been reached, the value &lt;code&gt;-1&lt;/code&gt; is returned.
 This method blocks until input data is available, the end of
 the stream is detected, or an exception is thrown.</description>
					<attribute name="@return">
						<description>the next character of data, or &lt;code&gt;-1&lt;/code&gt; if the end of the
             stream is reached.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if the pipe is
          &lt;a href=PipedInputStream.html#BROKEN&gt; &lt;code&gt;broken&lt;/code&gt;&lt;/a&gt;,
          {@link #connect(java.io.PipedWriter) unconnected}, closed,
          or an I/O error occurs.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if the pipe is
          &lt;a href=PipedInputStream.html#BROKEN&gt; &lt;code&gt;broken&lt;/code&gt;&lt;/a&gt;,
          {@link #connect(java.io.PipedWriter) unconnected}, closed,
          or an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="public" name="read" returncomment="the total number of characters read into the buffer, or
             &lt;code&gt;-1&lt;/code&gt; if there is no more data because the end of
             the stream has been reached." fulltype="int" type="int">
				<comment>
					<description>Reads up to &lt;code&gt;len&lt;/code&gt; characters of data from this piped
 stream into an array of characters. Less than &lt;code&gt;len&lt;/code&gt; characters
 will be read if the end of the data stream is reached or if
 &lt;code&gt;len&lt;/code&gt; exceeds the pipe&apos;s buffer size. This method
 blocks until at least one character of input is available.</description>
					<attribute name="@param">
						<description>cbuf     the buffer into which the data is read.</description>
					</attribute>
					<attribute name="@param">
						<description>off   the start offset of the data.</description>
					</attribute>
					<attribute name="@param">
						<description>len   the maximum number of characters read.</description>
					</attribute>
					<attribute name="@return">
						<description>the total number of characters read into the buffer, or
             &lt;code&gt;-1&lt;/code&gt; if there is no more data because the end of
             the stream has been reached.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if the pipe is
                  &lt;a href=PipedInputStream.html#BROKEN&gt; &lt;code&gt;broken&lt;/code&gt;&lt;/a&gt;,
                  {@link #connect(java.io.PipedWriter) unconnected}, closed,
                  or an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="cbuf" comment="the buffer into which the data is read." fulltype="char[]" type="char" />
					<param name="off" comment="the start offset of the data." fulltype="int" type="int" />
					<param name="len" comment="the maximum number of characters read." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if the pipe is
                  &lt;a href=PipedInputStream.html#BROKEN&gt; &lt;code&gt;broken&lt;/code&gt;&lt;/a&gt;,
                  {@link #connect(java.io.PipedWriter) unconnected}, closed,
                  or an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="public" name="ready" fulltype="boolean" type="boolean">
				<comment>
					<description>Tell whether this stream is ready to be read.  A piped character
 stream is ready if the circular buffer is not empty.</description>
					<attribute name="@exception">
						<description>IOException  if the pipe is
                  &lt;a href=PipedInputStream.html#BROKEN&gt; &lt;code&gt;broken&lt;/code&gt;&lt;/a&gt;,
                  {@link #connect(java.io.PipedWriter) unconnected}, or closed.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if the pipe is
                  &lt;a href=PipedInputStream.html#BROKEN&gt; &lt;code&gt;broken&lt;/code&gt;&lt;/a&gt;,
                  {@link #connect(java.io.PipedWriter) unconnected}, or closed." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="close" fulltype="void" type="void">
				<comment>
					<description>Closes this piped stream and releases any system resources
 associated with the stream.</description>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass abstract="true" visibility="public" package="java.io" interface="true" fulltype="java.io.ObjectInputValidation" type="ObjectInputValidation">
		<comment>
			<description>Callback interface to allow validation of objects within a graph.
 Allows an object to be called when a complete graph of objects has
 been deserialized.</description>
			<attribute name="@author">
				<description>unascribed</description>
			</attribute>
			<attribute name="@see">
				<description>ObjectInputStream</description>
			</attribute>
			<attribute name="@see">
				<description>ObjectInputStream#registerValidation(java.io.ObjectInputValidation, int)</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.1</description>
			</attribute>
		</comment>
		<methods>
			<method visibility="public" name="validateObject" fulltype="void" type="void">
				<comment>
					<description>Validates the object.</description>
					<attribute name="@exception">
						<description>InvalidObjectException If the object cannot validate itself.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If the object cannot validate itself." fulltype="java.io.InvalidObjectException" type="InvalidObjectException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass abstract="true" superclass="Object" visibility="public" package="java.io" superclassfulltype="java.lang.Object" fulltype="java.io.Reader" type="Reader">
		<implements>
			<interface fulltype="java.lang.Readable" type="Readable" />
			<interface fulltype="java.io.Closeable" type="Closeable" />
		</implements>
		<comment>
			<description>Abstract class for reading character streams.  The only methods that a
 subclass must implement are read(char[], int, int) and close().  Most
 subclasses, however, will override some of the methods defined here in order
 to provide higher efficiency, additional functionality, or both.</description>
			<attribute name="@see">
				<description>BufferedReader</description>
			</attribute>
			<attribute name="@see">
				<description>LineNumberReader</description>
			</attribute>
			<attribute name="@see">
				<description>CharArrayReader</description>
			</attribute>
			<attribute name="@see">
				<description>InputStreamReader</description>
			</attribute>
			<attribute name="@see">
				<description>FileReader</description>
			</attribute>
			<attribute name="@see">
				<description>FilterReader</description>
			</attribute>
			<attribute name="@see">
				<description>PushbackReader</description>
			</attribute>
			<attribute name="@see">
				<description>PipedReader</description>
			</attribute>
			<attribute name="@see">
				<description>StringReader</description>
			</attribute>
			<attribute name="@see">
				<description>Writer</description>
			</attribute>
			<attribute name="@author">
				<description>Mark Reinhold</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.1</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="protected" name="lock" fulltype="java.lang.Object" type="Object">
				<comment>
					<description>The object used to synchronize operations on this stream.  For
 efficiency, a character-stream object may use an object other than
 itself to protect critical sections.  A subclass should therefore use
 the object in this field rather than &lt;tt&gt;this&lt;/tt&gt; or a synchronized
 method.</description>
				</comment>
			</field>
			<field final="true" static="true" const="8192" visibility="private" name="maxSkipBufferSize" constexpr="8192" fulltype="int" type="int">
				<comment>
					<description>Maximum skip-buffer size</description>
				</comment>
			</field>
			<field visibility="private" name="skipBuffer" fulltype="char[]" type="char">
				<comment>
					<description>Skip buffer, null until allocated</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="protected" name="Reader">
				<comment>
					<description>Creates a new character-stream reader whose critical sections will
 synchronize on the reader itself.</description>
				</comment>
			</constructor>
			<constructor visibility="protected" name="Reader">
				<comment>
					<description>Creates a new character-stream reader whose critical sections will
 synchronize on the given object.</description>
					<attribute name="@param">
						<description>lock  The Object to synchronize on.</description>
					</attribute>
				</comment>
				<params>
					<param name="lock" comment="The Object to synchronize on." fulltype="java.lang.Object" type="Object" />
				</params>
			</constructor>
			<method visibility="public" name="read" returncomment="The number of characters added to the buffer, or
         -1 if this source of characters is at its end" fulltype="int" type="int">
				<comment>
					<description>Attempts to read characters into the specified character buffer.
 The buffer is used as a repository of characters as-is: the only
 changes made are the results of a put operation. No flipping or
 rewinding of the buffer is performed.</description>
					<attribute name="@param">
						<description>target the buffer to read characters into</description>
					</attribute>
					<attribute name="@return">
						<description>The number of characters added to the buffer, or
         -1 if this source of characters is at its end</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException if an I/O error occurs</description>
					</attribute>
					<attribute name="@throws">
						<description>NullPointerException if target is null</description>
					</attribute>
					<attribute name="@throws">
						<description>ReadOnlyBufferException if target is a read only buffer</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
				<params>
					<param name="target" comment="the buffer to read characters into" fulltype="java.nio.CharBuffer" type="CharBuffer" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="read" returncomment="The character read, as an integer in the range 0 to 65535
             (&lt;tt&gt;0x00-0xffff&lt;/tt&gt;), or -1 if the end of the stream has
             been reached" fulltype="int" type="int">
				<comment>
					<description>Reads a single character.  This method will block until a character is
 available, an I/O error occurs, or the end of the stream is reached.

 &lt;p&gt; Subclasses that intend to support efficient single-character input
 should override this method.</description>
					<attribute name="@return">
						<description>The character read, as an integer in the range 0 to 65535
             (&lt;tt&gt;0x00-0xffff&lt;/tt&gt;), or -1 if the end of the stream has
             been reached</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  If an I/O error occurs</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="read" returncomment="The number of characters read, or -1
              if the end of the stream
              has been reached" fulltype="int" type="int">
				<comment>
					<description>Reads characters into an array.  This method will block until some input
 is available, an I/O error occurs, or the end of the stream is reached.</description>
					<attribute name="@param">
						<description>cbuf  Destination buffer</description>
					</attribute>
					<attribute name="@return">
						<description>The number of characters read, or -1
              if the end of the stream
              has been reached</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  If an I/O error occurs</description>
					</attribute>
				</comment>
				<params>
					<param name="cbuf" comment="Destination buffer" fulltype="char[]" type="char" />
				</params>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="public" name="read" returncomment="The number of characters read, or -1 if the end of the
             stream has been reached" fulltype="int" type="int">
				<comment>
					<description>Reads characters into a portion of an array.  This method will block
 until some input is available, an I/O error occurs, or the end of the
 stream is reached.</description>
					<attribute name="@param">
						<description>cbuf  Destination buffer</description>
					</attribute>
					<attribute name="@param">
						<description>off   Offset at which to start storing characters</description>
					</attribute>
					<attribute name="@param">
						<description>len   Maximum number of characters to read</description>
					</attribute>
					<attribute name="@return">
						<description>The number of characters read, or -1 if the end of the
             stream has been reached</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  If an I/O error occurs</description>
					</attribute>
				</comment>
				<params>
					<param name="cbuf" comment="Destination buffer" fulltype="char[]" type="char" />
					<param name="off" comment="Offset at which to start storing characters" fulltype="int" type="int" />
					<param name="len" comment="Maximum number of characters to read" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="skip" returncomment="The number of characters actually skipped" fulltype="long" type="long">
				<comment>
					<description>Skips characters.  This method will block until some characters are
 available, an I/O error occurs, or the end of the stream is reached.</description>
					<attribute name="@param">
						<description>n  The number of characters to skip</description>
					</attribute>
					<attribute name="@return">
						<description>The number of characters actually skipped</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException  If &lt;code&gt;n&lt;/code&gt; is negative.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  If an I/O error occurs</description>
					</attribute>
				</comment>
				<params>
					<param name="n" comment="The number of characters to skip" fulltype="long" type="long" />
				</params>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="ready" returncomment="True if the next read() is guaranteed not to block for input,
 false otherwise.  Note that returning false does not guarantee that the
 next read will block." fulltype="boolean" type="boolean">
				<comment>
					<description>Tells whether this stream is ready to be read.</description>
					<attribute name="@return">
						<description>True if the next read() is guaranteed not to block for input,
 false otherwise.  Note that returning false does not guarantee that the
 next read will block.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  If an I/O error occurs</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="markSupported" returncomment="true if and only if this stream supports the mark operation." fulltype="boolean" type="boolean">
				<comment>
					<description>Tells whether this stream supports the mark() operation. The default
 implementation always returns false. Subclasses should override this
 method.</description>
					<attribute name="@return">
						<description>true if and only if this stream supports the mark operation.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="mark" fulltype="void" type="void">
				<comment>
					<description>Marks the present position in the stream.  Subsequent calls to reset()
 will attempt to reposition the stream to this point.  Not all
 character-input streams support the mark() operation.</description>
					<attribute name="@param">
						<description>readAheadLimit  Limit on the number of characters that may be
                         read while still preserving the mark.  After
                         reading this many characters, attempting to
                         reset the stream may fail.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  If the stream does not support mark(),
                          or if some other I/O error occurs</description>
					</attribute>
				</comment>
				<params>
					<param name="readAheadLimit" comment="Limit on the number of characters that may be
                         read while still preserving the mark.  After
                         reading this many characters, attempting to
                         reset the stream may fail." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="If the stream does not support mark(),
                          or if some other I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="reset" fulltype="void" type="void">
				<comment>
					<description>Resets the stream.  If the stream has been marked, then attempt to
 reposition it at the mark.  If the stream has not been marked, then
 attempt to reset it in some way appropriate to the particular stream,
 for example by repositioning it to its starting point.  Not all
 character-input streams support the reset() operation, and some support
 reset() without supporting mark().</description>
					<attribute name="@exception">
						<description>IOException  If the stream has not been marked,
                          or if the mark has been invalidated,
                          or if the stream does not support reset(),
                          or if some other I/O error occurs</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If the stream has not been marked,
                          or if the mark has been invalidated,
                          or if the stream does not support reset(),
                          or if some other I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="public" name="close" fulltype="void" type="void">
				<comment>
					<description>Closes the stream and releases any system resources associated with
 it.  Once the stream has been closed, further read(), ready(),
 mark(), reset(), or skip() invocations will throw an IOException.
 Closing a previously closed stream has no effect.</description>
					<attribute name="@exception">
						<description>IOException  If an I/O error occurs</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="ObjectStreamException" visibility="public" package="java.io" serializable="true" superclassfulltype="java.io.ObjectStreamException" fulltype="java.io.InvalidClassException" type="InvalidClassException">
		<comment>
			<description>Thrown when the Serialization runtime detects one of the following
 problems with a Class.
 &lt;UL&gt;
 &lt;LI&gt; The serial version of the class does not match that of the class
      descriptor read from the stream
 &lt;LI&gt; The class contains unknown datatypes
 &lt;LI&gt; The class does not have an accessible no-arg constructor
 &lt;/UL&gt;</description>
			<attribute name="@author">
				<description>unascribed</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.1</description>
			</attribute>
		</comment>
		<fields>
			<field final="true" static="true" const="-4333316296251054416" visibility="private" name="serialVersionUID" constexpr="-4333316296251054416L" fulltype="long" type="long" />
			<field visibility="public" name="classname" fulltype="java.lang.String" type="String">
				<comment>
					<description>Name of the invalid class.</description>
					<attribute name="@serial">
						<description>Name of the invalid class.</description>
					</attribute>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="public" name="InvalidClassException">
				<comment>
					<description>Report an InvalidClassException for the reason specified.</description>
					<attribute name="@param">
						<description>reason  String describing the reason for the exception.</description>
					</attribute>
				</comment>
				<params>
					<param name="reason" comment="String describing the reason for the exception." fulltype="java.lang.String" type="String" />
				</params>
			</constructor>
			<constructor visibility="public" name="InvalidClassException">
				<comment>
					<description>Constructs an InvalidClassException object.</description>
					<attribute name="@param">
						<description>cname   a String naming the invalid class.</description>
					</attribute>
					<attribute name="@param">
						<description>reason  a String describing the reason for the exception.</description>
					</attribute>
				</comment>
				<params>
					<param name="cname" comment="a String naming the invalid class." fulltype="java.lang.String" type="String" />
					<param name="reason" comment="a String describing the reason for the exception." fulltype="java.lang.String" type="String" />
				</params>
			</constructor>
			<method visibility="public" name="getMessage" fulltype="java.lang.String" type="String">
				<comment>
					<description>Produce the message and include the classname, if present.</description>
				</comment>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="IOException" visibility="public" package="java.io" serializable="true" superclassfulltype="java.io.IOException" fulltype="java.io.UTFDataFormatException" type="UTFDataFormatException">
		<comment>
			<description>Signals that a malformed string in
 &lt;a href=&quot;DataInput.html#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt;
 format has been read in a data
 input stream or by any class that implements the data input
 interface.
 See the
 &lt;a href=&quot;DataInput.html#modified-utf-8&quot;&gt;&lt;code&gt;DataInput&lt;/code&gt;&lt;/a&gt;
 class description for the format in
 which modified UTF-8 strings are read and written.</description>
			<attribute name="@author">
				<description>Frank Yellin</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.DataInput</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.DataInputStream#readUTF(java.io.DataInput)</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.IOException</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.0</description>
			</attribute>
		</comment>
		<methods>
			<constructor visibility="public" name="UTFDataFormatException">
				<comment>
					<description>Constructs a &lt;code&gt;UTFDataFormatException&lt;/code&gt; with
 &lt;code&gt;null&lt;/code&gt; as its error detail message.</description>
				</comment>
			</constructor>
			<constructor visibility="public" name="UTFDataFormatException">
				<comment>
					<description>Constructs a &lt;code&gt;UTFDataFormatException&lt;/code&gt; with the
 specified detail message. The string &lt;code&gt;s&lt;/code&gt; can be
 retrieved later by the
 &lt;code&gt;{@link java.lang.Throwable#getMessage}&lt;/code&gt;
 method of class &lt;code&gt;java.lang.Throwable&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>s   the detail message.</description>
					</attribute>
				</comment>
				<params>
					<param name="s" comment="the detail message." fulltype="java.lang.String" type="String" />
				</params>
			</constructor>
		</methods>
	</jelclass>
	<jelclass superclass="Writer" visibility="public" package="java.io" superclassfulltype="java.io.Writer" fulltype="java.io.CharArrayWriter" type="CharArrayWriter">
		<comment>
			<description>This class implements a character buffer that can be used as an Writer.
 The buffer automatically grows when data is written to the stream.  The data
 can be retrieved using toCharArray() and toString().
 &lt;P&gt;
 Note: Invoking close() on this class has no effect, and methods
 of this class can be called after the stream has closed
 without generating an IOException.</description>
			<attribute name="@author">
				<description>Herb Jellinek</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.1</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="protected" name="buf" fulltype="char[]" type="char">
				<comment>
					<description>The buffer where data is stored.</description>
				</comment>
			</field>
			<field visibility="protected" name="count" fulltype="int" type="int">
				<comment>
					<description>The number of chars in the buffer.</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="public" name="CharArrayWriter">
				<comment>
					<description>Creates a new CharArrayWriter.</description>
				</comment>
			</constructor>
			<constructor visibility="public" name="CharArrayWriter">
				<comment>
					<description>Creates a new CharArrayWriter with the specified initial size.</description>
					<attribute name="@param">
						<description>initialSize  an int specifying the initial buffer size.</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if initialSize is negative</description>
					</attribute>
				</comment>
				<params>
					<param name="initialSize" comment="an int specifying the initial buffer size." fulltype="int" type="int" />
				</params>
			</constructor>
			<method visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes a character to the buffer.</description>
				</comment>
				<params>
					<param name="c" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes characters to the buffer.</description>
					<attribute name="@param">
						<description>c the data to be written</description>
					</attribute>
					<attribute name="@param">
						<description>off       the start offset in the data</description>
					</attribute>
					<attribute name="@param">
						<description>len       the number of chars that are written</description>
					</attribute>
				</comment>
				<params>
					<param name="c" comment="the data to be written" fulltype="char[]" type="char" />
					<param name="off" comment="the start offset in the data" fulltype="int" type="int" />
					<param name="len" comment="the number of chars that are written" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Write a portion of a string to the buffer.</description>
					<attribute name="@param">
						<description>str  String to be written from</description>
					</attribute>
					<attribute name="@param">
						<description>off  Offset from which to start reading characters</description>
					</attribute>
					<attribute name="@param">
						<description>len  Number of characters to be written</description>
					</attribute>
				</comment>
				<params>
					<param name="str" comment="String to be written from" fulltype="java.lang.String" type="String" />
					<param name="off" comment="Offset from which to start reading characters" fulltype="int" type="int" />
					<param name="len" comment="Number of characters to be written" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="writeTo" fulltype="void" type="void">
				<comment>
					<description>Writes the contents of the buffer to another character stream.</description>
					<attribute name="@param">
						<description>out       the output stream to write to</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException If an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="out" comment="the output stream to write to" fulltype="java.io.Writer" type="Writer" />
				</params>
				<exceptions>
					<exception comment="If an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="append" returncomment="This writer" fulltype="java.io.CharArrayWriter" type="CharArrayWriter">
				<comment>
					<description>Appends the specified character sequence to this writer.

 &lt;p&gt; An invocation of this method of the form &lt;tt&gt;out.append(csq)&lt;/tt&gt;
 behaves in exactly the same way as the invocation

 &lt;pre&gt;
     out.write(csq.toString()) &lt;/pre&gt;

 &lt;p&gt; Depending on the specification of &lt;tt&gt;toString&lt;/tt&gt; for the
 character sequence &lt;tt&gt;csq&lt;/tt&gt;, the entire sequence may not be
 appended. For instance, invoking the &lt;tt&gt;toString&lt;/tt&gt; method of a
 character buffer will return a subsequence whose content depends upon
 the buffer&apos;s position and limit.</description>
					<attribute name="@param">
						<description>csq
         The character sequence to append.  If &lt;tt&gt;csq&lt;/tt&gt; is
         &lt;tt&gt;null&lt;/tt&gt;, then the four characters &lt;tt&gt;&quot;null&quot;&lt;/tt&gt; are
         appended to this writer.</description>
					</attribute>
					<attribute name="@return">
						<description>This writer</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
				<params>
					<param name="csq" comment="The character sequence to append.  If &lt;tt&gt;csq&lt;/tt&gt; is
         &lt;tt&gt;null&lt;/tt&gt;, then the four characters &lt;tt&gt;&quot;null&quot;&lt;/tt&gt; are
         appended to this writer." fulltype="java.lang.CharSequence" type="CharSequence" />
				</params>
			</method>
			<method visibility="public" name="append" returncomment="This writer" fulltype="java.io.CharArrayWriter" type="CharArrayWriter">
				<comment>
					<description>Appends a subsequence of the specified character sequence to this writer.

 &lt;p&gt; An invocation of this method of the form &lt;tt&gt;out.append(csq, start,
 end)&lt;/tt&gt; when &lt;tt&gt;csq&lt;/tt&gt; is not &lt;tt&gt;null&lt;/tt&gt;, behaves in
 exactly the same way as the invocation

 &lt;pre&gt;
     out.write(csq.subSequence(start, end).toString()) &lt;/pre&gt;</description>
					<attribute name="@param">
						<description>csq
         The character sequence from which a subsequence will be
         appended.  If &lt;tt&gt;csq&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;, then characters
         will be appended as if &lt;tt&gt;csq&lt;/tt&gt; contained the four
         characters &lt;tt&gt;&quot;null&quot;&lt;/tt&gt;.</description>
					</attribute>
					<attribute name="@param">
						<description>start
         The index of the first character in the subsequence</description>
					</attribute>
					<attribute name="@param">
						<description>end
         The index of the character following the last character in the
         subsequence</description>
					</attribute>
					<attribute name="@return">
						<description>This writer</description>
					</attribute>
					<attribute name="@throws">
						<description>IndexOutOfBoundsException
          If &lt;tt&gt;start&lt;/tt&gt; or &lt;tt&gt;end&lt;/tt&gt; are negative, &lt;tt&gt;start&lt;/tt&gt;
          is greater than &lt;tt&gt;end&lt;/tt&gt;, or &lt;tt&gt;end&lt;/tt&gt; is greater than
          &lt;tt&gt;csq.length()&lt;/tt&gt;</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
				<params>
					<param name="csq" comment="The character sequence from which a subsequence will be
         appended.  If &lt;tt&gt;csq&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;, then characters
         will be appended as if &lt;tt&gt;csq&lt;/tt&gt; contained the four
         characters &lt;tt&gt;&quot;null&quot;&lt;/tt&gt;." fulltype="java.lang.CharSequence" type="CharSequence" />
					<param name="start" comment="The index of the first character in the subsequence" fulltype="int" type="int" />
					<param name="end" comment="The index of the character following the last character in the
         subsequence" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="append" returncomment="This writer" fulltype="java.io.CharArrayWriter" type="CharArrayWriter">
				<comment>
					<description>Appends the specified character to this writer.

 &lt;p&gt; An invocation of this method of the form &lt;tt&gt;out.append(c)&lt;/tt&gt;
 behaves in exactly the same way as the invocation

 &lt;pre&gt;
     out.write(c) &lt;/pre&gt;</description>
					<attribute name="@param">
						<description>c
         The 16-bit character to append</description>
					</attribute>
					<attribute name="@return">
						<description>This writer</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
				<params>
					<param name="c" comment="The 16-bit character to append" fulltype="char" type="char" />
				</params>
			</method>
			<method visibility="public" name="reset" fulltype="void" type="void">
				<comment>
					<description>Resets the buffer so that you can use it again without
 throwing away the already allocated buffer.</description>
				</comment>
			</method>
			<method visibility="public" name="toCharArray" returncomment="an array of chars copied from the input data." fulltype="char[]" type="char">
				<comment>
					<description>Returns a copy of the input data.</description>
					<attribute name="@return">
						<description>an array of chars copied from the input data.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="size" returncomment="an int representing the current size of the buffer." fulltype="int" type="int">
				<comment>
					<description>Returns the current size of the buffer.</description>
					<attribute name="@return">
						<description>an int representing the current size of the buffer.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="toString" returncomment="the string." fulltype="java.lang.String" type="String">
				<comment>
					<description>Converts input data to a string.</description>
					<attribute name="@return">
						<description>the string.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="flush" fulltype="void" type="void">
				<comment>
					<description>Flush the stream.</description>
				</comment>
			</method>
			<method visibility="public" name="close" fulltype="void" type="void">
				<comment>
					<description>Close the stream.  This method does not release the buffer, since its
 contents might still be required. Note: Invoking this method in this class
 will have no effect.</description>
				</comment>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="FilterOutputStream" visibility="public" package="java.io" superclassfulltype="java.io.FilterOutputStream" fulltype="java.io.PrintStream" type="PrintStream">
		<implements>
			<interface fulltype="java.lang.Appendable" type="Appendable" />
			<interface fulltype="java.io.Closeable" type="Closeable" />
		</implements>
		<comment>
			<description>A &lt;code&gt;PrintStream&lt;/code&gt; adds functionality to another output stream,
 namely the ability to print representations of various data values
 conveniently.  Two other features are provided as well.  Unlike other output
 streams, a &lt;code&gt;PrintStream&lt;/code&gt; never throws an
 &lt;code&gt;IOException&lt;/code&gt;; instead, exceptional situations merely set an
 internal flag that can be tested via the &lt;code&gt;checkError&lt;/code&gt; method.
 Optionally, a &lt;code&gt;PrintStream&lt;/code&gt; can be created so as to flush
 automatically; this means that the &lt;code&gt;flush&lt;/code&gt; method is
 automatically invoked after a byte array is written, one of the
 &lt;code&gt;println&lt;/code&gt; methods is invoked, or a newline character or byte
 (&lt;code&gt;&apos;\n&apos;&lt;/code&gt;) is written.

 &lt;p&gt; All characters printed by a &lt;code&gt;PrintStream&lt;/code&gt; are converted into
 bytes using the platform&apos;s default character encoding.  The &lt;code&gt;{@link
 PrintWriter}&lt;/code&gt; class should be used in situations that require writing
 characters rather than bytes.</description>
			<attribute name="@author">
				<description>Frank Yellin</description>
			</attribute>
			<attribute name="@author">
				<description>Mark Reinhold</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.0</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="private" name="autoFlush" fulltype="boolean" type="boolean" />
			<field visibility="private" name="trouble" fulltype="boolean" type="boolean" />
			<field visibility="private" name="formatter" fulltype="java.util.Formatter" type="Formatter" />
			<field visibility="private" name="textOut" fulltype="java.io.BufferedWriter" type="BufferedWriter">
				<comment>
					<description>Track both the text- and character-output streams, so that their buffers
 can be flushed without flushing the entire stream.</description>
				</comment>
			</field>
			<field visibility="private" name="charOut" fulltype="java.io.OutputStreamWriter" type="OutputStreamWriter" />
			<field visibility="private" name="closing" fulltype="boolean" type="boolean" />
		</fields>
		<methods>
			<constructor visibility="public" name="PrintStream">
				<comment>
					<description>Creates a new print stream.  This stream will not flush automatically.</description>
					<attribute name="@param">
						<description>out        The output stream to which values and objects will be
                    printed</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.PrintWriter#PrintWriter(java.io.OutputStream)</description>
					</attribute>
				</comment>
				<params>
					<param name="out" comment="The output stream to which values and objects will be
                    printed" fulltype="java.io.OutputStream" type="OutputStream" />
				</params>
			</constructor>
			<constructor visibility="private" name="PrintStream">
				<params>
					<param name="autoFlush" fulltype="boolean" type="boolean" />
					<param name="out" fulltype="java.io.OutputStream" type="OutputStream" />
				</params>
			</constructor>
			<constructor visibility="public" name="PrintStream">
				<comment>
					<description>Creates a new print stream.</description>
					<attribute name="@param">
						<description>out        The output stream to which values and objects will be
                    printed</description>
					</attribute>
					<attribute name="@param">
						<description>autoFlush  A boolean; if true, the output buffer will be flushed
                    whenever a byte array is written, one of the
                    &lt;code&gt;println&lt;/code&gt; methods is invoked, or a newline
                    character or byte (&lt;code&gt;&apos;\n&apos;&lt;/code&gt;) is written</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.PrintWriter#PrintWriter(java.io.OutputStream, boolean)</description>
					</attribute>
				</comment>
				<params>
					<param name="out" comment="The output stream to which values and objects will be
                    printed" fulltype="java.io.OutputStream" type="OutputStream" />
					<param name="autoFlush" comment="A boolean; if true, the output buffer will be flushed
                    whenever a byte array is written, one of the
                    &lt;code&gt;println&lt;/code&gt; methods is invoked, or a newline
                    character or byte (&lt;code&gt;&apos;\n&apos;&lt;/code&gt;) is written" fulltype="boolean" type="boolean" />
				</params>
			</constructor>
			<constructor visibility="public" name="PrintStream">
				<comment>
					<description>Creates a new print stream.</description>
					<attribute name="@param">
						<description>out        The output stream to which values and objects will be
                    printed</description>
					</attribute>
					<attribute name="@param">
						<description>autoFlush  A boolean; if true, the output buffer will be flushed
                    whenever a byte array is written, one of the
                    &lt;code&gt;println&lt;/code&gt; methods is invoked, or a newline
                    character or byte (&lt;code&gt;&apos;\n&apos;&lt;/code&gt;) is written</description>
					</attribute>
					<attribute name="@param">
						<description>encoding   The name of a supported
                    &lt;a href=&quot;../lang/package-summary.html#charenc&quot;&gt;
                    character encoding&lt;/a&gt;</description>
					</attribute>
					<attribute name="@throws">
						<description>UnsupportedEncodingException
          If the named encoding is not supported</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
				<params>
					<param name="out" comment="The output stream to which values and objects will be
                    printed" fulltype="java.io.OutputStream" type="OutputStream" />
					<param name="autoFlush" comment="A boolean; if true, the output buffer will be flushed
                    whenever a byte array is written, one of the
                    &lt;code&gt;println&lt;/code&gt; methods is invoked, or a newline
                    character or byte (&lt;code&gt;&apos;\n&apos;&lt;/code&gt;) is written" fulltype="boolean" type="boolean" />
					<param name="encoding" comment="The name of a supported
                    &lt;a href=&quot;../lang/package-summary.html#charenc&quot;&gt;
                    character encoding&lt;/a&gt;" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception comment="If the named encoding is not supported" fulltype="java.io.UnsupportedEncodingException" type="UnsupportedEncodingException" />
				</exceptions>
			</constructor>
			<constructor visibility="public" name="PrintStream">
				<comment>
					<description>Creates a new print stream, without automatic line flushing, with the
 specified file name.  This convenience constructor creates
 the necessary intermediate {@link java.io.OutputStreamWriter
 OutputStreamWriter}, which will encode characters using the
 {@linkplain java.nio.charset.Charset#defaultCharset() default charset}
 for this instance of the Java virtual machine.</description>
					<attribute name="@param">
						<description>fileName
         The name of the file to use as the destination of this print
         stream.  If the file exists, then it will be truncated to
         zero size; otherwise, a new file will be created.  The output
         will be written to the file and is buffered.</description>
					</attribute>
					<attribute name="@throws">
						<description>FileNotFoundException
          If the given file object does not denote an existing, writable
          regular file and a new regular file of that name cannot be
          created, or if some other error occurs while opening or
          creating the file</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException
          If a security manager is present and {@link
          SecurityManager#checkWrite checkWrite(fileName)} denies write
          access to the file</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
				<params>
					<param name="fileName" comment="The name of the file to use as the destination of this print
         stream.  If the file exists, then it will be truncated to
         zero size; otherwise, a new file will be created.  The output
         will be written to the file and is buffered." fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception comment="If the given file object does not denote an existing, writable
          regular file and a new regular file of that name cannot be
          created, or if some other error occurs while opening or
          creating the file" fulltype="java.io.FileNotFoundException" type="FileNotFoundException" />
				</exceptions>
			</constructor>
			<constructor visibility="public" name="PrintStream">
				<comment>
					<description>Creates a new print stream, without automatic line flushing, with the
 specified file name and charset.  This convenience constructor creates
 the necessary intermediate {@link java.io.OutputStreamWriter
 OutputStreamWriter}, which will encode characters using the provided
 charset.</description>
					<attribute name="@param">
						<description>fileName
         The name of the file to use as the destination of this print
         stream.  If the file exists, then it will be truncated to
         zero size; otherwise, a new file will be created.  The output
         will be written to the file and is buffered.</description>
					</attribute>
					<attribute name="@param">
						<description>csn
         The name of a supported {@linkplain java.nio.charset.Charset
         charset}</description>
					</attribute>
					<attribute name="@throws">
						<description>FileNotFoundException
          If the given file object does not denote an existing, writable
          regular file and a new regular file of that name cannot be
          created, or if some other error occurs while opening or
          creating the file</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException
          If a security manager is present and {@link
          SecurityManager#checkWrite checkWrite(fileName)} denies write
          access to the file</description>
					</attribute>
					<attribute name="@throws">
						<description>UnsupportedEncodingException
          If the named charset is not supported</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
				<params>
					<param name="fileName" comment="The name of the file to use as the destination of this print
         stream.  If the file exists, then it will be truncated to
         zero size; otherwise, a new file will be created.  The output
         will be written to the file and is buffered." fulltype="java.lang.String" type="String" />
					<param name="csn" comment="The name of a supported {@linkplain java.nio.charset.Charset
         charset}" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception comment="If the given file object does not denote an existing, writable
          regular file and a new regular file of that name cannot be
          created, or if some other error occurs while opening or
          creating the file" fulltype="java.io.FileNotFoundException" type="FileNotFoundException" />
					<exception comment="If the named charset is not supported" fulltype="java.io.UnsupportedEncodingException" type="UnsupportedEncodingException" />
				</exceptions>
			</constructor>
			<constructor visibility="public" name="PrintStream">
				<comment>
					<description>Creates a new print stream, without automatic line flushing, with the
 specified file.  This convenience constructor creates the necessary
 intermediate {@link java.io.OutputStreamWriter OutputStreamWriter},
 which will encode characters using the {@linkplain
 java.nio.charset.Charset#defaultCharset() default charset} for this
 instance of the Java virtual machine.</description>
					<attribute name="@param">
						<description>file
         The file to use as the destination of this print stream.  If the
         file exists, then it will be truncated to zero size; otherwise,
         a new file will be created.  The output will be written to the
         file and is buffered.</description>
					</attribute>
					<attribute name="@throws">
						<description>FileNotFoundException
          If the given file object does not denote an existing, writable
          regular file and a new regular file of that name cannot be
          created, or if some other error occurs while opening or
          creating the file</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException
          If a security manager is present and {@link
          SecurityManager#checkWrite checkWrite(file.getPath())}
          denies write access to the file</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
				<params>
					<param name="file" comment="The file to use as the destination of this print stream.  If the
         file exists, then it will be truncated to zero size; otherwise,
         a new file will be created.  The output will be written to the
         file and is buffered." fulltype="java.io.File" type="File" />
				</params>
				<exceptions>
					<exception comment="If the given file object does not denote an existing, writable
          regular file and a new regular file of that name cannot be
          created, or if some other error occurs while opening or
          creating the file" fulltype="java.io.FileNotFoundException" type="FileNotFoundException" />
				</exceptions>
			</constructor>
			<constructor visibility="public" name="PrintStream">
				<comment>
					<description>Creates a new print stream, without automatic line flushing, with the
 specified file and charset.  This convenience constructor creates
 the necessary intermediate {@link java.io.OutputStreamWriter
 OutputStreamWriter}, which will encode characters using the provided
 charset.</description>
					<attribute name="@param">
						<description>file
         The file to use as the destination of this print stream.  If the
         file exists, then it will be truncated to zero size; otherwise,
         a new file will be created.  The output will be written to the
         file and is buffered.</description>
					</attribute>
					<attribute name="@param">
						<description>csn
         The name of a supported {@linkplain java.nio.charset.Charset
         charset}</description>
					</attribute>
					<attribute name="@throws">
						<description>FileNotFoundException
          If the given file object does not denote an existing, writable
          regular file and a new regular file of that name cannot be
          created, or if some other error occurs while opening or
          creating the file</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException
          If a security manager is presentand {@link
          SecurityManager#checkWrite checkWrite(file.getPath())}
          denies write access to the file</description>
					</attribute>
					<attribute name="@throws">
						<description>UnsupportedEncodingException
          If the named charset is not supported</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
				<params>
					<param name="file" comment="The file to use as the destination of this print stream.  If the
         file exists, then it will be truncated to zero size; otherwise,
         a new file will be created.  The output will be written to the
         file and is buffered." fulltype="java.io.File" type="File" />
					<param name="csn" comment="The name of a supported {@linkplain java.nio.charset.Charset
         charset}" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception comment="If the given file object does not denote an existing, writable
          regular file and a new regular file of that name cannot be
          created, or if some other error occurs while opening or
          creating the file" fulltype="java.io.FileNotFoundException" type="FileNotFoundException" />
					<exception comment="If the named charset is not supported" fulltype="java.io.UnsupportedEncodingException" type="UnsupportedEncodingException" />
				</exceptions>
			</constructor>
			<method visibility="private" name="init" fulltype="void" type="void">
				<params>
					<param name="osw" fulltype="java.io.OutputStreamWriter" type="OutputStreamWriter" />
				</params>
			</method>
			<method visibility="private" name="ensureOpen" fulltype="void" type="void">
				<comment>
					<description>Check to make sure that the stream has not been closed</description>
				</comment>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="flush" fulltype="void" type="void">
				<comment>
					<description>Flushes the stream.  This is done by writing any buffered output bytes to
 the underlying output stream and then flushing that stream.</description>
					<attribute name="@see">
						<description>java.io.OutputStream#flush()</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="close" fulltype="void" type="void">
				<comment>
					<description>Closes the stream.  This is done by flushing the stream and then closing
 the underlying output stream.</description>
					<attribute name="@see">
						<description>java.io.OutputStream#close()</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="checkError" returncomment="&lt;code&gt;true&lt;/code&gt; if and only if this stream has encountered an
         &lt;code&gt;IOException&lt;/code&gt; other than
         &lt;code&gt;InterruptedIOException&lt;/code&gt;, or the
         &lt;code&gt;setError&lt;/code&gt; method has been invoked" fulltype="boolean" type="boolean">
				<comment>
					<description>Flushes the stream and checks its error state. The internal error state
 is set to &lt;code&gt;true&lt;/code&gt; when the underlying output stream throws an
 &lt;code&gt;IOException&lt;/code&gt; other than &lt;code&gt;InterruptedIOException&lt;/code&gt;,
 and when the &lt;code&gt;setError&lt;/code&gt; method is invoked.  If an operation
 on the underlying output stream throws an
 &lt;code&gt;InterruptedIOException&lt;/code&gt;, then the &lt;code&gt;PrintStream&lt;/code&gt;
 converts the exception back into an interrupt by doing:
 &lt;pre&gt;
     Thread.currentThread().interrupt();
 &lt;/pre&gt;
 or the equivalent.</description>
					<attribute name="@return">
						<description>&lt;code&gt;true&lt;/code&gt; if and only if this stream has encountered an
         &lt;code&gt;IOException&lt;/code&gt; other than
         &lt;code&gt;InterruptedIOException&lt;/code&gt;, or the
         &lt;code&gt;setError&lt;/code&gt; method has been invoked</description>
					</attribute>
				</comment>
			</method>
			<method visibility="protected" name="setError" fulltype="void" type="void">
				<comment>
					<description>Sets the error state of the stream to &lt;code&gt;true&lt;/code&gt;.

 &lt;p&gt; This method will cause subsequent invocations of {@link
 #checkError()} to return &lt;tt&gt;true&lt;/tt&gt; until {@link
 #clearError()} is invoked.</description>
					<attribute name="@since">
						<description>JDK1.1</description>
					</attribute>
				</comment>
			</method>
			<method visibility="protected" name="clearError" fulltype="void" type="void">
				<comment>
					<description>Clears the internal error state of this stream.

 &lt;p&gt; This method will cause subsequent invocations of {@link
 #checkError()} to return &lt;tt&gt;false&lt;/tt&gt; until another write
 operation fails and invokes {@link #setError()}.</description>
					<attribute name="@since">
						<description>1.6</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes the specified byte to this stream.  If the byte is a newline and
 automatic flushing is enabled then the &lt;code&gt;flush&lt;/code&gt; method will be
 invoked.

 &lt;p&gt; Note that the byte is written as given; to write a character that
 will be translated according to the platform&apos;s default character
 encoding, use the &lt;code&gt;print(char)&lt;/code&gt; or &lt;code&gt;println(char)&lt;/code&gt;
 methods.</description>
					<attribute name="@param">
						<description>b  The byte to be written</description>
					</attribute>
					<attribute name="@see">
						<description>#print(char)</description>
					</attribute>
					<attribute name="@see">
						<description>#println(char)</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="The byte to be written" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes &lt;code&gt;len&lt;/code&gt; bytes from the specified byte array starting at
 offset &lt;code&gt;off&lt;/code&gt; to this stream.  If automatic flushing is
 enabled then the &lt;code&gt;flush&lt;/code&gt; method will be invoked.

 &lt;p&gt; Note that the bytes will be written as given; to write characters
 that will be translated according to the platform&apos;s default character
 encoding, use the &lt;code&gt;print(char)&lt;/code&gt; or &lt;code&gt;println(char)&lt;/code&gt;
 methods.</description>
					<attribute name="@param">
						<description>buf   A byte array</description>
					</attribute>
					<attribute name="@param">
						<description>off   Offset from which to start taking bytes</description>
					</attribute>
					<attribute name="@param">
						<description>len   Number of bytes to write</description>
					</attribute>
				</comment>
				<params>
					<param name="buf" comment="A byte array" fulltype="byte[]" type="byte" />
					<param name="off" comment="Offset from which to start taking bytes" fulltype="int" type="int" />
					<param name="len" comment="Number of bytes to write" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="private" name="write" fulltype="void" type="void">
				<params>
					<param name="buf" fulltype="char[]" type="char" />
				</params>
			</method>
			<method visibility="private" name="write" fulltype="void" type="void">
				<params>
					<param name="s" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="private" name="newLine" fulltype="void" type="void" />
			<method visibility="public" name="print" fulltype="void" type="void">
				<comment>
					<description>Prints a boolean value.  The string produced by &lt;code&gt;{@link
 java.lang.String#valueOf(boolean)}&lt;/code&gt; is translated into bytes
 according to the platform&apos;s default character encoding, and these bytes
 are written in exactly the manner of the
 &lt;code&gt;{@link #write(int)}&lt;/code&gt; method.</description>
					<attribute name="@param">
						<description>b   The &lt;code&gt;boolean&lt;/code&gt; to be printed</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="The &lt;code&gt;boolean&lt;/code&gt; to be printed" fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method visibility="public" name="print" fulltype="void" type="void">
				<comment>
					<description>Prints a character.  The character is translated into one or more bytes
 according to the platform&apos;s default character encoding, and these bytes
 are written in exactly the manner of the
 &lt;code&gt;{@link #write(int)}&lt;/code&gt; method.</description>
					<attribute name="@param">
						<description>c   The &lt;code&gt;char&lt;/code&gt; to be printed</description>
					</attribute>
				</comment>
				<params>
					<param name="c" comment="The &lt;code&gt;char&lt;/code&gt; to be printed" fulltype="char" type="char" />
				</params>
			</method>
			<method visibility="public" name="print" fulltype="void" type="void">
				<comment>
					<description>Prints an integer.  The string produced by &lt;code&gt;{@link
 java.lang.String#valueOf(int)}&lt;/code&gt; is translated into bytes
 according to the platform&apos;s default character encoding, and these bytes
 are written in exactly the manner of the
 &lt;code&gt;{@link #write(int)}&lt;/code&gt; method.</description>
					<attribute name="@param">
						<description>i   The &lt;code&gt;int&lt;/code&gt; to be printed</description>
					</attribute>
					<attribute name="@see">
						<description>java.lang.Integer#toString(int)</description>
					</attribute>
				</comment>
				<params>
					<param name="i" comment="The &lt;code&gt;int&lt;/code&gt; to be printed" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="print" fulltype="void" type="void">
				<comment>
					<description>Prints a long integer.  The string produced by &lt;code&gt;{@link
 java.lang.String#valueOf(long)}&lt;/code&gt; is translated into bytes
 according to the platform&apos;s default character encoding, and these bytes
 are written in exactly the manner of the
 &lt;code&gt;{@link #write(int)}&lt;/code&gt; method.</description>
					<attribute name="@param">
						<description>l   The &lt;code&gt;long&lt;/code&gt; to be printed</description>
					</attribute>
					<attribute name="@see">
						<description>java.lang.Long#toString(long)</description>
					</attribute>
				</comment>
				<params>
					<param name="l" comment="The &lt;code&gt;long&lt;/code&gt; to be printed" fulltype="long" type="long" />
				</params>
			</method>
			<method visibility="public" name="print" fulltype="void" type="void">
				<comment>
					<description>Prints a floating-point number.  The string produced by &lt;code&gt;{@link
 java.lang.String#valueOf(float)}&lt;/code&gt; is translated into bytes
 according to the platform&apos;s default character encoding, and these bytes
 are written in exactly the manner of the
 &lt;code&gt;{@link #write(int)}&lt;/code&gt; method.</description>
					<attribute name="@param">
						<description>f   The &lt;code&gt;float&lt;/code&gt; to be printed</description>
					</attribute>
					<attribute name="@see">
						<description>java.lang.Float#toString(float)</description>
					</attribute>
				</comment>
				<params>
					<param name="f" comment="The &lt;code&gt;float&lt;/code&gt; to be printed" fulltype="float" type="float" />
				</params>
			</method>
			<method visibility="public" name="print" fulltype="void" type="void">
				<comment>
					<description>Prints a double-precision floating-point number.  The string produced by
 &lt;code&gt;{@link java.lang.String#valueOf(double)}&lt;/code&gt; is translated into
 bytes according to the platform&apos;s default character encoding, and these
 bytes are written in exactly the manner of the &lt;code&gt;{@link
 #write(int)}&lt;/code&gt; method.</description>
					<attribute name="@param">
						<description>d   The &lt;code&gt;double&lt;/code&gt; to be printed</description>
					</attribute>
					<attribute name="@see">
						<description>java.lang.Double#toString(double)</description>
					</attribute>
				</comment>
				<params>
					<param name="d" comment="The &lt;code&gt;double&lt;/code&gt; to be printed" fulltype="double" type="double" />
				</params>
			</method>
			<method visibility="public" name="print" fulltype="void" type="void">
				<comment>
					<description>Prints an array of characters.  The characters are converted into bytes
 according to the platform&apos;s default character encoding, and these bytes
 are written in exactly the manner of the
 &lt;code&gt;{@link #write(int)}&lt;/code&gt; method.</description>
					<attribute name="@param">
						<description>s   The array of chars to be printed</description>
					</attribute>
					<attribute name="@throws">
						<description>NullPointerException  If &lt;code&gt;s&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</description>
					</attribute>
				</comment>
				<params>
					<param name="s" comment="The array of chars to be printed" fulltype="char[]" type="char" />
				</params>
			</method>
			<method visibility="public" name="print" fulltype="void" type="void">
				<comment>
					<description>Prints a string.  If the argument is &lt;code&gt;null&lt;/code&gt; then the string
 &lt;code&gt;&quot;null&quot;&lt;/code&gt; is printed.  Otherwise, the string&apos;s characters are
 converted into bytes according to the platform&apos;s default character
 encoding, and these bytes are written in exactly the manner of the
 &lt;code&gt;{@link #write(int)}&lt;/code&gt; method.</description>
					<attribute name="@param">
						<description>s   The &lt;code&gt;String&lt;/code&gt; to be printed</description>
					</attribute>
				</comment>
				<params>
					<param name="s" comment="The &lt;code&gt;String&lt;/code&gt; to be printed" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="public" name="print" fulltype="void" type="void">
				<comment>
					<description>Prints an object.  The string produced by the &lt;code&gt;{@link
 java.lang.String#valueOf(Object)}&lt;/code&gt; method is translated into bytes
 according to the platform&apos;s default character encoding, and these bytes
 are written in exactly the manner of the
 &lt;code&gt;{@link #write(int)}&lt;/code&gt; method.</description>
					<attribute name="@param">
						<description>obj   The &lt;code&gt;Object&lt;/code&gt; to be printed</description>
					</attribute>
					<attribute name="@see">
						<description>java.lang.Object#toString()</description>
					</attribute>
				</comment>
				<params>
					<param name="obj" comment="The &lt;code&gt;Object&lt;/code&gt; to be printed" fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method visibility="public" name="println" fulltype="void" type="void">
				<comment>
					<description>Terminates the current line by writing the line separator string.  The
 line separator string is defined by the system property
 &lt;code&gt;line.separator&lt;/code&gt;, and is not necessarily a single newline
 character (&lt;code&gt;&apos;\n&apos;&lt;/code&gt;).</description>
				</comment>
			</method>
			<method visibility="public" name="println" fulltype="void" type="void">
				<comment>
					<description>Prints a boolean and then terminate the line.  This method behaves as
 though it invokes &lt;code&gt;{@link #print(boolean)}&lt;/code&gt; and then
 &lt;code&gt;{@link #println()}&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>x  The &lt;code&gt;boolean&lt;/code&gt; to be printed</description>
					</attribute>
				</comment>
				<params>
					<param name="x" comment="The &lt;code&gt;boolean&lt;/code&gt; to be printed" fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method visibility="public" name="println" fulltype="void" type="void">
				<comment>
					<description>Prints a character and then terminate the line.  This method behaves as
 though it invokes &lt;code&gt;{@link #print(char)}&lt;/code&gt; and then
 &lt;code&gt;{@link #println()}&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>x  The &lt;code&gt;char&lt;/code&gt; to be printed.</description>
					</attribute>
				</comment>
				<params>
					<param name="x" comment="The &lt;code&gt;char&lt;/code&gt; to be printed." fulltype="char" type="char" />
				</params>
			</method>
			<method visibility="public" name="println" fulltype="void" type="void">
				<comment>
					<description>Prints an integer and then terminate the line.  This method behaves as
 though it invokes &lt;code&gt;{@link #print(int)}&lt;/code&gt; and then
 &lt;code&gt;{@link #println()}&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>x  The &lt;code&gt;int&lt;/code&gt; to be printed.</description>
					</attribute>
				</comment>
				<params>
					<param name="x" comment="The &lt;code&gt;int&lt;/code&gt; to be printed." fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="println" fulltype="void" type="void">
				<comment>
					<description>Prints a long and then terminate the line.  This method behaves as
 though it invokes &lt;code&gt;{@link #print(long)}&lt;/code&gt; and then
 &lt;code&gt;{@link #println()}&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>x  a The &lt;code&gt;long&lt;/code&gt; to be printed.</description>
					</attribute>
				</comment>
				<params>
					<param name="x" comment="a The &lt;code&gt;long&lt;/code&gt; to be printed." fulltype="long" type="long" />
				</params>
			</method>
			<method visibility="public" name="println" fulltype="void" type="void">
				<comment>
					<description>Prints a float and then terminate the line.  This method behaves as
 though it invokes &lt;code&gt;{@link #print(float)}&lt;/code&gt; and then
 &lt;code&gt;{@link #println()}&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>x  The &lt;code&gt;float&lt;/code&gt; to be printed.</description>
					</attribute>
				</comment>
				<params>
					<param name="x" comment="The &lt;code&gt;float&lt;/code&gt; to be printed." fulltype="float" type="float" />
				</params>
			</method>
			<method visibility="public" name="println" fulltype="void" type="void">
				<comment>
					<description>Prints a double and then terminate the line.  This method behaves as
 though it invokes &lt;code&gt;{@link #print(double)}&lt;/code&gt; and then
 &lt;code&gt;{@link #println()}&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>x  The &lt;code&gt;double&lt;/code&gt; to be printed.</description>
					</attribute>
				</comment>
				<params>
					<param name="x" comment="The &lt;code&gt;double&lt;/code&gt; to be printed." fulltype="double" type="double" />
				</params>
			</method>
			<method visibility="public" name="println" fulltype="void" type="void">
				<comment>
					<description>Prints an array of characters and then terminate the line.  This method
 behaves as though it invokes &lt;code&gt;{@link #print(char[])}&lt;/code&gt; and
 then &lt;code&gt;{@link #println()}&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>x  an array of chars to print.</description>
					</attribute>
				</comment>
				<params>
					<param name="x" comment="an array of chars to print." fulltype="char[]" type="char" />
				</params>
			</method>
			<method visibility="public" name="println" fulltype="void" type="void">
				<comment>
					<description>Prints a String and then terminate the line.  This method behaves as
 though it invokes &lt;code&gt;{@link #print(String)}&lt;/code&gt; and then
 &lt;code&gt;{@link #println()}&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>x  The &lt;code&gt;String&lt;/code&gt; to be printed.</description>
					</attribute>
				</comment>
				<params>
					<param name="x" comment="The &lt;code&gt;String&lt;/code&gt; to be printed." fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="public" name="println" fulltype="void" type="void">
				<comment>
					<description>Prints an Object and then terminate the line.  This method calls
 at first String.valueOf(x) to get the printed object&apos;s string value,
 then behaves as
 though it invokes &lt;code&gt;{@link #print(String)}&lt;/code&gt; and then
 &lt;code&gt;{@link #println()}&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>x  The &lt;code&gt;Object&lt;/code&gt; to be printed.</description>
					</attribute>
				</comment>
				<params>
					<param name="x" comment="The &lt;code&gt;Object&lt;/code&gt; to be printed." fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method visibility="public" name="printf" returncomment="This output stream" fulltype="java.io.PrintStream" type="PrintStream">
				<comment>
					<description>A convenience method to write a formatted string to this output stream
 using the specified format string and arguments.

 &lt;p&gt; An invocation of this method of the form &lt;tt&gt;out.printf(format,
 args)&lt;/tt&gt; behaves in exactly the same way as the invocation

 &lt;pre&gt;
     out.format(format, args) &lt;/pre&gt;</description>
					<attribute name="@param">
						<description>format
         A format string as described in &lt;a
         href=&quot;../util/Formatter.html#syntax&quot;&gt;Format string syntax&lt;/a&gt;</description>
					</attribute>
					<attribute name="@param">
						<description>args
         Arguments referenced by the format specifiers in the format
         string.  If there are more arguments than format specifiers, the
         extra arguments are ignored.  The number of arguments is
         variable and may be zero.  The maximum number of arguments is
         limited by the maximum dimension of a Java array as defined by
         the &lt;a href=&quot;http://java.sun.com/docs/books/vmspec/&quot;&gt;Java
         Virtual Machine Specification&lt;/a&gt;.  The behaviour on a
         &lt;tt&gt;null&lt;/tt&gt; argument depends on the &lt;a
         href=&quot;../util/Formatter.html#syntax&quot;&gt;conversion&lt;/a&gt;.</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalFormatException
          If a format string contains an illegal syntax, a format
          specifier that is incompatible with the given arguments,
          insufficient arguments given the format string, or other
          illegal conditions.  For specification of all possible
          formatting errors, see the &lt;a
          href=&quot;../util/Formatter.html#detail&quot;&gt;Details&lt;/a&gt; section of the
          formatter class specification.</description>
					</attribute>
					<attribute name="@throws">
						<description>NullPointerException
          If the &lt;tt&gt;format&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;</description>
					</attribute>
					<attribute name="@return">
						<description>This output stream</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
				<params>
					<param name="format" comment="A format string as described in &lt;a
         href=&quot;../util/Formatter.html#syntax&quot;&gt;Format string syntax&lt;/a&gt;" fulltype="java.lang.String" type="String" />
					<param name="args" comment="Arguments referenced by the format specifiers in the format
         string.  If there are more arguments than format specifiers, the
         extra arguments are ignored.  The number of arguments is
         variable and may be zero.  The maximum number of arguments is
         limited by the maximum dimension of a Java array as defined by
         the &lt;a href=&quot;http://java.sun.com/docs/books/vmspec/&quot;&gt;Java
         Virtual Machine Specification&lt;/a&gt;.  The behaviour on a
         &lt;tt&gt;null&lt;/tt&gt; argument depends on the &lt;a
         href=&quot;../util/Formatter.html#syntax&quot;&gt;conversion&lt;/a&gt;." fulltype="java.lang.Object[]" type="Object" />
				</params>
			</method>
			<method visibility="public" name="printf" returncomment="This output stream" fulltype="java.io.PrintStream" type="PrintStream">
				<comment>
					<description>A convenience method to write a formatted string to this output stream
 using the specified format string and arguments.

 &lt;p&gt; An invocation of this method of the form &lt;tt&gt;out.printf(l, format,
 args)&lt;/tt&gt; behaves in exactly the same way as the invocation

 &lt;pre&gt;
     out.format(l, format, args) &lt;/pre&gt;</description>
					<attribute name="@param">
						<description>l
         The {@linkplain java.util.Locale locale} to apply during
         formatting.  If &lt;tt&gt;l&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt; then no localization
         is applied.</description>
					</attribute>
					<attribute name="@param">
						<description>format
         A format string as described in &lt;a
         href=&quot;../util/Formatter.html#syntax&quot;&gt;Format string syntax&lt;/a&gt;</description>
					</attribute>
					<attribute name="@param">
						<description>args
         Arguments referenced by the format specifiers in the format
         string.  If there are more arguments than format specifiers, the
         extra arguments are ignored.  The number of arguments is
         variable and may be zero.  The maximum number of arguments is
         limited by the maximum dimension of a Java array as defined by
         the &lt;a href=&quot;http://java.sun.com/docs/books/vmspec/&quot;&gt;Java
         Virtual Machine Specification&lt;/a&gt;.  The behaviour on a
         &lt;tt&gt;null&lt;/tt&gt; argument depends on the &lt;a
         href=&quot;../util/Formatter.html#syntax&quot;&gt;conversion&lt;/a&gt;.</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalFormatException
          If a format string contains an illegal syntax, a format
          specifier that is incompatible with the given arguments,
          insufficient arguments given the format string, or other
          illegal conditions.  For specification of all possible
          formatting errors, see the &lt;a
          href=&quot;../util/Formatter.html#detail&quot;&gt;Details&lt;/a&gt; section of the
          formatter class specification.</description>
					</attribute>
					<attribute name="@throws">
						<description>NullPointerException
          If the &lt;tt&gt;format&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;</description>
					</attribute>
					<attribute name="@return">
						<description>This output stream</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
				<params>
					<param name="l" comment="The {@linkplain java.util.Locale locale} to apply during
         formatting.  If &lt;tt&gt;l&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt; then no localization
         is applied." fulltype="java.util.Locale" type="Locale" />
					<param name="format" comment="A format string as described in &lt;a
         href=&quot;../util/Formatter.html#syntax&quot;&gt;Format string syntax&lt;/a&gt;" fulltype="java.lang.String" type="String" />
					<param name="args" comment="Arguments referenced by the format specifiers in the format
         string.  If there are more arguments than format specifiers, the
         extra arguments are ignored.  The number of arguments is
         variable and may be zero.  The maximum number of arguments is
         limited by the maximum dimension of a Java array as defined by
         the &lt;a href=&quot;http://java.sun.com/docs/books/vmspec/&quot;&gt;Java
         Virtual Machine Specification&lt;/a&gt;.  The behaviour on a
         &lt;tt&gt;null&lt;/tt&gt; argument depends on the &lt;a
         href=&quot;../util/Formatter.html#syntax&quot;&gt;conversion&lt;/a&gt;." fulltype="java.lang.Object[]" type="Object" />
				</params>
			</method>
			<method visibility="public" name="format" returncomment="This output stream" fulltype="java.io.PrintStream" type="PrintStream">
				<comment>
					<description>Writes a formatted string to this output stream using the specified
 format string and arguments.

 &lt;p&gt; The locale always used is the one returned by {@link
 java.util.Locale#getDefault() Locale.getDefault()}, regardless of any
 previous invocations of other formatting methods on this object.</description>
					<attribute name="@param">
						<description>format
         A format string as described in &lt;a
         href=&quot;../util/Formatter.html#syntax&quot;&gt;Format string syntax&lt;/a&gt;</description>
					</attribute>
					<attribute name="@param">
						<description>args
         Arguments referenced by the format specifiers in the format
         string.  If there are more arguments than format specifiers, the
         extra arguments are ignored.  The number of arguments is
         variable and may be zero.  The maximum number of arguments is
         limited by the maximum dimension of a Java array as defined by
         the &lt;a href=&quot;http://java.sun.com/docs/books/vmspec/&quot;&gt;Java
         Virtual Machine Specification&lt;/a&gt;.  The behaviour on a
         &lt;tt&gt;null&lt;/tt&gt; argument depends on the &lt;a
         href=&quot;../util/Formatter.html#syntax&quot;&gt;conversion&lt;/a&gt;.</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalFormatException
          If a format string contains an illegal syntax, a format
          specifier that is incompatible with the given arguments,
          insufficient arguments given the format string, or other
          illegal conditions.  For specification of all possible
          formatting errors, see the &lt;a
          href=&quot;../util/Formatter.html#detail&quot;&gt;Details&lt;/a&gt; section of the
          formatter class specification.</description>
					</attribute>
					<attribute name="@throws">
						<description>NullPointerException
          If the &lt;tt&gt;format&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;</description>
					</attribute>
					<attribute name="@return">
						<description>This output stream</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
				<params>
					<param name="format" comment="A format string as described in &lt;a
         href=&quot;../util/Formatter.html#syntax&quot;&gt;Format string syntax&lt;/a&gt;" fulltype="java.lang.String" type="String" />
					<param name="args" comment="Arguments referenced by the format specifiers in the format
         string.  If there are more arguments than format specifiers, the
         extra arguments are ignored.  The number of arguments is
         variable and may be zero.  The maximum number of arguments is
         limited by the maximum dimension of a Java array as defined by
         the &lt;a href=&quot;http://java.sun.com/docs/books/vmspec/&quot;&gt;Java
         Virtual Machine Specification&lt;/a&gt;.  The behaviour on a
         &lt;tt&gt;null&lt;/tt&gt; argument depends on the &lt;a
         href=&quot;../util/Formatter.html#syntax&quot;&gt;conversion&lt;/a&gt;." fulltype="java.lang.Object[]" type="Object" />
				</params>
			</method>
			<method visibility="public" name="format" returncomment="This output stream" fulltype="java.io.PrintStream" type="PrintStream">
				<comment>
					<description>Writes a formatted string to this output stream using the specified
 format string and arguments.</description>
					<attribute name="@param">
						<description>l
         The {@linkplain java.util.Locale locale} to apply during
         formatting.  If &lt;tt&gt;l&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt; then no localization
         is applied.</description>
					</attribute>
					<attribute name="@param">
						<description>format
         A format string as described in &lt;a
         href=&quot;../util/Formatter.html#syntax&quot;&gt;Format string syntax&lt;/a&gt;</description>
					</attribute>
					<attribute name="@param">
						<description>args
         Arguments referenced by the format specifiers in the format
         string.  If there are more arguments than format specifiers, the
         extra arguments are ignored.  The number of arguments is
         variable and may be zero.  The maximum number of arguments is
         limited by the maximum dimension of a Java array as defined by
         the &lt;a href=&quot;http://java.sun.com/docs/books/vmspec/&quot;&gt;Java
         Virtual Machine Specification&lt;/a&gt;.  The behaviour on a
         &lt;tt&gt;null&lt;/tt&gt; argument depends on the &lt;a
         href=&quot;../util/Formatter.html#syntax&quot;&gt;conversion&lt;/a&gt;.</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalFormatException
          If a format string contains an illegal syntax, a format
          specifier that is incompatible with the given arguments,
          insufficient arguments given the format string, or other
          illegal conditions.  For specification of all possible
          formatting errors, see the &lt;a
          href=&quot;../util/Formatter.html#detail&quot;&gt;Details&lt;/a&gt; section of the
          formatter class specification.</description>
					</attribute>
					<attribute name="@throws">
						<description>NullPointerException
          If the &lt;tt&gt;format&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;</description>
					</attribute>
					<attribute name="@return">
						<description>This output stream</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
				<params>
					<param name="l" comment="The {@linkplain java.util.Locale locale} to apply during
         formatting.  If &lt;tt&gt;l&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt; then no localization
         is applied." fulltype="java.util.Locale" type="Locale" />
					<param name="format" comment="A format string as described in &lt;a
         href=&quot;../util/Formatter.html#syntax&quot;&gt;Format string syntax&lt;/a&gt;" fulltype="java.lang.String" type="String" />
					<param name="args" comment="Arguments referenced by the format specifiers in the format
         string.  If there are more arguments than format specifiers, the
         extra arguments are ignored.  The number of arguments is
         variable and may be zero.  The maximum number of arguments is
         limited by the maximum dimension of a Java array as defined by
         the &lt;a href=&quot;http://java.sun.com/docs/books/vmspec/&quot;&gt;Java
         Virtual Machine Specification&lt;/a&gt;.  The behaviour on a
         &lt;tt&gt;null&lt;/tt&gt; argument depends on the &lt;a
         href=&quot;../util/Formatter.html#syntax&quot;&gt;conversion&lt;/a&gt;." fulltype="java.lang.Object[]" type="Object" />
				</params>
			</method>
			<method visibility="public" name="append" returncomment="This output stream" fulltype="java.io.PrintStream" type="PrintStream">
				<comment>
					<description>Appends the specified character sequence to this output stream.

 &lt;p&gt; An invocation of this method of the form &lt;tt&gt;out.append(csq)&lt;/tt&gt;
 behaves in exactly the same way as the invocation

 &lt;pre&gt;
     out.print(csq.toString()) &lt;/pre&gt;

 &lt;p&gt; Depending on the specification of &lt;tt&gt;toString&lt;/tt&gt; for the
 character sequence &lt;tt&gt;csq&lt;/tt&gt;, the entire sequence may not be
 appended.  For instance, invoking then &lt;tt&gt;toString&lt;/tt&gt; method of a
 character buffer will return a subsequence whose content depends upon
 the buffer&apos;s position and limit.</description>
					<attribute name="@param">
						<description>csq
         The character sequence to append.  If &lt;tt&gt;csq&lt;/tt&gt; is
         &lt;tt&gt;null&lt;/tt&gt;, then the four characters &lt;tt&gt;&quot;null&quot;&lt;/tt&gt; are
         appended to this output stream.</description>
					</attribute>
					<attribute name="@return">
						<description>This output stream</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
				<params>
					<param name="csq" comment="The character sequence to append.  If &lt;tt&gt;csq&lt;/tt&gt; is
         &lt;tt&gt;null&lt;/tt&gt;, then the four characters &lt;tt&gt;&quot;null&quot;&lt;/tt&gt; are
         appended to this output stream." fulltype="java.lang.CharSequence" type="CharSequence" />
				</params>
			</method>
			<method visibility="public" name="append" returncomment="This output stream" fulltype="java.io.PrintStream" type="PrintStream">
				<comment>
					<description>Appends a subsequence of the specified character sequence to this output
 stream.

 &lt;p&gt; An invocation of this method of the form &lt;tt&gt;out.append(csq, start,
 end)&lt;/tt&gt; when &lt;tt&gt;csq&lt;/tt&gt; is not &lt;tt&gt;null&lt;/tt&gt;, behaves in
 exactly the same way as the invocation

 &lt;pre&gt;
     out.print(csq.subSequence(start, end).toString()) &lt;/pre&gt;</description>
					<attribute name="@param">
						<description>csq
         The character sequence from which a subsequence will be
         appended.  If &lt;tt&gt;csq&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;, then characters
         will be appended as if &lt;tt&gt;csq&lt;/tt&gt; contained the four
         characters &lt;tt&gt;&quot;null&quot;&lt;/tt&gt;.</description>
					</attribute>
					<attribute name="@param">
						<description>start
         The index of the first character in the subsequence</description>
					</attribute>
					<attribute name="@param">
						<description>end
         The index of the character following the last character in the
         subsequence</description>
					</attribute>
					<attribute name="@return">
						<description>This output stream</description>
					</attribute>
					<attribute name="@throws">
						<description>IndexOutOfBoundsException
          If &lt;tt&gt;start&lt;/tt&gt; or &lt;tt&gt;end&lt;/tt&gt; are negative, &lt;tt&gt;start&lt;/tt&gt;
          is greater than &lt;tt&gt;end&lt;/tt&gt;, or &lt;tt&gt;end&lt;/tt&gt; is greater than
          &lt;tt&gt;csq.length()&lt;/tt&gt;</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
				<params>
					<param name="csq" comment="The character sequence from which a subsequence will be
         appended.  If &lt;tt&gt;csq&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;, then characters
         will be appended as if &lt;tt&gt;csq&lt;/tt&gt; contained the four
         characters &lt;tt&gt;&quot;null&quot;&lt;/tt&gt;." fulltype="java.lang.CharSequence" type="CharSequence" />
					<param name="start" comment="The index of the first character in the subsequence" fulltype="int" type="int" />
					<param name="end" comment="The index of the character following the last character in the
         subsequence" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="append" returncomment="This output stream" fulltype="java.io.PrintStream" type="PrintStream">
				<comment>
					<description>Appends the specified character to this output stream.

 &lt;p&gt; An invocation of this method of the form &lt;tt&gt;out.append(c)&lt;/tt&gt;
 behaves in exactly the same way as the invocation

 &lt;pre&gt;
     out.print(c) &lt;/pre&gt;</description>
					<attribute name="@param">
						<description>c
         The 16-bit character to append</description>
					</attribute>
					<attribute name="@return">
						<description>This output stream</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
				<params>
					<param name="c" comment="The 16-bit character to append" fulltype="char" type="char" />
				</params>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="Reader" visibility="public" package="java.io" superclassfulltype="java.io.Reader" fulltype="java.io.StringReader" type="StringReader">
		<comment>
			<description>A character stream whose source is a string.</description>
			<attribute name="@author">
				<description>Mark Reinhold</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.1</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="private" name="str" fulltype="java.lang.String" type="String" />
			<field visibility="private" name="length" fulltype="int" type="int" />
			<field visibility="private" name="next" fulltype="int" type="int" />
			<field visibility="private" name="mark" fulltype="int" type="int" />
		</fields>
		<methods>
			<constructor visibility="public" name="StringReader">
				<comment>
					<description>Creates a new string reader.</description>
					<attribute name="@param">
						<description>s  String providing the character stream.</description>
					</attribute>
				</comment>
				<params>
					<param name="s" comment="String providing the character stream." fulltype="java.lang.String" type="String" />
				</params>
			</constructor>
			<method visibility="private" name="ensureOpen" fulltype="void" type="void">
				<comment>
					<description>Check to make sure that the stream has not been closed</description>
				</comment>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="read" returncomment="The character read, or -1 if the end of the stream has been
             reached" fulltype="int" type="int">
				<comment>
					<description>Reads a single character.</description>
					<attribute name="@return">
						<description>The character read, or -1 if the end of the stream has been
             reached</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  If an I/O error occurs</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="read" returncomment="The number of characters read, or -1 if the end of the
             stream has been reached" fulltype="int" type="int">
				<comment>
					<description>Reads characters into a portion of an array.</description>
					<attribute name="@param">
						<description>cbuf  Destination buffer</description>
					</attribute>
					<attribute name="@param">
						<description>off   Offset at which to start writing characters</description>
					</attribute>
					<attribute name="@param">
						<description>len   Maximum number of characters to read</description>
					</attribute>
					<attribute name="@return">
						<description>The number of characters read, or -1 if the end of the
             stream has been reached</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  If an I/O error occurs</description>
					</attribute>
				</comment>
				<params>
					<param name="cbuf" comment="Destination buffer" fulltype="char[]" type="char" />
					<param name="off" comment="Offset at which to start writing characters" fulltype="int" type="int" />
					<param name="len" comment="Maximum number of characters to read" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="skip" fulltype="long" type="long">
				<comment>
					<description>Skips the specified number of characters in the stream. Returns
 the number of characters that were skipped.

 &lt;p&gt;The &lt;code&gt;ns&lt;/code&gt; parameter may be negative, even though the
 &lt;code&gt;skip&lt;/code&gt; method of the {@link Reader} superclass throws
 an exception in this case. Negative values of &lt;code&gt;ns&lt;/code&gt; cause the
 stream to skip backwards. Negative return values indicate a skip
 backwards. It is not possible to skip backwards past the beginning of
 the string.

 &lt;p&gt;If the entire string has been read or skipped, then this method has
 no effect and always returns 0.</description>
					<attribute name="@exception">
						<description>IOException  If an I/O error occurs</description>
					</attribute>
				</comment>
				<params>
					<param name="ns" fulltype="long" type="long" />
				</params>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="ready" returncomment="True if the next read() is guaranteed not to block for input" fulltype="boolean" type="boolean">
				<comment>
					<description>Tells whether this stream is ready to be read.</description>
					<attribute name="@return">
						<description>True if the next read() is guaranteed not to block for input</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  If the stream is closed</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If the stream is closed" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="markSupported" fulltype="boolean" type="boolean">
				<comment>
					<description>Tells whether this stream supports the mark() operation, which it does.</description>
				</comment>
			</method>
			<method visibility="public" name="mark" fulltype="void" type="void">
				<comment>
					<description>Marks the present position in the stream.  Subsequent calls to reset()
 will reposition the stream to this point.</description>
					<attribute name="@param">
						<description>readAheadLimit  Limit on the number of characters that may be
                         read while still preserving the mark.  Because
                         the stream&apos;s input comes from a string, there
                         is no actual limit, so this argument must not
                         be negative, but is otherwise ignored.</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException  If readAheadLimit is &lt; 0</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  If an I/O error occurs</description>
					</attribute>
				</comment>
				<params>
					<param name="readAheadLimit" comment="Limit on the number of characters that may be
                         read while still preserving the mark.  Because
                         the stream&apos;s input comes from a string, there
                         is no actual limit, so this argument must not
                         be negative, but is otherwise ignored." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="reset" fulltype="void" type="void">
				<comment>
					<description>Resets the stream to the most recent mark, or to the beginning of the
 string if it has never been marked.</description>
					<attribute name="@exception">
						<description>IOException  If an I/O error occurs</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="close" fulltype="void" type="void">
				<comment>
					<description>Closes the stream and releases any system resources associated with
 it. Once the stream has been closed, further read(),
 ready(), mark(), or reset() invocations will throw an IOException.
 Closing a previously closed stream has no effect.</description>
				</comment>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="OutputStream" visibility="public" package="java.io" superclassfulltype="java.io.OutputStream" fulltype="java.io.FilterOutputStream" type="FilterOutputStream">
		<comment>
			<description>This class is the superclass of all classes that filter output
 streams. These streams sit on top of an already existing output
 stream (the &lt;i&gt;underlying&lt;/i&gt; output stream) which it uses as its
 basic sink of data, but possibly transforming the data along the
 way or providing additional functionality.
 &lt;p&gt;
 The class &lt;code&gt;FilterOutputStream&lt;/code&gt; itself simply overrides
 all methods of &lt;code&gt;OutputStream&lt;/code&gt; with versions that pass
 all requests to the underlying output stream. Subclasses of
 &lt;code&gt;FilterOutputStream&lt;/code&gt; may further override some of these
 methods as well as provide additional methods and fields.</description>
			<attribute name="@author">
				<description>Jonathan Payne</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.0</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="protected" name="out" fulltype="java.io.OutputStream" type="OutputStream">
				<comment>
					<description>The underlying output stream to be filtered.</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="public" name="FilterOutputStream">
				<comment>
					<description>Creates an output stream filter built on top of the specified
 underlying output stream.</description>
					<attribute name="@param">
						<description>out   the underlying output stream to be assigned to
                the field &lt;tt&gt;this.out&lt;/tt&gt; for later use, or
                &lt;code&gt;null&lt;/code&gt; if this instance is to be
                created without an underlying stream.</description>
					</attribute>
				</comment>
				<params>
					<param name="out" comment="the underlying output stream to be assigned to
                the field &lt;tt&gt;this.out&lt;/tt&gt; for later use, or
                &lt;code&gt;null&lt;/code&gt; if this instance is to be
                created without an underlying stream." fulltype="java.io.OutputStream" type="OutputStream" />
				</params>
			</constructor>
			<method visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes the specified &lt;code&gt;byte&lt;/code&gt; to this output stream.
 &lt;p&gt;
 The &lt;code&gt;write&lt;/code&gt; method of &lt;code&gt;FilterOutputStream&lt;/code&gt;
 calls the &lt;code&gt;write&lt;/code&gt; method of its underlying output stream,
 that is, it performs &lt;tt&gt;out.write(b)&lt;/tt&gt;.
 &lt;p&gt;
 Implements the abstract &lt;tt&gt;write&lt;/tt&gt; method of &lt;tt&gt;OutputStream&lt;/tt&gt;.</description>
					<attribute name="@param">
						<description>b   the &lt;code&gt;byte&lt;/code&gt;.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the &lt;code&gt;byte&lt;/code&gt;." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes &lt;code&gt;b.length&lt;/code&gt; bytes to this output stream.
 &lt;p&gt;
 The &lt;code&gt;write&lt;/code&gt; method of &lt;code&gt;FilterOutputStream&lt;/code&gt;
 calls its &lt;code&gt;write&lt;/code&gt; method of three arguments with the
 arguments &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt;, and
 &lt;code&gt;b.length&lt;/code&gt;.
 &lt;p&gt;
 Note that this method does not call the one-argument
 &lt;code&gt;write&lt;/code&gt; method of its underlying stream with the single
 argument &lt;code&gt;b&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>b   the data to be written.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.FilterOutputStream#write(byte[], int, int)</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the data to be written." fulltype="byte[]" type="byte" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes &lt;code&gt;len&lt;/code&gt; bytes from the specified
 &lt;code&gt;byte&lt;/code&gt; array starting at offset &lt;code&gt;off&lt;/code&gt; to
 this output stream.
 &lt;p&gt;
 The &lt;code&gt;write&lt;/code&gt; method of &lt;code&gt;FilterOutputStream&lt;/code&gt;
 calls the &lt;code&gt;write&lt;/code&gt; method of one argument on each
 &lt;code&gt;byte&lt;/code&gt; to output.
 &lt;p&gt;
 Note that this method does not call the &lt;code&gt;write&lt;/code&gt; method
 of its underlying input stream with the same arguments. Subclasses
 of &lt;code&gt;FilterOutputStream&lt;/code&gt; should provide a more efficient
 implementation of this method.</description>
					<attribute name="@param">
						<description>b     the data.</description>
					</attribute>
					<attribute name="@param">
						<description>off   the start offset in the data.</description>
					</attribute>
					<attribute name="@param">
						<description>len   the number of bytes to write.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.FilterOutputStream#write(int)</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the data." fulltype="byte[]" type="byte" />
					<param name="off" comment="the start offset in the data." fulltype="int" type="int" />
					<param name="len" comment="the number of bytes to write." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="flush" fulltype="void" type="void">
				<comment>
					<description>Flushes this output stream and forces any buffered output bytes
 to be written out to the stream.
 &lt;p&gt;
 The &lt;code&gt;flush&lt;/code&gt; method of &lt;code&gt;FilterOutputStream&lt;/code&gt;
 calls the &lt;code&gt;flush&lt;/code&gt; method of its underlying output stream.</description>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.FilterOutputStream#out</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="close" fulltype="void" type="void">
				<comment>
					<description>Closes this output stream and releases any system resources
 associated with the stream.
 &lt;p&gt;
 The &lt;code&gt;close&lt;/code&gt; method of &lt;code&gt;FilterOutputStream&lt;/code&gt;
 calls its &lt;code&gt;flush&lt;/code&gt; method, and then calls the
 &lt;code&gt;close&lt;/code&gt; method of its underlying output stream.</description>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.FilterOutputStream#flush()</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.FilterOutputStream#out</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="InputStream" visibility="public" package="java.io" superclassfulltype="java.io.InputStream" fulltype="java.io.FilterInputStream" type="FilterInputStream">
		<comment>
			<description>A &lt;code&gt;FilterInputStream&lt;/code&gt; contains
 some other input stream, which it uses as
 its  basic source of data, possibly transforming
 the data along the way or providing  additional
 functionality. The class &lt;code&gt;FilterInputStream&lt;/code&gt;
 itself simply overrides all  methods of
 &lt;code&gt;InputStream&lt;/code&gt; with versions that
 pass all requests to the contained  input
 stream. Subclasses of &lt;code&gt;FilterInputStream&lt;/code&gt;
 may further override some of  these methods
 and may also provide additional methods
 and fields.</description>
			<attribute name="@author">
				<description>Jonathan Payne</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.0</description>
			</attribute>
		</comment>
		<fields>
			<field volatile="true" visibility="protected" name="in" fulltype="java.io.InputStream" type="InputStream">
				<comment>
					<description>The input stream to be filtered.</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="protected" name="FilterInputStream">
				<comment>
					<description>Creates a &lt;code&gt;FilterInputStream&lt;/code&gt;
 by assigning the  argument &lt;code&gt;in&lt;/code&gt;
 to the field &lt;code&gt;this.in&lt;/code&gt; so as
 to remember it for later use.</description>
					<attribute name="@param">
						<description>in   the underlying input stream, or &lt;code&gt;null&lt;/code&gt; if
          this instance is to be created without an underlying stream.</description>
					</attribute>
				</comment>
				<params>
					<param name="in" comment="the underlying input stream, or &lt;code&gt;null&lt;/code&gt; if
          this instance is to be created without an underlying stream." fulltype="java.io.InputStream" type="InputStream" />
				</params>
			</constructor>
			<method visibility="public" name="read" returncomment="the next byte of data, or &lt;code&gt;-1&lt;/code&gt; if the end of the
             stream is reached." fulltype="int" type="int">
				<comment>
					<description>Reads the next byte of data from this input stream. The value
 byte is returned as an &lt;code&gt;int&lt;/code&gt; in the range
 &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;255&lt;/code&gt;. If no byte is available
 because the end of the stream has been reached, the value
 &lt;code&gt;-1&lt;/code&gt; is returned. This method blocks until input data
 is available, the end of the stream is detected, or an exception
 is thrown.
 &lt;p&gt;
 This method
 simply performs &lt;code&gt;in.read()&lt;/code&gt; and returns the result.</description>
					<attribute name="@return">
						<description>the next byte of data, or &lt;code&gt;-1&lt;/code&gt; if the end of the
             stream is reached.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.FilterInputStream#in</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="read" returncomment="the total number of bytes read into the buffer, or
             &lt;code&gt;-1&lt;/code&gt; if there is no more data because the end of
             the stream has been reached." fulltype="int" type="int">
				<comment>
					<description>Reads up to &lt;code&gt;byte.length&lt;/code&gt; bytes of data from this
 input stream into an array of bytes. This method blocks until some
 input is available.
 &lt;p&gt;
 This method simply performs the call
 &lt;code&gt;read(b, 0, b.length)&lt;/code&gt; and returns
 the  result. It is important that it does
 &lt;i&gt;not&lt;/i&gt; do &lt;code&gt;in.read(b)&lt;/code&gt; instead;
 certain subclasses of  &lt;code&gt;FilterInputStream&lt;/code&gt;
 depend on the implementation strategy actually
 used.</description>
					<attribute name="@param">
						<description>b   the buffer into which the data is read.</description>
					</attribute>
					<attribute name="@return">
						<description>the total number of bytes read into the buffer, or
             &lt;code&gt;-1&lt;/code&gt; if there is no more data because the end of
             the stream has been reached.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.FilterInputStream#read(byte[], int, int)</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the buffer into which the data is read." fulltype="byte[]" type="byte" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="read" returncomment="the total number of bytes read into the buffer, or
             &lt;code&gt;-1&lt;/code&gt; if there is no more data because the end of
             the stream has been reached." fulltype="int" type="int">
				<comment>
					<description>Reads up to &lt;code&gt;len&lt;/code&gt; bytes of data from this input stream
 into an array of bytes. If &lt;code&gt;len&lt;/code&gt; is not zero, the method
 blocks until some input is available; otherwise, no
 bytes are read and &lt;code&gt;0&lt;/code&gt; is returned.
 &lt;p&gt;
 This method simply performs &lt;code&gt;in.read(b, off, len)&lt;/code&gt;
 and returns the result.</description>
					<attribute name="@param">
						<description>b     the buffer into which the data is read.</description>
					</attribute>
					<attribute name="@param">
						<description>off   the start offset in the destination array &lt;code&gt;b&lt;/code&gt;</description>
					</attribute>
					<attribute name="@param">
						<description>len   the maximum number of bytes read.</description>
					</attribute>
					<attribute name="@return">
						<description>the total number of bytes read into the buffer, or
             &lt;code&gt;-1&lt;/code&gt; if there is no more data because the end of
             the stream has been reached.</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException If &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.</description>
					</attribute>
					<attribute name="@exception">
						<description>IndexOutOfBoundsException If &lt;code&gt;off&lt;/code&gt; is negative,
 &lt;code&gt;len&lt;/code&gt; is negative, or &lt;code&gt;len&lt;/code&gt; is greater than
 &lt;code&gt;b.length - off&lt;/code&gt;</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.FilterInputStream#in</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the buffer into which the data is read." fulltype="byte[]" type="byte" />
					<param name="off" comment="the start offset in the destination array &lt;code&gt;b&lt;/code&gt;" fulltype="int" type="int" />
					<param name="len" comment="the maximum number of bytes read." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="skip" fulltype="long" type="long">
				<comment>
					<description>{@inheritDoc}
 &lt;p&gt;
 This method simply performs &lt;code&gt;in.skip(n)&lt;/code&gt;.</description>
				</comment>
				<params>
					<param name="n" fulltype="long" type="long" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="available" returncomment="an estimate of the number of bytes that can be read (or skipped
             over) from this input stream without blocking." fulltype="int" type="int">
				<comment>
					<description>Returns an estimate of the number of bytes that can be read (or
 skipped over) from this input stream without blocking by the next
 caller of a method for this input stream. The next caller might be
 the same thread or another thread.  A single read or skip of this
 many bytes will not block, but may read or skip fewer bytes.
 &lt;p&gt;
 This method returns the result of {@link #in in}.available().</description>
					<attribute name="@return">
						<description>an estimate of the number of bytes that can be read (or skipped
             over) from this input stream without blocking.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="close" fulltype="void" type="void">
				<comment>
					<description>Closes this input stream and releases any system resources
 associated with the stream.
 This
 method simply performs &lt;code&gt;in.close()&lt;/code&gt;.</description>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.FilterInputStream#in</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="public" name="mark" fulltype="void" type="void">
				<comment>
					<description>Marks the current position in this input stream. A subsequent
 call to the &lt;code&gt;reset&lt;/code&gt; method repositions this stream at
 the last marked position so that subsequent reads re-read the same bytes.
 &lt;p&gt;
 The &lt;code&gt;readlimit&lt;/code&gt; argument tells this input stream to
 allow that many bytes to be read before the mark position gets
 invalidated.
 &lt;p&gt;
 This method simply performs &lt;code&gt;in.mark(readlimit)&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>readlimit   the maximum limit of bytes that can be read before
                      the mark position becomes invalid.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.FilterInputStream#in</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.FilterInputStream#reset()</description>
					</attribute>
				</comment>
				<params>
					<param name="readlimit" comment="the maximum limit of bytes that can be read before
                      the mark position becomes invalid." fulltype="int" type="int" />
				</params>
			</method>
			<method synchronized="true" visibility="public" name="reset" fulltype="void" type="void">
				<comment>
					<description>Repositions this stream to the position at the time the
 &lt;code&gt;mark&lt;/code&gt; method was last called on this input stream.
 &lt;p&gt;
 This method
 simply performs &lt;code&gt;in.reset()&lt;/code&gt;.
 &lt;p&gt;
 Stream marks are intended to be used in
 situations where you need to read ahead a little to see what&apos;s in
 the stream. Often this is most easily done by invoking some
 general parser. If the stream is of the type handled by the
 parse, it just chugs along happily. If the stream is not of
 that type, the parser should toss an exception when it fails.
 If this happens within readlimit bytes, it allows the outer
 code to reset the stream and try another parser.</description>
					<attribute name="@exception">
						<description>IOException  if the stream has not been marked or if the
               mark has been invalidated.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.FilterInputStream#in</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.FilterInputStream#mark(int)</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if the stream has not been marked or if the
               mark has been invalidated." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="markSupported" returncomment="&lt;code&gt;true&lt;/code&gt; if this stream type supports the
          &lt;code&gt;mark&lt;/code&gt; and &lt;code&gt;reset&lt;/code&gt; method;
          &lt;code&gt;false&lt;/code&gt; otherwise." fulltype="boolean" type="boolean">
				<comment>
					<description>Tests if this input stream supports the &lt;code&gt;mark&lt;/code&gt;
 and &lt;code&gt;reset&lt;/code&gt; methods.
 This method
 simply performs &lt;code&gt;in.markSupported()&lt;/code&gt;.</description>
					<attribute name="@return">
						<description>&lt;code&gt;true&lt;/code&gt; if this stream type supports the
          &lt;code&gt;mark&lt;/code&gt; and &lt;code&gt;reset&lt;/code&gt; method;
          &lt;code&gt;false&lt;/code&gt; otherwise.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.FilterInputStream#in</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.InputStream#mark(int)</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.InputStream#reset()</description>
					</attribute>
				</comment>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="OutputStreamWriter" visibility="public" package="java.io" superclassfulltype="java.io.OutputStreamWriter" fulltype="java.io.FileWriter" type="FileWriter">
		<comment>
			<description>Convenience class for writing character files.  The constructors of this
 class assume that the default character encoding and the default byte-buffer
 size are acceptable.  To specify these values yourself, construct an
 OutputStreamWriter on a FileOutputStream.

 &lt;p&gt;Whether or not a file is available or may be created depends upon the
 underlying platform.  Some platforms, in particular, allow a file to be
 opened for writing by only one &lt;tt&gt;FileWriter&lt;/tt&gt; (or other file-writing
 object) at a time.  In such situations the constructors in this class
 will fail if the file involved is already open.

 &lt;p&gt;&lt;code&gt;FileWriter&lt;/code&gt; is meant for writing streams of characters.
 For writing streams of raw bytes, consider using a
 &lt;code&gt;FileOutputStream&lt;/code&gt;.</description>
			<attribute name="@see">
				<description>OutputStreamWriter</description>
			</attribute>
			<attribute name="@see">
				<description>FileOutputStream</description>
			</attribute>
			<attribute name="@author">
				<description>Mark Reinhold</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.1</description>
			</attribute>
		</comment>
		<methods>
			<constructor visibility="public" name="FileWriter">
				<comment>
					<description>Constructs a FileWriter object given a file name.</description>
					<attribute name="@param">
						<description>fileName  String The system-dependent filename.</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException  if the named file exists but is a directory rather
                  than a regular file, does not exist but cannot be
                  created, or cannot be opened for any other reason</description>
					</attribute>
				</comment>
				<params>
					<param name="fileName" comment="String The system-dependent filename." fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception comment="if the named file exists but is a directory rather
                  than a regular file, does not exist but cannot be
                  created, or cannot be opened for any other reason" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</constructor>
			<constructor visibility="public" name="FileWriter">
				<comment>
					<description>Constructs a FileWriter object given a file name with a boolean
 indicating whether or not to append the data written.</description>
					<attribute name="@param">
						<description>fileName  String The system-dependent filename.</description>
					</attribute>
					<attribute name="@param">
						<description>append    boolean if &lt;code&gt;true&lt;/code&gt;, then data will be written
                  to the end of the file rather than the beginning.</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException  if the named file exists but is a directory rather
                  than a regular file, does not exist but cannot be
                  created, or cannot be opened for any other reason</description>
					</attribute>
				</comment>
				<params>
					<param name="fileName" comment="String The system-dependent filename." fulltype="java.lang.String" type="String" />
					<param name="append" comment="boolean if &lt;code&gt;true&lt;/code&gt;, then data will be written
                  to the end of the file rather than the beginning." fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception comment="if the named file exists but is a directory rather
                  than a regular file, does not exist but cannot be
                  created, or cannot be opened for any other reason" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</constructor>
			<constructor visibility="public" name="FileWriter">
				<comment>
					<description>Constructs a FileWriter object given a File object.</description>
					<attribute name="@param">
						<description>file  a File object to write to.</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException  if the file exists but is a directory rather than
                  a regular file, does not exist but cannot be created,
                  or cannot be opened for any other reason</description>
					</attribute>
				</comment>
				<params>
					<param name="file" comment="a File object to write to." fulltype="java.io.File" type="File" />
				</params>
				<exceptions>
					<exception comment="if the file exists but is a directory rather than
                  a regular file, does not exist but cannot be created,
                  or cannot be opened for any other reason" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</constructor>
			<constructor visibility="public" name="FileWriter">
				<comment>
					<description>Constructs a FileWriter object given a File object. If the second
 argument is &lt;code&gt;true&lt;/code&gt;, then bytes will be written to the end
 of the file rather than the beginning.</description>
					<attribute name="@param">
						<description>file  a File object to write to</description>
					</attribute>
					<attribute name="@param">
						<description>append    if &lt;code&gt;true&lt;/code&gt;, then bytes will be written
                      to the end of the file rather than the beginning</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException  if the file exists but is a directory rather than
                  a regular file, does not exist but cannot be created,
                  or cannot be opened for any other reason</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
				<params>
					<param name="file" comment="a File object to write to" fulltype="java.io.File" type="File" />
					<param name="append" comment="if &lt;code&gt;true&lt;/code&gt;, then bytes will be written
                      to the end of the file rather than the beginning" fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception comment="if the file exists but is a directory rather than
                  a regular file, does not exist but cannot be created,
                  or cannot be opened for any other reason" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</constructor>
			<constructor visibility="public" name="FileWriter">
				<comment>
					<description>Constructs a FileWriter object associated with a file descriptor.</description>
					<attribute name="@param">
						<description>fd  FileDescriptor object to write to.</description>
					</attribute>
				</comment>
				<params>
					<param name="fd" comment="FileDescriptor object to write to." fulltype="java.io.FileDescriptor" type="FileDescriptor" />
				</params>
			</constructor>
		</methods>
	</jelclass>
	<jelclass superclass="Writer" visibility="public" package="java.io" superclassfulltype="java.io.Writer" fulltype="java.io.OutputStreamWriter" type="OutputStreamWriter">
		<comment>
			<description>An OutputStreamWriter is a bridge from character streams to byte streams:
 Characters written to it are encoded into bytes using a specified {@link
 java.nio.charset.Charset &lt;code&gt;charset&lt;/code&gt;}.  The charset that it uses
 may be specified by name or may be given explicitly, or the platform&apos;s
 default charset may be accepted.

 &lt;p&gt; Each invocation of a write() method causes the encoding converter to be
 invoked on the given character(s).  The resulting bytes are accumulated in a
 buffer before being written to the underlying output stream.  The size of
 this buffer may be specified, but by default it is large enough for most
 purposes.  Note that the characters passed to the write() methods are not
 buffered.

 &lt;p&gt; For top efficiency, consider wrapping an OutputStreamWriter within a
 BufferedWriter so as to avoid frequent converter invocations.  For example:

 &lt;pre&gt;
 Writer out
   = new BufferedWriter(new OutputStreamWriter(System.out));
 &lt;/pre&gt;

 &lt;p&gt; A &lt;i&gt;surrogate pair&lt;/i&gt; is a character represented by a sequence of two
 &lt;tt&gt;char&lt;/tt&gt; values: A &lt;i&gt;high&lt;/i&gt; surrogate in the range &apos;&amp;#92;uD800&apos; to
 &apos;&amp;#92;uDBFF&apos; followed by a &lt;i&gt;low&lt;/i&gt; surrogate in the range &apos;&amp;#92;uDC00&apos; to
 &apos;&amp;#92;uDFFF&apos;.

 &lt;p&gt; A &lt;i&gt;malformed surrogate element&lt;/i&gt; is a high surrogate that is not
 followed by a low surrogate or a low surrogate that is not preceded by a
 high surrogate.

 &lt;p&gt; This class always replaces malformed surrogate elements and unmappable
 character sequences with the charset&apos;s default &lt;i&gt;substitution sequence&lt;/i&gt;.
 The {@linkplain java.nio.charset.CharsetEncoder} class should be used when more
 control over the encoding process is required.</description>
			<attribute name="@see">
				<description>BufferedWriter</description>
			</attribute>
			<attribute name="@see">
				<description>OutputStream</description>
			</attribute>
			<attribute name="@see">
				<description>java.nio.charset.Charset</description>
			</attribute>
			<attribute name="@author">
				<description>Mark Reinhold</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.1</description>
			</attribute>
		</comment>
		<fields>
			<field final="true" visibility="private" name="se" fulltype="sun.nio.cs.StreamEncoder" type="StreamEncoder" />
		</fields>
		<methods>
			<constructor visibility="public" name="OutputStreamWriter">
				<comment>
					<description>Creates an OutputStreamWriter that uses the named charset.</description>
					<attribute name="@param">
						<description>out
         An OutputStream</description>
					</attribute>
					<attribute name="@param">
						<description>charsetName
         The name of a supported
         {@link java.nio.charset.Charset &lt;/code&gt;charset&lt;code&gt;}</description>
					</attribute>
					<attribute name="@exception">
						<description>UnsupportedEncodingException
             If the named encoding is not supported</description>
					</attribute>
				</comment>
				<params>
					<param name="out" comment="An OutputStream" fulltype="java.io.OutputStream" type="OutputStream" />
					<param name="charsetName" comment="The name of a supported
         {@link java.nio.charset.Charset &lt;/code&gt;charset&lt;code&gt;}" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception comment="If the named encoding is not supported" fulltype="java.io.UnsupportedEncodingException" type="UnsupportedEncodingException" />
				</exceptions>
			</constructor>
			<constructor visibility="public" name="OutputStreamWriter">
				<comment>
					<description>Creates an OutputStreamWriter that uses the default character encoding.</description>
					<attribute name="@param">
						<description>out  An OutputStream</description>
					</attribute>
				</comment>
				<params>
					<param name="out" comment="An OutputStream" fulltype="java.io.OutputStream" type="OutputStream" />
				</params>
			</constructor>
			<constructor visibility="public" name="OutputStreamWriter">
				<comment>
					<description>Creates an OutputStreamWriter that uses the given charset. &lt;/p&gt;</description>
					<attribute name="@param">
						<description>out
         An OutputStream</description>
					</attribute>
					<attribute name="@param">
						<description>cs
         A charset</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
					<attribute name="@spec">
						<description>JSR-51</description>
					</attribute>
				</comment>
				<params>
					<param name="out" comment="An OutputStream" fulltype="java.io.OutputStream" type="OutputStream" />
					<param name="cs" comment="A charset" fulltype="java.nio.charset.Charset" type="Charset" />
				</params>
			</constructor>
			<constructor visibility="public" name="OutputStreamWriter">
				<comment>
					<description>Creates an OutputStreamWriter that uses the given charset encoder.  &lt;/p&gt;</description>
					<attribute name="@param">
						<description>out
         An OutputStream</description>
					</attribute>
					<attribute name="@param">
						<description>enc
         A charset encoder</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
					<attribute name="@spec">
						<description>JSR-51</description>
					</attribute>
				</comment>
				<params>
					<param name="out" comment="An OutputStream" fulltype="java.io.OutputStream" type="OutputStream" />
					<param name="enc" comment="A charset encoder" fulltype="java.nio.charset.CharsetEncoder" type="CharsetEncoder" />
				</params>
			</constructor>
			<method visibility="public" name="getEncoding" returncomment="The historical name of this encoding, or possibly
         &lt;code&gt;null&lt;/code&gt; if the stream has been closed" fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the name of the character encoding being used by this stream.

 &lt;p&gt; If the encoding has an historical name then that name is returned;
 otherwise the encoding&apos;s canonical name is returned.

 &lt;p&gt; If this instance was created with the {@link
 #OutputStreamWriter(OutputStream, String)} constructor then the returned
 name, being unique for the encoding, may differ from the name passed to
 the constructor.  This method may return &lt;tt&gt;null&lt;/tt&gt; if the stream has
 been closed. &lt;/p&gt;</description>
					<attribute name="@return">
						<description>The historical name of this encoding, or possibly
         &lt;code&gt;null&lt;/code&gt; if the stream has been closed</description>
					</attribute>
					<attribute name="@see">
						<description>java.nio.charset.Charset</description>
					</attribute>
					<attribute name="@revised">
						<description>1.4</description>
					</attribute>
					<attribute name="@spec">
						<description>JSR-51</description>
					</attribute>
				</comment>
			</method>
			<method visibility="package-private" name="flushBuffer" fulltype="void" type="void">
				<comment>
					<description>Flushes the output buffer to the underlying byte stream, without flushing
 the byte stream itself.  This method is non-private only so that it may
 be invoked by PrintStream.</description>
				</comment>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes a single character.</description>
					<attribute name="@exception">
						<description>IOException  If an I/O error occurs</description>
					</attribute>
				</comment>
				<params>
					<param name="c" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes a portion of an array of characters.</description>
					<attribute name="@param">
						<description>cbuf  Buffer of characters</description>
					</attribute>
					<attribute name="@param">
						<description>off   Offset from which to start writing characters</description>
					</attribute>
					<attribute name="@param">
						<description>len   Number of characters to write</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  If an I/O error occurs</description>
					</attribute>
				</comment>
				<params>
					<param name="cbuf" comment="Buffer of characters" fulltype="char[]" type="char" />
					<param name="off" comment="Offset from which to start writing characters" fulltype="int" type="int" />
					<param name="len" comment="Number of characters to write" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes a portion of a string.</description>
					<attribute name="@param">
						<description>str  A String</description>
					</attribute>
					<attribute name="@param">
						<description>off  Offset from which to start writing characters</description>
					</attribute>
					<attribute name="@param">
						<description>len  Number of characters to write</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  If an I/O error occurs</description>
					</attribute>
				</comment>
				<params>
					<param name="str" comment="A String" fulltype="java.lang.String" type="String" />
					<param name="off" comment="Offset from which to start writing characters" fulltype="int" type="int" />
					<param name="len" comment="Number of characters to write" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="flush" fulltype="void" type="void">
				<comment>
					<description>Flushes the stream.</description>
					<attribute name="@exception">
						<description>IOException  If an I/O error occurs</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="close" fulltype="void" type="void">
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass abstract="true" visibility="public" package="java.io" interface="true" fulltype="java.io.DataInput" type="DataInput">
		<comment>
			<description>The &lt;code&gt;DataInput&lt;/code&gt; interface provides
 for reading bytes from a binary stream and
 reconstructing from them data in any of
 the Java primitive types. There is also
 a
 facility for reconstructing a &lt;code&gt;String&lt;/code&gt;
 from data in
 &lt;a href=&quot;#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt;
 format.
 &lt;p&gt;
 It is generally true of all the reading
 routines in this interface that if end of
 file is reached before the desired number
 of bytes has been read, an &lt;code&gt;EOFException&lt;/code&gt;
 (which is a kind of &lt;code&gt;IOException&lt;/code&gt;)
 is thrown. If any byte cannot be read for
 any reason other than end of file, an &lt;code&gt;IOException&lt;/code&gt;
 other than &lt;code&gt;EOFException&lt;/code&gt; is
 thrown. In particular, an &lt;code&gt;IOException&lt;/code&gt;
 may be thrown if the input stream has been
 closed.

 &lt;h4&gt;&lt;a name=&quot;modified-utf-8&quot;&gt;Modified UTF-8&lt;/a&gt;&lt;/h4&gt;
 &lt;p&gt;
 Implementations of the DataInput and DataOutput interfaces represent
 Unicode strings in a format that is a slight modification of UTF-8.
 (For information regarding the standard UTF-8 format, see section
 &lt;i&gt;3.9 Unicode Encoding Forms&lt;/i&gt; of &lt;i&gt;The Unicode Standard, Version
 4.0&lt;/i&gt;).
 Note that in the following tables, the most significant bit appears in the
 far left-hand column.
 &lt;p&gt;
 All characters in the range &lt;code&gt;&apos;&amp;#92;u0001&apos;&lt;/code&gt; to
 &lt;code&gt;&apos;&amp;#92;u007F&apos;&lt;/code&gt; are represented by a single byte:

 &lt;blockquote&gt;
   &lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;8&quot; width=&quot;50%&quot;
          summary=&quot;Bit values and bytes&quot;&gt;
     &lt;tr&gt;
       &lt;td&gt;&lt;/td&gt;
       &lt;th id=&quot;bit&quot;&gt;Bit Values&lt;/th&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
       &lt;th id=&quot;byte1&quot;&gt;Byte 1&lt;/th&gt;
       &lt;td&gt;
         &lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; width=&quot;100%&quot;&gt;
           &lt;tr&gt;
             &lt;td width=&quot;12%&quot;&gt;&lt;center&gt;0&lt;/center&gt;
             &lt;td colspan=&quot;7&quot;&gt;&lt;center&gt;bits 6-0&lt;/center&gt;
           &lt;/tr&gt;
         &lt;/table&gt;
       &lt;/td&gt;
     &lt;/tr&gt;
   &lt;/table&gt;
 &lt;/blockquote&gt;

 &lt;p&gt;
 The null character &lt;code&gt;&apos;&amp;#92;u0000&apos;&lt;/code&gt; and characters in the
 range &lt;code&gt;&apos;&amp;#92;u0080&apos;&lt;/code&gt; to &lt;code&gt;&apos;&amp;#92;u07FF&apos;&lt;/code&gt; are
 represented by a pair of bytes:

 &lt;blockquote&gt;
   &lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;8&quot; width=&quot;50%&quot;
          summary=&quot;Bit values and bytes&quot;&gt;
     &lt;tr&gt;
       &lt;td&gt;&lt;/td&gt;
       &lt;th id=&quot;bit&quot;&gt;Bit Values&lt;/th&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
       &lt;th id=&quot;byte1&quot;&gt;Byte 1&lt;/th&gt;
       &lt;td&gt;
         &lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; width=&quot;100%&quot;&gt;
           &lt;tr&gt;
             &lt;td width=&quot;12%&quot;&gt;&lt;center&gt;1&lt;/center&gt;
             &lt;td width=&quot;13%&quot;&gt;&lt;center&gt;1&lt;/center&gt;
             &lt;td width=&quot;12%&quot;&gt;&lt;center&gt;0&lt;/center&gt;
             &lt;td colspan=&quot;5&quot;&gt;&lt;center&gt;bits 10-6&lt;/center&gt;
           &lt;/tr&gt;
         &lt;/table&gt;
       &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
       &lt;th id=&quot;byte2&quot;&gt;Byte 2&lt;/th&gt;
       &lt;td&gt;
         &lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; width=&quot;100%&quot;&gt;
           &lt;tr&gt;
             &lt;td width=&quot;12%&quot;&gt;&lt;center&gt;1&lt;/center&gt;
             &lt;td width=&quot;13%&quot;&gt;&lt;center&gt;0&lt;/center&gt;
             &lt;td colspan=&quot;6&quot;&gt;&lt;center&gt;bits 5-0&lt;/center&gt;
           &lt;/tr&gt;
         &lt;/table&gt;
       &lt;/td&gt;
     &lt;/tr&gt;
   &lt;/table&gt;
  &lt;/blockquote&gt;

 &lt;br&gt;
 &lt;code&gt;char&lt;/code&gt; values in the range &lt;code&gt;&apos;&amp;#92;u0800&apos;&lt;/code&gt; to
 &lt;code&gt;&apos;&amp;#92;uFFFF&apos;&lt;/code&gt; are represented by three bytes:

 &lt;blockquote&gt;
   &lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;8&quot; width=&quot;50%&quot;
          summary=&quot;Bit values and bytes&quot;&gt;
     &lt;tr&gt;
       &lt;td&gt;&lt;/td&gt;
       &lt;th id=&quot;bit&quot;&gt;Bit Values&lt;/th&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
       &lt;th id=&quot;byte1&quot;&gt;Byte 1&lt;/th&gt;
       &lt;td&gt;
         &lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; width=&quot;100%&quot;&gt;
           &lt;tr&gt;
             &lt;td width=&quot;12%&quot;&gt;&lt;center&gt;1&lt;/center&gt;
             &lt;td width=&quot;13%&quot;&gt;&lt;center&gt;1&lt;/center&gt;
             &lt;td width=&quot;12%&quot;&gt;&lt;center&gt;1&lt;/center&gt;
             &lt;td width=&quot;13%&quot;&gt;&lt;center&gt;0&lt;/center&gt;
             &lt;td colspan=&quot;4&quot;&gt;&lt;center&gt;bits 15-12&lt;/center&gt;
           &lt;/tr&gt;
         &lt;/table&gt;
       &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
       &lt;th id=&quot;byte2&quot;&gt;Byte 2&lt;/th&gt;
       &lt;td&gt;
         &lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; width=&quot;100%&quot;&gt;
           &lt;tr&gt;
             &lt;td width=&quot;12%&quot;&gt;&lt;center&gt;1&lt;/center&gt;
             &lt;td width=&quot;13%&quot;&gt;&lt;center&gt;0&lt;/center&gt;
             &lt;td colspan=&quot;6&quot;&gt;&lt;center&gt;bits 11-6&lt;/center&gt;
           &lt;/tr&gt;
         &lt;/table&gt;
       &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
       &lt;th id=&quot;byte3&quot;&gt;Byte 3&lt;/th&gt;
       &lt;td&gt;
         &lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; width=&quot;100%&quot;&gt;
           &lt;tr&gt;
             &lt;td width=&quot;12%&quot;&gt;&lt;center&gt;1&lt;/center&gt;
             &lt;td width=&quot;13%&quot;&gt;&lt;center&gt;0&lt;/center&gt;
             &lt;td colspan=&quot;6&quot;&gt;&lt;center&gt;bits 5-0&lt;/center&gt;
           &lt;/tr&gt;
         &lt;/table&gt;
       &lt;/td&gt;
     &lt;/tr&gt;
   &lt;/table&gt;
  &lt;/blockquote&gt;

 &lt;p&gt;
 The differences between this format and the
 standard UTF-8 format are the following:
 &lt;ul&gt;
 &lt;li&gt;The null byte &lt;code&gt;&apos;&amp;#92;u0000&apos;&lt;/code&gt; is encoded in 2-byte format
     rather than 1-byte, so that the encoded strings never have
     embedded nulls.
 &lt;li&gt;Only the 1-byte, 2-byte, and 3-byte formats are used.
 &lt;li&gt;&lt;a href=&quot;../lang/Character.html#unicode&quot;&gt;Supplementary characters&lt;/a&gt;
     are represented in the form of surrogate pairs.
 &lt;/ul&gt;</description>
			<attribute name="@author">
				<description>Frank Yellin</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.DataInputStream</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.DataOutput</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.0</description>
			</attribute>
		</comment>
		<methods>
			<method visibility="public" name="readFully" fulltype="void" type="void">
				<comment>
					<description>Reads some bytes from an input
 stream and stores them into the buffer
 array &lt;code&gt;b&lt;/code&gt;. The number of bytes
 read is equal
 to the length of &lt;code&gt;b&lt;/code&gt;.
 &lt;p&gt;
 This method blocks until one of the
 following conditions occurs:&lt;p&gt;
 &lt;ul&gt;
 &lt;li&gt;&lt;code&gt;b.length&lt;/code&gt;
 bytes of input data are available, in which
 case a normal return is made.

 &lt;li&gt;End of
 file is detected, in which case an &lt;code&gt;EOFException&lt;/code&gt;
 is thrown.

 &lt;li&gt;An I/O error occurs, in
 which case an &lt;code&gt;IOException&lt;/code&gt; other
 than &lt;code&gt;EOFException&lt;/code&gt; is thrown.
 &lt;/ul&gt;
 &lt;p&gt;
 If &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
 a &lt;code&gt;NullPointerException&lt;/code&gt; is thrown.
 If &lt;code&gt;b.length&lt;/code&gt; is zero, then
 no bytes are read. Otherwise, the first
 byte read is stored into element &lt;code&gt;b[0]&lt;/code&gt;,
 the next one into &lt;code&gt;b[1]&lt;/code&gt;, and
 so on.
 If an exception is thrown from
 this method, then it may be that some but
 not all bytes of &lt;code&gt;b&lt;/code&gt; have been
 updated with data from the input stream.</description>
					<attribute name="@param">
						<description>b   the buffer into which the data is read.</description>
					</attribute>
					<attribute name="@exception">
						<description>EOFException  if this stream reaches the end before reading
               all the bytes.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException   if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the buffer into which the data is read." fulltype="byte[]" type="byte" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="readFully" fulltype="void" type="void">
				<comment>
					<description>Reads &lt;code&gt;len&lt;/code&gt;
 bytes from
 an input stream.
 &lt;p&gt;
 This method
 blocks until one of the following conditions
 occurs:&lt;p&gt;
 &lt;ul&gt;
 &lt;li&gt;&lt;code&gt;len&lt;/code&gt; bytes
 of input data are available, in which case
 a normal return is made.

 &lt;li&gt;End of file
 is detected, in which case an &lt;code&gt;EOFException&lt;/code&gt;
 is thrown.

 &lt;li&gt;An I/O error occurs, in
 which case an &lt;code&gt;IOException&lt;/code&gt; other
 than &lt;code&gt;EOFException&lt;/code&gt; is thrown.
 &lt;/ul&gt;
 &lt;p&gt;
 If &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
 a &lt;code&gt;NullPointerException&lt;/code&gt; is thrown.
 If &lt;code&gt;off&lt;/code&gt; is negative, or &lt;code&gt;len&lt;/code&gt;
 is negative, or &lt;code&gt;off+len&lt;/code&gt; is
 greater than the length of the array &lt;code&gt;b&lt;/code&gt;,
 then an &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt;
 is thrown.
 If &lt;code&gt;len&lt;/code&gt; is zero,
 then no bytes are read. Otherwise, the first
 byte read is stored into element &lt;code&gt;b[off]&lt;/code&gt;,
 the next one into &lt;code&gt;b[off+1]&lt;/code&gt;,
 and so on. The number of bytes read is,
 at most, equal to &lt;code&gt;len&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>b   the buffer into which the data is read.</description>
					</attribute>
					<attribute name="@param">
						<description>off  an int specifying the offset into the data.</description>
					</attribute>
					<attribute name="@param">
						<description>len  an int specifying the number of bytes to read.</description>
					</attribute>
					<attribute name="@exception">
						<description>EOFException  if this stream reaches the end before reading
               all the bytes.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException   if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the buffer into which the data is read." fulltype="byte[]" type="byte" />
					<param name="off" comment="an int specifying the offset into the data." fulltype="int" type="int" />
					<param name="len" comment="an int specifying the number of bytes to read." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="skipBytes" returncomment="the number of bytes actually skipped." fulltype="int" type="int">
				<comment>
					<description>Makes an attempt to skip over
 &lt;code&gt;n&lt;/code&gt; bytes
 of data from the input
 stream, discarding the skipped bytes. However,
 it may skip
 over some smaller number of
 bytes, possibly zero. This may result from
 any of a
 number of conditions; reaching
 end of file before &lt;code&gt;n&lt;/code&gt; bytes
 have been skipped is
 only one possibility.
 This method never throws an &lt;code&gt;EOFException&lt;/code&gt;.
 The actual
 number of bytes skipped is returned.</description>
					<attribute name="@param">
						<description>n   the number of bytes to be skipped.</description>
					</attribute>
					<attribute name="@return">
						<description>the number of bytes actually skipped.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException   if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="n" comment="the number of bytes to be skipped." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="readBoolean" returncomment="the &lt;code&gt;boolean&lt;/code&gt; value read." fulltype="boolean" type="boolean">
				<comment>
					<description>Reads one input byte and returns
 &lt;code&gt;true&lt;/code&gt; if that byte is nonzero,
 &lt;code&gt;false&lt;/code&gt; if that byte is zero.
 This method is suitable for reading
 the byte written by the &lt;code&gt;writeBoolean&lt;/code&gt;
 method of interface &lt;code&gt;DataOutput&lt;/code&gt;.</description>
					<attribute name="@return">
						<description>the &lt;code&gt;boolean&lt;/code&gt; value read.</description>
					</attribute>
					<attribute name="@exception">
						<description>EOFException  if this stream reaches the end before reading
               all the bytes.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException   if an I/O error occurs.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="readByte" returncomment="the 8-bit value read." fulltype="byte" type="byte">
				<comment>
					<description>Reads and returns one input byte.
 The byte is treated as a signed value in
 the range &lt;code&gt;-128&lt;/code&gt; through &lt;code&gt;127&lt;/code&gt;,
 inclusive.
 This method is suitable for
 reading the byte written by the &lt;code&gt;writeByte&lt;/code&gt;
 method of interface &lt;code&gt;DataOutput&lt;/code&gt;.</description>
					<attribute name="@return">
						<description>the 8-bit value read.</description>
					</attribute>
					<attribute name="@exception">
						<description>EOFException  if this stream reaches the end before reading
               all the bytes.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException   if an I/O error occurs.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="readUnsignedByte" returncomment="the unsigned 8-bit value read." fulltype="int" type="int">
				<comment>
					<description>Reads one input byte, zero-extends
 it to type &lt;code&gt;int&lt;/code&gt;, and returns
 the result, which is therefore in the range
 &lt;code&gt;0&lt;/code&gt;
 through &lt;code&gt;255&lt;/code&gt;.
 This method is suitable for reading
 the byte written by the &lt;code&gt;writeByte&lt;/code&gt;
 method of interface &lt;code&gt;DataOutput&lt;/code&gt;
 if the argument to &lt;code&gt;writeByte&lt;/code&gt;
 was intended to be a value in the range
 &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;255&lt;/code&gt;.</description>
					<attribute name="@return">
						<description>the unsigned 8-bit value read.</description>
					</attribute>
					<attribute name="@exception">
						<description>EOFException  if this stream reaches the end before reading
               all the bytes.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException   if an I/O error occurs.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="readShort" returncomment="the 16-bit value read." fulltype="short" type="short">
				<comment>
					<description>Reads two input bytes and returns
 a &lt;code&gt;short&lt;/code&gt; value. Let &lt;code&gt;a&lt;/code&gt;
 be the first byte read and &lt;code&gt;b&lt;/code&gt;
 be the second byte. The value
 returned
 is:
 &lt;p&gt;&lt;pre&gt;&lt;code&gt;(short)((a &amp;lt;&amp;lt; 8) | (b &amp;amp; 0xff))
 &lt;/code&gt;&lt;/pre&gt;
 This method
 is suitable for reading the bytes written
 by the &lt;code&gt;writeShort&lt;/code&gt; method of
 interface &lt;code&gt;DataOutput&lt;/code&gt;.</description>
					<attribute name="@return">
						<description>the 16-bit value read.</description>
					</attribute>
					<attribute name="@exception">
						<description>EOFException  if this stream reaches the end before reading
               all the bytes.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException   if an I/O error occurs.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="readUnsignedShort" returncomment="the unsigned 16-bit value read." fulltype="int" type="int">
				<comment>
					<description>Reads two input bytes and returns
 an &lt;code&gt;int&lt;/code&gt; value in the range &lt;code&gt;0&lt;/code&gt;
 through &lt;code&gt;65535&lt;/code&gt;. Let &lt;code&gt;a&lt;/code&gt;
 be the first byte read and
 &lt;code&gt;b&lt;/code&gt;
 be the second byte. The value returned is:
 &lt;p&gt;&lt;pre&gt;&lt;code&gt;(((a &amp;amp; 0xff) &amp;lt;&amp;lt; 8) | (b &amp;amp; 0xff))
 &lt;/code&gt;&lt;/pre&gt;
 This method is suitable for reading the bytes
 written by the &lt;code&gt;writeShort&lt;/code&gt; method
 of interface &lt;code&gt;DataOutput&lt;/code&gt;  if
 the argument to &lt;code&gt;writeShort&lt;/code&gt;
 was intended to be a value in the range
 &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;65535&lt;/code&gt;.</description>
					<attribute name="@return">
						<description>the unsigned 16-bit value read.</description>
					</attribute>
					<attribute name="@exception">
						<description>EOFException  if this stream reaches the end before reading
               all the bytes.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException   if an I/O error occurs.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="readChar" returncomment="the &lt;code&gt;char&lt;/code&gt; value read." fulltype="char" type="char">
				<comment>
					<description>Reads two input bytes and returns a &lt;code&gt;char&lt;/code&gt; value.
 Let &lt;code&gt;a&lt;/code&gt;
 be the first byte read and &lt;code&gt;b&lt;/code&gt;
 be the second byte. The value
 returned is:
 &lt;p&gt;&lt;pre&gt;&lt;code&gt;(char)((a &amp;lt;&amp;lt; 8) | (b &amp;amp; 0xff))
 &lt;/code&gt;&lt;/pre&gt;
 This method
 is suitable for reading bytes written by
 the &lt;code&gt;writeChar&lt;/code&gt; method of interface
 &lt;code&gt;DataOutput&lt;/code&gt;.</description>
					<attribute name="@return">
						<description>the &lt;code&gt;char&lt;/code&gt; value read.</description>
					</attribute>
					<attribute name="@exception">
						<description>EOFException  if this stream reaches the end before reading
               all the bytes.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException   if an I/O error occurs.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="readInt" returncomment="the &lt;code&gt;int&lt;/code&gt; value read." fulltype="int" type="int">
				<comment>
					<description>Reads four input bytes and returns an
 &lt;code&gt;int&lt;/code&gt; value. Let &lt;code&gt;a-d&lt;/code&gt;
 be the first through fourth bytes read. The value returned is:
 &lt;p&gt;&lt;pre&gt;
 &lt;code&gt;
 (((a &amp;amp; 0xff) &amp;lt;&amp;lt; 24) | ((b &amp;amp; 0xff) &amp;lt;&amp;lt; 16) |
 &amp;#32;((c &amp;amp; 0xff) &amp;lt;&amp;lt; 8) | (d &amp;amp; 0xff))
 &lt;/code&gt;&lt;/pre&gt;
 This method is suitable
 for reading bytes written by the &lt;code&gt;writeInt&lt;/code&gt;
 method of interface &lt;code&gt;DataOutput&lt;/code&gt;.</description>
					<attribute name="@return">
						<description>the &lt;code&gt;int&lt;/code&gt; value read.</description>
					</attribute>
					<attribute name="@exception">
						<description>EOFException  if this stream reaches the end before reading
               all the bytes.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException   if an I/O error occurs.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="readLong" returncomment="the &lt;code&gt;long&lt;/code&gt; value read." fulltype="long" type="long">
				<comment>
					<description>Reads eight input bytes and returns
 a &lt;code&gt;long&lt;/code&gt; value. Let &lt;code&gt;a-h&lt;/code&gt;
 be the first through eighth bytes read.
 The value returned is:
 &lt;p&gt;&lt;pre&gt; &lt;code&gt;
 (((long)(a &amp;amp; 0xff) &amp;lt;&amp;lt; 56) |
  ((long)(b &amp;amp; 0xff) &amp;lt;&amp;lt; 48) |
  ((long)(c &amp;amp; 0xff) &amp;lt;&amp;lt; 40) |
  ((long)(d &amp;amp; 0xff) &amp;lt;&amp;lt; 32) |
  ((long)(e &amp;amp; 0xff) &amp;lt;&amp;lt; 24) |
  ((long)(f &amp;amp; 0xff) &amp;lt;&amp;lt; 16) |
  ((long)(g &amp;amp; 0xff) &amp;lt;&amp;lt;  8) |
  ((long)(h &amp;amp; 0xff)))
 &lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
 This method is suitable
 for reading bytes written by the &lt;code&gt;writeLong&lt;/code&gt;
 method of interface &lt;code&gt;DataOutput&lt;/code&gt;.</description>
					<attribute name="@return">
						<description>the &lt;code&gt;long&lt;/code&gt; value read.</description>
					</attribute>
					<attribute name="@exception">
						<description>EOFException  if this stream reaches the end before reading
               all the bytes.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException   if an I/O error occurs.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="readFloat" returncomment="the &lt;code&gt;float&lt;/code&gt; value read." fulltype="float" type="float">
				<comment>
					<description>Reads four input bytes and returns
 a &lt;code&gt;float&lt;/code&gt; value. It does this
 by first constructing an &lt;code&gt;int&lt;/code&gt;
 value in exactly the manner
 of the &lt;code&gt;readInt&lt;/code&gt;
 method, then converting this &lt;code&gt;int&lt;/code&gt;
 value to a &lt;code&gt;float&lt;/code&gt; in
 exactly the manner of the method &lt;code&gt;Float.intBitsToFloat&lt;/code&gt;.
 This method is suitable for reading
 bytes written by the &lt;code&gt;writeFloat&lt;/code&gt;
 method of interface &lt;code&gt;DataOutput&lt;/code&gt;.</description>
					<attribute name="@return">
						<description>the &lt;code&gt;float&lt;/code&gt; value read.</description>
					</attribute>
					<attribute name="@exception">
						<description>EOFException  if this stream reaches the end before reading
               all the bytes.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException   if an I/O error occurs.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="readDouble" returncomment="the &lt;code&gt;double&lt;/code&gt; value read." fulltype="double" type="double">
				<comment>
					<description>Reads eight input bytes and returns
 a &lt;code&gt;double&lt;/code&gt; value. It does this
 by first constructing a &lt;code&gt;long&lt;/code&gt;
 value in exactly the manner
 of the &lt;code&gt;readlong&lt;/code&gt;
 method, then converting this &lt;code&gt;long&lt;/code&gt;
 value to a &lt;code&gt;double&lt;/code&gt; in exactly
 the manner of the method &lt;code&gt;Double.longBitsToDouble&lt;/code&gt;.
 This method is suitable for reading
 bytes written by the &lt;code&gt;writeDouble&lt;/code&gt;
 method of interface &lt;code&gt;DataOutput&lt;/code&gt;.</description>
					<attribute name="@return">
						<description>the &lt;code&gt;double&lt;/code&gt; value read.</description>
					</attribute>
					<attribute name="@exception">
						<description>EOFException  if this stream reaches the end before reading
               all the bytes.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException   if an I/O error occurs.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="readLine" returncomment="the next line of text from the input stream,
         or &lt;CODE&gt;null&lt;/CODE&gt; if the end of file is
         encountered before a byte can be read." fulltype="java.lang.String" type="String">
				<comment>
					<description>Reads the next line of text from the input stream.
 It reads successive bytes, converting
 each byte separately into a character,
 until it encounters a line terminator or
 end of
 file; the characters read are then
 returned as a &lt;code&gt;String&lt;/code&gt;. Note
 that because this
 method processes bytes,
 it does not support input of the full Unicode
 character set.
 &lt;p&gt;
 If end of file is encountered
 before even one byte can be read, then &lt;code&gt;null&lt;/code&gt;
 is returned. Otherwise, each byte that is
 read is converted to type &lt;code&gt;char&lt;/code&gt;
 by zero-extension. If the character &lt;code&gt;&apos;\n&apos;&lt;/code&gt;
 is encountered, it is discarded and reading
 ceases. If the character &lt;code&gt;&apos;\r&apos;&lt;/code&gt;
 is encountered, it is discarded and, if
 the following byte converts &amp;#32;to the
 character &lt;code&gt;&apos;\n&apos;&lt;/code&gt;, then that is
 discarded also; reading then ceases. If
 end of file is encountered before either
 of the characters &lt;code&gt;&apos;\n&apos;&lt;/code&gt; and
 &lt;code&gt;&apos;\r&apos;&lt;/code&gt; is encountered, reading
 ceases. Once reading has ceased, a &lt;code&gt;String&lt;/code&gt;
 is returned that contains all the characters
 read and not discarded, taken in order.
 Note that every character in this string
 will have a value less than &lt;code&gt;&amp;#92;u0100&lt;/code&gt;,
 that is, &lt;code&gt;(char)256&lt;/code&gt;.</description>
					<attribute name="@return">
						<description>the next line of text from the input stream,
         or &lt;CODE&gt;null&lt;/CODE&gt; if the end of file is
         encountered before a byte can be read.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="readUTF" returncomment="a Unicode string." fulltype="java.lang.String" type="String">
				<comment>
					<description>Reads in a string that has been encoded using a
 &lt;a href=&quot;#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt;
 format.
 The general contract of &lt;code&gt;readUTF&lt;/code&gt;
 is that it reads a representation of a Unicode
 character string encoded in modified
 UTF-8 format; this string of characters
 is then returned as a &lt;code&gt;String&lt;/code&gt;.
 &lt;p&gt;
 First, two bytes are read and used to
 construct an unsigned 16-bit integer in
 exactly the manner of the &lt;code&gt;readUnsignedShort&lt;/code&gt;
 method . This integer value is called the
 &lt;i&gt;UTF length&lt;/i&gt; and specifies the number
 of additional bytes to be read. These bytes
 are then converted to characters by considering
 them in groups. The length of each group
 is computed from the value of the first
 byte of the group. The byte following a
 group, if any, is the first byte of the
 next group.
 &lt;p&gt;
 If the first byte of a group
 matches the bit pattern &lt;code&gt;0xxxxxxx&lt;/code&gt;
 (where &lt;code&gt;x&lt;/code&gt; means &quot;may be &lt;code&gt;0&lt;/code&gt;
 or &lt;code&gt;1&lt;/code&gt;&quot;), then the group consists
 of just that byte. The byte is zero-extended
 to form a character.
 &lt;p&gt;
 If the first byte
 of a group matches the bit pattern &lt;code&gt;110xxxxx&lt;/code&gt;,
 then the group consists of that byte &lt;code&gt;a&lt;/code&gt;
 and a second byte &lt;code&gt;b&lt;/code&gt;. If there
 is no byte &lt;code&gt;b&lt;/code&gt; (because byte
 &lt;code&gt;a&lt;/code&gt; was the last of the bytes
 to be read), or if byte &lt;code&gt;b&lt;/code&gt; does
 not match the bit pattern &lt;code&gt;10xxxxxx&lt;/code&gt;,
 then a &lt;code&gt;UTFDataFormatException&lt;/code&gt;
 is thrown. Otherwise, the group is converted
 to the character:&lt;p&gt;
 &lt;pre&gt;&lt;code&gt;(char)(((a&amp;amp; 0x1F) &amp;lt;&amp;lt; 6) | (b &amp;amp; 0x3F))
 &lt;/code&gt;&lt;/pre&gt;
 If the first byte of a group
 matches the bit pattern &lt;code&gt;1110xxxx&lt;/code&gt;,
 then the group consists of that byte &lt;code&gt;a&lt;/code&gt;
 and two more bytes &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;.
 If there is no byte &lt;code&gt;c&lt;/code&gt; (because
 byte &lt;code&gt;a&lt;/code&gt; was one of the last
 two of the bytes to be read), or either
 byte &lt;code&gt;b&lt;/code&gt; or byte &lt;code&gt;c&lt;/code&gt;
 does not match the bit pattern &lt;code&gt;10xxxxxx&lt;/code&gt;,
 then a &lt;code&gt;UTFDataFormatException&lt;/code&gt;
 is thrown. Otherwise, the group is converted
 to the character:&lt;p&gt;
 &lt;pre&gt;&lt;code&gt;
 (char)(((a &amp;amp; 0x0F) &amp;lt;&amp;lt; 12) | ((b &amp;amp; 0x3F) &amp;lt;&amp;lt; 6) | (c &amp;amp; 0x3F))
 &lt;/code&gt;&lt;/pre&gt;
 If the first byte of a group matches the
 pattern &lt;code&gt;1111xxxx&lt;/code&gt; or the pattern
 &lt;code&gt;10xxxxxx&lt;/code&gt;, then a &lt;code&gt;UTFDataFormatException&lt;/code&gt;
 is thrown.
 &lt;p&gt;
 If end of file is encountered
 at any time during this entire process,
 then an &lt;code&gt;EOFException&lt;/code&gt; is thrown.
 &lt;p&gt;
 After every group has been converted to
 a character by this process, the characters
 are gathered, in the same order in which
 their corresponding groups were read from
 the input stream, to form a &lt;code&gt;String&lt;/code&gt;,
 which is returned.
 &lt;p&gt;
 The &lt;code&gt;writeUTF&lt;/code&gt;
 method of interface &lt;code&gt;DataOutput&lt;/code&gt;
 may be used to write data that is suitable
 for reading by this method.</description>
					<attribute name="@return">
						<description>a Unicode string.</description>
					</attribute>
					<attribute name="@exception">
						<description>EOFException            if this stream reaches the end
               before reading all the bytes.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException             if an I/O error occurs.</description>
					</attribute>
					<attribute name="@exception">
						<description>UTFDataFormatException  if the bytes do not represent a
               valid modified UTF-8 encoding of a string.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="Object" visibility="package-private" package="java.io" superclassfulltype="java.lang.Object" fulltype="java.io.ExpiringCache" type="ExpiringCache">
		<fields>
			<field visibility="private" name="millisUntilExpiration" fulltype="long" type="long" />
			<field visibility="private" name="map" fulltype="java.util.Map" type="Map" />
			<field visibility="private" name="queryCount" fulltype="int" type="int" />
			<field visibility="private" name="queryOverflow" fulltype="int" type="int" />
			<field visibility="private" name="MAX_ENTRIES" fulltype="int" type="int" />
		</fields>
		<methods>
			<constructor visibility="package-private" name="ExpiringCache" />
			<constructor visibility="package-private" name="ExpiringCache">
				<params>
					<param name="millisUntilExpiration" fulltype="long" type="long" />
				</params>
			</constructor>
			<method synchronized="true" visibility="package-private" name="get" fulltype="java.lang.String" type="String">
				<params>
					<param name="key" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method synchronized="true" visibility="package-private" name="put" fulltype="void" type="void">
				<params>
					<param name="key" fulltype="java.lang.String" type="String" />
					<param name="val" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method synchronized="true" visibility="package-private" name="clear" fulltype="void" type="void" />
			<method visibility="private" name="entryFor" fulltype="java.io.ExpiringCache.Entry" type="ExpiringCache.Entry">
				<params>
					<param name="key" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="private" name="cleanup" fulltype="void" type="void" />
		</methods>
		<jelclass superclass="Object" visibility="package-private" package="java.io" superclassfulltype="java.lang.Object" fulltype="java.io.ExpiringCache.Entry" type="ExpiringCache.Entry">
			<fields>
				<field visibility="private" name="timestamp" fulltype="long" type="long" />
				<field visibility="private" name="val" fulltype="java.lang.String" type="String" />
			</fields>
			<methods>
				<constructor visibility="package-private" name="ExpiringCache.Entry">
					<params>
						<param name="timestamp" fulltype="long" type="long" />
						<param name="val" fulltype="java.lang.String" type="String" />
					</params>
				</constructor>
				<method visibility="package-private" name="timestamp" fulltype="long" type="long" />
				<method visibility="package-private" name="setTimestamp" fulltype="void" type="void">
					<params>
						<param name="timestamp" fulltype="long" type="long" />
					</params>
				</method>
				<method visibility="package-private" name="val" fulltype="java.lang.String" type="String" />
				<method visibility="package-private" name="setVal" fulltype="void" type="void">
					<params>
						<param name="val" fulltype="java.lang.String" type="String" />
					</params>
				</method>
			</methods>
		</jelclass>
	</jelclass>
	<jelclass superclass="Object" visibility="package-private" package="java.io" superclassfulltype="java.lang.Object" fulltype="java.io.ExpiringCache.Entry" type="ExpiringCache.Entry">
		<fields>
			<field visibility="private" name="timestamp" fulltype="long" type="long" />
			<field visibility="private" name="val" fulltype="java.lang.String" type="String" />
		</fields>
		<methods>
			<constructor visibility="package-private" name="ExpiringCache.Entry">
				<params>
					<param name="timestamp" fulltype="long" type="long" />
					<param name="val" fulltype="java.lang.String" type="String" />
				</params>
			</constructor>
			<method visibility="package-private" name="timestamp" fulltype="long" type="long" />
			<method visibility="package-private" name="setTimestamp" fulltype="void" type="void">
				<params>
					<param name="timestamp" fulltype="long" type="long" />
				</params>
			</method>
			<method visibility="package-private" name="val" fulltype="java.lang.String" type="String" />
			<method visibility="package-private" name="setVal" fulltype="void" type="void">
				<params>
					<param name="val" fulltype="java.lang.String" type="String" />
				</params>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="ObjectStreamException" visibility="public" package="java.io" serializable="true" superclassfulltype="java.io.ObjectStreamException" fulltype="java.io.NotActiveException" type="NotActiveException">
		<comment>
			<description>Thrown when serialization or deserialization is not active.</description>
			<attribute name="@author">
				<description>unascribed</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.1</description>
			</attribute>
		</comment>
		<fields>
			<field final="true" static="true" const="-3893467273049808895" visibility="private" name="serialVersionUID" constexpr="-3893467273049808895L" fulltype="long" type="long" />
		</fields>
		<methods>
			<constructor visibility="public" name="NotActiveException">
				<comment>
					<description>Constructor to create a new NotActiveException with the reason given.</description>
					<attribute name="@param">
						<description>reason  a String describing the reason for the exception.</description>
					</attribute>
				</comment>
				<params>
					<param name="reason" comment="a String describing the reason for the exception." fulltype="java.lang.String" type="String" />
				</params>
			</constructor>
			<constructor visibility="public" name="NotActiveException">
				<comment>
					<description>Constructor to create a new NotActiveException without a reason.</description>
				</comment>
			</constructor>
		</methods>
	</jelclass>
	<jelclass abstract="true" visibility="public" package="java.io" serializable="true" interface="true" fulltype="java.io.Externalizable" type="Externalizable">
		<implements>
			<interface fulltype="java.io.Serializable" type="Serializable" />
		</implements>
		<comment>
			<description>Only the identity of the class of an Externalizable instance is
 written in the serialization stream and it is the responsibility
 of the class to save and restore the contents of its instances.

 The writeExternal and readExternal methods of the Externalizable
 interface are implemented by a class to give the class complete
 control over the format and contents of the stream for an object
 and its supertypes. These methods must explicitly
 coordinate with the supertype to save its state. These methods supersede
 customized implementations of writeObject and readObject methods.&lt;br&gt;

 Object Serialization uses the Serializable and Externalizable
 interfaces.  Object persistence mechanisms can use them as well.  Each
 object to be stored is tested for the Externalizable interface. If
 the object supports Externalizable, the writeExternal method is called. If the
 object does not support Externalizable and does implement
 Serializable, the object is saved using
 ObjectOutputStream. &lt;br&gt; When an Externalizable object is
 reconstructed, an instance is created using the public no-arg
 constructor, then the readExternal method called.  Serializable
 objects are restored by reading them from an ObjectInputStream.&lt;br&gt;

 An Externalizable instance can designate a substitution object via
 the writeReplace and readResolve methods documented in the Serializable
 interface.&lt;br&gt;</description>
			<attribute name="@author">
				<description>unascribed</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.ObjectOutputStream</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.ObjectInputStream</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.ObjectOutput</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.ObjectInput</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.Serializable</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.1</description>
			</attribute>
		</comment>
		<methods>
			<method visibility="public" name="writeExternal" fulltype="void" type="void">
				<comment>
					<description>The object implements the writeExternal method to save its contents
 by calling the methods of DataOutput for its primitive values or
 calling the writeObject method of ObjectOutput for objects, strings,
 and arrays.</description>
					<attribute name="@serialData">
						<description>Overriding methods should use this tag to describe
             the data layout of this Externalizable object.
             List the sequence of element types and, if possible,
             relate the element to a public/protected field and/or
             method of this Externalizable class.</description>
					</attribute>
					<attribute name="@param">
						<description>out the stream to write the object to</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException Includes any I/O exceptions that may occur</description>
					</attribute>
				</comment>
				<params>
					<param name="out" comment="the stream to write the object to" fulltype="java.io.ObjectOutput" type="ObjectOutput" />
				</params>
				<exceptions>
					<exception comment="Includes any I/O exceptions that may occur" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="readExternal" fulltype="void" type="void">
				<comment>
					<description>The object implements the readExternal method to restore its
 contents by calling the methods of DataInput for primitive
 types and readObject for objects, strings and arrays.  The
 readExternal method must read the values in the same sequence
 and with the same types as were written by writeExternal.</description>
					<attribute name="@param">
						<description>in the stream to read data from in order to restore the object</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException if I/O errors occur</description>
					</attribute>
					<attribute name="@exception">
						<description>ClassNotFoundException If the class for an object being
              restored cannot be found.</description>
					</attribute>
				</comment>
				<params>
					<param name="in" comment="the stream to read data from in order to restore the object" fulltype="java.io.ObjectInput" type="ObjectInput" />
				</params>
				<exceptions>
					<exception comment="if I/O errors occur" fulltype="java.io.IOException" type="IOException" />
					<exception comment="If the class for an object being
              restored cannot be found." fulltype="java.lang.ClassNotFoundException" type="ClassNotFoundException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="Object" visibility="public" package="java.io" superclassfulltype="java.lang.Object" fulltype="java.io.ObjectStreamField" type="ObjectStreamField">
		<implements>
			<interface fulltype="java.lang.Comparable" type="Comparable" />
		</implements>
		<comment>
			<description>A description of a Serializable field from a Serializable class.  An array
 of ObjectStreamFields is used to declare the Serializable fields of a class.</description>
			<attribute name="@author">
				<description>Mike Warres</description>
			</attribute>
			<attribute name="@author">
				<description>Roger Riggs</description>
			</attribute>
			<attribute name="@see">
				<description>ObjectStreamClass</description>
			</attribute>
			<attribute name="@since">
				<description>1.2</description>
			</attribute>
		</comment>
		<fields>
			<field final="true" visibility="private" name="name" fulltype="java.lang.String" type="String">
				<comment>
					<description>field name</description>
				</comment>
			</field>
			<field final="true" visibility="private" name="signature" fulltype="java.lang.String" type="String">
				<comment>
					<description>canonical JVM signature of field type</description>
				</comment>
			</field>
			<field final="true" visibility="private" name="type" fulltype="java.lang.Class" type="Class">
				<comment>
					<description>field type (Object.class if unknown non-primitive type)</description>
				</comment>
			</field>
			<field final="true" visibility="private" name="unshared" fulltype="boolean" type="boolean">
				<comment>
					<description>whether or not to (de)serialize field values as unshared</description>
				</comment>
			</field>
			<field final="true" visibility="private" name="field" fulltype="java.lang.reflect.Field" type="Field">
				<comment>
					<description>corresponding reflective field object, if any</description>
				</comment>
			</field>
			<field visibility="private" name="offset" fulltype="int" type="int">
				<comment>
					<description>offset of field value in enclosing field group</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="public" name="ObjectStreamField">
				<comment>
					<description>Create a Serializable field with the specified type.  This field should
 be documented with a &lt;code&gt;serialField&lt;/code&gt; tag.</description>
					<attribute name="@param">
						<description>name the name of the serializable field</description>
					</attribute>
					<attribute name="@param">
						<description>type the &lt;code&gt;Class&lt;/code&gt; object of the serializable field</description>
					</attribute>
				</comment>
				<params>
					<param name="name" comment="the name of the serializable field" fulltype="java.lang.String" type="String" />
					<param name="type" comment="the &lt;code&gt;Class&lt;/code&gt; object of the serializable field" fulltype="java.lang.Class" type="Class" />
				</params>
			</constructor>
			<constructor visibility="public" name="ObjectStreamField">
				<comment>
					<description>Creates an ObjectStreamField representing a serializable field with the
 given name and type.  If unshared is false, values of the represented
 field are serialized and deserialized in the default manner--if the
 field is non-primitive, object values are serialized and deserialized as
 if they had been written and read by calls to writeObject and
 readObject.  If unshared is true, values of the represented field are
 serialized and deserialized as if they had been written and read by
 calls to writeUnshared and readUnshared.</description>
					<attribute name="@param">
						<description>name field name</description>
					</attribute>
					<attribute name="@param">
						<description>type field type</description>
					</attribute>
					<attribute name="@param">
						<description>unshared if false, write/read field values in the same manner
          as writeObject/readObject; if true, write/read in the same
          manner as writeUnshared/readUnshared</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
				<params>
					<param name="name" comment="field name" fulltype="java.lang.String" type="String" />
					<param name="type" comment="field type" fulltype="java.lang.Class" type="Class" />
					<param name="unshared" comment="if false, write/read field values in the same manner
          as writeObject/readObject; if true, write/read in the same
          manner as writeUnshared/readUnshared" fulltype="boolean" type="boolean" />
				</params>
			</constructor>
			<constructor visibility="package-private" name="ObjectStreamField">
				<comment>
					<description>Creates an ObjectStreamField representing a field with the given name,
 signature and unshared setting.</description>
				</comment>
				<params>
					<param name="name" fulltype="java.lang.String" type="String" />
					<param name="signature" fulltype="java.lang.String" type="String" />
					<param name="unshared" fulltype="boolean" type="boolean" />
				</params>
			</constructor>
			<constructor visibility="package-private" name="ObjectStreamField">
				<comment>
					<description>Creates an ObjectStreamField representing the given field with the
 specified unshared setting.  For compatibility with the behavior of
 earlier serialization implementations, a &quot;showType&quot; parameter is
 necessary to govern whether or not a getType() call on this
 ObjectStreamField (if non-primitive) will return Object.class (as
 opposed to a more specific reference type).</description>
				</comment>
				<params>
					<param name="field" fulltype="java.lang.reflect.Field" type="Field" />
					<param name="unshared" fulltype="boolean" type="boolean" />
					<param name="showType" fulltype="boolean" type="boolean" />
				</params>
			</constructor>
			<method visibility="public" name="getName" returncomment="a &lt;code&gt;String&lt;/code&gt; representing the name of the serializable
          field" fulltype="java.lang.String" type="String">
				<comment>
					<description>Get the name of this field.</description>
					<attribute name="@return">
						<description>a &lt;code&gt;String&lt;/code&gt; representing the name of the serializable
          field</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getType" returncomment="a &lt;code&gt;Class&lt;/code&gt; object representing the type of the
          serializable field" fulltype="java.lang.Class" type="Class">
				<comment>
					<description>Get the type of the field.  If the type is non-primitive and this
 &lt;code&gt;ObjectStreamField&lt;/code&gt; was obtained from a deserialized {@link
 ObjectStreamClass} instance, then &lt;code&gt;Object.class&lt;/code&gt; is returned.
 Otherwise, the &lt;code&gt;Class&lt;/code&gt; object for the type of the field is
 returned.</description>
					<attribute name="@return">
						<description>a &lt;code&gt;Class&lt;/code&gt; object representing the type of the
          serializable field</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getTypeCode" returncomment="the typecode of the serializable field" fulltype="char" type="char">
				<comment>
					<description>Returns character encoding of field type.  The encoding is as follows:
 &lt;blockquote&gt;&lt;pre&gt;
 B            byte
 C            char
 D            double
 F            float
 I            int
 J            long
 L            class or interface
 S            short
 Z            boolean
 [            array
 &lt;/pre&gt;&lt;/blockquote&gt;</description>
					<attribute name="@return">
						<description>the typecode of the serializable field</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getTypeString" returncomment="null if this field has a primitive type." fulltype="java.lang.String" type="String">
				<comment>
					<description>Return the JVM type signature.</description>
					<attribute name="@return">
						<description>null if this field has a primitive type.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getOffset" returncomment="the offset of this field" fulltype="int" type="int">
				<comment>
					<description>Offset of field within instance data.</description>
					<attribute name="@return">
						<description>the offset of this field</description>
					</attribute>
					<attribute name="@see">
						<description>#setOffset</description>
					</attribute>
				</comment>
			</method>
			<method visibility="protected" name="setOffset" fulltype="void" type="void">
				<comment>
					<description>Offset within instance data.</description>
					<attribute name="@param">
						<description>offset the offset of the field</description>
					</attribute>
					<attribute name="@see">
						<description>#getOffset</description>
					</attribute>
				</comment>
				<params>
					<param name="offset" comment="the offset of the field" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="isPrimitive" returncomment="true if and only if this field corresponds to a primitive type" fulltype="boolean" type="boolean">
				<comment>
					<description>Return true if this field has a primitive type.</description>
					<attribute name="@return">
						<description>true if and only if this field corresponds to a primitive type</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="isUnshared" fulltype="boolean" type="boolean">
				<comment>
					<description>Returns boolean value indicating whether or not the serializable field
 represented by this ObjectStreamField instance is unshared.</description>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="compareTo" fulltype="int" type="int">
				<comment>
					<description>Compare this field with another &lt;code&gt;ObjectStreamField&lt;/code&gt;.  Return
 -1 if this is smaller, 0 if equal, 1 if greater.  Types that are
 primitives are &quot;smaller&quot; than object types.  If equal, the field names
 are compared.</description>
				</comment>
				<params>
					<param name="obj" fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method visibility="public" name="toString" fulltype="java.lang.String" type="String">
				<comment>
					<description>Return a string that describes this field.</description>
				</comment>
			</method>
			<method visibility="package-private" name="getField" fulltype="java.lang.reflect.Field" type="Field">
				<comment>
					<description>Returns field represented by this ObjectStreamField, or null if
 ObjectStreamField is not associated with an actual field.</description>
				</comment>
			</method>
			<method visibility="package-private" name="getSignature" fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns JVM type signature of field (similar to getTypeString, except
 that signature strings are returned for primitive fields as well).</description>
				</comment>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="Writer" visibility="public" package="java.io" superclassfulltype="java.io.Writer" fulltype="java.io.PipedWriter" type="PipedWriter">
		<comment>
			<description>Piped character-output streams.</description>
			<attribute name="@author">
				<description>Mark Reinhold</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.1</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="private" name="sink" fulltype="java.io.PipedReader" type="PipedReader" />
			<field visibility="private" name="closed" fulltype="boolean" type="boolean" />
		</fields>
		<methods>
			<constructor visibility="public" name="PipedWriter">
				<comment>
					<description>Creates a piped writer connected to the specified piped
 reader. Data characters written to this stream will then be
 available as input from &lt;code&gt;snk&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>snk   The piped reader to connect to.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="snk" comment="The piped reader to connect to." fulltype="java.io.PipedReader" type="PipedReader" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</constructor>
			<constructor visibility="public" name="PipedWriter">
				<comment>
					<description>Creates a piped writer that is not yet connected to a
 piped reader. It must be connected to a piped reader,
 either by the receiver or the sender, before being used.</description>
					<attribute name="@see">
						<description>java.io.PipedReader#connect(java.io.PipedWriter)</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.PipedWriter#connect(java.io.PipedReader)</description>
					</attribute>
				</comment>
			</constructor>
			<method synchronized="true" visibility="public" name="connect" fulltype="void" type="void">
				<comment>
					<description>Connects this piped writer to a receiver. If this object
 is already connected to some other piped reader, an
 &lt;code&gt;IOException&lt;/code&gt; is thrown.
 &lt;p&gt;
 If &lt;code&gt;snk&lt;/code&gt; is an unconnected piped reader and
 &lt;code&gt;src&lt;/code&gt; is an unconnected piped writer, they may
 be connected by either the call:
 &lt;blockquote&gt;&lt;pre&gt;
 src.connect(snk)&lt;/pre&gt;&lt;/blockquote&gt;
 or the call:
 &lt;blockquote&gt;&lt;pre&gt;
 snk.connect(src)&lt;/pre&gt;&lt;/blockquote&gt;
 The two calls have the same effect.</description>
					<attribute name="@param">
						<description>snk   the piped reader to connect to.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="snk" comment="the piped reader to connect to." fulltype="java.io.PipedReader" type="PipedReader" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes the specified &lt;code&gt;char&lt;/code&gt; to the piped output stream.
 If a thread was reading data characters from the connected piped input
 stream, but the thread is no longer alive, then an
 &lt;code&gt;IOException&lt;/code&gt; is thrown.
 &lt;p&gt;
 Implements the &lt;code&gt;write&lt;/code&gt; method of &lt;code&gt;Writer&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>c   the &lt;code&gt;char&lt;/code&gt; to be written.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if the pipe is
          &lt;a href=PipedOutputStream.html#BROKEN&gt; &lt;code&gt;broken&lt;/code&gt;&lt;/a&gt;,
          {@link #connect(java.io.PipedReader) unconnected}, closed
          or an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="c" comment="the &lt;code&gt;char&lt;/code&gt; to be written." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if the pipe is
          &lt;a href=PipedOutputStream.html#BROKEN&gt; &lt;code&gt;broken&lt;/code&gt;&lt;/a&gt;,
          {@link #connect(java.io.PipedReader) unconnected}, closed
          or an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes &lt;code&gt;len&lt;/code&gt; characters from the specified character array
 starting at offset &lt;code&gt;off&lt;/code&gt; to this piped output stream.
 This method blocks until all the characters are written to the output
 stream.
 If a thread was reading data characters from the connected piped input
 stream, but the thread is no longer alive, then an
 &lt;code&gt;IOException&lt;/code&gt; is thrown.</description>
					<attribute name="@param">
						<description>cbuf  the data.</description>
					</attribute>
					<attribute name="@param">
						<description>off   the start offset in the data.</description>
					</attribute>
					<attribute name="@param">
						<description>len   the number of characters to write.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if the pipe is
          &lt;a href=PipedOutputStream.html#BROKEN&gt; &lt;code&gt;broken&lt;/code&gt;&lt;/a&gt;,
          {@link #connect(java.io.PipedReader) unconnected}, closed
          or an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="cbuf" comment="the data." fulltype="char[]" type="char" />
					<param name="off" comment="the start offset in the data." fulltype="int" type="int" />
					<param name="len" comment="the number of characters to write." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if the pipe is
          &lt;a href=PipedOutputStream.html#BROKEN&gt; &lt;code&gt;broken&lt;/code&gt;&lt;/a&gt;,
          {@link #connect(java.io.PipedReader) unconnected}, closed
          or an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="public" name="flush" fulltype="void" type="void">
				<comment>
					<description>Flushes this output stream and forces any buffered output characters
 to be written out.
 This will notify any readers that characters are waiting in the pipe.</description>
					<attribute name="@exception">
						<description>IOException  if the pipe is closed, or an I/O error occurs.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if the pipe is closed, or an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="close" fulltype="void" type="void">
				<comment>
					<description>Closes this piped output stream and releases any system resources
 associated with this stream. This stream may no longer be used for
 writing characters.</description>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="InputStream" visibility="public" package="java.io" superclassfulltype="java.io.InputStream" fulltype="java.io.FileInputStream" type="FileInputStream">
		<comment>
			<description>A &lt;code&gt;FileInputStream&lt;/code&gt; obtains input bytes
 from a file in a file system. What files
 are  available depends on the host environment.

 &lt;p&gt;&lt;code&gt;FileInputStream&lt;/code&gt; is meant for reading streams of raw bytes
 such as image data. For reading streams of characters, consider using
 &lt;code&gt;FileReader&lt;/code&gt;.</description>
			<attribute name="@author">
				<description>Arthur van Hoff</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.File</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.FileDescriptor</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.FileOutputStream</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.0</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="private" name="fd" fulltype="java.io.FileDescriptor" type="FileDescriptor" />
			<field visibility="private" name="channel" fulltype="java.nio.channels.FileChannel" type="FileChannel" />
			<field visibility="private" name="closeLock" fulltype="java.lang.Object" type="Object" />
			<field volatile="true" visibility="private" name="closed" fulltype="boolean" type="boolean" />
			<field static="true" visibility="private" name="runningFinalize" fulltype="java.lang.ThreadLocal" type="ThreadLocal" />
		</fields>
		<methods>
			<constructor visibility="public" name="FileInputStream">
				<comment>
					<description>Creates a &lt;code&gt;FileInputStream&lt;/code&gt; by
 opening a connection to an actual file,
 the file named by the path name &lt;code&gt;name&lt;/code&gt;
 in the file system.  A new &lt;code&gt;FileDescriptor&lt;/code&gt;
 object is created to represent this file
 connection.
 &lt;p&gt;
 First, if there is a security
 manager, its &lt;code&gt;checkRead&lt;/code&gt; method
 is called with the &lt;code&gt;name&lt;/code&gt; argument
 as its argument.
 &lt;p&gt;
 If the named file does not exist, is a directory rather than a regular
 file, or for some other reason cannot be opened for reading then a
 &lt;code&gt;FileNotFoundException&lt;/code&gt; is thrown.</description>
					<attribute name="@param">
						<description>name   the system-dependent file name.</description>
					</attribute>
					<attribute name="@exception">
						<description>FileNotFoundException  if the file does not exist,
                   is a directory rather than a regular file,
                   or for some other reason cannot be opened for
                   reading.</description>
					</attribute>
					<attribute name="@exception">
						<description>SecurityException      if a security manager exists and its
               &lt;code&gt;checkRead&lt;/code&gt; method denies read access
               to the file.</description>
					</attribute>
					<attribute name="@see">
						<description>java.lang.SecurityManager#checkRead(java.lang.String)</description>
					</attribute>
				</comment>
				<params>
					<param name="name" comment="the system-dependent file name." fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception comment="if the file does not exist,
                   is a directory rather than a regular file,
                   or for some other reason cannot be opened for
                   reading." fulltype="java.io.FileNotFoundException" type="FileNotFoundException" />
				</exceptions>
			</constructor>
			<constructor visibility="public" name="FileInputStream">
				<comment>
					<description>Creates a &lt;code&gt;FileInputStream&lt;/code&gt; by
 opening a connection to an actual file,
 the file named by the &lt;code&gt;File&lt;/code&gt;
 object &lt;code&gt;file&lt;/code&gt; in the file system.
 A new &lt;code&gt;FileDescriptor&lt;/code&gt; object
 is created to represent this file connection.
 &lt;p&gt;
 First, if there is a security manager,
 its &lt;code&gt;checkRead&lt;/code&gt; method  is called
 with the path represented by the &lt;code&gt;file&lt;/code&gt;
 argument as its argument.
 &lt;p&gt;
 If the named file does not exist, is a directory rather than a regular
 file, or for some other reason cannot be opened for reading then a
 &lt;code&gt;FileNotFoundException&lt;/code&gt; is thrown.</description>
					<attribute name="@param">
						<description>file   the file to be opened for reading.</description>
					</attribute>
					<attribute name="@exception">
						<description>FileNotFoundException  if the file does not exist,
                   is a directory rather than a regular file,
                   or for some other reason cannot be opened for
                   reading.</description>
					</attribute>
					<attribute name="@exception">
						<description>SecurityException      if a security manager exists and its
               &lt;code&gt;checkRead&lt;/code&gt; method denies read access to the file.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.File#getPath()</description>
					</attribute>
					<attribute name="@see">
						<description>java.lang.SecurityManager#checkRead(java.lang.String)</description>
					</attribute>
				</comment>
				<params>
					<param name="file" comment="the file to be opened for reading." fulltype="java.io.File" type="File" />
				</params>
				<exceptions>
					<exception comment="if the file does not exist,
                   is a directory rather than a regular file,
                   or for some other reason cannot be opened for
                   reading." fulltype="java.io.FileNotFoundException" type="FileNotFoundException" />
				</exceptions>
			</constructor>
			<constructor visibility="public" name="FileInputStream">
				<comment>
					<description>Creates a &lt;code&gt;FileInputStream&lt;/code&gt; by using the file descriptor
 &lt;code&gt;fdObj&lt;/code&gt;, which represents an existing connection to an
 actual file in the file system.
 &lt;p&gt;
 If there is a security manager, its &lt;code&gt;checkRead&lt;/code&gt; method is
 called with the file descriptor &lt;code&gt;fdObj&lt;/code&gt; as its argument to
 see if it&apos;s ok to read the file descriptor. If read access is denied
 to the file descriptor a &lt;code&gt;SecurityException&lt;/code&gt; is thrown.
 &lt;p&gt;
 If &lt;code&gt;fdObj&lt;/code&gt; is null then a &lt;code&gt;NullPointerException&lt;/code&gt;
 is thrown.</description>
					<attribute name="@param">
						<description>fdObj   the file descriptor to be opened for reading.</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException      if a security manager exists and its
                 &lt;code&gt;checkRead&lt;/code&gt; method denies read access to the
                 file descriptor.</description>
					</attribute>
					<attribute name="@see">
						<description>SecurityManager#checkRead(java.io.FileDescriptor)</description>
					</attribute>
				</comment>
				<params>
					<param name="fdObj" comment="the file descriptor to be opened for reading." fulltype="java.io.FileDescriptor" type="FileDescriptor" />
				</params>
			</constructor>
			<method static="true" visibility="private" name="isRunningFinalize" fulltype="boolean" type="boolean" />
			<method visibility="private" name="open" fulltype="void" type="void">
				<comment>
					<description>Opens the specified file for reading.</description>
					<attribute name="@param">
						<description>name the name of the file</description>
					</attribute>
				</comment>
				<params>
					<param name="name" comment="the name of the file" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception fulltype="java.io.FileNotFoundException" type="FileNotFoundException" />
				</exceptions>
			</method>
			<method visibility="public" name="read" returncomment="the next byte of data, or &lt;code&gt;-1&lt;/code&gt; if the end of the
             file is reached." fulltype="int" type="int">
				<comment>
					<description>Reads a byte of data from this input stream. This method blocks
 if no input is yet available.</description>
					<attribute name="@return">
						<description>the next byte of data, or &lt;code&gt;-1&lt;/code&gt; if the end of the
             file is reached.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="readBytes" fulltype="int" type="int">
				<comment>
					<description>Reads a subarray as a sequence of bytes.</description>
					<attribute name="@param">
						<description>b the data to be written</description>
					</attribute>
					<attribute name="@param">
						<description>off the start offset in the data</description>
					</attribute>
					<attribute name="@param">
						<description>len the number of bytes that are written</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException If an I/O error has occurred.</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the data to be written" fulltype="byte[]" type="byte" />
					<param name="off" comment="the start offset in the data" fulltype="int" type="int" />
					<param name="len" comment="the number of bytes that are written" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="If an I/O error has occurred." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="read" returncomment="the total number of bytes read into the buffer, or
             &lt;code&gt;-1&lt;/code&gt; if there is no more data because the end of
             the file has been reached." fulltype="int" type="int">
				<comment>
					<description>Reads up to &lt;code&gt;b.length&lt;/code&gt; bytes of data from this input
 stream into an array of bytes. This method blocks until some input
 is available.</description>
					<attribute name="@param">
						<description>b   the buffer into which the data is read.</description>
					</attribute>
					<attribute name="@return">
						<description>the total number of bytes read into the buffer, or
             &lt;code&gt;-1&lt;/code&gt; if there is no more data because the end of
             the file has been reached.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the buffer into which the data is read." fulltype="byte[]" type="byte" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="read" returncomment="the total number of bytes read into the buffer, or
             &lt;code&gt;-1&lt;/code&gt; if there is no more data because the end of
             the file has been reached." fulltype="int" type="int">
				<comment>
					<description>Reads up to &lt;code&gt;len&lt;/code&gt; bytes of data from this input stream
 into an array of bytes. If &lt;code&gt;len&lt;/code&gt; is not zero, the method
 blocks until some input is available; otherwise, no
 bytes are read and &lt;code&gt;0&lt;/code&gt; is returned.</description>
					<attribute name="@param">
						<description>b     the buffer into which the data is read.</description>
					</attribute>
					<attribute name="@param">
						<description>off   the start offset in the destination array &lt;code&gt;b&lt;/code&gt;</description>
					</attribute>
					<attribute name="@param">
						<description>len   the maximum number of bytes read.</description>
					</attribute>
					<attribute name="@return">
						<description>the total number of bytes read into the buffer, or
             &lt;code&gt;-1&lt;/code&gt; if there is no more data because the end of
             the file has been reached.</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException If &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.</description>
					</attribute>
					<attribute name="@exception">
						<description>IndexOutOfBoundsException If &lt;code&gt;off&lt;/code&gt; is negative,
 &lt;code&gt;len&lt;/code&gt; is negative, or &lt;code&gt;len&lt;/code&gt; is greater than
 &lt;code&gt;b.length - off&lt;/code&gt;</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the buffer into which the data is read." fulltype="byte[]" type="byte" />
					<param name="off" comment="the start offset in the destination array &lt;code&gt;b&lt;/code&gt;" fulltype="int" type="int" />
					<param name="len" comment="the maximum number of bytes read." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="skip" returncomment="the actual number of bytes skipped." fulltype="long" type="long">
				<comment>
					<description>Skips over and discards &lt;code&gt;n&lt;/code&gt; bytes of data from the
 input stream.

 &lt;p&gt;The &lt;code&gt;skip&lt;/code&gt; method may, for a variety of
 reasons, end up skipping over some smaller number of bytes,
 possibly &lt;code&gt;0&lt;/code&gt;. If &lt;code&gt;n&lt;/code&gt; is negative, an
 &lt;code&gt;IOException&lt;/code&gt; is thrown, even though the &lt;code&gt;skip&lt;/code&gt;
 method of the {@link InputStream} superclass does nothing in this case.
 The actual number of bytes skipped is returned.

 &lt;p&gt;This method may skip more bytes than are remaining in the backing
 file. This produces no exception and the number of bytes skipped
 may include some number of bytes that were beyond the EOF of the
 backing file. Attempting to read from the stream after skipping past
 the end will result in -1 indicating the end of the file.</description>
					<attribute name="@param">
						<description>n   the number of bytes to be skipped.</description>
					</attribute>
					<attribute name="@return">
						<description>the actual number of bytes skipped.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if n is negative, if the stream does not
             support seek, or if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="n" comment="the number of bytes to be skipped." fulltype="long" type="long" />
				</params>
				<exceptions>
					<exception comment="if n is negative, if the stream does not
             support seek, or if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="available" returncomment="an estimate of the number of remaining bytes that can be read
             (or skipped over) from this input stream without blocking." fulltype="int" type="int">
				<comment>
					<description>Returns an estimate of the number of remaining bytes that can be read (or
 skipped over) from this input stream without blocking by the next
 invocation of a method for this input stream. The next invocation might be
 the same thread or another thread.  A single read or skip of this
 many bytes will not block, but may read or skip fewer bytes.

 &lt;p&gt; In some cases, a non-blocking read (or skip) may appear to be
 blocked when it is merely slow, for example when reading large
 files over slow networks.</description>
					<attribute name="@return">
						<description>an estimate of the number of remaining bytes that can be read
             (or skipped over) from this input stream without blocking.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if this file input stream has been closed by calling
             {@code close} or an I/O error occurs.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if this file input stream has been closed by calling
             {@code close} or an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="close" fulltype="void" type="void">
				<comment>
					<description>Closes this file input stream and releases any system resources
 associated with the stream.

 &lt;p&gt; If this stream has an associated channel then the channel is closed
 as well.</description>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
					<attribute name="@revised">
						<description>1.4</description>
					</attribute>
					<attribute name="@spec">
						<description>JSR-51</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="getFD" returncomment="the file descriptor object associated with this stream." fulltype="java.io.FileDescriptor" type="FileDescriptor">
				<comment>
					<description>Returns the &lt;code&gt;FileDescriptor&lt;/code&gt;
 object  that represents the connection to
 the actual file in the file system being
 used by this &lt;code&gt;FileInputStream&lt;/code&gt;.</description>
					<attribute name="@return">
						<description>the file descriptor object associated with this stream.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.FileDescriptor</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="getChannel" returncomment="the file channel associated with this file input stream" fulltype="java.nio.channels.FileChannel" type="FileChannel">
				<comment>
					<description>Returns the unique {@link java.nio.channels.FileChannel FileChannel}
 object associated with this file input stream.

 &lt;p&gt; The initial {@link java.nio.channels.FileChannel#position()
 &lt;/code&gt;position&lt;code&gt;} of the returned channel will be equal to the
 number of bytes read from the file so far.  Reading bytes from this
 stream will increment the channel&apos;s position.  Changing the channel&apos;s
 position, either explicitly or by reading, will change this stream&apos;s
 file position.</description>
					<attribute name="@return">
						<description>the file channel associated with this file input stream</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
					<attribute name="@spec">
						<description>JSR-51</description>
					</attribute>
				</comment>
			</method>
			<method static="true" visibility="private" name="initIDs" fulltype="void" type="void" />
			<method visibility="private" name="close0" fulltype="void" type="void">
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="protected" name="finalize" fulltype="void" type="void">
				<comment>
					<description>Ensures that the &lt;code&gt;close&lt;/code&gt; method of this file input stream is
 called when there are no more references to it.</description>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.FileInputStream#close()</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="InputStream" visibility="public" package="java.io" superclassfulltype="java.io.InputStream" fulltype="java.io.SequenceInputStream" type="SequenceInputStream">
		<comment>
			<description>A &lt;code&gt;SequenceInputStream&lt;/code&gt; represents
 the logical concatenation of other input
 streams. It starts out with an ordered
 collection of input streams and reads from
 the first one until end of file is reached,
 whereupon it reads from the second one,
 and so on, until end of file is reached
 on the last of the contained input streams.</description>
			<attribute name="@author">
				<description>Author van Hoff</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.0</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="package-private" name="e" fulltype="java.util.Enumeration" type="Enumeration" />
			<field visibility="package-private" name="in" fulltype="java.io.InputStream" type="InputStream" />
		</fields>
		<methods>
			<constructor visibility="public" name="SequenceInputStream">
				<comment>
					<description>Initializes a newly created &lt;code&gt;SequenceInputStream&lt;/code&gt;
 by remembering the argument, which must
 be an &lt;code&gt;Enumeration&lt;/code&gt;  that produces
 objects whose run-time type is &lt;code&gt;InputStream&lt;/code&gt;.
 The input streams that are  produced by
 the enumeration will be read, in order,
 to provide the bytes to be read  from this
 &lt;code&gt;SequenceInputStream&lt;/code&gt;. After
 each input stream from the enumeration
 is exhausted, it is closed by calling its
 &lt;code&gt;close&lt;/code&gt; method.</description>
					<attribute name="@param">
						<description>e   an enumeration of input streams.</description>
					</attribute>
					<attribute name="@see">
						<description>java.util.Enumeration</description>
					</attribute>
				</comment>
				<params>
					<param name="e" comment="an enumeration of input streams." fulltype="java.util.Enumeration" type="Enumeration" />
				</params>
			</constructor>
			<constructor visibility="public" name="SequenceInputStream">
				<comment>
					<description>Initializes a newly
 created &lt;code&gt;SequenceInputStream&lt;/code&gt;
 by remembering the two arguments, which
 will be read in order, first &lt;code&gt;s1&lt;/code&gt;
 and then &lt;code&gt;s2&lt;/code&gt;, to provide the
 bytes to be read from this &lt;code&gt;SequenceInputStream&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>s1   the first input stream to read.</description>
					</attribute>
					<attribute name="@param">
						<description>s2   the second input stream to read.</description>
					</attribute>
				</comment>
				<params>
					<param name="s1" comment="the first input stream to read." fulltype="java.io.InputStream" type="InputStream" />
					<param name="s2" comment="the second input stream to read." fulltype="java.io.InputStream" type="InputStream" />
				</params>
			</constructor>
			<method final="true" visibility="package-private" name="nextStream" fulltype="void" type="void">
				<comment>
					<description>Continues reading in the next stream if an EOF is reached.</description>
				</comment>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="available" returncomment="an estimate of the number of bytes that can be read (or
         skipped over) from the current underlying input stream
         without blocking or {@code 0} if this input stream
         has been closed by invoking its {@link #close()} method" fulltype="int" type="int">
				<comment>
					<description>Returns an estimate of the number of bytes that can be read (or
 skipped over) from the current underlying input stream without
 blocking by the next invocation of a method for the current
 underlying input stream. The next invocation might be
 the same thread or another thread.  A single read or skip of this
 many bytes will not block, but may read or skip fewer bytes.
 &lt;p&gt;
 This method simply calls {@code available} of the current underlying
 input stream and returns the result.</description>
					<attribute name="@return">
						<description>an estimate of the number of bytes that can be read (or
         skipped over) from the current underlying input stream
         without blocking or {@code 0} if this input stream
         has been closed by invoking its {@link #close()} method</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
					<attribute name="@since">
						<description>JDK1.1</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="read" returncomment="the next byte of data, or &lt;code&gt;-1&lt;/code&gt; if the end of the
             stream is reached." fulltype="int" type="int">
				<comment>
					<description>Reads the next byte of data from this input stream. The byte is
 returned as an &lt;code&gt;int&lt;/code&gt; in the range &lt;code&gt;0&lt;/code&gt; to
 &lt;code&gt;255&lt;/code&gt;. If no byte is available because the end of the
 stream has been reached, the value &lt;code&gt;-1&lt;/code&gt; is returned.
 This method blocks until input data is available, the end of the
 stream is detected, or an exception is thrown.
 &lt;p&gt;
 This method
 tries to read one character from the current substream. If it
 reaches the end of the stream, it calls the &lt;code&gt;close&lt;/code&gt;
 method of the current substream and begins reading from the next
 substream.</description>
					<attribute name="@return">
						<description>the next byte of data, or &lt;code&gt;-1&lt;/code&gt; if the end of the
             stream is reached.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="read" returncomment="int   the number of bytes read." fulltype="int" type="int">
				<comment>
					<description>Reads up to &lt;code&gt;len&lt;/code&gt; bytes of data from this input stream
 into an array of bytes.  If &lt;code&gt;len&lt;/code&gt; is not zero, the method
 blocks until at least 1 byte of input is available; otherwise, no
 bytes are read and &lt;code&gt;0&lt;/code&gt; is returned.
 &lt;p&gt;
 The &lt;code&gt;read&lt;/code&gt; method of &lt;code&gt;SequenceInputStream&lt;/code&gt;
 tries to read the data from the current substream. If it fails to
 read any characters because the substream has reached the end of
 the stream, it calls the &lt;code&gt;close&lt;/code&gt; method of the current
 substream and begins reading from the next substream.</description>
					<attribute name="@param">
						<description>b     the buffer into which the data is read.</description>
					</attribute>
					<attribute name="@param">
						<description>off   the start offset in array &lt;code&gt;b&lt;/code&gt;
                   at which the data is written.</description>
					</attribute>
					<attribute name="@param">
						<description>len   the maximum number of bytes read.</description>
					</attribute>
					<attribute name="@return">
						<description>int   the number of bytes read.</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException If &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.</description>
					</attribute>
					<attribute name="@exception">
						<description>IndexOutOfBoundsException If &lt;code&gt;off&lt;/code&gt; is negative,
 &lt;code&gt;len&lt;/code&gt; is negative, or &lt;code&gt;len&lt;/code&gt; is greater than
 &lt;code&gt;b.length - off&lt;/code&gt;</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the buffer into which the data is read." fulltype="byte[]" type="byte" />
					<param name="off" comment="the start offset in array &lt;code&gt;b&lt;/code&gt;
                   at which the data is written." fulltype="int" type="int" />
					<param name="len" comment="the maximum number of bytes read." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="close" fulltype="void" type="void">
				<comment>
					<description>Closes this input stream and releases any system resources
 associated with the stream.
 A closed &lt;code&gt;SequenceInputStream&lt;/code&gt;
 cannot  perform input operations and cannot
 be reopened.
 &lt;p&gt;
 If this stream was created
 from an enumeration, all remaining elements
 are requested from the enumeration and closed
 before the &lt;code&gt;close&lt;/code&gt; method returns.</description>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass final="true" superclass="Object" visibility="public" package="java.io" superclassfulltype="java.lang.Object" fulltype="java.io.Console" type="Console">
		<implements>
			<interface fulltype="java.io.Flushable" type="Flushable" />
		</implements>
		<comment>
			<description>Methods to access the character-based console device, if any, associated
 with the current Java virtual machine.

 &lt;p&gt; Whether a virtual machine has a console is dependent upon the
 underlying platform and also upon the manner in which the virtual
 machine is invoked.  If the virtual machine is started from an
 interactive command line without redirecting the standard input and
 output streams then its console will exist and will typically be
 connected to the keyboard and display from which the virtual machine
 was launched.  If the virtual machine is started automatically, for
 example by a background job scheduler, then it will typically not
 have a console.
 &lt;p&gt;
 If this virtual machine has a console then it is represented by a
 unique instance of this class which can be obtained by invoking the
 {@link java.lang.System#console()} method.  If no console device is
 available then an invocation of that method will return &lt;tt&gt;null&lt;/tt&gt;.
 &lt;p&gt;
 Read and write operations are synchronized to guarantee the atomic
 completion of critical operations; therefore invoking methods
 {@link #readLine()}, {@link #readPassword()}, {@link #format format()},
 {@link #printf printf()} as well as the read, format and write operations
 on the objects returned by {@link #reader()} and {@link #writer()} may
 block in multithreaded scenarios.
 &lt;p&gt;
 Invoking &lt;tt&gt;close()&lt;/tt&gt; on the objects returned by the {@link #reader()}
 and the {@link #writer()} will not close the underlying stream of those
 objects.
 &lt;p&gt;
 The console-read methods return &lt;tt&gt;null&lt;/tt&gt; when the end of the
 console input stream is reached, for example by typing control-D on
 Unix or control-Z on Windows.  Subsequent read operations will succeed
 if additional characters are later entered on the console&apos;s input
 device.
 &lt;p&gt;
 Unless otherwise specified, passing a &lt;tt&gt;null&lt;/tt&gt; argument to any method
 in this class will cause a {@link NullPointerException} to be thrown.
 &lt;p&gt;
 &lt;b&gt;Security note:&lt;/b&gt;
 If an application needs to read a password or other secure data, it should
 use {@link #readPassword()} or {@link #readPassword(String, Object...)} and
 manually zero the returned character array after processing to minimize the
 lifetime of sensitive data in memory.

 &lt;blockquote&gt;&lt;pre&gt;
 Console cons;
 char[] passwd;
 if ((cons = System.console()) != null &amp;&amp;
     (passwd = cons.readPassword(&quot;[%s]&quot;, &quot;Password:&quot;)) != null) {
     ...
     java.util.Arrays.fill(passwd, &apos; &apos;);
 }
 &lt;/pre&gt;&lt;/blockquote&gt;</description>
			<attribute name="@author">
				<description>Xueming Shen</description>
			</attribute>
			<attribute name="@since">
				<description>1.6</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="private" name="readLock" fulltype="java.lang.Object" type="Object" />
			<field visibility="private" name="writeLock" fulltype="java.lang.Object" type="Object" />
			<field visibility="private" name="reader" fulltype="java.io.Reader" type="Reader" />
			<field visibility="private" name="out" fulltype="java.io.Writer" type="Writer" />
			<field visibility="private" name="pw" fulltype="java.io.PrintWriter" type="PrintWriter" />
			<field visibility="private" name="formatter" fulltype="java.util.Formatter" type="Formatter" />
			<field visibility="private" name="cs" fulltype="java.nio.charset.Charset" type="Charset" />
			<field visibility="private" name="rcb" fulltype="char[]" type="char" />
			<field static="true" visibility="private" name="echoOff" fulltype="boolean" type="boolean" />
			<field static="true" visibility="private" name="cons" fulltype="java.io.Console" type="Console" />
		</fields>
		<methods>
			<constructor visibility="private" name="Console" />
			<method visibility="public" name="writer" returncomment="The printwriter associated with this console" fulltype="java.io.PrintWriter" type="PrintWriter">
				<comment>
					<description>Retrieves the unique {@link java.io.PrintWriter PrintWriter} object
 associated with this console.</description>
					<attribute name="@return">
						<description>The printwriter associated with this console</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="reader" returncomment="The reader associated with this console" fulltype="java.io.Reader" type="Reader">
				<comment>
					<description>Retrieves the unique {@link java.io.Reader Reader} object associated
 with this console.
 &lt;p&gt;
 This method is intended to be used by sophisticated applications, for
 example, a {@link java.util.Scanner} object which utilizes the rich
 parsing/scanning functionality provided by the &lt;tt&gt;Scanner&lt;/tt&gt;:
 &lt;blockquote&gt;&lt;pre&gt;
 Console con = System.console();
 if (con != null) {
     Scanner sc = new Scanner(con.reader());
     ...
 }
 &lt;/pre&gt;&lt;/blockquote&gt;
 &lt;p&gt;
 For simple applications requiring only line-oriented reading, use
 &lt;tt&gt;{@link #readLine}&lt;/tt&gt;.
 &lt;p&gt;
 The bulk read operations {@link java.io.Reader#read(char[]) read(char[]) },
 {@link java.io.Reader#read(char[], int, int) read(char[], int, int) } and
 {@link java.io.Reader#read(java.nio.CharBuffer) read(java.nio.CharBuffer)}
 on the returned object will not read in characters beyond the line
 bound for each invocation, even if the destination buffer has space for
 more characters. A line bound is considered to be any one of a line feed
 (&lt;tt&gt;&apos;\n&apos;&lt;/tt&gt;), a carriage return (&lt;tt&gt;&apos;\r&apos;&lt;/tt&gt;), a carriage return
 followed immediately by a linefeed, or an end of stream.</description>
					<attribute name="@return">
						<description>The reader associated with this console</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="format" returncomment="This console" fulltype="java.io.Console" type="Console">
				<comment>
					<description>Writes a formatted string to this console&apos;s output stream using
 the specified format string and arguments.</description>
					<attribute name="@param">
						<description>fmt
         A format string as described in &lt;a
         href=&quot;../util/Formatter.html#syntax&quot;&gt;Format string syntax&lt;/a&gt;</description>
					</attribute>
					<attribute name="@param">
						<description>args
         Arguments referenced by the format specifiers in the format
         string.  If there are more arguments than format specifiers, the
         extra arguments are ignored.  The number of arguments is
         variable and may be zero.  The maximum number of arguments is
         limited by the maximum dimension of a Java array as defined by
         the &lt;a href=&quot;http://java.sun.com/docs/books/vmspec/&quot;&gt;Java
         Virtual Machine Specification&lt;/a&gt;.  The behaviour on a
         &lt;tt&gt;null&lt;/tt&gt; argument depends on the &lt;a
         href=&quot;../util/Formatter.html#syntax&quot;&gt;conversion&lt;/a&gt;.</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalFormatException
          If a format string contains an illegal syntax, a format
          specifier that is incompatible with the given arguments,
          insufficient arguments given the format string, or other
          illegal conditions.  For specification of all possible
          formatting errors, see the &lt;a
          href=&quot;../util/Formatter.html#detail&quot;&gt;Details&lt;/a&gt; section
          of the formatter class specification.</description>
					</attribute>
					<attribute name="@return">
						<description>This console</description>
					</attribute>
				</comment>
				<params>
					<param name="fmt" comment="A format string as described in &lt;a
         href=&quot;../util/Formatter.html#syntax&quot;&gt;Format string syntax&lt;/a&gt;" fulltype="java.lang.String" type="String" />
					<param name="args" comment="Arguments referenced by the format specifiers in the format
         string.  If there are more arguments than format specifiers, the
         extra arguments are ignored.  The number of arguments is
         variable and may be zero.  The maximum number of arguments is
         limited by the maximum dimension of a Java array as defined by
         the &lt;a href=&quot;http://java.sun.com/docs/books/vmspec/&quot;&gt;Java
         Virtual Machine Specification&lt;/a&gt;.  The behaviour on a
         &lt;tt&gt;null&lt;/tt&gt; argument depends on the &lt;a
         href=&quot;../util/Formatter.html#syntax&quot;&gt;conversion&lt;/a&gt;." fulltype="java.lang.Object[]" type="Object" />
				</params>
			</method>
			<method visibility="public" name="printf" returncomment="This console" fulltype="java.io.Console" type="Console">
				<comment>
					<description>A convenience method to write a formatted string to this console&apos;s
 output stream using the specified format string and arguments.

 &lt;p&gt; An invocation of this method of the form &lt;tt&gt;con.printf(format,
 args)&lt;/tt&gt; behaves in exactly the same way as the invocation of
 &lt;pre&gt;con.format(format, args)&lt;/pre&gt;.</description>
					<attribute name="@param">
						<description>format
         A format string as described in &lt;a
         href=&quot;../util/Formatter.html#syntax&quot;&gt;Format string syntax&lt;/a&gt;.</description>
					</attribute>
					<attribute name="@param">
						<description>args
         Arguments referenced by the format specifiers in the format
         string.  If there are more arguments than format specifiers, the
         extra arguments are ignored.  The number of arguments is
         variable and may be zero.  The maximum number of arguments is
         limited by the maximum dimension of a Java array as defined by
         the &lt;a href=&quot;http://java.sun.com/docs/books/vmspec/&quot;&gt;Java
         Virtual Machine Specification&lt;/a&gt;.  The behaviour on a
         &lt;tt&gt;null&lt;/tt&gt; argument depends on the &lt;a
         href=&quot;../util/Formatter.html#syntax&quot;&gt;conversion&lt;/a&gt;.</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalFormatException
          If a format string contains an illegal syntax, a format
          specifier that is incompatible with the given arguments,
          insufficient arguments given the format string, or other
          illegal conditions.  For specification of all possible
          formatting errors, see the &lt;a
          href=&quot;../util/Formatter.html#detail&quot;&gt;Details&lt;/a&gt; section of the
          formatter class specification.</description>
					</attribute>
					<attribute name="@return">
						<description>This console</description>
					</attribute>
				</comment>
				<params>
					<param name="format" comment="A format string as described in &lt;a
         href=&quot;../util/Formatter.html#syntax&quot;&gt;Format string syntax&lt;/a&gt;." fulltype="java.lang.String" type="String" />
					<param name="args" comment="Arguments referenced by the format specifiers in the format
         string.  If there are more arguments than format specifiers, the
         extra arguments are ignored.  The number of arguments is
         variable and may be zero.  The maximum number of arguments is
         limited by the maximum dimension of a Java array as defined by
         the &lt;a href=&quot;http://java.sun.com/docs/books/vmspec/&quot;&gt;Java
         Virtual Machine Specification&lt;/a&gt;.  The behaviour on a
         &lt;tt&gt;null&lt;/tt&gt; argument depends on the &lt;a
         href=&quot;../util/Formatter.html#syntax&quot;&gt;conversion&lt;/a&gt;." fulltype="java.lang.Object[]" type="Object" />
				</params>
			</method>
			<method visibility="public" name="readLine" returncomment="A string containing the line read from the console, not
          including any line-termination characters, or &lt;tt&gt;null&lt;/tt&gt;
          if an end of stream has been reached." fulltype="java.lang.String" type="String">
				<comment>
					<description>Provides a formatted prompt, then reads a single line of text from the
 console.</description>
					<attribute name="@param">
						<description>fmt
         A format string as described in &lt;a
         href=&quot;../util/Formatter.html#syntax&quot;&gt;Format string syntax&lt;/a&gt;.</description>
					</attribute>
					<attribute name="@param">
						<description>args
         Arguments referenced by the format specifiers in the format
         string.  If there are more arguments than format specifiers, the
         extra arguments are ignored.  The maximum number of arguments is
         limited by the maximum dimension of a Java array as defined by
         the &lt;a href=&quot;http://java.sun.com/docs/books/vmspec/&quot;&gt;Java
         Virtual Machine Specification&lt;/a&gt;.</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalFormatException
          If a format string contains an illegal syntax, a format
          specifier that is incompatible with the given arguments,
          insufficient arguments given the format string, or other
          illegal conditions.  For specification of all possible
          formatting errors, see the &lt;a
          href=&quot;../util/Formatter.html#detail&quot;&gt;Details&lt;/a&gt; section
          of the formatter class specification.</description>
					</attribute>
					<attribute name="@throws">
						<description>IOError
         If an I/O error occurs.</description>
					</attribute>
					<attribute name="@return">
						<description>A string containing the line read from the console, not
          including any line-termination characters, or &lt;tt&gt;null&lt;/tt&gt;
          if an end of stream has been reached.</description>
					</attribute>
				</comment>
				<params>
					<param name="fmt" comment="A format string as described in &lt;a
         href=&quot;../util/Formatter.html#syntax&quot;&gt;Format string syntax&lt;/a&gt;." fulltype="java.lang.String" type="String" />
					<param name="args" comment="Arguments referenced by the format specifiers in the format
         string.  If there are more arguments than format specifiers, the
         extra arguments are ignored.  The maximum number of arguments is
         limited by the maximum dimension of a Java array as defined by
         the &lt;a href=&quot;http://java.sun.com/docs/books/vmspec/&quot;&gt;Java
         Virtual Machine Specification&lt;/a&gt;." fulltype="java.lang.Object[]" type="Object" />
				</params>
			</method>
			<method visibility="public" name="readLine" returncomment="A string containing the line read from the console, not
          including any line-termination characters, or &lt;tt&gt;null&lt;/tt&gt;
          if an end of stream has been reached." fulltype="java.lang.String" type="String">
				<comment>
					<description>Reads a single line of text from the console.</description>
					<attribute name="@throws">
						<description>IOError
         If an I/O error occurs.</description>
					</attribute>
					<attribute name="@return">
						<description>A string containing the line read from the console, not
          including any line-termination characters, or &lt;tt&gt;null&lt;/tt&gt;
          if an end of stream has been reached.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="readPassword" returncomment="A character array containing the password or passphrase read
          from the console, not including any line-termination characters,
          or &lt;tt&gt;null&lt;/tt&gt; if an end of stream has been reached." fulltype="char[]" type="char">
				<comment>
					<description>Provides a formatted prompt, then reads a password or passphrase from
 the console with echoing disabled.</description>
					<attribute name="@param">
						<description>fmt
         A format string as described in &lt;a
         href=&quot;../util/Formatter.html#syntax&quot;&gt;Format string syntax&lt;/a&gt;
         for the prompt text.</description>
					</attribute>
					<attribute name="@param">
						<description>args
         Arguments referenced by the format specifiers in the format
         string.  If there are more arguments than format specifiers, the
         extra arguments are ignored.  The maximum number of arguments is
         limited by the maximum dimension of a Java array as defined by
         the &lt;a href=&quot;http://java.sun.com/docs/books/vmspec/&quot;&gt;Java
         Virtual Machine Specification&lt;/a&gt;.</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalFormatException
          If a format string contains an illegal syntax, a format
          specifier that is incompatible with the given arguments,
          insufficient arguments given the format string, or other
          illegal conditions.  For specification of all possible
          formatting errors, see the &lt;a
          href=&quot;../util/Formatter.html#detail&quot;&gt;Details&lt;/a&gt;
          section of the formatter class specification.</description>
					</attribute>
					<attribute name="@throws">
						<description>IOError
         If an I/O error occurs.</description>
					</attribute>
					<attribute name="@return">
						<description>A character array containing the password or passphrase read
          from the console, not including any line-termination characters,
          or &lt;tt&gt;null&lt;/tt&gt; if an end of stream has been reached.</description>
					</attribute>
				</comment>
				<params>
					<param name="fmt" comment="A format string as described in &lt;a
         href=&quot;../util/Formatter.html#syntax&quot;&gt;Format string syntax&lt;/a&gt;
         for the prompt text." fulltype="java.lang.String" type="String" />
					<param name="args" comment="Arguments referenced by the format specifiers in the format
         string.  If there are more arguments than format specifiers, the
         extra arguments are ignored.  The maximum number of arguments is
         limited by the maximum dimension of a Java array as defined by
         the &lt;a href=&quot;http://java.sun.com/docs/books/vmspec/&quot;&gt;Java
         Virtual Machine Specification&lt;/a&gt;." fulltype="java.lang.Object[]" type="Object" />
				</params>
			</method>
			<method visibility="public" name="readPassword" returncomment="A character array containing the password or passphrase read
          from the console, not including any line-termination characters,
          or &lt;tt&gt;null&lt;/tt&gt; if an end of stream has been reached." fulltype="char[]" type="char">
				<comment>
					<description>Reads a password or passphrase from the console with echoing disabled</description>
					<attribute name="@throws">
						<description>IOError
         If an I/O error occurs.</description>
					</attribute>
					<attribute name="@return">
						<description>A character array containing the password or passphrase read
          from the console, not including any line-termination characters,
          or &lt;tt&gt;null&lt;/tt&gt; if an end of stream has been reached.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="flush" fulltype="void" type="void">
				<comment>
					<description>Flushes the console and forces any buffered output to be written
 immediately .</description>
				</comment>
			</method>
			<method static="true" visibility="private" name="encoding" fulltype="java.lang.String" type="String" />
			<method static="true" visibility="private" name="echo" fulltype="boolean" type="boolean">
				<params>
					<param name="on" fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="readline" fulltype="char[]" type="char">
				<params>
					<param name="zeroOut" fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="grow" fulltype="char[]" type="char" />
			<method static="true" visibility="private" name="istty" fulltype="boolean" type="boolean" />
		</methods>
		<jelclass superclass="Reader" visibility="package-private" package="java.io" superclassfulltype="java.io.Reader" fulltype="java.io.Console.LineReader" type="Console.LineReader">
			<fields>
				<field visibility="private" name="in" fulltype="java.io.Reader" type="Reader" />
				<field visibility="private" name="cb" fulltype="char[]" type="char" />
				<field visibility="private" name="nChars" fulltype="int" type="int" />
				<field visibility="private" name="nextChar" fulltype="int" type="int" />
				<field visibility="package-private" name="leftoverLF" fulltype="boolean" type="boolean" />
			</fields>
			<methods>
				<constructor visibility="package-private" name="Console.LineReader">
					<params>
						<param name="in" fulltype="java.io.Reader" type="Reader" />
					</params>
				</constructor>
				<method visibility="public" name="close" fulltype="void" type="void" />
				<method visibility="public" name="ready" fulltype="boolean" type="boolean">
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="public" name="read" fulltype="int" type="int">
					<params>
						<param name="cbuf" fulltype="char[]" type="char" />
						<param name="offset" fulltype="int" type="int" />
						<param name="length" fulltype="int" type="int" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
			</methods>
		</jelclass>
	</jelclass>
	<jelclass superclass="Reader" visibility="package-private" package="java.io" superclassfulltype="java.io.Reader" fulltype="java.io.Console.LineReader" type="Console.LineReader">
		<fields>
			<field visibility="private" name="in" fulltype="java.io.Reader" type="Reader" />
			<field visibility="private" name="cb" fulltype="char[]" type="char" />
			<field visibility="private" name="nChars" fulltype="int" type="int" />
			<field visibility="private" name="nextChar" fulltype="int" type="int" />
			<field visibility="package-private" name="leftoverLF" fulltype="boolean" type="boolean" />
		</fields>
		<methods>
			<constructor visibility="package-private" name="Console.LineReader">
				<params>
					<param name="in" fulltype="java.io.Reader" type="Reader" />
				</params>
			</constructor>
			<method visibility="public" name="close" fulltype="void" type="void" />
			<method visibility="public" name="ready" fulltype="boolean" type="boolean">
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="read" fulltype="int" type="int">
				<params>
					<param name="cbuf" fulltype="char[]" type="char" />
					<param name="offset" fulltype="int" type="int" />
					<param name="length" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="ObjectStreamException" visibility="public" package="java.io" serializable="true" superclassfulltype="java.io.ObjectStreamException" fulltype="java.io.NotSerializableException" type="NotSerializableException">
		<comment>
			<description>Thrown when an instance is required to have a Serializable interface.
 The serialization runtime or the class of the instance can throw
 this exception. The argument should be the name of the class.</description>
			<attribute name="@author">
				<description>unascribed</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.1</description>
			</attribute>
		</comment>
		<fields>
			<field final="true" static="true" const="2906642554793891381" visibility="private" name="serialVersionUID" constexpr="2906642554793891381L" fulltype="long" type="long" />
		</fields>
		<methods>
			<constructor visibility="public" name="NotSerializableException">
				<comment>
					<description>Constructs a NotSerializableException object with message string.</description>
					<attribute name="@param">
						<description>classname Class of the instance being serialized/deserialized.</description>
					</attribute>
				</comment>
				<params>
					<param name="classname" comment="Class of the instance being serialized/deserialized." fulltype="java.lang.String" type="String" />
				</params>
			</constructor>
			<constructor visibility="public" name="NotSerializableException">
				<comment>
					<description>Constructs a NotSerializableException object.</description>
				</comment>
			</constructor>
		</methods>
	</jelclass>
	<jelclass superclass="Object" visibility="public" package="java.io" superclassfulltype="java.lang.Object" fulltype="java.io.StreamTokenizer" type="StreamTokenizer">
		<comment>
			<description>The &lt;code&gt;StreamTokenizer&lt;/code&gt; class takes an input stream and
 parses it into &quot;tokens&quot;, allowing the tokens to be
 read one at a time. The parsing process is controlled by a table
 and a number of flags that can be set to various states. The
 stream tokenizer can recognize identifiers, numbers, quoted
 strings, and various comment styles.
 &lt;p&gt;
 Each byte read from the input stream is regarded as a character
 in the range &lt;code&gt;&apos;&amp;#92;u0000&apos;&lt;/code&gt; through &lt;code&gt;&apos;&amp;#92;u00FF&apos;&lt;/code&gt;.
 The character value is used to look up five possible attributes of
 the character: &lt;i&gt;white space&lt;/i&gt;, &lt;i&gt;alphabetic&lt;/i&gt;,
 &lt;i&gt;numeric&lt;/i&gt;, &lt;i&gt;string quote&lt;/i&gt;, and &lt;i&gt;comment character&lt;/i&gt;.
 Each character can have zero or more of these attributes.
 &lt;p&gt;
 In addition, an instance has four flags. These flags indicate:
 &lt;ul&gt;
 &lt;li&gt;Whether line terminators are to be returned as tokens or treated
     as white space that merely separates tokens.
 &lt;li&gt;Whether C-style comments are to be recognized and skipped.
 &lt;li&gt;Whether C++-style comments are to be recognized and skipped.
 &lt;li&gt;Whether the characters of identifiers are converted to lowercase.
 &lt;/ul&gt;
 &lt;p&gt;
 A typical application first constructs an instance of this class,
 sets up the syntax tables, and then repeatedly loops calling the
 &lt;code&gt;nextToken&lt;/code&gt; method in each iteration of the loop until
 it returns the value &lt;code&gt;TT_EOF&lt;/code&gt;.</description>
			<attribute name="@author">
				<description>James Gosling</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.StreamTokenizer#nextToken()</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.StreamTokenizer#TT_EOF</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.0</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="private" name="reader" fulltype="java.io.Reader" type="Reader" />
			<field visibility="private" name="input" fulltype="java.io.InputStream" type="InputStream" />
			<field visibility="private" name="buf" fulltype="char[]" type="char" />
			<field visibility="private" name="peekc" fulltype="int" type="int">
				<comment>
					<description>The next character to be considered by the nextToken method.  May also
 be NEED_CHAR to indicate that a new character should be read, or SKIP_LF
 to indicate that a new character should be read and, if it is a &apos;\n&apos;
 character, it should be discarded and a second new character should be
 read.</description>
				</comment>
			</field>
			<field final="true" static="true" const="2147483647" visibility="private" name="NEED_CHAR" constexpr="2147483647" fulltype="int" type="int" />
			<field final="true" static="true" const="2147483646" visibility="private" name="SKIP_LF" constexpr="2147483646" fulltype="int" type="int" />
			<field visibility="private" name="pushedBack" fulltype="boolean" type="boolean" />
			<field visibility="private" name="forceLower" fulltype="boolean" type="boolean" />
			<field visibility="private" name="LINENO" fulltype="int" type="int">
				<comment>
					<description>The line number of the last token read</description>
				</comment>
			</field>
			<field visibility="private" name="eolIsSignificantP" fulltype="boolean" type="boolean" />
			<field visibility="private" name="slashSlashCommentsP" fulltype="boolean" type="boolean" />
			<field visibility="private" name="slashStarCommentsP" fulltype="boolean" type="boolean" />
			<field visibility="private" name="ctype" fulltype="byte[]" type="byte" />
			<field final="true" static="true" const="1" visibility="private" name="CT_WHITESPACE" constexpr="1" fulltype="byte" type="byte" />
			<field final="true" static="true" const="2" visibility="private" name="CT_DIGIT" constexpr="2" fulltype="byte" type="byte" />
			<field final="true" static="true" const="4" visibility="private" name="CT_ALPHA" constexpr="4" fulltype="byte" type="byte" />
			<field final="true" static="true" const="8" visibility="private" name="CT_QUOTE" constexpr="8" fulltype="byte" type="byte" />
			<field final="true" static="true" const="16" visibility="private" name="CT_COMMENT" constexpr="16" fulltype="byte" type="byte" />
			<field visibility="public" name="ttype" fulltype="int" type="int">
				<comment>
					<description>After a call to the &lt;code&gt;nextToken&lt;/code&gt; method, this field
 contains the type of the token just read. For a single character
 token, its value is the single character, converted to an integer.
 For a quoted string token, its value is the quote character.
 Otherwise, its value is one of the following:
 &lt;ul&gt;
 &lt;li&gt;&lt;code&gt;TT_WORD&lt;/code&gt; indicates that the token is a word.
 &lt;li&gt;&lt;code&gt;TT_NUMBER&lt;/code&gt; indicates that the token is a number.
 &lt;li&gt;&lt;code&gt;TT_EOL&lt;/code&gt; indicates that the end of line has been read.
     The field can only have this value if the
     &lt;code&gt;eolIsSignificant&lt;/code&gt; method has been called with the
     argument &lt;code&gt;true&lt;/code&gt;.
 &lt;li&gt;&lt;code&gt;TT_EOF&lt;/code&gt; indicates that the end of the input stream
     has been reached.
 &lt;/ul&gt;
 &lt;p&gt;
 The initial value of this field is -4.</description>
					<attribute name="@see">
						<description>java.io.StreamTokenizer#eolIsSignificant(boolean)</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.StreamTokenizer#nextToken()</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.StreamTokenizer#quoteChar(int)</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.StreamTokenizer#TT_EOF</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.StreamTokenizer#TT_EOL</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.StreamTokenizer#TT_NUMBER</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.StreamTokenizer#TT_WORD</description>
					</attribute>
				</comment>
			</field>
			<field final="true" static="true" const="-1" visibility="public" name="TT_EOF" constexpr="-1" fulltype="int" type="int">
				<comment>
					<description>A constant indicating that the end of the stream has been read.</description>
				</comment>
			</field>
			<field final="true" static="true" const="10" visibility="public" name="TT_EOL" constexpr="10" fulltype="int" type="int">
				<comment>
					<description>A constant indicating that the end of the line has been read.</description>
				</comment>
			</field>
			<field final="true" static="true" const="-2" visibility="public" name="TT_NUMBER" constexpr="-2" fulltype="int" type="int">
				<comment>
					<description>A constant indicating that a number token has been read.</description>
				</comment>
			</field>
			<field final="true" static="true" const="-3" visibility="public" name="TT_WORD" constexpr="-3" fulltype="int" type="int">
				<comment>
					<description>A constant indicating that a word token has been read.</description>
				</comment>
			</field>
			<field final="true" static="true" const="-4" visibility="private" name="TT_NOTHING" constexpr="-4" fulltype="int" type="int" />
			<field visibility="public" name="sval" fulltype="java.lang.String" type="String">
				<comment>
					<description>If the current token is a word token, this field contains a
 string giving the characters of the word token. When the current
 token is a quoted string token, this field contains the body of
 the string.
 &lt;p&gt;
 The current token is a word when the value of the
 &lt;code&gt;ttype&lt;/code&gt; field is &lt;code&gt;TT_WORD&lt;/code&gt;. The current token is
 a quoted string token when the value of the &lt;code&gt;ttype&lt;/code&gt; field is
 a quote character.
 &lt;p&gt;
 The initial value of this field is null.</description>
					<attribute name="@see">
						<description>java.io.StreamTokenizer#quoteChar(int)</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.StreamTokenizer#TT_WORD</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.StreamTokenizer#ttype</description>
					</attribute>
				</comment>
			</field>
			<field visibility="public" name="nval" fulltype="double" type="double">
				<comment>
					<description>If the current token is a number, this field contains the value
 of that number. The current token is a number when the value of
 the &lt;code&gt;ttype&lt;/code&gt; field is &lt;code&gt;TT_NUMBER&lt;/code&gt;.
 &lt;p&gt;
 The initial value of this field is 0.0.</description>
					<attribute name="@see">
						<description>java.io.StreamTokenizer#TT_NUMBER</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.StreamTokenizer#ttype</description>
					</attribute>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="private" name="StreamTokenizer">
				<comment>
					<description>Private constructor that initializes everything except the streams.</description>
				</comment>
			</constructor>
			<constructor visibility="public" name="StreamTokenizer">
				<comment>
					<description>Creates a stream tokenizer that parses the specified input
 stream. The stream tokenizer is initialized to the following
 default state:
 &lt;ul&gt;
 &lt;li&gt;All byte values &lt;code&gt;&apos;A&apos;&lt;/code&gt; through &lt;code&gt;&apos;Z&apos;&lt;/code&gt;,
     &lt;code&gt;&apos;a&apos;&lt;/code&gt; through &lt;code&gt;&apos;z&apos;&lt;/code&gt;, and
     &lt;code&gt;&apos;&amp;#92;u00A0&apos;&lt;/code&gt; through &lt;code&gt;&apos;&amp;#92;u00FF&apos;&lt;/code&gt; are
     considered to be alphabetic.
 &lt;li&gt;All byte values &lt;code&gt;&apos;&amp;#92;u0000&apos;&lt;/code&gt; through
     &lt;code&gt;&apos;&amp;#92;u0020&apos;&lt;/code&gt; are considered to be white space.
 &lt;li&gt;&lt;code&gt;&apos;/&apos;&lt;/code&gt; is a comment character.
 &lt;li&gt;Single quote &lt;code&gt;&apos;&amp;#92;&apos;&apos;&lt;/code&gt; and double quote &lt;code&gt;&apos;&quot;&apos;&lt;/code&gt;
     are string quote characters.
 &lt;li&gt;Numbers are parsed.
 &lt;li&gt;Ends of lines are treated as white space, not as separate tokens.
 &lt;li&gt;C-style and C++-style comments are not recognized.
 &lt;/ul&gt;</description>
					<attribute name="@deprecated">
						<description>As of JDK version 1.1, the preferred way to tokenize an
 input stream is to convert it into a character stream, for example:
 &lt;blockquote&gt;&lt;pre&gt;
   Reader r = new BufferedReader(new InputStreamReader(is));
   StreamTokenizer st = new StreamTokenizer(r);
 &lt;/pre&gt;&lt;/blockquote&gt;</description>
					</attribute>
					<attribute name="@param">
						<description>is        an input stream.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.BufferedReader</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.InputStreamReader</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.StreamTokenizer#StreamTokenizer(java.io.Reader)</description>
					</attribute>
				</comment>
				<params>
					<param name="is" comment="an input stream." fulltype="java.io.InputStream" type="InputStream" />
				</params>
			</constructor>
			<constructor visibility="public" name="StreamTokenizer">
				<comment>
					<description>Create a tokenizer that parses the given character stream.</description>
					<attribute name="@param">
						<description>r  a Reader object providing the input stream.</description>
					</attribute>
					<attribute name="@since">
						<description>JDK1.1</description>
					</attribute>
				</comment>
				<params>
					<param name="r" comment="a Reader object providing the input stream." fulltype="java.io.Reader" type="Reader" />
				</params>
			</constructor>
			<method visibility="public" name="resetSyntax" fulltype="void" type="void">
				<comment>
					<description>Resets this tokenizer&apos;s syntax table so that all characters are
 &quot;ordinary.&quot; See the &lt;code&gt;ordinaryChar&lt;/code&gt; method
 for more information on a character being ordinary.</description>
					<attribute name="@see">
						<description>java.io.StreamTokenizer#ordinaryChar(int)</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="wordChars" fulltype="void" type="void">
				<comment>
					<description>Specifies that all characters &lt;i&gt;c&lt;/i&gt; in the range
 &lt;code&gt;low&amp;nbsp;&amp;lt;=&amp;nbsp;&lt;i&gt;c&lt;/i&gt;&amp;nbsp;&amp;lt;=&amp;nbsp;high&lt;/code&gt;
 are word constituents. A word token consists of a word constituent
 followed by zero or more word constituents or number constituents.</description>
					<attribute name="@param">
						<description>low   the low end of the range.</description>
					</attribute>
					<attribute name="@param">
						<description>hi    the high end of the range.</description>
					</attribute>
				</comment>
				<params>
					<param name="low" comment="the low end of the range." fulltype="int" type="int" />
					<param name="hi" comment="the high end of the range." fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="whitespaceChars" fulltype="void" type="void">
				<comment>
					<description>Specifies that all characters &lt;i&gt;c&lt;/i&gt; in the range
 &lt;code&gt;low&amp;nbsp;&amp;lt;=&amp;nbsp;&lt;i&gt;c&lt;/i&gt;&amp;nbsp;&amp;lt;=&amp;nbsp;high&lt;/code&gt;
 are white space characters. White space characters serve only to
 separate tokens in the input stream.

 &lt;p&gt;Any other attribute settings for the characters in the specified
 range are cleared.</description>
					<attribute name="@param">
						<description>low   the low end of the range.</description>
					</attribute>
					<attribute name="@param">
						<description>hi    the high end of the range.</description>
					</attribute>
				</comment>
				<params>
					<param name="low" comment="the low end of the range." fulltype="int" type="int" />
					<param name="hi" comment="the high end of the range." fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="ordinaryChars" fulltype="void" type="void">
				<comment>
					<description>Specifies that all characters &lt;i&gt;c&lt;/i&gt; in the range
 &lt;code&gt;low&amp;nbsp;&amp;lt;=&amp;nbsp;&lt;i&gt;c&lt;/i&gt;&amp;nbsp;&amp;lt;=&amp;nbsp;high&lt;/code&gt;
 are &quot;ordinary&quot; in this tokenizer. See the
 &lt;code&gt;ordinaryChar&lt;/code&gt; method for more information on a
 character being ordinary.</description>
					<attribute name="@param">
						<description>low   the low end of the range.</description>
					</attribute>
					<attribute name="@param">
						<description>hi    the high end of the range.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.StreamTokenizer#ordinaryChar(int)</description>
					</attribute>
				</comment>
				<params>
					<param name="low" comment="the low end of the range." fulltype="int" type="int" />
					<param name="hi" comment="the high end of the range." fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="ordinaryChar" fulltype="void" type="void">
				<comment>
					<description>Specifies that the character argument is &quot;ordinary&quot;
 in this tokenizer. It removes any special significance the
 character has as a comment character, word component, string
 delimiter, white space, or number character. When such a character
 is encountered by the parser, the parser treats it as a
 single-character token and sets &lt;code&gt;ttype&lt;/code&gt; field to the
 character value.

 &lt;p&gt;Making a line terminator character &quot;ordinary&quot; may interfere
 with the ability of a &lt;code&gt;StreamTokenizer&lt;/code&gt; to count
 lines. The &lt;code&gt;lineno&lt;/code&gt; method may no longer reflect
 the presence of such terminator characters in its line count.</description>
					<attribute name="@param">
						<description>ch   the character.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.StreamTokenizer#ttype</description>
					</attribute>
				</comment>
				<params>
					<param name="ch" comment="the character." fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="commentChar" fulltype="void" type="void">
				<comment>
					<description>Specified that the character argument starts a single-line
 comment. All characters from the comment character to the end of
 the line are ignored by this stream tokenizer.

 &lt;p&gt;Any other attribute settings for the specified character are cleared.</description>
					<attribute name="@param">
						<description>ch   the character.</description>
					</attribute>
				</comment>
				<params>
					<param name="ch" comment="the character." fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="quoteChar" fulltype="void" type="void">
				<comment>
					<description>Specifies that matching pairs of this character delimit string
 constants in this tokenizer.
 &lt;p&gt;
 When the &lt;code&gt;nextToken&lt;/code&gt; method encounters a string
 constant, the &lt;code&gt;ttype&lt;/code&gt; field is set to the string
 delimiter and the &lt;code&gt;sval&lt;/code&gt; field is set to the body of
 the string.
 &lt;p&gt;
 If a string quote character is encountered, then a string is
 recognized, consisting of all characters after (but not including)
 the string quote character, up to (but not including) the next
 occurrence of that same string quote character, or a line
 terminator, or end of file. The usual escape sequences such as
 &lt;code&gt;&quot;&amp;#92;n&quot;&lt;/code&gt; and &lt;code&gt;&quot;&amp;#92;t&quot;&lt;/code&gt; are recognized and
 converted to single characters as the string is parsed.

 &lt;p&gt;Any other attribute settings for the specified character are cleared.</description>
					<attribute name="@param">
						<description>ch   the character.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.StreamTokenizer#nextToken()</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.StreamTokenizer#sval</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.StreamTokenizer#ttype</description>
					</attribute>
				</comment>
				<params>
					<param name="ch" comment="the character." fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="parseNumbers" fulltype="void" type="void">
				<comment>
					<description>Specifies that numbers should be parsed by this tokenizer. The
 syntax table of this tokenizer is modified so that each of the twelve
 characters:
 &lt;blockquote&gt;&lt;pre&gt;
      0 1 2 3 4 5 6 7 8 9 . -
 &lt;/pre&gt;&lt;/blockquote&gt;
 &lt;p&gt;
 has the &quot;numeric&quot; attribute.
 &lt;p&gt;
 When the parser encounters a word token that has the format of a
 double precision floating-point number, it treats the token as a
 number rather than a word, by setting the &lt;code&gt;ttype&lt;/code&gt;
 field to the value &lt;code&gt;TT_NUMBER&lt;/code&gt; and putting the numeric
 value of the token into the &lt;code&gt;nval&lt;/code&gt; field.</description>
					<attribute name="@see">
						<description>java.io.StreamTokenizer#nval</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.StreamTokenizer#TT_NUMBER</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.StreamTokenizer#ttype</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="eolIsSignificant" fulltype="void" type="void">
				<comment>
					<description>Determines whether or not ends of line are treated as tokens.
 If the flag argument is true, this tokenizer treats end of lines
 as tokens; the &lt;code&gt;nextToken&lt;/code&gt; method returns
 &lt;code&gt;TT_EOL&lt;/code&gt; and also sets the &lt;code&gt;ttype&lt;/code&gt; field to
 this value when an end of line is read.
 &lt;p&gt;
 A line is a sequence of characters ending with either a
 carriage-return character (&lt;code&gt;&apos;&amp;#92;r&apos;&lt;/code&gt;) or a newline
 character (&lt;code&gt;&apos;&amp;#92;n&apos;&lt;/code&gt;). In addition, a carriage-return
 character followed immediately by a newline character is treated
 as a single end-of-line token.
 &lt;p&gt;
 If the &lt;code&gt;flag&lt;/code&gt; is false, end-of-line characters are
 treated as white space and serve only to separate tokens.</description>
					<attribute name="@param">
						<description>flag   &lt;code&gt;true&lt;/code&gt; indicates that end-of-line characters
                 are separate tokens; &lt;code&gt;false&lt;/code&gt; indicates that
                 end-of-line characters are white space.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.StreamTokenizer#nextToken()</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.StreamTokenizer#ttype</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.StreamTokenizer#TT_EOL</description>
					</attribute>
				</comment>
				<params>
					<param name="flag" comment="&lt;code&gt;true&lt;/code&gt; indicates that end-of-line characters
                 are separate tokens; &lt;code&gt;false&lt;/code&gt; indicates that
                 end-of-line characters are white space." fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method visibility="public" name="slashStarComments" fulltype="void" type="void">
				<comment>
					<description>Determines whether or not the tokenizer recognizes C-style comments.
 If the flag argument is &lt;code&gt;true&lt;/code&gt;, this stream tokenizer
 recognizes C-style comments. All text between successive
 occurrences of &lt;code&gt;/*&lt;/code&gt; and &lt;code&gt;*&amp;#47;&lt;/code&gt; are discarded.
 &lt;p&gt;
 If the flag argument is &lt;code&gt;false&lt;/code&gt;, then C-style comments
 are not treated specially.</description>
					<attribute name="@param">
						<description>flag   &lt;code&gt;true&lt;/code&gt; indicates to recognize and ignore
                 C-style comments.</description>
					</attribute>
				</comment>
				<params>
					<param name="flag" comment="&lt;code&gt;true&lt;/code&gt; indicates to recognize and ignore
                 C-style comments." fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method visibility="public" name="slashSlashComments" fulltype="void" type="void">
				<comment>
					<description>Determines whether or not the tokenizer recognizes C++-style comments.
 If the flag argument is &lt;code&gt;true&lt;/code&gt;, this stream tokenizer
 recognizes C++-style comments. Any occurrence of two consecutive
 slash characters (&lt;code&gt;&apos;/&apos;&lt;/code&gt;) is treated as the beginning of
 a comment that extends to the end of the line.
 &lt;p&gt;
 If the flag argument is &lt;code&gt;false&lt;/code&gt;, then C++-style
 comments are not treated specially.</description>
					<attribute name="@param">
						<description>flag   &lt;code&gt;true&lt;/code&gt; indicates to recognize and ignore
                 C++-style comments.</description>
					</attribute>
				</comment>
				<params>
					<param name="flag" comment="&lt;code&gt;true&lt;/code&gt; indicates to recognize and ignore
                 C++-style comments." fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method visibility="public" name="lowerCaseMode" fulltype="void" type="void">
				<comment>
					<description>Determines whether or not word token are automatically lowercased.
 If the flag argument is &lt;code&gt;true&lt;/code&gt;, then the value in the
 &lt;code&gt;sval&lt;/code&gt; field is lowercased whenever a word token is
 returned (the &lt;code&gt;ttype&lt;/code&gt; field has the
 value &lt;code&gt;TT_WORD&lt;/code&gt; by the &lt;code&gt;nextToken&lt;/code&gt; method
 of this tokenizer.
 &lt;p&gt;
 If the flag argument is &lt;code&gt;false&lt;/code&gt;, then the
 &lt;code&gt;sval&lt;/code&gt; field is not modified.</description>
					<attribute name="@param">
						<description>fl   &lt;code&gt;true&lt;/code&gt; indicates that all word tokens should
               be lowercased.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.StreamTokenizer#nextToken()</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.StreamTokenizer#ttype</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.StreamTokenizer#TT_WORD</description>
					</attribute>
				</comment>
				<params>
					<param name="fl" comment="&lt;code&gt;true&lt;/code&gt; indicates that all word tokens should
               be lowercased." fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method visibility="private" name="read" fulltype="int" type="int">
				<comment>
					<description>Read the next character</description>
				</comment>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="nextToken" returncomment="the value of the &lt;code&gt;ttype&lt;/code&gt; field." fulltype="int" type="int">
				<comment>
					<description>Parses the next token from the input stream of this tokenizer.
 The type of the next token is returned in the &lt;code&gt;ttype&lt;/code&gt;
 field. Additional information about the token may be in the
 &lt;code&gt;nval&lt;/code&gt; field or the &lt;code&gt;sval&lt;/code&gt; field of this
 tokenizer.
 &lt;p&gt;
 Typical clients of this
 class first set up the syntax tables and then sit in a loop
 calling nextToken to parse successive tokens until TT_EOF
 is returned.</description>
					<attribute name="@return">
						<description>the value of the &lt;code&gt;ttype&lt;/code&gt; field.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.StreamTokenizer#nval</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.StreamTokenizer#sval</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.StreamTokenizer#ttype</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="pushBack" fulltype="void" type="void">
				<comment>
					<description>Causes the next call to the &lt;code&gt;nextToken&lt;/code&gt; method of this
 tokenizer to return the current value in the &lt;code&gt;ttype&lt;/code&gt;
 field, and not to modify the value in the &lt;code&gt;nval&lt;/code&gt; or
 &lt;code&gt;sval&lt;/code&gt; field.</description>
					<attribute name="@see">
						<description>java.io.StreamTokenizer#nextToken()</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.StreamTokenizer#nval</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.StreamTokenizer#sval</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.StreamTokenizer#ttype</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="lineno" returncomment="the current line number of this stream tokenizer." fulltype="int" type="int">
				<comment>
					<description>Return the current line number.</description>
					<attribute name="@return">
						<description>the current line number of this stream tokenizer.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="toString" returncomment="a string representation of the token" fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the string representation of the current stream token and
 the line number it occurs on.

 &lt;p&gt;The precise string returned is unspecified, although the following
 example can be considered typical:

 &lt;blockquote&gt;&lt;pre&gt;Token[&apos;a&apos;], line 10&lt;/pre&gt;&lt;/blockquote&gt;</description>
					<attribute name="@return">
						<description>a string representation of the token</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.StreamTokenizer#nval</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.StreamTokenizer#sval</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.StreamTokenizer#ttype</description>
					</attribute>
				</comment>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="Reader" visibility="public" package="java.io" superclassfulltype="java.io.Reader" fulltype="java.io.CharArrayReader" type="CharArrayReader">
		<comment>
			<description>This class implements a character buffer that can be used as a
 character-input stream.</description>
			<attribute name="@author">
				<description>Herb Jellinek</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.1</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="protected" name="buf" fulltype="char[]" type="char">
				<comment>
					<description>The character buffer.</description>
				</comment>
			</field>
			<field visibility="protected" name="pos" fulltype="int" type="int">
				<comment>
					<description>The current buffer position.</description>
				</comment>
			</field>
			<field visibility="protected" name="markedPos" fulltype="int" type="int">
				<comment>
					<description>The position of mark in buffer.</description>
				</comment>
			</field>
			<field visibility="protected" name="count" fulltype="int" type="int">
				<comment>
					<description>The index of the end of this buffer.  There is not valid
  data at or beyond this index.</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="public" name="CharArrayReader">
				<comment>
					<description>Creates a CharArrayReader from the specified array of chars.</description>
					<attribute name="@param">
						<description>buf       Input buffer (not copied)</description>
					</attribute>
				</comment>
				<params>
					<param name="buf" comment="Input buffer (not copied)" fulltype="char[]" type="char" />
				</params>
			</constructor>
			<constructor visibility="public" name="CharArrayReader">
				<comment>
					<description>Creates a CharArrayReader from the specified array of chars.

 &lt;p&gt; The resulting reader will start reading at the given
 &lt;tt&gt;offset&lt;/tt&gt;.  The total number of &lt;tt&gt;char&lt;/tt&gt; values that can be
 read from this reader will be either &lt;tt&gt;length&lt;/tt&gt; or
 &lt;tt&gt;buf.length-offset&lt;/tt&gt;, whichever is smaller.</description>
					<attribute name="@throws">
						<description>IllegalArgumentException
         If &lt;tt&gt;offset&lt;/tt&gt; is negative or greater than
         &lt;tt&gt;buf.length&lt;/tt&gt;, or if &lt;tt&gt;length&lt;/tt&gt; is negative, or if
         the sum of these two values is negative.</description>
					</attribute>
					<attribute name="@param">
						<description>buf       Input buffer (not copied)</description>
					</attribute>
					<attribute name="@param">
						<description>offset    Offset of the first char to read</description>
					</attribute>
					<attribute name="@param">
						<description>length    Number of chars to read</description>
					</attribute>
				</comment>
				<params>
					<param name="buf" comment="Input buffer (not copied)" fulltype="char[]" type="char" />
					<param name="offset" comment="Offset of the first char to read" fulltype="int" type="int" />
					<param name="length" comment="Number of chars to read" fulltype="int" type="int" />
				</params>
			</constructor>
			<method visibility="private" name="ensureOpen" fulltype="void" type="void">
				<comment>
					<description>Checks to make sure that the stream has not been closed</description>
				</comment>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="read" fulltype="int" type="int">
				<comment>
					<description>Reads a single character.</description>
					<attribute name="@exception">
						<description>IOException  If an I/O error occurs</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="read" returncomment="The actual number of characters read, or -1 if
          the end of the stream has been reached" fulltype="int" type="int">
				<comment>
					<description>Reads characters into a portion of an array.</description>
					<attribute name="@param">
						<description>b  Destination buffer</description>
					</attribute>
					<attribute name="@param">
						<description>off  Offset at which to start storing characters</description>
					</attribute>
					<attribute name="@param">
						<description>len   Maximum number of characters to read</description>
					</attribute>
					<attribute name="@return">
						<description>The actual number of characters read, or -1 if
          the end of the stream has been reached</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  If an I/O error occurs</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="Destination buffer" fulltype="char[]" type="char" />
					<param name="off" comment="Offset at which to start storing characters" fulltype="int" type="int" />
					<param name="len" comment="Maximum number of characters to read" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="skip" returncomment="The number of characters actually skipped" fulltype="long" type="long">
				<comment>
					<description>Skips characters.  Returns the number of characters that were skipped.

 &lt;p&gt;The &lt;code&gt;n&lt;/code&gt; parameter may be negative, even though the
 &lt;code&gt;skip&lt;/code&gt; method of the {@link Reader} superclass throws
 an exception in this case. If &lt;code&gt;n&lt;/code&gt; is negative, then
 this method does nothing and returns &lt;code&gt;0&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>n The number of characters to skip</description>
					</attribute>
					<attribute name="@return">
						<description>The number of characters actually skipped</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException If the stream is closed, or an I/O error occurs</description>
					</attribute>
				</comment>
				<params>
					<param name="n" comment="The number of characters to skip" fulltype="long" type="long" />
				</params>
				<exceptions>
					<exception comment="If the stream is closed, or an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="ready" fulltype="boolean" type="boolean">
				<comment>
					<description>Tells whether this stream is ready to be read.  Character-array readers
 are always ready to be read.</description>
					<attribute name="@exception">
						<description>IOException  If an I/O error occurs</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="markSupported" fulltype="boolean" type="boolean">
				<comment>
					<description>Tells whether this stream supports the mark() operation, which it does.</description>
				</comment>
			</method>
			<method visibility="public" name="mark" fulltype="void" type="void">
				<comment>
					<description>Marks the present position in the stream.  Subsequent calls to reset()
 will reposition the stream to this point.</description>
					<attribute name="@param">
						<description>readAheadLimit  Limit on the number of characters that may be
                         read while still preserving the mark.  Because
                         the stream&apos;s input comes from a character array,
                         there is no actual limit; hence this argument is
                         ignored.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  If an I/O error occurs</description>
					</attribute>
				</comment>
				<params>
					<param name="readAheadLimit" comment="Limit on the number of characters that may be
                         read while still preserving the mark.  Because
                         the stream&apos;s input comes from a character array,
                         there is no actual limit; hence this argument is
                         ignored." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="reset" fulltype="void" type="void">
				<comment>
					<description>Resets the stream to the most recent mark, or to the beginning if it has
 never been marked.</description>
					<attribute name="@exception">
						<description>IOException  If an I/O error occurs</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="close" fulltype="void" type="void">
				<comment>
					<description>Closes the stream and releases any system resources associated with
 it.  Once the stream has been closed, further read(), ready(),
 mark(), reset(), or skip() invocations will throw an IOException.
 Closing a previously closed stream has no effect.</description>
				</comment>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="Object" visibility="public" package="java.io" superclassfulltype="java.lang.Object" fulltype="java.io.RandomAccessFile" type="RandomAccessFile">
		<implements>
			<interface fulltype="java.io.DataOutput" type="DataOutput" />
			<interface fulltype="java.io.DataInput" type="DataInput" />
			<interface fulltype="java.io.Closeable" type="Closeable" />
		</implements>
		<comment>
			<description>Instances of this class support both reading and writing to a
 random access file. A random access file behaves like a large
 array of bytes stored in the file system. There is a kind of cursor,
 or index into the implied array, called the &lt;em&gt;file pointer&lt;/em&gt;;
 input operations read bytes starting at the file pointer and advance
 the file pointer past the bytes read. If the random access file is
 created in read/write mode, then output operations are also available;
 output operations write bytes starting at the file pointer and advance
 the file pointer past the bytes written. Output operations that write
 past the current end of the implied array cause the array to be
 extended. The file pointer can be read by the
 &lt;code&gt;getFilePointer&lt;/code&gt; method and set by the &lt;code&gt;seek&lt;/code&gt;
 method.
 &lt;p&gt;
 It is generally true of all the reading routines in this class that
 if end-of-file is reached before the desired number of bytes has been
 read, an &lt;code&gt;EOFException&lt;/code&gt; (which is a kind of
 &lt;code&gt;IOException&lt;/code&gt;) is thrown. If any byte cannot be read for
 any reason other than end-of-file, an &lt;code&gt;IOException&lt;/code&gt; other
 than &lt;code&gt;EOFException&lt;/code&gt; is thrown. In particular, an
 &lt;code&gt;IOException&lt;/code&gt; may be thrown if the stream has been closed.</description>
			<attribute name="@author">
				<description>unascribed</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.0</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="private" name="fd" fulltype="java.io.FileDescriptor" type="FileDescriptor" />
			<field visibility="private" name="channel" fulltype="java.nio.channels.FileChannel" type="FileChannel" />
			<field visibility="private" name="rw" fulltype="boolean" type="boolean" />
			<field visibility="private" name="closeLock" fulltype="java.lang.Object" type="Object" />
			<field volatile="true" visibility="private" name="closed" fulltype="boolean" type="boolean" />
			<field final="true" static="true" const="1" visibility="private" name="O_RDONLY" constexpr="1" fulltype="int" type="int" />
			<field final="true" static="true" const="2" visibility="private" name="O_RDWR" constexpr="2" fulltype="int" type="int" />
			<field final="true" static="true" const="4" visibility="private" name="O_SYNC" constexpr="4" fulltype="int" type="int" />
			<field final="true" static="true" const="8" visibility="private" name="O_DSYNC" constexpr="8" fulltype="int" type="int" />
		</fields>
		<methods>
			<constructor visibility="public" name="RandomAccessFile">
				<comment>
					<description>Creates a random access file stream to read from, and optionally
 to write to, a file with the specified name. A new
 {@link FileDescriptor} object is created to represent the
 connection to the file.

 &lt;p&gt; The &lt;tt&gt;mode&lt;/tt&gt; argument specifies the access mode with which the
 file is to be opened.  The permitted values and their meanings are as
 specified for the &lt;a
 href=&quot;#mode&quot;&gt;&lt;tt&gt;RandomAccessFile(File,String)&lt;/tt&gt;&lt;/a&gt; constructor.

 &lt;p&gt;
 If there is a security manager, its &lt;code&gt;checkRead&lt;/code&gt; method
 is called with the &lt;code&gt;name&lt;/code&gt; argument
 as its argument to see if read access to the file is allowed.
 If the mode allows writing, the security manager&apos;s
 &lt;code&gt;checkWrite&lt;/code&gt; method
 is also called with the &lt;code&gt;name&lt;/code&gt; argument
 as its argument to see if write access to the file is allowed.</description>
					<attribute name="@param">
						<description>name   the system-dependent filename</description>
					</attribute>
					<attribute name="@param">
						<description>mode   the access &lt;a href=&quot;#mode&quot;&gt;mode&lt;/a&gt;</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException  if the mode argument is not equal
               to one of &lt;tt&gt;&quot;r&quot;&lt;/tt&gt;, &lt;tt&gt;&quot;rw&quot;&lt;/tt&gt;, &lt;tt&gt;&quot;rws&quot;&lt;/tt&gt;, or
               &lt;tt&gt;&quot;rwd&quot;&lt;/tt&gt;</description>
					</attribute>
					<attribute name="@exception">
						<description>FileNotFoundException
            if the mode is &lt;tt&gt;&quot;r&quot;&lt;/tt&gt; but the given string does not
            denote an existing regular file, or if the mode begins with
            &lt;tt&gt;&quot;rw&quot;&lt;/tt&gt; but the given string does not denote an
            existing, writable regular file and a new regular file of
            that name cannot be created, or if some other error occurs
            while opening or creating the file</description>
					</attribute>
					<attribute name="@exception">
						<description>SecurityException         if a security manager exists and its
               &lt;code&gt;checkRead&lt;/code&gt; method denies read access to the file
               or the mode is &quot;rw&quot; and the security manager&apos;s
               &lt;code&gt;checkWrite&lt;/code&gt; method denies write access to the file</description>
					</attribute>
					<attribute name="@see">
						<description>java.lang.SecurityException</description>
					</attribute>
					<attribute name="@see">
						<description>java.lang.SecurityManager#checkRead(java.lang.String)</description>
					</attribute>
					<attribute name="@see">
						<description>java.lang.SecurityManager#checkWrite(java.lang.String)</description>
					</attribute>
					<attribute name="@revised">
						<description>1.4</description>
					</attribute>
					<attribute name="@spec">
						<description>JSR-51</description>
					</attribute>
				</comment>
				<params>
					<param name="name" comment="the system-dependent filename" fulltype="java.lang.String" type="String" />
					<param name="mode" comment="the access &lt;a href=&quot;#mode&quot;&gt;mode&lt;/a&gt;" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception comment="if the mode is &lt;tt&gt;&quot;r&quot;&lt;/tt&gt; but the given string does not
            denote an existing regular file, or if the mode begins with
            &lt;tt&gt;&quot;rw&quot;&lt;/tt&gt; but the given string does not denote an
            existing, writable regular file and a new regular file of
            that name cannot be created, or if some other error occurs
            while opening or creating the file" fulltype="java.io.FileNotFoundException" type="FileNotFoundException" />
				</exceptions>
			</constructor>
			<constructor visibility="public" name="RandomAccessFile">
				<comment>
					<description>Creates a random access file stream to read from, and optionally to
 write to, the file specified by the {@link File} argument.  A new {@link
 FileDescriptor} object is created to represent this file connection.

 &lt;a name=&quot;mode&quot;&gt;&lt;p&gt; The &lt;tt&gt;mode&lt;/tt&gt; argument specifies the access mode
 in which the file is to be opened.  The permitted values and their
 meanings are:

 &lt;blockquote&gt;&lt;table summary=&quot;Access mode permitted values and meanings&quot;&gt;
 &lt;tr&gt;&lt;th&gt;&lt;p align=&quot;left&quot;&gt;Value&lt;/p&gt;&lt;/th&gt;&lt;th&gt;&lt;p align=&quot;left&quot;&gt;Meaning&lt;/p&gt;&lt;/th&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;tt&gt;&quot;r&quot;&lt;/tt&gt;&lt;/td&gt;
     &lt;td&gt; Open for reading only.  Invoking any of the &lt;tt&gt;write&lt;/tt&gt;
     methods of the resulting object will cause an {@link
     java.io.IOException} to be thrown. &lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;tt&gt;&quot;rw&quot;&lt;/tt&gt;&lt;/td&gt;
     &lt;td&gt; Open for reading and writing.  If the file does not already
     exist then an attempt will be made to create it. &lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;tt&gt;&quot;rws&quot;&lt;/tt&gt;&lt;/td&gt;
     &lt;td&gt; Open for reading and writing, as with &lt;tt&gt;&quot;rw&quot;&lt;/tt&gt;, and also
     require that every update to the file&apos;s content or metadata be
     written synchronously to the underlying storage device.  &lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;tt&gt;&quot;rwd&quot;&amp;nbsp;&amp;nbsp;&lt;/tt&gt;&lt;/td&gt;
     &lt;td&gt; Open for reading and writing, as with &lt;tt&gt;&quot;rw&quot;&lt;/tt&gt;, and also
     require that every update to the file&apos;s content be written
     synchronously to the underlying storage device. &lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;&lt;/blockquote&gt;

 The &lt;tt&gt;&quot;rws&quot;&lt;/tt&gt; and &lt;tt&gt;&quot;rwd&quot;&lt;/tt&gt; modes work much like the {@link
 java.nio.channels.FileChannel#force(boolean) force(boolean)} method of
 the {@link java.nio.channels.FileChannel} class, passing arguments of
 &lt;tt&gt;true&lt;/tt&gt; and &lt;tt&gt;false&lt;/tt&gt;, respectively, except that they always
 apply to every I/O operation and are therefore often more efficient.  If
 the file resides on a local storage device then when an invocation of a
 method of this class returns it is guaranteed that all changes made to
 the file by that invocation will have been written to that device.  This
 is useful for ensuring that critical information is not lost in the
 event of a system crash.  If the file does not reside on a local device
 then no such guarantee is made.

 &lt;p&gt; The &lt;tt&gt;&quot;rwd&quot;&lt;/tt&gt; mode can be used to reduce the number of I/O
 operations performed.  Using &lt;tt&gt;&quot;rwd&quot;&lt;/tt&gt; only requires updates to the
 file&apos;s content to be written to storage; using &lt;tt&gt;&quot;rws&quot;&lt;/tt&gt; requires
 updates to both the file&apos;s content and its metadata to be written, which
 generally requires at least one more low-level I/O operation.

 &lt;p&gt; If there is a security manager, its &lt;code&gt;checkRead&lt;/code&gt; method is
 called with the pathname of the &lt;code&gt;file&lt;/code&gt; argument as its
 argument to see if read access to the file is allowed.  If the mode
 allows writing, the security manager&apos;s &lt;code&gt;checkWrite&lt;/code&gt; method is
 also called with the path argument to see if write access to the file is
 allowed.</description>
					<attribute name="@param">
						<description>file   the file object</description>
					</attribute>
					<attribute name="@param">
						<description>mode   the access mode, as described
                    &lt;a href=&quot;#mode&quot;&gt;above&lt;/a&gt;</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException  if the mode argument is not equal
               to one of &lt;tt&gt;&quot;r&quot;&lt;/tt&gt;, &lt;tt&gt;&quot;rw&quot;&lt;/tt&gt;, &lt;tt&gt;&quot;rws&quot;&lt;/tt&gt;, or
               &lt;tt&gt;&quot;rwd&quot;&lt;/tt&gt;</description>
					</attribute>
					<attribute name="@exception">
						<description>FileNotFoundException
            if the mode is &lt;tt&gt;&quot;r&quot;&lt;/tt&gt; but the given file object does
            not denote an existing regular file, or if the mode begins
            with &lt;tt&gt;&quot;rw&quot;&lt;/tt&gt; but the given file object does not denote
            an existing, writable regular file and a new regular file of
            that name cannot be created, or if some other error occurs
            while opening or creating the file</description>
					</attribute>
					<attribute name="@exception">
						<description>SecurityException         if a security manager exists and its
               &lt;code&gt;checkRead&lt;/code&gt; method denies read access to the file
               or the mode is &quot;rw&quot; and the security manager&apos;s
               &lt;code&gt;checkWrite&lt;/code&gt; method denies write access to the file</description>
					</attribute>
					<attribute name="@see">
						<description>java.lang.SecurityManager#checkRead(java.lang.String)</description>
					</attribute>
					<attribute name="@see">
						<description>java.lang.SecurityManager#checkWrite(java.lang.String)</description>
					</attribute>
					<attribute name="@see">
						<description>java.nio.channels.FileChannel#force(boolean)</description>
					</attribute>
					<attribute name="@revised">
						<description>1.4</description>
					</attribute>
					<attribute name="@spec">
						<description>JSR-51</description>
					</attribute>
				</comment>
				<params>
					<param name="file" comment="the file object" fulltype="java.io.File" type="File" />
					<param name="mode" comment="the access mode, as described
                    &lt;a href=&quot;#mode&quot;&gt;above&lt;/a&gt;" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception comment="if the mode is &lt;tt&gt;&quot;r&quot;&lt;/tt&gt; but the given file object does
            not denote an existing regular file, or if the mode begins
            with &lt;tt&gt;&quot;rw&quot;&lt;/tt&gt; but the given file object does not denote
            an existing, writable regular file and a new regular file of
            that name cannot be created, or if some other error occurs
            while opening or creating the file" fulltype="java.io.FileNotFoundException" type="FileNotFoundException" />
				</exceptions>
			</constructor>
			<method final="true" visibility="public" name="getFD" returncomment="the file descriptor object associated with this stream." fulltype="java.io.FileDescriptor" type="FileDescriptor">
				<comment>
					<description>Returns the opaque file descriptor object associated with this
 stream. &lt;/p&gt;</description>
					<attribute name="@return">
						<description>the file descriptor object associated with this stream.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.FileDescriptor</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="getChannel" returncomment="the file channel associated with this file" fulltype="java.nio.channels.FileChannel" type="FileChannel">
				<comment>
					<description>Returns the unique {@link java.nio.channels.FileChannel FileChannel}
 object associated with this file.

 &lt;p&gt; The {@link java.nio.channels.FileChannel#position()
 &lt;/code&gt;position&lt;code&gt;} of the returned channel will always be equal to
 this object&apos;s file-pointer offset as returned by the {@link
 #getFilePointer getFilePointer} method.  Changing this object&apos;s
 file-pointer offset, whether explicitly or by reading or writing bytes,
 will change the position of the channel, and vice versa.  Changing the
 file&apos;s length via this object will change the length seen via the file
 channel, and vice versa.</description>
					<attribute name="@return">
						<description>the file channel associated with this file</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
					<attribute name="@spec">
						<description>JSR-51</description>
					</attribute>
				</comment>
			</method>
			<method visibility="private" name="open" fulltype="void" type="void">
				<comment>
					<description>Opens a file and returns the file descriptor.  The file is
 opened in read-write mode if the O_RDWR bit in &lt;code&gt;mode&lt;/code&gt;
 is true, else the file is opened as read-only.
 If the &lt;code&gt;name&lt;/code&gt; refers to a directory, an IOException
 is thrown.</description>
					<attribute name="@param">
						<description>name the name of the file</description>
					</attribute>
					<attribute name="@param">
						<description>mode the mode flags, a combination of the O_ constants
             defined above</description>
					</attribute>
				</comment>
				<params>
					<param name="name" comment="the name of the file" fulltype="java.lang.String" type="String" />
					<param name="mode" comment="the mode flags, a combination of the O_ constants
             defined above" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.io.FileNotFoundException" type="FileNotFoundException" />
				</exceptions>
			</method>
			<method visibility="public" name="read" returncomment="the next byte of data, or &lt;code&gt;-1&lt;/code&gt; if the end of the
             file has been reached." fulltype="int" type="int">
				<comment>
					<description>Reads a byte of data from this file. The byte is returned as an
 integer in the range 0 to 255 (&lt;code&gt;0x00-0x0ff&lt;/code&gt;). This
 method blocks if no input is yet available.
 &lt;p&gt;
 Although &lt;code&gt;RandomAccessFile&lt;/code&gt; is not a subclass of
 &lt;code&gt;InputStream&lt;/code&gt;, this method behaves in exactly the same
 way as the {@link InputStream#read()} method of
 &lt;code&gt;InputStream&lt;/code&gt;.</description>
					<attribute name="@return">
						<description>the next byte of data, or &lt;code&gt;-1&lt;/code&gt; if the end of the
             file has been reached.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs. Not thrown if
                          end-of-file has been reached.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs. Not thrown if
                          end-of-file has been reached." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="readBytes" fulltype="int" type="int">
				<comment>
					<description>Reads a sub array as a sequence of bytes.</description>
					<attribute name="@param">
						<description>b the buffer into which the data is read.</description>
					</attribute>
					<attribute name="@param">
						<description>off the start offset of the data.</description>
					</attribute>
					<attribute name="@param">
						<description>len the number of bytes to read.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException If an I/O error has occurred.</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the buffer into which the data is read." fulltype="byte[]" type="byte" />
					<param name="off" comment="the start offset of the data." fulltype="int" type="int" />
					<param name="len" comment="the number of bytes to read." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="If an I/O error has occurred." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="read" returncomment="the total number of bytes read into the buffer, or
             &lt;code&gt;-1&lt;/code&gt; if there is no more data because the end of
             the file has been reached." fulltype="int" type="int">
				<comment>
					<description>Reads up to &lt;code&gt;len&lt;/code&gt; bytes of data from this file into an
 array of bytes. This method blocks until at least one byte of input
 is available.
 &lt;p&gt;
 Although &lt;code&gt;RandomAccessFile&lt;/code&gt; is not a subclass of
 &lt;code&gt;InputStream&lt;/code&gt;, this method behaves in exactly the
 same way as the {@link InputStream#read(byte[], int, int)} method of
 &lt;code&gt;InputStream&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>b     the buffer into which the data is read.</description>
					</attribute>
					<attribute name="@param">
						<description>off   the start offset in array &lt;code&gt;b&lt;/code&gt;
                   at which the data is written.</description>
					</attribute>
					<attribute name="@param">
						<description>len   the maximum number of bytes read.</description>
					</attribute>
					<attribute name="@return">
						<description>the total number of bytes read into the buffer, or
             &lt;code&gt;-1&lt;/code&gt; if there is no more data because the end of
             the file has been reached.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException If the first byte cannot be read for any reason
 other than end of file, or if the random access file has been closed, or if
 some other I/O error occurs.</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException If &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.</description>
					</attribute>
					<attribute name="@exception">
						<description>IndexOutOfBoundsException If &lt;code&gt;off&lt;/code&gt; is negative,
 &lt;code&gt;len&lt;/code&gt; is negative, or &lt;code&gt;len&lt;/code&gt; is greater than
 &lt;code&gt;b.length - off&lt;/code&gt;</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the buffer into which the data is read." fulltype="byte[]" type="byte" />
					<param name="off" comment="the start offset in array &lt;code&gt;b&lt;/code&gt;
                   at which the data is written." fulltype="int" type="int" />
					<param name="len" comment="the maximum number of bytes read." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="If the first byte cannot be read for any reason
 other than end of file, or if the random access file has been closed, or if
 some other I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="read" returncomment="the total number of bytes read into the buffer, or
             &lt;code&gt;-1&lt;/code&gt; if there is no more data because the end of
             this file has been reached." fulltype="int" type="int">
				<comment>
					<description>Reads up to &lt;code&gt;b.length&lt;/code&gt; bytes of data from this file
 into an array of bytes. This method blocks until at least one byte
 of input is available.
 &lt;p&gt;
 Although &lt;code&gt;RandomAccessFile&lt;/code&gt; is not a subclass of
 &lt;code&gt;InputStream&lt;/code&gt;, this method behaves in exactly the
 same way as the {@link InputStream#read(byte[])} method of
 &lt;code&gt;InputStream&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>b   the buffer into which the data is read.</description>
					</attribute>
					<attribute name="@return">
						<description>the total number of bytes read into the buffer, or
             &lt;code&gt;-1&lt;/code&gt; if there is no more data because the end of
             this file has been reached.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException If the first byte cannot be read for any reason
 other than end of file, or if the random access file has been closed, or if
 some other I/O error occurs.</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException If &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the buffer into which the data is read." fulltype="byte[]" type="byte" />
				</params>
				<exceptions>
					<exception comment="If the first byte cannot be read for any reason
 other than end of file, or if the random access file has been closed, or if
 some other I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="readFully" fulltype="void" type="void">
				<comment>
					<description>Reads &lt;code&gt;b.length&lt;/code&gt; bytes from this file into the byte
 array, starting at the current file pointer. This method reads
 repeatedly from the file until the requested number of bytes are
 read. This method blocks until the requested number of bytes are
 read, the end of the stream is detected, or an exception is thrown.</description>
					<attribute name="@param">
						<description>b   the buffer into which the data is read.</description>
					</attribute>
					<attribute name="@exception">
						<description>EOFException  if this file reaches the end before reading
               all the bytes.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException   if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the buffer into which the data is read." fulltype="byte[]" type="byte" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="readFully" fulltype="void" type="void">
				<comment>
					<description>Reads exactly &lt;code&gt;len&lt;/code&gt; bytes from this file into the byte
 array, starting at the current file pointer. This method reads
 repeatedly from the file until the requested number of bytes are
 read. This method blocks until the requested number of bytes are
 read, the end of the stream is detected, or an exception is thrown.</description>
					<attribute name="@param">
						<description>b     the buffer into which the data is read.</description>
					</attribute>
					<attribute name="@param">
						<description>off   the start offset of the data.</description>
					</attribute>
					<attribute name="@param">
						<description>len   the number of bytes to read.</description>
					</attribute>
					<attribute name="@exception">
						<description>EOFException  if this file reaches the end before reading
               all the bytes.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException   if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the buffer into which the data is read." fulltype="byte[]" type="byte" />
					<param name="off" comment="the start offset of the data." fulltype="int" type="int" />
					<param name="len" comment="the number of bytes to read." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="skipBytes" returncomment="the actual number of bytes skipped." fulltype="int" type="int">
				<comment>
					<description>Attempts to skip over &lt;code&gt;n&lt;/code&gt; bytes of input discarding the
 skipped bytes.
 &lt;p&gt;

 This method may skip over some smaller number of bytes, possibly zero.
 This may result from any of a number of conditions; reaching end of
 file before &lt;code&gt;n&lt;/code&gt; bytes have been skipped is only one
 possibility. This method never throws an &lt;code&gt;EOFException&lt;/code&gt;.
 The actual number of bytes skipped is returned.  If &lt;code&gt;n&lt;/code&gt;
 is negative, no bytes are skipped.</description>
					<attribute name="@param">
						<description>n   the number of bytes to be skipped.</description>
					</attribute>
					<attribute name="@return">
						<description>the actual number of bytes skipped.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="n" comment="the number of bytes to be skipped." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes the specified byte to this file. The write starts at
 the current file pointer.</description>
					<attribute name="@param">
						<description>b   the &lt;code&gt;byte&lt;/code&gt; to be written.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the &lt;code&gt;byte&lt;/code&gt; to be written." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="writeBytes" fulltype="void" type="void">
				<comment>
					<description>Writes a sub array as a sequence of bytes.</description>
					<attribute name="@param">
						<description>b the data to be written</description>
					</attribute>
					<attribute name="@param">
						<description>off the start offset in the data</description>
					</attribute>
					<attribute name="@param">
						<description>len the number of bytes that are written</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException If an I/O error has occurred.</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the data to be written" fulltype="byte[]" type="byte" />
					<param name="off" comment="the start offset in the data" fulltype="int" type="int" />
					<param name="len" comment="the number of bytes that are written" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="If an I/O error has occurred." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes &lt;code&gt;b.length&lt;/code&gt; bytes from the specified byte array
 to this file, starting at the current file pointer.</description>
					<attribute name="@param">
						<description>b   the data.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the data." fulltype="byte[]" type="byte" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes &lt;code&gt;len&lt;/code&gt; bytes from the specified byte array
 starting at offset &lt;code&gt;off&lt;/code&gt; to this file.</description>
					<attribute name="@param">
						<description>b     the data.</description>
					</attribute>
					<attribute name="@param">
						<description>off   the start offset in the data.</description>
					</attribute>
					<attribute name="@param">
						<description>len   the number of bytes to write.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the data." fulltype="byte[]" type="byte" />
					<param name="off" comment="the start offset in the data." fulltype="int" type="int" />
					<param name="len" comment="the number of bytes to write." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="getFilePointer" returncomment="the offset from the beginning of the file, in bytes,
             at which the next read or write occurs." fulltype="long" type="long">
				<comment>
					<description>Returns the current offset in this file.</description>
					<attribute name="@return">
						<description>the offset from the beginning of the file, in bytes,
             at which the next read or write occurs.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="seek" fulltype="void" type="void">
				<comment>
					<description>Sets the file-pointer offset, measured from the beginning of this
 file, at which the next read or write occurs.  The offset may be
 set beyond the end of the file. Setting the offset beyond the end
 of the file does not change the file length.  The file length will
 change only by writing after the offset has been set beyond the end
 of the file.</description>
					<attribute name="@param">
						<description>pos   the offset position, measured in bytes from the
                   beginning of the file, at which to set the file
                   pointer.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if &lt;code&gt;pos&lt;/code&gt; is less than
                          &lt;code&gt;0&lt;/code&gt; or if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="pos" comment="the offset position, measured in bytes from the
                   beginning of the file, at which to set the file
                   pointer." fulltype="long" type="long" />
				</params>
				<exceptions>
					<exception comment="if &lt;code&gt;pos&lt;/code&gt; is less than
                          &lt;code&gt;0&lt;/code&gt; or if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="length" returncomment="the length of this file, measured in bytes." fulltype="long" type="long">
				<comment>
					<description>Returns the length of this file.</description>
					<attribute name="@return">
						<description>the length of this file, measured in bytes.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="setLength" fulltype="void" type="void">
				<comment>
					<description>Sets the length of this file.

 &lt;p&gt; If the present length of the file as returned by the
 &lt;code&gt;length&lt;/code&gt; method is greater than the &lt;code&gt;newLength&lt;/code&gt;
 argument then the file will be truncated.  In this case, if the file
 offset as returned by the &lt;code&gt;getFilePointer&lt;/code&gt; method is greater
 than &lt;code&gt;newLength&lt;/code&gt; then after this method returns the offset
 will be equal to &lt;code&gt;newLength&lt;/code&gt;.

 &lt;p&gt; If the present length of the file as returned by the
 &lt;code&gt;length&lt;/code&gt; method is smaller than the &lt;code&gt;newLength&lt;/code&gt;
 argument then the file will be extended.  In this case, the contents of
 the extended portion of the file are not defined.</description>
					<attribute name="@param">
						<description>newLength    The desired length of the file</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  If an I/O error occurs</description>
					</attribute>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
				<params>
					<param name="newLength" comment="The desired length of the file" fulltype="long" type="long" />
				</params>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="close" fulltype="void" type="void">
				<comment>
					<description>Closes this random access file stream and releases any system
 resources associated with the stream. A closed random access
 file cannot perform input or output operations and cannot be
 reopened.

 &lt;p&gt; If this file has an associated channel then the channel is closed
 as well.</description>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
					<attribute name="@revised">
						<description>1.4</description>
					</attribute>
					<attribute name="@spec">
						<description>JSR-51</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="readBoolean" returncomment="the &lt;code&gt;boolean&lt;/code&gt; value read." fulltype="boolean" type="boolean">
				<comment>
					<description>Reads a &lt;code&gt;boolean&lt;/code&gt; from this file. This method reads a
 single byte from the file, starting at the current file pointer.
 A value of &lt;code&gt;0&lt;/code&gt; represents
 &lt;code&gt;false&lt;/code&gt;. Any other value represents &lt;code&gt;true&lt;/code&gt;.
 This method blocks until the byte is read, the end of the stream
 is detected, or an exception is thrown.</description>
					<attribute name="@return">
						<description>the &lt;code&gt;boolean&lt;/code&gt; value read.</description>
					</attribute>
					<attribute name="@exception">
						<description>EOFException  if this file has reached the end.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException   if an I/O error occurs.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="readByte" returncomment="the next byte of this file as a signed eight-bit
             &lt;code&gt;byte&lt;/code&gt;." fulltype="byte" type="byte">
				<comment>
					<description>Reads a signed eight-bit value from this file. This method reads a
 byte from the file, starting from the current file pointer.
 If the byte read is &lt;code&gt;b&lt;/code&gt;, where
 &lt;code&gt;0&amp;nbsp;&amp;lt;=&amp;nbsp;b&amp;nbsp;&amp;lt;=&amp;nbsp;255&lt;/code&gt;,
 then the result is:
 &lt;blockquote&gt;&lt;pre&gt;
     (byte)(b)
 &lt;/pre&gt;&lt;/blockquote&gt;
 &lt;p&gt;
 This method blocks until the byte is read, the end of the stream
 is detected, or an exception is thrown.</description>
					<attribute name="@return">
						<description>the next byte of this file as a signed eight-bit
             &lt;code&gt;byte&lt;/code&gt;.</description>
					</attribute>
					<attribute name="@exception">
						<description>EOFException  if this file has reached the end.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException   if an I/O error occurs.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="readUnsignedByte" returncomment="the next byte of this file, interpreted as an unsigned
             eight-bit number." fulltype="int" type="int">
				<comment>
					<description>Reads an unsigned eight-bit number from this file. This method reads
 a byte from this file, starting at the current file pointer,
 and returns that byte.
 &lt;p&gt;
 This method blocks until the byte is read, the end of the stream
 is detected, or an exception is thrown.</description>
					<attribute name="@return">
						<description>the next byte of this file, interpreted as an unsigned
             eight-bit number.</description>
					</attribute>
					<attribute name="@exception">
						<description>EOFException  if this file has reached the end.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException   if an I/O error occurs.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="readShort" returncomment="the next two bytes of this file, interpreted as a signed
             16-bit number." fulltype="short" type="short">
				<comment>
					<description>Reads a signed 16-bit number from this file. The method reads two
 bytes from this file, starting at the current file pointer.
 If the two bytes read, in order, are
 &lt;code&gt;b1&lt;/code&gt; and &lt;code&gt;b2&lt;/code&gt;, where each of the two values is
 between &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;255&lt;/code&gt;, inclusive, then the
 result is equal to:
 &lt;blockquote&gt;&lt;pre&gt;
     (short)((b1 &amp;lt;&amp;lt; 8) | b2)
 &lt;/pre&gt;&lt;/blockquote&gt;
 &lt;p&gt;
 This method blocks until the two bytes are read, the end of the
 stream is detected, or an exception is thrown.</description>
					<attribute name="@return">
						<description>the next two bytes of this file, interpreted as a signed
             16-bit number.</description>
					</attribute>
					<attribute name="@exception">
						<description>EOFException  if this file reaches the end before reading
               two bytes.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException   if an I/O error occurs.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="readUnsignedShort" returncomment="the next two bytes of this file, interpreted as an unsigned
             16-bit integer." fulltype="int" type="int">
				<comment>
					<description>Reads an unsigned 16-bit number from this file. This method reads
 two bytes from the file, starting at the current file pointer.
 If the bytes read, in order, are
 &lt;code&gt;b1&lt;/code&gt; and &lt;code&gt;b2&lt;/code&gt;, where
 &lt;code&gt;0&amp;nbsp;&amp;lt;=&amp;nbsp;b1, b2&amp;nbsp;&amp;lt;=&amp;nbsp;255&lt;/code&gt;,
 then the result is equal to:
 &lt;blockquote&gt;&lt;pre&gt;
     (b1 &amp;lt;&amp;lt; 8) | b2
 &lt;/pre&gt;&lt;/blockquote&gt;
 &lt;p&gt;
 This method blocks until the two bytes are read, the end of the
 stream is detected, or an exception is thrown.</description>
					<attribute name="@return">
						<description>the next two bytes of this file, interpreted as an unsigned
             16-bit integer.</description>
					</attribute>
					<attribute name="@exception">
						<description>EOFException  if this file reaches the end before reading
               two bytes.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException   if an I/O error occurs.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="readChar" returncomment="the next two bytes of this file, interpreted as a
                  &lt;code&gt;char&lt;/code&gt;." fulltype="char" type="char">
				<comment>
					<description>Reads a character from this file. This method reads two
 bytes from the file, starting at the current file pointer.
 If the bytes read, in order, are
 &lt;code&gt;b1&lt;/code&gt; and &lt;code&gt;b2&lt;/code&gt;, where
 &lt;code&gt;0&amp;nbsp;&amp;lt;=&amp;nbsp;b1,&amp;nbsp;b2&amp;nbsp;&amp;lt;=&amp;nbsp;255&lt;/code&gt;,
 then the result is equal to:
 &lt;blockquote&gt;&lt;pre&gt;
     (char)((b1 &amp;lt;&amp;lt; 8) | b2)
 &lt;/pre&gt;&lt;/blockquote&gt;
 &lt;p&gt;
 This method blocks until the two bytes are read, the end of the
 stream is detected, or an exception is thrown.</description>
					<attribute name="@return">
						<description>the next two bytes of this file, interpreted as a
                  &lt;code&gt;char&lt;/code&gt;.</description>
					</attribute>
					<attribute name="@exception">
						<description>EOFException  if this file reaches the end before reading
               two bytes.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException   if an I/O error occurs.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="readInt" returncomment="the next four bytes of this file, interpreted as an
             &lt;code&gt;int&lt;/code&gt;." fulltype="int" type="int">
				<comment>
					<description>Reads a signed 32-bit integer from this file. This method reads 4
 bytes from the file, starting at the current file pointer.
 If the bytes read, in order, are &lt;code&gt;b1&lt;/code&gt;,
 &lt;code&gt;b2&lt;/code&gt;, &lt;code&gt;b3&lt;/code&gt;, and &lt;code&gt;b4&lt;/code&gt;, where
 &lt;code&gt;0&amp;nbsp;&amp;lt;=&amp;nbsp;b1, b2, b3, b4&amp;nbsp;&amp;lt;=&amp;nbsp;255&lt;/code&gt;,
 then the result is equal to:
 &lt;blockquote&gt;&lt;pre&gt;
     (b1 &amp;lt;&amp;lt; 24) | (b2 &amp;lt;&amp;lt; 16) + (b3 &amp;lt;&amp;lt; 8) + b4
 &lt;/pre&gt;&lt;/blockquote&gt;
 &lt;p&gt;
 This method blocks until the four bytes are read, the end of the
 stream is detected, or an exception is thrown.</description>
					<attribute name="@return">
						<description>the next four bytes of this file, interpreted as an
             &lt;code&gt;int&lt;/code&gt;.</description>
					</attribute>
					<attribute name="@exception">
						<description>EOFException  if this file reaches the end before reading
               four bytes.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException   if an I/O error occurs.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="readLong" returncomment="the next eight bytes of this file, interpreted as a
             &lt;code&gt;long&lt;/code&gt;." fulltype="long" type="long">
				<comment>
					<description>Reads a signed 64-bit integer from this file. This method reads eight
 bytes from the file, starting at the current file pointer.
 If the bytes read, in order, are
 &lt;code&gt;b1&lt;/code&gt;, &lt;code&gt;b2&lt;/code&gt;, &lt;code&gt;b3&lt;/code&gt;,
 &lt;code&gt;b4&lt;/code&gt;, &lt;code&gt;b5&lt;/code&gt;, &lt;code&gt;b6&lt;/code&gt;,
 &lt;code&gt;b7&lt;/code&gt;, and &lt;code&gt;b8,&lt;/code&gt; where:
 &lt;blockquote&gt;&lt;pre&gt;
     0 &amp;lt;= b1, b2, b3, b4, b5, b6, b7, b8 &amp;lt;=255,
 &lt;/pre&gt;&lt;/blockquote&gt;
 &lt;p&gt;
 then the result is equal to:
 &lt;p&gt;&lt;blockquote&gt;&lt;pre&gt;
     ((long)b1 &amp;lt;&amp;lt; 56) + ((long)b2 &amp;lt;&amp;lt; 48)
     + ((long)b3 &amp;lt;&amp;lt; 40) + ((long)b4 &amp;lt;&amp;lt; 32)
     + ((long)b5 &amp;lt;&amp;lt; 24) + ((long)b6 &amp;lt;&amp;lt; 16)
     + ((long)b7 &amp;lt;&amp;lt; 8) + b8
 &lt;/pre&gt;&lt;/blockquote&gt;
 &lt;p&gt;
 This method blocks until the eight bytes are read, the end of the
 stream is detected, or an exception is thrown.</description>
					<attribute name="@return">
						<description>the next eight bytes of this file, interpreted as a
             &lt;code&gt;long&lt;/code&gt;.</description>
					</attribute>
					<attribute name="@exception">
						<description>EOFException  if this file reaches the end before reading
               eight bytes.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException   if an I/O error occurs.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="readFloat" returncomment="the next four bytes of this file, interpreted as a
             &lt;code&gt;float&lt;/code&gt;." fulltype="float" type="float">
				<comment>
					<description>Reads a &lt;code&gt;float&lt;/code&gt; from this file. This method reads an
 &lt;code&gt;int&lt;/code&gt; value, starting at the current file pointer,
 as if by the &lt;code&gt;readInt&lt;/code&gt; method
 and then converts that &lt;code&gt;int&lt;/code&gt; to a &lt;code&gt;float&lt;/code&gt;
 using the &lt;code&gt;intBitsToFloat&lt;/code&gt; method in class
 &lt;code&gt;Float&lt;/code&gt;.
 &lt;p&gt;
 This method blocks until the four bytes are read, the end of the
 stream is detected, or an exception is thrown.</description>
					<attribute name="@return">
						<description>the next four bytes of this file, interpreted as a
             &lt;code&gt;float&lt;/code&gt;.</description>
					</attribute>
					<attribute name="@exception">
						<description>EOFException  if this file reaches the end before reading
             four bytes.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException   if an I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.RandomAccessFile#readInt()</description>
					</attribute>
					<attribute name="@see">
						<description>java.lang.Float#intBitsToFloat(int)</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="readDouble" returncomment="the next eight bytes of this file, interpreted as a
             &lt;code&gt;double&lt;/code&gt;." fulltype="double" type="double">
				<comment>
					<description>Reads a &lt;code&gt;double&lt;/code&gt; from this file. This method reads a
 &lt;code&gt;long&lt;/code&gt; value, starting at the current file pointer,
 as if by the &lt;code&gt;readLong&lt;/code&gt; method
 and then converts that &lt;code&gt;long&lt;/code&gt; to a &lt;code&gt;double&lt;/code&gt;
 using the &lt;code&gt;longBitsToDouble&lt;/code&gt; method in
 class &lt;code&gt;Double&lt;/code&gt;.
 &lt;p&gt;
 This method blocks until the eight bytes are read, the end of the
 stream is detected, or an exception is thrown.</description>
					<attribute name="@return">
						<description>the next eight bytes of this file, interpreted as a
             &lt;code&gt;double&lt;/code&gt;.</description>
					</attribute>
					<attribute name="@exception">
						<description>EOFException  if this file reaches the end before reading
             eight bytes.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException   if an I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.RandomAccessFile#readLong()</description>
					</attribute>
					<attribute name="@see">
						<description>java.lang.Double#longBitsToDouble(long)</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="readLine" returncomment="the next line of text from this file, or null if end
             of file is encountered before even one byte is read." fulltype="java.lang.String" type="String">
				<comment>
					<description>Reads the next line of text from this file.  This method successively
 reads bytes from the file, starting at the current file pointer,
 until it reaches a line terminator or the end
 of the file.  Each byte is converted into a character by taking the
 byte&apos;s value for the lower eight bits of the character and setting the
 high eight bits of the character to zero.  This method does not,
 therefore, support the full Unicode character set.

 &lt;p&gt; A line of text is terminated by a carriage-return character
 (&lt;code&gt;&apos;&amp;#92;r&apos;&lt;/code&gt;), a newline character (&lt;code&gt;&apos;&amp;#92;n&apos;&lt;/code&gt;), a
 carriage-return character immediately followed by a newline character,
 or the end of the file.  Line-terminating characters are discarded and
 are not included as part of the string returned.

 &lt;p&gt; This method blocks until a newline character is read, a carriage
 return and the byte following it are read (to see if it is a newline),
 the end of the file is reached, or an exception is thrown.</description>
					<attribute name="@return">
						<description>the next line of text from this file, or null if end
             of file is encountered before even one byte is read.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="readUTF" returncomment="a Unicode string." fulltype="java.lang.String" type="String">
				<comment>
					<description>Reads in a string from this file. The string has been encoded
 using a
 &lt;a href=&quot;DataInput.html#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt;
 format.
 &lt;p&gt;
 The first two bytes are read, starting from the current file
 pointer, as if by
 &lt;code&gt;readUnsignedShort&lt;/code&gt;. This value gives the number of
 following bytes that are in the encoded string, not
 the length of the resulting string. The following bytes are then
 interpreted as bytes encoding characters in the modified UTF-8 format
 and are converted into characters.
 &lt;p&gt;
 This method blocks until all the bytes are read, the end of the
 stream is detected, or an exception is thrown.</description>
					<attribute name="@return">
						<description>a Unicode string.</description>
					</attribute>
					<attribute name="@exception">
						<description>EOFException            if this file reaches the end before
               reading all the bytes.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException             if an I/O error occurs.</description>
					</attribute>
					<attribute name="@exception">
						<description>UTFDataFormatException  if the bytes do not represent
               valid modified UTF-8 encoding of a Unicode string.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.RandomAccessFile#readUnsignedShort()</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="writeBoolean" fulltype="void" type="void">
				<comment>
					<description>Writes a &lt;code&gt;boolean&lt;/code&gt; to the file as a one-byte value. The
 value &lt;code&gt;true&lt;/code&gt; is written out as the value
 &lt;code&gt;(byte)1&lt;/code&gt;; the value &lt;code&gt;false&lt;/code&gt; is written out
 as the value &lt;code&gt;(byte)0&lt;/code&gt;. The write starts at
 the current position of the file pointer.</description>
					<attribute name="@param">
						<description>v   a &lt;code&gt;boolean&lt;/code&gt; value to be written.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="v" comment="a &lt;code&gt;boolean&lt;/code&gt; value to be written." fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="writeByte" fulltype="void" type="void">
				<comment>
					<description>Writes a &lt;code&gt;byte&lt;/code&gt; to the file as a one-byte value. The
 write starts at the current position of the file pointer.</description>
					<attribute name="@param">
						<description>v   a &lt;code&gt;byte&lt;/code&gt; value to be written.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="v" comment="a &lt;code&gt;byte&lt;/code&gt; value to be written." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="writeShort" fulltype="void" type="void">
				<comment>
					<description>Writes a &lt;code&gt;short&lt;/code&gt; to the file as two bytes, high byte first.
 The write starts at the current position of the file pointer.</description>
					<attribute name="@param">
						<description>v   a &lt;code&gt;short&lt;/code&gt; to be written.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="v" comment="a &lt;code&gt;short&lt;/code&gt; to be written." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="writeChar" fulltype="void" type="void">
				<comment>
					<description>Writes a &lt;code&gt;char&lt;/code&gt; to the file as a two-byte value, high
 byte first. The write starts at the current position of the
 file pointer.</description>
					<attribute name="@param">
						<description>v   a &lt;code&gt;char&lt;/code&gt; value to be written.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="v" comment="a &lt;code&gt;char&lt;/code&gt; value to be written." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="writeInt" fulltype="void" type="void">
				<comment>
					<description>Writes an &lt;code&gt;int&lt;/code&gt; to the file as four bytes, high byte first.
 The write starts at the current position of the file pointer.</description>
					<attribute name="@param">
						<description>v   an &lt;code&gt;int&lt;/code&gt; to be written.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="v" comment="an &lt;code&gt;int&lt;/code&gt; to be written." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="writeLong" fulltype="void" type="void">
				<comment>
					<description>Writes a &lt;code&gt;long&lt;/code&gt; to the file as eight bytes, high byte first.
 The write starts at the current position of the file pointer.</description>
					<attribute name="@param">
						<description>v   a &lt;code&gt;long&lt;/code&gt; to be written.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="v" comment="a &lt;code&gt;long&lt;/code&gt; to be written." fulltype="long" type="long" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="writeFloat" fulltype="void" type="void">
				<comment>
					<description>Converts the float argument to an &lt;code&gt;int&lt;/code&gt; using the
 &lt;code&gt;floatToIntBits&lt;/code&gt; method in class &lt;code&gt;Float&lt;/code&gt;,
 and then writes that &lt;code&gt;int&lt;/code&gt; value to the file as a
 four-byte quantity, high byte first. The write starts at the
 current position of the file pointer.</description>
					<attribute name="@param">
						<description>v   a &lt;code&gt;float&lt;/code&gt; value to be written.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.lang.Float#floatToIntBits(float)</description>
					</attribute>
				</comment>
				<params>
					<param name="v" comment="a &lt;code&gt;float&lt;/code&gt; value to be written." fulltype="float" type="float" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="writeDouble" fulltype="void" type="void">
				<comment>
					<description>Converts the double argument to a &lt;code&gt;long&lt;/code&gt; using the
 &lt;code&gt;doubleToLongBits&lt;/code&gt; method in class &lt;code&gt;Double&lt;/code&gt;,
 and then writes that &lt;code&gt;long&lt;/code&gt; value to the file as an
 eight-byte quantity, high byte first. The write starts at the current
 position of the file pointer.</description>
					<attribute name="@param">
						<description>v   a &lt;code&gt;double&lt;/code&gt; value to be written.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.lang.Double#doubleToLongBits(double)</description>
					</attribute>
				</comment>
				<params>
					<param name="v" comment="a &lt;code&gt;double&lt;/code&gt; value to be written." fulltype="double" type="double" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="writeBytes" fulltype="void" type="void">
				<comment>
					<description>Writes the string to the file as a sequence of bytes. Each
 character in the string is written out, in sequence, by discarding
 its high eight bits. The write starts at the current position of
 the file pointer.</description>
					<attribute name="@param">
						<description>s   a string of bytes to be written.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="s" comment="a string of bytes to be written." fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="writeChars" fulltype="void" type="void">
				<comment>
					<description>Writes a string to the file as a sequence of characters. Each
 character is written to the data output stream as if by the
 &lt;code&gt;writeChar&lt;/code&gt; method. The write starts at the current
 position of the file pointer.</description>
					<attribute name="@param">
						<description>s   a &lt;code&gt;String&lt;/code&gt; value to be written.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.RandomAccessFile#writeChar(int)</description>
					</attribute>
				</comment>
				<params>
					<param name="s" comment="a &lt;code&gt;String&lt;/code&gt; value to be written." fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="writeUTF" fulltype="void" type="void">
				<comment>
					<description>Writes a string to the file using
 &lt;a href=&quot;DataInput.html#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt;
 encoding in a machine-independent manner.
 &lt;p&gt;
 First, two bytes are written to the file, starting at the
 current file pointer, as if by the
 &lt;code&gt;writeShort&lt;/code&gt; method giving the number of bytes to
 follow. This value is the number of bytes actually written out,
 not the length of the string. Following the length, each character
 of the string is output, in sequence, using the modified UTF-8 encoding
 for each character.</description>
					<attribute name="@param">
						<description>str   a string to be written.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="str" comment="a string to be written." fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method static="true" visibility="private" name="initIDs" fulltype="void" type="void" />
			<method visibility="private" name="close0" fulltype="void" type="void">
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass abstract="true" visibility="public" package="java.io" serializable="true" interface="true" fulltype="java.io.Serializable" type="Serializable">
		<comment>
			<description>Serializability of a class is enabled by the class implementing the
 java.io.Serializable interface. Classes that do not implement this
 interface will not have any of their state serialized or
 deserialized.  All subtypes of a serializable class are themselves
 serializable.  The serialization interface has no methods or fields
 and serves only to identify the semantics of being serializable. &lt;p&gt;

 To allow subtypes of non-serializable classes to be serialized, the
 subtype may assume responsibility for saving and restoring the
 state of the supertype&apos;s public, protected, and (if accessible)
 package fields.  The subtype may assume this responsibility only if
 the class it extends has an accessible no-arg constructor to
 initialize the class&apos;s state.  It is an error to declare a class
 Serializable if this is not the case.  The error will be detected at
 runtime. &lt;p&gt;

 During deserialization, the fields of non-serializable classes will
 be initialized using the public or protected no-arg constructor of
 the class.  A no-arg constructor must be accessible to the subclass
 that is serializable.  The fields of serializable subclasses will
 be restored from the stream. &lt;p&gt;

 When traversing a graph, an object may be encountered that does not
 support the Serializable interface. In this case the
 NotSerializableException will be thrown and will identify the class
 of the non-serializable object. &lt;p&gt;

 Classes that require special handling during the serialization and
 deserialization process must implement special methods with these exact
 signatures: &lt;p&gt;

 &lt;PRE&gt;
 private void writeObject(java.io.ObjectOutputStream out)
     throws IOException
 private void readObject(java.io.ObjectInputStream in)
     throws IOException, ClassNotFoundException;
 private void readObjectNoData()
     throws ObjectStreamException;
 &lt;/PRE&gt;

 &lt;p&gt;The writeObject method is responsible for writing the state of the
 object for its particular class so that the corresponding
 readObject method can restore it.  The default mechanism for saving
 the Object&apos;s fields can be invoked by calling
 out.defaultWriteObject. The method does not need to concern
 itself with the state belonging to its superclasses or subclasses.
 State is saved by writing the individual fields to the
 ObjectOutputStream using the writeObject method or by using the
 methods for primitive data types supported by DataOutput.

 &lt;p&gt;The readObject method is responsible for reading from the stream and
 restoring the classes fields. It may call in.defaultReadObject to invoke
 the default mechanism for restoring the object&apos;s non-static and
 non-transient fields.  The defaultReadObject method uses information in
 the stream to assign the fields of the object saved in the stream with the
 correspondingly named fields in the current object.  This handles the case
 when the class has evolved to add new fields. The method does not need to
 concern itself with the state belonging to its superclasses or subclasses.
 State is saved by writing the individual fields to the
 ObjectOutputStream using the writeObject method or by using the
 methods for primitive data types supported by DataOutput.

 &lt;p&gt;The readObjectNoData method is responsible for initializing the state of
 the object for its particular class in the event that the serialization
 stream does not list the given class as a superclass of the object being
 deserialized.  This may occur in cases where the receiving party uses a
 different version of the deserialized instance&apos;s class than the sending
 party, and the receiver&apos;s version extends classes that are not extended by
 the sender&apos;s version.  This may also occur if the serialization stream has
 been tampered; hence, readObjectNoData is useful for initializing
 deserialized objects properly despite a &quot;hostile&quot; or incomplete source
 stream.

 &lt;p&gt;Serializable classes that need to designate an alternative object to be
 used when writing an object to the stream should implement this
 special method with the exact signature: &lt;p&gt;

 &lt;PRE&gt;
 ANY-ACCESS-MODIFIER Object writeReplace() throws ObjectStreamException;
 &lt;/PRE&gt;&lt;p&gt;

 This writeReplace method is invoked by serialization if the method
 exists and it would be accessible from a method defined within the
 class of the object being serialized. Thus, the method can have private,
 protected and package-private access. Subclass access to this method
 follows java accessibility rules. &lt;p&gt;

 Classes that need to designate a replacement when an instance of it
 is read from the stream should implement this special method with the
 exact signature.&lt;p&gt;

 &lt;PRE&gt;
 ANY-ACCESS-MODIFIER Object readResolve() throws ObjectStreamException;
 &lt;/PRE&gt;&lt;p&gt;

 This readResolve method follows the same invocation rules and
 accessibility rules as writeReplace.&lt;p&gt;

 The serialization runtime associates with each serializable class a version
 number, called a serialVersionUID, which is used during deserialization to
 verify that the sender and receiver of a serialized object have loaded
 classes for that object that are compatible with respect to serialization.
 If the receiver has loaded a class for the object that has a different
 serialVersionUID than that of the corresponding sender&apos;s class, then
 deserialization will result in an {@link InvalidClassException}.  A
 serializable class can declare its own serialVersionUID explicitly by
 declaring a field named &lt;code&gt;&quot;serialVersionUID&quot;&lt;/code&gt; that must be static,
 final, and of type &lt;code&gt;long&lt;/code&gt;:&lt;p&gt;

 &lt;PRE&gt;
 ANY-ACCESS-MODIFIER static final long serialVersionUID = 42L;
 &lt;/PRE&gt;

 If a serializable class does not explicitly declare a serialVersionUID, then
 the serialization runtime will calculate a default serialVersionUID value
 for that class based on various aspects of the class, as described in the
 Java(TM) Object Serialization Specification.  However, it is &lt;em&gt;strongly
 recommended&lt;/em&gt; that all serializable classes explicitly declare
 serialVersionUID values, since the default serialVersionUID computation is
 highly sensitive to class details that may vary depending on compiler
 implementations, and can thus result in unexpected
 &lt;code&gt;InvalidClassException&lt;/code&gt;s during deserialization.  Therefore, to
 guarantee a consistent serialVersionUID value across different java compiler
 implementations, a serializable class must declare an explicit
 serialVersionUID value.  It is also strongly advised that explicit
 serialVersionUID declarations use the &lt;code&gt;private&lt;/code&gt; modifier where
 possible, since such declarations apply only to the immediately declaring
 class--serialVersionUID fields are not useful as inherited members. Array
 classes cannot declare an explicit serialVersionUID, so they always have
 the default computed value, but the requirement for matching
 serialVersionUID values is waived for array classes.</description>
			<attribute name="@author">
				<description>unascribed</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.ObjectOutputStream</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.ObjectInputStream</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.ObjectOutput</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.ObjectInput</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.Externalizable</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.1</description>
			</attribute>
		</comment>
	</jelclass>
	<jelclass superclass="FilterInputStream" visibility="public" package="java.io" superclassfulltype="java.io.FilterInputStream" fulltype="java.io.DataInputStream" type="DataInputStream">
		<implements>
			<interface fulltype="java.io.DataInput" type="DataInput" />
		</implements>
		<comment>
			<description>A data input stream lets an application read primitive Java data
 types from an underlying input stream in a machine-independent
 way. An application uses a data output stream to write data that
 can later be read by a data input stream.
 &lt;p&gt;
 DataInputStream is not necessarily safe for multithreaded access.
 Thread safety is optional and is the responsibility of users of
 methods in this class.</description>
			<attribute name="@author">
				<description>Arthur van Hoff</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.DataOutputStream</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.0</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="private" name="bytearr" fulltype="byte[]" type="byte">
				<comment>
					<description>working arrays initialized on demand by readUTF</description>
				</comment>
			</field>
			<field visibility="private" name="chararr" fulltype="char[]" type="char" />
			<field visibility="private" name="readBuffer" fulltype="byte[]" type="byte" />
			<field visibility="private" name="lineBuffer" fulltype="char[]" type="char" />
		</fields>
		<methods>
			<constructor visibility="public" name="DataInputStream">
				<comment>
					<description>Creates a DataInputStream that uses the specified
 underlying InputStream.</description>
					<attribute name="@param">
						<description>in   the specified input stream</description>
					</attribute>
				</comment>
				<params>
					<param name="in" comment="the specified input stream" fulltype="java.io.InputStream" type="InputStream" />
				</params>
			</constructor>
			<method final="true" visibility="public" name="read" returncomment="the total number of bytes read into the buffer, or
             &lt;code&gt;-1&lt;/code&gt; if there is no more data because the end
             of the stream has been reached." fulltype="int" type="int">
				<comment>
					<description>Reads some number of bytes from the contained input stream and
 stores them into the buffer array &lt;code&gt;b&lt;/code&gt;. The number of
 bytes actually read is returned as an integer. This method blocks
 until input data is available, end of file is detected, or an
 exception is thrown.

 &lt;p&gt;If &lt;code&gt;b&lt;/code&gt; is null, a &lt;code&gt;NullPointerException&lt;/code&gt; is
 thrown. If the length of &lt;code&gt;b&lt;/code&gt; is zero, then no bytes are
 read and &lt;code&gt;0&lt;/code&gt; is returned; otherwise, there is an attempt
 to read at least one byte. If no byte is available because the
 stream is at end of file, the value &lt;code&gt;-1&lt;/code&gt; is returned;
 otherwise, at least one byte is read and stored into &lt;code&gt;b&lt;/code&gt;.

 &lt;p&gt;The first byte read is stored into element &lt;code&gt;b[0]&lt;/code&gt;, the
 next one into &lt;code&gt;b[1]&lt;/code&gt;, and so on. The number of bytes read
 is, at most, equal to the length of &lt;code&gt;b&lt;/code&gt;. Let &lt;code&gt;k&lt;/code&gt;
 be the number of bytes actually read; these bytes will be stored in
 elements &lt;code&gt;b[0]&lt;/code&gt; through &lt;code&gt;b[k-1]&lt;/code&gt;, leaving
 elements &lt;code&gt;b[k]&lt;/code&gt; through &lt;code&gt;b[b.length-1]&lt;/code&gt;
 unaffected.

 &lt;p&gt;The &lt;code&gt;read(b)&lt;/code&gt; method has the same effect as:
 &lt;blockquote&gt;&lt;pre&gt;
 read(b, 0, b.length)
 &lt;/pre&gt;&lt;/blockquote&gt;</description>
					<attribute name="@param">
						<description>b   the buffer into which the data is read.</description>
					</attribute>
					<attribute name="@return">
						<description>the total number of bytes read into the buffer, or
             &lt;code&gt;-1&lt;/code&gt; if there is no more data because the end
             of the stream has been reached.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException if the first byte cannot be read for any reason
 other than end of file, the stream has been closed and the underlying
 input stream does not support reading after close, or another I/O
 error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.FilterInputStream#in</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.InputStream#read(byte[], int, int)</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the buffer into which the data is read." fulltype="byte[]" type="byte" />
				</params>
				<exceptions>
					<exception comment="if the first byte cannot be read for any reason
 other than end of file, the stream has been closed and the underlying
 input stream does not support reading after close, or another I/O
 error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="read" returncomment="the total number of bytes read into the buffer, or
             &lt;code&gt;-1&lt;/code&gt; if there is no more data because the end
             of the stream has been reached." fulltype="int" type="int">
				<comment>
					<description>Reads up to &lt;code&gt;len&lt;/code&gt; bytes of data from the contained
 input stream into an array of bytes.  An attempt is made to read
 as many as &lt;code&gt;len&lt;/code&gt; bytes, but a smaller number may be read,
 possibly zero. The number of bytes actually read is returned as an
 integer.

 &lt;p&gt; This method blocks until input data is available, end of file is
 detected, or an exception is thrown.

 &lt;p&gt; If &lt;code&gt;len&lt;/code&gt; is zero, then no bytes are read and
 &lt;code&gt;0&lt;/code&gt; is returned; otherwise, there is an attempt to read at
 least one byte. If no byte is available because the stream is at end of
 file, the value &lt;code&gt;-1&lt;/code&gt; is returned; otherwise, at least one
 byte is read and stored into &lt;code&gt;b&lt;/code&gt;.

 &lt;p&gt; The first byte read is stored into element &lt;code&gt;b[off]&lt;/code&gt;, the
 next one into &lt;code&gt;b[off+1]&lt;/code&gt;, and so on. The number of bytes read
 is, at most, equal to &lt;code&gt;len&lt;/code&gt;. Let &lt;i&gt;k&lt;/i&gt; be the number of
 bytes actually read; these bytes will be stored in elements
 &lt;code&gt;b[off]&lt;/code&gt; through &lt;code&gt;b[off+&lt;/code&gt;&lt;i&gt;k&lt;/i&gt;&lt;code&gt;-1]&lt;/code&gt;,
 leaving elements &lt;code&gt;b[off+&lt;/code&gt;&lt;i&gt;k&lt;/i&gt;&lt;code&gt;]&lt;/code&gt; through
 &lt;code&gt;b[off+len-1]&lt;/code&gt; unaffected.

 &lt;p&gt; In every case, elements &lt;code&gt;b[0]&lt;/code&gt; through
 &lt;code&gt;b[off]&lt;/code&gt; and elements &lt;code&gt;b[off+len]&lt;/code&gt; through
 &lt;code&gt;b[b.length-1]&lt;/code&gt; are unaffected.</description>
					<attribute name="@param">
						<description>b     the buffer into which the data is read.</description>
					</attribute>
					<attribute name="@param">
						<description>off the start offset in the destination array &lt;code&gt;b&lt;/code&gt;</description>
					</attribute>
					<attribute name="@param">
						<description>len   the maximum number of bytes read.</description>
					</attribute>
					<attribute name="@return">
						<description>the total number of bytes read into the buffer, or
             &lt;code&gt;-1&lt;/code&gt; if there is no more data because the end
             of the stream has been reached.</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException If &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.</description>
					</attribute>
					<attribute name="@exception">
						<description>IndexOutOfBoundsException If &lt;code&gt;off&lt;/code&gt; is negative,
 &lt;code&gt;len&lt;/code&gt; is negative, or &lt;code&gt;len&lt;/code&gt; is greater than
 &lt;code&gt;b.length - off&lt;/code&gt;</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException if the first byte cannot be read for any reason
 other than end of file, the stream has been closed and the underlying
 input stream does not support reading after close, or another I/O
 error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.FilterInputStream#in</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.InputStream#read(byte[], int, int)</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the buffer into which the data is read." fulltype="byte[]" type="byte" />
					<param name="off" comment="the start offset in the destination array &lt;code&gt;b&lt;/code&gt;" fulltype="int" type="int" />
					<param name="len" comment="the maximum number of bytes read." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if the first byte cannot be read for any reason
 other than end of file, the stream has been closed and the underlying
 input stream does not support reading after close, or another I/O
 error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="readFully" fulltype="void" type="void">
				<comment>
					<description>See the general contract of the &lt;code&gt;readFully&lt;/code&gt;
 method of &lt;code&gt;DataInput&lt;/code&gt;.
 &lt;p&gt;
 Bytes
 for this operation are read from the contained
 input stream.</description>
					<attribute name="@param">
						<description>b   the buffer into which the data is read.</description>
					</attribute>
					<attribute name="@exception">
						<description>EOFException  if this input stream reaches the end before
             reading all the bytes.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException   the stream has been closed and the contained
             input stream does not support reading after close, or
             another I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.FilterInputStream#in</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the buffer into which the data is read." fulltype="byte[]" type="byte" />
				</params>
				<exceptions>
					<exception comment="the stream has been closed and the contained
             input stream does not support reading after close, or
             another I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="readFully" fulltype="void" type="void">
				<comment>
					<description>See the general contract of the &lt;code&gt;readFully&lt;/code&gt;
 method of &lt;code&gt;DataInput&lt;/code&gt;.
 &lt;p&gt;
 Bytes
 for this operation are read from the contained
 input stream.</description>
					<attribute name="@param">
						<description>b     the buffer into which the data is read.</description>
					</attribute>
					<attribute name="@param">
						<description>off   the start offset of the data.</description>
					</attribute>
					<attribute name="@param">
						<description>len   the number of bytes to read.</description>
					</attribute>
					<attribute name="@exception">
						<description>EOFException  if this input stream reaches the end before
               reading all the bytes.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException   the stream has been closed and the contained
             input stream does not support reading after close, or
             another I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.FilterInputStream#in</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the buffer into which the data is read." fulltype="byte[]" type="byte" />
					<param name="off" comment="the start offset of the data." fulltype="int" type="int" />
					<param name="len" comment="the number of bytes to read." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="the stream has been closed and the contained
             input stream does not support reading after close, or
             another I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="skipBytes" returncomment="the actual number of bytes skipped." fulltype="int" type="int">
				<comment>
					<description>See the general contract of the &lt;code&gt;skipBytes&lt;/code&gt;
 method of &lt;code&gt;DataInput&lt;/code&gt;.
 &lt;p&gt;
 Bytes for this operation are read from the contained
 input stream.</description>
					<attribute name="@param">
						<description>n   the number of bytes to be skipped.</description>
					</attribute>
					<attribute name="@return">
						<description>the actual number of bytes skipped.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if the contained input stream does not support
             seek, or the stream has been closed and
             the contained input stream does not support
             reading after close, or another I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="n" comment="the number of bytes to be skipped." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if the contained input stream does not support
             seek, or the stream has been closed and
             the contained input stream does not support
             reading after close, or another I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="readBoolean" returncomment="the &lt;code&gt;boolean&lt;/code&gt; value read." fulltype="boolean" type="boolean">
				<comment>
					<description>See the general contract of the &lt;code&gt;readBoolean&lt;/code&gt;
 method of &lt;code&gt;DataInput&lt;/code&gt;.
 &lt;p&gt;
 Bytes for this operation are read from the contained
 input stream.</description>
					<attribute name="@return">
						<description>the &lt;code&gt;boolean&lt;/code&gt; value read.</description>
					</attribute>
					<attribute name="@exception">
						<description>EOFException  if this input stream has reached the end.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException   the stream has been closed and the contained
             input stream does not support reading after close, or
             another I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.FilterInputStream#in</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="the stream has been closed and the contained
             input stream does not support reading after close, or
             another I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="readByte" returncomment="the next byte of this input stream as a signed 8-bit
             &lt;code&gt;byte&lt;/code&gt;." fulltype="byte" type="byte">
				<comment>
					<description>See the general contract of the &lt;code&gt;readByte&lt;/code&gt;
 method of &lt;code&gt;DataInput&lt;/code&gt;.
 &lt;p&gt;
 Bytes
 for this operation are read from the contained
 input stream.</description>
					<attribute name="@return">
						<description>the next byte of this input stream as a signed 8-bit
             &lt;code&gt;byte&lt;/code&gt;.</description>
					</attribute>
					<attribute name="@exception">
						<description>EOFException  if this input stream has reached the end.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException   the stream has been closed and the contained
             input stream does not support reading after close, or
             another I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.FilterInputStream#in</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="the stream has been closed and the contained
             input stream does not support reading after close, or
             another I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="readUnsignedByte" returncomment="the next byte of this input stream, interpreted as an
             unsigned 8-bit number." fulltype="int" type="int">
				<comment>
					<description>See the general contract of the &lt;code&gt;readUnsignedByte&lt;/code&gt;
 method of &lt;code&gt;DataInput&lt;/code&gt;.
 &lt;p&gt;
 Bytes
 for this operation are read from the contained
 input stream.</description>
					<attribute name="@return">
						<description>the next byte of this input stream, interpreted as an
             unsigned 8-bit number.</description>
					</attribute>
					<attribute name="@exception">
						<description>EOFException  if this input stream has reached the end.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException   the stream has been closed and the contained
             input stream does not support reading after close, or
             another I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.FilterInputStream#in</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="the stream has been closed and the contained
             input stream does not support reading after close, or
             another I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="readShort" returncomment="the next two bytes of this input stream, interpreted as a
             signed 16-bit number." fulltype="short" type="short">
				<comment>
					<description>See the general contract of the &lt;code&gt;readShort&lt;/code&gt;
 method of &lt;code&gt;DataInput&lt;/code&gt;.
 &lt;p&gt;
 Bytes
 for this operation are read from the contained
 input stream.</description>
					<attribute name="@return">
						<description>the next two bytes of this input stream, interpreted as a
             signed 16-bit number.</description>
					</attribute>
					<attribute name="@exception">
						<description>EOFException  if this input stream reaches the end before
               reading two bytes.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException   the stream has been closed and the contained
             input stream does not support reading after close, or
             another I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.FilterInputStream#in</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="the stream has been closed and the contained
             input stream does not support reading after close, or
             another I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="readUnsignedShort" returncomment="the next two bytes of this input stream, interpreted as an
             unsigned 16-bit integer." fulltype="int" type="int">
				<comment>
					<description>See the general contract of the &lt;code&gt;readUnsignedShort&lt;/code&gt;
 method of &lt;code&gt;DataInput&lt;/code&gt;.
 &lt;p&gt;
 Bytes
 for this operation are read from the contained
 input stream.</description>
					<attribute name="@return">
						<description>the next two bytes of this input stream, interpreted as an
             unsigned 16-bit integer.</description>
					</attribute>
					<attribute name="@exception">
						<description>EOFException  if this input stream reaches the end before
             reading two bytes.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException   the stream has been closed and the contained
             input stream does not support reading after close, or
             another I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.FilterInputStream#in</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="the stream has been closed and the contained
             input stream does not support reading after close, or
             another I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="readChar" returncomment="the next two bytes of this input stream, interpreted as a
             &lt;code&gt;char&lt;/code&gt;." fulltype="char" type="char">
				<comment>
					<description>See the general contract of the &lt;code&gt;readChar&lt;/code&gt;
 method of &lt;code&gt;DataInput&lt;/code&gt;.
 &lt;p&gt;
 Bytes
 for this operation are read from the contained
 input stream.</description>
					<attribute name="@return">
						<description>the next two bytes of this input stream, interpreted as a
             &lt;code&gt;char&lt;/code&gt;.</description>
					</attribute>
					<attribute name="@exception">
						<description>EOFException  if this input stream reaches the end before
               reading two bytes.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException   the stream has been closed and the contained
             input stream does not support reading after close, or
             another I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.FilterInputStream#in</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="the stream has been closed and the contained
             input stream does not support reading after close, or
             another I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="readInt" returncomment="the next four bytes of this input stream, interpreted as an
             &lt;code&gt;int&lt;/code&gt;." fulltype="int" type="int">
				<comment>
					<description>See the general contract of the &lt;code&gt;readInt&lt;/code&gt;
 method of &lt;code&gt;DataInput&lt;/code&gt;.
 &lt;p&gt;
 Bytes
 for this operation are read from the contained
 input stream.</description>
					<attribute name="@return">
						<description>the next four bytes of this input stream, interpreted as an
             &lt;code&gt;int&lt;/code&gt;.</description>
					</attribute>
					<attribute name="@exception">
						<description>EOFException  if this input stream reaches the end before
               reading four bytes.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException   the stream has been closed and the contained
             input stream does not support reading after close, or
             another I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.FilterInputStream#in</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="the stream has been closed and the contained
             input stream does not support reading after close, or
             another I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="readLong" returncomment="the next eight bytes of this input stream, interpreted as a
             &lt;code&gt;long&lt;/code&gt;." fulltype="long" type="long">
				<comment>
					<description>See the general contract of the &lt;code&gt;readLong&lt;/code&gt;
 method of &lt;code&gt;DataInput&lt;/code&gt;.
 &lt;p&gt;
 Bytes
 for this operation are read from the contained
 input stream.</description>
					<attribute name="@return">
						<description>the next eight bytes of this input stream, interpreted as a
             &lt;code&gt;long&lt;/code&gt;.</description>
					</attribute>
					<attribute name="@exception">
						<description>EOFException  if this input stream reaches the end before
               reading eight bytes.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException   the stream has been closed and the contained
             input stream does not support reading after close, or
             another I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.FilterInputStream#in</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="the stream has been closed and the contained
             input stream does not support reading after close, or
             another I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="readFloat" returncomment="the next four bytes of this input stream, interpreted as a
             &lt;code&gt;float&lt;/code&gt;." fulltype="float" type="float">
				<comment>
					<description>See the general contract of the &lt;code&gt;readFloat&lt;/code&gt;
 method of &lt;code&gt;DataInput&lt;/code&gt;.
 &lt;p&gt;
 Bytes
 for this operation are read from the contained
 input stream.</description>
					<attribute name="@return">
						<description>the next four bytes of this input stream, interpreted as a
             &lt;code&gt;float&lt;/code&gt;.</description>
					</attribute>
					<attribute name="@exception">
						<description>EOFException  if this input stream reaches the end before
               reading four bytes.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException   the stream has been closed and the contained
             input stream does not support reading after close, or
             another I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.DataInputStream#readInt()</description>
					</attribute>
					<attribute name="@see">
						<description>java.lang.Float#intBitsToFloat(int)</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="the stream has been closed and the contained
             input stream does not support reading after close, or
             another I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="readDouble" returncomment="the next eight bytes of this input stream, interpreted as a
             &lt;code&gt;double&lt;/code&gt;." fulltype="double" type="double">
				<comment>
					<description>See the general contract of the &lt;code&gt;readDouble&lt;/code&gt;
 method of &lt;code&gt;DataInput&lt;/code&gt;.
 &lt;p&gt;
 Bytes
 for this operation are read from the contained
 input stream.</description>
					<attribute name="@return">
						<description>the next eight bytes of this input stream, interpreted as a
             &lt;code&gt;double&lt;/code&gt;.</description>
					</attribute>
					<attribute name="@exception">
						<description>EOFException  if this input stream reaches the end before
               reading eight bytes.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException   the stream has been closed and the contained
             input stream does not support reading after close, or
             another I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.DataInputStream#readLong()</description>
					</attribute>
					<attribute name="@see">
						<description>java.lang.Double#longBitsToDouble(long)</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="the stream has been closed and the contained
             input stream does not support reading after close, or
             another I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="readLine" returncomment="the next line of text from this input stream." fulltype="java.lang.String" type="String">
				<comment>
					<description>See the general contract of the &lt;code&gt;readLine&lt;/code&gt;
 method of &lt;code&gt;DataInput&lt;/code&gt;.
 &lt;p&gt;
 Bytes
 for this operation are read from the contained
 input stream.</description>
					<attribute name="@deprecated">
						<description>This method does not properly convert bytes to characters.
 As of JDK&amp;nbsp;1.1, the preferred way to read lines of text is via the
 &lt;code&gt;BufferedReader.readLine()&lt;/code&gt; method.  Programs that use the
 &lt;code&gt;DataInputStream&lt;/code&gt; class to read lines can be converted to use
 the &lt;code&gt;BufferedReader&lt;/code&gt; class by replacing code of the form:
 &lt;blockquote&gt;&lt;pre&gt;
     DataInputStream d =&amp;nbsp;new&amp;nbsp;DataInputStream(in);
 &lt;/pre&gt;&lt;/blockquote&gt;
 with:
 &lt;blockquote&gt;&lt;pre&gt;
     BufferedReader d
          =&amp;nbsp;new&amp;nbsp;BufferedReader(new&amp;nbsp;InputStreamReader(in));
 &lt;/pre&gt;&lt;/blockquote&gt;</description>
					</attribute>
					<attribute name="@return">
						<description>the next line of text from this input stream.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.BufferedReader#readLine()</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.FilterInputStream#in</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="readUTF" returncomment="a Unicode string." fulltype="java.lang.String" type="String">
				<comment>
					<description>See the general contract of the &lt;code&gt;readUTF&lt;/code&gt;
 method of &lt;code&gt;DataInput&lt;/code&gt;.
 &lt;p&gt;
 Bytes
 for this operation are read from the contained
 input stream.</description>
					<attribute name="@return">
						<description>a Unicode string.</description>
					</attribute>
					<attribute name="@exception">
						<description>EOFException  if this input stream reaches the end before
               reading all the bytes.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException   the stream has been closed and the contained
             input stream does not support reading after close, or
             another I/O error occurs.</description>
					</attribute>
					<attribute name="@exception">
						<description>UTFDataFormatException if the bytes do not represent a valid
             modified UTF-8 encoding of a string.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.DataInputStream#readUTF(java.io.DataInput)</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="the stream has been closed and the contained
             input stream does not support reading after close, or
             another I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" static="true" visibility="public" name="readUTF" returncomment="a Unicode string." fulltype="java.lang.String" type="String">
				<comment>
					<description>Reads from the
 stream &lt;code&gt;in&lt;/code&gt; a representation
 of a Unicode  character string encoded in
 &lt;a href=&quot;DataInput.html#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt; format;
 this string of characters is then returned as a &lt;code&gt;String&lt;/code&gt;.
 The details of the modified UTF-8 representation
 are  exactly the same as for the &lt;code&gt;readUTF&lt;/code&gt;
 method of &lt;code&gt;DataInput&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>in   a data input stream.</description>
					</attribute>
					<attribute name="@return">
						<description>a Unicode string.</description>
					</attribute>
					<attribute name="@exception">
						<description>EOFException            if the input stream reaches the end
               before all the bytes.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException   the stream has been closed and the contained
             input stream does not support reading after close, or
             another I/O error occurs.</description>
					</attribute>
					<attribute name="@exception">
						<description>UTFDataFormatException  if the bytes do not represent a
               valid modified UTF-8 encoding of a Unicode string.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.DataInputStream#readUnsignedShort()</description>
					</attribute>
				</comment>
				<params>
					<param name="in" comment="a data input stream." fulltype="java.io.DataInput" type="DataInput" />
				</params>
				<exceptions>
					<exception comment="the stream has been closed and the contained
             input stream does not support reading after close, or
             another I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="BufferedReader" visibility="public" package="java.io" superclassfulltype="java.io.BufferedReader" fulltype="java.io.LineNumberReader" type="LineNumberReader">
		<comment>
			<description>A buffered character-input stream that keeps track of line numbers.  This
 class defines methods {@link #setLineNumber(int)} and {@link
 #getLineNumber()} for setting and getting the current line number
 respectively.

 &lt;p&gt; By default, line numbering begins at 0. This number increments at every
 &lt;a href=&quot;#lt&quot;&gt;line terminator&lt;/a&gt; as the data is read, and can be changed
 with a call to &lt;tt&gt;setLineNumber(int)&lt;/tt&gt;.  Note however, that
 &lt;tt&gt;setLineNumber(int)&lt;/tt&gt; does not actually change the current position in
 the stream; it only changes the value that will be returned by
 &lt;tt&gt;getLineNumber()&lt;/tt&gt;.

 &lt;p&gt; A line is considered to be &lt;a name=&quot;lt&quot;&gt;terminated&lt;/a&gt; by any one of a
 line feed (&apos;\n&apos;), a carriage return (&apos;\r&apos;), or a carriage return followed
 immediately by a linefeed.</description>
			<attribute name="@author">
				<description>Mark Reinhold</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.1</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="private" name="lineNumber" fulltype="int" type="int">
				<comment>
					<description>The current line number</description>
				</comment>
			</field>
			<field visibility="private" name="markedLineNumber" fulltype="int" type="int">
				<comment>
					<description>The line number of the mark, if any</description>
				</comment>
			</field>
			<field visibility="private" name="skipLF" fulltype="boolean" type="boolean">
				<comment>
					<description>If the next character is a line feed, skip it</description>
				</comment>
			</field>
			<field visibility="private" name="markedSkipLF" fulltype="boolean" type="boolean">
				<comment>
					<description>The skipLF flag when the mark was set</description>
				</comment>
			</field>
			<field final="true" static="true" const="8192" visibility="private" name="maxSkipBufferSize" constexpr="8192" fulltype="int" type="int">
				<comment>
					<description>Maximum skip-buffer size</description>
				</comment>
			</field>
			<field visibility="private" name="skipBuffer" fulltype="char[]" type="char">
				<comment>
					<description>Skip buffer, null until allocated</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="public" name="LineNumberReader">
				<comment>
					<description>Create a new line-numbering reader, using the default input-buffer
 size.</description>
					<attribute name="@param">
						<description>in
         A Reader object to provide the underlying stream</description>
					</attribute>
				</comment>
				<params>
					<param name="in" comment="A Reader object to provide the underlying stream" fulltype="java.io.Reader" type="Reader" />
				</params>
			</constructor>
			<constructor visibility="public" name="LineNumberReader">
				<comment>
					<description>Create a new line-numbering reader, reading characters into a buffer of
 the given size.</description>
					<attribute name="@param">
						<description>in
         A Reader object to provide the underlying stream</description>
					</attribute>
					<attribute name="@param">
						<description>sz
         An int specifying the size of the buffer</description>
					</attribute>
				</comment>
				<params>
					<param name="in" comment="A Reader object to provide the underlying stream" fulltype="java.io.Reader" type="Reader" />
					<param name="sz" comment="An int specifying the size of the buffer" fulltype="int" type="int" />
				</params>
			</constructor>
			<method visibility="public" name="setLineNumber" fulltype="void" type="void">
				<comment>
					<description>Set the current line number.</description>
					<attribute name="@param">
						<description>lineNumber
         An int specifying the line number</description>
					</attribute>
					<attribute name="@see">
						<description>#getLineNumber</description>
					</attribute>
				</comment>
				<params>
					<param name="lineNumber" comment="An int specifying the line number" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="getLineNumber" returncomment="The current line number" fulltype="int" type="int">
				<comment>
					<description>Get the current line number.</description>
					<attribute name="@return">
						<description>The current line number</description>
					</attribute>
					<attribute name="@see">
						<description>#setLineNumber</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="read" returncomment="The character read, or -1 if the end of the stream has been
          reached" fulltype="int" type="int">
				<comment>
					<description>Read a single character.  &lt;a href=&quot;#lt&quot;&gt;Line terminators&lt;/a&gt; are
 compressed into single newline (&apos;\n&apos;) characters.  Whenever a line
 terminator is read the current line number is incremented.</description>
					<attribute name="@return">
						<description>The character read, or -1 if the end of the stream has been
          reached</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException
          If an I/O error occurs</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="read" returncomment="The number of bytes read, or -1 if the end of the stream has
          already been reached" fulltype="int" type="int">
				<comment>
					<description>Read characters into a portion of an array.  Whenever a &lt;a
 href=&quot;#lt&quot;&gt;line terminator&lt;/a&gt; is read the current line number is
 incremented.</description>
					<attribute name="@param">
						<description>cbuf
         Destination buffer</description>
					</attribute>
					<attribute name="@param">
						<description>off
         Offset at which to start storing characters</description>
					</attribute>
					<attribute name="@param">
						<description>len
         Maximum number of characters to read</description>
					</attribute>
					<attribute name="@return">
						<description>The number of bytes read, or -1 if the end of the stream has
          already been reached</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException
          If an I/O error occurs</description>
					</attribute>
				</comment>
				<params>
					<param name="cbuf" comment="Destination buffer" fulltype="char[]" type="char" />
					<param name="off" comment="Offset at which to start storing characters" fulltype="int" type="int" />
					<param name="len" comment="Maximum number of characters to read" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="readLine" returncomment="A String containing the contents of the line, not including
          any &lt;a href=&quot;#lt&quot;&gt;line termination characters&lt;/a&gt;, or
          &lt;tt&gt;null&lt;/tt&gt; if the end of the stream has been reached" fulltype="java.lang.String" type="String">
				<comment>
					<description>Read a line of text.  Whenever a &lt;a href=&quot;#lt&quot;&gt;line terminator&lt;/a&gt; is
 read the current line number is incremented.</description>
					<attribute name="@return">
						<description>A String containing the contents of the line, not including
          any &lt;a href=&quot;#lt&quot;&gt;line termination characters&lt;/a&gt;, or
          &lt;tt&gt;null&lt;/tt&gt; if the end of the stream has been reached</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException
          If an I/O error occurs</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="skip" returncomment="The number of characters actually skipped" fulltype="long" type="long">
				<comment>
					<description>Skip characters.</description>
					<attribute name="@param">
						<description>n
         The number of characters to skip</description>
					</attribute>
					<attribute name="@return">
						<description>The number of characters actually skipped</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException
          If an I/O error occurs</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException
          If &lt;tt&gt;n&lt;/tt&gt; is negative</description>
					</attribute>
				</comment>
				<params>
					<param name="n" comment="The number of characters to skip" fulltype="long" type="long" />
				</params>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="mark" fulltype="void" type="void">
				<comment>
					<description>Mark the present position in the stream.  Subsequent calls to reset()
 will attempt to reposition the stream to this point, and will also reset
 the line number appropriately.</description>
					<attribute name="@param">
						<description>readAheadLimit
         Limit on the number of characters that may be read while still
         preserving the mark.  After reading this many characters,
         attempting to reset the stream may fail.</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException
          If an I/O error occurs</description>
					</attribute>
				</comment>
				<params>
					<param name="readAheadLimit" comment="Limit on the number of characters that may be read while still
         preserving the mark.  After reading this many characters,
         attempting to reset the stream may fail." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="reset" fulltype="void" type="void">
				<comment>
					<description>Reset the stream to the most recent mark.</description>
					<attribute name="@throws">
						<description>IOException
          If the stream has not been marked, or if the mark has been
          invalidated</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If the stream has not been marked, or if the mark has been
          invalidated" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass abstract="true" superclass="IOException" visibility="public" package="java.io" serializable="true" superclassfulltype="java.io.IOException" fulltype="java.io.ObjectStreamException" type="ObjectStreamException">
		<comment>
			<description>Superclass of all exceptions specific to Object Stream classes.</description>
			<attribute name="@author">
				<description>unascribed</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.1</description>
			</attribute>
		</comment>
		<fields>
			<field final="true" static="true" const="7260898174833392607" visibility="private" name="serialVersionUID" constexpr="7260898174833392607L" fulltype="long" type="long" />
		</fields>
		<methods>
			<constructor visibility="protected" name="ObjectStreamException">
				<comment>
					<description>Create an ObjectStreamException with the specified argument.</description>
					<attribute name="@param">
						<description>classname the detailed message for the exception</description>
					</attribute>
				</comment>
				<params>
					<param name="classname" comment="the detailed message for the exception" fulltype="java.lang.String" type="String" />
				</params>
			</constructor>
			<constructor visibility="protected" name="ObjectStreamException">
				<comment>
					<description>Create an ObjectStreamException.</description>
				</comment>
			</constructor>
		</methods>
	</jelclass>
	<jelclass superclass="IOException" visibility="public" package="java.io" serializable="true" superclassfulltype="java.io.IOException" fulltype="java.io.FileNotFoundException" type="FileNotFoundException">
		<comment>
			<description>Signals that an attempt to open the file denoted by a specified pathname
 has failed.

 &lt;p&gt; This exception will be thrown by the {@link FileInputStream}, {@link
 FileOutputStream}, and {@link RandomAccessFile} constructors when a file
 with the specified pathname does not exist.  It will also be thrown by these
 constructors if the file does exist but for some reason is inaccessible, for
 example when an attempt is made to open a read-only file for writing.</description>
			<attribute name="@author">
				<description>unascribed</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.0</description>
			</attribute>
		</comment>
		<methods>
			<constructor visibility="public" name="FileNotFoundException">
				<comment>
					<description>Constructs a &lt;code&gt;FileNotFoundException&lt;/code&gt; with
 &lt;code&gt;null&lt;/code&gt; as its error detail message.</description>
				</comment>
			</constructor>
			<constructor visibility="public" name="FileNotFoundException">
				<comment>
					<description>Constructs a &lt;code&gt;FileNotFoundException&lt;/code&gt; with the
 specified detail message. The string &lt;code&gt;s&lt;/code&gt; can be
 retrieved later by the
 &lt;code&gt;{@link java.lang.Throwable#getMessage}&lt;/code&gt;
 method of class &lt;code&gt;java.lang.Throwable&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>s   the detail message.</description>
					</attribute>
				</comment>
				<params>
					<param name="s" comment="the detail message." fulltype="java.lang.String" type="String" />
				</params>
			</constructor>
			<constructor visibility="private" name="FileNotFoundException">
				<comment>
					<description>Constructs a &lt;code&gt;FileNotFoundException&lt;/code&gt; with a detail message
 consisting of the given pathname string followed by the given reason
 string.  If the &lt;code&gt;reason&lt;/code&gt; argument is &lt;code&gt;null&lt;/code&gt; then
 it will be omitted.  This private constructor is invoked only by native
 I/O methods.</description>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
				<params>
					<param name="path" fulltype="java.lang.String" type="String" />
					<param name="reason" fulltype="java.lang.String" type="String" />
				</params>
			</constructor>
		</methods>
	</jelclass>
	<jelclass superclass="OutputStream" visibility="public" package="java.io" superclassfulltype="java.io.OutputStream" fulltype="java.io.FileOutputStream" type="FileOutputStream">
		<comment>
			<description>A file output stream is an output stream for writing data to a
 &lt;code&gt;File&lt;/code&gt; or to a &lt;code&gt;FileDescriptor&lt;/code&gt;. Whether or not
 a file is available or may be created depends upon the underlying
 platform.  Some platforms, in particular, allow a file to be opened
 for writing by only one &lt;tt&gt;FileOutputStream&lt;/tt&gt; (or other
 file-writing object) at a time.  In such situations the constructors in
 this class will fail if the file involved is already open.

 &lt;p&gt;&lt;code&gt;FileOutputStream&lt;/code&gt; is meant for writing streams of raw bytes
 such as image data. For writing streams of characters, consider using
 &lt;code&gt;FileWriter&lt;/code&gt;.</description>
			<attribute name="@author">
				<description>Arthur van Hoff</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.File</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.FileDescriptor</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.FileInputStream</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.0</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="private" name="fd" fulltype="java.io.FileDescriptor" type="FileDescriptor">
				<comment>
					<description>The system dependent file descriptor. The value is
 1 more than actual file descriptor. This means that
 the default value 0 indicates that the file is not open.</description>
				</comment>
			</field>
			<field visibility="private" name="channel" fulltype="java.nio.channels.FileChannel" type="FileChannel" />
			<field visibility="private" name="append" fulltype="boolean" type="boolean" />
			<field visibility="private" name="closeLock" fulltype="java.lang.Object" type="Object" />
			<field volatile="true" visibility="private" name="closed" fulltype="boolean" type="boolean" />
			<field static="true" visibility="private" name="runningFinalize" fulltype="java.lang.ThreadLocal" type="ThreadLocal" />
		</fields>
		<methods>
			<constructor visibility="public" name="FileOutputStream">
				<comment>
					<description>Creates an output file stream to write to the file with the
 specified name. A new &lt;code&gt;FileDescriptor&lt;/code&gt; object is
 created to represent this file connection.
 &lt;p&gt;
 First, if there is a security manager, its &lt;code&gt;checkWrite&lt;/code&gt;
 method is called with &lt;code&gt;name&lt;/code&gt; as its argument.
 &lt;p&gt;
 If the file exists but is a directory rather than a regular file, does
 not exist but cannot be created, or cannot be opened for any other
 reason then a &lt;code&gt;FileNotFoundException&lt;/code&gt; is thrown.</description>
					<attribute name="@param">
						<description>name   the system-dependent filename</description>
					</attribute>
					<attribute name="@exception">
						<description>FileNotFoundException  if the file exists but is a directory
                   rather than a regular file, does not exist but cannot
                   be created, or cannot be opened for any other reason</description>
					</attribute>
					<attribute name="@exception">
						<description>SecurityException  if a security manager exists and its
               &lt;code&gt;checkWrite&lt;/code&gt; method denies write access
               to the file.</description>
					</attribute>
					<attribute name="@see">
						<description>java.lang.SecurityManager#checkWrite(java.lang.String)</description>
					</attribute>
				</comment>
				<params>
					<param name="name" comment="the system-dependent filename" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception comment="if the file exists but is a directory
                   rather than a regular file, does not exist but cannot
                   be created, or cannot be opened for any other reason" fulltype="java.io.FileNotFoundException" type="FileNotFoundException" />
				</exceptions>
			</constructor>
			<constructor visibility="public" name="FileOutputStream">
				<comment>
					<description>Creates an output file stream to write to the file with the specified
 &lt;code&gt;name&lt;/code&gt;.  If the second argument is &lt;code&gt;true&lt;/code&gt;, then
 bytes will be written to the end of the file rather than the beginning.
 A new &lt;code&gt;FileDescriptor&lt;/code&gt; object is created to represent this
 file connection.
 &lt;p&gt;
 First, if there is a security manager, its &lt;code&gt;checkWrite&lt;/code&gt;
 method is called with &lt;code&gt;name&lt;/code&gt; as its argument.
 &lt;p&gt;
 If the file exists but is a directory rather than a regular file, does
 not exist but cannot be created, or cannot be opened for any other
 reason then a &lt;code&gt;FileNotFoundException&lt;/code&gt; is thrown.</description>
					<attribute name="@param">
						<description>name        the system-dependent file name</description>
					</attribute>
					<attribute name="@param">
						<description>append      if &lt;code&gt;true&lt;/code&gt;, then bytes will be written
                   to the end of the file rather than the beginning</description>
					</attribute>
					<attribute name="@exception">
						<description>FileNotFoundException  if the file exists but is a directory
                   rather than a regular file, does not exist but cannot
                   be created, or cannot be opened for any other reason.</description>
					</attribute>
					<attribute name="@exception">
						<description>SecurityException  if a security manager exists and its
               &lt;code&gt;checkWrite&lt;/code&gt; method denies write access
               to the file.</description>
					</attribute>
					<attribute name="@see">
						<description>java.lang.SecurityManager#checkWrite(java.lang.String)</description>
					</attribute>
					<attribute name="@since">
						<description>JDK1.1</description>
					</attribute>
				</comment>
				<params>
					<param name="name" comment="the system-dependent file name" fulltype="java.lang.String" type="String" />
					<param name="append" comment="if &lt;code&gt;true&lt;/code&gt;, then bytes will be written
                   to the end of the file rather than the beginning" fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception comment="if the file exists but is a directory
                   rather than a regular file, does not exist but cannot
                   be created, or cannot be opened for any other reason." fulltype="java.io.FileNotFoundException" type="FileNotFoundException" />
				</exceptions>
			</constructor>
			<constructor visibility="public" name="FileOutputStream">
				<comment>
					<description>Creates a file output stream to write to the file represented by
 the specified &lt;code&gt;File&lt;/code&gt; object. A new
 &lt;code&gt;FileDescriptor&lt;/code&gt; object is created to represent this
 file connection.
 &lt;p&gt;
 First, if there is a security manager, its &lt;code&gt;checkWrite&lt;/code&gt;
 method is called with the path represented by the &lt;code&gt;file&lt;/code&gt;
 argument as its argument.
 &lt;p&gt;
 If the file exists but is a directory rather than a regular file, does
 not exist but cannot be created, or cannot be opened for any other
 reason then a &lt;code&gt;FileNotFoundException&lt;/code&gt; is thrown.</description>
					<attribute name="@param">
						<description>file               the file to be opened for writing.</description>
					</attribute>
					<attribute name="@exception">
						<description>FileNotFoundException  if the file exists but is a directory
                   rather than a regular file, does not exist but cannot
                   be created, or cannot be opened for any other reason</description>
					</attribute>
					<attribute name="@exception">
						<description>SecurityException  if a security manager exists and its
               &lt;code&gt;checkWrite&lt;/code&gt; method denies write access
               to the file.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.File#getPath()</description>
					</attribute>
					<attribute name="@see">
						<description>java.lang.SecurityException</description>
					</attribute>
					<attribute name="@see">
						<description>java.lang.SecurityManager#checkWrite(java.lang.String)</description>
					</attribute>
				</comment>
				<params>
					<param name="file" comment="the file to be opened for writing." fulltype="java.io.File" type="File" />
				</params>
				<exceptions>
					<exception comment="if the file exists but is a directory
                   rather than a regular file, does not exist but cannot
                   be created, or cannot be opened for any other reason" fulltype="java.io.FileNotFoundException" type="FileNotFoundException" />
				</exceptions>
			</constructor>
			<constructor visibility="public" name="FileOutputStream">
				<comment>
					<description>Creates a file output stream to write to the file represented by
 the specified &lt;code&gt;File&lt;/code&gt; object. If the second argument is
 &lt;code&gt;true&lt;/code&gt;, then bytes will be written to the end of the file
 rather than the beginning. A new &lt;code&gt;FileDescriptor&lt;/code&gt; object is
 created to represent this file connection.
 &lt;p&gt;
 First, if there is a security manager, its &lt;code&gt;checkWrite&lt;/code&gt;
 method is called with the path represented by the &lt;code&gt;file&lt;/code&gt;
 argument as its argument.
 &lt;p&gt;
 If the file exists but is a directory rather than a regular file, does
 not exist but cannot be created, or cannot be opened for any other
 reason then a &lt;code&gt;FileNotFoundException&lt;/code&gt; is thrown.</description>
					<attribute name="@param">
						<description>file               the file to be opened for writing.</description>
					</attribute>
					<attribute name="@param">
						<description>append      if &lt;code&gt;true&lt;/code&gt;, then bytes will be written
                   to the end of the file rather than the beginning</description>
					</attribute>
					<attribute name="@exception">
						<description>FileNotFoundException  if the file exists but is a directory
                   rather than a regular file, does not exist but cannot
                   be created, or cannot be opened for any other reason</description>
					</attribute>
					<attribute name="@exception">
						<description>SecurityException  if a security manager exists and its
               &lt;code&gt;checkWrite&lt;/code&gt; method denies write access
               to the file.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.File#getPath()</description>
					</attribute>
					<attribute name="@see">
						<description>java.lang.SecurityException</description>
					</attribute>
					<attribute name="@see">
						<description>java.lang.SecurityManager#checkWrite(java.lang.String)</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
				<params>
					<param name="file" comment="the file to be opened for writing." fulltype="java.io.File" type="File" />
					<param name="append" comment="if &lt;code&gt;true&lt;/code&gt;, then bytes will be written
                   to the end of the file rather than the beginning" fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception comment="if the file exists but is a directory
                   rather than a regular file, does not exist but cannot
                   be created, or cannot be opened for any other reason" fulltype="java.io.FileNotFoundException" type="FileNotFoundException" />
				</exceptions>
			</constructor>
			<constructor visibility="public" name="FileOutputStream">
				<comment>
					<description>Creates an output file stream to write to the specified file
 descriptor, which represents an existing connection to an actual
 file in the file system.
 &lt;p&gt;
 First, if there is a security manager, its &lt;code&gt;checkWrite&lt;/code&gt;
 method is called with the file descriptor &lt;code&gt;fdObj&lt;/code&gt;
 argument as its argument.</description>
					<attribute name="@param">
						<description>fdObj   the file descriptor to be opened for writing</description>
					</attribute>
					<attribute name="@exception">
						<description>SecurityException  if a security manager exists and its
               &lt;code&gt;checkWrite&lt;/code&gt; method denies
               write access to the file descriptor</description>
					</attribute>
					<attribute name="@see">
						<description>java.lang.SecurityManager#checkWrite(java.io.FileDescriptor)</description>
					</attribute>
				</comment>
				<params>
					<param name="fdObj" comment="the file descriptor to be opened for writing" fulltype="java.io.FileDescriptor" type="FileDescriptor" />
				</params>
			</constructor>
			<method static="true" visibility="private" name="isRunningFinalize" fulltype="boolean" type="boolean" />
			<method visibility="private" name="open" fulltype="void" type="void">
				<comment>
					<description>Opens a file, with the specified name, for writing.</description>
					<attribute name="@param">
						<description>name name of file to be opened</description>
					</attribute>
				</comment>
				<params>
					<param name="name" comment="name of file to be opened" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception fulltype="java.io.FileNotFoundException" type="FileNotFoundException" />
				</exceptions>
			</method>
			<method visibility="private" name="openAppend" fulltype="void" type="void">
				<comment>
					<description>Opens a file, with the specified name, for appending.</description>
					<attribute name="@param">
						<description>name name of file to be opened</description>
					</attribute>
				</comment>
				<params>
					<param name="name" comment="name of file to be opened" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception fulltype="java.io.FileNotFoundException" type="FileNotFoundException" />
				</exceptions>
			</method>
			<method visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes the specified byte to this file output stream. Implements
 the &lt;code&gt;write&lt;/code&gt; method of &lt;code&gt;OutputStream&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>b   the byte to be written.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the byte to be written." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="writeBytes" fulltype="void" type="void">
				<comment>
					<description>Writes a sub array as a sequence of bytes.</description>
					<attribute name="@param">
						<description>b the data to be written</description>
					</attribute>
					<attribute name="@param">
						<description>off the start offset in the data</description>
					</attribute>
					<attribute name="@param">
						<description>len the number of bytes that are written</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException If an I/O error has occurred.</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the data to be written" fulltype="byte[]" type="byte" />
					<param name="off" comment="the start offset in the data" fulltype="int" type="int" />
					<param name="len" comment="the number of bytes that are written" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="If an I/O error has occurred." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes &lt;code&gt;b.length&lt;/code&gt; bytes from the specified byte array
 to this file output stream.</description>
					<attribute name="@param">
						<description>b   the data.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the data." fulltype="byte[]" type="byte" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes &lt;code&gt;len&lt;/code&gt; bytes from the specified byte array
 starting at offset &lt;code&gt;off&lt;/code&gt; to this file output stream.</description>
					<attribute name="@param">
						<description>b     the data.</description>
					</attribute>
					<attribute name="@param">
						<description>off   the start offset in the data.</description>
					</attribute>
					<attribute name="@param">
						<description>len   the number of bytes to write.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the data." fulltype="byte[]" type="byte" />
					<param name="off" comment="the start offset in the data." fulltype="int" type="int" />
					<param name="len" comment="the number of bytes to write." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="close" fulltype="void" type="void">
				<comment>
					<description>Closes this file output stream and releases any system resources
 associated with this stream. This file output stream may no longer
 be used for writing bytes.

 &lt;p&gt; If this stream has an associated channel then the channel is closed
 as well.</description>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
					<attribute name="@revised">
						<description>1.4</description>
					</attribute>
					<attribute name="@spec">
						<description>JSR-51</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="getFD" returncomment="the &lt;code&gt;FileDescriptor&lt;/code&gt; object that represents
          the connection to the file in the file system being used
          by this &lt;code&gt;FileOutputStream&lt;/code&gt; object." fulltype="java.io.FileDescriptor" type="FileDescriptor">
				<comment>
					<description>Returns the file descriptor associated with this stream.</description>
					<attribute name="@return">
						<description>the &lt;code&gt;FileDescriptor&lt;/code&gt; object that represents
          the connection to the file in the file system being used
          by this &lt;code&gt;FileOutputStream&lt;/code&gt; object.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.FileDescriptor</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="getChannel" returncomment="the file channel associated with this file output stream" fulltype="java.nio.channels.FileChannel" type="FileChannel">
				<comment>
					<description>Returns the unique {@link java.nio.channels.FileChannel FileChannel}
 object associated with this file output stream. &lt;/p&gt;

 &lt;p&gt; The initial {@link java.nio.channels.FileChannel#position()
 &lt;/code&gt;position&lt;code&gt;} of the returned channel will be equal to the
 number of bytes written to the file so far unless this stream is in
 append mode, in which case it will be equal to the size of the file.
 Writing bytes to this stream will increment the channel&apos;s position
 accordingly.  Changing the channel&apos;s position, either explicitly or by
 writing, will change this stream&apos;s file position.</description>
					<attribute name="@return">
						<description>the file channel associated with this file output stream</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
					<attribute name="@spec">
						<description>JSR-51</description>
					</attribute>
				</comment>
			</method>
			<method visibility="protected" name="finalize" fulltype="void" type="void">
				<comment>
					<description>Cleans up the connection to the file, and ensures that the
 &lt;code&gt;close&lt;/code&gt; method of this file output stream is
 called when there are no more references to this stream.</description>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.FileInputStream#close()</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="close0" fulltype="void" type="void">
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method static="true" visibility="private" name="initIDs" fulltype="void" type="void" />
		</methods>
	</jelclass>
	<jelclass final="true" superclass="BasicPermission" visibility="public" package="java.io" serializable="true" superclassfulltype="java.security.BasicPermission" fulltype="java.io.SerializablePermission" type="SerializablePermission">
		<comment>
			<description>This class is for Serializable permissions. A SerializablePermission
 contains a name (also referred to as a &quot;target name&quot;) but
 no actions list; you either have the named permission
 or you don&apos;t.

 &lt;P&gt;
 The target name is the name of the Serializable permission (see below).

 &lt;P&gt;
 The following table lists all the possible SerializablePermission target names,
 and for each provides a description of what the permission allows
 and a discussion of the risks of granting code the permission.
 &lt;P&gt;

 &lt;table border=1 cellpadding=5 summary=&quot;Permission target name, what the permission allows, and associated risks&quot;&gt;
 &lt;tr&gt;
 &lt;th&gt;Permission Target Name&lt;/th&gt;
 &lt;th&gt;What the Permission Allows&lt;/th&gt;
 &lt;th&gt;Risks of Allowing this Permission&lt;/th&gt;
 &lt;/tr&gt;

 &lt;tr&gt;
   &lt;td&gt;enableSubclassImplementation&lt;/td&gt;
   &lt;td&gt;Subclass implementation of ObjectOutputStream or ObjectInputStream
 to override the default serialization or deserialization, respectively,
 of objects&lt;/td&gt;
   &lt;td&gt;Code can use this to serialize or
 deserialize classes in a purposefully malfeasant manner. For example,
 during serialization, malicious code can use this to
 purposefully store confidential private field data in a way easily accessible
 to attackers. Or, during deserialization it could, for example, deserialize
 a class with all its private fields zeroed out.&lt;/td&gt;
 &lt;/tr&gt;

 &lt;tr&gt;
   &lt;td&gt;enableSubstitution&lt;/td&gt;
   &lt;td&gt;Substitution of one object for another during
 serialization or deserialization&lt;/td&gt;
   &lt;td&gt;This is dangerous because malicious code
 can replace the actual object with one which has incorrect or
 malignant data.&lt;/td&gt;
 &lt;/tr&gt;

 &lt;/table&gt;</description>
			<attribute name="@see">
				<description>java.security.BasicPermission</description>
			</attribute>
			<attribute name="@see">
				<description>java.security.Permission</description>
			</attribute>
			<attribute name="@see">
				<description>java.security.Permissions</description>
			</attribute>
			<attribute name="@see">
				<description>java.security.PermissionCollection</description>
			</attribute>
			<attribute name="@see">
				<description>java.lang.SecurityManager</description>
			</attribute>
			<attribute name="@author">
				<description>Joe Fialli</description>
			</attribute>
			<attribute name="@since">
				<description>1.2</description>
			</attribute>
		</comment>
		<fields>
			<field final="true" static="true" const="8537212141160296410" visibility="private" name="serialVersionUID" constexpr="8537212141160296410L" fulltype="long" type="long" />
			<field visibility="private" name="actions" fulltype="java.lang.String" type="String">
				<comment>
					<attribute name="@serial" />
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="public" name="SerializablePermission">
				<comment>
					<description>Creates a new SerializablePermission with the specified name.
 The name is the symbolic name of the SerializablePermission, such as
 &quot;enableSubstitution&quot;, etc.</description>
					<attribute name="@param">
						<description>name the name of the SerializablePermission.</description>
					</attribute>
					<attribute name="@throws">
						<description>NullPointerException if &lt;code&gt;name&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; is empty.</description>
					</attribute>
				</comment>
				<params>
					<param name="name" comment="the name of the SerializablePermission." fulltype="java.lang.String" type="String" />
				</params>
			</constructor>
			<constructor visibility="public" name="SerializablePermission">
				<comment>
					<description>Creates a new SerializablePermission object with the specified name.
 The name is the symbolic name of the SerializablePermission, and the
 actions String is currently unused and should be null.</description>
					<attribute name="@param">
						<description>name the name of the SerializablePermission.</description>
					</attribute>
					<attribute name="@param">
						<description>actions currently unused and must be set to null</description>
					</attribute>
					<attribute name="@throws">
						<description>NullPointerException if &lt;code&gt;name&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; is empty.</description>
					</attribute>
				</comment>
				<params>
					<param name="name" comment="the name of the SerializablePermission." fulltype="java.lang.String" type="String" />
					<param name="actions" comment="currently unused and must be set to null" fulltype="java.lang.String" type="String" />
				</params>
			</constructor>
		</methods>
	</jelclass>
	<jelclass abstract="true" superclass="Object" visibility="public" package="java.io" superclassfulltype="java.lang.Object" fulltype="java.io.InputStream" type="InputStream">
		<implements>
			<interface fulltype="java.io.Closeable" type="Closeable" />
		</implements>
		<comment>
			<description>This abstract class is the superclass of all classes representing
 an input stream of bytes.

 &lt;p&gt; Applications that need to define a subclass of &lt;code&gt;InputStream&lt;/code&gt;
 must always provide a method that returns the next byte of input.</description>
			<attribute name="@author">
				<description>Arthur van Hoff</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.BufferedInputStream</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.ByteArrayInputStream</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.DataInputStream</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.FilterInputStream</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.InputStream#read()</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.OutputStream</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.PushbackInputStream</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.0</description>
			</attribute>
		</comment>
		<fields>
			<field final="true" static="true" const="2048" visibility="private" name="MAX_SKIP_BUFFER_SIZE" constexpr="2048" fulltype="int" type="int" />
		</fields>
		<methods>
			<constructor visibility="public" name="InputStream" />
			<method abstract="true" visibility="public" name="read" returncomment="the next byte of data, or &lt;code&gt;-1&lt;/code&gt; if the end of the
             stream is reached." fulltype="int" type="int">
				<comment>
					<description>Reads the next byte of data from the input stream. The value byte is
 returned as an &lt;code&gt;int&lt;/code&gt; in the range &lt;code&gt;0&lt;/code&gt; to
 &lt;code&gt;255&lt;/code&gt;. If no byte is available because the end of the stream
 has been reached, the value &lt;code&gt;-1&lt;/code&gt; is returned. This method
 blocks until input data is available, the end of the stream is detected,
 or an exception is thrown.

 &lt;p&gt; A subclass must provide an implementation of this method.</description>
					<attribute name="@return">
						<description>the next byte of data, or &lt;code&gt;-1&lt;/code&gt; if the end of the
             stream is reached.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="read" returncomment="the total number of bytes read into the buffer, or
             &lt;code&gt;-1&lt;/code&gt; is there is no more data because the end of
             the stream has been reached." fulltype="int" type="int">
				<comment>
					<description>Reads some number of bytes from the input stream and stores them into
 the buffer array &lt;code&gt;b&lt;/code&gt;. The number of bytes actually read is
 returned as an integer.  This method blocks until input data is
 available, end of file is detected, or an exception is thrown.

 &lt;p&gt; If the length of &lt;code&gt;b&lt;/code&gt; is zero, then no bytes are read and
 &lt;code&gt;0&lt;/code&gt; is returned; otherwise, there is an attempt to read at
 least one byte. If no byte is available because the stream is at the
 end of the file, the value &lt;code&gt;-1&lt;/code&gt; is returned; otherwise, at
 least one byte is read and stored into &lt;code&gt;b&lt;/code&gt;.

 &lt;p&gt; The first byte read is stored into element &lt;code&gt;b[0]&lt;/code&gt;, the
 next one into &lt;code&gt;b[1]&lt;/code&gt;, and so on. The number of bytes read is,
 at most, equal to the length of &lt;code&gt;b&lt;/code&gt;. Let &lt;i&gt;k&lt;/i&gt; be the
 number of bytes actually read; these bytes will be stored in elements
 &lt;code&gt;b[0]&lt;/code&gt; through &lt;code&gt;b[&lt;/code&gt;&lt;i&gt;k&lt;/i&gt;&lt;code&gt;-1]&lt;/code&gt;,
 leaving elements &lt;code&gt;b[&lt;/code&gt;&lt;i&gt;k&lt;/i&gt;&lt;code&gt;]&lt;/code&gt; through
 &lt;code&gt;b[b.length-1]&lt;/code&gt; unaffected.

 &lt;p&gt; The &lt;code&gt;read(b)&lt;/code&gt; method for class &lt;code&gt;InputStream&lt;/code&gt;
 has the same effect as: &lt;pre&gt;&lt;code&gt; read(b, 0, b.length) &lt;/code&gt;&lt;/pre&gt;</description>
					<attribute name="@param">
						<description>b   the buffer into which the data is read.</description>
					</attribute>
					<attribute name="@return">
						<description>the total number of bytes read into the buffer, or
             &lt;code&gt;-1&lt;/code&gt; is there is no more data because the end of
             the stream has been reached.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  If the first byte cannot be read for any reason
 other than the end of the file, if the input stream has been closed, or
 if some other I/O error occurs.</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException  if &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.InputStream#read(byte[], int, int)</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the buffer into which the data is read." fulltype="byte[]" type="byte" />
				</params>
				<exceptions>
					<exception comment="If the first byte cannot be read for any reason
 other than the end of the file, if the input stream has been closed, or
 if some other I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="read" returncomment="the total number of bytes read into the buffer, or
             &lt;code&gt;-1&lt;/code&gt; if there is no more data because the end of
             the stream has been reached." fulltype="int" type="int">
				<comment>
					<description>Reads up to &lt;code&gt;len&lt;/code&gt; bytes of data from the input stream into
 an array of bytes.  An attempt is made to read as many as
 &lt;code&gt;len&lt;/code&gt; bytes, but a smaller number may be read.
 The number of bytes actually read is returned as an integer.

 &lt;p&gt; This method blocks until input data is available, end of file is
 detected, or an exception is thrown.

 &lt;p&gt; If &lt;code&gt;len&lt;/code&gt; is zero, then no bytes are read and
 &lt;code&gt;0&lt;/code&gt; is returned; otherwise, there is an attempt to read at
 least one byte. If no byte is available because the stream is at end of
 file, the value &lt;code&gt;-1&lt;/code&gt; is returned; otherwise, at least one
 byte is read and stored into &lt;code&gt;b&lt;/code&gt;.

 &lt;p&gt; The first byte read is stored into element &lt;code&gt;b[off]&lt;/code&gt;, the
 next one into &lt;code&gt;b[off+1]&lt;/code&gt;, and so on. The number of bytes read
 is, at most, equal to &lt;code&gt;len&lt;/code&gt;. Let &lt;i&gt;k&lt;/i&gt; be the number of
 bytes actually read; these bytes will be stored in elements
 &lt;code&gt;b[off]&lt;/code&gt; through &lt;code&gt;b[off+&lt;/code&gt;&lt;i&gt;k&lt;/i&gt;&lt;code&gt;-1]&lt;/code&gt;,
 leaving elements &lt;code&gt;b[off+&lt;/code&gt;&lt;i&gt;k&lt;/i&gt;&lt;code&gt;]&lt;/code&gt; through
 &lt;code&gt;b[off+len-1]&lt;/code&gt; unaffected.

 &lt;p&gt; In every case, elements &lt;code&gt;b[0]&lt;/code&gt; through
 &lt;code&gt;b[off]&lt;/code&gt; and elements &lt;code&gt;b[off+len]&lt;/code&gt; through
 &lt;code&gt;b[b.length-1]&lt;/code&gt; are unaffected.

 &lt;p&gt; The &lt;code&gt;read(b,&lt;/code&gt; &lt;code&gt;off,&lt;/code&gt; &lt;code&gt;len)&lt;/code&gt; method
 for class &lt;code&gt;InputStream&lt;/code&gt; simply calls the method
 &lt;code&gt;read()&lt;/code&gt; repeatedly. If the first such call results in an
 &lt;code&gt;IOException&lt;/code&gt;, that exception is returned from the call to
 the &lt;code&gt;read(b,&lt;/code&gt; &lt;code&gt;off,&lt;/code&gt; &lt;code&gt;len)&lt;/code&gt; method.  If
 any subsequent call to &lt;code&gt;read()&lt;/code&gt; results in a
 &lt;code&gt;IOException&lt;/code&gt;, the exception is caught and treated as if it
 were end of file; the bytes read up to that point are stored into
 &lt;code&gt;b&lt;/code&gt; and the number of bytes read before the exception
 occurred is returned. The default implementation of this method blocks
 until the requested amount of input data &lt;code&gt;len&lt;/code&gt; has been read,
 end of file is detected, or an exception is thrown. Subclasses are encouraged
 to provide a more efficient implementation of this method.</description>
					<attribute name="@param">
						<description>b     the buffer into which the data is read.</description>
					</attribute>
					<attribute name="@param">
						<description>off   the start offset in array &lt;code&gt;b&lt;/code&gt;
                   at which the data is written.</description>
					</attribute>
					<attribute name="@param">
						<description>len   the maximum number of bytes to read.</description>
					</attribute>
					<attribute name="@return">
						<description>the total number of bytes read into the buffer, or
             &lt;code&gt;-1&lt;/code&gt; if there is no more data because the end of
             the stream has been reached.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException If the first byte cannot be read for any reason
 other than end of file, or if the input stream has been closed, or if
 some other I/O error occurs.</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException If &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.</description>
					</attribute>
					<attribute name="@exception">
						<description>IndexOutOfBoundsException If &lt;code&gt;off&lt;/code&gt; is negative,
 &lt;code&gt;len&lt;/code&gt; is negative, or &lt;code&gt;len&lt;/code&gt; is greater than
 &lt;code&gt;b.length - off&lt;/code&gt;</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.InputStream#read()</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the buffer into which the data is read." fulltype="byte[]" type="byte" />
					<param name="off" comment="the start offset in array &lt;code&gt;b&lt;/code&gt;
                   at which the data is written." fulltype="int" type="int" />
					<param name="len" comment="the maximum number of bytes to read." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="If the first byte cannot be read for any reason
 other than end of file, or if the input stream has been closed, or if
 some other I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="skip" returncomment="the actual number of bytes skipped." fulltype="long" type="long">
				<comment>
					<description>Skips over and discards &lt;code&gt;n&lt;/code&gt; bytes of data from this input
 stream. The &lt;code&gt;skip&lt;/code&gt; method may, for a variety of reasons, end
 up skipping over some smaller number of bytes, possibly &lt;code&gt;0&lt;/code&gt;.
 This may result from any of a number of conditions; reaching end of file
 before &lt;code&gt;n&lt;/code&gt; bytes have been skipped is only one possibility.
 The actual number of bytes skipped is returned.  If &lt;code&gt;n&lt;/code&gt; is
 negative, no bytes are skipped.

 &lt;p&gt; The &lt;code&gt;skip&lt;/code&gt; method of this class creates a
 byte array and then repeatedly reads into it until &lt;code&gt;n&lt;/code&gt; bytes
 have been read or the end of the stream has been reached. Subclasses are
 encouraged to provide a more efficient implementation of this method.
 For instance, the implementation may depend on the ability to seek.</description>
					<attribute name="@param">
						<description>n   the number of bytes to be skipped.</description>
					</attribute>
					<attribute name="@return">
						<description>the actual number of bytes skipped.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if the stream does not support seek,
                          or if some other I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="n" comment="the number of bytes to be skipped." fulltype="long" type="long" />
				</params>
				<exceptions>
					<exception comment="if the stream does not support seek,
                          or if some other I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="available" returncomment="an estimate of the number of bytes that can be read (or skipped
             over) from this input stream without blocking or {@code 0} when
             it reaches the end of the input stream." fulltype="int" type="int">
				<comment>
					<description>Returns an estimate of the number of bytes that can be read (or
 skipped over) from this input stream without blocking by the next
 invocation of a method for this input stream. The next invocation
 might be the same thread or another thread.  A single read or skip of this
 many bytes will not block, but may read or skip fewer bytes.

 &lt;p&gt; Note that while some implementations of {@code InputStream} will return
 the total number of bytes in the stream, many will not.  It is
 never correct to use the return value of this method to allocate
 a buffer intended to hold all data in this stream.

 &lt;p&gt; A subclass&apos; implementation of this method may choose to throw an
 {@link IOException} if this input stream has been closed by
 invoking the {@link #close()} method.

 &lt;p&gt; The {@code available} method for class {@code InputStream} always
 returns {@code 0}.

 &lt;p&gt; This method should be overridden by subclasses.</description>
					<attribute name="@return">
						<description>an estimate of the number of bytes that can be read (or skipped
             over) from this input stream without blocking or {@code 0} when
             it reaches the end of the input stream.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException if an I/O error occurs.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="close" fulltype="void" type="void">
				<comment>
					<description>Closes this input stream and releases any system resources associated
 with the stream.

 &lt;p&gt; The &lt;code&gt;close&lt;/code&gt; method of &lt;code&gt;InputStream&lt;/code&gt; does
 nothing.</description>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="public" name="mark" fulltype="void" type="void">
				<comment>
					<description>Marks the current position in this input stream. A subsequent call to
 the &lt;code&gt;reset&lt;/code&gt; method repositions this stream at the last marked
 position so that subsequent reads re-read the same bytes.

 &lt;p&gt; The &lt;code&gt;readlimit&lt;/code&gt; arguments tells this input stream to
 allow that many bytes to be read before the mark position gets
 invalidated.

 &lt;p&gt; The general contract of &lt;code&gt;mark&lt;/code&gt; is that, if the method
 &lt;code&gt;markSupported&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, the stream somehow
 remembers all the bytes read after the call to &lt;code&gt;mark&lt;/code&gt; and
 stands ready to supply those same bytes again if and whenever the method
 &lt;code&gt;reset&lt;/code&gt; is called.  However, the stream is not required to
 remember any data at all if more than &lt;code&gt;readlimit&lt;/code&gt; bytes are
 read from the stream before &lt;code&gt;reset&lt;/code&gt; is called.

 &lt;p&gt; Marking a closed stream should not have any effect on the stream.

 &lt;p&gt; The &lt;code&gt;mark&lt;/code&gt; method of &lt;code&gt;InputStream&lt;/code&gt; does
 nothing.</description>
					<attribute name="@param">
						<description>readlimit   the maximum limit of bytes that can be read before
                      the mark position becomes invalid.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.InputStream#reset()</description>
					</attribute>
				</comment>
				<params>
					<param name="readlimit" comment="the maximum limit of bytes that can be read before
                      the mark position becomes invalid." fulltype="int" type="int" />
				</params>
			</method>
			<method synchronized="true" visibility="public" name="reset" fulltype="void" type="void">
				<comment>
					<description>Repositions this stream to the position at the time the
 &lt;code&gt;mark&lt;/code&gt; method was last called on this input stream.

 &lt;p&gt; The general contract of &lt;code&gt;reset&lt;/code&gt; is:

 &lt;p&gt;&lt;ul&gt;

 &lt;li&gt; If the method &lt;code&gt;markSupported&lt;/code&gt; returns
 &lt;code&gt;true&lt;/code&gt;, then:

     &lt;ul&gt;&lt;li&gt; If the method &lt;code&gt;mark&lt;/code&gt; has not been called since
     the stream was created, or the number of bytes read from the stream
     since &lt;code&gt;mark&lt;/code&gt; was last called is larger than the argument
     to &lt;code&gt;mark&lt;/code&gt; at that last call, then an
     &lt;code&gt;IOException&lt;/code&gt; might be thrown.

     &lt;li&gt; If such an &lt;code&gt;IOException&lt;/code&gt; is not thrown, then the
     stream is reset to a state such that all the bytes read since the
     most recent call to &lt;code&gt;mark&lt;/code&gt; (or since the start of the
     file, if &lt;code&gt;mark&lt;/code&gt; has not been called) will be resupplied
     to subsequent callers of the &lt;code&gt;read&lt;/code&gt; method, followed by
     any bytes that otherwise would have been the next input data as of
     the time of the call to &lt;code&gt;reset&lt;/code&gt;. &lt;/ul&gt;

 &lt;li&gt; If the method &lt;code&gt;markSupported&lt;/code&gt; returns
 &lt;code&gt;false&lt;/code&gt;, then:

     &lt;ul&gt;&lt;li&gt; The call to &lt;code&gt;reset&lt;/code&gt; may throw an
     &lt;code&gt;IOException&lt;/code&gt;.

     &lt;li&gt; If an &lt;code&gt;IOException&lt;/code&gt; is not thrown, then the stream
     is reset to a fixed state that depends on the particular type of the
     input stream and how it was created. The bytes that will be supplied
     to subsequent callers of the &lt;code&gt;read&lt;/code&gt; method depend on the
     particular type of the input stream. &lt;/ul&gt;&lt;/ul&gt;

 &lt;p&gt;The method &lt;code&gt;reset&lt;/code&gt; for class &lt;code&gt;InputStream&lt;/code&gt;
 does nothing except throw an &lt;code&gt;IOException&lt;/code&gt;.</description>
					<attribute name="@exception">
						<description>IOException  if this stream has not been marked or if the
               mark has been invalidated.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.InputStream#mark(int)</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.IOException</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if this stream has not been marked or if the
               mark has been invalidated." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="markSupported" returncomment="&lt;code&gt;true&lt;/code&gt; if this stream instance supports the mark
          and reset methods; &lt;code&gt;false&lt;/code&gt; otherwise." fulltype="boolean" type="boolean">
				<comment>
					<description>Tests if this input stream supports the &lt;code&gt;mark&lt;/code&gt; and
 &lt;code&gt;reset&lt;/code&gt; methods. Whether or not &lt;code&gt;mark&lt;/code&gt; and
 &lt;code&gt;reset&lt;/code&gt; are supported is an invariant property of a
 particular input stream instance. The &lt;code&gt;markSupported&lt;/code&gt; method
 of &lt;code&gt;InputStream&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</description>
					<attribute name="@return">
						<description>&lt;code&gt;true&lt;/code&gt; if this stream instance supports the mark
          and reset methods; &lt;code&gt;false&lt;/code&gt; otherwise.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.InputStream#mark(int)</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.InputStream#reset()</description>
					</attribute>
				</comment>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="FilterOutputStream" visibility="public" package="java.io" superclassfulltype="java.io.FilterOutputStream" fulltype="java.io.BufferedOutputStream" type="BufferedOutputStream">
		<comment>
			<description>The class implements a buffered output stream. By setting up such
 an output stream, an application can write bytes to the underlying
 output stream without necessarily causing a call to the underlying
 system for each byte written.</description>
			<attribute name="@author">
				<description>Arthur van Hoff</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.0</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="protected" name="buf" fulltype="byte[]" type="byte">
				<comment>
					<description>The internal buffer where data is stored.</description>
				</comment>
			</field>
			<field visibility="protected" name="count" fulltype="int" type="int">
				<comment>
					<description>The number of valid bytes in the buffer. This value is always
 in the range &lt;tt&gt;0&lt;/tt&gt; through &lt;tt&gt;buf.length&lt;/tt&gt;; elements
 &lt;tt&gt;buf[0]&lt;/tt&gt; through &lt;tt&gt;buf[count-1]&lt;/tt&gt; contain valid
 byte data.</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="public" name="BufferedOutputStream">
				<comment>
					<description>Creates a new buffered output stream to write data to the
 specified underlying output stream.</description>
					<attribute name="@param">
						<description>out   the underlying output stream.</description>
					</attribute>
				</comment>
				<params>
					<param name="out" comment="the underlying output stream." fulltype="java.io.OutputStream" type="OutputStream" />
				</params>
			</constructor>
			<constructor visibility="public" name="BufferedOutputStream">
				<comment>
					<description>Creates a new buffered output stream to write data to the
 specified underlying output stream with the specified buffer
 size.</description>
					<attribute name="@param">
						<description>out    the underlying output stream.</description>
					</attribute>
					<attribute name="@param">
						<description>size   the buffer size.</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if size &amp;lt;= 0.</description>
					</attribute>
				</comment>
				<params>
					<param name="out" comment="the underlying output stream." fulltype="java.io.OutputStream" type="OutputStream" />
					<param name="size" comment="the buffer size." fulltype="int" type="int" />
				</params>
			</constructor>
			<method visibility="private" name="flushBuffer" fulltype="void" type="void">
				<comment>
					<description>Flush the internal buffer</description>
				</comment>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes the specified byte to this buffered output stream.</description>
					<attribute name="@param">
						<description>b   the byte to be written.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the byte to be written." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes &lt;code&gt;len&lt;/code&gt; bytes from the specified byte array
 starting at offset &lt;code&gt;off&lt;/code&gt; to this buffered output stream.

 &lt;p&gt; Ordinarily this method stores bytes from the given array into this
 stream&apos;s buffer, flushing the buffer to the underlying output stream as
 needed.  If the requested length is at least as large as this stream&apos;s
 buffer, however, then this method will flush the buffer and write the
 bytes directly to the underlying output stream.  Thus redundant
 &lt;code&gt;BufferedOutputStream&lt;/code&gt;s will not copy data unnecessarily.</description>
					<attribute name="@param">
						<description>b     the data.</description>
					</attribute>
					<attribute name="@param">
						<description>off   the start offset in the data.</description>
					</attribute>
					<attribute name="@param">
						<description>len   the number of bytes to write.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the data." fulltype="byte[]" type="byte" />
					<param name="off" comment="the start offset in the data." fulltype="int" type="int" />
					<param name="len" comment="the number of bytes to write." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="public" name="flush" fulltype="void" type="void">
				<comment>
					<description>Flushes this buffered output stream. This forces any buffered
 output bytes to be written out to the underlying output stream.</description>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.FilterOutputStream#out</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="Reader" visibility="public" package="java.io" superclassfulltype="java.io.Reader" fulltype="java.io.InputStreamReader" type="InputStreamReader">
		<comment>
			<description>An InputStreamReader is a bridge from byte streams to character streams: It
 reads bytes and decodes them into characters using a specified {@link
 java.nio.charset.Charset &lt;code&gt;charset&lt;/code&gt;}.  The charset that it uses
 may be specified by name or may be given explicitly, or the platform&apos;s
 default charset may be accepted.

 &lt;p&gt; Each invocation of one of an InputStreamReader&apos;s read() methods may
 cause one or more bytes to be read from the underlying byte-input stream.
 To enable the efficient conversion of bytes to characters, more bytes may
 be read ahead from the underlying stream than are necessary to satisfy the
 current read operation.

 &lt;p&gt; For top efficiency, consider wrapping an InputStreamReader within a
 BufferedReader.  For example:

 &lt;pre&gt;
 BufferedReader in
   = new BufferedReader(new InputStreamReader(System.in));
 &lt;/pre&gt;</description>
			<attribute name="@see">
				<description>BufferedReader</description>
			</attribute>
			<attribute name="@see">
				<description>InputStream</description>
			</attribute>
			<attribute name="@see">
				<description>java.nio.charset.Charset</description>
			</attribute>
			<attribute name="@author">
				<description>Mark Reinhold</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.1</description>
			</attribute>
		</comment>
		<fields>
			<field final="true" visibility="private" name="sd" fulltype="sun.nio.cs.StreamDecoder" type="StreamDecoder" />
		</fields>
		<methods>
			<constructor visibility="public" name="InputStreamReader">
				<comment>
					<description>Creates an InputStreamReader that uses the default charset.</description>
					<attribute name="@param">
						<description>in   An InputStream</description>
					</attribute>
				</comment>
				<params>
					<param name="in" comment="An InputStream" fulltype="java.io.InputStream" type="InputStream" />
				</params>
			</constructor>
			<constructor visibility="public" name="InputStreamReader">
				<comment>
					<description>Creates an InputStreamReader that uses the named charset.</description>
					<attribute name="@param">
						<description>in
         An InputStream</description>
					</attribute>
					<attribute name="@param">
						<description>charsetName
         The name of a supported
         {@link java.nio.charset.Charset &lt;/code&gt;charset&lt;code&gt;}</description>
					</attribute>
					<attribute name="@exception">
						<description>UnsupportedEncodingException
             If the named charset is not supported</description>
					</attribute>
				</comment>
				<params>
					<param name="in" comment="An InputStream" fulltype="java.io.InputStream" type="InputStream" />
					<param name="charsetName" comment="The name of a supported
         {@link java.nio.charset.Charset &lt;/code&gt;charset&lt;code&gt;}" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception comment="If the named charset is not supported" fulltype="java.io.UnsupportedEncodingException" type="UnsupportedEncodingException" />
				</exceptions>
			</constructor>
			<constructor visibility="public" name="InputStreamReader">
				<comment>
					<description>Creates an InputStreamReader that uses the given charset. &lt;/p&gt;</description>
					<attribute name="@param">
						<description>in       An InputStream</description>
					</attribute>
					<attribute name="@param">
						<description>cs       A charset</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
					<attribute name="@spec">
						<description>JSR-51</description>
					</attribute>
				</comment>
				<params>
					<param name="in" comment="An InputStream" fulltype="java.io.InputStream" type="InputStream" />
					<param name="cs" comment="A charset" fulltype="java.nio.charset.Charset" type="Charset" />
				</params>
			</constructor>
			<constructor visibility="public" name="InputStreamReader">
				<comment>
					<description>Creates an InputStreamReader that uses the given charset decoder.  &lt;/p&gt;</description>
					<attribute name="@param">
						<description>in       An InputStream</description>
					</attribute>
					<attribute name="@param">
						<description>dec      A charset decoder</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
					<attribute name="@spec">
						<description>JSR-51</description>
					</attribute>
				</comment>
				<params>
					<param name="in" comment="An InputStream" fulltype="java.io.InputStream" type="InputStream" />
					<param name="dec" comment="A charset decoder" fulltype="java.nio.charset.CharsetDecoder" type="CharsetDecoder" />
				</params>
			</constructor>
			<method visibility="public" name="getEncoding" returncomment="The historical name of this encoding, or
         &lt;code&gt;null&lt;/code&gt; if the stream has been closed" fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the name of the character encoding being used by this stream.

 &lt;p&gt; If the encoding has an historical name then that name is returned;
 otherwise the encoding&apos;s canonical name is returned.

 &lt;p&gt; If this instance was created with the {@link
 #InputStreamReader(InputStream, String)} constructor then the returned
 name, being unique for the encoding, may differ from the name passed to
 the constructor. This method will return &lt;code&gt;null&lt;/code&gt; if the
 stream has been closed.
 &lt;/p&gt;</description>
					<attribute name="@return">
						<description>The historical name of this encoding, or
         &lt;code&gt;null&lt;/code&gt; if the stream has been closed</description>
					</attribute>
					<attribute name="@see">
						<description>java.nio.charset.Charset</description>
					</attribute>
					<attribute name="@revised">
						<description>1.4</description>
					</attribute>
					<attribute name="@spec">
						<description>JSR-51</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="read" returncomment="The character read, or -1 if the end of the stream has been
         reached" fulltype="int" type="int">
				<comment>
					<description>Reads a single character.</description>
					<attribute name="@return">
						<description>The character read, or -1 if the end of the stream has been
         reached</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  If an I/O error occurs</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="read" returncomment="The number of characters read, or -1 if the end of the
             stream has been reached" fulltype="int" type="int">
				<comment>
					<description>Reads characters into a portion of an array.</description>
					<attribute name="@param">
						<description>cbuf     Destination buffer</description>
					</attribute>
					<attribute name="@param">
						<description>offset   Offset at which to start storing characters</description>
					</attribute>
					<attribute name="@param">
						<description>length   Maximum number of characters to read</description>
					</attribute>
					<attribute name="@return">
						<description>The number of characters read, or -1 if the end of the
             stream has been reached</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  If an I/O error occurs</description>
					</attribute>
				</comment>
				<params>
					<param name="cbuf" comment="Destination buffer" fulltype="char[]" type="char" />
					<param name="offset" comment="Offset at which to start storing characters" fulltype="int" type="int" />
					<param name="length" comment="Maximum number of characters to read" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="ready" fulltype="boolean" type="boolean">
				<comment>
					<description>Tells whether this stream is ready to be read.  An InputStreamReader is
 ready if its input buffer is not empty, or if bytes are available to be
 read from the underlying byte stream.</description>
					<attribute name="@exception">
						<description>IOException  If an I/O error occurs</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If an I/O error occurs" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="close" fulltype="void" type="void">
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="ObjectStreamException" visibility="public" package="java.io" serializable="true" superclassfulltype="java.io.ObjectStreamException" fulltype="java.io.OptionalDataException" type="OptionalDataException">
		<comment>
			<description>Exception indicating the failure of an object read operation due to
 unread primitive data, or the end of data belonging to a serialized
 object in the stream.  This exception may be thrown in two cases:

 &lt;ul&gt;
   &lt;li&gt;An attempt was made to read an object when the next element in the
       stream is primitive data.  In this case, the OptionalDataException&apos;s
       length field is set to the number of bytes of primitive data
       immediately readable from the stream, and the eof field is set to
       false.

   &lt;li&gt;An attempt was made to read past the end of data consumable by a
       class-defined readObject or readExternal method.  In this case, the
       OptionalDataException&apos;s eof field is set to true, and the length field
       is set to 0.
 &lt;/ul&gt;</description>
			<attribute name="@author">
				<description>unascribed</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.1</description>
			</attribute>
		</comment>
		<fields>
			<field final="true" static="true" const="-8011121865681257820" visibility="private" name="serialVersionUID" constexpr="-8011121865681257820L" fulltype="long" type="long" />
			<field visibility="public" name="length" fulltype="int" type="int">
				<comment>
					<description>The number of bytes of primitive data available to be read
 in the current buffer.</description>
					<attribute name="@serial" />
				</comment>
			</field>
			<field visibility="public" name="eof" fulltype="boolean" type="boolean">
				<comment>
					<description>True if there is no more data in the buffered part of the stream.</description>
					<attribute name="@serial" />
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="package-private" name="OptionalDataException">
				<params>
					<param name="len" fulltype="int" type="int" />
				</params>
			</constructor>
			<constructor visibility="package-private" name="OptionalDataException">
				<params>
					<param name="end" fulltype="boolean" type="boolean" />
				</params>
			</constructor>
		</methods>
	</jelclass>
	<jelclass superclass="InputStream" visibility="public" package="java.io" superclassfulltype="java.io.InputStream" fulltype="java.io.PipedInputStream" type="PipedInputStream">
		<comment>
			<description>A piped input stream should be connected
 to a piped output stream; the piped  input
 stream then provides whatever data bytes
 are written to the piped output  stream.
 Typically, data is read from a &lt;code&gt;PipedInputStream&lt;/code&gt;
 object by one thread  and data is written
 to the corresponding &lt;code&gt;PipedOutputStream&lt;/code&gt;
 by some  other thread. Attempting to use
 both objects from a single thread is not
 recommended, as it may deadlock the thread.
 The piped input stream contains a buffer,
 decoupling read operations from write operations,
 within limits.
 A pipe is said to be &lt;a name=BROKEN&gt; &lt;i&gt;broken&lt;/i&gt; &lt;/a&gt; if a
 thread that was providing data bytes to the connected
 piped output stream is no longer alive.</description>
			<attribute name="@author">
				<description>James Gosling</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.PipedOutputStream</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.0</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="package-private" name="closedByWriter" fulltype="boolean" type="boolean" />
			<field volatile="true" visibility="package-private" name="closedByReader" fulltype="boolean" type="boolean" />
			<field visibility="package-private" name="connected" fulltype="boolean" type="boolean" />
			<field visibility="package-private" name="readSide" fulltype="java.lang.Thread" type="Thread" />
			<field visibility="package-private" name="writeSide" fulltype="java.lang.Thread" type="Thread" />
			<field final="true" static="true" const="1024" visibility="private" name="DEFAULT_PIPE_SIZE" constexpr="1024" fulltype="int" type="int" />
			<field final="true" static="true" const="1024" visibility="protected" name="PIPE_SIZE" constexpr="1024" fulltype="int" type="int">
				<comment>
					<description>The default size of the pipe&apos;s circular input buffer.</description>
					<attribute name="@since">
						<description>JDK1.1</description>
					</attribute>
				</comment>
			</field>
			<field visibility="protected" name="buffer" fulltype="byte[]" type="byte">
				<comment>
					<description>The circular buffer into which incoming data is placed.</description>
					<attribute name="@since">
						<description>JDK1.1</description>
					</attribute>
				</comment>
			</field>
			<field visibility="protected" name="in" fulltype="int" type="int">
				<comment>
					<description>The index of the position in the circular buffer at which the
 next byte of data will be stored when received from the connected
 piped output stream. &lt;code&gt;in&amp;lt;0&lt;/code&gt; implies the buffer is empty,
 &lt;code&gt;in==out&lt;/code&gt; implies the buffer is full</description>
					<attribute name="@since">
						<description>JDK1.1</description>
					</attribute>
				</comment>
			</field>
			<field visibility="protected" name="out" fulltype="int" type="int">
				<comment>
					<description>The index of the position in the circular buffer at which the next
 byte of data will be read by this piped input stream.</description>
					<attribute name="@since">
						<description>JDK1.1</description>
					</attribute>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="public" name="PipedInputStream">
				<comment>
					<description>Creates a &lt;code&gt;PipedInputStream&lt;/code&gt; so
 that it is connected to the piped output
 stream &lt;code&gt;src&lt;/code&gt;. Data bytes written
 to &lt;code&gt;src&lt;/code&gt; will then be  available
 as input from this stream.</description>
					<attribute name="@param">
						<description>src   the stream to connect to.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="src" comment="the stream to connect to." fulltype="java.io.PipedOutputStream" type="PipedOutputStream" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</constructor>
			<constructor visibility="public" name="PipedInputStream">
				<comment>
					<description>Creates a &lt;code&gt;PipedInputStream&lt;/code&gt; so that it is
 connected to the piped output stream
 &lt;code&gt;src&lt;/code&gt; and uses the specified pipe size for
 the pipe&apos;s buffer.
 Data bytes written to &lt;code&gt;src&lt;/code&gt; will then
 be available as input from this stream.</description>
					<attribute name="@param">
						<description>src   the stream to connect to.</description>
					</attribute>
					<attribute name="@param">
						<description>pipeSize the size of the pipe&apos;s buffer.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if &lt;code&gt;pipeSize &lt;= 0&lt;/code&gt;.</description>
					</attribute>
					<attribute name="@since">
						<description>1.6</description>
					</attribute>
				</comment>
				<params>
					<param name="src" comment="the stream to connect to." fulltype="java.io.PipedOutputStream" type="PipedOutputStream" />
					<param name="pipeSize" comment="the size of the pipe&apos;s buffer." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</constructor>
			<constructor visibility="public" name="PipedInputStream">
				<comment>
					<description>Creates a &lt;code&gt;PipedInputStream&lt;/code&gt; so
 that it is not yet {@linkplain #connect(java.io.PipedOutputStream)
 connected}.
 It must be {@linkplain java.io.PipedOutputStream#connect(
 java.io.PipedInputStream) connected} to a
 &lt;code&gt;PipedOutputStream&lt;/code&gt; before being used.</description>
				</comment>
			</constructor>
			<constructor visibility="public" name="PipedInputStream">
				<comment>
					<description>Creates a &lt;code&gt;PipedInputStream&lt;/code&gt; so that it is not yet
 {@linkplain #connect(java.io.PipedOutputStream) connected} and
 uses the specified pipe size for the pipe&apos;s buffer.
 It must be {@linkplain java.io.PipedOutputStream#connect(
 java.io.PipedInputStream)
 connected} to a &lt;code&gt;PipedOutputStream&lt;/code&gt; before being used.</description>
					<attribute name="@param">
						<description>pipeSize the size of the pipe&apos;s buffer.</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if &lt;code&gt;pipeSize &lt;= 0&lt;/code&gt;.</description>
					</attribute>
					<attribute name="@since">
						<description>1.6</description>
					</attribute>
				</comment>
				<params>
					<param name="pipeSize" comment="the size of the pipe&apos;s buffer." fulltype="int" type="int" />
				</params>
			</constructor>
			<method visibility="private" name="initPipe" fulltype="void" type="void">
				<params>
					<param name="pipeSize" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="connect" fulltype="void" type="void">
				<comment>
					<description>Causes this piped input stream to be connected
 to the piped  output stream &lt;code&gt;src&lt;/code&gt;.
 If this object is already connected to some
 other piped output  stream, an &lt;code&gt;IOException&lt;/code&gt;
 is thrown.
 &lt;p&gt;
 If &lt;code&gt;src&lt;/code&gt; is an
 unconnected piped output stream and &lt;code&gt;snk&lt;/code&gt;
 is an unconnected piped input stream, they
 may be connected by either the call:
 &lt;p&gt;
 &lt;pre&gt;&lt;code&gt;snk.connect(src)&lt;/code&gt; &lt;/pre&gt;
 &lt;p&gt;
 or the call:
 &lt;p&gt;
 &lt;pre&gt;&lt;code&gt;src.connect(snk)&lt;/code&gt; &lt;/pre&gt;
 &lt;p&gt;
 The two
 calls have the same effect.</description>
					<attribute name="@param">
						<description>src   The piped output stream to connect to.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="src" comment="The piped output stream to connect to." fulltype="java.io.PipedOutputStream" type="PipedOutputStream" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="protected" name="receive" fulltype="void" type="void">
				<comment>
					<description>Receives a byte of data.  This method will block if no input is
 available.</description>
					<attribute name="@param">
						<description>b the byte being received</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException If the pipe is &lt;a href=#BROKEN&gt; &lt;code&gt;broken&lt;/code&gt;&lt;/a&gt;,
          {@link #connect(java.io.PipedOutputStream) unconnected},
          closed, or if an I/O error occurs.</description>
					</attribute>
					<attribute name="@since">
						<description>JDK1.1</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the byte being received" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="If the pipe is &lt;a href=#BROKEN&gt; &lt;code&gt;broken&lt;/code&gt;&lt;/a&gt;,
          {@link #connect(java.io.PipedOutputStream) unconnected},
          closed, or if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="package-private" name="receive" fulltype="void" type="void">
				<comment>
					<description>Receives data into an array of bytes.  This method will
 block until some input is available.</description>
					<attribute name="@param">
						<description>b the buffer into which the data is received</description>
					</attribute>
					<attribute name="@param">
						<description>off the start offset of the data</description>
					</attribute>
					<attribute name="@param">
						<description>len the maximum number of bytes received</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException If the pipe is &lt;a href=#BROKEN&gt; broken&lt;/a&gt;,
           {@link #connect(java.io.PipedOutputStream) unconnected},
           closed,or if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the buffer into which the data is received" fulltype="byte[]" type="byte" />
					<param name="off" comment="the start offset of the data" fulltype="int" type="int" />
					<param name="len" comment="the maximum number of bytes received" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="If the pipe is &lt;a href=#BROKEN&gt; broken&lt;/a&gt;,
           {@link #connect(java.io.PipedOutputStream) unconnected},
           closed,or if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="checkStateForReceive" fulltype="void" type="void">
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="awaitSpace" fulltype="void" type="void">
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="package-private" name="receivedLast" fulltype="void" type="void">
				<comment>
					<description>Notifies all waiting threads that the last byte of data has been
 received.</description>
				</comment>
			</method>
			<method synchronized="true" visibility="public" name="read" returncomment="the next byte of data, or &lt;code&gt;-1&lt;/code&gt; if the end of the
             stream is reached." fulltype="int" type="int">
				<comment>
					<description>Reads the next byte of data from this piped input stream. The
 value byte is returned as an &lt;code&gt;int&lt;/code&gt; in the range
 &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;255&lt;/code&gt;.
 This method blocks until input data is available, the end of the
 stream is detected, or an exception is thrown.</description>
					<attribute name="@return">
						<description>the next byte of data, or &lt;code&gt;-1&lt;/code&gt; if the end of the
             stream is reached.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if the pipe is
           {@link #connect(java.io.PipedOutputStream) unconnected},
           &lt;a href=#BROKEN&gt; &lt;code&gt;broken&lt;/code&gt;&lt;/a&gt;, closed,
           or if an I/O error occurs.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if the pipe is
           {@link #connect(java.io.PipedOutputStream) unconnected},
           &lt;a href=#BROKEN&gt; &lt;code&gt;broken&lt;/code&gt;&lt;/a&gt;, closed,
           or if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="public" name="read" returncomment="the total number of bytes read into the buffer, or
             &lt;code&gt;-1&lt;/code&gt; if there is no more data because the end of
             the stream has been reached." fulltype="int" type="int">
				<comment>
					<description>Reads up to &lt;code&gt;len&lt;/code&gt; bytes of data from this piped input
 stream into an array of bytes. Less than &lt;code&gt;len&lt;/code&gt; bytes
 will be read if the end of the data stream is reached or if
 &lt;code&gt;len&lt;/code&gt; exceeds the pipe&apos;s buffer size.
 If &lt;code&gt;len &lt;/code&gt; is zero, then no bytes are read and 0 is returned;
 otherwise, the method blocks until at least 1 byte of input is
 available, end of the stream has been detected, or an exception is
 thrown.</description>
					<attribute name="@param">
						<description>b     the buffer into which the data is read.</description>
					</attribute>
					<attribute name="@param">
						<description>off   the start offset in the destination array &lt;code&gt;b&lt;/code&gt;</description>
					</attribute>
					<attribute name="@param">
						<description>len   the maximum number of bytes read.</description>
					</attribute>
					<attribute name="@return">
						<description>the total number of bytes read into the buffer, or
             &lt;code&gt;-1&lt;/code&gt; if there is no more data because the end of
             the stream has been reached.</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException If &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.</description>
					</attribute>
					<attribute name="@exception">
						<description>IndexOutOfBoundsException If &lt;code&gt;off&lt;/code&gt; is negative,
 &lt;code&gt;len&lt;/code&gt; is negative, or &lt;code&gt;len&lt;/code&gt; is greater than
 &lt;code&gt;b.length - off&lt;/code&gt;</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException if the pipe is &lt;a href=#BROKEN&gt; &lt;code&gt;broken&lt;/code&gt;&lt;/a&gt;,
           {@link #connect(java.io.PipedOutputStream) unconnected},
           closed, or if an I/O error occurs.</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the buffer into which the data is read." fulltype="byte[]" type="byte" />
					<param name="off" comment="the start offset in the destination array &lt;code&gt;b&lt;/code&gt;" fulltype="int" type="int" />
					<param name="len" comment="the maximum number of bytes read." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if the pipe is &lt;a href=#BROKEN&gt; &lt;code&gt;broken&lt;/code&gt;&lt;/a&gt;,
           {@link #connect(java.io.PipedOutputStream) unconnected},
           closed, or if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="public" name="available" returncomment="the number of bytes that can be read from this input stream
         without blocking, or {@code 0} if this input stream has been
         closed by invoking its {@link #close()} method, or if the pipe
         is {@link #connect(java.io.PipedOutputStream) unconnected}, or
          &lt;a href=#BROKEN&gt; &lt;code&gt;broken&lt;/code&gt;&lt;/a&gt;." fulltype="int" type="int">
				<comment>
					<description>Returns the number of bytes that can be read from this input
 stream without blocking.</description>
					<attribute name="@return">
						<description>the number of bytes that can be read from this input stream
         without blocking, or {@code 0} if this input stream has been
         closed by invoking its {@link #close()} method, or if the pipe
         is {@link #connect(java.io.PipedOutputStream) unconnected}, or
          &lt;a href=#BROKEN&gt; &lt;code&gt;broken&lt;/code&gt;&lt;/a&gt;.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
					<attribute name="@since">
						<description>JDK1.0.2</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="close" fulltype="void" type="void">
				<comment>
					<description>Closes this piped input stream and releases any system resources
 associated with the stream.</description>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="IOException" visibility="public" package="java.io" serializable="true" superclassfulltype="java.io.IOException" fulltype="java.io.CharConversionException" type="CharConversionException">
		<comment>
			<description>Base class for character conversion exceptions.</description>
			<attribute name="@author">
				<description>Asmus Freytag</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.1</description>
			</attribute>
		</comment>
		<methods>
			<constructor visibility="public" name="CharConversionException">
				<comment>
					<description>This provides no detailed message.</description>
				</comment>
			</constructor>
			<constructor visibility="public" name="CharConversionException">
				<comment>
					<description>This provides a detailed message.</description>
					<attribute name="@param">
						<description>s the detailed message associated with the exception.</description>
					</attribute>
				</comment>
				<params>
					<param name="s" comment="the detailed message associated with the exception." fulltype="java.lang.String" type="String" />
				</params>
			</constructor>
		</methods>
	</jelclass>
	<jelclass superclass="Writer" visibility="public" package="java.io" superclassfulltype="java.io.Writer" fulltype="java.io.StringWriter" type="StringWriter">
		<comment>
			<description>A character stream that collects its output in a string buffer, which can
 then be used to construct a string.
 &lt;p&gt;
 Closing a &lt;tt&gt;StringWriter&lt;/tt&gt; has no effect. The methods in this class
 can be called after the stream has been closed without generating an
 &lt;tt&gt;IOException&lt;/tt&gt;.</description>
			<attribute name="@author">
				<description>Mark Reinhold</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.1</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="private" name="buf" fulltype="java.lang.StringBuffer" type="StringBuffer" />
		</fields>
		<methods>
			<constructor visibility="public" name="StringWriter">
				<comment>
					<description>Create a new string writer using the default initial string-buffer
 size.</description>
				</comment>
			</constructor>
			<constructor visibility="public" name="StringWriter">
				<comment>
					<description>Create a new string writer using the specified initial string-buffer
 size.</description>
					<attribute name="@param">
						<description>initialSize
        The number of &lt;tt&gt;char&lt;/tt&gt; values that will fit into this buffer
        before it is automatically expanded</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException
         If &lt;tt&gt;initialSize&lt;/tt&gt; is negative</description>
					</attribute>
				</comment>
				<params>
					<param name="initialSize" comment="The number of &lt;tt&gt;char&lt;/tt&gt; values that will fit into this buffer
        before it is automatically expanded" fulltype="int" type="int" />
				</params>
			</constructor>
			<method visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Write a single character.</description>
				</comment>
				<params>
					<param name="c" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Write a portion of an array of characters.</description>
					<attribute name="@param">
						<description>cbuf  Array of characters</description>
					</attribute>
					<attribute name="@param">
						<description>off   Offset from which to start writing characters</description>
					</attribute>
					<attribute name="@param">
						<description>len   Number of characters to write</description>
					</attribute>
				</comment>
				<params>
					<param name="cbuf" comment="Array of characters" fulltype="char[]" type="char" />
					<param name="off" comment="Offset from which to start writing characters" fulltype="int" type="int" />
					<param name="len" comment="Number of characters to write" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Write a string.</description>
				</comment>
				<params>
					<param name="str" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Write a portion of a string.</description>
					<attribute name="@param">
						<description>str  String to be written</description>
					</attribute>
					<attribute name="@param">
						<description>off  Offset from which to start writing characters</description>
					</attribute>
					<attribute name="@param">
						<description>len  Number of characters to write</description>
					</attribute>
				</comment>
				<params>
					<param name="str" comment="String to be written" fulltype="java.lang.String" type="String" />
					<param name="off" comment="Offset from which to start writing characters" fulltype="int" type="int" />
					<param name="len" comment="Number of characters to write" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="append" returncomment="This writer" fulltype="java.io.StringWriter" type="StringWriter">
				<comment>
					<description>Appends the specified character sequence to this writer.

 &lt;p&gt; An invocation of this method of the form &lt;tt&gt;out.append(csq)&lt;/tt&gt;
 behaves in exactly the same way as the invocation

 &lt;pre&gt;
     out.write(csq.toString()) &lt;/pre&gt;

 &lt;p&gt; Depending on the specification of &lt;tt&gt;toString&lt;/tt&gt; for the
 character sequence &lt;tt&gt;csq&lt;/tt&gt;, the entire sequence may not be
 appended. For instance, invoking the &lt;tt&gt;toString&lt;/tt&gt; method of a
 character buffer will return a subsequence whose content depends upon
 the buffer&apos;s position and limit.</description>
					<attribute name="@param">
						<description>csq
         The character sequence to append.  If &lt;tt&gt;csq&lt;/tt&gt; is
         &lt;tt&gt;null&lt;/tt&gt;, then the four characters &lt;tt&gt;&quot;null&quot;&lt;/tt&gt; are
         appended to this writer.</description>
					</attribute>
					<attribute name="@return">
						<description>This writer</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
				<params>
					<param name="csq" comment="The character sequence to append.  If &lt;tt&gt;csq&lt;/tt&gt; is
         &lt;tt&gt;null&lt;/tt&gt;, then the four characters &lt;tt&gt;&quot;null&quot;&lt;/tt&gt; are
         appended to this writer." fulltype="java.lang.CharSequence" type="CharSequence" />
				</params>
			</method>
			<method visibility="public" name="append" returncomment="This writer" fulltype="java.io.StringWriter" type="StringWriter">
				<comment>
					<description>Appends a subsequence of the specified character sequence to this writer.

 &lt;p&gt; An invocation of this method of the form &lt;tt&gt;out.append(csq, start,
 end)&lt;/tt&gt; when &lt;tt&gt;csq&lt;/tt&gt; is not &lt;tt&gt;null&lt;/tt&gt;, behaves in
 exactly the same way as the invocation

 &lt;pre&gt;
     out.write(csq.subSequence(start, end).toString()) &lt;/pre&gt;</description>
					<attribute name="@param">
						<description>csq
         The character sequence from which a subsequence will be
         appended.  If &lt;tt&gt;csq&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;, then characters
         will be appended as if &lt;tt&gt;csq&lt;/tt&gt; contained the four
         characters &lt;tt&gt;&quot;null&quot;&lt;/tt&gt;.</description>
					</attribute>
					<attribute name="@param">
						<description>start
         The index of the first character in the subsequence</description>
					</attribute>
					<attribute name="@param">
						<description>end
         The index of the character following the last character in the
         subsequence</description>
					</attribute>
					<attribute name="@return">
						<description>This writer</description>
					</attribute>
					<attribute name="@throws">
						<description>IndexOutOfBoundsException
          If &lt;tt&gt;start&lt;/tt&gt; or &lt;tt&gt;end&lt;/tt&gt; are negative, &lt;tt&gt;start&lt;/tt&gt;
          is greater than &lt;tt&gt;end&lt;/tt&gt;, or &lt;tt&gt;end&lt;/tt&gt; is greater than
          &lt;tt&gt;csq.length()&lt;/tt&gt;</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
				<params>
					<param name="csq" comment="The character sequence from which a subsequence will be
         appended.  If &lt;tt&gt;csq&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;, then characters
         will be appended as if &lt;tt&gt;csq&lt;/tt&gt; contained the four
         characters &lt;tt&gt;&quot;null&quot;&lt;/tt&gt;." fulltype="java.lang.CharSequence" type="CharSequence" />
					<param name="start" comment="The index of the first character in the subsequence" fulltype="int" type="int" />
					<param name="end" comment="The index of the character following the last character in the
         subsequence" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="append" returncomment="This writer" fulltype="java.io.StringWriter" type="StringWriter">
				<comment>
					<description>Appends the specified character to this writer.

 &lt;p&gt; An invocation of this method of the form &lt;tt&gt;out.append(c)&lt;/tt&gt;
 behaves in exactly the same way as the invocation

 &lt;pre&gt;
     out.write(c) &lt;/pre&gt;</description>
					<attribute name="@param">
						<description>c
         The 16-bit character to append</description>
					</attribute>
					<attribute name="@return">
						<description>This writer</description>
					</attribute>
					<attribute name="@since">
						<description>1.5</description>
					</attribute>
				</comment>
				<params>
					<param name="c" comment="The 16-bit character to append" fulltype="char" type="char" />
				</params>
			</method>
			<method visibility="public" name="toString" fulltype="java.lang.String" type="String">
				<comment>
					<description>Return the buffer&apos;s current value as a string.</description>
				</comment>
			</method>
			<method visibility="public" name="getBuffer" returncomment="StringBuffer holding the current buffer value." fulltype="java.lang.StringBuffer" type="StringBuffer">
				<comment>
					<description>Return the string buffer itself.</description>
					<attribute name="@return">
						<description>StringBuffer holding the current buffer value.</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="flush" fulltype="void" type="void">
				<comment>
					<description>Flush the stream.</description>
				</comment>
			</method>
			<method visibility="public" name="close" fulltype="void" type="void">
				<comment>
					<description>Closing a &lt;tt&gt;StringWriter&lt;/tt&gt; has no effect. The methods in this
 class can be called after the stream has been closed without generating
 an &lt;tt&gt;IOException&lt;/tt&gt;.</description>
				</comment>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="FilterInputStream" visibility="public" package="java.io" superclassfulltype="java.io.FilterInputStream" fulltype="java.io.PushbackInputStream" type="PushbackInputStream">
		<comment>
			<description>A &lt;code&gt;PushbackInputStream&lt;/code&gt; adds
 functionality to another input stream, namely
 the  ability to &quot;push back&quot; or &quot;unread&quot;
 one byte. This is useful in situations where
 it is  convenient for a fragment of code
 to read an indefinite number of data bytes
 that  are delimited by a particular byte
 value; after reading the terminating byte,
 the  code fragment can &quot;unread&quot; it, so that
 the next read operation on the input stream
 will reread the byte that was pushed back.
 For example, bytes representing the  characters
 constituting an identifier might be terminated
 by a byte representing an  operator character;
 a method whose job is to read just an identifier
 can read until it  sees the operator and
 then push the operator back to be re-read.</description>
			<attribute name="@author">
				<description>David Connelly</description>
			</attribute>
			<attribute name="@author">
				<description>Jonathan Payne</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.0</description>
			</attribute>
		</comment>
		<fields>
			<field visibility="protected" name="buf" fulltype="byte[]" type="byte">
				<comment>
					<description>The pushback buffer.</description>
					<attribute name="@since">
						<description>JDK1.1</description>
					</attribute>
				</comment>
			</field>
			<field visibility="protected" name="pos" fulltype="int" type="int">
				<comment>
					<description>The position within the pushback buffer from which the next byte will
 be read.  When the buffer is empty, &lt;code&gt;pos&lt;/code&gt; is equal to
 &lt;code&gt;buf.length&lt;/code&gt;; when the buffer is full, &lt;code&gt;pos&lt;/code&gt; is
 equal to zero.</description>
					<attribute name="@since">
						<description>JDK1.1</description>
					</attribute>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="public" name="PushbackInputStream">
				<comment>
					<description>Creates a &lt;code&gt;PushbackInputStream&lt;/code&gt;
 with a pushback buffer of the specified &lt;code&gt;size&lt;/code&gt;,
 and saves its  argument, the input stream
 &lt;code&gt;in&lt;/code&gt;, for later use. Initially,
 there is no pushed-back byte  (the field
 &lt;code&gt;pushBack&lt;/code&gt; is initialized to
 &lt;code&gt;-1&lt;/code&gt;).</description>
					<attribute name="@param">
						<description>in    the input stream from which bytes will be read.</description>
					</attribute>
					<attribute name="@param">
						<description>size  the size of the pushback buffer.</description>
					</attribute>
					<attribute name="@exception">
						<description>IllegalArgumentException if size is &lt;= 0</description>
					</attribute>
					<attribute name="@since">
						<description>JDK1.1</description>
					</attribute>
				</comment>
				<params>
					<param name="in" comment="the input stream from which bytes will be read." fulltype="java.io.InputStream" type="InputStream" />
					<param name="size" comment="the size of the pushback buffer." fulltype="int" type="int" />
				</params>
			</constructor>
			<constructor visibility="public" name="PushbackInputStream">
				<comment>
					<description>Creates a &lt;code&gt;PushbackInputStream&lt;/code&gt;
 and saves its  argument, the input stream
 &lt;code&gt;in&lt;/code&gt;, for later use. Initially,
 there is no pushed-back byte  (the field
 &lt;code&gt;pushBack&lt;/code&gt; is initialized to
 &lt;code&gt;-1&lt;/code&gt;).</description>
					<attribute name="@param">
						<description>in   the input stream from which bytes will be read.</description>
					</attribute>
				</comment>
				<params>
					<param name="in" comment="the input stream from which bytes will be read." fulltype="java.io.InputStream" type="InputStream" />
				</params>
			</constructor>
			<method visibility="private" name="ensureOpen" fulltype="void" type="void">
				<comment>
					<description>Check to make sure that this stream has not been closed</description>
				</comment>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="read" returncomment="the next byte of data, or &lt;code&gt;-1&lt;/code&gt; if the end of the
             stream has been reached." fulltype="int" type="int">
				<comment>
					<description>Reads the next byte of data from this input stream. The value
 byte is returned as an &lt;code&gt;int&lt;/code&gt; in the range
 &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;255&lt;/code&gt;. If no byte is available
 because the end of the stream has been reached, the value
 &lt;code&gt;-1&lt;/code&gt; is returned. This method blocks until input data
 is available, the end of the stream is detected, or an exception
 is thrown.

 &lt;p&gt; This method returns the most recently pushed-back byte, if there is
 one, and otherwise calls the &lt;code&gt;read&lt;/code&gt; method of its underlying
 input stream and returns whatever value that method returns.</description>
					<attribute name="@return">
						<description>the next byte of data, or &lt;code&gt;-1&lt;/code&gt; if the end of the
             stream has been reached.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if this input stream has been closed by
             invoking its {@link #close()} method,
             or an I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.InputStream#read()</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if this input stream has been closed by
             invoking its {@link #close()} method,
             or an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="read" returncomment="the total number of bytes read into the buffer, or
             &lt;code&gt;-1&lt;/code&gt; if there is no more data because the end of
             the stream has been reached." fulltype="int" type="int">
				<comment>
					<description>Reads up to &lt;code&gt;len&lt;/code&gt; bytes of data from this input stream into
 an array of bytes.  This method first reads any pushed-back bytes; after
 that, if fewer than &lt;code&gt;len&lt;/code&gt; bytes have been read then it
 reads from the underlying input stream. If &lt;code&gt;len&lt;/code&gt; is not zero, the method
 blocks until at least 1 byte of input is available; otherwise, no
 bytes are read and &lt;code&gt;0&lt;/code&gt; is returned.</description>
					<attribute name="@param">
						<description>b     the buffer into which the data is read.</description>
					</attribute>
					<attribute name="@param">
						<description>off   the start offset in the destination array &lt;code&gt;b&lt;/code&gt;</description>
					</attribute>
					<attribute name="@param">
						<description>len   the maximum number of bytes read.</description>
					</attribute>
					<attribute name="@return">
						<description>the total number of bytes read into the buffer, or
             &lt;code&gt;-1&lt;/code&gt; if there is no more data because the end of
             the stream has been reached.</description>
					</attribute>
					<attribute name="@exception">
						<description>NullPointerException If &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.</description>
					</attribute>
					<attribute name="@exception">
						<description>IndexOutOfBoundsException If &lt;code&gt;off&lt;/code&gt; is negative,
 &lt;code&gt;len&lt;/code&gt; is negative, or &lt;code&gt;len&lt;/code&gt; is greater than
 &lt;code&gt;b.length - off&lt;/code&gt;</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if this input stream has been closed by
             invoking its {@link #close()} method,
             or an I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.InputStream#read(byte[], int, int)</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the buffer into which the data is read." fulltype="byte[]" type="byte" />
					<param name="off" comment="the start offset in the destination array &lt;code&gt;b&lt;/code&gt;" fulltype="int" type="int" />
					<param name="len" comment="the maximum number of bytes read." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if this input stream has been closed by
             invoking its {@link #close()} method,
             or an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="unread" fulltype="void" type="void">
				<comment>
					<description>Pushes back a byte by copying it to the front of the pushback buffer.
 After this method returns, the next byte to be read will have the value
 &lt;code&gt;(byte)b&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>b   the &lt;code&gt;int&lt;/code&gt; value whose low-order
                  byte is to be pushed back.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException If there is not enough room in the pushback
            buffer for the byte, or this input stream has been closed by
            invoking its {@link #close()} method.</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the &lt;code&gt;int&lt;/code&gt; value whose low-order
                  byte is to be pushed back." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="If there is not enough room in the pushback
            buffer for the byte, or this input stream has been closed by
            invoking its {@link #close()} method." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="unread" fulltype="void" type="void">
				<comment>
					<description>Pushes back a portion of an array of bytes by copying it to the front
 of the pushback buffer.  After this method returns, the next byte to be
 read will have the value &lt;code&gt;b[off]&lt;/code&gt;, the byte after that will
 have the value &lt;code&gt;b[off+1]&lt;/code&gt;, and so forth.</description>
					<attribute name="@param">
						<description>b the byte array to push back.</description>
					</attribute>
					<attribute name="@param">
						<description>off the start offset of the data.</description>
					</attribute>
					<attribute name="@param">
						<description>len the number of bytes to push back.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException If there is not enough room in the pushback
            buffer for the specified number of bytes,
            or this input stream has been closed by
            invoking its {@link #close()} method.</description>
					</attribute>
					<attribute name="@since">
						<description>JDK1.1</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the byte array to push back." fulltype="byte[]" type="byte" />
					<param name="off" comment="the start offset of the data." fulltype="int" type="int" />
					<param name="len" comment="the number of bytes to push back." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="If there is not enough room in the pushback
            buffer for the specified number of bytes,
            or this input stream has been closed by
            invoking its {@link #close()} method." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="unread" fulltype="void" type="void">
				<comment>
					<description>Pushes back an array of bytes by copying it to the front of the
 pushback buffer.  After this method returns, the next byte to be read
 will have the value &lt;code&gt;b[0]&lt;/code&gt;, the byte after that will have the
 value &lt;code&gt;b[1]&lt;/code&gt;, and so forth.</description>
					<attribute name="@param">
						<description>b the byte array to push back</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException If there is not enough room in the pushback
            buffer for the specified number of bytes,
            or this input stream has been closed by
            invoking its {@link #close()} method.</description>
					</attribute>
					<attribute name="@since">
						<description>JDK1.1</description>
					</attribute>
				</comment>
				<params>
					<param name="b" comment="the byte array to push back" fulltype="byte[]" type="byte" />
				</params>
				<exceptions>
					<exception comment="If there is not enough room in the pushback
            buffer for the specified number of bytes,
            or this input stream has been closed by
            invoking its {@link #close()} method." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="available" returncomment="the number of bytes that can be read (or skipped over) from
             the input stream without blocking." fulltype="int" type="int">
				<comment>
					<description>Returns an estimate of the number of bytes that can be read (or
 skipped over) from this input stream without blocking by the next
 invocation of a method for this input stream. The next invocation might be
 the same thread or another thread.  A single read or skip of this
 many bytes will not block, but may read or skip fewer bytes.

 &lt;p&gt; The method returns the sum of the number of bytes that have been
 pushed back and the value returned by {@link
 java.io.FilterInputStream#available available}.</description>
					<attribute name="@return">
						<description>the number of bytes that can be read (or skipped over) from
             the input stream without blocking.</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if this input stream has been closed by
             invoking its {@link #close()} method,
             or an I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.FilterInputStream#in</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.InputStream#available()</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if this input stream has been closed by
             invoking its {@link #close()} method,
             or an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="skip" returncomment="{@inheritDoc}" fulltype="long" type="long">
				<comment>
					<description>Skips over and discards &lt;code&gt;n&lt;/code&gt; bytes of data from this
 input stream. The &lt;code&gt;skip&lt;/code&gt; method may, for a variety of
 reasons, end up skipping over some smaller number of bytes,
 possibly zero.  If &lt;code&gt;n&lt;/code&gt; is negative, no bytes are skipped.

 &lt;p&gt; The &lt;code&gt;skip&lt;/code&gt; method of &lt;code&gt;PushbackInputStream&lt;/code&gt;
 first skips over the bytes in the pushback buffer, if any.  It then
 calls the &lt;code&gt;skip&lt;/code&gt; method of the underlying input stream if
 more bytes need to be skipped.  The actual number of bytes skipped
 is returned.</description>
					<attribute name="@param">
						<description>n  {@inheritDoc}</description>
					</attribute>
					<attribute name="@return">
						<description>{@inheritDoc}</description>
					</attribute>
					<attribute name="@exception">
						<description>IOException  if the stream does not support seek,
            or the stream has been closed by
            invoking its {@link #close()} method,
            or an I/O error occurs.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.FilterInputStream#in</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.InputStream#skip(long n)</description>
					</attribute>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
				<params>
					<param name="n" comment="{@inheritDoc}" fulltype="long" type="long" />
				</params>
				<exceptions>
					<exception comment="if the stream does not support seek,
            or the stream has been closed by
            invoking its {@link #close()} method,
            or an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="markSupported" returncomment="&lt;code&gt;false&lt;/code&gt;, since this class does not support the
           &lt;code&gt;mark&lt;/code&gt; and &lt;code&gt;reset&lt;/code&gt; methods." fulltype="boolean" type="boolean">
				<comment>
					<description>Tests if this input stream supports the &lt;code&gt;mark&lt;/code&gt; and
 &lt;code&gt;reset&lt;/code&gt; methods, which it does not.</description>
					<attribute name="@return">
						<description>&lt;code&gt;false&lt;/code&gt;, since this class does not support the
           &lt;code&gt;mark&lt;/code&gt; and &lt;code&gt;reset&lt;/code&gt; methods.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.InputStream#mark(int)</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.InputStream#reset()</description>
					</attribute>
				</comment>
			</method>
			<method synchronized="true" visibility="public" name="mark" fulltype="void" type="void">
				<comment>
					<description>Marks the current position in this input stream.

 &lt;p&gt; The &lt;code&gt;mark&lt;/code&gt; method of &lt;code&gt;PushbackInputStream&lt;/code&gt;
 does nothing.</description>
					<attribute name="@param">
						<description>readlimit   the maximum limit of bytes that can be read before
                      the mark position becomes invalid.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.InputStream#reset()</description>
					</attribute>
				</comment>
				<params>
					<param name="readlimit" comment="the maximum limit of bytes that can be read before
                      the mark position becomes invalid." fulltype="int" type="int" />
				</params>
			</method>
			<method synchronized="true" visibility="public" name="reset" fulltype="void" type="void">
				<comment>
					<description>Repositions this stream to the position at the time the
 &lt;code&gt;mark&lt;/code&gt; method was last called on this input stream.

 &lt;p&gt; The method &lt;code&gt;reset&lt;/code&gt; for class
 &lt;code&gt;PushbackInputStream&lt;/code&gt; does nothing except throw an
 &lt;code&gt;IOException&lt;/code&gt;.</description>
					<attribute name="@exception">
						<description>IOException  if this method is invoked.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.InputStream#mark(int)</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.IOException</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if this method is invoked." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="public" name="close" fulltype="void" type="void">
				<comment>
					<description>Closes this input stream and releases any system resources
 associated with the stream.
 Once the stream has been closed, further read(), unread(),
 available(), reset(), or skip() invocations will throw an IOException.
 Closing a previously closed stream has no effect.</description>
					<attribute name="@exception">
						<description>IOException  if an I/O error occurs.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="OutputStream" visibility="public" package="java.io" superclassfulltype="java.io.OutputStream" fulltype="java.io.ObjectOutputStream" type="ObjectOutputStream">
		<implements>
			<interface fulltype="java.io.ObjectOutput" type="ObjectOutput" />
			<interface fulltype="java.io.ObjectStreamConstants" type="ObjectStreamConstants" />
		</implements>
		<comment>
			<description>An ObjectOutputStream writes primitive data types and graphs of Java objects
 to an OutputStream.  The objects can be read (reconstituted) using an
 ObjectInputStream.  Persistent storage of objects can be accomplished by
 using a file for the stream.  If the stream is a network socket stream, the
 objects can be reconstituted on another host or in another process.

 &lt;p&gt;Only objects that support the java.io.Serializable interface can be
 written to streams.  The class of each serializable object is encoded
 including the class name and signature of the class, the values of the
 object&apos;s fields and arrays, and the closure of any other objects referenced
 from the initial objects.

 &lt;p&gt;The method writeObject is used to write an object to the stream.  Any
 object, including Strings and arrays, is written with writeObject. Multiple
 objects or primitives can be written to the stream.  The objects must be
 read back from the corresponding ObjectInputstream with the same types and
 in the same order as they were written.

 &lt;p&gt;Primitive data types can also be written to the stream using the
 appropriate methods from DataOutput. Strings can also be written using the
 writeUTF method.

 &lt;p&gt;The default serialization mechanism for an object writes the class of the
 object, the class signature, and the values of all non-transient and
 non-static fields.  References to other objects (except in transient or
 static fields) cause those objects to be written also. Multiple references
 to a single object are encoded using a reference sharing mechanism so that
 graphs of objects can be restored to the same shape as when the original was
 written.

 &lt;p&gt;For example to write an object that can be read by the example in
 ObjectInputStream:
 &lt;br&gt;
 &lt;pre&gt;
      FileOutputStream fos = new FileOutputStream(&quot;t.tmp&quot;);
      ObjectOutputStream oos = new ObjectOutputStream(fos);

      oos.writeInt(12345);
      oos.writeObject(&quot;Today&quot;);
      oos.writeObject(new Date());

      oos.close();
 &lt;/pre&gt;

 &lt;p&gt;Classes that require special handling during the serialization and
 deserialization process must implement special methods with these exact
 signatures:
 &lt;br&gt;
 &lt;pre&gt;
 private void readObject(java.io.ObjectInputStream stream)
     throws IOException, ClassNotFoundException;
 private void writeObject(java.io.ObjectOutputStream stream)
     throws IOException
 private void readObjectNoData()
     throws ObjectStreamException;
 &lt;/pre&gt;

 &lt;p&gt;The writeObject method is responsible for writing the state of the object
 for its particular class so that the corresponding readObject method can
 restore it.  The method does not need to concern itself with the state
 belonging to the object&apos;s superclasses or subclasses.  State is saved by
 writing the individual fields to the ObjectOutputStream using the
 writeObject method or by using the methods for primitive data types
 supported by DataOutput.

 &lt;p&gt;Serialization does not write out the fields of any object that does not
 implement the java.io.Serializable interface.  Subclasses of Objects that
 are not serializable can be serializable. In this case the non-serializable
 class must have a no-arg constructor to allow its fields to be initialized.
 In this case it is the responsibility of the subclass to save and restore
 the state of the non-serializable class. It is frequently the case that the
 fields of that class are accessible (public, package, or protected) or that
 there are get and set methods that can be used to restore the state.

 &lt;p&gt;Serialization of an object can be prevented by implementing writeObject
 and readObject methods that throw the NotSerializableException.  The
 exception will be caught by the ObjectOutputStream and abort the
 serialization process.

 &lt;p&gt;Implementing the Externalizable interface allows the object to assume
 complete control over the contents and format of the object&apos;s serialized
 form.  The methods of the Externalizable interface, writeExternal and
 readExternal, are called to save and restore the objects state.  When
 implemented by a class they can write and read their own state using all of
 the methods of ObjectOutput and ObjectInput.  It is the responsibility of
 the objects to handle any versioning that occurs.

 &lt;p&gt;Enum constants are serialized differently than ordinary serializable or
 externalizable objects.  The serialized form of an enum constant consists
 solely of its name; field values of the constant are not transmitted.  To
 serialize an enum constant, ObjectOutputStream writes the string returned by
 the constant&apos;s name method.  Like other serializable or externalizable
 objects, enum constants can function as the targets of back references
 appearing subsequently in the serialization stream.  The process by which
 enum constants are serialized cannot be customized; any class-specific
 writeObject and writeReplace methods defined by enum types are ignored
 during serialization.  Similarly, any serialPersistentFields or
 serialVersionUID field declarations are also ignored--all enum types have a
 fixed serialVersionUID of 0L.

 &lt;p&gt;Primitive data, excluding serializable fields and externalizable data, is
 written to the ObjectOutputStream in block-data records. A block data record
 is composed of a header and data. The block data header consists of a marker
 and the number of bytes to follow the header.  Consecutive primitive data
 writes are merged into one block-data record.  The blocking factor used for
 a block-data record will be 1024 bytes.  Each block-data record will be
 filled up to 1024 bytes, or be written whenever there is a termination of
 block-data mode.  Calls to the ObjectOutputStream methods writeObject,
 defaultWriteObject and writeFields initially terminate any existing
 block-data record.</description>
			<attribute name="@author">
				<description>Mike Warres</description>
			</attribute>
			<attribute name="@author">
				<description>Roger Riggs</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.DataOutput</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.ObjectInputStream</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.Serializable</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.Externalizable</description>
			</attribute>
			<attribute name="@see">
				<description>&lt;a href=&quot;../../../platform/serialization/spec/output.html&quot;&gt;Object Serialization Specification, Section 2, Object Output Classes&lt;/a&gt;</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.1</description>
			</attribute>
		</comment>
		<fields>
			<field final="true" visibility="private" name="bout" fulltype="java.io.ObjectOutputStream.BlockDataOutputStream" type="ObjectOutputStream.BlockDataOutputStream">
				<comment>
					<description>filter stream for handling block data conversion</description>
				</comment>
			</field>
			<field final="true" visibility="private" name="handles" fulltype="java.io.ObjectOutputStream.HandleTable" type="ObjectOutputStream.HandleTable">
				<comment>
					<description>obj -&gt; wire handle map</description>
				</comment>
			</field>
			<field final="true" visibility="private" name="subs" fulltype="java.io.ObjectOutputStream.ReplaceTable" type="ObjectOutputStream.ReplaceTable">
				<comment>
					<description>obj -&gt; replacement obj map</description>
				</comment>
			</field>
			<field visibility="private" name="protocol" fulltype="int" type="int">
				<comment>
					<description>stream protocol version</description>
				</comment>
			</field>
			<field visibility="private" name="depth" fulltype="int" type="int">
				<comment>
					<description>recursion depth</description>
				</comment>
			</field>
			<field visibility="private" name="primVals" fulltype="byte[]" type="byte">
				<comment>
					<description>buffer for writing primitive field values</description>
				</comment>
			</field>
			<field final="true" visibility="private" name="enableOverride" fulltype="boolean" type="boolean">
				<comment>
					<description>if true, invoke writeObjectOverride() instead of writeObject()</description>
				</comment>
			</field>
			<field visibility="private" name="enableReplace" fulltype="boolean" type="boolean">
				<comment>
					<description>if true, invoke replaceObject()</description>
				</comment>
			</field>
			<field visibility="private" name="curContext" fulltype="java.io.SerialCallbackContext" type="SerialCallbackContext">
				<comment>
					<description>Context during upcalls to class-defined writeObject methods; holds
 object currently being serialized and descriptor for current class.
 Null when not during writeObject upcall.</description>
				</comment>
			</field>
			<field visibility="private" name="curPut" fulltype="java.io.ObjectOutputStream.PutFieldImpl" type="ObjectOutputStream.PutFieldImpl">
				<comment>
					<description>current PutField object</description>
				</comment>
			</field>
			<field final="true" visibility="private" name="debugInfoStack" fulltype="java.io.ObjectOutputStream.DebugTraceInfoStack" type="ObjectOutputStream.DebugTraceInfoStack">
				<comment>
					<description>custom storage for debug trace info</description>
				</comment>
			</field>
			<field final="true" static="true" visibility="private" name="extendedDebugInfo" fulltype="boolean" type="boolean">
				<comment>
					<description>value of &quot;sun.io.serialization.extendedDebugInfo&quot; property,
 as true or false for extended information about exception&apos;s place</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="public" name="ObjectOutputStream">
				<comment>
					<description>Creates an ObjectOutputStream that writes to the specified OutputStream.
 This constructor writes the serialization stream header to the
 underlying stream; callers may wish to flush the stream immediately to
 ensure that constructors for receiving ObjectInputStreams will not block
 when reading the header.

 &lt;p&gt;If a security manager is installed, this constructor will check for
 the &quot;enableSubclassImplementation&quot; SerializablePermission when invoked
 directly or indirectly by the constructor of a subclass which overrides
 the ObjectOutputStream.putFields or ObjectOutputStream.writeUnshared
 methods.</description>
					<attribute name="@param">
						<description>out output stream to write to</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException if an I/O error occurs while writing stream header</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException if untrusted subclass illegally overrides
          security-sensitive methods</description>
					</attribute>
					<attribute name="@throws">
						<description>NullPointerException if &lt;code&gt;out&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
					<attribute name="@see">
						<description>ObjectOutputStream#ObjectOutputStream()</description>
					</attribute>
					<attribute name="@see">
						<description>ObjectOutputStream#putFields()</description>
					</attribute>
					<attribute name="@see">
						<description>ObjectInputStream#ObjectInputStream(InputStream)</description>
					</attribute>
				</comment>
				<params>
					<param name="out" comment="output stream to write to" fulltype="java.io.OutputStream" type="OutputStream" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs while writing stream header" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</constructor>
			<constructor visibility="protected" name="ObjectOutputStream">
				<comment>
					<description>Provide a way for subclasses that are completely reimplementing
 ObjectOutputStream to not have to allocate private data just used by
 this implementation of ObjectOutputStream.

 &lt;p&gt;If there is a security manager installed, this method first calls the
 security manager&apos;s &lt;code&gt;checkPermission&lt;/code&gt; method with a
 &lt;code&gt;SerializablePermission(&quot;enableSubclassImplementation&quot;)&lt;/code&gt;
 permission to ensure it&apos;s ok to enable subclassing.</description>
					<attribute name="@throws">
						<description>SecurityException if a security manager exists and its
          &lt;code&gt;checkPermission&lt;/code&gt; method denies enabling
          subclassing.</description>
					</attribute>
					<attribute name="@see">
						<description>SecurityManager#checkPermission</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.SerializablePermission</description>
					</attribute>
				</comment>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
					<exception comment="if a security manager exists and its
          &lt;code&gt;checkPermission&lt;/code&gt; method denies enabling
          subclassing." fulltype="java.lang.SecurityException" type="SecurityException" />
				</exceptions>
			</constructor>
			<method visibility="public" name="useProtocolVersion" fulltype="void" type="void">
				<comment>
					<description>Specify stream protocol version to use when writing the stream.

 &lt;p&gt;This routine provides a hook to enable the current version of
 Serialization to write in a format that is backwards compatible to a
 previous version of the stream format.

 &lt;p&gt;Every effort will be made to avoid introducing additional
 backwards incompatibilities; however, sometimes there is no
 other alternative.</description>
					<attribute name="@param">
						<description>version use ProtocolVersion from java.io.ObjectStreamConstants.</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalStateException if called after any objects
          have been serialized.</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if invalid version is passed in.</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException if I/O errors occur</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.ObjectStreamConstants#PROTOCOL_VERSION_1</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.ObjectStreamConstants#PROTOCOL_VERSION_2</description>
					</attribute>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
				<params>
					<param name="version" comment="use ProtocolVersion from java.io.ObjectStreamConstants." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if I/O errors occur" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method final="true" visibility="public" name="writeObject" fulltype="void" type="void">
				<comment>
					<description>Write the specified object to the ObjectOutputStream.  The class of the
 object, the signature of the class, and the values of the non-transient
 and non-static fields of the class and all of its supertypes are
 written.  Default serialization for a class can be overridden using the
 writeObject and the readObject methods.  Objects referenced by this
 object are written transitively so that a complete equivalent graph of
 objects can be reconstructed by an ObjectInputStream.

 &lt;p&gt;Exceptions are thrown for problems with the OutputStream and for
 classes that should not be serialized.  All exceptions are fatal to the
 OutputStream, which is left in an indeterminate state, and it is up to
 the caller to ignore or recover the stream state.</description>
					<attribute name="@throws">
						<description>InvalidClassException Something is wrong with a class used by
          serialization.</description>
					</attribute>
					<attribute name="@throws">
						<description>NotSerializableException Some object to be serialized does not
          implement the java.io.Serializable interface.</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException Any exception thrown by the underlying
          OutputStream.</description>
					</attribute>
				</comment>
				<params>
					<param name="obj" fulltype="java.lang.Object" type="Object" />
				</params>
				<exceptions>
					<exception comment="Any exception thrown by the underlying
          OutputStream." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="protected" name="writeObjectOverride" fulltype="void" type="void">
				<comment>
					<description>Method used by subclasses to override the default writeObject method.
 This method is called by trusted subclasses of ObjectInputStream that
 constructed ObjectInputStream using the protected no-arg constructor.
 The subclass is expected to provide an override method with the modifier
 &quot;final&quot;.</description>
					<attribute name="@param">
						<description>obj object to be written to the underlying stream</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException if there are I/O errors while writing to the
          underlying stream</description>
					</attribute>
					<attribute name="@see">
						<description>#ObjectOutputStream()</description>
					</attribute>
					<attribute name="@see">
						<description>#writeObject(Object)</description>
					</attribute>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
				<params>
					<param name="obj" comment="object to be written to the underlying stream" fulltype="java.lang.Object" type="Object" />
				</params>
				<exceptions>
					<exception comment="if there are I/O errors while writing to the
          underlying stream" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="writeUnshared" fulltype="void" type="void">
				<comment>
					<description>Writes an &quot;unshared&quot; object to the ObjectOutputStream.  This method is
 identical to writeObject, except that it always writes the given object
 as a new, unique object in the stream (as opposed to a back-reference
 pointing to a previously serialized instance).  Specifically:
 &lt;ul&gt;
   &lt;li&gt;An object written via writeUnshared is always serialized in the
       same manner as a newly appearing object (an object that has not
       been written to the stream yet), regardless of whether or not the
       object has been written previously.

   &lt;li&gt;If writeObject is used to write an object that has been previously
       written with writeUnshared, the previous writeUnshared operation
       is treated as if it were a write of a separate object.  In other
       words, ObjectOutputStream will never generate back-references to
       object data written by calls to writeUnshared.
 &lt;/ul&gt;
 While writing an object via writeUnshared does not in itself guarantee a
 unique reference to the object when it is deserialized, it allows a
 single object to be defined multiple times in a stream, so that multiple
 calls to readUnshared by the receiver will not conflict.  Note that the
 rules described above only apply to the base-level object written with
 writeUnshared, and not to any transitively referenced sub-objects in the
 object graph to be serialized.

 &lt;p&gt;ObjectOutputStream subclasses which override this method can only be
 constructed in security contexts possessing the
 &quot;enableSubclassImplementation&quot; SerializablePermission; any attempt to
 instantiate such a subclass without this permission will cause a
 SecurityException to be thrown.</description>
					<attribute name="@param">
						<description>obj object to write to stream</description>
					</attribute>
					<attribute name="@throws">
						<description>NotSerializableException if an object in the graph to be
          serialized does not implement the Serializable interface</description>
					</attribute>
					<attribute name="@throws">
						<description>InvalidClassException if a problem exists with the class of an
          object to be serialized</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException if an I/O error occurs during serialization</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
				<params>
					<param name="obj" comment="object to write to stream" fulltype="java.lang.Object" type="Object" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs during serialization" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="defaultWriteObject" fulltype="void" type="void">
				<comment>
					<description>Write the non-static and non-transient fields of the current class to
 this stream.  This may only be called from the writeObject method of the
 class being serialized. It will throw the NotActiveException if it is
 called otherwise.</description>
					<attribute name="@throws">
						<description>IOException if I/O errors occur while writing to the underlying
          &lt;code&gt;OutputStream&lt;/code&gt;</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if I/O errors occur while writing to the underlying
          &lt;code&gt;OutputStream&lt;/code&gt;" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="putFields" returncomment="an instance of the class Putfield that holds the serializable
          fields" fulltype="java.io.ObjectOutputStream.PutField" type="ObjectOutputStream.PutField">
				<comment>
					<description>Retrieve the object used to buffer persistent fields to be written to
 the stream.  The fields will be written to the stream when writeFields
 method is called.</description>
					<attribute name="@return">
						<description>an instance of the class Putfield that holds the serializable
          fields</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException if I/O errors occur</description>
					</attribute>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if I/O errors occur" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="writeFields" fulltype="void" type="void">
				<comment>
					<description>Write the buffered fields to the stream.</description>
					<attribute name="@throws">
						<description>IOException if I/O errors occur while writing to the underlying
          stream</description>
					</attribute>
					<attribute name="@throws">
						<description>NotActiveException Called when a classes writeObject method was
          not called to write the state of the object.</description>
					</attribute>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if I/O errors occur while writing to the underlying
          stream" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="reset" fulltype="void" type="void">
				<comment>
					<description>Reset will disregard the state of any objects already written to the
 stream.  The state is reset to be the same as a new ObjectOutputStream.
 The current point in the stream is marked as reset so the corresponding
 ObjectInputStream will be reset at the same point.  Objects previously
 written to the stream will not be refered to as already being in the
 stream.  They will be written to the stream again.</description>
					<attribute name="@throws">
						<description>IOException if reset() is invoked while serializing an object.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if reset() is invoked while serializing an object." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="protected" name="annotateClass" fulltype="void" type="void">
				<comment>
					<description>Subclasses may implement this method to allow class data to be stored in
 the stream. By default this method does nothing.  The corresponding
 method in ObjectInputStream is resolveClass.  This method is called
 exactly once for each unique class in the stream.  The class name and
 signature will have already been written to the stream.  This method may
 make free use of the ObjectOutputStream to save any representation of
 the class it deems suitable (for example, the bytes of the class file).
 The resolveClass method in the corresponding subclass of
 ObjectInputStream must read and use any data or objects written by
 annotateClass.</description>
					<attribute name="@param">
						<description>cl the class to annotate custom data for</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException Any exception thrown by the underlying
          OutputStream.</description>
					</attribute>
				</comment>
				<params>
					<param name="cl" comment="the class to annotate custom data for" fulltype="java.lang.Class" type="Class" />
				</params>
				<exceptions>
					<exception comment="Any exception thrown by the underlying
          OutputStream." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="protected" name="annotateProxyClass" fulltype="void" type="void">
				<comment>
					<description>Subclasses may implement this method to store custom data in the stream
 along with descriptors for dynamic proxy classes.

 &lt;p&gt;This method is called exactly once for each unique proxy class
 descriptor in the stream.  The default implementation of this method in
 &lt;code&gt;ObjectOutputStream&lt;/code&gt; does nothing.

 &lt;p&gt;The corresponding method in &lt;code&gt;ObjectInputStream&lt;/code&gt; is
 &lt;code&gt;resolveProxyClass&lt;/code&gt;.  For a given subclass of
 &lt;code&gt;ObjectOutputStream&lt;/code&gt; that overrides this method, the
 &lt;code&gt;resolveProxyClass&lt;/code&gt; method in the corresponding subclass of
 &lt;code&gt;ObjectInputStream&lt;/code&gt; must read any data or objects written by
 &lt;code&gt;annotateProxyClass&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>cl the proxy class to annotate custom data for</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException any exception thrown by the underlying
          &lt;code&gt;OutputStream&lt;/code&gt;</description>
					</attribute>
					<attribute name="@see">
						<description>ObjectInputStream#resolveProxyClass(String[])</description>
					</attribute>
					<attribute name="@since">
						<description>1.3</description>
					</attribute>
				</comment>
				<params>
					<param name="cl" comment="the proxy class to annotate custom data for" fulltype="java.lang.Class" type="Class" />
				</params>
				<exceptions>
					<exception comment="any exception thrown by the underlying
          &lt;code&gt;OutputStream&lt;/code&gt;" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="protected" name="replaceObject" returncomment="the alternate object that replaced the specified one" fulltype="java.lang.Object" type="Object">
				<comment>
					<description>This method will allow trusted subclasses of ObjectOutputStream to
 substitute one object for another during serialization. Replacing
 objects is disabled until enableReplaceObject is called. The
 enableReplaceObject method checks that the stream requesting to do
 replacement can be trusted.  The first occurrence of each object written
 into the serialization stream is passed to replaceObject.  Subsequent
 references to the object are replaced by the object returned by the
 original call to replaceObject.  To ensure that the private state of
 objects is not unintentionally exposed, only trusted streams may use
 replaceObject.

 &lt;p&gt;The ObjectOutputStream.writeObject method takes a parameter of type
 Object (as opposed to type Serializable) to allow for cases where
 non-serializable objects are replaced by serializable ones.

 &lt;p&gt;When a subclass is replacing objects it must insure that either a
 complementary substitution must be made during deserialization or that
 the substituted object is compatible with every field where the
 reference will be stored.  Objects whose type is not a subclass of the
 type of the field or array element abort the serialization by raising an
 exception and the object is not be stored.

 &lt;p&gt;This method is called only once when each object is first
 encountered.  All subsequent references to the object will be redirected
 to the new object. This method should return the object to be
 substituted or the original object.

 &lt;p&gt;Null can be returned as the object to be substituted, but may cause
 NullReferenceException in classes that contain references to the
 original object since they may be expecting an object instead of
 null.</description>
					<attribute name="@param">
						<description>obj the object to be replaced</description>
					</attribute>
					<attribute name="@return">
						<description>the alternate object that replaced the specified one</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException Any exception thrown by the underlying
          OutputStream.</description>
					</attribute>
				</comment>
				<params>
					<param name="obj" comment="the object to be replaced" fulltype="java.lang.Object" type="Object" />
				</params>
				<exceptions>
					<exception comment="Any exception thrown by the underlying
          OutputStream." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="protected" name="enableReplaceObject" returncomment="the previous setting before this method was invoked" fulltype="boolean" type="boolean">
				<comment>
					<description>Enable the stream to do replacement of objects in the stream.  When
 enabled, the replaceObject method is called for every object being
 serialized.

 &lt;p&gt;If &lt;code&gt;enable&lt;/code&gt; is true, and there is a security manager
 installed, this method first calls the security manager&apos;s
 &lt;code&gt;checkPermission&lt;/code&gt; method with a
 &lt;code&gt;SerializablePermission(&quot;enableSubstitution&quot;)&lt;/code&gt; permission to
 ensure it&apos;s ok to enable the stream to do replacement of objects in the
 stream.</description>
					<attribute name="@param">
						<description>enable boolean parameter to enable replacement of objects</description>
					</attribute>
					<attribute name="@return">
						<description>the previous setting before this method was invoked</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException if a security manager exists and its
          &lt;code&gt;checkPermission&lt;/code&gt; method denies enabling the stream
          to do replacement of objects in the stream.</description>
					</attribute>
					<attribute name="@see">
						<description>SecurityManager#checkPermission</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.SerializablePermission</description>
					</attribute>
				</comment>
				<params>
					<param name="enable" comment="boolean parameter to enable replacement of objects" fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception comment="if a security manager exists and its
          &lt;code&gt;checkPermission&lt;/code&gt; method denies enabling the stream
          to do replacement of objects in the stream." fulltype="java.lang.SecurityException" type="SecurityException" />
				</exceptions>
			</method>
			<method visibility="protected" name="writeStreamHeader" fulltype="void" type="void">
				<comment>
					<description>The writeStreamHeader method is provided so subclasses can append or
 prepend their own header to the stream.  It writes the magic number and
 version to the stream.</description>
					<attribute name="@throws">
						<description>IOException if I/O errors occur while writing to the underlying
          stream</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if I/O errors occur while writing to the underlying
          stream" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="protected" name="writeClassDescriptor" fulltype="void" type="void">
				<comment>
					<description>Write the specified class descriptor to the ObjectOutputStream.  Class
 descriptors are used to identify the classes of objects written to the
 stream.  Subclasses of ObjectOutputStream may override this method to
 customize the way in which class descriptors are written to the
 serialization stream.  The corresponding method in ObjectInputStream,
 &lt;code&gt;readClassDescriptor&lt;/code&gt;, should then be overridden to
 reconstitute the class descriptor from its custom stream representation.
 By default, this method writes class descriptors according to the format
 defined in the Object Serialization specification.

 &lt;p&gt;Note that this method will only be called if the ObjectOutputStream
 is not using the old serialization stream format (set by calling
 ObjectOutputStream&apos;s &lt;code&gt;useProtocolVersion&lt;/code&gt; method).  If this
 serialization stream is using the old format
 (&lt;code&gt;PROTOCOL_VERSION_1&lt;/code&gt;), the class descriptor will be written
 internally in a manner that cannot be overridden or customized.</description>
					<attribute name="@param">
						<description>desc class descriptor to write to the stream</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException If an I/O error has occurred.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.ObjectInputStream#readClassDescriptor()</description>
					</attribute>
					<attribute name="@see">
						<description>#useProtocolVersion(int)</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.ObjectStreamConstants#PROTOCOL_VERSION_1</description>
					</attribute>
					<attribute name="@since">
						<description>1.3</description>
					</attribute>
				</comment>
				<params>
					<param name="desc" comment="class descriptor to write to the stream" fulltype="java.io.ObjectStreamClass" type="ObjectStreamClass" />
				</params>
				<exceptions>
					<exception comment="If an I/O error has occurred." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes a byte. This method will block until the byte is actually
 written.</description>
					<attribute name="@param">
						<description>val the byte to be written to the stream</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException If an I/O error has occurred.</description>
					</attribute>
				</comment>
				<params>
					<param name="val" comment="the byte to be written to the stream" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="If an I/O error has occurred." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes an array of bytes. This method will block until the bytes are
 actually written.</description>
					<attribute name="@param">
						<description>buf the data to be written</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException If an I/O error has occurred.</description>
					</attribute>
				</comment>
				<params>
					<param name="buf" comment="the data to be written" fulltype="byte[]" type="byte" />
				</params>
				<exceptions>
					<exception comment="If an I/O error has occurred." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes a sub array of bytes.</description>
					<attribute name="@param">
						<description>buf the data to be written</description>
					</attribute>
					<attribute name="@param">
						<description>off the start offset in the data</description>
					</attribute>
					<attribute name="@param">
						<description>len the number of bytes that are written</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException If an I/O error has occurred.</description>
					</attribute>
				</comment>
				<params>
					<param name="buf" comment="the data to be written" fulltype="byte[]" type="byte" />
					<param name="off" comment="the start offset in the data" fulltype="int" type="int" />
					<param name="len" comment="the number of bytes that are written" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="If an I/O error has occurred." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="flush" fulltype="void" type="void">
				<comment>
					<description>Flushes the stream. This will write any buffered output bytes and flush
 through to the underlying stream.</description>
					<attribute name="@throws">
						<description>IOException If an I/O error has occurred.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If an I/O error has occurred." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="protected" name="drain" fulltype="void" type="void">
				<comment>
					<description>Drain any buffered data in ObjectOutputStream.  Similar to flush but
 does not propagate the flush to the underlying stream.</description>
					<attribute name="@throws">
						<description>IOException if I/O errors occur while writing to the underlying
          stream</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if I/O errors occur while writing to the underlying
          stream" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="close" fulltype="void" type="void">
				<comment>
					<description>Closes the stream. This method must be called to release any resources
 associated with the stream.</description>
					<attribute name="@throws">
						<description>IOException If an I/O error has occurred.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If an I/O error has occurred." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="writeBoolean" fulltype="void" type="void">
				<comment>
					<description>Writes a boolean.</description>
					<attribute name="@param">
						<description>val the boolean to be written</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException if I/O errors occur while writing to the underlying
          stream</description>
					</attribute>
				</comment>
				<params>
					<param name="val" comment="the boolean to be written" fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception comment="if I/O errors occur while writing to the underlying
          stream" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="writeByte" fulltype="void" type="void">
				<comment>
					<description>Writes an 8 bit byte.</description>
					<attribute name="@param">
						<description>val the byte value to be written</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException if I/O errors occur while writing to the underlying
          stream</description>
					</attribute>
				</comment>
				<params>
					<param name="val" comment="the byte value to be written" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if I/O errors occur while writing to the underlying
          stream" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="writeShort" fulltype="void" type="void">
				<comment>
					<description>Writes a 16 bit short.</description>
					<attribute name="@param">
						<description>val the short value to be written</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException if I/O errors occur while writing to the underlying
          stream</description>
					</attribute>
				</comment>
				<params>
					<param name="val" comment="the short value to be written" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if I/O errors occur while writing to the underlying
          stream" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="writeChar" fulltype="void" type="void">
				<comment>
					<description>Writes a 16 bit char.</description>
					<attribute name="@param">
						<description>val the char value to be written</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException if I/O errors occur while writing to the underlying
          stream</description>
					</attribute>
				</comment>
				<params>
					<param name="val" comment="the char value to be written" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if I/O errors occur while writing to the underlying
          stream" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="writeInt" fulltype="void" type="void">
				<comment>
					<description>Writes a 32 bit int.</description>
					<attribute name="@param">
						<description>val the integer value to be written</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException if I/O errors occur while writing to the underlying
          stream</description>
					</attribute>
				</comment>
				<params>
					<param name="val" comment="the integer value to be written" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if I/O errors occur while writing to the underlying
          stream" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="writeLong" fulltype="void" type="void">
				<comment>
					<description>Writes a 64 bit long.</description>
					<attribute name="@param">
						<description>val the long value to be written</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException if I/O errors occur while writing to the underlying
          stream</description>
					</attribute>
				</comment>
				<params>
					<param name="val" comment="the long value to be written" fulltype="long" type="long" />
				</params>
				<exceptions>
					<exception comment="if I/O errors occur while writing to the underlying
          stream" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="writeFloat" fulltype="void" type="void">
				<comment>
					<description>Writes a 32 bit float.</description>
					<attribute name="@param">
						<description>val the float value to be written</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException if I/O errors occur while writing to the underlying
          stream</description>
					</attribute>
				</comment>
				<params>
					<param name="val" comment="the float value to be written" fulltype="float" type="float" />
				</params>
				<exceptions>
					<exception comment="if I/O errors occur while writing to the underlying
          stream" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="writeDouble" fulltype="void" type="void">
				<comment>
					<description>Writes a 64 bit double.</description>
					<attribute name="@param">
						<description>val the double value to be written</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException if I/O errors occur while writing to the underlying
          stream</description>
					</attribute>
				</comment>
				<params>
					<param name="val" comment="the double value to be written" fulltype="double" type="double" />
				</params>
				<exceptions>
					<exception comment="if I/O errors occur while writing to the underlying
          stream" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="writeBytes" fulltype="void" type="void">
				<comment>
					<description>Writes a String as a sequence of bytes.</description>
					<attribute name="@param">
						<description>str the String of bytes to be written</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException if I/O errors occur while writing to the underlying
          stream</description>
					</attribute>
				</comment>
				<params>
					<param name="str" comment="the String of bytes to be written" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception comment="if I/O errors occur while writing to the underlying
          stream" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="writeChars" fulltype="void" type="void">
				<comment>
					<description>Writes a String as a sequence of chars.</description>
					<attribute name="@param">
						<description>str the String of chars to be written</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException if I/O errors occur while writing to the underlying
          stream</description>
					</attribute>
				</comment>
				<params>
					<param name="str" comment="the String of chars to be written" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception comment="if I/O errors occur while writing to the underlying
          stream" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="writeUTF" fulltype="void" type="void">
				<comment>
					<description>Primitive data write of this String in
 &lt;a href=&quot;DataInput.html#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt;
 format.  Note that there is a
 significant difference between writing a String into the stream as
 primitive data or as an Object. A String instance written by writeObject
 is written into the stream as a String initially. Future writeObject()
 calls write references to the string into the stream.</description>
					<attribute name="@param">
						<description>str the String to be written</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException if I/O errors occur while writing to the underlying
          stream</description>
					</attribute>
				</comment>
				<params>
					<param name="str" comment="the String to be written" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception comment="if I/O errors occur while writing to the underlying
          stream" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="package-private" name="getProtocolVersion" fulltype="int" type="int">
				<comment>
					<description>Returns protocol version in use.</description>
				</comment>
			</method>
			<method visibility="package-private" name="writeTypeString" fulltype="void" type="void">
				<comment>
					<description>Writes string without allowing it to be replaced in stream.  Used by
 ObjectStreamClass to write class descriptor type strings.</description>
				</comment>
				<params>
					<param name="str" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="verifySubclass" fulltype="void" type="void">
				<comment>
					<description>Verifies that this (possibly subclass) instance can be constructed
 without violating security constraints: the subclass must not override
 security-sensitive non-final methods, or else the
 &quot;enableSubclassImplementation&quot; SerializablePermission is checked.</description>
				</comment>
			</method>
			<method static="true" visibility="private" name="auditSubclass" fulltype="boolean" type="boolean">
				<comment>
					<description>Performs reflective checks on given subclass to verify that it doesn&apos;t
 override security-sensitive non-final methods.  Returns true if subclass
 is &quot;safe&quot;, false otherwise.</description>
				</comment>
				<params>
					<param name="subcl" fulltype="java.lang.Class" type="Class" />
				</params>
			</method>
			<method visibility="private" name="clear" fulltype="void" type="void">
				<comment>
					<description>Clears internal data structures.</description>
				</comment>
			</method>
			<method visibility="private" name="writeObject0" fulltype="void" type="void">
				<comment>
					<description>Underlying writeObject/writeUnshared implementation.</description>
				</comment>
				<params>
					<param name="obj" fulltype="java.lang.Object" type="Object" />
					<param name="unshared" fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="writeNull" fulltype="void" type="void">
				<comment>
					<description>Writes null code to stream.</description>
				</comment>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="writeHandle" fulltype="void" type="void">
				<comment>
					<description>Writes given object handle to stream.</description>
				</comment>
				<params>
					<param name="handle" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="writeClass" fulltype="void" type="void">
				<comment>
					<description>Writes representation of given class to stream.</description>
				</comment>
				<params>
					<param name="cl" fulltype="java.lang.Class" type="Class" />
					<param name="unshared" fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="writeClassDesc" fulltype="void" type="void">
				<comment>
					<description>Writes representation of given class descriptor to stream.</description>
				</comment>
				<params>
					<param name="desc" fulltype="java.io.ObjectStreamClass" type="ObjectStreamClass" />
					<param name="unshared" fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="writeProxyDesc" fulltype="void" type="void">
				<comment>
					<description>Writes class descriptor representing a dynamic proxy class to stream.</description>
				</comment>
				<params>
					<param name="desc" fulltype="java.io.ObjectStreamClass" type="ObjectStreamClass" />
					<param name="unshared" fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="writeNonProxyDesc" fulltype="void" type="void">
				<comment>
					<description>Writes class descriptor representing a standard (i.e., not a dynamic
 proxy) class to stream.</description>
				</comment>
				<params>
					<param name="desc" fulltype="java.io.ObjectStreamClass" type="ObjectStreamClass" />
					<param name="unshared" fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="writeString" fulltype="void" type="void">
				<comment>
					<description>Writes given string to stream, using standard or long UTF format
 depending on string length.</description>
				</comment>
				<params>
					<param name="str" fulltype="java.lang.String" type="String" />
					<param name="unshared" fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="writeArray" fulltype="void" type="void">
				<comment>
					<description>Writes given array object to stream.</description>
				</comment>
				<params>
					<param name="array" fulltype="java.lang.Object" type="Object" />
					<param name="desc" fulltype="java.io.ObjectStreamClass" type="ObjectStreamClass" />
					<param name="unshared" fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="writeEnum" fulltype="void" type="void">
				<comment>
					<description>Writes given enum constant to stream.</description>
				</comment>
				<params>
					<param name="en" fulltype="java.lang.Enum" type="Enum" />
					<param name="desc" fulltype="java.io.ObjectStreamClass" type="ObjectStreamClass" />
					<param name="unshared" fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="writeOrdinaryObject" fulltype="void" type="void">
				<comment>
					<description>Writes representation of a &quot;ordinary&quot; (i.e., not a String, Class,
 ObjectStreamClass, array, or enum constant) serializable object to the
 stream.</description>
				</comment>
				<params>
					<param name="obj" fulltype="java.lang.Object" type="Object" />
					<param name="desc" fulltype="java.io.ObjectStreamClass" type="ObjectStreamClass" />
					<param name="unshared" fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="writeExternalData" fulltype="void" type="void">
				<comment>
					<description>Writes externalizable data of given object by invoking its
 writeExternal() method.</description>
				</comment>
				<params>
					<param name="obj" fulltype="java.io.Externalizable" type="Externalizable" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="writeSerialData" fulltype="void" type="void">
				<comment>
					<description>Writes instance data for each serializable class of given object, from
 superclass to subclass.</description>
				</comment>
				<params>
					<param name="obj" fulltype="java.lang.Object" type="Object" />
					<param name="desc" fulltype="java.io.ObjectStreamClass" type="ObjectStreamClass" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="defaultWriteFields" fulltype="void" type="void">
				<comment>
					<description>Fetches and writes values of serializable fields of given object to
 stream.  The given class descriptor specifies which field values to
 write, and in which order they should be written.</description>
				</comment>
				<params>
					<param name="obj" fulltype="java.lang.Object" type="Object" />
					<param name="desc" fulltype="java.io.ObjectStreamClass" type="ObjectStreamClass" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="writeFatalException" fulltype="void" type="void">
				<comment>
					<description>Attempts to write to stream fatal IOException that has caused
 serialization to abort.</description>
				</comment>
				<params>
					<param name="ex" fulltype="java.io.IOException" type="IOException" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method static="true" visibility="private" name="floatsToBytes" fulltype="void" type="void">
				<comment>
					<description>Converts specified span of float values into byte values.</description>
				</comment>
				<params>
					<param name="src" fulltype="float[]" type="float" />
					<param name="srcpos" fulltype="int" type="int" />
					<param name="dst" fulltype="byte[]" type="byte" />
					<param name="dstpos" fulltype="int" type="int" />
					<param name="nfloats" fulltype="int" type="int" />
				</params>
			</method>
			<method static="true" visibility="private" name="doublesToBytes" fulltype="void" type="void">
				<comment>
					<description>Converts specified span of double values into byte values.</description>
				</comment>
				<params>
					<param name="src" fulltype="double[]" type="double" />
					<param name="srcpos" fulltype="int" type="int" />
					<param name="dst" fulltype="byte[]" type="byte" />
					<param name="dstpos" fulltype="int" type="int" />
					<param name="ndoubles" fulltype="int" type="int" />
				</params>
			</method>
		</methods>
		<jelclass superclass="Object" visibility="private" package="java.io" superclassfulltype="java.lang.Object" fulltype="java.io.ObjectOutputStream.Caches" type="ObjectOutputStream.Caches">
			<fields>
				<field final="true" static="true" visibility="package-private" name="subclassAudits" fulltype="java.util.concurrent.ConcurrentMap" type="ConcurrentMap">
					<comment>
						<description>cache of subclass security audit results</description>
					</comment>
				</field>
				<field final="true" static="true" visibility="package-private" name="subclassAuditsQueue" fulltype="java.lang.ref.ReferenceQueue" type="ReferenceQueue">
					<comment>
						<description>queue for WeakReferences to audited subclasses</description>
					</comment>
				</field>
			</fields>
			<methods>
				<constructor visibility="private" name="ObjectOutputStream.Caches" />
			</methods>
		</jelclass>
		<jelclass abstract="true" superclass="Object" visibility="public" package="java.io" superclassfulltype="java.lang.Object" fulltype="java.io.ObjectOutputStream.PutField" type="ObjectOutputStream.PutField">
			<comment>
				<description>Provide programmatic access to the persistent fields to be written
 to ObjectOutput.</description>
				<attribute name="@since">
					<description>1.2</description>
				</attribute>
			</comment>
			<methods>
				<constructor visibility="public" name="ObjectOutputStream.PutField" />
				<method abstract="true" visibility="public" name="put" fulltype="void" type="void">
					<comment>
						<description>Put the value of the named boolean field into the persistent field.</description>
						<attribute name="@param">
							<description>name the name of the serializable field</description>
						</attribute>
						<attribute name="@param">
							<description>val the value to assign to the field</description>
						</attribute>
						<attribute name="@throws">
							<description>IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; does not
 match the name of a serializable field for the class whose fields
 are being written, or if the type of the named field is not
 &lt;code&gt;boolean&lt;/code&gt;</description>
						</attribute>
					</comment>
					<params>
						<param name="name" comment="the name of the serializable field" fulltype="java.lang.String" type="String" />
						<param name="val" comment="the value to assign to the field" fulltype="boolean" type="boolean" />
					</params>
				</method>
				<method abstract="true" visibility="public" name="put" fulltype="void" type="void">
					<comment>
						<description>Put the value of the named byte field into the persistent field.</description>
						<attribute name="@param">
							<description>name the name of the serializable field</description>
						</attribute>
						<attribute name="@param">
							<description>val the value to assign to the field</description>
						</attribute>
						<attribute name="@throws">
							<description>IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; does not
 match the name of a serializable field for the class whose fields
 are being written, or if the type of the named field is not
 &lt;code&gt;byte&lt;/code&gt;</description>
						</attribute>
					</comment>
					<params>
						<param name="name" comment="the name of the serializable field" fulltype="java.lang.String" type="String" />
						<param name="val" comment="the value to assign to the field" fulltype="byte" type="byte" />
					</params>
				</method>
				<method abstract="true" visibility="public" name="put" fulltype="void" type="void">
					<comment>
						<description>Put the value of the named char field into the persistent field.</description>
						<attribute name="@param">
							<description>name the name of the serializable field</description>
						</attribute>
						<attribute name="@param">
							<description>val the value to assign to the field</description>
						</attribute>
						<attribute name="@throws">
							<description>IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; does not
 match the name of a serializable field for the class whose fields
 are being written, or if the type of the named field is not
 &lt;code&gt;char&lt;/code&gt;</description>
						</attribute>
					</comment>
					<params>
						<param name="name" comment="the name of the serializable field" fulltype="java.lang.String" type="String" />
						<param name="val" comment="the value to assign to the field" fulltype="char" type="char" />
					</params>
				</method>
				<method abstract="true" visibility="public" name="put" fulltype="void" type="void">
					<comment>
						<description>Put the value of the named short field into the persistent field.</description>
						<attribute name="@param">
							<description>name the name of the serializable field</description>
						</attribute>
						<attribute name="@param">
							<description>val the value to assign to the field</description>
						</attribute>
						<attribute name="@throws">
							<description>IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; does not
 match the name of a serializable field for the class whose fields
 are being written, or if the type of the named field is not
 &lt;code&gt;short&lt;/code&gt;</description>
						</attribute>
					</comment>
					<params>
						<param name="name" comment="the name of the serializable field" fulltype="java.lang.String" type="String" />
						<param name="val" comment="the value to assign to the field" fulltype="short" type="short" />
					</params>
				</method>
				<method abstract="true" visibility="public" name="put" fulltype="void" type="void">
					<comment>
						<description>Put the value of the named int field into the persistent field.</description>
						<attribute name="@param">
							<description>name the name of the serializable field</description>
						</attribute>
						<attribute name="@param">
							<description>val the value to assign to the field</description>
						</attribute>
						<attribute name="@throws">
							<description>IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; does not
 match the name of a serializable field for the class whose fields
 are being written, or if the type of the named field is not
 &lt;code&gt;int&lt;/code&gt;</description>
						</attribute>
					</comment>
					<params>
						<param name="name" comment="the name of the serializable field" fulltype="java.lang.String" type="String" />
						<param name="val" comment="the value to assign to the field" fulltype="int" type="int" />
					</params>
				</method>
				<method abstract="true" visibility="public" name="put" fulltype="void" type="void">
					<comment>
						<description>Put the value of the named long field into the persistent field.</description>
						<attribute name="@param">
							<description>name the name of the serializable field</description>
						</attribute>
						<attribute name="@param">
							<description>val the value to assign to the field</description>
						</attribute>
						<attribute name="@throws">
							<description>IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; does not
 match the name of a serializable field for the class whose fields
 are being written, or if the type of the named field is not
 &lt;code&gt;long&lt;/code&gt;</description>
						</attribute>
					</comment>
					<params>
						<param name="name" comment="the name of the serializable field" fulltype="java.lang.String" type="String" />
						<param name="val" comment="the value to assign to the field" fulltype="long" type="long" />
					</params>
				</method>
				<method abstract="true" visibility="public" name="put" fulltype="void" type="void">
					<comment>
						<description>Put the value of the named float field into the persistent field.</description>
						<attribute name="@param">
							<description>name the name of the serializable field</description>
						</attribute>
						<attribute name="@param">
							<description>val the value to assign to the field</description>
						</attribute>
						<attribute name="@throws">
							<description>IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; does not
 match the name of a serializable field for the class whose fields
 are being written, or if the type of the named field is not
 &lt;code&gt;float&lt;/code&gt;</description>
						</attribute>
					</comment>
					<params>
						<param name="name" comment="the name of the serializable field" fulltype="java.lang.String" type="String" />
						<param name="val" comment="the value to assign to the field" fulltype="float" type="float" />
					</params>
				</method>
				<method abstract="true" visibility="public" name="put" fulltype="void" type="void">
					<comment>
						<description>Put the value of the named double field into the persistent field.</description>
						<attribute name="@param">
							<description>name the name of the serializable field</description>
						</attribute>
						<attribute name="@param">
							<description>val the value to assign to the field</description>
						</attribute>
						<attribute name="@throws">
							<description>IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; does not
 match the name of a serializable field for the class whose fields
 are being written, or if the type of the named field is not
 &lt;code&gt;double&lt;/code&gt;</description>
						</attribute>
					</comment>
					<params>
						<param name="name" comment="the name of the serializable field" fulltype="java.lang.String" type="String" />
						<param name="val" comment="the value to assign to the field" fulltype="double" type="double" />
					</params>
				</method>
				<method abstract="true" visibility="public" name="put" fulltype="void" type="void">
					<comment>
						<description>Put the value of the named Object field into the persistent field.</description>
						<attribute name="@param">
							<description>name the name of the serializable field</description>
						</attribute>
						<attribute name="@param">
							<description>val the value to assign to the field
         (which may be &lt;code&gt;null&lt;/code&gt;)</description>
						</attribute>
						<attribute name="@throws">
							<description>IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; does not
 match the name of a serializable field for the class whose fields
 are being written, or if the type of the named field is not a
 reference type</description>
						</attribute>
					</comment>
					<params>
						<param name="name" comment="the name of the serializable field" fulltype="java.lang.String" type="String" />
						<param name="val" comment="the value to assign to the field
         (which may be &lt;code&gt;null&lt;/code&gt;)" fulltype="java.lang.Object" type="Object" />
					</params>
				</method>
				<method abstract="true" visibility="public" name="write" fulltype="void" type="void">
					<comment>
						<description>Write the data and fields to the specified ObjectOutput stream,
 which must be the same stream that produced this
 &lt;code&gt;PutField&lt;/code&gt; object.</description>
						<attribute name="@param">
							<description>out the stream to write the data and fields to</description>
						</attribute>
						<attribute name="@throws">
							<description>IOException if I/O errors occur while writing to the
         underlying stream</description>
						</attribute>
						<attribute name="@throws">
							<description>IllegalArgumentException if the specified stream is not
         the same stream that produced this &lt;code&gt;PutField&lt;/code&gt;
         object</description>
						</attribute>
						<attribute name="@deprecated">
							<description>This method does not write the values contained by this
         &lt;code&gt;PutField&lt;/code&gt; object in a proper format, and may
         result in corruption of the serialization stream.  The
         correct way to write &lt;code&gt;PutField&lt;/code&gt; data is by
         calling the {@link java.io.ObjectOutputStream#writeFields()}
         method.</description>
						</attribute>
					</comment>
					<params>
						<param name="out" comment="the stream to write the data and fields to" fulltype="java.io.ObjectOutput" type="ObjectOutput" />
					</params>
					<exceptions>
						<exception comment="if I/O errors occur while writing to the
         underlying stream" fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
			</methods>
		</jelclass>
		<jelclass superclass="ObjectOutputStream.PutField" visibility="private" package="java.io" superclassfulltype="java.io.ObjectOutputStream.PutField" fulltype="java.io.ObjectOutputStream.PutFieldImpl" type="ObjectOutputStream.PutFieldImpl">
			<comment>
				<description>Default PutField implementation.</description>
			</comment>
			<fields>
				<field final="true" visibility="private" name="desc" fulltype="java.io.ObjectStreamClass" type="ObjectStreamClass">
					<comment>
						<description>class descriptor describing serializable fields</description>
					</comment>
				</field>
				<field final="true" visibility="private" name="primVals" fulltype="byte[]" type="byte">
					<comment>
						<description>primitive field values</description>
					</comment>
				</field>
				<field final="true" visibility="private" name="objVals" fulltype="java.lang.Object[]" type="Object">
					<comment>
						<description>object field values</description>
					</comment>
				</field>
			</fields>
			<methods>
				<constructor visibility="package-private" name="ObjectOutputStream.PutFieldImpl">
					<comment>
						<description>Creates PutFieldImpl object for writing fields defined in given
 class descriptor.</description>
					</comment>
					<params>
						<param name="desc" fulltype="java.io.ObjectStreamClass" type="ObjectStreamClass" />
					</params>
				</constructor>
				<method visibility="public" name="put" fulltype="void" type="void">
					<params>
						<param name="name" fulltype="java.lang.String" type="String" />
						<param name="val" fulltype="boolean" type="boolean" />
					</params>
				</method>
				<method visibility="public" name="put" fulltype="void" type="void">
					<params>
						<param name="name" fulltype="java.lang.String" type="String" />
						<param name="val" fulltype="byte" type="byte" />
					</params>
				</method>
				<method visibility="public" name="put" fulltype="void" type="void">
					<params>
						<param name="name" fulltype="java.lang.String" type="String" />
						<param name="val" fulltype="char" type="char" />
					</params>
				</method>
				<method visibility="public" name="put" fulltype="void" type="void">
					<params>
						<param name="name" fulltype="java.lang.String" type="String" />
						<param name="val" fulltype="short" type="short" />
					</params>
				</method>
				<method visibility="public" name="put" fulltype="void" type="void">
					<params>
						<param name="name" fulltype="java.lang.String" type="String" />
						<param name="val" fulltype="int" type="int" />
					</params>
				</method>
				<method visibility="public" name="put" fulltype="void" type="void">
					<params>
						<param name="name" fulltype="java.lang.String" type="String" />
						<param name="val" fulltype="float" type="float" />
					</params>
				</method>
				<method visibility="public" name="put" fulltype="void" type="void">
					<params>
						<param name="name" fulltype="java.lang.String" type="String" />
						<param name="val" fulltype="long" type="long" />
					</params>
				</method>
				<method visibility="public" name="put" fulltype="void" type="void">
					<params>
						<param name="name" fulltype="java.lang.String" type="String" />
						<param name="val" fulltype="double" type="double" />
					</params>
				</method>
				<method visibility="public" name="put" fulltype="void" type="void">
					<params>
						<param name="name" fulltype="java.lang.String" type="String" />
						<param name="val" fulltype="java.lang.Object" type="Object" />
					</params>
				</method>
				<method visibility="public" name="write" fulltype="void" type="void">
					<params>
						<param name="out" fulltype="java.io.ObjectOutput" type="ObjectOutput" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="package-private" name="writeFields" fulltype="void" type="void">
					<comment>
						<description>Writes buffered primitive data and object fields to stream.</description>
					</comment>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="private" name="getFieldOffset" fulltype="int" type="int">
					<comment>
						<description>Returns offset of field with given name and type.  A specified type
 of null matches all types, Object.class matches all non-primitive
 types, and any other non-null type matches assignable types only.
 Throws IllegalArgumentException if no matching field found.</description>
					</comment>
					<params>
						<param name="name" fulltype="java.lang.String" type="String" />
						<param name="type" fulltype="java.lang.Class" type="Class" />
					</params>
				</method>
			</methods>
		</jelclass>
		<jelclass superclass="OutputStream" visibility="private" package="java.io" superclassfulltype="java.io.OutputStream" fulltype="java.io.ObjectOutputStream.BlockDataOutputStream" type="ObjectOutputStream.BlockDataOutputStream">
			<implements>
				<interface fulltype="java.io.DataOutput" type="DataOutput" />
			</implements>
			<comment>
				<description>Buffered output stream with two modes: in default mode, outputs data in
 same format as DataOutputStream; in &quot;block data&quot; mode, outputs data
 bracketed by block data markers (see object serialization specification
 for details).</description>
			</comment>
			<fields>
				<field final="true" static="true" const="1024" visibility="private" name="MAX_BLOCK_SIZE" constexpr="1024" fulltype="int" type="int">
					<comment>
						<description>maximum data block length</description>
					</comment>
				</field>
				<field final="true" static="true" const="5" visibility="private" name="MAX_HEADER_SIZE" constexpr="5" fulltype="int" type="int">
					<comment>
						<description>maximum data block header length</description>
					</comment>
				</field>
				<field final="true" static="true" const="256" visibility="private" name="CHAR_BUF_SIZE" constexpr="256" fulltype="int" type="int">
					<comment>
						<description>(tunable) length of char buffer (for writing strings)</description>
					</comment>
				</field>
				<field final="true" visibility="private" name="buf" fulltype="byte[]" type="byte">
					<comment>
						<description>buffer for writing general/block data</description>
					</comment>
				</field>
				<field final="true" visibility="private" name="hbuf" fulltype="byte[]" type="byte">
					<comment>
						<description>buffer for writing block data headers</description>
					</comment>
				</field>
				<field final="true" visibility="private" name="cbuf" fulltype="char[]" type="char">
					<comment>
						<description>char buffer for fast string writes</description>
					</comment>
				</field>
				<field visibility="private" name="blkmode" fulltype="boolean" type="boolean">
					<comment>
						<description>block data mode</description>
					</comment>
				</field>
				<field visibility="private" name="pos" fulltype="int" type="int">
					<comment>
						<description>current offset into buf</description>
					</comment>
				</field>
				<field final="true" visibility="private" name="out" fulltype="java.io.OutputStream" type="OutputStream">
					<comment>
						<description>underlying output stream</description>
					</comment>
				</field>
				<field final="true" visibility="private" name="dout" fulltype="java.io.DataOutputStream" type="DataOutputStream">
					<comment>
						<description>loopback stream (for data writes that span data blocks)</description>
					</comment>
				</field>
			</fields>
			<methods>
				<constructor visibility="package-private" name="ObjectOutputStream.BlockDataOutputStream">
					<comment>
						<description>Creates new BlockDataOutputStream on top of given underlying stream.
 Block data mode is turned off by default.</description>
					</comment>
					<params>
						<param name="out" fulltype="java.io.OutputStream" type="OutputStream" />
					</params>
				</constructor>
				<method visibility="package-private" name="setBlockDataMode" fulltype="boolean" type="boolean">
					<comment>
						<description>Sets block data mode to the given mode (true == on, false == off)
 and returns the previous mode value.  If the new mode is the same as
 the old mode, no action is taken.  If the new mode differs from the
 old mode, any buffered data is flushed before switching to the new
 mode.</description>
					</comment>
					<params>
						<param name="mode" fulltype="boolean" type="boolean" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="package-private" name="getBlockDataMode" fulltype="boolean" type="boolean">
					<comment>
						<description>Returns true if the stream is currently in block data mode, false
 otherwise.</description>
					</comment>
				</method>
				<method visibility="public" name="write" fulltype="void" type="void">
					<params>
						<param name="b" fulltype="int" type="int" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="public" name="write" fulltype="void" type="void">
					<params>
						<param name="b" fulltype="byte[]" type="byte" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="public" name="write" fulltype="void" type="void">
					<params>
						<param name="b" fulltype="byte[]" type="byte" />
						<param name="off" fulltype="int" type="int" />
						<param name="len" fulltype="int" type="int" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="public" name="flush" fulltype="void" type="void">
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="public" name="close" fulltype="void" type="void">
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="package-private" name="write" fulltype="void" type="void">
					<comment>
						<description>Writes specified span of byte values from given array.  If copy is
 true, copies the values to an intermediate buffer before writing
 them to underlying stream (to avoid exposing a reference to the
 original byte array).</description>
					</comment>
					<params>
						<param name="b" fulltype="byte[]" type="byte" />
						<param name="off" fulltype="int" type="int" />
						<param name="len" fulltype="int" type="int" />
						<param name="copy" fulltype="boolean" type="boolean" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="package-private" name="drain" fulltype="void" type="void">
					<comment>
						<description>Writes all buffered data from this stream to the underlying stream,
 but does not flush underlying stream.</description>
					</comment>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="private" name="writeBlockHeader" fulltype="void" type="void">
					<comment>
						<description>Writes block data header.  Data blocks shorter than 256 bytes are
 prefixed with a 2-byte header; all others start with a 5-byte
 header.</description>
					</comment>
					<params>
						<param name="len" fulltype="int" type="int" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="public" name="writeBoolean" fulltype="void" type="void">
					<params>
						<param name="v" fulltype="boolean" type="boolean" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="public" name="writeByte" fulltype="void" type="void">
					<params>
						<param name="v" fulltype="int" type="int" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="public" name="writeChar" fulltype="void" type="void">
					<params>
						<param name="v" fulltype="int" type="int" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="public" name="writeShort" fulltype="void" type="void">
					<params>
						<param name="v" fulltype="int" type="int" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="public" name="writeInt" fulltype="void" type="void">
					<params>
						<param name="v" fulltype="int" type="int" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="public" name="writeFloat" fulltype="void" type="void">
					<params>
						<param name="v" fulltype="float" type="float" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="public" name="writeLong" fulltype="void" type="void">
					<params>
						<param name="v" fulltype="long" type="long" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="public" name="writeDouble" fulltype="void" type="void">
					<params>
						<param name="v" fulltype="double" type="double" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="public" name="writeBytes" fulltype="void" type="void">
					<params>
						<param name="s" fulltype="java.lang.String" type="String" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="public" name="writeChars" fulltype="void" type="void">
					<params>
						<param name="s" fulltype="java.lang.String" type="String" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="public" name="writeUTF" fulltype="void" type="void">
					<params>
						<param name="s" fulltype="java.lang.String" type="String" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="package-private" name="writeBooleans" fulltype="void" type="void">
					<params>
						<param name="v" fulltype="boolean[]" type="boolean" />
						<param name="off" fulltype="int" type="int" />
						<param name="len" fulltype="int" type="int" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="package-private" name="writeChars" fulltype="void" type="void">
					<params>
						<param name="v" fulltype="char[]" type="char" />
						<param name="off" fulltype="int" type="int" />
						<param name="len" fulltype="int" type="int" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="package-private" name="writeShorts" fulltype="void" type="void">
					<params>
						<param name="v" fulltype="short[]" type="short" />
						<param name="off" fulltype="int" type="int" />
						<param name="len" fulltype="int" type="int" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="package-private" name="writeInts" fulltype="void" type="void">
					<params>
						<param name="v" fulltype="int[]" type="int" />
						<param name="off" fulltype="int" type="int" />
						<param name="len" fulltype="int" type="int" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="package-private" name="writeFloats" fulltype="void" type="void">
					<params>
						<param name="v" fulltype="float[]" type="float" />
						<param name="off" fulltype="int" type="int" />
						<param name="len" fulltype="int" type="int" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="package-private" name="writeLongs" fulltype="void" type="void">
					<params>
						<param name="v" fulltype="long[]" type="long" />
						<param name="off" fulltype="int" type="int" />
						<param name="len" fulltype="int" type="int" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="package-private" name="writeDoubles" fulltype="void" type="void">
					<params>
						<param name="v" fulltype="double[]" type="double" />
						<param name="off" fulltype="int" type="int" />
						<param name="len" fulltype="int" type="int" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="package-private" name="getUTFLength" fulltype="long" type="long">
					<comment>
						<description>Returns the length in bytes of the UTF encoding of the given string.</description>
					</comment>
					<params>
						<param name="s" fulltype="java.lang.String" type="String" />
					</params>
				</method>
				<method visibility="package-private" name="writeUTF" fulltype="void" type="void">
					<comment>
						<description>Writes the given string in UTF format.  This method is used in
 situations where the UTF encoding length of the string is already
 known; specifying it explicitly avoids a prescan of the string to
 determine its UTF length.</description>
					</comment>
					<params>
						<param name="s" fulltype="java.lang.String" type="String" />
						<param name="utflen" fulltype="long" type="long" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="package-private" name="writeLongUTF" fulltype="void" type="void">
					<comment>
						<description>Writes given string in &quot;long&quot; UTF format.  &quot;Long&quot; UTF format is
 identical to standard UTF, except that it uses an 8 byte header
 (instead of the standard 2 bytes) to convey the UTF encoding length.</description>
					</comment>
					<params>
						<param name="s" fulltype="java.lang.String" type="String" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="package-private" name="writeLongUTF" fulltype="void" type="void">
					<comment>
						<description>Writes given string in &quot;long&quot; UTF format, where the UTF encoding
 length of the string is already known.</description>
					</comment>
					<params>
						<param name="s" fulltype="java.lang.String" type="String" />
						<param name="utflen" fulltype="long" type="long" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="private" name="writeUTFBody" fulltype="void" type="void">
					<comment>
						<description>Writes the &quot;body&quot; (i.e., the UTF representation minus the 2-byte or
 8-byte length header) of the UTF encoding for the given string.</description>
					</comment>
					<params>
						<param name="s" fulltype="java.lang.String" type="String" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
			</methods>
		</jelclass>
		<jelclass superclass="Object" visibility="private" package="java.io" superclassfulltype="java.lang.Object" fulltype="java.io.ObjectOutputStream.HandleTable" type="ObjectOutputStream.HandleTable">
			<comment>
				<description>Lightweight identity hash table which maps objects to integer handles,
 assigned in ascending order.</description>
			</comment>
			<fields>
				<field visibility="private" name="size" fulltype="int" type="int" />
				<field visibility="private" name="threshold" fulltype="int" type="int" />
				<field final="true" visibility="private" name="loadFactor" fulltype="float" type="float" />
				<field visibility="private" name="spine" fulltype="int[]" type="int" />
				<field visibility="private" name="next" fulltype="int[]" type="int" />
				<field visibility="private" name="objs" fulltype="java.lang.Object[]" type="Object" />
			</fields>
			<methods>
				<constructor visibility="package-private" name="ObjectOutputStream.HandleTable">
					<comment>
						<description>Creates new HandleTable with given capacity and load factor.</description>
					</comment>
					<params>
						<param name="initialCapacity" fulltype="int" type="int" />
						<param name="loadFactor" fulltype="float" type="float" />
					</params>
				</constructor>
				<method visibility="package-private" name="assign" fulltype="int" type="int">
					<comment>
						<description>Assigns next available handle to given object, and returns handle
 value.  Handles are assigned in ascending order starting at 0.</description>
					</comment>
					<params>
						<param name="obj" fulltype="java.lang.Object" type="Object" />
					</params>
				</method>
				<method visibility="package-private" name="lookup" fulltype="int" type="int">
					<comment>
						<description>Looks up and returns handle associated with given object, or -1 if
 no mapping found.</description>
					</comment>
					<params>
						<param name="obj" fulltype="java.lang.Object" type="Object" />
					</params>
				</method>
				<method visibility="package-private" name="clear" fulltype="void" type="void">
					<comment>
						<description>Resets table to its initial (empty) state.</description>
					</comment>
				</method>
				<method visibility="package-private" name="size" fulltype="int" type="int">
					<comment>
						<description>Returns the number of mappings currently in table.</description>
					</comment>
				</method>
				<method visibility="private" name="insert" fulltype="void" type="void">
					<comment>
						<description>Inserts mapping object -&gt; handle mapping into table.  Assumes table
 is large enough to accommodate new mapping.</description>
					</comment>
					<params>
						<param name="obj" fulltype="java.lang.Object" type="Object" />
						<param name="handle" fulltype="int" type="int" />
					</params>
				</method>
				<method visibility="private" name="growSpine" fulltype="void" type="void">
					<comment>
						<description>Expands the hash &quot;spine&quot; -- equivalent to increasing the number of
 buckets in a conventional hash table.</description>
					</comment>
				</method>
				<method visibility="private" name="growEntries" fulltype="void" type="void">
					<comment>
						<description>Increases hash table capacity by lengthening entry arrays.</description>
					</comment>
				</method>
				<method visibility="private" name="hash" fulltype="int" type="int">
					<comment>
						<description>Returns hash value for given object.</description>
					</comment>
					<params>
						<param name="obj" fulltype="java.lang.Object" type="Object" />
					</params>
				</method>
			</methods>
		</jelclass>
		<jelclass superclass="Object" visibility="private" package="java.io" superclassfulltype="java.lang.Object" fulltype="java.io.ObjectOutputStream.ReplaceTable" type="ObjectOutputStream.ReplaceTable">
			<comment>
				<description>Lightweight identity hash table which maps objects to replacement
 objects.</description>
			</comment>
			<fields>
				<field final="true" visibility="private" name="htab" fulltype="java.io.ObjectOutputStream.HandleTable" type="ObjectOutputStream.HandleTable" />
				<field visibility="private" name="reps" fulltype="java.lang.Object[]" type="Object" />
			</fields>
			<methods>
				<constructor visibility="package-private" name="ObjectOutputStream.ReplaceTable">
					<comment>
						<description>Creates new ReplaceTable with given capacity and load factor.</description>
					</comment>
					<params>
						<param name="initialCapacity" fulltype="int" type="int" />
						<param name="loadFactor" fulltype="float" type="float" />
					</params>
				</constructor>
				<method visibility="package-private" name="assign" fulltype="void" type="void">
					<comment>
						<description>Enters mapping from object to replacement object.</description>
					</comment>
					<params>
						<param name="obj" fulltype="java.lang.Object" type="Object" />
						<param name="rep" fulltype="java.lang.Object" type="Object" />
					</params>
				</method>
				<method visibility="package-private" name="lookup" fulltype="java.lang.Object" type="Object">
					<comment>
						<description>Looks up and returns replacement for given object.  If no
 replacement is found, returns the lookup object itself.</description>
					</comment>
					<params>
						<param name="obj" fulltype="java.lang.Object" type="Object" />
					</params>
				</method>
				<method visibility="package-private" name="clear" fulltype="void" type="void">
					<comment>
						<description>Resets table to its initial (empty) state.</description>
					</comment>
				</method>
				<method visibility="package-private" name="size" fulltype="int" type="int">
					<comment>
						<description>Returns the number of mappings currently in table.</description>
					</comment>
				</method>
				<method visibility="private" name="grow" fulltype="void" type="void">
					<comment>
						<description>Increases table capacity.</description>
					</comment>
				</method>
			</methods>
		</jelclass>
		<jelclass superclass="Object" visibility="private" package="java.io" superclassfulltype="java.lang.Object" fulltype="java.io.ObjectOutputStream.DebugTraceInfoStack" type="ObjectOutputStream.DebugTraceInfoStack">
			<comment>
				<description>Stack to keep debug information about the state of the
 serialization process, for embedding in exception messages.</description>
			</comment>
			<fields>
				<field final="true" visibility="private" name="stack" fulltype="java.util.List" type="List" />
			</fields>
			<methods>
				<constructor visibility="package-private" name="ObjectOutputStream.DebugTraceInfoStack" />
				<method visibility="package-private" name="clear" fulltype="void" type="void">
					<comment>
						<description>Removes all of the elements from enclosed list.</description>
					</comment>
				</method>
				<method visibility="package-private" name="pop" fulltype="void" type="void">
					<comment>
						<description>Removes the object at the top of enclosed list.</description>
					</comment>
				</method>
				<method visibility="package-private" name="push" fulltype="void" type="void">
					<comment>
						<description>Pushes a String onto the top of enclosed list.</description>
					</comment>
					<params>
						<param name="entry" fulltype="java.lang.String" type="String" />
					</params>
				</method>
				<method visibility="public" name="toString" fulltype="java.lang.String" type="String">
					<comment>
						<description>Returns a string representation of this object</description>
					</comment>
				</method>
			</methods>
		</jelclass>
	</jelclass>
	<jelclass superclass="Object" visibility="private" package="java.io" superclassfulltype="java.lang.Object" fulltype="java.io.ObjectOutputStream.Caches" type="ObjectOutputStream.Caches">
		<fields>
			<field final="true" static="true" visibility="package-private" name="subclassAudits" fulltype="java.util.concurrent.ConcurrentMap" type="ConcurrentMap">
				<comment>
					<description>cache of subclass security audit results</description>
				</comment>
			</field>
			<field final="true" static="true" visibility="package-private" name="subclassAuditsQueue" fulltype="java.lang.ref.ReferenceQueue" type="ReferenceQueue">
				<comment>
					<description>queue for WeakReferences to audited subclasses</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="private" name="ObjectOutputStream.Caches" />
		</methods>
	</jelclass>
	<jelclass abstract="true" superclass="Object" visibility="public" package="java.io" superclassfulltype="java.lang.Object" fulltype="java.io.ObjectOutputStream.PutField" type="ObjectOutputStream.PutField">
		<comment>
			<description>Provide programmatic access to the persistent fields to be written
 to ObjectOutput.</description>
			<attribute name="@since">
				<description>1.2</description>
			</attribute>
		</comment>
		<methods>
			<constructor visibility="public" name="ObjectOutputStream.PutField" />
			<method abstract="true" visibility="public" name="put" fulltype="void" type="void">
				<comment>
					<description>Put the value of the named boolean field into the persistent field.</description>
					<attribute name="@param">
						<description>name the name of the serializable field</description>
					</attribute>
					<attribute name="@param">
						<description>val the value to assign to the field</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; does not
 match the name of a serializable field for the class whose fields
 are being written, or if the type of the named field is not
 &lt;code&gt;boolean&lt;/code&gt;</description>
					</attribute>
				</comment>
				<params>
					<param name="name" comment="the name of the serializable field" fulltype="java.lang.String" type="String" />
					<param name="val" comment="the value to assign to the field" fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method abstract="true" visibility="public" name="put" fulltype="void" type="void">
				<comment>
					<description>Put the value of the named byte field into the persistent field.</description>
					<attribute name="@param">
						<description>name the name of the serializable field</description>
					</attribute>
					<attribute name="@param">
						<description>val the value to assign to the field</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; does not
 match the name of a serializable field for the class whose fields
 are being written, or if the type of the named field is not
 &lt;code&gt;byte&lt;/code&gt;</description>
					</attribute>
				</comment>
				<params>
					<param name="name" comment="the name of the serializable field" fulltype="java.lang.String" type="String" />
					<param name="val" comment="the value to assign to the field" fulltype="byte" type="byte" />
				</params>
			</method>
			<method abstract="true" visibility="public" name="put" fulltype="void" type="void">
				<comment>
					<description>Put the value of the named char field into the persistent field.</description>
					<attribute name="@param">
						<description>name the name of the serializable field</description>
					</attribute>
					<attribute name="@param">
						<description>val the value to assign to the field</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; does not
 match the name of a serializable field for the class whose fields
 are being written, or if the type of the named field is not
 &lt;code&gt;char&lt;/code&gt;</description>
					</attribute>
				</comment>
				<params>
					<param name="name" comment="the name of the serializable field" fulltype="java.lang.String" type="String" />
					<param name="val" comment="the value to assign to the field" fulltype="char" type="char" />
				</params>
			</method>
			<method abstract="true" visibility="public" name="put" fulltype="void" type="void">
				<comment>
					<description>Put the value of the named short field into the persistent field.</description>
					<attribute name="@param">
						<description>name the name of the serializable field</description>
					</attribute>
					<attribute name="@param">
						<description>val the value to assign to the field</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; does not
 match the name of a serializable field for the class whose fields
 are being written, or if the type of the named field is not
 &lt;code&gt;short&lt;/code&gt;</description>
					</attribute>
				</comment>
				<params>
					<param name="name" comment="the name of the serializable field" fulltype="java.lang.String" type="String" />
					<param name="val" comment="the value to assign to the field" fulltype="short" type="short" />
				</params>
			</method>
			<method abstract="true" visibility="public" name="put" fulltype="void" type="void">
				<comment>
					<description>Put the value of the named int field into the persistent field.</description>
					<attribute name="@param">
						<description>name the name of the serializable field</description>
					</attribute>
					<attribute name="@param">
						<description>val the value to assign to the field</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; does not
 match the name of a serializable field for the class whose fields
 are being written, or if the type of the named field is not
 &lt;code&gt;int&lt;/code&gt;</description>
					</attribute>
				</comment>
				<params>
					<param name="name" comment="the name of the serializable field" fulltype="java.lang.String" type="String" />
					<param name="val" comment="the value to assign to the field" fulltype="int" type="int" />
				</params>
			</method>
			<method abstract="true" visibility="public" name="put" fulltype="void" type="void">
				<comment>
					<description>Put the value of the named long field into the persistent field.</description>
					<attribute name="@param">
						<description>name the name of the serializable field</description>
					</attribute>
					<attribute name="@param">
						<description>val the value to assign to the field</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; does not
 match the name of a serializable field for the class whose fields
 are being written, or if the type of the named field is not
 &lt;code&gt;long&lt;/code&gt;</description>
					</attribute>
				</comment>
				<params>
					<param name="name" comment="the name of the serializable field" fulltype="java.lang.String" type="String" />
					<param name="val" comment="the value to assign to the field" fulltype="long" type="long" />
				</params>
			</method>
			<method abstract="true" visibility="public" name="put" fulltype="void" type="void">
				<comment>
					<description>Put the value of the named float field into the persistent field.</description>
					<attribute name="@param">
						<description>name the name of the serializable field</description>
					</attribute>
					<attribute name="@param">
						<description>val the value to assign to the field</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; does not
 match the name of a serializable field for the class whose fields
 are being written, or if the type of the named field is not
 &lt;code&gt;float&lt;/code&gt;</description>
					</attribute>
				</comment>
				<params>
					<param name="name" comment="the name of the serializable field" fulltype="java.lang.String" type="String" />
					<param name="val" comment="the value to assign to the field" fulltype="float" type="float" />
				</params>
			</method>
			<method abstract="true" visibility="public" name="put" fulltype="void" type="void">
				<comment>
					<description>Put the value of the named double field into the persistent field.</description>
					<attribute name="@param">
						<description>name the name of the serializable field</description>
					</attribute>
					<attribute name="@param">
						<description>val the value to assign to the field</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; does not
 match the name of a serializable field for the class whose fields
 are being written, or if the type of the named field is not
 &lt;code&gt;double&lt;/code&gt;</description>
					</attribute>
				</comment>
				<params>
					<param name="name" comment="the name of the serializable field" fulltype="java.lang.String" type="String" />
					<param name="val" comment="the value to assign to the field" fulltype="double" type="double" />
				</params>
			</method>
			<method abstract="true" visibility="public" name="put" fulltype="void" type="void">
				<comment>
					<description>Put the value of the named Object field into the persistent field.</description>
					<attribute name="@param">
						<description>name the name of the serializable field</description>
					</attribute>
					<attribute name="@param">
						<description>val the value to assign to the field
         (which may be &lt;code&gt;null&lt;/code&gt;)</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; does not
 match the name of a serializable field for the class whose fields
 are being written, or if the type of the named field is not a
 reference type</description>
					</attribute>
				</comment>
				<params>
					<param name="name" comment="the name of the serializable field" fulltype="java.lang.String" type="String" />
					<param name="val" comment="the value to assign to the field
         (which may be &lt;code&gt;null&lt;/code&gt;)" fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method abstract="true" visibility="public" name="write" fulltype="void" type="void">
				<comment>
					<description>Write the data and fields to the specified ObjectOutput stream,
 which must be the same stream that produced this
 &lt;code&gt;PutField&lt;/code&gt; object.</description>
					<attribute name="@param">
						<description>out the stream to write the data and fields to</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException if I/O errors occur while writing to the
         underlying stream</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if the specified stream is not
         the same stream that produced this &lt;code&gt;PutField&lt;/code&gt;
         object</description>
					</attribute>
					<attribute name="@deprecated">
						<description>This method does not write the values contained by this
         &lt;code&gt;PutField&lt;/code&gt; object in a proper format, and may
         result in corruption of the serialization stream.  The
         correct way to write &lt;code&gt;PutField&lt;/code&gt; data is by
         calling the {@link java.io.ObjectOutputStream#writeFields()}
         method.</description>
					</attribute>
				</comment>
				<params>
					<param name="out" comment="the stream to write the data and fields to" fulltype="java.io.ObjectOutput" type="ObjectOutput" />
				</params>
				<exceptions>
					<exception comment="if I/O errors occur while writing to the
         underlying stream" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="ObjectOutputStream.PutField" visibility="private" package="java.io" superclassfulltype="java.io.ObjectOutputStream.PutField" fulltype="java.io.ObjectOutputStream.PutFieldImpl" type="ObjectOutputStream.PutFieldImpl">
		<comment>
			<description>Default PutField implementation.</description>
		</comment>
		<fields>
			<field final="true" visibility="private" name="desc" fulltype="java.io.ObjectStreamClass" type="ObjectStreamClass">
				<comment>
					<description>class descriptor describing serializable fields</description>
				</comment>
			</field>
			<field final="true" visibility="private" name="primVals" fulltype="byte[]" type="byte">
				<comment>
					<description>primitive field values</description>
				</comment>
			</field>
			<field final="true" visibility="private" name="objVals" fulltype="java.lang.Object[]" type="Object">
				<comment>
					<description>object field values</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="package-private" name="ObjectOutputStream.PutFieldImpl">
				<comment>
					<description>Creates PutFieldImpl object for writing fields defined in given
 class descriptor.</description>
				</comment>
				<params>
					<param name="desc" fulltype="java.io.ObjectStreamClass" type="ObjectStreamClass" />
				</params>
			</constructor>
			<method visibility="public" name="put" fulltype="void" type="void">
				<params>
					<param name="name" fulltype="java.lang.String" type="String" />
					<param name="val" fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method visibility="public" name="put" fulltype="void" type="void">
				<params>
					<param name="name" fulltype="java.lang.String" type="String" />
					<param name="val" fulltype="byte" type="byte" />
				</params>
			</method>
			<method visibility="public" name="put" fulltype="void" type="void">
				<params>
					<param name="name" fulltype="java.lang.String" type="String" />
					<param name="val" fulltype="char" type="char" />
				</params>
			</method>
			<method visibility="public" name="put" fulltype="void" type="void">
				<params>
					<param name="name" fulltype="java.lang.String" type="String" />
					<param name="val" fulltype="short" type="short" />
				</params>
			</method>
			<method visibility="public" name="put" fulltype="void" type="void">
				<params>
					<param name="name" fulltype="java.lang.String" type="String" />
					<param name="val" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="put" fulltype="void" type="void">
				<params>
					<param name="name" fulltype="java.lang.String" type="String" />
					<param name="val" fulltype="float" type="float" />
				</params>
			</method>
			<method visibility="public" name="put" fulltype="void" type="void">
				<params>
					<param name="name" fulltype="java.lang.String" type="String" />
					<param name="val" fulltype="long" type="long" />
				</params>
			</method>
			<method visibility="public" name="put" fulltype="void" type="void">
				<params>
					<param name="name" fulltype="java.lang.String" type="String" />
					<param name="val" fulltype="double" type="double" />
				</params>
			</method>
			<method visibility="public" name="put" fulltype="void" type="void">
				<params>
					<param name="name" fulltype="java.lang.String" type="String" />
					<param name="val" fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method visibility="public" name="write" fulltype="void" type="void">
				<params>
					<param name="out" fulltype="java.io.ObjectOutput" type="ObjectOutput" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="package-private" name="writeFields" fulltype="void" type="void">
				<comment>
					<description>Writes buffered primitive data and object fields to stream.</description>
				</comment>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="getFieldOffset" fulltype="int" type="int">
				<comment>
					<description>Returns offset of field with given name and type.  A specified type
 of null matches all types, Object.class matches all non-primitive
 types, and any other non-null type matches assignable types only.
 Throws IllegalArgumentException if no matching field found.</description>
				</comment>
				<params>
					<param name="name" fulltype="java.lang.String" type="String" />
					<param name="type" fulltype="java.lang.Class" type="Class" />
				</params>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="OutputStream" visibility="private" package="java.io" superclassfulltype="java.io.OutputStream" fulltype="java.io.ObjectOutputStream.BlockDataOutputStream" type="ObjectOutputStream.BlockDataOutputStream">
		<implements>
			<interface fulltype="java.io.DataOutput" type="DataOutput" />
		</implements>
		<comment>
			<description>Buffered output stream with two modes: in default mode, outputs data in
 same format as DataOutputStream; in &quot;block data&quot; mode, outputs data
 bracketed by block data markers (see object serialization specification
 for details).</description>
		</comment>
		<fields>
			<field final="true" static="true" const="1024" visibility="private" name="MAX_BLOCK_SIZE" constexpr="1024" fulltype="int" type="int">
				<comment>
					<description>maximum data block length</description>
				</comment>
			</field>
			<field final="true" static="true" const="5" visibility="private" name="MAX_HEADER_SIZE" constexpr="5" fulltype="int" type="int">
				<comment>
					<description>maximum data block header length</description>
				</comment>
			</field>
			<field final="true" static="true" const="256" visibility="private" name="CHAR_BUF_SIZE" constexpr="256" fulltype="int" type="int">
				<comment>
					<description>(tunable) length of char buffer (for writing strings)</description>
				</comment>
			</field>
			<field final="true" visibility="private" name="buf" fulltype="byte[]" type="byte">
				<comment>
					<description>buffer for writing general/block data</description>
				</comment>
			</field>
			<field final="true" visibility="private" name="hbuf" fulltype="byte[]" type="byte">
				<comment>
					<description>buffer for writing block data headers</description>
				</comment>
			</field>
			<field final="true" visibility="private" name="cbuf" fulltype="char[]" type="char">
				<comment>
					<description>char buffer for fast string writes</description>
				</comment>
			</field>
			<field visibility="private" name="blkmode" fulltype="boolean" type="boolean">
				<comment>
					<description>block data mode</description>
				</comment>
			</field>
			<field visibility="private" name="pos" fulltype="int" type="int">
				<comment>
					<description>current offset into buf</description>
				</comment>
			</field>
			<field final="true" visibility="private" name="out" fulltype="java.io.OutputStream" type="OutputStream">
				<comment>
					<description>underlying output stream</description>
				</comment>
			</field>
			<field final="true" visibility="private" name="dout" fulltype="java.io.DataOutputStream" type="DataOutputStream">
				<comment>
					<description>loopback stream (for data writes that span data blocks)</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="package-private" name="ObjectOutputStream.BlockDataOutputStream">
				<comment>
					<description>Creates new BlockDataOutputStream on top of given underlying stream.
 Block data mode is turned off by default.</description>
				</comment>
				<params>
					<param name="out" fulltype="java.io.OutputStream" type="OutputStream" />
				</params>
			</constructor>
			<method visibility="package-private" name="setBlockDataMode" fulltype="boolean" type="boolean">
				<comment>
					<description>Sets block data mode to the given mode (true == on, false == off)
 and returns the previous mode value.  If the new mode is the same as
 the old mode, no action is taken.  If the new mode differs from the
 old mode, any buffered data is flushed before switching to the new
 mode.</description>
				</comment>
				<params>
					<param name="mode" fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="package-private" name="getBlockDataMode" fulltype="boolean" type="boolean">
				<comment>
					<description>Returns true if the stream is currently in block data mode, false
 otherwise.</description>
				</comment>
			</method>
			<method visibility="public" name="write" fulltype="void" type="void">
				<params>
					<param name="b" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="write" fulltype="void" type="void">
				<params>
					<param name="b" fulltype="byte[]" type="byte" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="write" fulltype="void" type="void">
				<params>
					<param name="b" fulltype="byte[]" type="byte" />
					<param name="off" fulltype="int" type="int" />
					<param name="len" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="flush" fulltype="void" type="void">
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="close" fulltype="void" type="void">
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="package-private" name="write" fulltype="void" type="void">
				<comment>
					<description>Writes specified span of byte values from given array.  If copy is
 true, copies the values to an intermediate buffer before writing
 them to underlying stream (to avoid exposing a reference to the
 original byte array).</description>
				</comment>
				<params>
					<param name="b" fulltype="byte[]" type="byte" />
					<param name="off" fulltype="int" type="int" />
					<param name="len" fulltype="int" type="int" />
					<param name="copy" fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="package-private" name="drain" fulltype="void" type="void">
				<comment>
					<description>Writes all buffered data from this stream to the underlying stream,
 but does not flush underlying stream.</description>
				</comment>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="writeBlockHeader" fulltype="void" type="void">
				<comment>
					<description>Writes block data header.  Data blocks shorter than 256 bytes are
 prefixed with a 2-byte header; all others start with a 5-byte
 header.</description>
				</comment>
				<params>
					<param name="len" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="writeBoolean" fulltype="void" type="void">
				<params>
					<param name="v" fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="writeByte" fulltype="void" type="void">
				<params>
					<param name="v" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="writeChar" fulltype="void" type="void">
				<params>
					<param name="v" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="writeShort" fulltype="void" type="void">
				<params>
					<param name="v" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="writeInt" fulltype="void" type="void">
				<params>
					<param name="v" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="writeFloat" fulltype="void" type="void">
				<params>
					<param name="v" fulltype="float" type="float" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="writeLong" fulltype="void" type="void">
				<params>
					<param name="v" fulltype="long" type="long" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="writeDouble" fulltype="void" type="void">
				<params>
					<param name="v" fulltype="double" type="double" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="writeBytes" fulltype="void" type="void">
				<params>
					<param name="s" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="writeChars" fulltype="void" type="void">
				<params>
					<param name="s" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="writeUTF" fulltype="void" type="void">
				<params>
					<param name="s" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="package-private" name="writeBooleans" fulltype="void" type="void">
				<params>
					<param name="v" fulltype="boolean[]" type="boolean" />
					<param name="off" fulltype="int" type="int" />
					<param name="len" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="package-private" name="writeChars" fulltype="void" type="void">
				<params>
					<param name="v" fulltype="char[]" type="char" />
					<param name="off" fulltype="int" type="int" />
					<param name="len" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="package-private" name="writeShorts" fulltype="void" type="void">
				<params>
					<param name="v" fulltype="short[]" type="short" />
					<param name="off" fulltype="int" type="int" />
					<param name="len" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="package-private" name="writeInts" fulltype="void" type="void">
				<params>
					<param name="v" fulltype="int[]" type="int" />
					<param name="off" fulltype="int" type="int" />
					<param name="len" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="package-private" name="writeFloats" fulltype="void" type="void">
				<params>
					<param name="v" fulltype="float[]" type="float" />
					<param name="off" fulltype="int" type="int" />
					<param name="len" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="package-private" name="writeLongs" fulltype="void" type="void">
				<params>
					<param name="v" fulltype="long[]" type="long" />
					<param name="off" fulltype="int" type="int" />
					<param name="len" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="package-private" name="writeDoubles" fulltype="void" type="void">
				<params>
					<param name="v" fulltype="double[]" type="double" />
					<param name="off" fulltype="int" type="int" />
					<param name="len" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="package-private" name="getUTFLength" fulltype="long" type="long">
				<comment>
					<description>Returns the length in bytes of the UTF encoding of the given string.</description>
				</comment>
				<params>
					<param name="s" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="package-private" name="writeUTF" fulltype="void" type="void">
				<comment>
					<description>Writes the given string in UTF format.  This method is used in
 situations where the UTF encoding length of the string is already
 known; specifying it explicitly avoids a prescan of the string to
 determine its UTF length.</description>
				</comment>
				<params>
					<param name="s" fulltype="java.lang.String" type="String" />
					<param name="utflen" fulltype="long" type="long" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="package-private" name="writeLongUTF" fulltype="void" type="void">
				<comment>
					<description>Writes given string in &quot;long&quot; UTF format.  &quot;Long&quot; UTF format is
 identical to standard UTF, except that it uses an 8 byte header
 (instead of the standard 2 bytes) to convey the UTF encoding length.</description>
				</comment>
				<params>
					<param name="s" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="package-private" name="writeLongUTF" fulltype="void" type="void">
				<comment>
					<description>Writes given string in &quot;long&quot; UTF format, where the UTF encoding
 length of the string is already known.</description>
				</comment>
				<params>
					<param name="s" fulltype="java.lang.String" type="String" />
					<param name="utflen" fulltype="long" type="long" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="writeUTFBody" fulltype="void" type="void">
				<comment>
					<description>Writes the &quot;body&quot; (i.e., the UTF representation minus the 2-byte or
 8-byte length header) of the UTF encoding for the given string.</description>
				</comment>
				<params>
					<param name="s" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="Object" visibility="private" package="java.io" superclassfulltype="java.lang.Object" fulltype="java.io.ObjectOutputStream.HandleTable" type="ObjectOutputStream.HandleTable">
		<comment>
			<description>Lightweight identity hash table which maps objects to integer handles,
 assigned in ascending order.</description>
		</comment>
		<fields>
			<field visibility="private" name="size" fulltype="int" type="int" />
			<field visibility="private" name="threshold" fulltype="int" type="int" />
			<field final="true" visibility="private" name="loadFactor" fulltype="float" type="float" />
			<field visibility="private" name="spine" fulltype="int[]" type="int" />
			<field visibility="private" name="next" fulltype="int[]" type="int" />
			<field visibility="private" name="objs" fulltype="java.lang.Object[]" type="Object" />
		</fields>
		<methods>
			<constructor visibility="package-private" name="ObjectOutputStream.HandleTable">
				<comment>
					<description>Creates new HandleTable with given capacity and load factor.</description>
				</comment>
				<params>
					<param name="initialCapacity" fulltype="int" type="int" />
					<param name="loadFactor" fulltype="float" type="float" />
				</params>
			</constructor>
			<method visibility="package-private" name="assign" fulltype="int" type="int">
				<comment>
					<description>Assigns next available handle to given object, and returns handle
 value.  Handles are assigned in ascending order starting at 0.</description>
				</comment>
				<params>
					<param name="obj" fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method visibility="package-private" name="lookup" fulltype="int" type="int">
				<comment>
					<description>Looks up and returns handle associated with given object, or -1 if
 no mapping found.</description>
				</comment>
				<params>
					<param name="obj" fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method visibility="package-private" name="clear" fulltype="void" type="void">
				<comment>
					<description>Resets table to its initial (empty) state.</description>
				</comment>
			</method>
			<method visibility="package-private" name="size" fulltype="int" type="int">
				<comment>
					<description>Returns the number of mappings currently in table.</description>
				</comment>
			</method>
			<method visibility="private" name="insert" fulltype="void" type="void">
				<comment>
					<description>Inserts mapping object -&gt; handle mapping into table.  Assumes table
 is large enough to accommodate new mapping.</description>
				</comment>
				<params>
					<param name="obj" fulltype="java.lang.Object" type="Object" />
					<param name="handle" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="private" name="growSpine" fulltype="void" type="void">
				<comment>
					<description>Expands the hash &quot;spine&quot; -- equivalent to increasing the number of
 buckets in a conventional hash table.</description>
				</comment>
			</method>
			<method visibility="private" name="growEntries" fulltype="void" type="void">
				<comment>
					<description>Increases hash table capacity by lengthening entry arrays.</description>
				</comment>
			</method>
			<method visibility="private" name="hash" fulltype="int" type="int">
				<comment>
					<description>Returns hash value for given object.</description>
				</comment>
				<params>
					<param name="obj" fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="Object" visibility="private" package="java.io" superclassfulltype="java.lang.Object" fulltype="java.io.ObjectOutputStream.ReplaceTable" type="ObjectOutputStream.ReplaceTable">
		<comment>
			<description>Lightweight identity hash table which maps objects to replacement
 objects.</description>
		</comment>
		<fields>
			<field final="true" visibility="private" name="htab" fulltype="java.io.ObjectOutputStream.HandleTable" type="ObjectOutputStream.HandleTable" />
			<field visibility="private" name="reps" fulltype="java.lang.Object[]" type="Object" />
		</fields>
		<methods>
			<constructor visibility="package-private" name="ObjectOutputStream.ReplaceTable">
				<comment>
					<description>Creates new ReplaceTable with given capacity and load factor.</description>
				</comment>
				<params>
					<param name="initialCapacity" fulltype="int" type="int" />
					<param name="loadFactor" fulltype="float" type="float" />
				</params>
			</constructor>
			<method visibility="package-private" name="assign" fulltype="void" type="void">
				<comment>
					<description>Enters mapping from object to replacement object.</description>
				</comment>
				<params>
					<param name="obj" fulltype="java.lang.Object" type="Object" />
					<param name="rep" fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method visibility="package-private" name="lookup" fulltype="java.lang.Object" type="Object">
				<comment>
					<description>Looks up and returns replacement for given object.  If no
 replacement is found, returns the lookup object itself.</description>
				</comment>
				<params>
					<param name="obj" fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method visibility="package-private" name="clear" fulltype="void" type="void">
				<comment>
					<description>Resets table to its initial (empty) state.</description>
				</comment>
			</method>
			<method visibility="package-private" name="size" fulltype="int" type="int">
				<comment>
					<description>Returns the number of mappings currently in table.</description>
				</comment>
			</method>
			<method visibility="private" name="grow" fulltype="void" type="void">
				<comment>
					<description>Increases table capacity.</description>
				</comment>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="Object" visibility="private" package="java.io" superclassfulltype="java.lang.Object" fulltype="java.io.ObjectOutputStream.DebugTraceInfoStack" type="ObjectOutputStream.DebugTraceInfoStack">
		<comment>
			<description>Stack to keep debug information about the state of the
 serialization process, for embedding in exception messages.</description>
		</comment>
		<fields>
			<field final="true" visibility="private" name="stack" fulltype="java.util.List" type="List" />
		</fields>
		<methods>
			<constructor visibility="package-private" name="ObjectOutputStream.DebugTraceInfoStack" />
			<method visibility="package-private" name="clear" fulltype="void" type="void">
				<comment>
					<description>Removes all of the elements from enclosed list.</description>
				</comment>
			</method>
			<method visibility="package-private" name="pop" fulltype="void" type="void">
				<comment>
					<description>Removes the object at the top of enclosed list.</description>
				</comment>
			</method>
			<method visibility="package-private" name="push" fulltype="void" type="void">
				<comment>
					<description>Pushes a String onto the top of enclosed list.</description>
				</comment>
				<params>
					<param name="entry" fulltype="java.lang.String" type="String" />
				</params>
			</method>
			<method visibility="public" name="toString" fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns a string representation of this object</description>
				</comment>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="InputStream" visibility="public" package="java.io" superclassfulltype="java.io.InputStream" fulltype="java.io.ObjectInputStream" type="ObjectInputStream">
		<implements>
			<interface fulltype="java.io.ObjectInput" type="ObjectInput" />
			<interface fulltype="java.io.ObjectStreamConstants" type="ObjectStreamConstants" />
		</implements>
		<comment>
			<description>An ObjectInputStream deserializes primitive data and objects previously
 written using an ObjectOutputStream.

 &lt;p&gt;ObjectOutputStream and ObjectInputStream can provide an application with
 persistent storage for graphs of objects when used with a FileOutputStream
 and FileInputStream respectively.  ObjectInputStream is used to recover
 those objects previously serialized. Other uses include passing objects
 between hosts using a socket stream or for marshaling and unmarshaling
 arguments and parameters in a remote communication system.

 &lt;p&gt;ObjectInputStream ensures that the types of all objects in the graph
 created from the stream match the classes present in the Java Virtual
 Machine.  Classes are loaded as required using the standard mechanisms.

 &lt;p&gt;Only objects that support the java.io.Serializable or
 java.io.Externalizable interface can be read from streams.

 &lt;p&gt;The method &lt;code&gt;readObject&lt;/code&gt; is used to read an object from the
 stream.  Java&apos;s safe casting should be used to get the desired type.  In
 Java, strings and arrays are objects and are treated as objects during
 serialization. When read they need to be cast to the expected type.

 &lt;p&gt;Primitive data types can be read from the stream using the appropriate
 method on DataInput.

 &lt;p&gt;The default deserialization mechanism for objects restores the contents
 of each field to the value and type it had when it was written.  Fields
 declared as transient or static are ignored by the deserialization process.
 References to other objects cause those objects to be read from the stream
 as necessary.  Graphs of objects are restored correctly using a reference
 sharing mechanism.  New objects are always allocated when deserializing,
 which prevents existing objects from being overwritten.

 &lt;p&gt;Reading an object is analogous to running the constructors of a new
 object.  Memory is allocated for the object and initialized to zero (NULL).
 No-arg constructors are invoked for the non-serializable classes and then
 the fields of the serializable classes are restored from the stream starting
 with the serializable class closest to java.lang.object and finishing with
 the object&apos;s most specific class.

 &lt;p&gt;For example to read from a stream as written by the example in
 ObjectOutputStream:
 &lt;br&gt;
 &lt;pre&gt;
      FileInputStream fis = new FileInputStream(&quot;t.tmp&quot;);
      ObjectInputStream ois = new ObjectInputStream(fis);

      int i = ois.readInt();
      String today = (String) ois.readObject();
      Date date = (Date) ois.readObject();

      ois.close();
 &lt;/pre&gt;

 &lt;p&gt;Classes control how they are serialized by implementing either the
 java.io.Serializable or java.io.Externalizable interfaces.

 &lt;p&gt;Implementing the Serializable interface allows object serialization to
 save and restore the entire state of the object and it allows classes to
 evolve between the time the stream is written and the time it is read.  It
 automatically traverses references between objects, saving and restoring
 entire graphs.

 &lt;p&gt;Serializable classes that require special handling during the
 serialization and deserialization process should implement the following
 methods:&lt;p&gt;

 &lt;pre&gt;
 private void writeObject(java.io.ObjectOutputStream stream)
     throws IOException;
 private void readObject(java.io.ObjectInputStream stream)
     throws IOException, ClassNotFoundException;
 private void readObjectNoData()
     throws ObjectStreamException;
 &lt;/pre&gt;

 &lt;p&gt;The readObject method is responsible for reading and restoring the state
 of the object for its particular class using data written to the stream by
 the corresponding writeObject method.  The method does not need to concern
 itself with the state belonging to its superclasses or subclasses.  State is
 restored by reading data from the ObjectInputStream for the individual
 fields and making assignments to the appropriate fields of the object.
 Reading primitive data types is supported by DataInput.

 &lt;p&gt;Any attempt to read object data which exceeds the boundaries of the
 custom data written by the corresponding writeObject method will cause an
 OptionalDataException to be thrown with an eof field value of true.
 Non-object reads which exceed the end of the allotted data will reflect the
 end of data in the same way that they would indicate the end of the stream:
 bytewise reads will return -1 as the byte read or number of bytes read, and
 primitive reads will throw EOFExceptions.  If there is no corresponding
 writeObject method, then the end of default serialized data marks the end of
 the allotted data.

 &lt;p&gt;Primitive and object read calls issued from within a readExternal method
 behave in the same manner--if the stream is already positioned at the end of
 data written by the corresponding writeExternal method, object reads will
 throw OptionalDataExceptions with eof set to true, bytewise reads will
 return -1, and primitive reads will throw EOFExceptions.  Note that this
 behavior does not hold for streams written with the old
 &lt;code&gt;ObjectStreamConstants.PROTOCOL_VERSION_1&lt;/code&gt; protocol, in which the
 end of data written by writeExternal methods is not demarcated, and hence
 cannot be detected.

 &lt;p&gt;The readObjectNoData method is responsible for initializing the state of
 the object for its particular class in the event that the serialization
 stream does not list the given class as a superclass of the object being
 deserialized.  This may occur in cases where the receiving party uses a
 different version of the deserialized instance&apos;s class than the sending
 party, and the receiver&apos;s version extends classes that are not extended by
 the sender&apos;s version.  This may also occur if the serialization stream has
 been tampered; hence, readObjectNoData is useful for initializing
 deserialized objects properly despite a &quot;hostile&quot; or incomplete source
 stream.

 &lt;p&gt;Serialization does not read or assign values to the fields of any object
 that does not implement the java.io.Serializable interface.  Subclasses of
 Objects that are not serializable can be serializable. In this case the
 non-serializable class must have a no-arg constructor to allow its fields to
 be initialized.  In this case it is the responsibility of the subclass to
 save and restore the state of the non-serializable class. It is frequently
 the case that the fields of that class are accessible (public, package, or
 protected) or that there are get and set methods that can be used to restore
 the state.

 &lt;p&gt;Any exception that occurs while deserializing an object will be caught by
 the ObjectInputStream and abort the reading process.

 &lt;p&gt;Implementing the Externalizable interface allows the object to assume
 complete control over the contents and format of the object&apos;s serialized
 form.  The methods of the Externalizable interface, writeExternal and
 readExternal, are called to save and restore the objects state.  When
 implemented by a class they can write and read their own state using all of
 the methods of ObjectOutput and ObjectInput.  It is the responsibility of
 the objects to handle any versioning that occurs.

 &lt;p&gt;Enum constants are deserialized differently than ordinary serializable or
 externalizable objects.  The serialized form of an enum constant consists
 solely of its name; field values of the constant are not transmitted.  To
 deserialize an enum constant, ObjectInputStream reads the constant name from
 the stream; the deserialized constant is then obtained by calling the static
 method &lt;code&gt;Enum.valueOf(Class, String)&lt;/code&gt; with the enum constant&apos;s
 base type and the received constant name as arguments.  Like other
 serializable or externalizable objects, enum constants can function as the
 targets of back references appearing subsequently in the serialization
 stream.  The process by which enum constants are deserialized cannot be
 customized: any class-specific readObject, readObjectNoData, and readResolve
 methods defined by enum types are ignored during deserialization.
 Similarly, any serialPersistentFields or serialVersionUID field declarations
 are also ignored--all enum types have a fixed serialVersionUID of 0L.</description>
			<attribute name="@author">
				<description>Mike Warres</description>
			</attribute>
			<attribute name="@author">
				<description>Roger Riggs</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.DataInput</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.ObjectOutputStream</description>
			</attribute>
			<attribute name="@see">
				<description>java.io.Serializable</description>
			</attribute>
			<attribute name="@see">
				<description>&lt;a href=&quot;../../../platform/serialization/spec/input.html&quot;&gt; Object Serialization Specification, Section 3, Object Input Classes&lt;/a&gt;</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.1</description>
			</attribute>
		</comment>
		<fields>
			<field final="true" static="true" const="-1" visibility="private" name="NULL_HANDLE" constexpr="-1" fulltype="int" type="int">
				<comment>
					<description>handle value representing null</description>
				</comment>
			</field>
			<field final="true" static="true" visibility="private" name="unsharedMarker" fulltype="java.lang.Object" type="Object">
				<comment>
					<description>marker for unshared objects in internal handle table</description>
				</comment>
			</field>
			<field final="true" static="true" visibility="private" name="primClasses" fulltype="java.util.HashMap" type="HashMap">
				<comment>
					<description>table mapping primitive type names to corresponding class objects</description>
				</comment>
			</field>
			<field final="true" visibility="private" name="bin" fulltype="java.io.ObjectInputStream.BlockDataInputStream" type="ObjectInputStream.BlockDataInputStream">
				<comment>
					<description>filter stream for handling block data conversion</description>
				</comment>
			</field>
			<field final="true" visibility="private" name="vlist" fulltype="java.io.ObjectInputStream.ValidationList" type="ObjectInputStream.ValidationList">
				<comment>
					<description>validation callback list</description>
				</comment>
			</field>
			<field visibility="private" name="depth" fulltype="int" type="int">
				<comment>
					<description>recursion depth</description>
				</comment>
			</field>
			<field visibility="private" name="closed" fulltype="boolean" type="boolean">
				<comment>
					<description>whether stream is closed</description>
				</comment>
			</field>
			<field final="true" visibility="private" name="handles" fulltype="java.io.ObjectInputStream.HandleTable" type="ObjectInputStream.HandleTable">
				<comment>
					<description>wire handle -&gt; obj/exception map</description>
				</comment>
			</field>
			<field visibility="private" name="passHandle" fulltype="int" type="int">
				<comment>
					<description>scratch field for passing handle values up/down call stack</description>
				</comment>
			</field>
			<field visibility="private" name="defaultDataEnd" fulltype="boolean" type="boolean">
				<comment>
					<description>flag set when at end of field value block with no TC_ENDBLOCKDATA</description>
				</comment>
			</field>
			<field visibility="private" name="primVals" fulltype="byte[]" type="byte">
				<comment>
					<description>buffer for reading primitive field values</description>
				</comment>
			</field>
			<field final="true" visibility="private" name="enableOverride" fulltype="boolean" type="boolean">
				<comment>
					<description>if true, invoke readObjectOverride() instead of readObject()</description>
				</comment>
			</field>
			<field visibility="private" name="enableResolve" fulltype="boolean" type="boolean">
				<comment>
					<description>if true, invoke resolveObject()</description>
				</comment>
			</field>
			<field visibility="private" name="curContext" fulltype="java.io.SerialCallbackContext" type="SerialCallbackContext">
				<comment>
					<description>Context during upcalls to class-defined readObject methods; holds
 object currently being deserialized and descriptor for current class.
 Null when not during readObject upcall.</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="public" name="ObjectInputStream">
				<comment>
					<description>Creates an ObjectInputStream that reads from the specified InputStream.
 A serialization stream header is read from the stream and verified.
 This constructor will block until the corresponding ObjectOutputStream
 has written and flushed the header.

 &lt;p&gt;If a security manager is installed, this constructor will check for
 the &quot;enableSubclassImplementation&quot; SerializablePermission when invoked
 directly or indirectly by the constructor of a subclass which overrides
 the ObjectInputStream.readFields or ObjectInputStream.readUnshared
 methods.</description>
					<attribute name="@param">
						<description>in input stream to read from</description>
					</attribute>
					<attribute name="@throws">
						<description>StreamCorruptedException if the stream header is incorrect</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException if an I/O error occurs while reading stream header</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException if untrusted subclass illegally overrides
          security-sensitive methods</description>
					</attribute>
					<attribute name="@throws">
						<description>NullPointerException if &lt;code&gt;in&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</description>
					</attribute>
					<attribute name="@see">
						<description>ObjectInputStream#ObjectInputStream()</description>
					</attribute>
					<attribute name="@see">
						<description>ObjectInputStream#readFields()</description>
					</attribute>
					<attribute name="@see">
						<description>ObjectOutputStream#ObjectOutputStream(OutputStream)</description>
					</attribute>
				</comment>
				<params>
					<param name="in" comment="input stream to read from" fulltype="java.io.InputStream" type="InputStream" />
				</params>
				<exceptions>
					<exception comment="if an I/O error occurs while reading stream header" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</constructor>
			<constructor visibility="protected" name="ObjectInputStream">
				<comment>
					<description>Provide a way for subclasses that are completely reimplementing
 ObjectInputStream to not have to allocate private data just used by this
 implementation of ObjectInputStream.

 &lt;p&gt;If there is a security manager installed, this method first calls the
 security manager&apos;s &lt;code&gt;checkPermission&lt;/code&gt; method with the
 &lt;code&gt;SerializablePermission(&quot;enableSubclassImplementation&quot;)&lt;/code&gt;
 permission to ensure it&apos;s ok to enable subclassing.</description>
					<attribute name="@throws">
						<description>SecurityException if a security manager exists and its
          &lt;code&gt;checkPermission&lt;/code&gt; method denies enabling
          subclassing.</description>
					</attribute>
					<attribute name="@see">
						<description>SecurityManager#checkPermission</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.SerializablePermission</description>
					</attribute>
				</comment>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
					<exception comment="if a security manager exists and its
          &lt;code&gt;checkPermission&lt;/code&gt; method denies enabling
          subclassing." fulltype="java.lang.SecurityException" type="SecurityException" />
				</exceptions>
			</constructor>
			<method final="true" visibility="public" name="readObject" fulltype="java.lang.Object" type="Object">
				<comment>
					<description>Read an object from the ObjectInputStream.  The class of the object, the
 signature of the class, and the values of the non-transient and
 non-static fields of the class and all of its supertypes are read.
 Default deserializing for a class can be overriden using the writeObject
 and readObject methods.  Objects referenced by this object are read
 transitively so that a complete equivalent graph of objects is
 reconstructed by readObject.

 &lt;p&gt;The root object is completely restored when all of its fields and the
 objects it references are completely restored.  At this point the object
 validation callbacks are executed in order based on their registered
 priorities. The callbacks are registered by objects (in the readObject
 special methods) as they are individually restored.

 &lt;p&gt;Exceptions are thrown for problems with the InputStream and for
 classes that should not be deserialized.  All exceptions are fatal to
 the InputStream and leave it in an indeterminate state; it is up to the
 caller to ignore or recover the stream state.</description>
					<attribute name="@throws">
						<description>ClassNotFoundException Class of a serialized object cannot be
          found.</description>
					</attribute>
					<attribute name="@throws">
						<description>InvalidClassException Something is wrong with a class used by
          serialization.</description>
					</attribute>
					<attribute name="@throws">
						<description>StreamCorruptedException Control information in the
          stream is inconsistent.</description>
					</attribute>
					<attribute name="@throws">
						<description>OptionalDataException Primitive data was found in the
          stream instead of objects.</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException Any of the usual Input/Output related exceptions.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="Any of the usual Input/Output related exceptions." fulltype="java.io.IOException" type="IOException" />
					<exception comment="Class of a serialized object cannot be
          found." fulltype="java.lang.ClassNotFoundException" type="ClassNotFoundException" />
				</exceptions>
			</method>
			<method visibility="protected" name="readObjectOverride" returncomment="the Object read from the stream." fulltype="java.lang.Object" type="Object">
				<comment>
					<description>This method is called by trusted subclasses of ObjectOutputStream that
 constructed ObjectOutputStream using the protected no-arg constructor.
 The subclass is expected to provide an override method with the modifier
 &quot;final&quot;.</description>
					<attribute name="@return">
						<description>the Object read from the stream.</description>
					</attribute>
					<attribute name="@throws">
						<description>ClassNotFoundException Class definition of a serialized object
          cannot be found.</description>
					</attribute>
					<attribute name="@throws">
						<description>OptionalDataException Primitive data was found in the stream
          instead of objects.</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException if I/O errors occurred while reading from the
          underlying stream</description>
					</attribute>
					<attribute name="@see">
						<description>#ObjectInputStream()</description>
					</attribute>
					<attribute name="@see">
						<description>#readObject()</description>
					</attribute>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if I/O errors occurred while reading from the
          underlying stream" fulltype="java.io.IOException" type="IOException" />
					<exception comment="Class definition of a serialized object
          cannot be found." fulltype="java.lang.ClassNotFoundException" type="ClassNotFoundException" />
				</exceptions>
			</method>
			<method visibility="public" name="readUnshared" returncomment="reference to deserialized object" fulltype="java.lang.Object" type="Object">
				<comment>
					<description>Reads an &quot;unshared&quot; object from the ObjectInputStream.  This method is
 identical to readObject, except that it prevents subsequent calls to
 readObject and readUnshared from returning additional references to the
 deserialized instance obtained via this call.  Specifically:
 &lt;ul&gt;
   &lt;li&gt;If readUnshared is called to deserialize a back-reference (the
       stream representation of an object which has been written
       previously to the stream), an ObjectStreamException will be
       thrown.

   &lt;li&gt;If readUnshared returns successfully, then any subsequent attempts
       to deserialize back-references to the stream handle deserialized
       by readUnshared will cause an ObjectStreamException to be thrown.
 &lt;/ul&gt;
 Deserializing an object via readUnshared invalidates the stream handle
 associated with the returned object.  Note that this in itself does not
 always guarantee that the reference returned by readUnshared is unique;
 the deserialized object may define a readResolve method which returns an
 object visible to other parties, or readUnshared may return a Class
 object or enum constant obtainable elsewhere in the stream or through
 external means. If the deserialized object defines a readResolve method
 and the invocation of that method returns an array, then readUnshared
 returns a shallow clone of that array; this guarantees that the returned
 array object is unique and cannot be obtained a second time from an
 invocation of readObject or readUnshared on the ObjectInputStream,
 even if the underlying data stream has been manipulated.

 &lt;p&gt;ObjectInputStream subclasses which override this method can only be
 constructed in security contexts possessing the
 &quot;enableSubclassImplementation&quot; SerializablePermission; any attempt to
 instantiate such a subclass without this permission will cause a
 SecurityException to be thrown.</description>
					<attribute name="@return">
						<description>reference to deserialized object</description>
					</attribute>
					<attribute name="@throws">
						<description>ClassNotFoundException if class of an object to deserialize
          cannot be found</description>
					</attribute>
					<attribute name="@throws">
						<description>StreamCorruptedException if control information in the stream
          is inconsistent</description>
					</attribute>
					<attribute name="@throws">
						<description>ObjectStreamException if object to deserialize has already
          appeared in stream</description>
					</attribute>
					<attribute name="@throws">
						<description>OptionalDataException if primitive data is next in stream</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException if an I/O error occurs during deserialization</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs during deserialization" fulltype="java.io.IOException" type="IOException" />
					<exception comment="if class of an object to deserialize
          cannot be found" fulltype="java.lang.ClassNotFoundException" type="ClassNotFoundException" />
				</exceptions>
			</method>
			<method visibility="public" name="defaultReadObject" fulltype="void" type="void">
				<comment>
					<description>Read the non-static and non-transient fields of the current class from
 this stream.  This may only be called from the readObject method of the
 class being deserialized. It will throw the NotActiveException if it is
 called otherwise.</description>
					<attribute name="@throws">
						<description>ClassNotFoundException if the class of a serialized object
          could not be found.</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException if an I/O error occurs.</description>
					</attribute>
					<attribute name="@throws">
						<description>NotActiveException if the stream is not currently reading
          objects.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
					<exception comment="if the class of a serialized object
          could not be found." fulltype="java.lang.ClassNotFoundException" type="ClassNotFoundException" />
				</exceptions>
			</method>
			<method visibility="public" name="readFields" returncomment="the &lt;code&gt;GetField&lt;/code&gt; object representing the persistent
          fields of the object being deserialized" fulltype="java.io.ObjectInputStream.GetField" type="ObjectInputStream.GetField">
				<comment>
					<description>Reads the persistent fields from the stream and makes them available by
 name.</description>
					<attribute name="@return">
						<description>the &lt;code&gt;GetField&lt;/code&gt; object representing the persistent
          fields of the object being deserialized</description>
					</attribute>
					<attribute name="@throws">
						<description>ClassNotFoundException if the class of a serialized object
          could not be found.</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException if an I/O error occurs.</description>
					</attribute>
					<attribute name="@throws">
						<description>NotActiveException if the stream is not currently reading
          objects.</description>
					</attribute>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if an I/O error occurs." fulltype="java.io.IOException" type="IOException" />
					<exception comment="if the class of a serialized object
          could not be found." fulltype="java.lang.ClassNotFoundException" type="ClassNotFoundException" />
				</exceptions>
			</method>
			<method visibility="public" name="registerValidation" fulltype="void" type="void">
				<comment>
					<description>Register an object to be validated before the graph is returned.  While
 similar to resolveObject these validations are called after the entire
 graph has been reconstituted.  Typically, a readObject method will
 register the object with the stream so that when all of the objects are
 restored a final set of validations can be performed.</description>
					<attribute name="@param">
						<description>obj the object to receive the validation callback.</description>
					</attribute>
					<attribute name="@param">
						<description>prio controls the order of callbacks;zero is a good default.
          Use higher numbers to be called back earlier, lower numbers for
          later callbacks. Within a priority, callbacks are processed in
          no particular order.</description>
					</attribute>
					<attribute name="@throws">
						<description>NotActiveException The stream is not currently reading objects
          so it is invalid to register a callback.</description>
					</attribute>
					<attribute name="@throws">
						<description>InvalidObjectException The validation object is null.</description>
					</attribute>
				</comment>
				<params>
					<param name="obj" comment="the object to receive the validation callback." fulltype="java.io.ObjectInputValidation" type="ObjectInputValidation" />
					<param name="prio" comment="controls the order of callbacks;zero is a good default.
          Use higher numbers to be called back earlier, lower numbers for
          later callbacks. Within a priority, callbacks are processed in
          no particular order." fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="The stream is not currently reading objects
          so it is invalid to register a callback." fulltype="java.io.NotActiveException" type="NotActiveException" />
					<exception comment="The validation object is null." fulltype="java.io.InvalidObjectException" type="InvalidObjectException" />
				</exceptions>
			</method>
			<method visibility="protected" name="resolveClass" returncomment="a &lt;code&gt;Class&lt;/code&gt; object corresponding to &lt;code&gt;desc&lt;/code&gt;" fulltype="java.lang.Class" type="Class">
				<comment>
					<description>Load the local class equivalent of the specified stream class
 description.  Subclasses may implement this method to allow classes to
 be fetched from an alternate source.

 &lt;p&gt;The corresponding method in &lt;code&gt;ObjectOutputStream&lt;/code&gt; is
 &lt;code&gt;annotateClass&lt;/code&gt;.  This method will be invoked only once for
 each unique class in the stream.  This method can be implemented by
 subclasses to use an alternate loading mechanism but must return a
 &lt;code&gt;Class&lt;/code&gt; object. Once returned, if the class is not an array
 class, its serialVersionUID is compared to the serialVersionUID of the
 serialized class, and if there is a mismatch, the deserialization fails
 and an {@link InvalidClassException} is thrown.

 &lt;p&gt;The default implementation of this method in
 &lt;code&gt;ObjectInputStream&lt;/code&gt; returns the result of calling
 &lt;pre&gt;
     Class.forName(desc.getName(), false, loader)
 &lt;/pre&gt;
 where &lt;code&gt;loader&lt;/code&gt; is determined as follows: if there is a
 method on the current thread&apos;s stack whose declaring class was
 defined by a user-defined class loader (and was not a generated to
 implement reflective invocations), then &lt;code&gt;loader&lt;/code&gt; is class
 loader corresponding to the closest such method to the currently
 executing frame; otherwise, &lt;code&gt;loader&lt;/code&gt; is
 &lt;code&gt;null&lt;/code&gt;. If this call results in a
 &lt;code&gt;ClassNotFoundException&lt;/code&gt; and the name of the passed
 &lt;code&gt;ObjectStreamClass&lt;/code&gt; instance is the Java language keyword
 for a primitive type or void, then the &lt;code&gt;Class&lt;/code&gt; object
 representing that primitive type or void will be returned
 (e.g., an &lt;code&gt;ObjectStreamClass&lt;/code&gt; with the name
 &lt;code&gt;&quot;int&quot;&lt;/code&gt; will be resolved to &lt;code&gt;Integer.TYPE&lt;/code&gt;).
 Otherwise, the &lt;code&gt;ClassNotFoundException&lt;/code&gt; will be thrown to
 the caller of this method.</description>
					<attribute name="@param">
						<description>desc an instance of class &lt;code&gt;ObjectStreamClass&lt;/code&gt;</description>
					</attribute>
					<attribute name="@return">
						<description>a &lt;code&gt;Class&lt;/code&gt; object corresponding to &lt;code&gt;desc&lt;/code&gt;</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException any of the usual Input/Output exceptions.</description>
					</attribute>
					<attribute name="@throws">
						<description>ClassNotFoundException if class of a serialized object cannot
          be found.</description>
					</attribute>
				</comment>
				<params>
					<param name="desc" comment="an instance of class &lt;code&gt;ObjectStreamClass&lt;/code&gt;" fulltype="java.io.ObjectStreamClass" type="ObjectStreamClass" />
				</params>
				<exceptions>
					<exception comment="any of the usual Input/Output exceptions." fulltype="java.io.IOException" type="IOException" />
					<exception comment="if class of a serialized object cannot
          be found." fulltype="java.lang.ClassNotFoundException" type="ClassNotFoundException" />
				</exceptions>
			</method>
			<method visibility="protected" name="resolveProxyClass" returncomment="a proxy class for the specified interfaces" fulltype="java.lang.Class" type="Class">
				<comment>
					<description>Returns a proxy class that implements the interfaces named in a proxy
 class descriptor; subclasses may implement this method to read custom
 data from the stream along with the descriptors for dynamic proxy
 classes, allowing them to use an alternate loading mechanism for the
 interfaces and the proxy class.

 &lt;p&gt;This method is called exactly once for each unique proxy class
 descriptor in the stream.

 &lt;p&gt;The corresponding method in &lt;code&gt;ObjectOutputStream&lt;/code&gt; is
 &lt;code&gt;annotateProxyClass&lt;/code&gt;.  For a given subclass of
 &lt;code&gt;ObjectInputStream&lt;/code&gt; that overrides this method, the
 &lt;code&gt;annotateProxyClass&lt;/code&gt; method in the corresponding subclass of
 &lt;code&gt;ObjectOutputStream&lt;/code&gt; must write any data or objects read by
 this method.

 &lt;p&gt;The default implementation of this method in
 &lt;code&gt;ObjectInputStream&lt;/code&gt; returns the result of calling
 &lt;code&gt;Proxy.getProxyClass&lt;/code&gt; with the list of &lt;code&gt;Class&lt;/code&gt;
 objects for the interfaces that are named in the &lt;code&gt;interfaces&lt;/code&gt;
 parameter.  The &lt;code&gt;Class&lt;/code&gt; object for each interface name
 &lt;code&gt;i&lt;/code&gt; is the value returned by calling
 &lt;pre&gt;
     Class.forName(i, false, loader)
 &lt;/pre&gt;
 where &lt;code&gt;loader&lt;/code&gt; is that of the first non-&lt;code&gt;null&lt;/code&gt;
 class loader up the execution stack, or &lt;code&gt;null&lt;/code&gt; if no
 non-&lt;code&gt;null&lt;/code&gt; class loaders are on the stack (the same class
 loader choice used by the &lt;code&gt;resolveClass&lt;/code&gt; method).  Unless any
 of the resolved interfaces are non-public, this same value of
 &lt;code&gt;loader&lt;/code&gt; is also the class loader passed to
 &lt;code&gt;Proxy.getProxyClass&lt;/code&gt;; if non-public interfaces are present,
 their class loader is passed instead (if more than one non-public
 interface class loader is encountered, an
 &lt;code&gt;IllegalAccessError&lt;/code&gt; is thrown).
 If &lt;code&gt;Proxy.getProxyClass&lt;/code&gt; throws an
 &lt;code&gt;IllegalArgumentException&lt;/code&gt;, &lt;code&gt;resolveProxyClass&lt;/code&gt;
 will throw a &lt;code&gt;ClassNotFoundException&lt;/code&gt; containing the
 &lt;code&gt;IllegalArgumentException&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>interfaces the list of interface names that were
                deserialized in the proxy class descriptor</description>
					</attribute>
					<attribute name="@return">
						<description>a proxy class for the specified interfaces</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException any exception thrown by the underlying
                &lt;code&gt;InputStream&lt;/code&gt;</description>
					</attribute>
					<attribute name="@throws">
						<description>ClassNotFoundException if the proxy class or any of the
                named interfaces could not be found</description>
					</attribute>
					<attribute name="@see">
						<description>ObjectOutputStream#annotateProxyClass(Class)</description>
					</attribute>
					<attribute name="@since">
						<description>1.3</description>
					</attribute>
				</comment>
				<params>
					<param name="interfaces" comment="the list of interface names that were
                deserialized in the proxy class descriptor" fulltype="java.lang.String[]" type="String" />
				</params>
				<exceptions>
					<exception comment="any exception thrown by the underlying
                &lt;code&gt;InputStream&lt;/code&gt;" fulltype="java.io.IOException" type="IOException" />
					<exception comment="if the proxy class or any of the
                named interfaces could not be found" fulltype="java.lang.ClassNotFoundException" type="ClassNotFoundException" />
				</exceptions>
			</method>
			<method visibility="protected" name="resolveObject" returncomment="the substituted object" fulltype="java.lang.Object" type="Object">
				<comment>
					<description>This method will allow trusted subclasses of ObjectInputStream to
 substitute one object for another during deserialization. Replacing
 objects is disabled until enableResolveObject is called. The
 enableResolveObject method checks that the stream requesting to resolve
 object can be trusted. Every reference to serializable objects is passed
 to resolveObject.  To insure that the private state of objects is not
 unintentionally exposed only trusted streams may use resolveObject.

 &lt;p&gt;This method is called after an object has been read but before it is
 returned from readObject.  The default resolveObject method just returns
 the same object.

 &lt;p&gt;When a subclass is replacing objects it must insure that the
 substituted object is compatible with every field where the reference
 will be stored.  Objects whose type is not a subclass of the type of the
 field or array element abort the serialization by raising an exception
 and the object is not be stored.

 &lt;p&gt;This method is called only once when each object is first
 encountered.  All subsequent references to the object will be redirected
 to the new object.</description>
					<attribute name="@param">
						<description>obj object to be substituted</description>
					</attribute>
					<attribute name="@return">
						<description>the substituted object</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException Any of the usual Input/Output exceptions.</description>
					</attribute>
				</comment>
				<params>
					<param name="obj" comment="object to be substituted" fulltype="java.lang.Object" type="Object" />
				</params>
				<exceptions>
					<exception comment="Any of the usual Input/Output exceptions." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="protected" name="enableResolveObject" returncomment="the previous setting before this method was invoked" fulltype="boolean" type="boolean">
				<comment>
					<description>Enable the stream to allow objects read from the stream to be replaced.
 When enabled, the resolveObject method is called for every object being
 deserialized.

 &lt;p&gt;If &lt;i&gt;enable&lt;/i&gt; is true, and there is a security manager installed,
 this method first calls the security manager&apos;s
 &lt;code&gt;checkPermission&lt;/code&gt; method with the
 &lt;code&gt;SerializablePermission(&quot;enableSubstitution&quot;)&lt;/code&gt; permission to
 ensure it&apos;s ok to enable the stream to allow objects read from the
 stream to be replaced.</description>
					<attribute name="@param">
						<description>enable true for enabling use of &lt;code&gt;resolveObject&lt;/code&gt; for
          every object being deserialized</description>
					</attribute>
					<attribute name="@return">
						<description>the previous setting before this method was invoked</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException if a security manager exists and its
          &lt;code&gt;checkPermission&lt;/code&gt; method denies enabling the stream
          to allow objects read from the stream to be replaced.</description>
					</attribute>
					<attribute name="@see">
						<description>SecurityManager#checkPermission</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.SerializablePermission</description>
					</attribute>
				</comment>
				<params>
					<param name="enable" comment="true for enabling use of &lt;code&gt;resolveObject&lt;/code&gt; for
          every object being deserialized" fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception comment="if a security manager exists and its
          &lt;code&gt;checkPermission&lt;/code&gt; method denies enabling the stream
          to allow objects read from the stream to be replaced." fulltype="java.lang.SecurityException" type="SecurityException" />
				</exceptions>
			</method>
			<method visibility="protected" name="readStreamHeader" fulltype="void" type="void">
				<comment>
					<description>The readStreamHeader method is provided to allow subclasses to read and
 verify their own stream headers. It reads and verifies the magic number
 and version number.</description>
					<attribute name="@throws">
						<description>IOException if there are I/O errors while reading from the
          underlying &lt;code&gt;InputStream&lt;/code&gt;</description>
					</attribute>
					<attribute name="@throws">
						<description>StreamCorruptedException if control information in the stream
          is inconsistent</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if there are I/O errors while reading from the
          underlying &lt;code&gt;InputStream&lt;/code&gt;" fulltype="java.io.IOException" type="IOException" />
					<exception comment="if control information in the stream
          is inconsistent" fulltype="java.io.StreamCorruptedException" type="StreamCorruptedException" />
				</exceptions>
			</method>
			<method visibility="protected" name="readClassDescriptor" returncomment="the class descriptor read" fulltype="java.io.ObjectStreamClass" type="ObjectStreamClass">
				<comment>
					<description>Read a class descriptor from the serialization stream.  This method is
 called when the ObjectInputStream expects a class descriptor as the next
 item in the serialization stream.  Subclasses of ObjectInputStream may
 override this method to read in class descriptors that have been written
 in non-standard formats (by subclasses of ObjectOutputStream which have
 overridden the &lt;code&gt;writeClassDescriptor&lt;/code&gt; method).  By default,
 this method reads class descriptors according to the format defined in
 the Object Serialization specification.</description>
					<attribute name="@return">
						<description>the class descriptor read</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException If an I/O error has occurred.</description>
					</attribute>
					<attribute name="@throws">
						<description>ClassNotFoundException If the Class of a serialized object used
          in the class descriptor representation cannot be found</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.ObjectOutputStream#writeClassDescriptor(java.io.ObjectStreamClass)</description>
					</attribute>
					<attribute name="@since">
						<description>1.3</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If an I/O error has occurred." fulltype="java.io.IOException" type="IOException" />
					<exception comment="If the Class of a serialized object used
          in the class descriptor representation cannot be found" fulltype="java.lang.ClassNotFoundException" type="ClassNotFoundException" />
				</exceptions>
			</method>
			<method visibility="public" name="read" returncomment="the byte read, or -1 if the end of the stream is reached." fulltype="int" type="int">
				<comment>
					<description>Reads a byte of data. This method will block if no input is available.</description>
					<attribute name="@return">
						<description>the byte read, or -1 if the end of the stream is reached.</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException If an I/O error has occurred.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If an I/O error has occurred." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="read" returncomment="the actual number of bytes read, -1 is returned when the end of
          the stream is reached." fulltype="int" type="int">
				<comment>
					<description>Reads into an array of bytes.  This method will block until some input
 is available. Consider using java.io.DataInputStream.readFully to read
 exactly &apos;length&apos; bytes.</description>
					<attribute name="@param">
						<description>buf the buffer into which the data is read</description>
					</attribute>
					<attribute name="@param">
						<description>off the start offset of the data</description>
					</attribute>
					<attribute name="@param">
						<description>len the maximum number of bytes read</description>
					</attribute>
					<attribute name="@return">
						<description>the actual number of bytes read, -1 is returned when the end of
          the stream is reached.</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException If an I/O error has occurred.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.DataInputStream#readFully(byte[],int,int)</description>
					</attribute>
				</comment>
				<params>
					<param name="buf" comment="the buffer into which the data is read" fulltype="byte[]" type="byte" />
					<param name="off" comment="the start offset of the data" fulltype="int" type="int" />
					<param name="len" comment="the maximum number of bytes read" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="If an I/O error has occurred." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="available" returncomment="the number of available bytes." fulltype="int" type="int">
				<comment>
					<description>Returns the number of bytes that can be read without blocking.</description>
					<attribute name="@return">
						<description>the number of available bytes.</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException if there are I/O errors while reading from the
          underlying &lt;code&gt;InputStream&lt;/code&gt;</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if there are I/O errors while reading from the
          underlying &lt;code&gt;InputStream&lt;/code&gt;" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="close" fulltype="void" type="void">
				<comment>
					<description>Closes the input stream. Must be called to release any resources
 associated with the stream.</description>
					<attribute name="@throws">
						<description>IOException If an I/O error has occurred.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If an I/O error has occurred." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="readBoolean" returncomment="the boolean read." fulltype="boolean" type="boolean">
				<comment>
					<description>Reads in a boolean.</description>
					<attribute name="@return">
						<description>the boolean read.</description>
					</attribute>
					<attribute name="@throws">
						<description>EOFException If end of file is reached.</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException If other I/O error has occurred.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If other I/O error has occurred." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="readByte" returncomment="the 8 bit byte read." fulltype="byte" type="byte">
				<comment>
					<description>Reads an 8 bit byte.</description>
					<attribute name="@return">
						<description>the 8 bit byte read.</description>
					</attribute>
					<attribute name="@throws">
						<description>EOFException If end of file is reached.</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException If other I/O error has occurred.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If other I/O error has occurred." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="readUnsignedByte" returncomment="the 8 bit byte read." fulltype="int" type="int">
				<comment>
					<description>Reads an unsigned 8 bit byte.</description>
					<attribute name="@return">
						<description>the 8 bit byte read.</description>
					</attribute>
					<attribute name="@throws">
						<description>EOFException If end of file is reached.</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException If other I/O error has occurred.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If other I/O error has occurred." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="readChar" returncomment="the 16 bit char read." fulltype="char" type="char">
				<comment>
					<description>Reads a 16 bit char.</description>
					<attribute name="@return">
						<description>the 16 bit char read.</description>
					</attribute>
					<attribute name="@throws">
						<description>EOFException If end of file is reached.</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException If other I/O error has occurred.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If other I/O error has occurred." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="readShort" returncomment="the 16 bit short read." fulltype="short" type="short">
				<comment>
					<description>Reads a 16 bit short.</description>
					<attribute name="@return">
						<description>the 16 bit short read.</description>
					</attribute>
					<attribute name="@throws">
						<description>EOFException If end of file is reached.</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException If other I/O error has occurred.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If other I/O error has occurred." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="readUnsignedShort" returncomment="the 16 bit short read." fulltype="int" type="int">
				<comment>
					<description>Reads an unsigned 16 bit short.</description>
					<attribute name="@return">
						<description>the 16 bit short read.</description>
					</attribute>
					<attribute name="@throws">
						<description>EOFException If end of file is reached.</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException If other I/O error has occurred.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If other I/O error has occurred." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="readInt" returncomment="the 32 bit integer read." fulltype="int" type="int">
				<comment>
					<description>Reads a 32 bit int.</description>
					<attribute name="@return">
						<description>the 32 bit integer read.</description>
					</attribute>
					<attribute name="@throws">
						<description>EOFException If end of file is reached.</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException If other I/O error has occurred.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If other I/O error has occurred." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="readLong" returncomment="the read 64 bit long." fulltype="long" type="long">
				<comment>
					<description>Reads a 64 bit long.</description>
					<attribute name="@return">
						<description>the read 64 bit long.</description>
					</attribute>
					<attribute name="@throws">
						<description>EOFException If end of file is reached.</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException If other I/O error has occurred.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If other I/O error has occurred." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="readFloat" returncomment="the 32 bit float read." fulltype="float" type="float">
				<comment>
					<description>Reads a 32 bit float.</description>
					<attribute name="@return">
						<description>the 32 bit float read.</description>
					</attribute>
					<attribute name="@throws">
						<description>EOFException If end of file is reached.</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException If other I/O error has occurred.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If other I/O error has occurred." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="readDouble" returncomment="the 64 bit double read." fulltype="double" type="double">
				<comment>
					<description>Reads a 64 bit double.</description>
					<attribute name="@return">
						<description>the 64 bit double read.</description>
					</attribute>
					<attribute name="@throws">
						<description>EOFException If end of file is reached.</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException If other I/O error has occurred.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If other I/O error has occurred." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="readFully" fulltype="void" type="void">
				<comment>
					<description>Reads bytes, blocking until all bytes are read.</description>
					<attribute name="@param">
						<description>buf the buffer into which the data is read</description>
					</attribute>
					<attribute name="@throws">
						<description>EOFException If end of file is reached.</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException If other I/O error has occurred.</description>
					</attribute>
				</comment>
				<params>
					<param name="buf" comment="the buffer into which the data is read" fulltype="byte[]" type="byte" />
				</params>
				<exceptions>
					<exception comment="If other I/O error has occurred." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="readFully" fulltype="void" type="void">
				<comment>
					<description>Reads bytes, blocking until all bytes are read.</description>
					<attribute name="@param">
						<description>buf the buffer into which the data is read</description>
					</attribute>
					<attribute name="@param">
						<description>off the start offset of the data</description>
					</attribute>
					<attribute name="@param">
						<description>len the maximum number of bytes to read</description>
					</attribute>
					<attribute name="@throws">
						<description>EOFException If end of file is reached.</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException If other I/O error has occurred.</description>
					</attribute>
				</comment>
				<params>
					<param name="buf" comment="the buffer into which the data is read" fulltype="byte[]" type="byte" />
					<param name="off" comment="the start offset of the data" fulltype="int" type="int" />
					<param name="len" comment="the maximum number of bytes to read" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="If other I/O error has occurred." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="skipBytes" returncomment="the actual number of bytes skipped." fulltype="int" type="int">
				<comment>
					<description>Skips bytes.</description>
					<attribute name="@param">
						<description>len the number of bytes to be skipped</description>
					</attribute>
					<attribute name="@return">
						<description>the actual number of bytes skipped.</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException If an I/O error has occurred.</description>
					</attribute>
				</comment>
				<params>
					<param name="len" comment="the number of bytes to be skipped" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="If an I/O error has occurred." fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="readLine" returncomment="a String copy of the line." fulltype="java.lang.String" type="String">
				<comment>
					<description>Reads in a line that has been terminated by a \n, \r, \r\n or EOF.</description>
					<attribute name="@return">
						<description>a String copy of the line.</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException if there are I/O errors while reading from the
          underlying &lt;code&gt;InputStream&lt;/code&gt;</description>
					</attribute>
					<attribute name="@deprecated">
						<description>This method does not properly convert bytes to characters.
          see DataInputStream for the details and alternatives.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if there are I/O errors while reading from the
          underlying &lt;code&gt;InputStream&lt;/code&gt;" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="readUTF" returncomment="the String." fulltype="java.lang.String" type="String">
				<comment>
					<description>Reads a String in
 &lt;a href=&quot;DataInput.html#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt;
 format.</description>
					<attribute name="@return">
						<description>the String.</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException if there are I/O errors while reading from the
          underlying &lt;code&gt;InputStream&lt;/code&gt;</description>
					</attribute>
					<attribute name="@throws">
						<description>UTFDataFormatException if read bytes do not represent a valid
          modified UTF-8 encoding of a string</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="if there are I/O errors while reading from the
          underlying &lt;code&gt;InputStream&lt;/code&gt;" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="verifySubclass" fulltype="void" type="void">
				<comment>
					<description>Verifies that this (possibly subclass) instance can be constructed
 without violating security constraints: the subclass must not override
 security-sensitive non-final methods, or else the
 &quot;enableSubclassImplementation&quot; SerializablePermission is checked.</description>
				</comment>
			</method>
			<method static="true" visibility="private" name="auditSubclass" fulltype="boolean" type="boolean">
				<comment>
					<description>Performs reflective checks on given subclass to verify that it doesn&apos;t
 override security-sensitive non-final methods.  Returns true if subclass
 is &quot;safe&quot;, false otherwise.</description>
				</comment>
				<params>
					<param name="subcl" fulltype="java.lang.Class" type="Class" />
				</params>
			</method>
			<method visibility="private" name="clear" fulltype="void" type="void">
				<comment>
					<description>Clears internal data structures.</description>
				</comment>
			</method>
			<method visibility="private" name="readObject0" fulltype="java.lang.Object" type="Object">
				<comment>
					<description>Underlying readObject implementation.</description>
				</comment>
				<params>
					<param name="unshared" fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="checkResolve" fulltype="java.lang.Object" type="Object">
				<comment>
					<description>If resolveObject has been enabled and given object does not have an
 exception associated with it, calls resolveObject to determine
 replacement for object, and updates handle table accordingly.  Returns
 replacement object, or echoes provided object if no replacement
 occurred.  Expects that passHandle is set to given object&apos;s handle prior
 to calling this method.</description>
				</comment>
				<params>
					<param name="obj" fulltype="java.lang.Object" type="Object" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="package-private" name="readTypeString" fulltype="java.lang.String" type="String">
				<comment>
					<description>Reads string without allowing it to be replaced in stream.  Called from
 within ObjectStreamClass.read().</description>
				</comment>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="readNull" fulltype="java.lang.Object" type="Object">
				<comment>
					<description>Reads in null code, sets passHandle to NULL_HANDLE and returns null.</description>
				</comment>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="readHandle" fulltype="java.lang.Object" type="Object">
				<comment>
					<description>Reads in object handle, sets passHandle to the read handle, and returns
 object associated with the handle.</description>
				</comment>
				<params>
					<param name="unshared" fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="readClass" fulltype="java.lang.Class" type="Class">
				<comment>
					<description>Reads in and returns class object.  Sets passHandle to class object&apos;s
 assigned handle.  Returns null if class is unresolvable (in which case a
 ClassNotFoundException will be associated with the class&apos; handle in the
 handle table).</description>
				</comment>
				<params>
					<param name="unshared" fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="readClassDesc" fulltype="java.io.ObjectStreamClass" type="ObjectStreamClass">
				<comment>
					<description>Reads in and returns (possibly null) class descriptor.  Sets passHandle
 to class descriptor&apos;s assigned handle.  If class descriptor cannot be
 resolved to a class in the local VM, a ClassNotFoundException is
 associated with the class descriptor&apos;s handle.</description>
				</comment>
				<params>
					<param name="unshared" fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="readProxyDesc" fulltype="java.io.ObjectStreamClass" type="ObjectStreamClass">
				<comment>
					<description>Reads in and returns class descriptor for a dynamic proxy class.  Sets
 passHandle to proxy class descriptor&apos;s assigned handle.  If proxy class
 descriptor cannot be resolved to a class in the local VM, a
 ClassNotFoundException is associated with the descriptor&apos;s handle.</description>
				</comment>
				<params>
					<param name="unshared" fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="readNonProxyDesc" fulltype="java.io.ObjectStreamClass" type="ObjectStreamClass">
				<comment>
					<description>Reads in and returns class descriptor for a class that is not a dynamic
 proxy class.  Sets passHandle to class descriptor&apos;s assigned handle.  If
 class descriptor cannot be resolved to a class in the local VM, a
 ClassNotFoundException is associated with the descriptor&apos;s handle.</description>
				</comment>
				<params>
					<param name="unshared" fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="readString" fulltype="java.lang.String" type="String">
				<comment>
					<description>Reads in and returns new string.  Sets passHandle to new string&apos;s
 assigned handle.</description>
				</comment>
				<params>
					<param name="unshared" fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="readArray" fulltype="java.lang.Object" type="Object">
				<comment>
					<description>Reads in and returns array object, or null if array class is
 unresolvable.  Sets passHandle to array&apos;s assigned handle.</description>
				</comment>
				<params>
					<param name="unshared" fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="readEnum" fulltype="java.lang.Enum" type="Enum">
				<comment>
					<description>Reads in and returns enum constant, or null if enum type is
 unresolvable.  Sets passHandle to enum constant&apos;s assigned handle.</description>
				</comment>
				<params>
					<param name="unshared" fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="readOrdinaryObject" fulltype="java.lang.Object" type="Object">
				<comment>
					<description>Reads and returns &quot;ordinary&quot; (i.e., not a String, Class,
 ObjectStreamClass, array, or enum constant) object, or null if object&apos;s
 class is unresolvable (in which case a ClassNotFoundException will be
 associated with object&apos;s handle).  Sets passHandle to object&apos;s assigned
 handle.</description>
				</comment>
				<params>
					<param name="unshared" fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="readExternalData" fulltype="void" type="void">
				<comment>
					<description>If obj is non-null, reads externalizable data by invoking readExternal()
 method of obj; otherwise, attempts to skip over externalizable data.
 Expects that passHandle is set to obj&apos;s handle before this method is
 called.</description>
				</comment>
				<params>
					<param name="obj" fulltype="java.io.Externalizable" type="Externalizable" />
					<param name="desc" fulltype="java.io.ObjectStreamClass" type="ObjectStreamClass" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="readSerialData" fulltype="void" type="void">
				<comment>
					<description>Reads (or attempts to skip, if obj is null or is tagged with a
 ClassNotFoundException) instance data for each serializable class of
 object in stream, from superclass to subclass.  Expects that passHandle
 is set to obj&apos;s handle before this method is called.</description>
				</comment>
				<params>
					<param name="obj" fulltype="java.lang.Object" type="Object" />
					<param name="desc" fulltype="java.io.ObjectStreamClass" type="ObjectStreamClass" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="skipCustomData" fulltype="void" type="void">
				<comment>
					<description>Skips over all block data and objects until TC_ENDBLOCKDATA is
 encountered.</description>
				</comment>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="defaultReadFields" fulltype="void" type="void">
				<comment>
					<description>Reads in values of serializable fields declared by given class
 descriptor.  If obj is non-null, sets field values in obj.  Expects that
 passHandle is set to obj&apos;s handle before this method is called.</description>
				</comment>
				<params>
					<param name="obj" fulltype="java.lang.Object" type="Object" />
					<param name="desc" fulltype="java.io.ObjectStreamClass" type="ObjectStreamClass" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="readFatalException" fulltype="java.io.IOException" type="IOException">
				<comment>
					<description>Reads in and returns IOException that caused serialization to abort.
 All stream state is discarded prior to reading in fatal exception.  Sets
 passHandle to fatal exception&apos;s handle.</description>
				</comment>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="handleReset" fulltype="void" type="void">
				<comment>
					<description>If recursion depth is 0, clears internal data structures; otherwise,
 throws a StreamCorruptedException.  This method is called when a
 TC_RESET typecode is encountered.</description>
				</comment>
				<exceptions>
					<exception fulltype="java.io.StreamCorruptedException" type="StreamCorruptedException" />
				</exceptions>
			</method>
			<method static="true" visibility="private" name="bytesToFloats" fulltype="void" type="void">
				<comment>
					<description>Converts specified span of bytes into float values.</description>
				</comment>
				<params>
					<param name="src" fulltype="byte[]" type="byte" />
					<param name="srcpos" fulltype="int" type="int" />
					<param name="dst" fulltype="float[]" type="float" />
					<param name="dstpos" fulltype="int" type="int" />
					<param name="nfloats" fulltype="int" type="int" />
				</params>
			</method>
			<method static="true" visibility="private" name="bytesToDoubles" fulltype="void" type="void">
				<comment>
					<description>Converts specified span of bytes into double values.</description>
				</comment>
				<params>
					<param name="src" fulltype="byte[]" type="byte" />
					<param name="srcpos" fulltype="int" type="int" />
					<param name="dst" fulltype="double[]" type="double" />
					<param name="dstpos" fulltype="int" type="int" />
					<param name="ndoubles" fulltype="int" type="int" />
				</params>
			</method>
			<method static="true" visibility="private" name="latestUserDefinedLoader" fulltype="java.lang.ClassLoader" type="ClassLoader">
				<comment>
					<description>Returns the first non-null class loader (not counting class loaders of
 generated reflection implementation classes) up the execution stack, or
 null if only code from the null class loader is on the stack.  This
 method is also called via reflection by the following RMI-IIOP class:

     com.sun.corba.se.internal.util.JDKClassLoader

 This method should not be removed or its signature changed without
 corresponding modifications to the above class.</description>
				</comment>
			</method>
			<method static="true" visibility="private" name="cloneArray" fulltype="java.lang.Object" type="Object">
				<comment>
					<description>Method for cloning arrays in case of using unsharing reading</description>
				</comment>
				<params>
					<param name="array" fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
		</methods>
		<jelclass superclass="Object" visibility="private" package="java.io" superclassfulltype="java.lang.Object" fulltype="java.io.ObjectInputStream.Caches" type="ObjectInputStream.Caches">
			<fields>
				<field final="true" static="true" visibility="package-private" name="subclassAudits" fulltype="java.util.concurrent.ConcurrentMap" type="ConcurrentMap">
					<comment>
						<description>cache of subclass security audit results</description>
					</comment>
				</field>
				<field final="true" static="true" visibility="package-private" name="subclassAuditsQueue" fulltype="java.lang.ref.ReferenceQueue" type="ReferenceQueue">
					<comment>
						<description>queue for WeakReferences to audited subclasses</description>
					</comment>
				</field>
			</fields>
			<methods>
				<constructor visibility="private" name="ObjectInputStream.Caches" />
			</methods>
		</jelclass>
		<jelclass abstract="true" superclass="Object" visibility="public" package="java.io" superclassfulltype="java.lang.Object" fulltype="java.io.ObjectInputStream.GetField" type="ObjectInputStream.GetField">
			<comment>
				<description>Provide access to the persistent fields read from the input stream.</description>
			</comment>
			<methods>
				<constructor visibility="public" name="ObjectInputStream.GetField" />
				<method abstract="true" visibility="public" name="getObjectStreamClass" returncomment="the descriptor class that describes the serializable fields" fulltype="java.io.ObjectStreamClass" type="ObjectStreamClass">
					<comment>
						<description>Get the ObjectStreamClass that describes the fields in the stream.</description>
						<attribute name="@return">
							<description>the descriptor class that describes the serializable fields</description>
						</attribute>
					</comment>
				</method>
				<method abstract="true" visibility="public" name="defaulted" returncomment="true, if and only if the named field is defaulted" fulltype="boolean" type="boolean">
					<comment>
						<description>Return true if the named field is defaulted and has no value in this
 stream.</description>
						<attribute name="@param">
							<description>name the name of the field</description>
						</attribute>
						<attribute name="@return">
							<description>true, if and only if the named field is defaulted</description>
						</attribute>
						<attribute name="@throws">
							<description>IOException if there are I/O errors while reading from
         the underlying &lt;code&gt;InputStream&lt;/code&gt;</description>
						</attribute>
						<attribute name="@throws">
							<description>IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; does not
         correspond to a serializable field</description>
						</attribute>
					</comment>
					<params>
						<param name="name" comment="the name of the field" fulltype="java.lang.String" type="String" />
					</params>
					<exceptions>
						<exception comment="if there are I/O errors while reading from
         the underlying &lt;code&gt;InputStream&lt;/code&gt;" fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method abstract="true" visibility="public" name="get" returncomment="the value of the named &lt;code&gt;boolean&lt;/code&gt; field" fulltype="boolean" type="boolean">
					<comment>
						<description>Get the value of the named boolean field from the persistent field.</description>
						<attribute name="@param">
							<description>name the name of the field</description>
						</attribute>
						<attribute name="@param">
							<description>val the default value to use if &lt;code&gt;name&lt;/code&gt; does not
         have a value</description>
						</attribute>
						<attribute name="@return">
							<description>the value of the named &lt;code&gt;boolean&lt;/code&gt; field</description>
						</attribute>
						<attribute name="@throws">
							<description>IOException if there are I/O errors while reading from the
         underlying &lt;code&gt;InputStream&lt;/code&gt;</description>
						</attribute>
						<attribute name="@throws">
							<description>IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is
         not serializable or if the field type is incorrect</description>
						</attribute>
					</comment>
					<params>
						<param name="name" comment="the name of the field" fulltype="java.lang.String" type="String" />
						<param name="val" comment="the default value to use if &lt;code&gt;name&lt;/code&gt; does not
         have a value" fulltype="boolean" type="boolean" />
					</params>
					<exceptions>
						<exception comment="if there are I/O errors while reading from the
         underlying &lt;code&gt;InputStream&lt;/code&gt;" fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method abstract="true" visibility="public" name="get" returncomment="the value of the named &lt;code&gt;byte&lt;/code&gt; field" fulltype="byte" type="byte">
					<comment>
						<description>Get the value of the named byte field from the persistent field.</description>
						<attribute name="@param">
							<description>name the name of the field</description>
						</attribute>
						<attribute name="@param">
							<description>val the default value to use if &lt;code&gt;name&lt;/code&gt; does not
         have a value</description>
						</attribute>
						<attribute name="@return">
							<description>the value of the named &lt;code&gt;byte&lt;/code&gt; field</description>
						</attribute>
						<attribute name="@throws">
							<description>IOException if there are I/O errors while reading from the
         underlying &lt;code&gt;InputStream&lt;/code&gt;</description>
						</attribute>
						<attribute name="@throws">
							<description>IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is
         not serializable or if the field type is incorrect</description>
						</attribute>
					</comment>
					<params>
						<param name="name" comment="the name of the field" fulltype="java.lang.String" type="String" />
						<param name="val" comment="the default value to use if &lt;code&gt;name&lt;/code&gt; does not
         have a value" fulltype="byte" type="byte" />
					</params>
					<exceptions>
						<exception comment="if there are I/O errors while reading from the
         underlying &lt;code&gt;InputStream&lt;/code&gt;" fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method abstract="true" visibility="public" name="get" returncomment="the value of the named &lt;code&gt;char&lt;/code&gt; field" fulltype="char" type="char">
					<comment>
						<description>Get the value of the named char field from the persistent field.</description>
						<attribute name="@param">
							<description>name the name of the field</description>
						</attribute>
						<attribute name="@param">
							<description>val the default value to use if &lt;code&gt;name&lt;/code&gt; does not
         have a value</description>
						</attribute>
						<attribute name="@return">
							<description>the value of the named &lt;code&gt;char&lt;/code&gt; field</description>
						</attribute>
						<attribute name="@throws">
							<description>IOException if there are I/O errors while reading from the
         underlying &lt;code&gt;InputStream&lt;/code&gt;</description>
						</attribute>
						<attribute name="@throws">
							<description>IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is
         not serializable or if the field type is incorrect</description>
						</attribute>
					</comment>
					<params>
						<param name="name" comment="the name of the field" fulltype="java.lang.String" type="String" />
						<param name="val" comment="the default value to use if &lt;code&gt;name&lt;/code&gt; does not
         have a value" fulltype="char" type="char" />
					</params>
					<exceptions>
						<exception comment="if there are I/O errors while reading from the
         underlying &lt;code&gt;InputStream&lt;/code&gt;" fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method abstract="true" visibility="public" name="get" returncomment="the value of the named &lt;code&gt;short&lt;/code&gt; field" fulltype="short" type="short">
					<comment>
						<description>Get the value of the named short field from the persistent field.</description>
						<attribute name="@param">
							<description>name the name of the field</description>
						</attribute>
						<attribute name="@param">
							<description>val the default value to use if &lt;code&gt;name&lt;/code&gt; does not
         have a value</description>
						</attribute>
						<attribute name="@return">
							<description>the value of the named &lt;code&gt;short&lt;/code&gt; field</description>
						</attribute>
						<attribute name="@throws">
							<description>IOException if there are I/O errors while reading from the
         underlying &lt;code&gt;InputStream&lt;/code&gt;</description>
						</attribute>
						<attribute name="@throws">
							<description>IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is
         not serializable or if the field type is incorrect</description>
						</attribute>
					</comment>
					<params>
						<param name="name" comment="the name of the field" fulltype="java.lang.String" type="String" />
						<param name="val" comment="the default value to use if &lt;code&gt;name&lt;/code&gt; does not
         have a value" fulltype="short" type="short" />
					</params>
					<exceptions>
						<exception comment="if there are I/O errors while reading from the
         underlying &lt;code&gt;InputStream&lt;/code&gt;" fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method abstract="true" visibility="public" name="get" returncomment="the value of the named &lt;code&gt;int&lt;/code&gt; field" fulltype="int" type="int">
					<comment>
						<description>Get the value of the named int field from the persistent field.</description>
						<attribute name="@param">
							<description>name the name of the field</description>
						</attribute>
						<attribute name="@param">
							<description>val the default value to use if &lt;code&gt;name&lt;/code&gt; does not
         have a value</description>
						</attribute>
						<attribute name="@return">
							<description>the value of the named &lt;code&gt;int&lt;/code&gt; field</description>
						</attribute>
						<attribute name="@throws">
							<description>IOException if there are I/O errors while reading from the
         underlying &lt;code&gt;InputStream&lt;/code&gt;</description>
						</attribute>
						<attribute name="@throws">
							<description>IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is
         not serializable or if the field type is incorrect</description>
						</attribute>
					</comment>
					<params>
						<param name="name" comment="the name of the field" fulltype="java.lang.String" type="String" />
						<param name="val" comment="the default value to use if &lt;code&gt;name&lt;/code&gt; does not
         have a value" fulltype="int" type="int" />
					</params>
					<exceptions>
						<exception comment="if there are I/O errors while reading from the
         underlying &lt;code&gt;InputStream&lt;/code&gt;" fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method abstract="true" visibility="public" name="get" returncomment="the value of the named &lt;code&gt;long&lt;/code&gt; field" fulltype="long" type="long">
					<comment>
						<description>Get the value of the named long field from the persistent field.</description>
						<attribute name="@param">
							<description>name the name of the field</description>
						</attribute>
						<attribute name="@param">
							<description>val the default value to use if &lt;code&gt;name&lt;/code&gt; does not
         have a value</description>
						</attribute>
						<attribute name="@return">
							<description>the value of the named &lt;code&gt;long&lt;/code&gt; field</description>
						</attribute>
						<attribute name="@throws">
							<description>IOException if there are I/O errors while reading from the
         underlying &lt;code&gt;InputStream&lt;/code&gt;</description>
						</attribute>
						<attribute name="@throws">
							<description>IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is
         not serializable or if the field type is incorrect</description>
						</attribute>
					</comment>
					<params>
						<param name="name" comment="the name of the field" fulltype="java.lang.String" type="String" />
						<param name="val" comment="the default value to use if &lt;code&gt;name&lt;/code&gt; does not
         have a value" fulltype="long" type="long" />
					</params>
					<exceptions>
						<exception comment="if there are I/O errors while reading from the
         underlying &lt;code&gt;InputStream&lt;/code&gt;" fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method abstract="true" visibility="public" name="get" returncomment="the value of the named &lt;code&gt;float&lt;/code&gt; field" fulltype="float" type="float">
					<comment>
						<description>Get the value of the named float field from the persistent field.</description>
						<attribute name="@param">
							<description>name the name of the field</description>
						</attribute>
						<attribute name="@param">
							<description>val the default value to use if &lt;code&gt;name&lt;/code&gt; does not
         have a value</description>
						</attribute>
						<attribute name="@return">
							<description>the value of the named &lt;code&gt;float&lt;/code&gt; field</description>
						</attribute>
						<attribute name="@throws">
							<description>IOException if there are I/O errors while reading from the
         underlying &lt;code&gt;InputStream&lt;/code&gt;</description>
						</attribute>
						<attribute name="@throws">
							<description>IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is
         not serializable or if the field type is incorrect</description>
						</attribute>
					</comment>
					<params>
						<param name="name" comment="the name of the field" fulltype="java.lang.String" type="String" />
						<param name="val" comment="the default value to use if &lt;code&gt;name&lt;/code&gt; does not
         have a value" fulltype="float" type="float" />
					</params>
					<exceptions>
						<exception comment="if there are I/O errors while reading from the
         underlying &lt;code&gt;InputStream&lt;/code&gt;" fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method abstract="true" visibility="public" name="get" returncomment="the value of the named &lt;code&gt;double&lt;/code&gt; field" fulltype="double" type="double">
					<comment>
						<description>Get the value of the named double field from the persistent field.</description>
						<attribute name="@param">
							<description>name the name of the field</description>
						</attribute>
						<attribute name="@param">
							<description>val the default value to use if &lt;code&gt;name&lt;/code&gt; does not
         have a value</description>
						</attribute>
						<attribute name="@return">
							<description>the value of the named &lt;code&gt;double&lt;/code&gt; field</description>
						</attribute>
						<attribute name="@throws">
							<description>IOException if there are I/O errors while reading from the
         underlying &lt;code&gt;InputStream&lt;/code&gt;</description>
						</attribute>
						<attribute name="@throws">
							<description>IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is
         not serializable or if the field type is incorrect</description>
						</attribute>
					</comment>
					<params>
						<param name="name" comment="the name of the field" fulltype="java.lang.String" type="String" />
						<param name="val" comment="the default value to use if &lt;code&gt;name&lt;/code&gt; does not
         have a value" fulltype="double" type="double" />
					</params>
					<exceptions>
						<exception comment="if there are I/O errors while reading from the
         underlying &lt;code&gt;InputStream&lt;/code&gt;" fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method abstract="true" visibility="public" name="get" returncomment="the value of the named &lt;code&gt;Object&lt;/code&gt; field" fulltype="java.lang.Object" type="Object">
					<comment>
						<description>Get the value of the named Object field from the persistent field.</description>
						<attribute name="@param">
							<description>name the name of the field</description>
						</attribute>
						<attribute name="@param">
							<description>val the default value to use if &lt;code&gt;name&lt;/code&gt; does not
         have a value</description>
						</attribute>
						<attribute name="@return">
							<description>the value of the named &lt;code&gt;Object&lt;/code&gt; field</description>
						</attribute>
						<attribute name="@throws">
							<description>IOException if there are I/O errors while reading from the
         underlying &lt;code&gt;InputStream&lt;/code&gt;</description>
						</attribute>
						<attribute name="@throws">
							<description>IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is
         not serializable or if the field type is incorrect</description>
						</attribute>
					</comment>
					<params>
						<param name="name" comment="the name of the field" fulltype="java.lang.String" type="String" />
						<param name="val" comment="the default value to use if &lt;code&gt;name&lt;/code&gt; does not
         have a value" fulltype="java.lang.Object" type="Object" />
					</params>
					<exceptions>
						<exception comment="if there are I/O errors while reading from the
         underlying &lt;code&gt;InputStream&lt;/code&gt;" fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
			</methods>
		</jelclass>
		<jelclass superclass="ObjectInputStream.GetField" visibility="private" package="java.io" superclassfulltype="java.io.ObjectInputStream.GetField" fulltype="java.io.ObjectInputStream.GetFieldImpl" type="ObjectInputStream.GetFieldImpl">
			<comment>
				<description>Default GetField implementation.</description>
			</comment>
			<fields>
				<field final="true" visibility="private" name="desc" fulltype="java.io.ObjectStreamClass" type="ObjectStreamClass">
					<comment>
						<description>class descriptor describing serializable fields</description>
					</comment>
				</field>
				<field final="true" visibility="private" name="primVals" fulltype="byte[]" type="byte">
					<comment>
						<description>primitive field values</description>
					</comment>
				</field>
				<field final="true" visibility="private" name="objVals" fulltype="java.lang.Object[]" type="Object">
					<comment>
						<description>object field values</description>
					</comment>
				</field>
				<field final="true" visibility="private" name="objHandles" fulltype="int[]" type="int">
					<comment>
						<description>object field value handles</description>
					</comment>
				</field>
			</fields>
			<methods>
				<constructor visibility="package-private" name="ObjectInputStream.GetFieldImpl">
					<comment>
						<description>Creates GetFieldImpl object for reading fields defined in given
 class descriptor.</description>
					</comment>
					<params>
						<param name="desc" fulltype="java.io.ObjectStreamClass" type="ObjectStreamClass" />
					</params>
				</constructor>
				<method visibility="public" name="getObjectStreamClass" fulltype="java.io.ObjectStreamClass" type="ObjectStreamClass" />
				<method visibility="public" name="defaulted" fulltype="boolean" type="boolean">
					<params>
						<param name="name" fulltype="java.lang.String" type="String" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="public" name="get" fulltype="boolean" type="boolean">
					<params>
						<param name="name" fulltype="java.lang.String" type="String" />
						<param name="val" fulltype="boolean" type="boolean" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="public" name="get" fulltype="byte" type="byte">
					<params>
						<param name="name" fulltype="java.lang.String" type="String" />
						<param name="val" fulltype="byte" type="byte" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="public" name="get" fulltype="char" type="char">
					<params>
						<param name="name" fulltype="java.lang.String" type="String" />
						<param name="val" fulltype="char" type="char" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="public" name="get" fulltype="short" type="short">
					<params>
						<param name="name" fulltype="java.lang.String" type="String" />
						<param name="val" fulltype="short" type="short" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="public" name="get" fulltype="int" type="int">
					<params>
						<param name="name" fulltype="java.lang.String" type="String" />
						<param name="val" fulltype="int" type="int" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="public" name="get" fulltype="float" type="float">
					<params>
						<param name="name" fulltype="java.lang.String" type="String" />
						<param name="val" fulltype="float" type="float" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="public" name="get" fulltype="long" type="long">
					<params>
						<param name="name" fulltype="java.lang.String" type="String" />
						<param name="val" fulltype="long" type="long" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="public" name="get" fulltype="double" type="double">
					<params>
						<param name="name" fulltype="java.lang.String" type="String" />
						<param name="val" fulltype="double" type="double" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="public" name="get" fulltype="java.lang.Object" type="Object">
					<params>
						<param name="name" fulltype="java.lang.String" type="String" />
						<param name="val" fulltype="java.lang.Object" type="Object" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="package-private" name="readFields" fulltype="void" type="void">
					<comment>
						<description>Reads primitive and object field values from stream.</description>
					</comment>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="private" name="getFieldOffset" fulltype="int" type="int">
					<comment>
						<description>Returns offset of field with given name and type.  A specified type
 of null matches all types, Object.class matches all non-primitive
 types, and any other non-null type matches assignable types only.
 If no matching field is found in the (incoming) class
 descriptor but a matching field is present in the associated local
 class descriptor, returns -1.  Throws IllegalArgumentException if
 neither incoming nor local class descriptor contains a match.</description>
					</comment>
					<params>
						<param name="name" fulltype="java.lang.String" type="String" />
						<param name="type" fulltype="java.lang.Class" type="Class" />
					</params>
				</method>
			</methods>
		</jelclass>
		<jelclass superclass="Object" visibility="private" package="java.io" superclassfulltype="java.lang.Object" fulltype="java.io.ObjectInputStream.ValidationList" type="ObjectInputStream.ValidationList">
			<comment>
				<description>Prioritized list of callbacks to be performed once object graph has been
 completely deserialized.</description>
			</comment>
			<fields>
				<field visibility="private" name="list" fulltype="java.io.ObjectInputStream.ValidationList.Callback" type="ObjectInputStream.ValidationList.Callback">
					<comment>
						<description>linked list of callbacks</description>
					</comment>
				</field>
			</fields>
			<methods>
				<constructor visibility="package-private" name="ObjectInputStream.ValidationList">
					<comment>
						<description>Creates new (empty) ValidationList.</description>
					</comment>
				</constructor>
				<method visibility="package-private" name="register" fulltype="void" type="void">
					<comment>
						<description>Registers callback.  Throws InvalidObjectException if callback
 object is null.</description>
					</comment>
					<params>
						<param name="obj" fulltype="java.io.ObjectInputValidation" type="ObjectInputValidation" />
						<param name="priority" fulltype="int" type="int" />
					</params>
					<exceptions>
						<exception fulltype="java.io.InvalidObjectException" type="InvalidObjectException" />
					</exceptions>
				</method>
				<method visibility="package-private" name="doCallbacks" fulltype="void" type="void">
					<comment>
						<description>Invokes all registered callbacks and clears the callback list.
 Callbacks with higher priorities are called first; those with equal
 priorities may be called in any order.  If any of the callbacks
 throws an InvalidObjectException, the callback process is terminated
 and the exception propagated upwards.</description>
					</comment>
					<exceptions>
						<exception fulltype="java.io.InvalidObjectException" type="InvalidObjectException" />
					</exceptions>
				</method>
				<method visibility="public" name="clear" fulltype="void" type="void">
					<comment>
						<description>Resets the callback list to its initial (empty) state.</description>
					</comment>
				</method>
			</methods>
			<jelclass superclass="Object" visibility="private" package="java.io" superclassfulltype="java.lang.Object" fulltype="java.io.ObjectInputStream.ValidationList.Callback" type="ObjectInputStream.ValidationList.Callback">
				<fields>
					<field final="true" visibility="package-private" name="obj" fulltype="java.io.ObjectInputValidation" type="ObjectInputValidation" />
					<field final="true" visibility="package-private" name="priority" fulltype="int" type="int" />
					<field visibility="package-private" name="next" fulltype="java.io.ObjectInputStream.ValidationList.Callback" type="ObjectInputStream.ValidationList.Callback" />
					<field final="true" visibility="package-private" name="acc" fulltype="java.security.AccessControlContext" type="AccessControlContext" />
				</fields>
				<methods>
					<constructor visibility="package-private" name="ObjectInputStream.ValidationList.Callback">
						<params>
							<param name="obj" fulltype="java.io.ObjectInputValidation" type="ObjectInputValidation" />
							<param name="priority" fulltype="int" type="int" />
							<param name="next" fulltype="java.io.ObjectInputStream.ValidationList.Callback" type="ObjectInputStream.ValidationList.Callback" />
							<param name="acc" fulltype="java.security.AccessControlContext" type="AccessControlContext" />
						</params>
					</constructor>
				</methods>
			</jelclass>
		</jelclass>
		<jelclass superclass="InputStream" visibility="private" package="java.io" superclassfulltype="java.io.InputStream" fulltype="java.io.ObjectInputStream.PeekInputStream" type="ObjectInputStream.PeekInputStream">
			<comment>
				<description>Input stream supporting single-byte peek operations.</description>
			</comment>
			<fields>
				<field final="true" visibility="private" name="in" fulltype="java.io.InputStream" type="InputStream">
					<comment>
						<description>underlying stream</description>
					</comment>
				</field>
				<field visibility="private" name="peekb" fulltype="int" type="int">
					<comment>
						<description>peeked byte</description>
					</comment>
				</field>
			</fields>
			<methods>
				<constructor visibility="package-private" name="ObjectInputStream.PeekInputStream">
					<comment>
						<description>Creates new PeekInputStream on top of given underlying stream.</description>
					</comment>
					<params>
						<param name="in" fulltype="java.io.InputStream" type="InputStream" />
					</params>
				</constructor>
				<method visibility="package-private" name="peek" fulltype="int" type="int">
					<comment>
						<description>Peeks at next byte value in stream.  Similar to read(), except
 that it does not consume the read value.</description>
					</comment>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="public" name="read" fulltype="int" type="int">
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="public" name="read" fulltype="int" type="int">
					<params>
						<param name="b" fulltype="byte[]" type="byte" />
						<param name="off" fulltype="int" type="int" />
						<param name="len" fulltype="int" type="int" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="package-private" name="readFully" fulltype="void" type="void">
					<params>
						<param name="b" fulltype="byte[]" type="byte" />
						<param name="off" fulltype="int" type="int" />
						<param name="len" fulltype="int" type="int" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="public" name="skip" fulltype="long" type="long">
					<params>
						<param name="n" fulltype="long" type="long" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="public" name="available" fulltype="int" type="int">
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="public" name="close" fulltype="void" type="void">
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
			</methods>
		</jelclass>
		<jelclass superclass="InputStream" visibility="private" package="java.io" superclassfulltype="java.io.InputStream" fulltype="java.io.ObjectInputStream.BlockDataInputStream" type="ObjectInputStream.BlockDataInputStream">
			<implements>
				<interface fulltype="java.io.DataInput" type="DataInput" />
			</implements>
			<comment>
				<description>Input stream with two modes: in default mode, inputs data written in the
 same format as DataOutputStream; in &quot;block data&quot; mode, inputs data
 bracketed by block data markers (see object serialization specification
 for details).  Buffering depends on block data mode: when in default
 mode, no data is buffered in advance; when in block data mode, all data
 for the current data block is read in at once (and buffered).</description>
			</comment>
			<fields>
				<field final="true" static="true" const="1024" visibility="private" name="MAX_BLOCK_SIZE" constexpr="1024" fulltype="int" type="int">
					<comment>
						<description>maximum data block length</description>
					</comment>
				</field>
				<field final="true" static="true" const="5" visibility="private" name="MAX_HEADER_SIZE" constexpr="5" fulltype="int" type="int">
					<comment>
						<description>maximum data block header length</description>
					</comment>
				</field>
				<field final="true" static="true" const="256" visibility="private" name="CHAR_BUF_SIZE" constexpr="256" fulltype="int" type="int">
					<comment>
						<description>(tunable) length of char buffer (for reading strings)</description>
					</comment>
				</field>
				<field final="true" static="true" const="-2" visibility="private" name="HEADER_BLOCKED" constexpr="-2" fulltype="int" type="int">
					<comment>
						<description>readBlockHeader() return value indicating header read may block</description>
					</comment>
				</field>
				<field final="true" visibility="private" name="buf" fulltype="byte[]" type="byte">
					<comment>
						<description>buffer for reading general/block data</description>
					</comment>
				</field>
				<field final="true" visibility="private" name="hbuf" fulltype="byte[]" type="byte">
					<comment>
						<description>buffer for reading block data headers</description>
					</comment>
				</field>
				<field final="true" visibility="private" name="cbuf" fulltype="char[]" type="char">
					<comment>
						<description>char buffer for fast string reads</description>
					</comment>
				</field>
				<field visibility="private" name="blkmode" fulltype="boolean" type="boolean">
					<comment>
						<description>block data mode</description>
					</comment>
				</field>
				<field visibility="private" name="pos" fulltype="int" type="int">
					<comment>
						<description>current offset into buf</description>
					</comment>
				</field>
				<field visibility="private" name="end" fulltype="int" type="int">
					<comment>
						<description>end offset of valid data in buf, or -1 if no more block data</description>
					</comment>
				</field>
				<field visibility="private" name="unread" fulltype="int" type="int">
					<comment>
						<description>number of bytes in current block yet to be read from stream</description>
					</comment>
				</field>
				<field final="true" visibility="private" name="in" fulltype="java.io.ObjectInputStream.PeekInputStream" type="ObjectInputStream.PeekInputStream">
					<comment>
						<description>underlying stream (wrapped in peekable filter stream)</description>
					</comment>
				</field>
				<field final="true" visibility="private" name="din" fulltype="java.io.DataInputStream" type="DataInputStream">
					<comment>
						<description>loopback stream (for data reads that span data blocks)</description>
					</comment>
				</field>
			</fields>
			<methods>
				<constructor visibility="package-private" name="ObjectInputStream.BlockDataInputStream">
					<comment>
						<description>Creates new BlockDataInputStream on top of given underlying stream.
 Block data mode is turned off by default.</description>
					</comment>
					<params>
						<param name="in" fulltype="java.io.InputStream" type="InputStream" />
					</params>
				</constructor>
				<method visibility="package-private" name="setBlockDataMode" fulltype="boolean" type="boolean">
					<comment>
						<description>Sets block data mode to the given mode (true == on, false == off)
 and returns the previous mode value.  If the new mode is the same as
 the old mode, no action is taken.  Throws IllegalStateException if
 block data mode is being switched from on to off while unconsumed
 block data is still present in the stream.</description>
					</comment>
					<params>
						<param name="newmode" fulltype="boolean" type="boolean" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="package-private" name="getBlockDataMode" fulltype="boolean" type="boolean">
					<comment>
						<description>Returns true if the stream is currently in block data mode, false
 otherwise.</description>
					</comment>
				</method>
				<method visibility="package-private" name="skipBlockData" fulltype="void" type="void">
					<comment>
						<description>If in block data mode, skips to the end of the current group of data
 blocks (but does not unset block data mode).  If not in block data
 mode, throws an IllegalStateException.</description>
					</comment>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="private" name="readBlockHeader" fulltype="int" type="int">
					<comment>
						<description>Attempts to read in the next block data header (if any).  If
 canBlock is false and a full header cannot be read without possibly
 blocking, returns HEADER_BLOCKED, else if the next element in the
 stream is a block data header, returns the block data length
 specified by the header, else returns -1.</description>
					</comment>
					<params>
						<param name="canBlock" fulltype="boolean" type="boolean" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="private" name="refill" fulltype="void" type="void">
					<comment>
						<description>Refills internal buffer buf with block data.  Any data in buf at the
 time of the call is considered consumed.  Sets the pos, end, and
 unread fields to reflect the new amount of available block data; if
 the next element in the stream is not a data block, sets pos and
 unread to 0 and end to -1.</description>
					</comment>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="package-private" name="currentBlockRemaining" fulltype="int" type="int">
					<comment>
						<description>If in block data mode, returns the number of unconsumed bytes
 remaining in the current data block.  If not in block data mode,
 throws an IllegalStateException.</description>
					</comment>
				</method>
				<method visibility="package-private" name="peek" fulltype="int" type="int">
					<comment>
						<description>Peeks at (but does not consume) and returns the next byte value in
 the stream, or -1 if the end of the stream/block data (if in block
 data mode) has been reached.</description>
					</comment>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="package-private" name="peekByte" fulltype="byte" type="byte">
					<comment>
						<description>Peeks at (but does not consume) and returns the next byte value in
 the stream, or throws EOFException if end of stream/block data has
 been reached.</description>
					</comment>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="public" name="read" fulltype="int" type="int">
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="public" name="read" fulltype="int" type="int">
					<params>
						<param name="b" fulltype="byte[]" type="byte" />
						<param name="off" fulltype="int" type="int" />
						<param name="len" fulltype="int" type="int" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="public" name="skip" fulltype="long" type="long">
					<params>
						<param name="len" fulltype="long" type="long" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="public" name="available" fulltype="int" type="int">
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="public" name="close" fulltype="void" type="void">
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="package-private" name="read" fulltype="int" type="int">
					<comment>
						<description>Attempts to read len bytes into byte array b at offset off.  Returns
 the number of bytes read, or -1 if the end of stream/block data has
 been reached.  If copy is true, reads values into an intermediate
 buffer before copying them to b (to avoid exposing a reference to
 b).</description>
					</comment>
					<params>
						<param name="b" fulltype="byte[]" type="byte" />
						<param name="off" fulltype="int" type="int" />
						<param name="len" fulltype="int" type="int" />
						<param name="copy" fulltype="boolean" type="boolean" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="public" name="readFully" fulltype="void" type="void">
					<params>
						<param name="b" fulltype="byte[]" type="byte" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="public" name="readFully" fulltype="void" type="void">
					<params>
						<param name="b" fulltype="byte[]" type="byte" />
						<param name="off" fulltype="int" type="int" />
						<param name="len" fulltype="int" type="int" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="public" name="readFully" fulltype="void" type="void">
					<params>
						<param name="b" fulltype="byte[]" type="byte" />
						<param name="off" fulltype="int" type="int" />
						<param name="len" fulltype="int" type="int" />
						<param name="copy" fulltype="boolean" type="boolean" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="public" name="skipBytes" fulltype="int" type="int">
					<params>
						<param name="n" fulltype="int" type="int" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="public" name="readBoolean" fulltype="boolean" type="boolean">
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="public" name="readByte" fulltype="byte" type="byte">
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="public" name="readUnsignedByte" fulltype="int" type="int">
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="public" name="readChar" fulltype="char" type="char">
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="public" name="readShort" fulltype="short" type="short">
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="public" name="readUnsignedShort" fulltype="int" type="int">
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="public" name="readInt" fulltype="int" type="int">
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="public" name="readFloat" fulltype="float" type="float">
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="public" name="readLong" fulltype="long" type="long">
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="public" name="readDouble" fulltype="double" type="double">
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="public" name="readUTF" fulltype="java.lang.String" type="String">
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="public" name="readLine" fulltype="java.lang.String" type="String">
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="package-private" name="readBooleans" fulltype="void" type="void">
					<params>
						<param name="v" fulltype="boolean[]" type="boolean" />
						<param name="off" fulltype="int" type="int" />
						<param name="len" fulltype="int" type="int" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="package-private" name="readChars" fulltype="void" type="void">
					<params>
						<param name="v" fulltype="char[]" type="char" />
						<param name="off" fulltype="int" type="int" />
						<param name="len" fulltype="int" type="int" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="package-private" name="readShorts" fulltype="void" type="void">
					<params>
						<param name="v" fulltype="short[]" type="short" />
						<param name="off" fulltype="int" type="int" />
						<param name="len" fulltype="int" type="int" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="package-private" name="readInts" fulltype="void" type="void">
					<params>
						<param name="v" fulltype="int[]" type="int" />
						<param name="off" fulltype="int" type="int" />
						<param name="len" fulltype="int" type="int" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="package-private" name="readFloats" fulltype="void" type="void">
					<params>
						<param name="v" fulltype="float[]" type="float" />
						<param name="off" fulltype="int" type="int" />
						<param name="len" fulltype="int" type="int" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="package-private" name="readLongs" fulltype="void" type="void">
					<params>
						<param name="v" fulltype="long[]" type="long" />
						<param name="off" fulltype="int" type="int" />
						<param name="len" fulltype="int" type="int" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="package-private" name="readDoubles" fulltype="void" type="void">
					<params>
						<param name="v" fulltype="double[]" type="double" />
						<param name="off" fulltype="int" type="int" />
						<param name="len" fulltype="int" type="int" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="package-private" name="readLongUTF" fulltype="java.lang.String" type="String">
					<comment>
						<description>Reads in string written in &quot;long&quot; UTF format.  &quot;Long&quot; UTF format is
 identical to standard UTF, except that it uses an 8 byte header
 (instead of the standard 2 bytes) to convey the UTF encoding length.</description>
					</comment>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="private" name="readUTFBody" fulltype="java.lang.String" type="String">
					<comment>
						<description>Reads in the &quot;body&quot; (i.e., the UTF representation minus the 2-byte
 or 8-byte length header) of a UTF encoding, which occupies the next
 utflen bytes.</description>
					</comment>
					<params>
						<param name="utflen" fulltype="long" type="long" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="private" name="readUTFSpan" fulltype="long" type="long">
					<comment>
						<description>Reads span of UTF-encoded characters out of internal buffer
 (starting at offset pos and ending at or before offset end),
 consuming no more than utflen bytes.  Appends read characters to
 sbuf.  Returns the number of bytes consumed.</description>
					</comment>
					<params>
						<param name="sbuf" fulltype="java.lang.StringBuilder" type="StringBuilder" />
						<param name="utflen" fulltype="long" type="long" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
				<method visibility="private" name="readUTFChar" fulltype="int" type="int">
					<comment>
						<description>Reads in single UTF-encoded character one byte at a time, appends
 the character to sbuf, and returns the number of bytes consumed.
 This method is used when reading in UTF strings written in block
 data mode to handle UTF-encoded characters which (potentially)
 straddle block-data boundaries.</description>
					</comment>
					<params>
						<param name="sbuf" fulltype="java.lang.StringBuilder" type="StringBuilder" />
						<param name="utflen" fulltype="long" type="long" />
					</params>
					<exceptions>
						<exception fulltype="java.io.IOException" type="IOException" />
					</exceptions>
				</method>
			</methods>
		</jelclass>
		<jelclass superclass="Object" visibility="private" package="java.io" superclassfulltype="java.lang.Object" fulltype="java.io.ObjectInputStream.HandleTable" type="ObjectInputStream.HandleTable">
			<comment>
				<description>Unsynchronized table which tracks wire handle to object mappings, as
 well as ClassNotFoundExceptions associated with deserialized objects.
 This class implements an exception-propagation algorithm for
 determining which objects should have ClassNotFoundExceptions associated
 with them, taking into account cycles and discontinuities (e.g., skipped
 fields) in the object graph.

 &lt;p&gt;General use of the table is as follows: during deserialization, a
 given object is first assigned a handle by calling the assign method.
 This method leaves the assigned handle in an &quot;open&quot; state, wherein
 dependencies on the exception status of other handles can be registered
 by calling the markDependency method, or an exception can be directly
 associated with the handle by calling markException.  When a handle is
 tagged with an exception, the HandleTable assumes responsibility for
 propagating the exception to any other objects which depend
 (transitively) on the exception-tagged object.

 &lt;p&gt;Once all exception information/dependencies for the handle have been
 registered, the handle should be &quot;closed&quot; by calling the finish method
 on it.  The act of finishing a handle allows the exception propagation
 algorithm to aggressively prune dependency links, lessening the
 performance/memory impact of exception tracking.

 &lt;p&gt;Note that the exception propagation algorithm used depends on handles
 being assigned/finished in LIFO order; however, for simplicity as well
 as memory conservation, it does not enforce this constraint.</description>
			</comment>
			<fields>
				<field final="true" static="true" const="1" visibility="private" name="STATUS_OK" constexpr="1" fulltype="byte" type="byte" />
				<field final="true" static="true" const="2" visibility="private" name="STATUS_UNKNOWN" constexpr="2" fulltype="byte" type="byte" />
				<field final="true" static="true" const="3" visibility="private" name="STATUS_EXCEPTION" constexpr="3" fulltype="byte" type="byte" />
				<field visibility="package-private" name="status" fulltype="byte[]" type="byte">
					<comment>
						<description>array mapping handle -&gt; object status</description>
					</comment>
				</field>
				<field visibility="package-private" name="entries" fulltype="java.lang.Object[]" type="Object">
					<comment>
						<description>array mapping handle -&gt; object/exception (depending on status)</description>
					</comment>
				</field>
				<field visibility="package-private" name="deps" fulltype="java.io.ObjectInputStream.HandleTable.HandleList[]" type="ObjectInputStream.HandleTable.HandleList">
					<comment>
						<description>array mapping handle -&gt; list of dependent handles (if any)</description>
					</comment>
				</field>
				<field visibility="package-private" name="lowDep" fulltype="int" type="int">
					<comment>
						<description>lowest unresolved dependency</description>
					</comment>
				</field>
				<field visibility="package-private" name="size" fulltype="int" type="int">
					<comment>
						<description>number of handles in table</description>
					</comment>
				</field>
			</fields>
			<methods>
				<constructor visibility="package-private" name="ObjectInputStream.HandleTable">
					<comment>
						<description>Creates handle table with the given initial capacity.</description>
					</comment>
					<params>
						<param name="initialCapacity" fulltype="int" type="int" />
					</params>
				</constructor>
				<method visibility="package-private" name="assign" fulltype="int" type="int">
					<comment>
						<description>Assigns next available handle to given object, and returns assigned
 handle.  Once object has been completely deserialized (and all
 dependencies on other objects identified), the handle should be
 &quot;closed&quot; by passing it to finish().</description>
					</comment>
					<params>
						<param name="obj" fulltype="java.lang.Object" type="Object" />
					</params>
				</method>
				<method visibility="package-private" name="markDependency" fulltype="void" type="void">
					<comment>
						<description>Registers a dependency (in exception status) of one handle on
 another.  The dependent handle must be &quot;open&quot; (i.e., assigned, but
 not finished yet).  No action is taken if either dependent or target
 handle is NULL_HANDLE.</description>
					</comment>
					<params>
						<param name="dependent" fulltype="int" type="int" />
						<param name="target" fulltype="int" type="int" />
					</params>
				</method>
				<method visibility="package-private" name="markException" fulltype="void" type="void">
					<comment>
						<description>Associates a ClassNotFoundException (if one not already associated)
 with the currently active handle and propagates it to other
 referencing objects as appropriate.  The specified handle must be
 &quot;open&quot; (i.e., assigned, but not finished yet).</description>
					</comment>
					<params>
						<param name="handle" fulltype="int" type="int" />
						<param name="ex" fulltype="java.lang.ClassNotFoundException" type="ClassNotFoundException" />
					</params>
				</method>
				<method visibility="package-private" name="finish" fulltype="void" type="void">
					<comment>
						<description>Marks given handle as finished, meaning that no new dependencies
 will be marked for handle.  Calls to the assign and finish methods
 must occur in LIFO order.</description>
					</comment>
					<params>
						<param name="handle" fulltype="int" type="int" />
					</params>
				</method>
				<method visibility="package-private" name="setObject" fulltype="void" type="void">
					<comment>
						<description>Assigns a new object to the given handle.  The object previously
 associated with the handle is forgotten.  This method has no effect
 if the given handle already has an exception associated with it.
 This method may be called at any time after the handle is assigned.</description>
					</comment>
					<params>
						<param name="handle" fulltype="int" type="int" />
						<param name="obj" fulltype="java.lang.Object" type="Object" />
					</params>
				</method>
				<method visibility="package-private" name="lookupObject" fulltype="java.lang.Object" type="Object">
					<comment>
						<description>Looks up and returns object associated with the given handle.
 Returns null if the given handle is NULL_HANDLE, or if it has an
 associated ClassNotFoundException.</description>
					</comment>
					<params>
						<param name="handle" fulltype="int" type="int" />
					</params>
				</method>
				<method visibility="package-private" name="lookupException" fulltype="java.lang.ClassNotFoundException" type="ClassNotFoundException">
					<comment>
						<description>Looks up and returns ClassNotFoundException associated with the
 given handle.  Returns null if the given handle is NULL_HANDLE, or
 if there is no ClassNotFoundException associated with the handle.</description>
					</comment>
					<params>
						<param name="handle" fulltype="int" type="int" />
					</params>
				</method>
				<method visibility="package-private" name="clear" fulltype="void" type="void">
					<comment>
						<description>Resets table to its initial state.</description>
					</comment>
				</method>
				<method visibility="package-private" name="size" fulltype="int" type="int">
					<comment>
						<description>Returns number of handles registered in table.</description>
					</comment>
				</method>
				<method visibility="private" name="grow" fulltype="void" type="void">
					<comment>
						<description>Expands capacity of internal arrays.</description>
					</comment>
				</method>
			</methods>
			<jelclass superclass="Object" visibility="private" package="java.io" superclassfulltype="java.lang.Object" fulltype="java.io.ObjectInputStream.HandleTable.HandleList" type="ObjectInputStream.HandleTable.HandleList">
				<comment>
					<description>Simple growable list of (integer) handles.</description>
				</comment>
				<fields>
					<field visibility="private" name="list" fulltype="int[]" type="int" />
					<field visibility="private" name="size" fulltype="int" type="int" />
				</fields>
				<methods>
					<constructor visibility="public" name="ObjectInputStream.HandleTable.HandleList" />
					<method visibility="public" name="add" fulltype="void" type="void">
						<params>
							<param name="handle" fulltype="int" type="int" />
						</params>
					</method>
					<method visibility="public" name="get" fulltype="int" type="int">
						<params>
							<param name="index" fulltype="int" type="int" />
						</params>
					</method>
					<method visibility="public" name="size" fulltype="int" type="int" />
				</methods>
			</jelclass>
		</jelclass>
	</jelclass>
	<jelclass superclass="Object" visibility="private" package="java.io" superclassfulltype="java.lang.Object" fulltype="java.io.ObjectInputStream.Caches" type="ObjectInputStream.Caches">
		<fields>
			<field final="true" static="true" visibility="package-private" name="subclassAudits" fulltype="java.util.concurrent.ConcurrentMap" type="ConcurrentMap">
				<comment>
					<description>cache of subclass security audit results</description>
				</comment>
			</field>
			<field final="true" static="true" visibility="package-private" name="subclassAuditsQueue" fulltype="java.lang.ref.ReferenceQueue" type="ReferenceQueue">
				<comment>
					<description>queue for WeakReferences to audited subclasses</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="private" name="ObjectInputStream.Caches" />
		</methods>
	</jelclass>
	<jelclass abstract="true" superclass="Object" visibility="public" package="java.io" superclassfulltype="java.lang.Object" fulltype="java.io.ObjectInputStream.GetField" type="ObjectInputStream.GetField">
		<comment>
			<description>Provide access to the persistent fields read from the input stream.</description>
		</comment>
		<methods>
			<constructor visibility="public" name="ObjectInputStream.GetField" />
			<method abstract="true" visibility="public" name="getObjectStreamClass" returncomment="the descriptor class that describes the serializable fields" fulltype="java.io.ObjectStreamClass" type="ObjectStreamClass">
				<comment>
					<description>Get the ObjectStreamClass that describes the fields in the stream.</description>
					<attribute name="@return">
						<description>the descriptor class that describes the serializable fields</description>
					</attribute>
				</comment>
			</method>
			<method abstract="true" visibility="public" name="defaulted" returncomment="true, if and only if the named field is defaulted" fulltype="boolean" type="boolean">
				<comment>
					<description>Return true if the named field is defaulted and has no value in this
 stream.</description>
					<attribute name="@param">
						<description>name the name of the field</description>
					</attribute>
					<attribute name="@return">
						<description>true, if and only if the named field is defaulted</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException if there are I/O errors while reading from
         the underlying &lt;code&gt;InputStream&lt;/code&gt;</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; does not
         correspond to a serializable field</description>
					</attribute>
				</comment>
				<params>
					<param name="name" comment="the name of the field" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception comment="if there are I/O errors while reading from
         the underlying &lt;code&gt;InputStream&lt;/code&gt;" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="public" name="get" returncomment="the value of the named &lt;code&gt;boolean&lt;/code&gt; field" fulltype="boolean" type="boolean">
				<comment>
					<description>Get the value of the named boolean field from the persistent field.</description>
					<attribute name="@param">
						<description>name the name of the field</description>
					</attribute>
					<attribute name="@param">
						<description>val the default value to use if &lt;code&gt;name&lt;/code&gt; does not
         have a value</description>
					</attribute>
					<attribute name="@return">
						<description>the value of the named &lt;code&gt;boolean&lt;/code&gt; field</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException if there are I/O errors while reading from the
         underlying &lt;code&gt;InputStream&lt;/code&gt;</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is
         not serializable or if the field type is incorrect</description>
					</attribute>
				</comment>
				<params>
					<param name="name" comment="the name of the field" fulltype="java.lang.String" type="String" />
					<param name="val" comment="the default value to use if &lt;code&gt;name&lt;/code&gt; does not
         have a value" fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception comment="if there are I/O errors while reading from the
         underlying &lt;code&gt;InputStream&lt;/code&gt;" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="public" name="get" returncomment="the value of the named &lt;code&gt;byte&lt;/code&gt; field" fulltype="byte" type="byte">
				<comment>
					<description>Get the value of the named byte field from the persistent field.</description>
					<attribute name="@param">
						<description>name the name of the field</description>
					</attribute>
					<attribute name="@param">
						<description>val the default value to use if &lt;code&gt;name&lt;/code&gt; does not
         have a value</description>
					</attribute>
					<attribute name="@return">
						<description>the value of the named &lt;code&gt;byte&lt;/code&gt; field</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException if there are I/O errors while reading from the
         underlying &lt;code&gt;InputStream&lt;/code&gt;</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is
         not serializable or if the field type is incorrect</description>
					</attribute>
				</comment>
				<params>
					<param name="name" comment="the name of the field" fulltype="java.lang.String" type="String" />
					<param name="val" comment="the default value to use if &lt;code&gt;name&lt;/code&gt; does not
         have a value" fulltype="byte" type="byte" />
				</params>
				<exceptions>
					<exception comment="if there are I/O errors while reading from the
         underlying &lt;code&gt;InputStream&lt;/code&gt;" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="public" name="get" returncomment="the value of the named &lt;code&gt;char&lt;/code&gt; field" fulltype="char" type="char">
				<comment>
					<description>Get the value of the named char field from the persistent field.</description>
					<attribute name="@param">
						<description>name the name of the field</description>
					</attribute>
					<attribute name="@param">
						<description>val the default value to use if &lt;code&gt;name&lt;/code&gt; does not
         have a value</description>
					</attribute>
					<attribute name="@return">
						<description>the value of the named &lt;code&gt;char&lt;/code&gt; field</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException if there are I/O errors while reading from the
         underlying &lt;code&gt;InputStream&lt;/code&gt;</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is
         not serializable or if the field type is incorrect</description>
					</attribute>
				</comment>
				<params>
					<param name="name" comment="the name of the field" fulltype="java.lang.String" type="String" />
					<param name="val" comment="the default value to use if &lt;code&gt;name&lt;/code&gt; does not
         have a value" fulltype="char" type="char" />
				</params>
				<exceptions>
					<exception comment="if there are I/O errors while reading from the
         underlying &lt;code&gt;InputStream&lt;/code&gt;" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="public" name="get" returncomment="the value of the named &lt;code&gt;short&lt;/code&gt; field" fulltype="short" type="short">
				<comment>
					<description>Get the value of the named short field from the persistent field.</description>
					<attribute name="@param">
						<description>name the name of the field</description>
					</attribute>
					<attribute name="@param">
						<description>val the default value to use if &lt;code&gt;name&lt;/code&gt; does not
         have a value</description>
					</attribute>
					<attribute name="@return">
						<description>the value of the named &lt;code&gt;short&lt;/code&gt; field</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException if there are I/O errors while reading from the
         underlying &lt;code&gt;InputStream&lt;/code&gt;</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is
         not serializable or if the field type is incorrect</description>
					</attribute>
				</comment>
				<params>
					<param name="name" comment="the name of the field" fulltype="java.lang.String" type="String" />
					<param name="val" comment="the default value to use if &lt;code&gt;name&lt;/code&gt; does not
         have a value" fulltype="short" type="short" />
				</params>
				<exceptions>
					<exception comment="if there are I/O errors while reading from the
         underlying &lt;code&gt;InputStream&lt;/code&gt;" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="public" name="get" returncomment="the value of the named &lt;code&gt;int&lt;/code&gt; field" fulltype="int" type="int">
				<comment>
					<description>Get the value of the named int field from the persistent field.</description>
					<attribute name="@param">
						<description>name the name of the field</description>
					</attribute>
					<attribute name="@param">
						<description>val the default value to use if &lt;code&gt;name&lt;/code&gt; does not
         have a value</description>
					</attribute>
					<attribute name="@return">
						<description>the value of the named &lt;code&gt;int&lt;/code&gt; field</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException if there are I/O errors while reading from the
         underlying &lt;code&gt;InputStream&lt;/code&gt;</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is
         not serializable or if the field type is incorrect</description>
					</attribute>
				</comment>
				<params>
					<param name="name" comment="the name of the field" fulltype="java.lang.String" type="String" />
					<param name="val" comment="the default value to use if &lt;code&gt;name&lt;/code&gt; does not
         have a value" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception comment="if there are I/O errors while reading from the
         underlying &lt;code&gt;InputStream&lt;/code&gt;" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="public" name="get" returncomment="the value of the named &lt;code&gt;long&lt;/code&gt; field" fulltype="long" type="long">
				<comment>
					<description>Get the value of the named long field from the persistent field.</description>
					<attribute name="@param">
						<description>name the name of the field</description>
					</attribute>
					<attribute name="@param">
						<description>val the default value to use if &lt;code&gt;name&lt;/code&gt; does not
         have a value</description>
					</attribute>
					<attribute name="@return">
						<description>the value of the named &lt;code&gt;long&lt;/code&gt; field</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException if there are I/O errors while reading from the
         underlying &lt;code&gt;InputStream&lt;/code&gt;</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is
         not serializable or if the field type is incorrect</description>
					</attribute>
				</comment>
				<params>
					<param name="name" comment="the name of the field" fulltype="java.lang.String" type="String" />
					<param name="val" comment="the default value to use if &lt;code&gt;name&lt;/code&gt; does not
         have a value" fulltype="long" type="long" />
				</params>
				<exceptions>
					<exception comment="if there are I/O errors while reading from the
         underlying &lt;code&gt;InputStream&lt;/code&gt;" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="public" name="get" returncomment="the value of the named &lt;code&gt;float&lt;/code&gt; field" fulltype="float" type="float">
				<comment>
					<description>Get the value of the named float field from the persistent field.</description>
					<attribute name="@param">
						<description>name the name of the field</description>
					</attribute>
					<attribute name="@param">
						<description>val the default value to use if &lt;code&gt;name&lt;/code&gt; does not
         have a value</description>
					</attribute>
					<attribute name="@return">
						<description>the value of the named &lt;code&gt;float&lt;/code&gt; field</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException if there are I/O errors while reading from the
         underlying &lt;code&gt;InputStream&lt;/code&gt;</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is
         not serializable or if the field type is incorrect</description>
					</attribute>
				</comment>
				<params>
					<param name="name" comment="the name of the field" fulltype="java.lang.String" type="String" />
					<param name="val" comment="the default value to use if &lt;code&gt;name&lt;/code&gt; does not
         have a value" fulltype="float" type="float" />
				</params>
				<exceptions>
					<exception comment="if there are I/O errors while reading from the
         underlying &lt;code&gt;InputStream&lt;/code&gt;" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="public" name="get" returncomment="the value of the named &lt;code&gt;double&lt;/code&gt; field" fulltype="double" type="double">
				<comment>
					<description>Get the value of the named double field from the persistent field.</description>
					<attribute name="@param">
						<description>name the name of the field</description>
					</attribute>
					<attribute name="@param">
						<description>val the default value to use if &lt;code&gt;name&lt;/code&gt; does not
         have a value</description>
					</attribute>
					<attribute name="@return">
						<description>the value of the named &lt;code&gt;double&lt;/code&gt; field</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException if there are I/O errors while reading from the
         underlying &lt;code&gt;InputStream&lt;/code&gt;</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is
         not serializable or if the field type is incorrect</description>
					</attribute>
				</comment>
				<params>
					<param name="name" comment="the name of the field" fulltype="java.lang.String" type="String" />
					<param name="val" comment="the default value to use if &lt;code&gt;name&lt;/code&gt; does not
         have a value" fulltype="double" type="double" />
				</params>
				<exceptions>
					<exception comment="if there are I/O errors while reading from the
         underlying &lt;code&gt;InputStream&lt;/code&gt;" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method abstract="true" visibility="public" name="get" returncomment="the value of the named &lt;code&gt;Object&lt;/code&gt; field" fulltype="java.lang.Object" type="Object">
				<comment>
					<description>Get the value of the named Object field from the persistent field.</description>
					<attribute name="@param">
						<description>name the name of the field</description>
					</attribute>
					<attribute name="@param">
						<description>val the default value to use if &lt;code&gt;name&lt;/code&gt; does not
         have a value</description>
					</attribute>
					<attribute name="@return">
						<description>the value of the named &lt;code&gt;Object&lt;/code&gt; field</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException if there are I/O errors while reading from the
         underlying &lt;code&gt;InputStream&lt;/code&gt;</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is
         not serializable or if the field type is incorrect</description>
					</attribute>
				</comment>
				<params>
					<param name="name" comment="the name of the field" fulltype="java.lang.String" type="String" />
					<param name="val" comment="the default value to use if &lt;code&gt;name&lt;/code&gt; does not
         have a value" fulltype="java.lang.Object" type="Object" />
				</params>
				<exceptions>
					<exception comment="if there are I/O errors while reading from the
         underlying &lt;code&gt;InputStream&lt;/code&gt;" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="ObjectInputStream.GetField" visibility="private" package="java.io" superclassfulltype="java.io.ObjectInputStream.GetField" fulltype="java.io.ObjectInputStream.GetFieldImpl" type="ObjectInputStream.GetFieldImpl">
		<comment>
			<description>Default GetField implementation.</description>
		</comment>
		<fields>
			<field final="true" visibility="private" name="desc" fulltype="java.io.ObjectStreamClass" type="ObjectStreamClass">
				<comment>
					<description>class descriptor describing serializable fields</description>
				</comment>
			</field>
			<field final="true" visibility="private" name="primVals" fulltype="byte[]" type="byte">
				<comment>
					<description>primitive field values</description>
				</comment>
			</field>
			<field final="true" visibility="private" name="objVals" fulltype="java.lang.Object[]" type="Object">
				<comment>
					<description>object field values</description>
				</comment>
			</field>
			<field final="true" visibility="private" name="objHandles" fulltype="int[]" type="int">
				<comment>
					<description>object field value handles</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="package-private" name="ObjectInputStream.GetFieldImpl">
				<comment>
					<description>Creates GetFieldImpl object for reading fields defined in given
 class descriptor.</description>
				</comment>
				<params>
					<param name="desc" fulltype="java.io.ObjectStreamClass" type="ObjectStreamClass" />
				</params>
			</constructor>
			<method visibility="public" name="getObjectStreamClass" fulltype="java.io.ObjectStreamClass" type="ObjectStreamClass" />
			<method visibility="public" name="defaulted" fulltype="boolean" type="boolean">
				<params>
					<param name="name" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="get" fulltype="boolean" type="boolean">
				<params>
					<param name="name" fulltype="java.lang.String" type="String" />
					<param name="val" fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="get" fulltype="byte" type="byte">
				<params>
					<param name="name" fulltype="java.lang.String" type="String" />
					<param name="val" fulltype="byte" type="byte" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="get" fulltype="char" type="char">
				<params>
					<param name="name" fulltype="java.lang.String" type="String" />
					<param name="val" fulltype="char" type="char" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="get" fulltype="short" type="short">
				<params>
					<param name="name" fulltype="java.lang.String" type="String" />
					<param name="val" fulltype="short" type="short" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="get" fulltype="int" type="int">
				<params>
					<param name="name" fulltype="java.lang.String" type="String" />
					<param name="val" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="get" fulltype="float" type="float">
				<params>
					<param name="name" fulltype="java.lang.String" type="String" />
					<param name="val" fulltype="float" type="float" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="get" fulltype="long" type="long">
				<params>
					<param name="name" fulltype="java.lang.String" type="String" />
					<param name="val" fulltype="long" type="long" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="get" fulltype="double" type="double">
				<params>
					<param name="name" fulltype="java.lang.String" type="String" />
					<param name="val" fulltype="double" type="double" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="get" fulltype="java.lang.Object" type="Object">
				<params>
					<param name="name" fulltype="java.lang.String" type="String" />
					<param name="val" fulltype="java.lang.Object" type="Object" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="package-private" name="readFields" fulltype="void" type="void">
				<comment>
					<description>Reads primitive and object field values from stream.</description>
				</comment>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="getFieldOffset" fulltype="int" type="int">
				<comment>
					<description>Returns offset of field with given name and type.  A specified type
 of null matches all types, Object.class matches all non-primitive
 types, and any other non-null type matches assignable types only.
 If no matching field is found in the (incoming) class
 descriptor but a matching field is present in the associated local
 class descriptor, returns -1.  Throws IllegalArgumentException if
 neither incoming nor local class descriptor contains a match.</description>
				</comment>
				<params>
					<param name="name" fulltype="java.lang.String" type="String" />
					<param name="type" fulltype="java.lang.Class" type="Class" />
				</params>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="Object" visibility="private" package="java.io" superclassfulltype="java.lang.Object" fulltype="java.io.ObjectInputStream.ValidationList" type="ObjectInputStream.ValidationList">
		<comment>
			<description>Prioritized list of callbacks to be performed once object graph has been
 completely deserialized.</description>
		</comment>
		<fields>
			<field visibility="private" name="list" fulltype="java.io.ObjectInputStream.ValidationList.Callback" type="ObjectInputStream.ValidationList.Callback">
				<comment>
					<description>linked list of callbacks</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="package-private" name="ObjectInputStream.ValidationList">
				<comment>
					<description>Creates new (empty) ValidationList.</description>
				</comment>
			</constructor>
			<method visibility="package-private" name="register" fulltype="void" type="void">
				<comment>
					<description>Registers callback.  Throws InvalidObjectException if callback
 object is null.</description>
				</comment>
				<params>
					<param name="obj" fulltype="java.io.ObjectInputValidation" type="ObjectInputValidation" />
					<param name="priority" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.io.InvalidObjectException" type="InvalidObjectException" />
				</exceptions>
			</method>
			<method visibility="package-private" name="doCallbacks" fulltype="void" type="void">
				<comment>
					<description>Invokes all registered callbacks and clears the callback list.
 Callbacks with higher priorities are called first; those with equal
 priorities may be called in any order.  If any of the callbacks
 throws an InvalidObjectException, the callback process is terminated
 and the exception propagated upwards.</description>
				</comment>
				<exceptions>
					<exception fulltype="java.io.InvalidObjectException" type="InvalidObjectException" />
				</exceptions>
			</method>
			<method visibility="public" name="clear" fulltype="void" type="void">
				<comment>
					<description>Resets the callback list to its initial (empty) state.</description>
				</comment>
			</method>
		</methods>
		<jelclass superclass="Object" visibility="private" package="java.io" superclassfulltype="java.lang.Object" fulltype="java.io.ObjectInputStream.ValidationList.Callback" type="ObjectInputStream.ValidationList.Callback">
			<fields>
				<field final="true" visibility="package-private" name="obj" fulltype="java.io.ObjectInputValidation" type="ObjectInputValidation" />
				<field final="true" visibility="package-private" name="priority" fulltype="int" type="int" />
				<field visibility="package-private" name="next" fulltype="java.io.ObjectInputStream.ValidationList.Callback" type="ObjectInputStream.ValidationList.Callback" />
				<field final="true" visibility="package-private" name="acc" fulltype="java.security.AccessControlContext" type="AccessControlContext" />
			</fields>
			<methods>
				<constructor visibility="package-private" name="ObjectInputStream.ValidationList.Callback">
					<params>
						<param name="obj" fulltype="java.io.ObjectInputValidation" type="ObjectInputValidation" />
						<param name="priority" fulltype="int" type="int" />
						<param name="next" fulltype="java.io.ObjectInputStream.ValidationList.Callback" type="ObjectInputStream.ValidationList.Callback" />
						<param name="acc" fulltype="java.security.AccessControlContext" type="AccessControlContext" />
					</params>
				</constructor>
			</methods>
		</jelclass>
	</jelclass>
	<jelclass superclass="Object" visibility="private" package="java.io" superclassfulltype="java.lang.Object" fulltype="java.io.ObjectInputStream.ValidationList.Callback" type="ObjectInputStream.ValidationList.Callback">
		<fields>
			<field final="true" visibility="package-private" name="obj" fulltype="java.io.ObjectInputValidation" type="ObjectInputValidation" />
			<field final="true" visibility="package-private" name="priority" fulltype="int" type="int" />
			<field visibility="package-private" name="next" fulltype="java.io.ObjectInputStream.ValidationList.Callback" type="ObjectInputStream.ValidationList.Callback" />
			<field final="true" visibility="package-private" name="acc" fulltype="java.security.AccessControlContext" type="AccessControlContext" />
		</fields>
		<methods>
			<constructor visibility="package-private" name="ObjectInputStream.ValidationList.Callback">
				<params>
					<param name="obj" fulltype="java.io.ObjectInputValidation" type="ObjectInputValidation" />
					<param name="priority" fulltype="int" type="int" />
					<param name="next" fulltype="java.io.ObjectInputStream.ValidationList.Callback" type="ObjectInputStream.ValidationList.Callback" />
					<param name="acc" fulltype="java.security.AccessControlContext" type="AccessControlContext" />
				</params>
			</constructor>
		</methods>
	</jelclass>
	<jelclass superclass="InputStream" visibility="private" package="java.io" superclassfulltype="java.io.InputStream" fulltype="java.io.ObjectInputStream.PeekInputStream" type="ObjectInputStream.PeekInputStream">
		<comment>
			<description>Input stream supporting single-byte peek operations.</description>
		</comment>
		<fields>
			<field final="true" visibility="private" name="in" fulltype="java.io.InputStream" type="InputStream">
				<comment>
					<description>underlying stream</description>
				</comment>
			</field>
			<field visibility="private" name="peekb" fulltype="int" type="int">
				<comment>
					<description>peeked byte</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="package-private" name="ObjectInputStream.PeekInputStream">
				<comment>
					<description>Creates new PeekInputStream on top of given underlying stream.</description>
				</comment>
				<params>
					<param name="in" fulltype="java.io.InputStream" type="InputStream" />
				</params>
			</constructor>
			<method visibility="package-private" name="peek" fulltype="int" type="int">
				<comment>
					<description>Peeks at next byte value in stream.  Similar to read(), except
 that it does not consume the read value.</description>
				</comment>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="read" fulltype="int" type="int">
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="read" fulltype="int" type="int">
				<params>
					<param name="b" fulltype="byte[]" type="byte" />
					<param name="off" fulltype="int" type="int" />
					<param name="len" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="package-private" name="readFully" fulltype="void" type="void">
				<params>
					<param name="b" fulltype="byte[]" type="byte" />
					<param name="off" fulltype="int" type="int" />
					<param name="len" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="skip" fulltype="long" type="long">
				<params>
					<param name="n" fulltype="long" type="long" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="available" fulltype="int" type="int">
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="close" fulltype="void" type="void">
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="InputStream" visibility="private" package="java.io" superclassfulltype="java.io.InputStream" fulltype="java.io.ObjectInputStream.BlockDataInputStream" type="ObjectInputStream.BlockDataInputStream">
		<implements>
			<interface fulltype="java.io.DataInput" type="DataInput" />
		</implements>
		<comment>
			<description>Input stream with two modes: in default mode, inputs data written in the
 same format as DataOutputStream; in &quot;block data&quot; mode, inputs data
 bracketed by block data markers (see object serialization specification
 for details).  Buffering depends on block data mode: when in default
 mode, no data is buffered in advance; when in block data mode, all data
 for the current data block is read in at once (and buffered).</description>
		</comment>
		<fields>
			<field final="true" static="true" const="1024" visibility="private" name="MAX_BLOCK_SIZE" constexpr="1024" fulltype="int" type="int">
				<comment>
					<description>maximum data block length</description>
				</comment>
			</field>
			<field final="true" static="true" const="5" visibility="private" name="MAX_HEADER_SIZE" constexpr="5" fulltype="int" type="int">
				<comment>
					<description>maximum data block header length</description>
				</comment>
			</field>
			<field final="true" static="true" const="256" visibility="private" name="CHAR_BUF_SIZE" constexpr="256" fulltype="int" type="int">
				<comment>
					<description>(tunable) length of char buffer (for reading strings)</description>
				</comment>
			</field>
			<field final="true" static="true" const="-2" visibility="private" name="HEADER_BLOCKED" constexpr="-2" fulltype="int" type="int">
				<comment>
					<description>readBlockHeader() return value indicating header read may block</description>
				</comment>
			</field>
			<field final="true" visibility="private" name="buf" fulltype="byte[]" type="byte">
				<comment>
					<description>buffer for reading general/block data</description>
				</comment>
			</field>
			<field final="true" visibility="private" name="hbuf" fulltype="byte[]" type="byte">
				<comment>
					<description>buffer for reading block data headers</description>
				</comment>
			</field>
			<field final="true" visibility="private" name="cbuf" fulltype="char[]" type="char">
				<comment>
					<description>char buffer for fast string reads</description>
				</comment>
			</field>
			<field visibility="private" name="blkmode" fulltype="boolean" type="boolean">
				<comment>
					<description>block data mode</description>
				</comment>
			</field>
			<field visibility="private" name="pos" fulltype="int" type="int">
				<comment>
					<description>current offset into buf</description>
				</comment>
			</field>
			<field visibility="private" name="end" fulltype="int" type="int">
				<comment>
					<description>end offset of valid data in buf, or -1 if no more block data</description>
				</comment>
			</field>
			<field visibility="private" name="unread" fulltype="int" type="int">
				<comment>
					<description>number of bytes in current block yet to be read from stream</description>
				</comment>
			</field>
			<field final="true" visibility="private" name="in" fulltype="java.io.ObjectInputStream.PeekInputStream" type="ObjectInputStream.PeekInputStream">
				<comment>
					<description>underlying stream (wrapped in peekable filter stream)</description>
				</comment>
			</field>
			<field final="true" visibility="private" name="din" fulltype="java.io.DataInputStream" type="DataInputStream">
				<comment>
					<description>loopback stream (for data reads that span data blocks)</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="package-private" name="ObjectInputStream.BlockDataInputStream">
				<comment>
					<description>Creates new BlockDataInputStream on top of given underlying stream.
 Block data mode is turned off by default.</description>
				</comment>
				<params>
					<param name="in" fulltype="java.io.InputStream" type="InputStream" />
				</params>
			</constructor>
			<method visibility="package-private" name="setBlockDataMode" fulltype="boolean" type="boolean">
				<comment>
					<description>Sets block data mode to the given mode (true == on, false == off)
 and returns the previous mode value.  If the new mode is the same as
 the old mode, no action is taken.  Throws IllegalStateException if
 block data mode is being switched from on to off while unconsumed
 block data is still present in the stream.</description>
				</comment>
				<params>
					<param name="newmode" fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="package-private" name="getBlockDataMode" fulltype="boolean" type="boolean">
				<comment>
					<description>Returns true if the stream is currently in block data mode, false
 otherwise.</description>
				</comment>
			</method>
			<method visibility="package-private" name="skipBlockData" fulltype="void" type="void">
				<comment>
					<description>If in block data mode, skips to the end of the current group of data
 blocks (but does not unset block data mode).  If not in block data
 mode, throws an IllegalStateException.</description>
				</comment>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="readBlockHeader" fulltype="int" type="int">
				<comment>
					<description>Attempts to read in the next block data header (if any).  If
 canBlock is false and a full header cannot be read without possibly
 blocking, returns HEADER_BLOCKED, else if the next element in the
 stream is a block data header, returns the block data length
 specified by the header, else returns -1.</description>
				</comment>
				<params>
					<param name="canBlock" fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="refill" fulltype="void" type="void">
				<comment>
					<description>Refills internal buffer buf with block data.  Any data in buf at the
 time of the call is considered consumed.  Sets the pos, end, and
 unread fields to reflect the new amount of available block data; if
 the next element in the stream is not a data block, sets pos and
 unread to 0 and end to -1.</description>
				</comment>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="package-private" name="currentBlockRemaining" fulltype="int" type="int">
				<comment>
					<description>If in block data mode, returns the number of unconsumed bytes
 remaining in the current data block.  If not in block data mode,
 throws an IllegalStateException.</description>
				</comment>
			</method>
			<method visibility="package-private" name="peek" fulltype="int" type="int">
				<comment>
					<description>Peeks at (but does not consume) and returns the next byte value in
 the stream, or -1 if the end of the stream/block data (if in block
 data mode) has been reached.</description>
				</comment>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="package-private" name="peekByte" fulltype="byte" type="byte">
				<comment>
					<description>Peeks at (but does not consume) and returns the next byte value in
 the stream, or throws EOFException if end of stream/block data has
 been reached.</description>
				</comment>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="read" fulltype="int" type="int">
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="read" fulltype="int" type="int">
				<params>
					<param name="b" fulltype="byte[]" type="byte" />
					<param name="off" fulltype="int" type="int" />
					<param name="len" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="skip" fulltype="long" type="long">
				<params>
					<param name="len" fulltype="long" type="long" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="available" fulltype="int" type="int">
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="close" fulltype="void" type="void">
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="package-private" name="read" fulltype="int" type="int">
				<comment>
					<description>Attempts to read len bytes into byte array b at offset off.  Returns
 the number of bytes read, or -1 if the end of stream/block data has
 been reached.  If copy is true, reads values into an intermediate
 buffer before copying them to b (to avoid exposing a reference to
 b).</description>
				</comment>
				<params>
					<param name="b" fulltype="byte[]" type="byte" />
					<param name="off" fulltype="int" type="int" />
					<param name="len" fulltype="int" type="int" />
					<param name="copy" fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="readFully" fulltype="void" type="void">
				<params>
					<param name="b" fulltype="byte[]" type="byte" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="readFully" fulltype="void" type="void">
				<params>
					<param name="b" fulltype="byte[]" type="byte" />
					<param name="off" fulltype="int" type="int" />
					<param name="len" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="readFully" fulltype="void" type="void">
				<params>
					<param name="b" fulltype="byte[]" type="byte" />
					<param name="off" fulltype="int" type="int" />
					<param name="len" fulltype="int" type="int" />
					<param name="copy" fulltype="boolean" type="boolean" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="skipBytes" fulltype="int" type="int">
				<params>
					<param name="n" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="readBoolean" fulltype="boolean" type="boolean">
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="readByte" fulltype="byte" type="byte">
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="readUnsignedByte" fulltype="int" type="int">
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="readChar" fulltype="char" type="char">
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="readShort" fulltype="short" type="short">
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="readUnsignedShort" fulltype="int" type="int">
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="readInt" fulltype="int" type="int">
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="readFloat" fulltype="float" type="float">
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="readLong" fulltype="long" type="long">
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="readDouble" fulltype="double" type="double">
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="readUTF" fulltype="java.lang.String" type="String">
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="readLine" fulltype="java.lang.String" type="String">
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="package-private" name="readBooleans" fulltype="void" type="void">
				<params>
					<param name="v" fulltype="boolean[]" type="boolean" />
					<param name="off" fulltype="int" type="int" />
					<param name="len" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="package-private" name="readChars" fulltype="void" type="void">
				<params>
					<param name="v" fulltype="char[]" type="char" />
					<param name="off" fulltype="int" type="int" />
					<param name="len" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="package-private" name="readShorts" fulltype="void" type="void">
				<params>
					<param name="v" fulltype="short[]" type="short" />
					<param name="off" fulltype="int" type="int" />
					<param name="len" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="package-private" name="readInts" fulltype="void" type="void">
				<params>
					<param name="v" fulltype="int[]" type="int" />
					<param name="off" fulltype="int" type="int" />
					<param name="len" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="package-private" name="readFloats" fulltype="void" type="void">
				<params>
					<param name="v" fulltype="float[]" type="float" />
					<param name="off" fulltype="int" type="int" />
					<param name="len" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="package-private" name="readLongs" fulltype="void" type="void">
				<params>
					<param name="v" fulltype="long[]" type="long" />
					<param name="off" fulltype="int" type="int" />
					<param name="len" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="package-private" name="readDoubles" fulltype="void" type="void">
				<params>
					<param name="v" fulltype="double[]" type="double" />
					<param name="off" fulltype="int" type="int" />
					<param name="len" fulltype="int" type="int" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="package-private" name="readLongUTF" fulltype="java.lang.String" type="String">
				<comment>
					<description>Reads in string written in &quot;long&quot; UTF format.  &quot;Long&quot; UTF format is
 identical to standard UTF, except that it uses an 8 byte header
 (instead of the standard 2 bytes) to convey the UTF encoding length.</description>
				</comment>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="readUTFBody" fulltype="java.lang.String" type="String">
				<comment>
					<description>Reads in the &quot;body&quot; (i.e., the UTF representation minus the 2-byte
 or 8-byte length header) of a UTF encoding, which occupies the next
 utflen bytes.</description>
				</comment>
				<params>
					<param name="utflen" fulltype="long" type="long" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="readUTFSpan" fulltype="long" type="long">
				<comment>
					<description>Reads span of UTF-encoded characters out of internal buffer
 (starting at offset pos and ending at or before offset end),
 consuming no more than utflen bytes.  Appends read characters to
 sbuf.  Returns the number of bytes consumed.</description>
				</comment>
				<params>
					<param name="sbuf" fulltype="java.lang.StringBuilder" type="StringBuilder" />
					<param name="utflen" fulltype="long" type="long" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="private" name="readUTFChar" fulltype="int" type="int">
				<comment>
					<description>Reads in single UTF-encoded character one byte at a time, appends
 the character to sbuf, and returns the number of bytes consumed.
 This method is used when reading in UTF strings written in block
 data mode to handle UTF-encoded characters which (potentially)
 straddle block-data boundaries.</description>
				</comment>
				<params>
					<param name="sbuf" fulltype="java.lang.StringBuilder" type="StringBuilder" />
					<param name="utflen" fulltype="long" type="long" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
		</methods>
	</jelclass>
	<jelclass superclass="Object" visibility="private" package="java.io" superclassfulltype="java.lang.Object" fulltype="java.io.ObjectInputStream.HandleTable" type="ObjectInputStream.HandleTable">
		<comment>
			<description>Unsynchronized table which tracks wire handle to object mappings, as
 well as ClassNotFoundExceptions associated with deserialized objects.
 This class implements an exception-propagation algorithm for
 determining which objects should have ClassNotFoundExceptions associated
 with them, taking into account cycles and discontinuities (e.g., skipped
 fields) in the object graph.

 &lt;p&gt;General use of the table is as follows: during deserialization, a
 given object is first assigned a handle by calling the assign method.
 This method leaves the assigned handle in an &quot;open&quot; state, wherein
 dependencies on the exception status of other handles can be registered
 by calling the markDependency method, or an exception can be directly
 associated with the handle by calling markException.  When a handle is
 tagged with an exception, the HandleTable assumes responsibility for
 propagating the exception to any other objects which depend
 (transitively) on the exception-tagged object.

 &lt;p&gt;Once all exception information/dependencies for the handle have been
 registered, the handle should be &quot;closed&quot; by calling the finish method
 on it.  The act of finishing a handle allows the exception propagation
 algorithm to aggressively prune dependency links, lessening the
 performance/memory impact of exception tracking.

 &lt;p&gt;Note that the exception propagation algorithm used depends on handles
 being assigned/finished in LIFO order; however, for simplicity as well
 as memory conservation, it does not enforce this constraint.</description>
		</comment>
		<fields>
			<field final="true" static="true" const="1" visibility="private" name="STATUS_OK" constexpr="1" fulltype="byte" type="byte" />
			<field final="true" static="true" const="2" visibility="private" name="STATUS_UNKNOWN" constexpr="2" fulltype="byte" type="byte" />
			<field final="true" static="true" const="3" visibility="private" name="STATUS_EXCEPTION" constexpr="3" fulltype="byte" type="byte" />
			<field visibility="package-private" name="status" fulltype="byte[]" type="byte">
				<comment>
					<description>array mapping handle -&gt; object status</description>
				</comment>
			</field>
			<field visibility="package-private" name="entries" fulltype="java.lang.Object[]" type="Object">
				<comment>
					<description>array mapping handle -&gt; object/exception (depending on status)</description>
				</comment>
			</field>
			<field visibility="package-private" name="deps" fulltype="java.io.ObjectInputStream.HandleTable.HandleList[]" type="ObjectInputStream.HandleTable.HandleList">
				<comment>
					<description>array mapping handle -&gt; list of dependent handles (if any)</description>
				</comment>
			</field>
			<field visibility="package-private" name="lowDep" fulltype="int" type="int">
				<comment>
					<description>lowest unresolved dependency</description>
				</comment>
			</field>
			<field visibility="package-private" name="size" fulltype="int" type="int">
				<comment>
					<description>number of handles in table</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="package-private" name="ObjectInputStream.HandleTable">
				<comment>
					<description>Creates handle table with the given initial capacity.</description>
				</comment>
				<params>
					<param name="initialCapacity" fulltype="int" type="int" />
				</params>
			</constructor>
			<method visibility="package-private" name="assign" fulltype="int" type="int">
				<comment>
					<description>Assigns next available handle to given object, and returns assigned
 handle.  Once object has been completely deserialized (and all
 dependencies on other objects identified), the handle should be
 &quot;closed&quot; by passing it to finish().</description>
				</comment>
				<params>
					<param name="obj" fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method visibility="package-private" name="markDependency" fulltype="void" type="void">
				<comment>
					<description>Registers a dependency (in exception status) of one handle on
 another.  The dependent handle must be &quot;open&quot; (i.e., assigned, but
 not finished yet).  No action is taken if either dependent or target
 handle is NULL_HANDLE.</description>
				</comment>
				<params>
					<param name="dependent" fulltype="int" type="int" />
					<param name="target" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="package-private" name="markException" fulltype="void" type="void">
				<comment>
					<description>Associates a ClassNotFoundException (if one not already associated)
 with the currently active handle and propagates it to other
 referencing objects as appropriate.  The specified handle must be
 &quot;open&quot; (i.e., assigned, but not finished yet).</description>
				</comment>
				<params>
					<param name="handle" fulltype="int" type="int" />
					<param name="ex" fulltype="java.lang.ClassNotFoundException" type="ClassNotFoundException" />
				</params>
			</method>
			<method visibility="package-private" name="finish" fulltype="void" type="void">
				<comment>
					<description>Marks given handle as finished, meaning that no new dependencies
 will be marked for handle.  Calls to the assign and finish methods
 must occur in LIFO order.</description>
				</comment>
				<params>
					<param name="handle" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="package-private" name="setObject" fulltype="void" type="void">
				<comment>
					<description>Assigns a new object to the given handle.  The object previously
 associated with the handle is forgotten.  This method has no effect
 if the given handle already has an exception associated with it.
 This method may be called at any time after the handle is assigned.</description>
				</comment>
				<params>
					<param name="handle" fulltype="int" type="int" />
					<param name="obj" fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method visibility="package-private" name="lookupObject" fulltype="java.lang.Object" type="Object">
				<comment>
					<description>Looks up and returns object associated with the given handle.
 Returns null if the given handle is NULL_HANDLE, or if it has an
 associated ClassNotFoundException.</description>
				</comment>
				<params>
					<param name="handle" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="package-private" name="lookupException" fulltype="java.lang.ClassNotFoundException" type="ClassNotFoundException">
				<comment>
					<description>Looks up and returns ClassNotFoundException associated with the
 given handle.  Returns null if the given handle is NULL_HANDLE, or
 if there is no ClassNotFoundException associated with the handle.</description>
				</comment>
				<params>
					<param name="handle" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="package-private" name="clear" fulltype="void" type="void">
				<comment>
					<description>Resets table to its initial state.</description>
				</comment>
			</method>
			<method visibility="package-private" name="size" fulltype="int" type="int">
				<comment>
					<description>Returns number of handles registered in table.</description>
				</comment>
			</method>
			<method visibility="private" name="grow" fulltype="void" type="void">
				<comment>
					<description>Expands capacity of internal arrays.</description>
				</comment>
			</method>
		</methods>
		<jelclass superclass="Object" visibility="private" package="java.io" superclassfulltype="java.lang.Object" fulltype="java.io.ObjectInputStream.HandleTable.HandleList" type="ObjectInputStream.HandleTable.HandleList">
			<comment>
				<description>Simple growable list of (integer) handles.</description>
			</comment>
			<fields>
				<field visibility="private" name="list" fulltype="int[]" type="int" />
				<field visibility="private" name="size" fulltype="int" type="int" />
			</fields>
			<methods>
				<constructor visibility="public" name="ObjectInputStream.HandleTable.HandleList" />
				<method visibility="public" name="add" fulltype="void" type="void">
					<params>
						<param name="handle" fulltype="int" type="int" />
					</params>
				</method>
				<method visibility="public" name="get" fulltype="int" type="int">
					<params>
						<param name="index" fulltype="int" type="int" />
					</params>
				</method>
				<method visibility="public" name="size" fulltype="int" type="int" />
			</methods>
		</jelclass>
	</jelclass>
	<jelclass superclass="Object" visibility="private" package="java.io" superclassfulltype="java.lang.Object" fulltype="java.io.ObjectInputStream.HandleTable.HandleList" type="ObjectInputStream.HandleTable.HandleList">
		<comment>
			<description>Simple growable list of (integer) handles.</description>
		</comment>
		<fields>
			<field visibility="private" name="list" fulltype="int[]" type="int" />
			<field visibility="private" name="size" fulltype="int" type="int" />
		</fields>
		<methods>
			<constructor visibility="public" name="ObjectInputStream.HandleTable.HandleList" />
			<method visibility="public" name="add" fulltype="void" type="void">
				<params>
					<param name="handle" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="get" fulltype="int" type="int">
				<params>
					<param name="index" fulltype="int" type="int" />
				</params>
			</method>
			<method visibility="public" name="size" fulltype="int" type="int" />
		</methods>
	</jelclass>
	<jelclass superclass="Object" visibility="public" package="java.io" serializable="true" superclassfulltype="java.lang.Object" fulltype="java.io.File" type="File">
		<implements>
			<interface fulltype="java.io.Serializable" type="Serializable" />
			<interface fulltype="java.lang.Comparable" type="Comparable" />
		</implements>
		<comment>
			<description>An abstract representation of file and directory pathnames.

 &lt;p&gt; User interfaces and operating systems use system-dependent &lt;em&gt;pathname
 strings&lt;/em&gt; to name files and directories.  This class presents an
 abstract, system-independent view of hierarchical pathnames.  An
 &lt;em&gt;abstract pathname&lt;/em&gt; has two components:

 &lt;ol&gt;
 &lt;li&gt; An optional system-dependent &lt;em&gt;prefix&lt;/em&gt; string,
      such as a disk-drive specifier, &lt;code&gt;&quot;/&quot;&lt;/code&gt;&amp;nbsp;for the UNIX root
      directory, or &lt;code&gt;&quot;\\\\&quot;&lt;/code&gt;&amp;nbsp;for a Microsoft Windows UNC pathname, and
 &lt;li&gt; A sequence of zero or more string &lt;em&gt;names&lt;/em&gt;.
 &lt;/ol&gt;

 The first name in an abstract pathname may be a directory name or, in the
 case of Microsoft Windows UNC pathnames, a hostname.  Each subsequent name
 in an abstract pathname denotes a directory; the last name may denote
 either a directory or a file.  The &lt;em&gt;empty&lt;/em&gt; abstract pathname has no
 prefix and an empty name sequence.

 &lt;p&gt; The conversion of a pathname string to or from an abstract pathname is
 inherently system-dependent.  When an abstract pathname is converted into a
 pathname string, each name is separated from the next by a single copy of
 the default &lt;em&gt;separator character&lt;/em&gt;.  The default name-separator
 character is defined by the system property &lt;code&gt;file.separator&lt;/code&gt;, and
 is made available in the public static fields &lt;code&gt;{@link
 #separator}&lt;/code&gt; and &lt;code&gt;{@link #separatorChar}&lt;/code&gt; of this class.
 When a pathname string is converted into an abstract pathname, the names
 within it may be separated by the default name-separator character or by any
 other name-separator character that is supported by the underlying system.

 &lt;p&gt; A pathname, whether abstract or in string form, may be either
 &lt;em&gt;absolute&lt;/em&gt; or &lt;em&gt;relative&lt;/em&gt;.  An absolute pathname is complete in
 that no other information is required in order to locate the file that it
 denotes.  A relative pathname, in contrast, must be interpreted in terms of
 information taken from some other pathname.  By default the classes in the
 &lt;code&gt;java.io&lt;/code&gt; package always resolve relative pathnames against the
 current user directory.  This directory is named by the system property
 &lt;code&gt;user.dir&lt;/code&gt;, and is typically the directory in which the Java
 virtual machine was invoked.

 &lt;p&gt; The &lt;em&gt;parent&lt;/em&gt; of an abstract pathname may be obtained by invoking
 the {@link #getParent} method of this class and consists of the pathname&apos;s
 prefix and each name in the pathname&apos;s name sequence except for the last.
 Each directory&apos;s absolute pathname is an ancestor of any &lt;tt&gt;File&lt;/tt&gt;
 object with an absolute abstract pathname which begins with the directory&apos;s
 absolute pathname.  For example, the directory denoted by the abstract
 pathname &lt;tt&gt;&quot;/usr&quot;&lt;/tt&gt; is an ancestor of the directory denoted by the
 pathname &lt;tt&gt;&quot;/usr/local/bin&quot;&lt;/tt&gt;.

 &lt;p&gt; The prefix concept is used to handle root directories on UNIX platforms,
 and drive specifiers, root directories and UNC pathnames on Microsoft Windows platforms,
 as follows:

 &lt;ul&gt;

 &lt;li&gt; For UNIX platforms, the prefix of an absolute pathname is always
 &lt;code&gt;&quot;/&quot;&lt;/code&gt;.  Relative pathnames have no prefix.  The abstract pathname
 denoting the root directory has the prefix &lt;code&gt;&quot;/&quot;&lt;/code&gt; and an empty
 name sequence.

 &lt;li&gt; For Microsoft Windows platforms, the prefix of a pathname that contains a drive
 specifier consists of the drive letter followed by &lt;code&gt;&quot;:&quot;&lt;/code&gt; and
 possibly followed by &lt;code&gt;&quot;\\&quot;&lt;/code&gt; if the pathname is absolute.  The
 prefix of a UNC pathname is &lt;code&gt;&quot;\\\\&quot;&lt;/code&gt;; the hostname and the share
 name are the first two names in the name sequence.  A relative pathname that
 does not specify a drive has no prefix.

 &lt;/ul&gt;

 &lt;p&gt; Instances of this class may or may not denote an actual file-system
 object such as a file or a directory.  If it does denote such an object
 then that object resides in a &lt;i&gt;partition&lt;/i&gt;.  A partition is an
 operating system-specific portion of storage for a file system.  A single
 storage device (e.g. a physical disk-drive, flash memory, CD-ROM) may
 contain multiple partitions.  The object, if any, will reside on the
 partition &lt;a name=&quot;partName&quot;&gt;named&lt;/a&gt; by some ancestor of the absolute
 form of this pathname.

 &lt;p&gt; A file system may implement restrictions to certain operations on the
 actual file-system object, such as reading, writing, and executing.  These
 restrictions are collectively known as &lt;i&gt;access permissions&lt;/i&gt;.  The file
 system may have multiple sets of access permissions on a single object.
 For example, one set may apply to the object&apos;s &lt;i&gt;owner&lt;/i&gt;, and another
 may apply to all other users.  The access permissions on an object may
 cause some methods in this class to fail.

 &lt;p&gt; Instances of the &lt;code&gt;File&lt;/code&gt; class are immutable; that is, once
 created, the abstract pathname represented by a &lt;code&gt;File&lt;/code&gt; object
 will never change.</description>
			<attribute name="@author">
				<description>unascribed</description>
			</attribute>
			<attribute name="@since">
				<description>JDK1.0</description>
			</attribute>
		</comment>
		<fields>
			<field static="true" visibility="private" name="fs" fulltype="java.io.FileSystem" type="FileSystem">
				<comment>
					<description>The FileSystem object representing the platform&apos;s local file system.</description>
				</comment>
			</field>
			<field visibility="private" name="path" fulltype="java.lang.String" type="String">
				<comment>
					<description>This abstract pathname&apos;s normalized pathname string.  A normalized
 pathname string uses the default name-separator character and does not
 contain any duplicate or redundant separators.</description>
					<attribute name="@serial" />
				</comment>
			</field>
			<field visibility="private" transient="true" name="prefixLength" fulltype="int" type="int">
				<comment>
					<description>The length of this abstract pathname&apos;s prefix, or zero if it has no
 prefix.</description>
				</comment>
			</field>
			<field final="true" static="true" visibility="public" name="separatorChar" fulltype="char" type="char">
				<comment>
					<description>The system-dependent default name-separator character.  This field is
 initialized to contain the first character of the value of the system
 property &lt;code&gt;file.separator&lt;/code&gt;.  On UNIX systems the value of this
 field is &lt;code&gt;&apos;/&apos;&lt;/code&gt;; on Microsoft Windows systems it is &lt;code&gt;&apos;\\&apos;&lt;/code&gt;.</description>
					<attribute name="@see">
						<description>java.lang.System#getProperty(java.lang.String)</description>
					</attribute>
				</comment>
			</field>
			<field final="true" static="true" visibility="public" name="separator" fulltype="java.lang.String" type="String">
				<comment>
					<description>The system-dependent default name-separator character, represented as a
 string for convenience.  This string contains a single character, namely
 &lt;code&gt;{@link #separatorChar}&lt;/code&gt;.</description>
				</comment>
			</field>
			<field final="true" static="true" visibility="public" name="pathSeparatorChar" fulltype="char" type="char">
				<comment>
					<description>The system-dependent path-separator character.  This field is
 initialized to contain the first character of the value of the system
 property &lt;code&gt;path.separator&lt;/code&gt;.  This character is used to
 separate filenames in a sequence of files given as a &lt;em&gt;path list&lt;/em&gt;.
 On UNIX systems, this character is &lt;code&gt;&apos;:&apos;&lt;/code&gt;; on Microsoft Windows systems it
 is &lt;code&gt;&apos;;&apos;&lt;/code&gt;.</description>
					<attribute name="@see">
						<description>java.lang.System#getProperty(java.lang.String)</description>
					</attribute>
				</comment>
			</field>
			<field final="true" static="true" visibility="public" name="pathSeparator" fulltype="java.lang.String" type="String">
				<comment>
					<description>The system-dependent path-separator character, represented as a string
 for convenience.  This string contains a single character, namely
 &lt;code&gt;{@link #pathSeparatorChar}&lt;/code&gt;.</description>
				</comment>
			</field>
			<field final="true" static="true" const="301077366599181567" visibility="private" name="serialVersionUID" constexpr="301077366599181567L" fulltype="long" type="long">
				<comment>
					<description>use serialVersionUID from JDK 1.0.2 for interoperability</description>
				</comment>
			</field>
		</fields>
		<methods>
			<constructor visibility="private" name="File">
				<comment>
					<description>Internal constructor for already-normalized pathname strings.</description>
				</comment>
				<params>
					<param name="pathname" fulltype="java.lang.String" type="String" />
					<param name="prefixLength" fulltype="int" type="int" />
				</params>
			</constructor>
			<constructor visibility="private" name="File">
				<comment>
					<description>Internal constructor for already-normalized pathname strings.
 The parameter order is used to disambiguate this method from the
 public(File, String) constructor.</description>
				</comment>
				<params>
					<param name="child" fulltype="java.lang.String" type="String" />
					<param name="parent" fulltype="java.io.File" type="File" />
				</params>
			</constructor>
			<constructor visibility="public" name="File">
				<comment>
					<description>Creates a new &lt;code&gt;File&lt;/code&gt; instance by converting the given
 pathname string into an abstract pathname.  If the given string is
 the empty string, then the result is the empty abstract pathname.</description>
					<attribute name="@param">
						<description>pathname  A pathname string</description>
					</attribute>
					<attribute name="@throws">
						<description>NullPointerException
          If the &lt;code&gt;pathname&lt;/code&gt; argument is &lt;code&gt;null&lt;/code&gt;</description>
					</attribute>
				</comment>
				<params>
					<param name="pathname" comment="A pathname string" fulltype="java.lang.String" type="String" />
				</params>
			</constructor>
			<constructor visibility="public" name="File">
				<comment>
					<description>Creates a new &lt;code&gt;File&lt;/code&gt; instance from a parent pathname string
 and a child pathname string.

 &lt;p&gt; If &lt;code&gt;parent&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; then the new
 &lt;code&gt;File&lt;/code&gt; instance is created as if by invoking the
 single-argument &lt;code&gt;File&lt;/code&gt; constructor on the given
 &lt;code&gt;child&lt;/code&gt; pathname string.

 &lt;p&gt; Otherwise the &lt;code&gt;parent&lt;/code&gt; pathname string is taken to denote
 a directory, and the &lt;code&gt;child&lt;/code&gt; pathname string is taken to
 denote either a directory or a file.  If the &lt;code&gt;child&lt;/code&gt; pathname
 string is absolute then it is converted into a relative pathname in a
 system-dependent way.  If &lt;code&gt;parent&lt;/code&gt; is the empty string then
 the new &lt;code&gt;File&lt;/code&gt; instance is created by converting
 &lt;code&gt;child&lt;/code&gt; into an abstract pathname and resolving the result
 against a system-dependent default directory.  Otherwise each pathname
 string is converted into an abstract pathname and the child abstract
 pathname is resolved against the parent.</description>
					<attribute name="@param">
						<description>parent  The parent pathname string</description>
					</attribute>
					<attribute name="@param">
						<description>child   The child pathname string</description>
					</attribute>
					<attribute name="@throws">
						<description>NullPointerException
          If &lt;code&gt;child&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</description>
					</attribute>
				</comment>
				<params>
					<param name="parent" comment="The parent pathname string" fulltype="java.lang.String" type="String" />
					<param name="child" comment="The child pathname string" fulltype="java.lang.String" type="String" />
				</params>
			</constructor>
			<constructor visibility="public" name="File">
				<comment>
					<description>Creates a new &lt;code&gt;File&lt;/code&gt; instance from a parent abstract
 pathname and a child pathname string.

 &lt;p&gt; If &lt;code&gt;parent&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; then the new
 &lt;code&gt;File&lt;/code&gt; instance is created as if by invoking the
 single-argument &lt;code&gt;File&lt;/code&gt; constructor on the given
 &lt;code&gt;child&lt;/code&gt; pathname string.

 &lt;p&gt; Otherwise the &lt;code&gt;parent&lt;/code&gt; abstract pathname is taken to
 denote a directory, and the &lt;code&gt;child&lt;/code&gt; pathname string is taken
 to denote either a directory or a file.  If the &lt;code&gt;child&lt;/code&gt;
 pathname string is absolute then it is converted into a relative
 pathname in a system-dependent way.  If &lt;code&gt;parent&lt;/code&gt; is the empty
 abstract pathname then the new &lt;code&gt;File&lt;/code&gt; instance is created by
 converting &lt;code&gt;child&lt;/code&gt; into an abstract pathname and resolving
 the result against a system-dependent default directory.  Otherwise each
 pathname string is converted into an abstract pathname and the child
 abstract pathname is resolved against the parent.</description>
					<attribute name="@param">
						<description>parent  The parent abstract pathname</description>
					</attribute>
					<attribute name="@param">
						<description>child   The child pathname string</description>
					</attribute>
					<attribute name="@throws">
						<description>NullPointerException
          If &lt;code&gt;child&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</description>
					</attribute>
				</comment>
				<params>
					<param name="parent" comment="The parent abstract pathname" fulltype="java.io.File" type="File" />
					<param name="child" comment="The child pathname string" fulltype="java.lang.String" type="String" />
				</params>
			</constructor>
			<constructor visibility="public" name="File">
				<comment>
					<description>Creates a new &lt;tt&gt;File&lt;/tt&gt; instance by converting the given
 &lt;tt&gt;file:&lt;/tt&gt; URI into an abstract pathname.

 &lt;p&gt; The exact form of a &lt;tt&gt;file:&lt;/tt&gt; URI is system-dependent, hence
 the transformation performed by this constructor is also
 system-dependent.

 &lt;p&gt; For a given abstract pathname &lt;i&gt;f&lt;/i&gt; it is guaranteed that

 &lt;blockquote&gt;&lt;tt&gt;
 new File(&lt;/tt&gt;&lt;i&gt;&amp;nbsp;f&lt;/i&gt;&lt;tt&gt;.{@link #toURI() toURI}()).equals(&lt;/tt&gt;&lt;i&gt;&amp;nbsp;f&lt;/i&gt;&lt;tt&gt;.{@link #getAbsoluteFile() getAbsoluteFile}())
 &lt;/tt&gt;&lt;/blockquote&gt;

 so long as the original abstract pathname, the URI, and the new abstract
 pathname are all created in (possibly different invocations of) the same
 Java virtual machine.  This relationship typically does not hold,
 however, when a &lt;tt&gt;file:&lt;/tt&gt; URI that is created in a virtual machine
 on one operating system is converted into an abstract pathname in a
 virtual machine on a different operating system.</description>
					<attribute name="@param">
						<description>uri
         An absolute, hierarchical URI with a scheme equal to
         &lt;tt&gt;&quot;file&quot;&lt;/tt&gt;, a non-empty path component, and undefined
         authority, query, and fragment components</description>
					</attribute>
					<attribute name="@throws">
						<description>NullPointerException
          If &lt;tt&gt;uri&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException
          If the preconditions on the parameter do not hold</description>
					</attribute>
					<attribute name="@see">
						<description>#toURI()</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URI</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
				<params>
					<param name="uri" comment="An absolute, hierarchical URI with a scheme equal to
         &lt;tt&gt;&quot;file&quot;&lt;/tt&gt;, a non-empty path component, and undefined
         authority, query, and fragment components" fulltype="java.net.URI" type="URI" />
				</params>
			</constructor>
			<method visibility="package-private" name="getPrefixLength" fulltype="int" type="int">
				<comment>
					<description>Returns the length of this abstract pathname&apos;s prefix.
 For use by FileSystem classes.</description>
				</comment>
			</method>
			<method visibility="public" name="getName" returncomment="The name of the file or directory denoted by this abstract
          pathname, or the empty string if this pathname&apos;s name sequence
          is empty" fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the name of the file or directory denoted by this abstract
 pathname.  This is just the last name in the pathname&apos;s name
 sequence.  If the pathname&apos;s name sequence is empty, then the empty
 string is returned.</description>
					<attribute name="@return">
						<description>The name of the file or directory denoted by this abstract
          pathname, or the empty string if this pathname&apos;s name sequence
          is empty</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getParent" returncomment="The pathname string of the parent directory named by this
          abstract pathname, or &lt;code&gt;null&lt;/code&gt; if this pathname
          does not name a parent" fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the pathname string of this abstract pathname&apos;s parent, or
 &lt;code&gt;null&lt;/code&gt; if this pathname does not name a parent directory.

 &lt;p&gt; The &lt;em&gt;parent&lt;/em&gt; of an abstract pathname consists of the
 pathname&apos;s prefix, if any, and each name in the pathname&apos;s name
 sequence except for the last.  If the name sequence is empty then
 the pathname does not name a parent directory.</description>
					<attribute name="@return">
						<description>The pathname string of the parent directory named by this
          abstract pathname, or &lt;code&gt;null&lt;/code&gt; if this pathname
          does not name a parent</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getParentFile" returncomment="The abstract pathname of the parent directory named by this
          abstract pathname, or &lt;code&gt;null&lt;/code&gt; if this pathname
          does not name a parent" fulltype="java.io.File" type="File">
				<comment>
					<description>Returns the abstract pathname of this abstract pathname&apos;s parent,
 or &lt;code&gt;null&lt;/code&gt; if this pathname does not name a parent
 directory.

 &lt;p&gt; The &lt;em&gt;parent&lt;/em&gt; of an abstract pathname consists of the
 pathname&apos;s prefix, if any, and each name in the pathname&apos;s name
 sequence except for the last.  If the name sequence is empty then
 the pathname does not name a parent directory.</description>
					<attribute name="@return">
						<description>The abstract pathname of the parent directory named by this
          abstract pathname, or &lt;code&gt;null&lt;/code&gt; if this pathname
          does not name a parent</description>
					</attribute>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getPath" returncomment="The string form of this abstract pathname" fulltype="java.lang.String" type="String">
				<comment>
					<description>Converts this abstract pathname into a pathname string.  The resulting
 string uses the {@link #separator default name-separator character} to
 separate the names in the name sequence.</description>
					<attribute name="@return">
						<description>The string form of this abstract pathname</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="isAbsolute" returncomment="&lt;code&gt;true&lt;/code&gt; if this abstract pathname is absolute,
          &lt;code&gt;false&lt;/code&gt; otherwise" fulltype="boolean" type="boolean">
				<comment>
					<description>Tests whether this abstract pathname is absolute.  The definition of
 absolute pathname is system dependent.  On UNIX systems, a pathname is
 absolute if its prefix is &lt;code&gt;&quot;/&quot;&lt;/code&gt;.  On Microsoft Windows systems, a
 pathname is absolute if its prefix is a drive specifier followed by
 &lt;code&gt;&quot;\\&quot;&lt;/code&gt;, or if its prefix is &lt;code&gt;&quot;\\\\&quot;&lt;/code&gt;.</description>
					<attribute name="@return">
						<description>&lt;code&gt;true&lt;/code&gt; if this abstract pathname is absolute,
          &lt;code&gt;false&lt;/code&gt; otherwise</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getAbsolutePath" returncomment="The absolute pathname string denoting the same file or
          directory as this abstract pathname" fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the absolute pathname string of this abstract pathname.

 &lt;p&gt; If this abstract pathname is already absolute, then the pathname
 string is simply returned as if by the &lt;code&gt;{@link #getPath}&lt;/code&gt;
 method.  If this abstract pathname is the empty abstract pathname then
 the pathname string of the current user directory, which is named by the
 system property &lt;code&gt;user.dir&lt;/code&gt;, is returned.  Otherwise this
 pathname is resolved in a system-dependent way.  On UNIX systems, a
 relative pathname is made absolute by resolving it against the current
 user directory.  On Microsoft Windows systems, a relative pathname is made absolute
 by resolving it against the current directory of the drive named by the
 pathname, if any; if not, it is resolved against the current user
 directory.</description>
					<attribute name="@return">
						<description>The absolute pathname string denoting the same file or
          directory as this abstract pathname</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException
          If a required system property value cannot be accessed.</description>
					</attribute>
					<attribute name="@see">
						<description>java.io.File#isAbsolute()</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getAbsoluteFile" returncomment="The absolute abstract pathname denoting the same file or
          directory as this abstract pathname" fulltype="java.io.File" type="File">
				<comment>
					<description>Returns the absolute form of this abstract pathname.  Equivalent to
 &lt;code&gt;new&amp;nbsp;File(this.{@link #getAbsolutePath})&lt;/code&gt;.</description>
					<attribute name="@return">
						<description>The absolute abstract pathname denoting the same file or
          directory as this abstract pathname</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException
          If a required system property value cannot be accessed.</description>
					</attribute>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getCanonicalPath" returncomment="The canonical pathname string denoting the same file or
          directory as this abstract pathname" fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the canonical pathname string of this abstract pathname.

 &lt;p&gt; A canonical pathname is both absolute and unique.  The precise
 definition of canonical form is system-dependent.  This method first
 converts this pathname to absolute form if necessary, as if by invoking the
 {@link #getAbsolutePath} method, and then maps it to its unique form in a
 system-dependent way.  This typically involves removing redundant names
 such as &lt;tt&gt;&quot;.&quot;&lt;/tt&gt; and &lt;tt&gt;&quot;..&quot;&lt;/tt&gt; from the pathname, resolving
 symbolic links (on UNIX platforms), and converting drive letters to a
 standard case (on Microsoft Windows platforms).

 &lt;p&gt; Every pathname that denotes an existing file or directory has a
 unique canonical form.  Every pathname that denotes a nonexistent file
 or directory also has a unique canonical form.  The canonical form of
 the pathname of a nonexistent file or directory may be different from
 the canonical form of the same pathname after the file or directory is
 created.  Similarly, the canonical form of the pathname of an existing
 file or directory may be different from the canonical form of the same
 pathname after the file or directory is deleted.</description>
					<attribute name="@return">
						<description>The canonical pathname string denoting the same file or
          directory as this abstract pathname</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException
          If an I/O error occurs, which is possible because the
          construction of the canonical pathname may require
          filesystem queries</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException
          If a required system property value cannot be accessed, or
          if a security manager exists and its &lt;code&gt;{@link
          java.lang.SecurityManager#checkRead}&lt;/code&gt; method denies
          read access to the file</description>
					</attribute>
					<attribute name="@since">
						<description>JDK1.1</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If an I/O error occurs, which is possible because the
          construction of the canonical pathname may require
          filesystem queries" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="getCanonicalFile" returncomment="The canonical pathname string denoting the same file or
          directory as this abstract pathname" fulltype="java.io.File" type="File">
				<comment>
					<description>Returns the canonical form of this abstract pathname.  Equivalent to
 &lt;code&gt;new&amp;nbsp;File(this.{@link #getCanonicalPath})&lt;/code&gt;.</description>
					<attribute name="@return">
						<description>The canonical pathname string denoting the same file or
          directory as this abstract pathname</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException
          If an I/O error occurs, which is possible because the
          construction of the canonical pathname may require
          filesystem queries</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException
          If a required system property value cannot be accessed, or
          if a security manager exists and its &lt;code&gt;{@link
          java.lang.SecurityManager#checkRead}&lt;/code&gt; method denies
          read access to the file</description>
					</attribute>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If an I/O error occurs, which is possible because the
          construction of the canonical pathname may require
          filesystem queries" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method static="true" visibility="private" name="slashify" fulltype="java.lang.String" type="String">
				<params>
					<param name="path" fulltype="java.lang.String" type="String" />
					<param name="isDirectory" fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method visibility="public" name="toURL" returncomment="A URL object representing the equivalent file URL" fulltype="java.net.URL" type="URL">
				<comment>
					<description>Converts this abstract pathname into a &lt;code&gt;file:&lt;/code&gt; URL.  The
 exact form of the URL is system-dependent.  If it can be determined that
 the file denoted by this abstract pathname is a directory, then the
 resulting URL will end with a slash.</description>
					<attribute name="@return">
						<description>A URL object representing the equivalent file URL</description>
					</attribute>
					<attribute name="@throws">
						<description>MalformedURLException
          If the path cannot be parsed as a URL</description>
					</attribute>
					<attribute name="@see">
						<description>#toURI()</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URI</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URI#toURL()</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URL</description>
					</attribute>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
					<attribute name="@deprecated">
						<description>This method does not automatically escape characters that
 are illegal in URLs.  It is recommended that new code convert an
 abstract pathname into a URL by first converting it into a URI, via the
 {@link #toURI() toURI} method, and then converting the URI into a URL
 via the {@link java.net.URI#toURL() URI.toURL} method.</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If the path cannot be parsed as a URL" fulltype="java.net.MalformedURLException" type="MalformedURLException" />
				</exceptions>
			</method>
			<method visibility="public" name="toURI" returncomment="An absolute, hierarchical URI with a scheme equal to
          &lt;tt&gt;&quot;file&quot;&lt;/tt&gt;, a path representing this abstract pathname,
          and undefined authority, query, and fragment components" fulltype="java.net.URI" type="URI">
				<comment>
					<description>Constructs a &lt;tt&gt;file:&lt;/tt&gt; URI that represents this abstract pathname.

 &lt;p&gt; The exact form of the URI is system-dependent.  If it can be
 determined that the file denoted by this abstract pathname is a
 directory, then the resulting URI will end with a slash.

 &lt;p&gt; For a given abstract pathname &lt;i&gt;f&lt;/i&gt;, it is guaranteed that

 &lt;blockquote&gt;&lt;tt&gt;
 new {@link #File(java.net.URI) File}(&lt;/tt&gt;&lt;i&gt;&amp;nbsp;f&lt;/i&gt;&lt;tt&gt;.toURI()).equals(&lt;/tt&gt;&lt;i&gt;&amp;nbsp;f&lt;/i&gt;&lt;tt&gt;.{@link #getAbsoluteFile() getAbsoluteFile}())
 &lt;/tt&gt;&lt;/blockquote&gt;

 so long as the original abstract pathname, the URI, and the new abstract
 pathname are all created in (possibly different invocations of) the same
 Java virtual machine.  Due to the system-dependent nature of abstract
 pathnames, however, this relationship typically does not hold when a
 &lt;tt&gt;file:&lt;/tt&gt; URI that is created in a virtual machine on one operating
 system is converted into an abstract pathname in a virtual machine on a
 different operating system.</description>
					<attribute name="@return">
						<description>An absolute, hierarchical URI with a scheme equal to
          &lt;tt&gt;&quot;file&quot;&lt;/tt&gt;, a path representing this abstract pathname,
          and undefined authority, query, and fragment components</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException If a required system property value cannot
 be accessed.</description>
					</attribute>
					<attribute name="@see">
						<description>#File(java.net.URI)</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URI</description>
					</attribute>
					<attribute name="@see">
						<description>java.net.URI#toURL()</description>
					</attribute>
					<attribute name="@since">
						<description>1.4</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="canRead" returncomment="&lt;code&gt;true&lt;/code&gt; if and only if the file specified by this
          abstract pathname exists &lt;em&gt;and&lt;/em&gt; can be read by the
          application; &lt;code&gt;false&lt;/code&gt; otherwise" fulltype="boolean" type="boolean">
				<comment>
					<description>Tests whether the application can read the file denoted by this
 abstract pathname.</description>
					<attribute name="@return">
						<description>&lt;code&gt;true&lt;/code&gt; if and only if the file specified by this
          abstract pathname exists &lt;em&gt;and&lt;/em&gt; can be read by the
          application; &lt;code&gt;false&lt;/code&gt; otherwise</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException
          If a security manager exists and its &lt;code&gt;{@link
          java.lang.SecurityManager#checkRead(java.lang.String)}&lt;/code&gt;
          method denies read access to the file</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="canWrite" returncomment="&lt;code&gt;true&lt;/code&gt; if and only if the file system actually
          contains a file denoted by this abstract pathname &lt;em&gt;and&lt;/em&gt;
          the application is allowed to write to the file;
          &lt;code&gt;false&lt;/code&gt; otherwise." fulltype="boolean" type="boolean">
				<comment>
					<description>Tests whether the application can modify the file denoted by this
 abstract pathname.</description>
					<attribute name="@return">
						<description>&lt;code&gt;true&lt;/code&gt; if and only if the file system actually
          contains a file denoted by this abstract pathname &lt;em&gt;and&lt;/em&gt;
          the application is allowed to write to the file;
          &lt;code&gt;false&lt;/code&gt; otherwise.</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException
          If a security manager exists and its &lt;code&gt;{@link
          java.lang.SecurityManager#checkWrite(java.lang.String)}&lt;/code&gt;
          method denies write access to the file</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="exists" returncomment="&lt;code&gt;true&lt;/code&gt; if and only if the file or directory denoted
          by this abstract pathname exists; &lt;code&gt;false&lt;/code&gt; otherwise" fulltype="boolean" type="boolean">
				<comment>
					<description>Tests whether the file or directory denoted by this abstract pathname
 exists.</description>
					<attribute name="@return">
						<description>&lt;code&gt;true&lt;/code&gt; if and only if the file or directory denoted
          by this abstract pathname exists; &lt;code&gt;false&lt;/code&gt; otherwise</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException
          If a security manager exists and its &lt;code&gt;{@link
          java.lang.SecurityManager#checkRead(java.lang.String)}&lt;/code&gt;
          method denies read access to the file or directory</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="isDirectory" returncomment="&lt;code&gt;true&lt;/code&gt; if and only if the file denoted by this
          abstract pathname exists &lt;em&gt;and&lt;/em&gt; is a directory;
          &lt;code&gt;false&lt;/code&gt; otherwise" fulltype="boolean" type="boolean">
				<comment>
					<description>Tests whether the file denoted by this abstract pathname is a
 directory.</description>
					<attribute name="@return">
						<description>&lt;code&gt;true&lt;/code&gt; if and only if the file denoted by this
          abstract pathname exists &lt;em&gt;and&lt;/em&gt; is a directory;
          &lt;code&gt;false&lt;/code&gt; otherwise</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException
          If a security manager exists and its &lt;code&gt;{@link
          java.lang.SecurityManager#checkRead(java.lang.String)}&lt;/code&gt;
          method denies read access to the file</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="isFile" returncomment="&lt;code&gt;true&lt;/code&gt; if and only if the file denoted by this
          abstract pathname exists &lt;em&gt;and&lt;/em&gt; is a normal file;
          &lt;code&gt;false&lt;/code&gt; otherwise" fulltype="boolean" type="boolean">
				<comment>
					<description>Tests whether the file denoted by this abstract pathname is a normal
 file.  A file is &lt;em&gt;normal&lt;/em&gt; if it is not a directory and, in
 addition, satisfies other system-dependent criteria.  Any non-directory
 file created by a Java application is guaranteed to be a normal file.</description>
					<attribute name="@return">
						<description>&lt;code&gt;true&lt;/code&gt; if and only if the file denoted by this
          abstract pathname exists &lt;em&gt;and&lt;/em&gt; is a normal file;
          &lt;code&gt;false&lt;/code&gt; otherwise</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException
          If a security manager exists and its &lt;code&gt;{@link
          java.lang.SecurityManager#checkRead(java.lang.String)}&lt;/code&gt;
          method denies read access to the file</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="isHidden" returncomment="&lt;code&gt;true&lt;/code&gt; if and only if the file denoted by this
          abstract pathname is hidden according to the conventions of the
          underlying platform" fulltype="boolean" type="boolean">
				<comment>
					<description>Tests whether the file named by this abstract pathname is a hidden
 file.  The exact definition of &lt;em&gt;hidden&lt;/em&gt; is system-dependent.  On
 UNIX systems, a file is considered to be hidden if its name begins with
 a period character (&lt;code&gt;&apos;.&apos;&lt;/code&gt;).  On Microsoft Windows systems, a file is
 considered to be hidden if it has been marked as such in the filesystem.</description>
					<attribute name="@return">
						<description>&lt;code&gt;true&lt;/code&gt; if and only if the file denoted by this
          abstract pathname is hidden according to the conventions of the
          underlying platform</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException
          If a security manager exists and its &lt;code&gt;{@link
          java.lang.SecurityManager#checkRead(java.lang.String)}&lt;/code&gt;
          method denies read access to the file</description>
					</attribute>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="lastModified" returncomment="A &lt;code&gt;long&lt;/code&gt; value representing the time the file was
          last modified, measured in milliseconds since the epoch
          (00:00:00 GMT, January 1, 1970), or &lt;code&gt;0L&lt;/code&gt; if the
          file does not exist or if an I/O error occurs" fulltype="long" type="long">
				<comment>
					<description>Returns the time that the file denoted by this abstract pathname was
 last modified.</description>
					<attribute name="@return">
						<description>A &lt;code&gt;long&lt;/code&gt; value representing the time the file was
          last modified, measured in milliseconds since the epoch
          (00:00:00 GMT, January 1, 1970), or &lt;code&gt;0L&lt;/code&gt; if the
          file does not exist or if an I/O error occurs</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException
          If a security manager exists and its &lt;code&gt;{@link
          java.lang.SecurityManager#checkRead(java.lang.String)}&lt;/code&gt;
          method denies read access to the file</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="length" returncomment="The length, in bytes, of the file denoted by this abstract
          pathname, or &lt;code&gt;0L&lt;/code&gt; if the file does not exist.  Some
          operating systems may return &lt;code&gt;0L&lt;/code&gt; for pathnames
          denoting system-dependent entities such as devices or pipes." fulltype="long" type="long">
				<comment>
					<description>Returns the length of the file denoted by this abstract pathname.
 The return value is unspecified if this pathname denotes a directory.</description>
					<attribute name="@return">
						<description>The length, in bytes, of the file denoted by this abstract
          pathname, or &lt;code&gt;0L&lt;/code&gt; if the file does not exist.  Some
          operating systems may return &lt;code&gt;0L&lt;/code&gt; for pathnames
          denoting system-dependent entities such as devices or pipes.</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException
          If a security manager exists and its &lt;code&gt;{@link
          java.lang.SecurityManager#checkRead(java.lang.String)}&lt;/code&gt;
          method denies read access to the file</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="createNewFile" returncomment="&lt;code&gt;true&lt;/code&gt; if the named file does not exist and was
          successfully created; &lt;code&gt;false&lt;/code&gt; if the named file
          already exists" fulltype="boolean" type="boolean">
				<comment>
					<description>Atomically creates a new, empty file named by this abstract pathname if
 and only if a file with this name does not yet exist.  The check for the
 existence of the file and the creation of the file if it does not exist
 are a single operation that is atomic with respect to all other
 filesystem activities that might affect the file.
 &lt;P&gt;
 Note: this method should &lt;i&gt;not&lt;/i&gt; be used for file-locking, as
 the resulting protocol cannot be made to work reliably. The
 {@link java.nio.channels.FileLock FileLock}
 facility should be used instead.</description>
					<attribute name="@return">
						<description>&lt;code&gt;true&lt;/code&gt; if the named file does not exist and was
          successfully created; &lt;code&gt;false&lt;/code&gt; if the named file
          already exists</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException
          If an I/O error occurred</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException
          If a security manager exists and its &lt;code&gt;{@link
          java.lang.SecurityManager#checkWrite(java.lang.String)}&lt;/code&gt;
          method denies write access to the file</description>
					</attribute>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
				<exceptions>
					<exception comment="If an I/O error occurred" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="delete" returncomment="&lt;code&gt;true&lt;/code&gt; if and only if the file or directory is
          successfully deleted; &lt;code&gt;false&lt;/code&gt; otherwise" fulltype="boolean" type="boolean">
				<comment>
					<description>Deletes the file or directory denoted by this abstract pathname.  If
 this pathname denotes a directory, then the directory must be empty in
 order to be deleted.</description>
					<attribute name="@return">
						<description>&lt;code&gt;true&lt;/code&gt; if and only if the file or directory is
          successfully deleted; &lt;code&gt;false&lt;/code&gt; otherwise</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException
          If a security manager exists and its &lt;code&gt;{@link
          java.lang.SecurityManager#checkDelete}&lt;/code&gt; method denies
          delete access to the file</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="deleteOnExit" fulltype="void" type="void">
				<comment>
					<description>Requests that the file or directory denoted by this abstract
 pathname be deleted when the virtual machine terminates.
 Files (or directories) are deleted in the reverse order that
 they are registered. Invoking this method to delete a file or
 directory that is already registered for deletion has no effect.
 Deletion will be attempted only for normal termination of the
 virtual machine, as defined by the Java Language Specification.

 &lt;p&gt; Once deletion has been requested, it is not possible to cancel the
 request.  This method should therefore be used with care.

 &lt;P&gt;
 Note: this method should &lt;i&gt;not&lt;/i&gt; be used for file-locking, as
 the resulting protocol cannot be made to work reliably. The
 {@link java.nio.channels.FileLock FileLock}
 facility should be used instead.</description>
					<attribute name="@throws">
						<description>SecurityException
          If a security manager exists and its &lt;code&gt;{@link
          java.lang.SecurityManager#checkDelete}&lt;/code&gt; method denies
          delete access to the file</description>
					</attribute>
					<attribute name="@see">
						<description>#delete</description>
					</attribute>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="list" returncomment="An array of strings naming the files and directories in the
          directory denoted by this abstract pathname.  The array will be
          empty if the directory is empty.  Returns {@code null} if
          this abstract pathname does not denote a directory, or if an
          I/O error occurs." fulltype="java.lang.String[]" type="String">
				<comment>
					<description>Returns an array of strings naming the files and directories in the
 directory denoted by this abstract pathname.

 &lt;p&gt; If this abstract pathname does not denote a directory, then this
 method returns {@code null}.  Otherwise an array of strings is
 returned, one for each file or directory in the directory.  Names
 denoting the directory itself and the directory&apos;s parent directory are
 not included in the result.  Each string is a file name rather than a
 complete path.

 &lt;p&gt; There is no guarantee that the name strings in the resulting array
 will appear in any specific order; they are not, in particular,
 guaranteed to appear in alphabetical order.</description>
					<attribute name="@return">
						<description>An array of strings naming the files and directories in the
          directory denoted by this abstract pathname.  The array will be
          empty if the directory is empty.  Returns {@code null} if
          this abstract pathname does not denote a directory, or if an
          I/O error occurs.</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException
          If a security manager exists and its {@link
          SecurityManager#checkRead(String)} method denies read access to
          the directory</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="list" returncomment="An array of strings naming the files and directories in the
          directory denoted by this abstract pathname that were accepted
          by the given {@code filter}.  The array will be empty if the
          directory is empty or if no names were accepted by the filter.
          Returns {@code null} if this abstract pathname does not denote
          a directory, or if an I/O error occurs." fulltype="java.lang.String[]" type="String">
				<comment>
					<description>Returns an array of strings naming the files and directories in the
 directory denoted by this abstract pathname that satisfy the specified
 filter.  The behavior of this method is the same as that of the
 {@link #list()} method, except that the strings in the returned array
 must satisfy the filter.  If the given {@code filter} is {@code null}
 then all names are accepted.  Otherwise, a name satisfies the filter if
 and only if the value {@code true} results when the {@link
 FilenameFilter#accept FilenameFilter.accept(File,&amp;nbsp;String)} method
 of the filter is invoked on this abstract pathname and the name of a
 file or directory in the directory that it denotes.</description>
					<attribute name="@param">
						<description>filter
         A filename filter</description>
					</attribute>
					<attribute name="@return">
						<description>An array of strings naming the files and directories in the
          directory denoted by this abstract pathname that were accepted
          by the given {@code filter}.  The array will be empty if the
          directory is empty or if no names were accepted by the filter.
          Returns {@code null} if this abstract pathname does not denote
          a directory, or if an I/O error occurs.</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException
          If a security manager exists and its {@link
          SecurityManager#checkRead(String)} method denies read access to
          the directory</description>
					</attribute>
				</comment>
				<params>
					<param name="filter" comment="A filename filter" fulltype="java.io.FilenameFilter" type="FilenameFilter" />
				</params>
			</method>
			<method visibility="public" name="listFiles" returncomment="An array of abstract pathnames denoting the files and
          directories in the directory denoted by this abstract pathname.
          The array will be empty if the directory is empty.  Returns
          {@code null} if this abstract pathname does not denote a
          directory, or if an I/O error occurs." fulltype="java.io.File[]" type="File">
				<comment>
					<description>Returns an array of abstract pathnames denoting the files in the
 directory denoted by this abstract pathname.

 &lt;p&gt; If this abstract pathname does not denote a directory, then this
 method returns {@code null}.  Otherwise an array of {@code File} objects
 is returned, one for each file or directory in the directory.  Pathnames
 denoting the directory itself and the directory&apos;s parent directory are
 not included in the result.  Each resulting abstract pathname is
 constructed from this abstract pathname using the {@link #File(File,
 String) File(File,&amp;nbsp;String)} constructor.  Therefore if this
 pathname is absolute then each resulting pathname is absolute; if this
 pathname is relative then each resulting pathname will be relative to
 the same directory.

 &lt;p&gt; There is no guarantee that the name strings in the resulting array
 will appear in any specific order; they are not, in particular,
 guaranteed to appear in alphabetical order.</description>
					<attribute name="@return">
						<description>An array of abstract pathnames denoting the files and
          directories in the directory denoted by this abstract pathname.
          The array will be empty if the directory is empty.  Returns
          {@code null} if this abstract pathname does not denote a
          directory, or if an I/O error occurs.</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException
          If a security manager exists and its {@link
          SecurityManager#checkRead(String)} method denies read access to
          the directory</description>
					</attribute>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="listFiles" returncomment="An array of abstract pathnames denoting the files and
          directories in the directory denoted by this abstract pathname.
          The array will be empty if the directory is empty.  Returns
          {@code null} if this abstract pathname does not denote a
          directory, or if an I/O error occurs." fulltype="java.io.File[]" type="File">
				<comment>
					<description>Returns an array of abstract pathnames denoting the files and
 directories in the directory denoted by this abstract pathname that
 satisfy the specified filter.  The behavior of this method is the same
 as that of the {@link #listFiles()} method, except that the pathnames in
 the returned array must satisfy the filter.  If the given {@code filter}
 is {@code null} then all pathnames are accepted.  Otherwise, a pathname
 satisfies the filter if and only if the value {@code true} results when
 the {@link FilenameFilter#accept
 FilenameFilter.accept(File,&amp;nbsp;String)} method of the filter is
 invoked on this abstract pathname and the name of a file or directory in
 the directory that it denotes.</description>
					<attribute name="@param">
						<description>filter
         A filename filter</description>
					</attribute>
					<attribute name="@return">
						<description>An array of abstract pathnames denoting the files and
          directories in the directory denoted by this abstract pathname.
          The array will be empty if the directory is empty.  Returns
          {@code null} if this abstract pathname does not denote a
          directory, or if an I/O error occurs.</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException
          If a security manager exists and its {@link
          SecurityManager#checkRead(String)} method denies read access to
          the directory</description>
					</attribute>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
				<params>
					<param name="filter" comment="A filename filter" fulltype="java.io.FilenameFilter" type="FilenameFilter" />
				</params>
			</method>
			<method visibility="public" name="listFiles" returncomment="An array of abstract pathnames denoting the files and
          directories in the directory denoted by this abstract pathname.
          The array will be empty if the directory is empty.  Returns
          {@code null} if this abstract pathname does not denote a
          directory, or if an I/O error occurs." fulltype="java.io.File[]" type="File">
				<comment>
					<description>Returns an array of abstract pathnames denoting the files and
 directories in the directory denoted by this abstract pathname that
 satisfy the specified filter.  The behavior of this method is the same
 as that of the {@link #listFiles()} method, except that the pathnames in
 the returned array must satisfy the filter.  If the given {@code filter}
 is {@code null} then all pathnames are accepted.  Otherwise, a pathname
 satisfies the filter if and only if the value {@code true} results when
 the {@link FileFilter#accept FileFilter.accept(File)} method of the
 filter is invoked on the pathname.</description>
					<attribute name="@param">
						<description>filter
         A file filter</description>
					</attribute>
					<attribute name="@return">
						<description>An array of abstract pathnames denoting the files and
          directories in the directory denoted by this abstract pathname.
          The array will be empty if the directory is empty.  Returns
          {@code null} if this abstract pathname does not denote a
          directory, or if an I/O error occurs.</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException
          If a security manager exists and its {@link
          SecurityManager#checkRead(String)} method denies read access to
          the directory</description>
					</attribute>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
				<params>
					<param name="filter" comment="A file filter" fulltype="java.io.FileFilter" type="FileFilter" />
				</params>
			</method>
			<method visibility="public" name="mkdir" returncomment="&lt;code&gt;true&lt;/code&gt; if and only if the directory was
          created; &lt;code&gt;false&lt;/code&gt; otherwise" fulltype="boolean" type="boolean">
				<comment>
					<description>Creates the directory named by this abstract pathname.</description>
					<attribute name="@return">
						<description>&lt;code&gt;true&lt;/code&gt; if and only if the directory was
          created; &lt;code&gt;false&lt;/code&gt; otherwise</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException
          If a security manager exists and its &lt;code&gt;{@link
          java.lang.SecurityManager#checkWrite(java.lang.String)}&lt;/code&gt;
          method does not permit the named directory to be created</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="mkdirs" returncomment="&lt;code&gt;true&lt;/code&gt; if and only if the directory was created,
          along with all necessary parent directories; &lt;code&gt;false&lt;/code&gt;
          otherwise" fulltype="boolean" type="boolean">
				<comment>
					<description>Creates the directory named by this abstract pathname, including any
 necessary but nonexistent parent directories.  Note that if this
 operation fails it may have succeeded in creating some of the necessary
 parent directories.</description>
					<attribute name="@return">
						<description>&lt;code&gt;true&lt;/code&gt; if and only if the directory was created,
          along with all necessary parent directories; &lt;code&gt;false&lt;/code&gt;
          otherwise</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException
          If a security manager exists and its &lt;code&gt;{@link
          java.lang.SecurityManager#checkRead(java.lang.String)}&lt;/code&gt;
          method does not permit verification of the existence of the
          named directory and all necessary parent directories; or if
          the &lt;code&gt;{@link
          java.lang.SecurityManager#checkWrite(java.lang.String)}&lt;/code&gt;
          method does not permit the named directory and all necessary
          parent directories to be created</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="renameTo" returncomment="&lt;code&gt;true&lt;/code&gt; if and only if the renaming succeeded;
          &lt;code&gt;false&lt;/code&gt; otherwise" fulltype="boolean" type="boolean">
				<comment>
					<description>Renames the file denoted by this abstract pathname.

 &lt;p&gt; Many aspects of the behavior of this method are inherently
 platform-dependent: The rename operation might not be able to move a
 file from one filesystem to another, it might not be atomic, and it
 might not succeed if a file with the destination abstract pathname
 already exists.  The return value should always be checked to make sure
 that the rename operation was successful.</description>
					<attribute name="@param">
						<description>dest  The new abstract pathname for the named file</description>
					</attribute>
					<attribute name="@return">
						<description>&lt;code&gt;true&lt;/code&gt; if and only if the renaming succeeded;
          &lt;code&gt;false&lt;/code&gt; otherwise</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException
          If a security manager exists and its &lt;code&gt;{@link
          java.lang.SecurityManager#checkWrite(java.lang.String)}&lt;/code&gt;
          method denies write access to either the old or new pathnames</description>
					</attribute>
					<attribute name="@throws">
						<description>NullPointerException
          If parameter &lt;code&gt;dest&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</description>
					</attribute>
				</comment>
				<params>
					<param name="dest" comment="The new abstract pathname for the named file" fulltype="java.io.File" type="File" />
				</params>
			</method>
			<method visibility="public" name="setLastModified" returncomment="&lt;code&gt;true&lt;/code&gt; if and only if the operation succeeded;
          &lt;code&gt;false&lt;/code&gt; otherwise" fulltype="boolean" type="boolean">
				<comment>
					<description>Sets the last-modified time of the file or directory named by this
 abstract pathname.

 &lt;p&gt; All platforms support file-modification times to the nearest second,
 but some provide more precision.  The argument will be truncated to fit
 the supported precision.  If the operation succeeds and no intervening
 operations on the file take place, then the next invocation of the
 &lt;code&gt;{@link #lastModified}&lt;/code&gt; method will return the (possibly
 truncated) &lt;code&gt;time&lt;/code&gt; argument that was passed to this method.</description>
					<attribute name="@param">
						<description>time  The new last-modified time, measured in milliseconds since
               the epoch (00:00:00 GMT, January 1, 1970)</description>
					</attribute>
					<attribute name="@return">
						<description>&lt;code&gt;true&lt;/code&gt; if and only if the operation succeeded;
          &lt;code&gt;false&lt;/code&gt; otherwise</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException  If the argument is negative</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException
          If a security manager exists and its &lt;code&gt;{@link
          java.lang.SecurityManager#checkWrite(java.lang.String)}&lt;/code&gt;
          method denies write access to the named file</description>
					</attribute>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
				<params>
					<param name="time" comment="The new last-modified time, measured in milliseconds since
               the epoch (00:00:00 GMT, January 1, 1970)" fulltype="long" type="long" />
				</params>
			</method>
			<method visibility="public" name="setReadOnly" returncomment="&lt;code&gt;true&lt;/code&gt; if and only if the operation succeeded;
          &lt;code&gt;false&lt;/code&gt; otherwise" fulltype="boolean" type="boolean">
				<comment>
					<description>Marks the file or directory named by this abstract pathname so that
 only read operations are allowed.  After invoking this method the file
 or directory is guaranteed not to change until it is either deleted or
 marked to allow write access.  Whether or not a read-only file or
 directory may be deleted depends upon the underlying system.</description>
					<attribute name="@return">
						<description>&lt;code&gt;true&lt;/code&gt; if and only if the operation succeeded;
          &lt;code&gt;false&lt;/code&gt; otherwise</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException
          If a security manager exists and its &lt;code&gt;{@link
          java.lang.SecurityManager#checkWrite(java.lang.String)}&lt;/code&gt;
          method denies write access to the named file</description>
					</attribute>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="setWritable" returncomment="&lt;code&gt;true&lt;/code&gt; if and only if the operation succeeded. The
          operation will fail if the user does not have permission to change
          the access permissions of this abstract pathname." fulltype="boolean" type="boolean">
				<comment>
					<description>Sets the owner&apos;s or everybody&apos;s write permission for this abstract
 pathname.</description>
					<attribute name="@param">
						<description>writable
          If &lt;code&gt;true&lt;/code&gt;, sets the access permission to allow write
          operations; if &lt;code&gt;false&lt;/code&gt; to disallow write operations</description>
					</attribute>
					<attribute name="@param">
						<description>ownerOnly
          If &lt;code&gt;true&lt;/code&gt;, the write permission applies only to the
          owner&apos;s write permission; otherwise, it applies to everybody.  If
          the underlying file system can not distinguish the owner&apos;s write
          permission from that of others, then the permission will apply to
          everybody, regardless of this value.</description>
					</attribute>
					<attribute name="@return">
						<description>&lt;code&gt;true&lt;/code&gt; if and only if the operation succeeded. The
          operation will fail if the user does not have permission to change
          the access permissions of this abstract pathname.</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException
          If a security manager exists and its &lt;code&gt;{@link
          java.lang.SecurityManager#checkWrite(java.lang.String)}&lt;/code&gt;
          method denies write access to the named file</description>
					</attribute>
					<attribute name="@since">
						<description>1.6</description>
					</attribute>
				</comment>
				<params>
					<param name="writable" comment="If &lt;code&gt;true&lt;/code&gt;, sets the access permission to allow write
          operations; if &lt;code&gt;false&lt;/code&gt; to disallow write operations" fulltype="boolean" type="boolean" />
					<param name="ownerOnly" comment="If &lt;code&gt;true&lt;/code&gt;, the write permission applies only to the
          owner&apos;s write permission; otherwise, it applies to everybody.  If
          the underlying file system can not distinguish the owner&apos;s write
          permission from that of others, then the permission will apply to
          everybody, regardless of this value." fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method visibility="public" name="setWritable" returncomment="&lt;code&gt;true&lt;/code&gt; if and only if the operation succeeded.  The
          operation will fail if the user does not have permission to
          change the access permissions of this abstract pathname." fulltype="boolean" type="boolean">
				<comment>
					<description>A convenience method to set the owner&apos;s write permission for this abstract
 pathname.

 &lt;p&gt; An invocation of this method of the form &lt;tt&gt;file.setWritable(arg)&lt;/tt&gt;
 behaves in exactly the same way as the invocation

 &lt;pre&gt;
     file.setWritable(arg, true) &lt;/pre&gt;</description>
					<attribute name="@param">
						<description>writable
          If &lt;code&gt;true&lt;/code&gt;, sets the access permission to allow write
          operations; if &lt;code&gt;false&lt;/code&gt; to disallow write operations</description>
					</attribute>
					<attribute name="@return">
						<description>&lt;code&gt;true&lt;/code&gt; if and only if the operation succeeded.  The
          operation will fail if the user does not have permission to
          change the access permissions of this abstract pathname.</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException
          If a security manager exists and its &lt;code&gt;{@link
          java.lang.SecurityManager#checkWrite(java.lang.String)}&lt;/code&gt;
          method denies write access to the file</description>
					</attribute>
					<attribute name="@since">
						<description>1.6</description>
					</attribute>
				</comment>
				<params>
					<param name="writable" comment="If &lt;code&gt;true&lt;/code&gt;, sets the access permission to allow write
          operations; if &lt;code&gt;false&lt;/code&gt; to disallow write operations" fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method visibility="public" name="setReadable" returncomment="&lt;code&gt;true&lt;/code&gt; if and only if the operation succeeded.  The
          operation will fail if the user does not have permission to
          change the access permissions of this abstract pathname.  If
          &lt;code&gt;readable&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; and the underlying
          file system does not implement a read permission, then the
          operation will fail." fulltype="boolean" type="boolean">
				<comment>
					<description>Sets the owner&apos;s or everybody&apos;s read permission for this abstract
 pathname.</description>
					<attribute name="@param">
						<description>readable
          If &lt;code&gt;true&lt;/code&gt;, sets the access permission to allow read
          operations; if &lt;code&gt;false&lt;/code&gt; to disallow read operations</description>
					</attribute>
					<attribute name="@param">
						<description>ownerOnly
          If &lt;code&gt;true&lt;/code&gt;, the read permission applies only to the
          owner&apos;s read permission; otherwise, it applies to everybody.  If
          the underlying file system can not distinguish the owner&apos;s read
          permission from that of others, then the permission will apply to
          everybody, regardless of this value.</description>
					</attribute>
					<attribute name="@return">
						<description>&lt;code&gt;true&lt;/code&gt; if and only if the operation succeeded.  The
          operation will fail if the user does not have permission to
          change the access permissions of this abstract pathname.  If
          &lt;code&gt;readable&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; and the underlying
          file system does not implement a read permission, then the
          operation will fail.</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException
          If a security manager exists and its &lt;code&gt;{@link
          java.lang.SecurityManager#checkWrite(java.lang.String)}&lt;/code&gt;
          method denies write access to the file</description>
					</attribute>
					<attribute name="@since">
						<description>1.6</description>
					</attribute>
				</comment>
				<params>
					<param name="readable" comment="If &lt;code&gt;true&lt;/code&gt;, sets the access permission to allow read
          operations; if &lt;code&gt;false&lt;/code&gt; to disallow read operations" fulltype="boolean" type="boolean" />
					<param name="ownerOnly" comment="If &lt;code&gt;true&lt;/code&gt;, the read permission applies only to the
          owner&apos;s read permission; otherwise, it applies to everybody.  If
          the underlying file system can not distinguish the owner&apos;s read
          permission from that of others, then the permission will apply to
          everybody, regardless of this value." fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method visibility="public" name="setReadable" returncomment="&lt;code&gt;true&lt;/code&gt; if and only if the operation succeeded.  The
          operation will fail if the user does not have permission to
          change the access permissions of this abstract pathname.  If
          &lt;code&gt;readable&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; and the underlying
          file system does not implement a read permission, then the
          operation will fail." fulltype="boolean" type="boolean">
				<comment>
					<description>A convenience method to set the owner&apos;s read permission for this abstract
 pathname.

 &lt;p&gt;An invocation of this method of the form &lt;tt&gt;file.setReadable(arg)&lt;/tt&gt;
 behaves in exactly the same way as the invocation

 &lt;pre&gt;
     file.setReadable(arg, true) &lt;/pre&gt;</description>
					<attribute name="@param">
						<description>readable
          If &lt;code&gt;true&lt;/code&gt;, sets the access permission to allow read
          operations; if &lt;code&gt;false&lt;/code&gt; to disallow read operations</description>
					</attribute>
					<attribute name="@return">
						<description>&lt;code&gt;true&lt;/code&gt; if and only if the operation succeeded.  The
          operation will fail if the user does not have permission to
          change the access permissions of this abstract pathname.  If
          &lt;code&gt;readable&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; and the underlying
          file system does not implement a read permission, then the
          operation will fail.</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException
          If a security manager exists and its &lt;code&gt;{@link
          java.lang.SecurityManager#checkWrite(java.lang.String)}&lt;/code&gt;
          method denies write access to the file</description>
					</attribute>
					<attribute name="@since">
						<description>1.6</description>
					</attribute>
				</comment>
				<params>
					<param name="readable" comment="If &lt;code&gt;true&lt;/code&gt;, sets the access permission to allow read
          operations; if &lt;code&gt;false&lt;/code&gt; to disallow read operations" fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method visibility="public" name="setExecutable" returncomment="&lt;code&gt;true&lt;/code&gt; if and only if the operation succeeded.  The
          operation will fail if the user does not have permission to
          change the access permissions of this abstract pathname.  If
          &lt;code&gt;executable&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; and the underlying
          file system does not implement an execute permission, then the
          operation will fail." fulltype="boolean" type="boolean">
				<comment>
					<description>Sets the owner&apos;s or everybody&apos;s execute permission for this abstract
 pathname.</description>
					<attribute name="@param">
						<description>executable
          If &lt;code&gt;true&lt;/code&gt;, sets the access permission to allow execute
          operations; if &lt;code&gt;false&lt;/code&gt; to disallow execute operations</description>
					</attribute>
					<attribute name="@param">
						<description>ownerOnly
          If &lt;code&gt;true&lt;/code&gt;, the execute permission applies only to the
          owner&apos;s execute permission; otherwise, it applies to everybody.
          If the underlying file system can not distinguish the owner&apos;s
          execute permission from that of others, then the permission will
          apply to everybody, regardless of this value.</description>
					</attribute>
					<attribute name="@return">
						<description>&lt;code&gt;true&lt;/code&gt; if and only if the operation succeeded.  The
          operation will fail if the user does not have permission to
          change the access permissions of this abstract pathname.  If
          &lt;code&gt;executable&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; and the underlying
          file system does not implement an execute permission, then the
          operation will fail.</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException
          If a security manager exists and its &lt;code&gt;{@link
          java.lang.SecurityManager#checkWrite(java.lang.String)}&lt;/code&gt;
          method denies write access to the file</description>
					</attribute>
					<attribute name="@since">
						<description>1.6</description>
					</attribute>
				</comment>
				<params>
					<param name="executable" comment="If &lt;code&gt;true&lt;/code&gt;, sets the access permission to allow execute
          operations; if &lt;code&gt;false&lt;/code&gt; to disallow execute operations" fulltype="boolean" type="boolean" />
					<param name="ownerOnly" comment="If &lt;code&gt;true&lt;/code&gt;, the execute permission applies only to the
          owner&apos;s execute permission; otherwise, it applies to everybody.
          If the underlying file system can not distinguish the owner&apos;s
          execute permission from that of others, then the permission will
          apply to everybody, regardless of this value." fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method visibility="public" name="setExecutable" returncomment="&lt;code&gt;true&lt;/code&gt; if and only if the operation succeeded.  The
           operation will fail if the user does not have permission to
           change the access permissions of this abstract pathname.  If
           &lt;code&gt;executable&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; and the underlying
           file system does not implement an excute permission, then the
           operation will fail." fulltype="boolean" type="boolean">
				<comment>
					<description>A convenience method to set the owner&apos;s execute permission for this abstract
 pathname.

 &lt;p&gt;An invocation of this method of the form &lt;tt&gt;file.setExcutable(arg)&lt;/tt&gt;
 behaves in exactly the same way as the invocation

 &lt;pre&gt;
     file.setExecutable(arg, true) &lt;/pre&gt;</description>
					<attribute name="@param">
						<description>executable
          If &lt;code&gt;true&lt;/code&gt;, sets the access permission to allow execute
          operations; if &lt;code&gt;false&lt;/code&gt; to disallow execute operations</description>
					</attribute>
					<attribute name="@return">
						<description>&lt;code&gt;true&lt;/code&gt; if and only if the operation succeeded.  The
           operation will fail if the user does not have permission to
           change the access permissions of this abstract pathname.  If
           &lt;code&gt;executable&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; and the underlying
           file system does not implement an excute permission, then the
           operation will fail.</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException
          If a security manager exists and its &lt;code&gt;{@link
          java.lang.SecurityManager#checkWrite(java.lang.String)}&lt;/code&gt;
          method denies write access to the file</description>
					</attribute>
					<attribute name="@since">
						<description>1.6</description>
					</attribute>
				</comment>
				<params>
					<param name="executable" comment="If &lt;code&gt;true&lt;/code&gt;, sets the access permission to allow execute
          operations; if &lt;code&gt;false&lt;/code&gt; to disallow execute operations" fulltype="boolean" type="boolean" />
				</params>
			</method>
			<method visibility="public" name="canExecute" returncomment="&lt;code&gt;true&lt;/code&gt; if and only if the abstract pathname exists
          &lt;em&gt;and&lt;/em&gt; the application is allowed to execute the file" fulltype="boolean" type="boolean">
				<comment>
					<description>Tests whether the application can execute the file denoted by this
 abstract pathname.</description>
					<attribute name="@return">
						<description>&lt;code&gt;true&lt;/code&gt; if and only if the abstract pathname exists
          &lt;em&gt;and&lt;/em&gt; the application is allowed to execute the file</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException
          If a security manager exists and its &lt;code&gt;{@link
          java.lang.SecurityManager#checkExec(java.lang.String)}&lt;/code&gt;
          method denies execute access to the file</description>
					</attribute>
					<attribute name="@since">
						<description>1.6</description>
					</attribute>
				</comment>
			</method>
			<method static="true" visibility="public" name="listRoots" returncomment="An array of {@code File} objects denoting the available
          filesystem roots, or {@code null} if the set of roots could not
          be determined.  The array will be empty if there are no
          filesystem roots." fulltype="java.io.File[]" type="File">
				<comment>
					<description>List the available filesystem roots.

 &lt;p&gt; A particular Java platform may support zero or more
 hierarchically-organized file systems.  Each file system has a
 {@code root} directory from which all other files in that file system
 can be reached.  Windows platforms, for example, have a root directory
 for each active drive; UNIX platforms have a single root directory,
 namely {@code &quot;/&quot;}.  The set of available filesystem roots is affected
 by various system-level operations such as the insertion or ejection of
 removable media and the disconnecting or unmounting of physical or
 virtual disk drives.

 &lt;p&gt; This method returns an array of {@code File} objects that denote the
 root directories of the available filesystem roots.  It is guaranteed
 that the canonical pathname of any file physically present on the local
 machine will begin with one of the roots returned by this method.

 &lt;p&gt; The canonical pathname of a file that resides on some other machine
 and is accessed via a remote-filesystem protocol such as SMB or NFS may
 or may not begin with one of the roots returned by this method.  If the
 pathname of a remote file is syntactically indistinguishable from the
 pathname of a local file then it will begin with one of the roots
 returned by this method.  Thus, for example, {@code File} objects
 denoting the root directories of the mapped network drives of a Windows
 platform will be returned by this method, while {@code File} objects
 containing UNC pathnames will not be returned by this method.

 &lt;p&gt; Unlike most methods in this class, this method does not throw
 security exceptions.  If a security manager exists and its {@link
 SecurityManager#checkRead(String)} method denies read access to a
 particular root directory, then that directory will not appear in the
 result.</description>
					<attribute name="@return">
						<description>An array of {@code File} objects denoting the available
          filesystem roots, or {@code null} if the set of roots could not
          be determined.  The array will be empty if there are no
          filesystem roots.</description>
					</attribute>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getTotalSpace" returncomment="The size, in bytes, of the partition or &lt;tt&gt;0L&lt;/tt&gt; if this
          abstract pathname does not name a partition" fulltype="long" type="long">
				<comment>
					<description>Returns the size of the partition &lt;a href=&quot;#partName&quot;&gt;named&lt;/a&gt; by this
 abstract pathname.</description>
					<attribute name="@return">
						<description>The size, in bytes, of the partition or &lt;tt&gt;0L&lt;/tt&gt; if this
          abstract pathname does not name a partition</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException
          If a security manager has been installed and it denies
          {@link RuntimePermission}&lt;tt&gt;(&quot;getFileSystemAttributes&quot;)&lt;/tt&gt;
          or its {@link SecurityManager#checkRead(String)} method denies
          read access to the file named by this abstract pathname</description>
					</attribute>
					<attribute name="@since">
						<description>1.6</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getFreeSpace" returncomment="The number of unallocated bytes on the partition &lt;tt&gt;0L&lt;/tt&gt;
          if the abstract pathname does not name a partition.  This
          value will be less than or equal to the total file system size
          returned by {@link #getTotalSpace}." fulltype="long" type="long">
				<comment>
					<description>Returns the number of unallocated bytes in the partition &lt;a
 href=&quot;#partName&quot;&gt;named&lt;/a&gt; by this abstract path name.

 &lt;p&gt; The returned number of unallocated bytes is a hint, but not
 a guarantee, that it is possible to use most or any of these
 bytes.  The number of unallocated bytes is most likely to be
 accurate immediately after this call.  It is likely to be made
 inaccurate by any external I/O operations including those made
 on the system outside of this virtual machine.  This method
 makes no guarantee that write operations to this file system
 will succeed.</description>
					<attribute name="@return">
						<description>The number of unallocated bytes on the partition &lt;tt&gt;0L&lt;/tt&gt;
          if the abstract pathname does not name a partition.  This
          value will be less than or equal to the total file system size
          returned by {@link #getTotalSpace}.</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException
          If a security manager has been installed and it denies
          {@link RuntimePermission}&lt;tt&gt;(&quot;getFileSystemAttributes&quot;)&lt;/tt&gt;
          or its {@link SecurityManager#checkRead(String)} method denies
          read access to the file named by this abstract pathname</description>
					</attribute>
					<attribute name="@since">
						<description>1.6</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="getUsableSpace" returncomment="The number of available bytes on the partition or &lt;tt&gt;0L&lt;/tt&gt;
          if the abstract pathname does not name a partition.  On
          systems where this information is not available, this method
          will be equivalent to a call to {@link #getFreeSpace}." fulltype="long" type="long">
				<comment>
					<description>Returns the number of bytes available to this virtual machine on the
 partition &lt;a href=&quot;#partName&quot;&gt;named&lt;/a&gt; by this abstract pathname.  When
 possible, this method checks for write permissions and other operating
 system restrictions and will therefore usually provide a more accurate
 estimate of how much new data can actually be written than {@link
 #getFreeSpace}.

 &lt;p&gt; The returned number of available bytes is a hint, but not a
 guarantee, that it is possible to use most or any of these bytes.  The
 number of unallocated bytes is most likely to be accurate immediately
 after this call.  It is likely to be made inaccurate by any external
 I/O operations including those made on the system outside of this
 virtual machine.  This method makes no guarantee that write operations
 to this file system will succeed.</description>
					<attribute name="@return">
						<description>The number of available bytes on the partition or &lt;tt&gt;0L&lt;/tt&gt;
          if the abstract pathname does not name a partition.  On
          systems where this information is not available, this method
          will be equivalent to a call to {@link #getFreeSpace}.</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException
          If a security manager has been installed and it denies
          {@link RuntimePermission}&lt;tt&gt;(&quot;getFileSystemAttributes&quot;)&lt;/tt&gt;
          or its {@link SecurityManager#checkRead(String)} method denies
          read access to the file named by this abstract pathname</description>
					</attribute>
					<attribute name="@since">
						<description>1.6</description>
					</attribute>
				</comment>
			</method>
			<method static="true" visibility="private" name="generateFile" fulltype="java.io.File" type="File">
				<params>
					<param name="prefix" fulltype="java.lang.String" type="String" />
					<param name="suffix" fulltype="java.lang.String" type="String" />
					<param name="dir" fulltype="java.io.File" type="File" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method static="true" visibility="private" name="checkAndCreate" fulltype="boolean" type="boolean">
				<params>
					<param name="filename" fulltype="java.lang.String" type="String" />
					<param name="sm" fulltype="java.lang.SecurityManager" type="SecurityManager" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method static="true" visibility="public" name="createTempFile" returncomment="An abstract pathname denoting a newly-created empty file" fulltype="java.io.File" type="File">
				<comment>
					<description>&lt;p&gt; Creates a new empty file in the specified directory, using the
 given prefix and suffix strings to generate its name.  If this method
 returns successfully then it is guaranteed that:

 &lt;ol&gt;
 &lt;li&gt; The file denoted by the returned abstract pathname did not exist
      before this method was invoked, and
 &lt;li&gt; Neither this method nor any of its variants will return the same
      abstract pathname again in the current invocation of the virtual
      machine.
 &lt;/ol&gt;

 This method provides only part of a temporary-file facility.  To arrange
 for a file created by this method to be deleted automatically, use the
 &lt;code&gt;{@link #deleteOnExit}&lt;/code&gt; method.

 &lt;p&gt; The &lt;code&gt;prefix&lt;/code&gt; argument must be at least three characters
 long.  It is recommended that the prefix be a short, meaningful string
 such as &lt;code&gt;&quot;hjb&quot;&lt;/code&gt; or &lt;code&gt;&quot;mail&quot;&lt;/code&gt;.  The
 &lt;code&gt;suffix&lt;/code&gt; argument may be &lt;code&gt;null&lt;/code&gt;, in which case the
 suffix &lt;code&gt;&quot;.tmp&quot;&lt;/code&gt; will be used.

 &lt;p&gt; To create the new file, the prefix and the suffix may first be
 adjusted to fit the limitations of the underlying platform.  If the
 prefix is too long then it will be truncated, but its first three
 characters will always be preserved.  If the suffix is too long then it
 too will be truncated, but if it begins with a period character
 (&lt;code&gt;&apos;.&apos;&lt;/code&gt;) then the period and the first three characters
 following it will always be preserved.  Once these adjustments have been
 made the name of the new file will be generated by concatenating the
 prefix, five or more internally-generated characters, and the suffix.

 &lt;p&gt; If the &lt;code&gt;directory&lt;/code&gt; argument is &lt;code&gt;null&lt;/code&gt; then the
 system-dependent default temporary-file directory will be used.  The
 default temporary-file directory is specified by the system property
 &lt;code&gt;java.io.tmpdir&lt;/code&gt;.  On UNIX systems the default value of this
 property is typically &lt;code&gt;&quot;/tmp&quot;&lt;/code&gt; or &lt;code&gt;&quot;/var/tmp&quot;&lt;/code&gt;; on
 Microsoft Windows systems it is typically &lt;code&gt;&quot;C:\\WINNT\\TEMP&quot;&lt;/code&gt;.  A different
 value may be given to this system property when the Java virtual machine
 is invoked, but programmatic changes to this property are not guaranteed
 to have any effect upon the temporary directory used by this method.</description>
					<attribute name="@param">
						<description>prefix     The prefix string to be used in generating the file&apos;s
                    name; must be at least three characters long</description>
					</attribute>
					<attribute name="@param">
						<description>suffix     The suffix string to be used in generating the file&apos;s
                    name; may be &lt;code&gt;null&lt;/code&gt;, in which case the
                    suffix &lt;code&gt;&quot;.tmp&quot;&lt;/code&gt; will be used</description>
					</attribute>
					<attribute name="@param">
						<description>directory  The directory in which the file is to be created, or
                    &lt;code&gt;null&lt;/code&gt; if the default temporary-file
                    directory is to be used</description>
					</attribute>
					<attribute name="@return">
						<description>An abstract pathname denoting a newly-created empty file</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException
          If the &lt;code&gt;prefix&lt;/code&gt; argument contains fewer than three
          characters</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException  If a file could not be created</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException
          If a security manager exists and its &lt;code&gt;{@link
          java.lang.SecurityManager#checkWrite(java.lang.String)}&lt;/code&gt;
          method does not allow a file to be created</description>
					</attribute>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
				<params>
					<param name="prefix" comment="The prefix string to be used in generating the file&apos;s
                    name; must be at least three characters long" fulltype="java.lang.String" type="String" />
					<param name="suffix" comment="The suffix string to be used in generating the file&apos;s
                    name; may be &lt;code&gt;null&lt;/code&gt;, in which case the
                    suffix &lt;code&gt;&quot;.tmp&quot;&lt;/code&gt; will be used" fulltype="java.lang.String" type="String" />
					<param name="directory" comment="The directory in which the file is to be created, or
                    &lt;code&gt;null&lt;/code&gt; if the default temporary-file
                    directory is to be used" fulltype="java.io.File" type="File" />
				</params>
				<exceptions>
					<exception comment="If a file could not be created" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method static="true" visibility="public" name="createTempFile" returncomment="An abstract pathname denoting a newly-created empty file" fulltype="java.io.File" type="File">
				<comment>
					<description>Creates an empty file in the default temporary-file directory, using
 the given prefix and suffix to generate its name.  Invoking this method
 is equivalent to invoking &lt;code&gt;{@link #createTempFile(java.lang.String,
 java.lang.String, java.io.File)
 createTempFile(prefix,&amp;nbsp;suffix,&amp;nbsp;null)}&lt;/code&gt;.</description>
					<attribute name="@param">
						<description>prefix     The prefix string to be used in generating the file&apos;s
                    name; must be at least three characters long</description>
					</attribute>
					<attribute name="@param">
						<description>suffix     The suffix string to be used in generating the file&apos;s
                    name; may be &lt;code&gt;null&lt;/code&gt;, in which case the
                    suffix &lt;code&gt;&quot;.tmp&quot;&lt;/code&gt; will be used</description>
					</attribute>
					<attribute name="@return">
						<description>An abstract pathname denoting a newly-created empty file</description>
					</attribute>
					<attribute name="@throws">
						<description>IllegalArgumentException
          If the &lt;code&gt;prefix&lt;/code&gt; argument contains fewer than three
          characters</description>
					</attribute>
					<attribute name="@throws">
						<description>IOException  If a file could not be created</description>
					</attribute>
					<attribute name="@throws">
						<description>SecurityException
          If a security manager exists and its &lt;code&gt;{@link
          java.lang.SecurityManager#checkWrite(java.lang.String)}&lt;/code&gt;
          method does not allow a file to be created</description>
					</attribute>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
				<params>
					<param name="prefix" comment="The prefix string to be used in generating the file&apos;s
                    name; must be at least three characters long" fulltype="java.lang.String" type="String" />
					<param name="suffix" comment="The suffix string to be used in generating the file&apos;s
                    name; may be &lt;code&gt;null&lt;/code&gt;, in which case the
                    suffix &lt;code&gt;&quot;.tmp&quot;&lt;/code&gt; will be used" fulltype="java.lang.String" type="String" />
				</params>
				<exceptions>
					<exception comment="If a file could not be created" fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method visibility="public" name="compareTo" returncomment="Zero if the argument is equal to this abstract pathname, a
          value less than zero if this abstract pathname is
          lexicographically less than the argument, or a value greater
          than zero if this abstract pathname is lexicographically
          greater than the argument" fulltype="int" type="int">
				<comment>
					<description>Compares two abstract pathnames lexicographically.  The ordering
 defined by this method depends upon the underlying system.  On UNIX
 systems, alphabetic case is significant in comparing pathnames; on Microsoft Windows
 systems it is not.</description>
					<attribute name="@param">
						<description>pathname  The abstract pathname to be compared to this abstract
                    pathname</description>
					</attribute>
					<attribute name="@return">
						<description>Zero if the argument is equal to this abstract pathname, a
          value less than zero if this abstract pathname is
          lexicographically less than the argument, or a value greater
          than zero if this abstract pathname is lexicographically
          greater than the argument</description>
					</attribute>
					<attribute name="@since">
						<description>1.2</description>
					</attribute>
				</comment>
				<params>
					<param name="pathname" comment="The abstract pathname to be compared to this abstract
                    pathname" fulltype="java.io.File" type="File" />
				</params>
			</method>
			<method visibility="public" name="equals" returncomment="&lt;code&gt;true&lt;/code&gt; if and only if the objects are the same;
          &lt;code&gt;false&lt;/code&gt; otherwise" fulltype="boolean" type="boolean">
				<comment>
					<description>Tests this abstract pathname for equality with the given object.
 Returns &lt;code&gt;true&lt;/code&gt; if and only if the argument is not
 &lt;code&gt;null&lt;/code&gt; and is an abstract pathname that denotes the same file
 or directory as this abstract pathname.  Whether or not two abstract
 pathnames are equal depends upon the underlying system.  On UNIX
 systems, alphabetic case is significant in comparing pathnames; on Microsoft Windows
 systems it is not.</description>
					<attribute name="@param">
						<description>obj   The object to be compared with this abstract pathname</description>
					</attribute>
					<attribute name="@return">
						<description>&lt;code&gt;true&lt;/code&gt; if and only if the objects are the same;
          &lt;code&gt;false&lt;/code&gt; otherwise</description>
					</attribute>
				</comment>
				<params>
					<param name="obj" comment="The object to be compared with this abstract pathname" fulltype="java.lang.Object" type="Object" />
				</params>
			</method>
			<method visibility="public" name="hashCode" returncomment="A hash code for this abstract pathname" fulltype="int" type="int">
				<comment>
					<description>Computes a hash code for this abstract pathname.  Because equality of
 abstract pathnames is inherently system-dependent, so is the computation
 of their hash codes.  On UNIX systems, the hash code of an abstract
 pathname is equal to the exclusive &lt;em&gt;or&lt;/em&gt; of the hash code
 of its pathname string and the decimal value
 &lt;code&gt;1234321&lt;/code&gt;.  On Microsoft Windows systems, the hash
 code is equal to the exclusive &lt;em&gt;or&lt;/em&gt; of the hash code of
 its pathname string converted to lower case and the decimal
 value &lt;code&gt;1234321&lt;/code&gt;.  Locale is not taken into account on
 lowercasing the pathname string.</description>
					<attribute name="@return">
						<description>A hash code for this abstract pathname</description>
					</attribute>
				</comment>
			</method>
			<method visibility="public" name="toString" returncomment="The string form of this abstract pathname" fulltype="java.lang.String" type="String">
				<comment>
					<description>Returns the pathname string of this abstract pathname.  This is just the
 string returned by the &lt;code&gt;{@link #getPath}&lt;/code&gt; method.</description>
					<attribute name="@return">
						<description>The string form of this abstract pathname</description>
					</attribute>
				</comment>
			</method>
			<method synchronized="true" visibility="private" name="writeObject" fulltype="void" type="void">
				<comment>
					<description>WriteObject is called to save this filename.
 The separator character is saved also so it can be replaced
 in case the path is reconstituted on a different host type.
 &lt;p&gt;</description>
					<attribute name="@serialData">
						<description>Default fields followed by separator character.</description>
					</attribute>
				</comment>
				<params>
					<param name="s" fulltype="java.io.ObjectOutputStream" type="ObjectOutputStream" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
				</exceptions>
			</method>
			<method synchronized="true" visibility="private" name="readObject" fulltype="void" type="void">
				<comment>
					<description>readObject is called to restore this filename.
 The original separator character is read.  If it is different
 than the separator character on this system, then the old separator
 is replaced by the local separator.</description>
				</comment>
				<params>
					<param name="s" fulltype="java.io.ObjectInputStream" type="ObjectInputStream" />
				</params>
				<exceptions>
					<exception fulltype="java.io.IOException" type="IOException" />
					<exception fulltype="java.lang.ClassNotFoundException" type="ClassNotFoundException" />
				</exceptions>
			</method>
		</methods>
		<jelclass superclass="Object" visibility="private" package="java.io" superclassfulltype="java.lang.Object" fulltype="java.io.File.LazyInitialization" type="File.LazyInitialization">
			<fields>
				<field final="true" static="true" visibility="package-private" name="random" fulltype="java.security.SecureRandom" type="SecureRandom" />
				<field final="true" static="true" visibility="package-private" name="temporaryDirectory" fulltype="java.lang.String" type="String" />
			</fields>
			<methods>
				<constructor visibility="private" name="File.LazyInitialization" />
				<method static="true" visibility="package-private" name="temporaryDirectory" fulltype="java.lang.String" type="String" />
			</methods>
		</jelclass>
	</jelclass>
	<jelclass superclass="Object" visibility="private" package="java.io" superclassfulltype="java.lang.Object" fulltype="java.io.File.LazyInitialization" type="File.LazyInitialization">
		<fields>
			<field final="true" static="true" visibility="package-private" name="random" fulltype="java.security.SecureRandom" type="SecureRandom" />
			<field final="true" static="true" visibility="package-private" name="temporaryDirectory" fulltype="java.lang.String" type="String" />
		</fields>
		<methods>
			<constructor visibility="private" name="File.LazyInitialization" />
			<method static="true" visibility="package-private" name="temporaryDirectory" fulltype="java.lang.String" type="String" />
		</methods>
	</jelclass>
	<jelclass abstract="true" visibility="public" package="java.io" interface="true" fulltype="java.io.FileFilter" type="FileFilter">
		<comment>
			<description>A filter for abstract pathnames.

 &lt;p&gt; Instances of this interface may be passed to the &lt;code&gt;{@link
 File#listFiles(java.io.FileFilter) listFiles(FileFilter)}&lt;/code&gt; method
 of the &lt;code&gt;{@link java.io.File}&lt;/code&gt; class.</description>
			<attribute name="@since">
				<description>1.2</description>
			</attribute>
		</comment>
		<methods>
			<method visibility="public" name="accept" returncomment="&lt;code&gt;true&lt;/code&gt; if and only if &lt;code&gt;pathname&lt;/code&gt;
          should be included" fulltype="boolean" type="boolean">
				<comment>
					<description>Tests whether or not the specified abstract pathname should be
 included in a pathname list.</description>
					<attribute name="@param">
						<description>pathname  The abstract pathname to be tested</description>
					</attribute>
					<attribute name="@return">
						<description>&lt;code&gt;true&lt;/code&gt; if and only if &lt;code&gt;pathname&lt;/code&gt;
          should be included</description>
					</attribute>
				</comment>
				<params>
					<param name="pathname" comment="The abstract pathname to be tested" fulltype="java.io.File" type="File" />
				</params>
			</method>
		</methods>
	</jelclass>
</jel>
