<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>*</a> x y &amp; more )</tt>	returns the product of nums
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>*'</a> x y &amp; more )</tt>	returns the product of nums
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>+</a> x y &amp; more )</tt>	returns the sum of nums
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>+'</a> x y &amp; more )</tt>	returns the sum of nums
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>-</a> x y &amp; more )</tt>	if no ys are supplied returns the negation of x else subtracts the ys from x and returns the result
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>-'</a> x y &amp; more )</tt>	if no ys are supplied returns the negation of x else subtracts the ys from x and returns the result
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>-&gt;</a> x &amp; forms )</tt>	threads the expr through the forms
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>-&gt;&gt;</a> x &amp; forms )</tt>	threads the expr through the forms
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>-&gt;ArrayChunk</a> am arr off end )</tt>	positional factory function for class clojure core arraychunk
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>-&gt;Eduction</a> xform coll )</tt>	positional factory function for class clojure core eduction
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>-&gt;Vec</a> am cnt shift root tail _meta )</tt>	positional factory function for class clojure core vec
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>-&gt;VecNode</a> edit arr )</tt>	positional factory function for class clojure core vecnode
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>-&gt;VecSeq</a> am vec anode i offset )</tt>	positional factory function for class clojure core vecseq
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>..</a> x form &amp; more )</tt>	form = > fieldname-symbol orinstancemethodname-symbol args*) expands into a member access
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>/</a> x y &amp; more )</tt>	if no denominators are supplied returns 1 / numerator else returns numerator divided by all of the denominators
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>&lt;</a> x y &amp; more )</tt>	returns non-nil if nums are in monotonically increasing order otherwise false
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>&lt;=</a> x y &amp; more )</tt>	returns non-nil if nums are in monotonically non-decreasing order otherwise false
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>==</a> x y &amp; more )</tt>	returns non-nil if nums all have the equivalent value type-independent otherwise false
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>&gt;</a> x y &amp; more )</tt>	returns non-nil if nums are in monotonically decreasing order otherwise false
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>&gt;=</a> x y &amp; more )</tt>	returns non-nil if nums are in monotonically non-increasing order otherwise false
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>Throwable-&gt;map</a> o )</tt>	constructs a data representation for a throwable
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>accessor</a> s key )</tt>	returns a fn that given an instance of a structmap with the basis returns the value at the key
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>aclone</a> array )</tt>	returns a clone of the java array
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>add-classpath</a> url )</tt>	adds the url string or url object to the classpath per urlclassloader addurl
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>add-watch</a> reference key fn )</tt>	adds a watch function to an agent / atom / var / ref reference
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>agent</a> state &amp; options )</tt>	creates and returns an agent with an initial value of state and zero or more options in any order : :meta metadata-map :validator validate-fn :error-handler handler-fn :error-mode mode-keyword if metadata-map is supplied it will become the metadata on the agent
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>agent-error</a> a )</tt>	returns the exception thrown during an asynchronous action of the agent if the agent is failed
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>aget</a> array idx &amp; idxs )</tt>	returns the value at the index / indices
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>alength</a> array )</tt>	returns the length of the java array
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>alias</a> alias namespace-sym )</tt>	add an alias in the current namespace to another namespace
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>all-ns</a>  )</tt>	returns a sequence of all namespaces
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>alter</a> ref fun &amp; args )</tt>	must be called in a transaction
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>alter-meta!</a> iref f &amp; args )</tt>	atomically sets the metadata for a namespace / var / ref / agent / atom to be: apply f its-current-meta args f must be free of side-effects
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>alter-var-root</a> v f &amp; args )</tt>	atomically alters the root binding of var v by applying f to its current value plus any args
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>amap</a> a idx ret expr )</tt>	maps an expression across an array a using an index named idx and return value named ret initialized to a clone of a then setting each element of ret to the evaluation of expr returning the new array ret
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>ancestors</a> h tag )</tt>	returns the immediate and indirect parents of tag either via a java type inheritance relationship or a relationship established via derive
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>and</a> x &amp; next )</tt>	evaluates exprs one at a time from left to right
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>apply</a> f a b c d &amp; args )</tt>	applies fn f to the argument list formed by prepending intervening arguments to args
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>areduce</a> a idx ret init expr )</tt>	reduces an expression across an array a using an index named idx and return value named ret initialized to init setting ret to the evaluation of expr at each step returning ret
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>array-map</a> &amp; keyvals )</tt>	constructs an array-map
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>as-&gt;</a> expr name &amp; forms )</tt>	binds name to expr evaluates the first form in the lexical context of that binding then binds name to that result repeating for each successive form returning the result of the last form
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>aset</a> array idx idx2 &amp; idxv )</tt>	sets the value at the index / indices
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>aset-boolean</a> array idx idx2 &amp; idxv )</tt>	sets the value at the index / indices
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>aset-byte</a> array idx idx2 &amp; idxv )</tt>	sets the value at the index / indices
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>aset-char</a> array idx idx2 &amp; idxv )</tt>	sets the value at the index / indices
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>aset-double</a> array idx idx2 &amp; idxv )</tt>	sets the value at the index / indices
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>aset-float</a> array idx idx2 &amp; idxv )</tt>	sets the value at the index / indices
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>aset-int</a> array idx idx2 &amp; idxv )</tt>	sets the value at the index / indices
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>aset-long</a> array idx idx2 &amp; idxv )</tt>	sets the value at the index / indices
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>aset-short</a> array idx idx2 &amp; idxv )</tt>	sets the value at the index / indices
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>assert</a> x message )</tt>	evaluates expr and throws an exception if it does not evaluate to logical true
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>assoc!</a> coll key val &amp; kvs )</tt>	when applied to a transient map adds mapping of key s to val s
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>assoc-in</a> m [k &amp; ks] v )</tt>	associates a value in a nested associative structure where ks is a sequence of keys and v is the new value and returns a new nested structure
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>associative?</a> coll )</tt>	returns true if coll implements associative
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>atom</a> x &amp; options )</tt>	creates and returns an atom with an initial value of x and zero or more options in any order : :meta metadata-map :validator validate-fn if metadata-map is supplied it will become the metadata on the atom
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>await</a> &amp; agents )</tt>	blocks the current threadindefinitely!) until all actions dispatched thus far from this thread or agent to the agent s have occurred
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>await-for</a> timeout-ms &amp; agents )</tt>	blocks the current thread until all actions dispatched thus far from this thread or agent to the agents have occurred or the timeout in milliseconds has elapsed
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>bases</a> c )</tt>	returns the immediate superclass and direct interfaces of c if any
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>bean</a> x )</tt>	takes a java object and returns a read-only implementation of the map abstraction based upon its javabean properties
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>bigdec</a> x )</tt>	coerce to bigdecimal
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>bigint</a> x )</tt>	coerce to bigint
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>biginteger</a> x )</tt>	coerce to biginteger
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>binding</a> bindings &amp; body )</tt>	binding = > var-symbol init-expr creates new bindings for the already-existing vars with the supplied initial values executes the exprs in an implicit do then re-establishes the bindings that existed before
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>bit-and</a> x y &amp; more )</tt>	bitwise and
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>bit-and-not</a> x y &amp; more )</tt>	bitwise and with complement
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>bit-clear</a> x n )</tt>	clear bit at index n
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>bit-flip</a> x n )</tt>	flip bit at index n
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>bit-not</a> x )</tt>	bitwise complement
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>bit-or</a> x y &amp; more )</tt>	bitwise or
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>bit-set</a> x n )</tt>	set bit at index n
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>bit-shift-left</a> x n )</tt>	bitwise shift left
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>bit-shift-right</a> x n )</tt>	bitwise shift right
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>bit-test</a> x n )</tt>	test bit at index n
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>bit-xor</a> x y &amp; more )</tt>	bitwise exclusive or
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>boolean</a> x )</tt>	coerce to boolean
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>boolean-array</a> size init-val-or-seq )</tt>	creates an array of booleans
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>booleans</a> xs )</tt>	casts to boolean[]
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>bound-fn</a> &amp; fntail )</tt>	returns a function defined by the given fntail which will install the same bindings in effect as in the thread at the time bound-fn was called
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>bound-fn*</a> f )</tt>	returns a function which will install the same bindings in effect as in the thread at the time bound-fn* was called and then call f with any given arguments
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>bound?</a> &amp; vars )</tt>	returns true if all of the vars provided as arguments have any bound value root or thread-local
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>butlast</a> coll )</tt>	return a seq of all but the last item in coll in linear time
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>byte</a> x )</tt>	coerce to byte
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>byte-array</a> size init-val-or-seq )</tt>	creates an array of bytes
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>bytes</a> xs )</tt>	casts to bytes[]
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>case</a> e &amp; clauses )</tt>	takes an expression and a set of clauses
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>cast</a> c x )</tt>	throws a classcastexception if x is not a c else returns x
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>cat</a> rf )</tt>	a transducer which concatenates the contents of each input which must be a collection into the reduction
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>char</a> x )</tt>	coerce to char
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>char-array</a> size init-val-or-seq )</tt>	creates an array of chars
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>char?</a> x )</tt>	return true if x is a character
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>chars</a> xs )</tt>	casts to chars[]
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>class</a> x )</tt>	returns the class of x
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>class?</a> x )</tt>	returns true if x is an instance of class
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>clojure-version</a>  )</tt>	returns clojure version as a printable string
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>coll?</a> x )</tt>	returns true if x implements ipersistentcollection
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>comment</a> &amp; body )</tt>	ignores body yields nil
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>commute</a> ref fun &amp; args )</tt>	must be called in a transaction
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>comp</a> f g &amp; fs )</tt>	takes a set of functions and returns a fn that is the composition of those fns
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>comparator</a> pred )</tt>	returns an implementation of java util comparator based upon pred
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>compare-and-set!</a> atom oldval newval )</tt>	atomically sets the value of atom to newval if and only if the current value of the atom is identical to oldval
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>compile</a> lib )</tt>	compiles the namespace named by the symbol lib into a set of classfiles
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>complement</a> f )</tt>	takes a fn f and returns a fn that takes the same arguments as f has the same effects if any and returns the opposite truth value
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>completing</a> f cf )</tt>	takes a reducing function f of 2 args and returns a fn suitable for transduce by adding an arity-1 signature that calls cf default - identity on the result argument
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>concat</a> x y &amp; zs )</tt>	returns a lazy seq representing the concatenation of the elements in the supplied colls
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>cond</a> &amp; clauses )</tt>	takes a set of test / expr pairs
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>cond-&gt;</a> expr &amp; clauses )</tt>	takes an expression and a set of test / form pairs
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>cond-&gt;&gt;</a> expr &amp; clauses )</tt>	takes an expression and a set of test / form pairs
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>condp</a> pred expr &amp; clauses )</tt>	takes a binary predicate an expression and a set of clauses
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>conj!</a> coll x )</tt>	adds x to the transient collection and return coll
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>cons</a> x seq )</tt>	returns a new seq where x is the first element and seq is the rest
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>constantly</a> x )</tt>	returns a function that takes any number of arguments and returns x
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>construct-proxy</a> c &amp; ctor-args )</tt>	takes a proxy class and any arguments for its superclass ctor and creates and returns an instance of the proxy
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>contains?</a> coll key )</tt>	returns true if key is present in the given collection otherwise returns false
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>count</a> coll )</tt>	returns the number of items in the collection
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>counted?</a> coll )</tt>	returns true if coll implements count in constant time
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>create-ns</a> sym )</tt>	create a new namespace named by the symbol if one doesn't already exist returns it or the already-existing namespace of the same name
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>create-struct</a> &amp; keys )</tt>	returns a structure basis object
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>cycle</a> coll )</tt>	returns a lazyinfinite!) sequence of repetitions of the items in coll
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>dec</a> x )</tt>	returns a number one less than num
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>dec'</a> x )</tt>	returns a number one less than num
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>decimal?</a> n )</tt>	returns true if n is a bigdecimal
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>declare</a> &amp; names )</tt>	defs the supplied var names with no bindings useful for making forward declarations
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>dedupe</a> coll )</tt>	returns a lazy sequence removing consecutive duplicates in coll
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>def</a> symbol doc-string? init? )</tt>	creates and interns a global var with the name of symbol in the current namespace *ns*) or locates such a var if it already exists
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>definterface</a> name &amp; sigs )</tt>	creates a new java interface with the given name and method sigs
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>defmacro</a> name doc-string? attr-map? [params*] body + attr-map? )</tt>	like defn but the resulting function name is declared as a macro and will be used as a macro by the compiler when it is called
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>defmethod</a> multifn dispatch-val &amp; fn-tail )</tt>	creates and installs a new method of multimethod associated with dispatch-value
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>defmulti</a> name docstring? attr-map? dispatch-fn &amp; options )</tt>	creates a new multimethod with the associated dispatch function
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>defn-</a> name &amp; decls )</tt>	same as defn yielding non-public def
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>defonce</a> name expr )</tt>	defs name to have the root value of the expr iff the named var has no root value else expr is unevaluated
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>defprotocol</a> name &amp; opts+sigs )</tt>	a protocol is a named set of named methods and their signatures:defprotocol aprotocolname ;optional doc string "a doc string for aprotocol abstraction" ;method signatures bar this a b "bar docs") baz this a this a b this a b c "baz docs")) no implementations are provided
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>delay</a> &amp; body )</tt>	takes a body of expressions and yields a delay object that will invoke the body only the first time it is forced with force or deref / @) and will cache the result and return it on all subsequent force calls
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>delay?</a> x )</tt>	returns true if x is a delay created with delay
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>deliver</a> promise val )</tt>	delivers the supplied value to the promise releasing any pending derefs
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>denominator</a> r )</tt>	returns the denominator part of a ratio
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>deref</a> ref timeout-ms timeout-val )</tt>	also reader macro: @ref / @agent / @var / @atom / @delay / @future / @promise
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>derive</a> h tag parent )</tt>	establishes a parent / child relationship between parent and tag
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>descendants</a> h tag )</tt>	returns the immediate and indirect children of tag through a relationship established via derive
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>dissoc!</a> map key &amp; ks )</tt>	returns a transient map that doesn't contain a mapping for key s
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>distinct</a> coll )</tt>	returns a lazy sequence of the elements of coll with duplicates removed
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>distinct?</a> x y &amp; more )</tt>	returns true if no two of the arguments are =
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>do</a> exprs* )</tt>	evaluates the expressions in order and returns the value of the last
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>doall</a> n coll )</tt>	when lazy sequences are produced via functions that have side effects any effects other than those needed to produce the first element in the seq do not occur until the seq is consumed
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>dorun</a> n coll )</tt>	when lazy sequences are produced via functions that have side effects any effects other than those needed to produce the first element in the seq do not occur until the seq is consumed
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>doseq</a> seq-exprs &amp; body )</tt>	repeatedly executes body presumably for side-effects with bindings and filtering as provided by "for"
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>dosync</a> &amp; exprs )</tt>	runs the exprs in an implicit do in a transaction that encompasses exprs and any nested calls
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>dotimes</a> bindings &amp; body )</tt>	repeatedly executes body presumably for side-effects with name bound to integers from 0 through n-1
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>doto</a> x &amp; forms )</tt>	evaluates x then calls all of the methods and functions with the value of x supplied at the front of the given arguments
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>double</a> x )</tt>	coerce to double
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>double-array</a> size init-val-or-seq )</tt>	creates an array of doubles
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>doubles</a> xs )</tt>	casts to double[]
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>drop</a> n coll )</tt>	returns a lazy sequence of all but the first n items in coll
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>drop-last</a> n s )</tt>	return a lazy sequence of all but the last n default 1 items in coll
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>drop-while</a> pred coll )</tt>	returns a lazy sequence of the items in coll starting from the first item for which pred item returns logical false
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>eduction</a> xform* coll )</tt>	returns a reducible / iterable application of the transducers to the items in coll
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>empty</a> coll )</tt>	returns an empty collection of the same category as coll or nil
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>empty?</a> coll )</tt>	returns true if coll has no items - same asnot seq coll
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>ensure</a> ref )</tt>	must be called in a transaction
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>ensure-reduced</a> x )</tt>	if x is already reduced? returns it else returns reduced x
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>enumeration-seq</a> e )</tt>	returns a seq on a java util enumeration
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>error-handler</a> a )</tt>	returns the error-handler of agent a or nil if there is none
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>error-mode</a> a )</tt>	returns the error-mode of agent a
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>eval</a> form )</tt>	evaluates the form data structurenot text!) and returns the result
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>even?</a> n )</tt>	returns true if n is even throws an exception if n is not an integer
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>every-pred</a> p1 p2 p3 &amp; ps )</tt>	takes a set of predicates and returns a function f that returns true if all of its composing predicates return a logical true value against all of its arguments else it returns false
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>every?</a> pred coll )</tt>	returns true if pred x is logical true for every x in coll else false
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>ex-data</a> ex )</tt>	returns exception data a map if ex is an iexceptioninfo
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>ex-info</a> msg map cause )</tt>	create an instance of exceptioninfo a runtimeexception subclass that carries a map of additional data
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>extend</a> atype &amp; proto+mmaps )</tt>	implementations of protocol methods can be provided using the extend construct
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>extend-protocol</a> p &amp; specs )</tt>	useful when you want to provide several implementations of the same protocol all at once
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>extend-type</a> t &amp; specs )</tt>	a macro that expands into an extend call
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>extenders</a> protocol )</tt>	returns a collection of the types explicitly extending protocol
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>extends?</a> protocol atype )</tt>	returns true if atype extends protocol
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>false?</a> x )</tt>	returns true if x is the value false false otherwise
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>file-seq</a> dir )</tt>	a tree seq on java io files
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>filter</a> pred coll )</tt>	returns a lazy sequence of the items in coll for which pred item returns true
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>filterv</a> pred coll )</tt>	returns a vector of the items in coll for which pred item returns true
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>find</a> map key )</tt>	returns the map entry for key or nil if key not present
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>find-keyword</a> ns name )</tt>	returns a keyword with the given namespace and name if one already exists
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>find-ns</a> sym )</tt>	returns the namespace named by the symbol or nil if it doesn't exist
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>find-var</a> sym )</tt>	returns the global var named by the namespace-qualified symbol or nil if no var with that name
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>first</a> coll )</tt>	returns the first item in the collection
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>flatten</a> x )</tt>	takes any nested combination of sequential thingslists vectors etc
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>float</a> x )</tt>	coerce to float
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>float-array</a> size init-val-or-seq )</tt>	creates an array of floats
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>float?</a> n )</tt>	returns true if n is a floating point number
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>floats</a> xs )</tt>	casts to float[]
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>flush</a>  )</tt>	flushes the output stream that is the current value of *out*
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>fn</a> name? [params*] exprs* + )</tt>	params = > positional-params* or positional-params* & next-param positional-param = > binding-form next-param = > binding-form name = > symbol defines a function
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>fn?</a> x )</tt>	returns true if x implements fn i e
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>fnil</a> f x y z )</tt>	takes a function f and returns a function that calls f replacing a nil first argument to f with the supplied value x
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>for</a> seq-exprs body-expr )</tt>	list comprehension
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>force</a> x )</tt>	if x is a delay returns the possibly cached value of its expression else returns x
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>format</a> fmt &amp; args )</tt>	formats a string using java lang string format see java util formatter for format string syntax
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>frequencies</a> coll )</tt>	returns a map from distinct items in coll to the number of times they appear
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>future</a> &amp; body )</tt>	takes a body of expressions and yields a future object that will invoke the body in another thread and will cache the result and return it on all subsequent calls to deref / @
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>future-call</a> f )</tt>	takes a function of no args and yields a future object that will invoke the function in another thread and will cache the result and return it on all subsequent calls to deref / @
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>future-cancel</a> f )</tt>	cancels the future if possible
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>future-cancelled?</a> f )</tt>	returns true if future f is cancelled
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>future-done?</a> f )</tt>	returns true if future f is done
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>future?</a> x )</tt>	returns true if x is a future
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>gen-class</a> &amp; options )</tt>	when compiling generates compiled bytecode for a class with the given package-qualified :name which as all names in these parameters can be a string or symbol) and writes the class file to the *compile-path* directory
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>gen-interface</a> &amp; options )</tt>	when compiling generates compiled bytecode for an interface with the given package-qualified :name which as all names in these parameters can be a string or symbol) and writes the class file to the *compile-path* directory
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>gensym</a> prefix-string )</tt>	returns a new symbol with a unique name
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>get</a> map key not-found )</tt>	returns the value mapped to key not-found or nil if key not present
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>get-in</a> m ks not-found )</tt>	returns the value in a nested associative structure where ks is a sequence of keys
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>get-method</a> multifn dispatch-val )</tt>	given a multimethod and a dispatch value returns the dispatch fn that would apply to that value or nil if none apply and no default
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>get-proxy-class</a> &amp; bases )</tt>	takes an optional single class followed by zero or more interfaces
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>get-thread-bindings</a>  )</tt>	get a map with the var / value pairs which is currently in effect for the current thread
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>get-validator</a> iref )</tt>	gets the validator-fn for a var / ref / agent / atom
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>group-by</a> f coll )</tt>	returns a map of the elements of coll keyed by the result of f on each element
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>hash</a> x )</tt>	returns the hash code of its argument
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>hash-map</a> &amp; keyvals )</tt>	keyval = > key val returns a new hash map with supplied mappings
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>hash-ordered-coll</a> coll )</tt>	returns the hash code consistent with = for an external ordered collection implementing iterable
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>hash-set</a> &amp; keys )</tt>	returns a new hash set with supplied keys
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>hash-unordered-coll</a> coll )</tt>	returns the hash code consistent with = for an external unordered collection implementing iterable
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>identical?</a> x y )</tt>	tests if 2 arguments are the same object
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>identity</a> x )</tt>	returns its argument
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>if</a> test then else? )</tt>	evaluates test
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>if-let</a> bindings then else &amp; oldform )</tt>	if test is true evaluates then with binding-form bound to the value of test if not yields else
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>if-not</a> test then else )</tt>	evaluates test
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>if-some</a> bindings then else &amp; oldform )</tt>	if test is not nil evaluates then with binding-form bound to the value of test if not yields else
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>ifn?</a> x )</tt>	returns true if x implements ifn
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>import</a> &amp; import-symbols-or-lists )</tt>	import-list = > package-symbol class-name-symbols*) for each name in class-name-symbols adds a mapping from name to the class named by package name to the current namespace
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>in-ns</a> name )</tt>	sets *ns* to the namespace named by the symbol creating it if needed
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>inc</a> x )</tt>	returns a number one greater than num
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>inc'</a> x )</tt>	returns a number one greater than num
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>init-proxy</a> proxy mappings )</tt>	takes a proxy instance and a map of strings which must correspond to methods of the proxy superclass / superinterfaces) to fns which must take arguments matching the corresponding method plus an additional explicit first arg corresponding to this and sets the proxy's fn map
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>instance?</a> c x )</tt>	evaluates x and tests if it is an instance of the class c
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>int</a> x )</tt>	coerce to int
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>int-array</a> size init-val-or-seq )</tt>	creates an array of ints
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>integer?</a> n )</tt>	returns true if n is an integer
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>interleave</a> c1 c2 &amp; colls )</tt>	returns a lazy seq of the first item in each coll then the second etc
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>intern</a> ns name val )</tt>	finds or creates a var named by the symbol name in the namespace ns which can be a symbol or a namespace setting its root binding to val if supplied
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>interpose</a> sep coll )</tt>	returns a lazy seq of the elements of coll separated by sep
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>into</a> to xform from )</tt>	returns a new coll consisting of to-coll with all of the items of from-coll conjoined
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>into-array</a> type aseq )</tt>	returns an array with components set to the values in aseq
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>ints</a> xs )</tt>	casts to int[]
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>io!</a> &amp; body )</tt>	if an io! block occurs in a transaction throws an illegalstateexception else runs body in an implicit do
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>isa?</a> h child parent )</tt>	returns true if= child parent) or child is directly or indirectly derived from parent either via a java type inheritance relationship or a relationship established via derive
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>iterate</a> f x )</tt>	returns a lazy sequence of x f x f f x etc
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>iterator-seq</a> iter )</tt>	returns a seq on a java util iterator
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>juxt</a> f g h &amp; fs )</tt>	takes a set of functions and returns a fn that is the juxtaposition of those fns
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>keep</a> f coll )</tt>	returns a lazy sequence of the non-nil results of f item
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>keep-indexed</a> f coll )</tt>	returns a lazy sequence of the non-nil results of f index item
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>key</a> e )</tt>	returns the key of the map entry
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>keys</a> map )</tt>	returns a sequence of the map's keys in the same order as seq map
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>keyword</a> ns name )</tt>	returns a keyword with the given namespace and name
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>keyword?</a> x )</tt>	return true if x is a keyword
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>last</a> coll )</tt>	return the last item in coll in linear time
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>lazy-cat</a> &amp; colls )</tt>	expands to code which yields a lazy sequence of the concatenation of the supplied colls
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>lazy-seq</a> &amp; body )</tt>	takes a body of expressions that returns an iseq or nil and yields a seqable object that will invoke the body only the first time seq is called and will cache the result and return it on all subsequent seq calls
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>let</a> [bindings*] exprs* )</tt>	binding = > binding-form init-expr evaluates the exprs in a lexical context in which the symbols in the binding-forms are bound to their respective init-exprs or parts therein
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>letfn</a> [fnspecs*] exprs* )</tt>	fnspec == > fname [params*] exprs) orfname[params*] exprs)+) takes a vector of function specs and a body and generates a set of bindings of functions to their names
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>line-seq</a> rdr )</tt>	returns the lines of text from rdr as a lazy sequence of strings
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>list</a> &amp; items )</tt>	creates a new list containing the items
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>list*</a> a b c d &amp; more )</tt>	creates a new seq containing the items prepended to the rest the last of which will be treated as a sequence
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>list?</a> x )</tt>	returns true if x implements ipersistentlist
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>load</a> &amp; paths )</tt>	loads clojure code from resources in classpath
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>load-file</a> name )</tt>	sequentially read and evaluate the set of forms contained in the file
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>load-reader</a> rdr )</tt>	sequentially read and evaluate the set of forms contained in the stream / file
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>load-string</a> s )</tt>	sequentially read and evaluate the set of forms contained in the string
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>loaded-libs</a>  )</tt>	returns a sorted set of symbols naming the currently loaded libs
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>locking</a> x &amp; body )</tt>	executes exprs in an implicit do while holding the monitor of x
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>long</a> x )</tt>	coerce to long
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>long-array</a> size init-val-or-seq )</tt>	creates an array of longs
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>longs</a> xs )</tt>	casts to long[]
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>loop</a> [bindings*] exprs* )</tt>	evaluates the exprs in a lexical context in which the symbols in the binding-forms are bound to their respective init-exprs or parts therein
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>macroexpand</a> form )</tt>	repeatedly calls macroexpand-1 on form until it no longer represents a macro form then returns it
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>macroexpand-1</a> form )</tt>	if form represents a macro form returns its expansion else returns form
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>make-array</a> type dim &amp; more-dims )</tt>	creates and returns an array of instances of the specified class of the specified dimension s
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>make-hierarchy</a>  )</tt>	creates a hierarchy object for use with derive isa? etc
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>map</a> f c1 c2 c3 &amp; colls )</tt>	returns a lazy sequence consisting of the result of applying f to the set of first items of each coll followed by applying f to the set of second items in each coll until any one of the colls is exhausted
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>map-entry?</a> x )</tt>	return true if x is a map entry
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>map-indexed</a> f coll )</tt>	returns a lazy sequence consisting of the result of applying f to 0 and the first item of coll followed by applying f to 1 and the second item in coll etc until coll is exhausted
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>map?</a> x )</tt>	return true if x implements ipersistentmap
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>mapcat</a> f &amp; colls )</tt>	returns the result of applying concat to the result of applying map to f and colls
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>mapv</a> f c1 c2 c3 &amp; colls )</tt>	returns a vector consisting of the result of applying f to the set of first items of each coll followed by applying f to the set of second items in each coll until any one of the colls is exhausted
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>max</a> x y &amp; more )</tt>	returns the greatest of the nums
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>max-key</a> k x y &amp; more )</tt>	returns the x for which k x a number is greatest
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>memfn</a> name &amp; args )</tt>	expands into code that creates a fn that expects to be passed an object and any args and calls the named instance method on the object passing the args
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>memoize</a> f )</tt>	returns a memoized version of a referentially transparent function
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>merge</a> &amp; maps )</tt>	returns a map that consists of the rest of the maps conj-ed onto the first
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>merge-with</a> f &amp; maps )</tt>	returns a map that consists of the rest of the maps conj-ed onto the first
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>meta</a> obj )</tt>	returns the metadata of obj returns nil if there is no metadata
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>methods</a> multifn )</tt>	given a multimethod returns a map of dispatch values - > dispatch fns
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>min</a> x y &amp; more )</tt>	returns the least of the nums
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>min-key</a> k x y &amp; more )</tt>	returns the x for which k x a number is least
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>mix-collection-hash</a> hash-basis count )</tt>	mix final collection hash for ordered or unordered collections
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>mod</a> num div )</tt>	modulus of num and div
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>monitor-enter</a> x )</tt>	synchronization primitive that should be avoided in user code
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>monitor-exit</a> x )</tt>	synchronization primitive that should be avoided in user code
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>name</a> x )</tt>	returns the name string of a string symbol or keyword
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>namespace</a> x )</tt>	returns the namespace string of a symbol or keyword or nil if not present
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>namespace-munge</a> ns )</tt>	convert a clojure namespace name to a legal java package name
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>neg?</a> x )</tt>	returns true if num is less than zero else false
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>new</a> Classname args* )</tt>	the args if any are evaluated from left to right and passed to the constructor of the class named by classname
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>newline</a>  )</tt>	writes a platform-specific newline to *out*
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>next</a> coll )</tt>	returns a seq of the items after the first
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>nil?</a> x )</tt>	returns true if x is nil false otherwise
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>not</a> x )</tt>	returns true if x is logical false false otherwise
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>not-any?</a> pred coll )</tt>	returns false if pred x is logical true for any x in coll else true
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>not-empty</a> coll )</tt>	if coll is empty returns nil else coll
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>not-every?</a> pred coll )</tt>	returns false if pred x is logical true for every x in coll else true
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>ns</a> name docstring? attr-map? references* )</tt>	sets *ns* to the namespace named by name unevaluated creating it if needed
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>ns-aliases</a> ns )</tt>	returns a map of the aliases for the namespace
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>ns-imports</a> ns )</tt>	returns a map of the import mappings for the namespace
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>ns-interns</a> ns )</tt>	returns a map of the intern mappings for the namespace
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>ns-map</a> ns )</tt>	returns a map of all the mappings for the namespace
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>ns-name</a> ns )</tt>	returns the name of the namespace a symbol
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>ns-publics</a> ns )</tt>	returns a map of the public intern mappings for the namespace
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>ns-refers</a> ns )</tt>	returns a map of the refer mappings for the namespace
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>ns-resolve</a> ns env sym )</tt>	returns the var or class to which a symbol will be resolved in the namespace unless found in the environment else nil
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>ns-unalias</a> ns sym )</tt>	removes the alias for the symbol from the namespace
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>ns-unmap</a> ns sym )</tt>	removes the mappings for the symbol from the namespace
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>nth</a> coll index not-found )</tt>	returns the value at the index
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>nthnext</a> coll n )</tt>	returns the nth next of coll seq coll when n is 0
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>nthrest</a> coll n )</tt>	returns the nth rest of coll coll when n is 0
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>num</a> x )</tt>	coerce to number
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>number?</a> x )</tt>	returns true if x is a number
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>numerator</a> r )</tt>	returns the numerator part of a ratio
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>object-array</a> size-or-seq )</tt>	creates an array of objects
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>odd?</a> n )</tt>	returns true if n is odd throws an exception if n is not an integer
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>or</a> x &amp; next )</tt>	evaluates exprs one at a time from left to right
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>parents</a> h tag )</tt>	returns the immediate parents of tag either via a java type inheritance relationship or a relationship established via derive
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>partial</a> f arg1 arg2 arg3 &amp; more )</tt>	takes a function f and fewer than the normal arguments to f and returns a fn that takes a variable number of additional args
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>partition</a> n step pad coll )</tt>	returns a lazy sequence of lists of n items each at offsets step apart
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>partition-all</a> n step coll )</tt>	returns a lazy sequence of lists like partition but may include partitions with fewer than n items at the end
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>partition-by</a> f coll )</tt>	applies f to each value in coll splitting it each time f returns a new value
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>pcalls</a> &amp; fns )</tt>	executes the no-arg fns in parallel returning a lazy sequence of their values
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>peek</a> coll )</tt>	for a list or queue same as first for a vector same as but much more efficient than last
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>persistent!</a> coll )</tt>	returns a new persistent version of the transient collection in constant time
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>pmap</a> f coll &amp; colls )</tt>	like map except f is applied in parallel
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>pop</a> coll )</tt>	for a list or queue returns a new list / queue without the first item for a vector returns a new vector without the last item
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>pop!</a> coll )</tt>	removes the last item from a transient vector
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>pop-thread-bindings</a>  )</tt>	pop one set of bindings pushed with push-binding before
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>pos?</a> x )</tt>	returns true if num is greater than zero else false
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>pr</a> x &amp; more )</tt>	prints the object s to the output stream that is the current value of *out*
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>pr-str</a> &amp; xs )</tt>	pr to a string returning it
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>prefer-method</a> multifn dispatch-val-x dispatch-val-y )</tt>	causes the multimethod to prefer matches of dispatch-val-x over dispatch-val-y when there is a conflict
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>prefers</a> multifn )</tt>	given a multimethod returns a map of preferred value - > set of other values
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>print</a> &amp; more )</tt>	prints the object s to the output stream that is the current value of *out*
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>print-str</a> &amp; xs )</tt>	print to a string returning it
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>printf</a> fmt &amp; args )</tt>	prints formatted output as per format
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>println-str</a> &amp; xs )</tt>	println to a string returning it
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>prn-str</a> &amp; xs )</tt>	prn to a string returning it
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>promise</a>  )</tt>	returns a promise object that can be read with deref / @ and set once only with deliver
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>proxy</a> class-and-interfaces args &amp; fs )</tt>	class-and-interfaces - a vector of class names args - a possibly empty vector of arguments to the superclass constructor
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>proxy-mappings</a> proxy )</tt>	takes a proxy instance and returns the proxy's fn map
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>proxy-super</a> meth &amp; args )</tt>	use to call a superclass method in the body of a proxy method
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>push-thread-bindings</a> bindings )</tt>	warning: this is a low-level function
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>pvalues</a> &amp; exprs )</tt>	returns a lazy sequence of the values of the exprs which are evaluated in parallel
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>quot</a> num div )</tt>	quot ient of dividing numerator by denominator
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>quote</a> form )</tt>	yields the unevaluated form
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>rand</a> n )</tt>	returns a random floating point number between 0 inclusive and n default 1 exclusive
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>rand-int</a> n )</tt>	returns a random integer between 0 inclusive and n exclusive
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>rand-nth</a> coll )</tt>	return a random element of the sequential collection
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>random-sample</a> prob coll )</tt>	returns items from coll with random probability of prob 0 0 - 1 0
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>range</a> start end step )</tt>	returns a lazy seq of nums from start inclusive to end exclusive by step where start defaults to 0 step to 1 and end to infinity
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>ratio?</a> n )</tt>	returns true if n is a ratio
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>rational?</a> n )</tt>	returns true if n is a rational number
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>rationalize</a> num )</tt>	returns the rational value of num
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>re-find</a> re s )</tt>	returns the next regex match if any of string to pattern using java util regex matcher find
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>re-groups</a> m )</tt>	returns the groups from the most recent match / find
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>re-matcher</a> re s )</tt>	returns an instance of java util regex matcher for use e g
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>re-matches</a> re s )</tt>	returns the match if any of string to pattern using java util regex matcher matches
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>re-pattern</a> s )</tt>	returns an instance of java util regex pattern for use e g
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>re-seq</a> re s )</tt>	returns a lazy sequence of successive matches of pattern in string using java util regex matcher find) each such match processed with re-groups
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>read</a> opts stream )</tt>	reads the next object from stream which must be an instance of java io pushbackreader or some derivee
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>read-line</a>  )</tt>	reads the next line from stream that is the current value of *in*
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>read-string</a> opts s )</tt>	reads one object from the string s
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>reader-conditional</a> form splicing? )</tt>	construct a data representation of a reader conditional
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>reader-conditional?</a> value )</tt>	return true if the value is the data representation of a reader conditional
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>realized?</a> x )</tt>	returns true if a value has been produced for a promise delay future or lazy sequence
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>record?</a> x )</tt>	returns true if x is a record
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>recur</a> exprs* )</tt>	evaluates the exprs in order then in parallel rebinds the bindings of the recursion point to the values of the exprs
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>reduce</a> f val coll )</tt>	f should be a function of 2 arguments
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>reduce-kv</a> f init coll )</tt>	reduces an associative collection
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>reduced</a> x )</tt>	wraps x in a way such that a reduce will terminate with the value x
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>reduced?</a> x )</tt>	returns true if x is the result of a call to reduced
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>reductions</a> f init coll )</tt>	returns a lazy seq of the intermediate values of the reduction as per reduce of coll by f starting with init
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>ref</a> x &amp; options )</tt>	creates and returns a ref with an initial value of x and zero or more options in any order : :meta metadata-map :validator validate-fn :min-history default 0 :max-history default 10 if metadata-map is supplied it will become the metadata on the ref
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>ref-history-count</a> ref )</tt>	returns the history count of a ref
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>ref-max-history</a> ref n )</tt>	gets the max-history of a ref or sets it and returns the ref
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>ref-min-history</a> ref n )</tt>	gets the min-history of a ref or sets it and returns the ref
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>ref-set</a> ref val )</tt>	must be called in a transaction
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>refer</a> ns-sym &amp; filters )</tt>	refers to all public vars of ns subject to filters
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>reify</a> &amp; opts+specs )</tt>	reify is a macro with the following structure:reify options* specs*) currently there are no options
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>release-pending-sends</a>  )</tt>	normally actions sent directly or indirectly during another action are held until the action completeschanges the agent's state
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>rem</a> num div )</tt>	remainder of dividing numerator by denominator
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>remove</a> pred coll )</tt>	returns a lazy sequence of the items in coll for which pred item returns false
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>remove-all-methods</a> multifn )</tt>	removes all of the methods of multimethod
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>remove-method</a> multifn dispatch-val )</tt>	removes the method of multimethod associated with dispatch-value
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>remove-ns</a> sym )</tt>	removes the namespace named by the symbol
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>remove-watch</a> reference key )</tt>	removes a watch set by add-watch from a reference
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>repeat</a> n x )</tt>	returns a lazyinfinite! or length n if supplied) sequence of xs
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>repeatedly</a> n f )</tt>	takes a function of no args presumably with side effects and returns an infinite or length n if supplied lazy sequence of calls to it
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>replace</a> smap coll )</tt>	given a map of replacement pairs and a vector / collection returns a vector / seq with any elements = a key in smap replaced with the corresponding val in smap
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>require</a> &amp; args )</tt>	loads libs skipping any that are already loaded
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>reset!</a> atom newval )</tt>	sets the value of atom to newval without regard for the current value
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>reset-meta!</a> iref metadata-map )</tt>	atomically resets the metadata for a namespace / var / ref / agent / atom
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>resolve</a> env sym )</tt>	same asns-resolve *ns* symbol) orns-resolve *ns* & env symbol
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>rest</a> coll )</tt>	returns a possibly empty seq of the items after the first
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>restart-agent</a> a new-state &amp; options )</tt>	when an agent is failed changes the agent state to new-state and then un-fails the agent so that sends are allowed again
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>resultset-seq</a> rs )</tt>	creates and returns a lazy sequence of structmaps corresponding to the rows in the java sql resultset rs
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>reverse</a> coll )</tt>	returns a seq of the items in coll in reverse order
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>reversible?</a> coll )</tt>	returns true if coll implements reversible
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>rseq</a> rev )</tt>	returns in constant time a seq of the items in rev which can be a vector or sorted-map in reverse order
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>rsubseq</a> sc start-test start-key end-test end-key )</tt>	sc must be a sorted collection test s one of < < = > or > =
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>run!</a> proc coll )</tt>	runs the supplied procedure via reduce for purposes of side effects on successive items in the collection
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>satisfies?</a> protocol x )</tt>	returns true if x satisfies the protocol
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>select-keys</a> map keyseq )</tt>	returns a map containing only those entries in map whose key is in keys
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>send</a> a f &amp; args )</tt>	dispatch an action to an agent
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>send-off</a> a f &amp; args )</tt>	dispatch a potentially blocking action to an agent
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>send-via</a> executor a f &amp; args )</tt>	dispatch an action to an agent
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>seq</a> coll )</tt>	returns a seq on the collection
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>seq?</a> x )</tt>	return true if x implements iseq
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>seque</a> n-or-q s )</tt>	creates a queued seq on another presumably lazy seq s
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>sequence</a> xform coll &amp; colls )</tt>	coerces coll to a possibly empty sequence if it is not already one
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>sequential?</a> coll )</tt>	returns true if coll implements sequential
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>set</a> coll )</tt>	returns a set of the distinct elements of coll
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>set!</a> . Classname-symbol staticFieldName-symbol expr )</tt>	used to set thread-local-bound vars java object instance fields and java class static fields
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>set-agent-send-executor!</a> executor )</tt>	sets the executorservice to be used by send
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>set-agent-send-off-executor!</a> executor )</tt>	sets the executorservice to be used by send-off
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>set-error-handler!</a> a handler-fn )</tt>	sets the error-handler of agent a to handler-fn
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>set-error-mode!</a> a mode-keyword )</tt>	sets the error-mode of agent a to mode-keyword which must be either :fail or :continue
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>set-validator!</a> iref validator-fn )</tt>	sets the validator-fn for a var / ref / agent / atom
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>set?</a> x )</tt>	returns true if x implements ipersistentset
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>short</a> x )</tt>	coerce to short
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>short-array</a> size init-val-or-seq )</tt>	creates an array of shorts
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>shorts</a> xs )</tt>	casts to shorts[]
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>shuffle</a> coll )</tt>	return a random permutation of coll
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>shutdown-agents</a>  )</tt>	initiates a shutdown of the thread pools that back the agent system
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>slurp</a> f &amp; opts )</tt>	opens a reader on f and reads all its contents returning a string
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>some</a> pred coll )</tt>	returns the first logical true value of pred x for any x in coll else nil
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>some-&gt;</a> expr &amp; forms )</tt>	when expr is not nil threads it into the first form via - > and when that result is not nil through the next etc
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>some-&gt;&gt;</a> expr &amp; forms )</tt>	when expr is not nil threads it into the first form via - > > and when that result is not nil through the next etc
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>some-fn</a> p1 p2 p3 &amp; ps )</tt>	takes a set of predicates and returns a function f that returns the first logical true value returned by one of its composing predicates against any of its arguments else it returns logical false
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>some?</a> x )</tt>	returns true if x is not nil false otherwise
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>sort</a> comp coll )</tt>	returns a sorted sequence of the items in coll
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>sort-by</a> keyfn comp coll )</tt>	returns a sorted sequence of the items in coll where the sort order is determined by comparing keyfn item
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>sorted-map</a> &amp; keyvals )</tt>	keyval = > key val returns a new sorted map with supplied mappings
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>sorted-map-by</a> comparator &amp; keyvals )</tt>	keyval = > key val returns a new sorted map with supplied mappings using the supplied comparator
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>sorted-set</a> &amp; keys )</tt>	returns a new sorted set with supplied keys
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>sorted-set-by</a> comparator &amp; keys )</tt>	returns a new sorted set with supplied keys using the supplied comparator
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>sorted?</a> coll )</tt>	returns true if coll implements sorted
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>special-symbol?</a> s )</tt>	returns true if s names a special form
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>spit</a> f content &amp; options )</tt>	opposite of slurp
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>split-at</a> n coll )</tt>	returns a vector of take n coll drop n coll
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>split-with</a> pred coll )</tt>	returns a vector of take-while pred coll drop-while pred coll
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>str</a> x &amp; ys )</tt>	with no args returns the empty string
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>string?</a> x )</tt>	return true if x is a string
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>struct</a> s &amp; vals )</tt>	returns a new structmap instance with the keys of the structure-basis
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>struct-map</a> s &amp; inits )</tt>	returns a new structmap instance with the keys of the structure-basis
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>subs</a> s start end )</tt>	returns the substring of s beginning at start inclusive and ending at end defaults to length of string exclusive
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>subseq</a> sc start-test start-key end-test end-key )</tt>	sc must be a sorted collection test s one of < < = > or > =
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>subvec</a> v start end )</tt>	returns a persistent vector of the items in vector from start inclusive to end exclusive
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>supers</a> class )</tt>	returns the immediate and indirect superclasses and interfaces of c if any
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>swap!</a> atom f x y &amp; args )</tt>	atomically swaps the value of atom to be: apply f current-value-of-atom args
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>symbol</a> ns name )</tt>	returns a symbol with the given namespace and name
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>symbol?</a> x )</tt>	return true if x is a symbol
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>sync</a> flags-ignored-for-now &amp; body )</tt>	transaction-flags = > tbd pass nil for now runs the exprs in an implicit do in a transaction that encompasses exprs and any nested calls
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>tagged-literal</a> tag form )</tt>	construct a data representation of a tagged literal from a tag symbol and a form
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>tagged-literal?</a> value )</tt>	return true if the value is the data representation of a tagged literal
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>take</a> n coll )</tt>	returns a lazy sequence of the first n items in coll or all items if there are fewer than n
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>take-last</a> n coll )</tt>	returns a seq of the last n items in coll
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>take-nth</a> n coll )</tt>	returns a lazy seq of every nth item in coll
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>take-while</a> pred coll )</tt>	returns a lazy sequence of successive items from coll while pred item returns true
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>test</a> v )</tt>	test v finds fn at key :test in var metadata and calls it presuming failure will throw exception
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>the-ns</a> x )</tt>	if passed a namespace returns it
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>thread-bound?</a> &amp; vars )</tt>	returns true if all of the vars provided as arguments have thread-local bindings
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>throw</a> expr )</tt>	the expr is evaluated and thrown therefore it should yield an instance of some derivee of throwable
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>time</a> expr )</tt>	evaluates expr and prints the time it took
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>to-array</a> coll )</tt>	returns an array of objects containing the contents of coll which can be any collection
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>to-array-2d</a> coll )</tt>	returns a potentially-ragged 2-dimensional array of objects containing the contents of coll which can be any collection of any collection
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>trampoline</a> f &amp; args )</tt>	trampoline can be used to convert algorithms requiring mutual recursion without stack consumption
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>transduce</a> xform f init coll )</tt>	reduce with a transformation of f xf
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>transient</a> coll )</tt>	returns a new transient version of the collection in constant time
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>tree-seq</a> branch? children root )</tt>	returns a lazy sequence of the nodes in a tree via a depth-first walk
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>true?</a> x )</tt>	returns true if x is the value true false otherwise
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>try</a> expr* catch-clause* finally-clause? )</tt>	catch-clause = > catch classname name expr*) finally-clause = > finally expr*) catches and handles java exceptions
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>type</a> x )</tt>	returns the :type metadata of x or its class if none
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>unchecked-add</a> x y )</tt>	returns the sum of x and y both long
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>unchecked-add-int</a> x y )</tt>	returns the sum of x and y both int
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>unchecked-byte</a> x )</tt>	coerce to byte
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>unchecked-char</a> x )</tt>	coerce to char
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>unchecked-dec</a> x )</tt>	returns a number one less than x a long
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>unchecked-dec-int</a> x )</tt>	returns a number one less than x an int
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>unchecked-divide-int</a> x y )</tt>	returns the division of x by y both int
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>unchecked-double</a> x )</tt>	coerce to double
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>unchecked-float</a> x )</tt>	coerce to float
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>unchecked-inc</a> x )</tt>	returns a number one greater than x a long
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>unchecked-inc-int</a> x )</tt>	returns a number one greater than x an int
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>unchecked-int</a> x )</tt>	coerce to int
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>unchecked-long</a> x )</tt>	coerce to long
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>unchecked-multiply</a> x y )</tt>	returns the product of x and y both long
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>unchecked-multiply-int</a> x y )</tt>	returns the product of x and y both int
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>unchecked-negate</a> x )</tt>	returns the negation of x a long
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>unchecked-negate-int</a> x )</tt>	returns the negation of x an int
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>unchecked-remainder-int</a> x y )</tt>	returns the remainder of division of x by y both int
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>unchecked-short</a> x )</tt>	coerce to short
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>unchecked-subtract</a> x y )</tt>	returns the difference of x and y both long
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>unchecked-subtract-int</a> x y )</tt>	returns the difference of x and y both int
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>underive</a> h tag parent )</tt>	removes a parent / child relationship between parent and tag
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>unreduced</a> x )</tt>	if x is reduced? returns deref x else returns x
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>unsigned-bit-shift-right</a> x n )</tt>	bitwise shift right without sign-extension
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>update</a> m k f x y z &amp; more )</tt>	'updates' a value in an associative structure where k is a key and f is a function that will take the old value and any supplied args and return the new value and returns a new structure
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>update-in</a> m [k &amp; ks] f &amp; args )</tt>	'updates' a value in a nested associative structure where ks is a sequence of keys and f is a function that will take the old value and any supplied args and return the new value and returns a new nested structure
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>update-proxy</a> proxy mappings )</tt>	takes a proxy instance and a map of strings which must correspond to methods of the proxy superclass / superinterfaces) to fns which must take arguments matching the corresponding method plus an additional explicit first arg corresponding to this and updates via assoc the proxy's fn map
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>use</a> &amp; args )</tt>	like 'require but also refers to each lib's namespace using clojure core / refer
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>val</a> e )</tt>	returns the value in the map entry
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>vals</a> map )</tt>	returns a sequence of the map's values in the same order as seq map
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>var</a> symbol )</tt>	the symbol must resolve to a var and the var object itself not its value is returned
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>var-get</a> x )</tt>	gets the value in the var object
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>var-set</a> x val )</tt>	sets the value in the var object to val
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>var?</a> v )</tt>	returns true if v is of type clojure lang var
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>vary-meta</a> obj f &amp; args )</tt>	returns an object of the same type and value as obj withapply f meta obj args) as its metadata
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>vec</a> coll )</tt>	creates a new vector containing the contents of coll
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>vector</a> a b c d e f &amp; args )</tt>	creates a new vector containing the args
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>vector-of</a> t &amp; elements )</tt>	creates a new vector of a single primitive type t where t is one of :int :long :float :double :byte :short :char or :boolean
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>vector?</a> x )</tt>	return true if x implements ipersistentvector
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>volatile!</a> val )</tt>	creates and returns a volatile with an initial value of val
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>volatile?</a> x )</tt>	returns true if x is a volatile
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>vreset!</a> vol newval )</tt>	sets the value of volatile to newval without regard for the current value
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>vswap!</a> vol f &amp; args )</tt>	non-atomically swaps the value of the volatile as if: apply f current-value-of-vol args
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>when</a> test &amp; body )</tt>	evaluates test
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>when-first</a> bindings &amp; body )</tt>	roughly the same as when seq xs let x first xs body)) but xs is evaluated only once
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>when-let</a> bindings &amp; body )</tt>	when test is true evaluates body with binding-form bound to the value of test
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>when-not</a> test &amp; body )</tt>	evaluates test
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>when-some</a> bindings &amp; body )</tt>	when test is not nil evaluates body with binding-form bound to the value of test
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>while</a> test &amp; body )</tt>	repeatedly executes body while test expression is true
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>with-bindings</a> binding-map &amp; body )</tt>	takes a map of var / value pairs
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>with-bindings*</a> binding-map f &amp; args )</tt>	takes a map of var / value pairs
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>with-in-str</a> s &amp; body )</tt>	evaluates body in a context in which *in* is bound to a fresh stringreader initialized with the string s
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>with-local-vars</a> name-vals-vec &amp; body )</tt>	varbinding= > symbol init-expr executes the exprs in a context in which the symbols are bound to vars with per-thread bindings to the init-exprs
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>with-meta</a> obj m )</tt>	returns an object of the same type and value as obj with map m as its metadata
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>with-open</a> bindings &amp; body )</tt>	evaluates body in a try expression with names bound to the values of the inits and a finally clause that calls close name on each name in reverse order
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>with-out-str</a> &amp; body )</tt>	evaluates exprs in a context in which *out* is bound to a fresh stringwriter
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>with-precision</a> precision &amp; exprs )</tt>	sets the precision and rounding mode to be used for bigdecimal operations
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>with-redefs</a> bindings &amp; body )</tt>	binding = > var-symbol temp-value-expr temporarily redefines vars while executing the body
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>with-redefs-fn</a> binding-map func )</tt>	temporarily redefines vars during a call to func
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>xml-seq</a> root )</tt>	a tree seq on the xml elements as per xml / parse
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>zero?</a> x )</tt>	returns true if num is zero else false
<tt style='background-color:#E8E8E8;'> (ns clojure.core) <br> (<a href=''>zipmap</a> keys vals )</tt>	returns a map with the keys mapped to the corresponding vals
<tt style='background-color:#E8E8E8;'> (ns clojure.data) <br> (<a href=''>diff</a> a b )</tt>	recursively compares a and b returning a tuple of things-only-in-a things-only-in-b things-in-both
<tt style='background-color:#E8E8E8;'> (ns clojure.edn) <br> (<a href=''>read</a> opts stream )</tt>	reads the next object from stream which must be an instance of java io pushbackreader or some derivee
<tt style='background-color:#E8E8E8;'> (ns clojure.edn) <br> (<a href=''>read-string</a> opts s )</tt>	reads one object from the string s
<tt style='background-color:#E8E8E8;'> (ns clojure.inspector) <br> (<a href=''>inspect</a> x )</tt>	creates a graphical swing inspector on the supplied object
<tt style='background-color:#E8E8E8;'> (ns clojure.inspector) <br> (<a href=''>inspect-table</a> data )</tt>	creates a graphical swing inspector on the supplied regular data which must be a sequential data structure of data structures of equal length
<tt style='background-color:#E8E8E8;'> (ns clojure.inspector) <br> (<a href=''>inspect-tree</a> data )</tt>	creates a graphical swing inspector on the supplied hierarchical data
<tt style='background-color:#E8E8E8;'> (ns clojure.instant) <br> (<a href=''>validated</a> new-instance )</tt>	return a function which constructs and instant by calling constructor after first validating that those arguments are in range and otherwise plausible
<tt style='background-color:#E8E8E8;'> (ns clojure.java.browse) <br> (<a href=''>browse-url</a> url )</tt>	open url in a browser
<tt style='background-color:#E8E8E8;'> (ns clojure.java.io) <br> (<a href=''>as-relative-path</a> x )</tt>	take an as-file-able thing and return a string if it is a relative path else illegalargumentexception
<tt style='background-color:#E8E8E8;'> (ns clojure.java.io) <br> (<a href=''>copy</a> input output &amp; opts )</tt>	copies input to output
<tt style='background-color:#E8E8E8;'> (ns clojure.java.io) <br> (<a href=''>delete-file</a> f &amp; [silently] )</tt>	delete file f
<tt style='background-color:#E8E8E8;'> (ns clojure.java.io) <br> (<a href=''>file</a> parent child &amp; more )</tt>	returns a java io file passing each arg to as-file
<tt style='background-color:#E8E8E8;'> (ns clojure.java.io) <br> (<a href=''>input-stream</a> x &amp; opts )</tt>	attempts to coerce its argument into an open java io inputstream
<tt style='background-color:#E8E8E8;'> (ns clojure.java.io) <br> (<a href=''>make-parents</a> f &amp; more )</tt>	given the same arg s as for file creates all parent directories of the file they represent
<tt style='background-color:#E8E8E8;'> (ns clojure.java.io) <br> (<a href=''>output-stream</a> x &amp; opts )</tt>	attempts to coerce its argument into an open java io outputstream
<tt style='background-color:#E8E8E8;'> (ns clojure.java.io) <br> (<a href=''>reader</a> x &amp; opts )</tt>	attempts to coerce its argument into an open java io reader
<tt style='background-color:#E8E8E8;'> (ns clojure.java.io) <br> (<a href=''>resource</a> n loader )</tt>	returns the url for a named resource
<tt style='background-color:#E8E8E8;'> (ns clojure.java.io) <br> (<a href=''>writer</a> x &amp; opts )</tt>	attempts to coerce its argument into an open java io writer
<tt style='background-color:#E8E8E8;'> (ns clojure.java.javadoc) <br> (<a href=''>add-local-javadoc</a> path )</tt>	adds to the list of local javadoc paths
<tt style='background-color:#E8E8E8;'> (ns clojure.java.javadoc) <br> (<a href=''>add-remote-javadoc</a> package-prefix url )</tt>	adds to the list of remote javadoc urls
<tt style='background-color:#E8E8E8;'> (ns clojure.java.javadoc) <br> (<a href=''>javadoc</a> class-or-object )</tt>	opens a browser window displaying the javadoc for the argument
<tt style='background-color:#E8E8E8;'> (ns clojure.java.shell) <br> (<a href=''>sh</a> &amp; args )</tt>	passes the given strings to runtime exec) to launch a sub-process
<tt style='background-color:#E8E8E8;'> (ns clojure.java.shell) <br> (<a href=''>with-sh-dir</a> dir &amp; forms )</tt>	sets the directory for use with sh see sh for details
<tt style='background-color:#E8E8E8;'> (ns clojure.java.shell) <br> (<a href=''>with-sh-env</a> env &amp; forms )</tt>	sets the environment for use with sh see sh for details
<tt style='background-color:#E8E8E8;'> (ns clojure.main) <br> (<a href=''>demunge</a> fn-name )</tt>	given a string representation of a fn class as in a stack trace element returns a readable version
<tt style='background-color:#E8E8E8;'> (ns clojure.main) <br> (<a href=''>load-script</a> path )</tt>	loads clojure source from a file or resource given its path
<tt style='background-color:#E8E8E8;'> (ns clojure.main) <br> (<a href=''>repl</a> &amp; options )</tt>	generic reusable read-eval-print loop
<tt style='background-color:#E8E8E8;'> (ns clojure.main) <br> (<a href=''>repl-caught</a> e )</tt>	default :caught hook for repl
<tt style='background-color:#E8E8E8;'> (ns clojure.main) <br> (<a href=''>repl-exception</a> throwable )</tt>	returns the root cause of throwables
<tt style='background-color:#E8E8E8;'> (ns clojure.main) <br> (<a href=''>repl-prompt</a>  )</tt>	default :prompt hook for repl
<tt style='background-color:#E8E8E8;'> (ns clojure.main) <br> (<a href=''>repl-read</a> request-prompt request-exit )</tt>	default :read hook for repl
<tt style='background-color:#E8E8E8;'> (ns clojure.main) <br> (<a href=''>root-cause</a> t )</tt>	returns the initial cause of an exception or error by peeling off all of its wrappers
<tt style='background-color:#E8E8E8;'> (ns clojure.main) <br> (<a href=''>skip-if-eol</a> s )</tt>	if the next character on stream s is a newline skips it otherwise leaves the stream untouched
<tt style='background-color:#E8E8E8;'> (ns clojure.main) <br> (<a href=''>skip-whitespace</a> s )</tt>	skips whitespace characters on stream s
<tt style='background-color:#E8E8E8;'> (ns clojure.main) <br> (<a href=''>stack-element-str</a> el )</tt>	returns a possibly unmunged string representation of a stacktraceelement
<tt style='background-color:#E8E8E8;'> (ns clojure.main) <br> (<a href=''>with-bindings</a> &amp; body )</tt>	executes body in the context of thread-local bindings for several vars that often need to be set!
<tt style='background-color:#E8E8E8;'> (ns clojure.main) <br> (<a href=''>with-read-known</a> &amp; body )</tt>	evaluates body with *read-eval* set to a "known" value i e
<tt style='background-color:#E8E8E8;'> (ns clojure.pprint) <br> (<a href=''>cl-format</a> writer format-in &amp; args )</tt>	an implementation of a common lisp compatible format function
<tt style='background-color:#E8E8E8;'> (ns clojure.pprint) <br> (<a href=''>code-dispatch</a> object )</tt>	the pretty print dispatch function for pretty printing clojure code
<tt style='background-color:#E8E8E8;'> (ns clojure.pprint) <br> (<a href=''>formatter</a> format-in )</tt>	makes a function which can directly run format-in
<tt style='background-color:#E8E8E8;'> (ns clojure.pprint) <br> (<a href=''>formatter-out</a> format-in )</tt>	makes a function which can directly run format-in
<tt style='background-color:#E8E8E8;'> (ns clojure.pprint) <br> (<a href=''>fresh-line</a>  )</tt>	make a newline if *out* is not already at the beginning of the line
<tt style='background-color:#E8E8E8;'> (ns clojure.pprint) <br> (<a href=''>get-pretty-writer</a> writer )</tt>	returns the java io writer passed in wrapped in a pretty writer proxy unless it's already a pretty writer
<tt style='background-color:#E8E8E8;'> (ns clojure.pprint) <br> (<a href=''>pp</a>  )</tt>	a convenience macro that pretty prints the last thing output
<tt style='background-color:#E8E8E8;'> (ns clojure.pprint) <br> (<a href=''>pprint</a> object writer )</tt>	pretty print object to the optional output writer
<tt style='background-color:#E8E8E8;'> (ns clojure.pprint) <br> (<a href=''>pprint-indent</a> relative-to n )</tt>	create an indent at this point in the pretty printing stream
<tt style='background-color:#E8E8E8;'> (ns clojure.pprint) <br> (<a href=''>pprint-logical-block</a> options* body )</tt>	execute the body as a pretty printing logical block with output to *out* which must be a pretty printing writer
<tt style='background-color:#E8E8E8;'> (ns clojure.pprint) <br> (<a href=''>pprint-newline</a> kind )</tt>	print a conditional newline to a pretty printing stream
<tt style='background-color:#E8E8E8;'> (ns clojure.pprint) <br> (<a href=''>pprint-tab</a> kind colnum colinc )</tt>	tab at this point in the pretty printing stream
<tt style='background-color:#E8E8E8;'> (ns clojure.pprint) <br> (<a href=''>print-length-loop</a> bindings &amp; body )</tt>	a version of loop that iterates at most *print-length* times
<tt style='background-color:#E8E8E8;'> (ns clojure.pprint) <br> (<a href=''>print-table</a> rows )</tt>	prints a collection of maps in a textual table
<tt style='background-color:#E8E8E8;'> (ns clojure.pprint) <br> (<a href=''>set-pprint-dispatch</a> function )</tt>	set the pretty print dispatch function to a function matchingfn obj where obj is the object to pretty print
<tt style='background-color:#E8E8E8;'> (ns clojure.pprint) <br> (<a href=''>simple-dispatch</a> object )</tt>	the pretty print dispatch function for simple data structure format
<tt style='background-color:#E8E8E8;'> (ns clojure.pprint) <br> (<a href=''>with-pprint-dispatch</a> function &amp; body )</tt>	execute body with the pretty print dispatch function bound to function
<tt style='background-color:#E8E8E8;'> (ns clojure.pprint) <br> (<a href=''>write</a> object &amp; kw-args )</tt>	write an object subject to the current bindings of the printer control variables
<tt style='background-color:#E8E8E8;'> (ns clojure.pprint) <br> (<a href=''>write-out</a> object )</tt>	write an object to *out* subject to the current bindings of the printer control variables
<tt style='background-color:#E8E8E8;'> (ns clojure.reflect) <br> (<a href=''>-&gt;AsmReflector</a> class-resolver )</tt>	positional factory function for class clojure reflect asmreflector
<tt style='background-color:#E8E8E8;'> (ns clojure.reflect) <br> (<a href=''>-&gt;Constructor</a> name declaring-class parameter-types exception-types flags )</tt>	positional factory function for class clojure reflect constructor
<tt style='background-color:#E8E8E8;'> (ns clojure.reflect) <br> (<a href=''>-&gt;Field</a> name type declaring-class flags )</tt>	positional factory function for class clojure reflect field
<tt style='background-color:#E8E8E8;'> (ns clojure.reflect) <br> (<a href=''>-&gt;JavaReflector</a> classloader )</tt>	positional factory function for class clojure reflect javareflector
<tt style='background-color:#E8E8E8;'> (ns clojure.reflect) <br> (<a href=''>-&gt;Method</a> name return-type declaring-class parameter-types exception-types flags )</tt>	positional factory function for class clojure reflect method
<tt style='background-color:#E8E8E8;'> (ns clojure.reflect) <br> (<a href=''>map-&gt;Constructor</a> m# )</tt>	factory function for class clojure reflect constructor taking a map of keywords to field values
<tt style='background-color:#E8E8E8;'> (ns clojure.reflect) <br> (<a href=''>map-&gt;Field</a> m# )</tt>	factory function for class clojure reflect field taking a map of keywords to field values
<tt style='background-color:#E8E8E8;'> (ns clojure.reflect) <br> (<a href=''>map-&gt;Method</a> m# )</tt>	factory function for class clojure reflect method taking a map of keywords to field values
<tt style='background-color:#E8E8E8;'> (ns clojure.repl) <br> (<a href=''>apropos</a> str-or-pattern )</tt>	given a regular expression or stringable thing return a seq of all public definitions in all currently-loaded namespaces that match the str-or-pattern
<tt style='background-color:#E8E8E8;'> (ns clojure.repl) <br> (<a href=''>demunge</a> fn-name )</tt>	given a string representation of a fn class as in a stack trace element returns a readable version
<tt style='background-color:#E8E8E8;'> (ns clojure.repl) <br> (<a href=''>dir</a> nsname )</tt>	prints a sorted directory of public vars in a namespace
<tt style='background-color:#E8E8E8;'> (ns clojure.repl) <br> (<a href=''>dir-fn</a> ns )</tt>	returns a sorted seq of symbols naming public vars in a namespace
<tt style='background-color:#E8E8E8;'> (ns clojure.repl) <br> (<a href=''>doc</a> name )</tt>	prints documentation for a var or special form given its name
<tt style='background-color:#E8E8E8;'> (ns clojure.repl) <br> (<a href=''>find-doc</a> re-string-or-pattern )</tt>	prints documentation for any var whose documentation or name contains a match for re-string-or-pattern
<tt style='background-color:#E8E8E8;'> (ns clojure.repl) <br> (<a href=''>pst</a> e depth )</tt>	prints a stack trace of the exception to the depth requested
<tt style='background-color:#E8E8E8;'> (ns clojure.repl) <br> (<a href=''>root-cause</a> t )</tt>	returns the initial cause of an exception or error by peeling off all of its wrappers
<tt style='background-color:#E8E8E8;'> (ns clojure.repl) <br> (<a href=''>set-break-handler!</a> f )</tt>	register int signal handler
<tt style='background-color:#E8E8E8;'> (ns clojure.repl) <br> (<a href=''>source</a> n )</tt>	prints the source code for the given symbol if it can find it
<tt style='background-color:#E8E8E8;'> (ns clojure.repl) <br> (<a href=''>source-fn</a> x )</tt>	returns a string of the source code for the given symbol if it can find it
<tt style='background-color:#E8E8E8;'> (ns clojure.repl) <br> (<a href=''>stack-element-str</a> el )</tt>	returns a possibly unmunged string representation of a stacktraceelement
<tt style='background-color:#E8E8E8;'> (ns clojure.repl) <br> (<a href=''>thread-stopper</a> thread )</tt>	returns a function that takes one arg and uses that as an exception message to stop the given thread
<tt style='background-color:#E8E8E8;'> (ns clojure.set) <br> (<a href=''>difference</a> s1 s2 &amp; sets )</tt>	return a set that is the first set without elements of the remaining sets
<tt style='background-color:#E8E8E8;'> (ns clojure.set) <br> (<a href=''>index</a> xrel ks )</tt>	returns a map of the distinct values of ks in the xrel mapped to a set of the maps in xrel with the corresponding values of ks
<tt style='background-color:#E8E8E8;'> (ns clojure.set) <br> (<a href=''>intersection</a> s1 s2 &amp; sets )</tt>	return a set that is the intersection of the input sets
<tt style='background-color:#E8E8E8;'> (ns clojure.set) <br> (<a href=''>join</a> xrel yrel km )</tt>	when passed 2 rels returns the rel corresponding to the natural join
<tt style='background-color:#E8E8E8;'> (ns clojure.set) <br> (<a href=''>map-invert</a> m )</tt>	returns the map with the vals mapped to the keys
<tt style='background-color:#E8E8E8;'> (ns clojure.set) <br> (<a href=''>project</a> xrel ks )</tt>	returns a rel of the elements of xrel with only the keys in ks
<tt style='background-color:#E8E8E8;'> (ns clojure.set) <br> (<a href=''>rename</a> xrel kmap )</tt>	returns a rel of the maps in xrel with the keys in kmap renamed to the vals in kmap
<tt style='background-color:#E8E8E8;'> (ns clojure.set) <br> (<a href=''>rename-keys</a> map kmap )</tt>	returns the map with the keys in kmap renamed to the vals in kmap
<tt style='background-color:#E8E8E8;'> (ns clojure.set) <br> (<a href=''>select</a> pred xset )</tt>	returns a set of the elements for which pred is true
<tt style='background-color:#E8E8E8;'> (ns clojure.set) <br> (<a href=''>subset?</a> set1 set2 )</tt>	is set1 a subset of set2?
<tt style='background-color:#E8E8E8;'> (ns clojure.set) <br> (<a href=''>superset?</a> set1 set2 )</tt>	is set1 a superset of set2?
<tt style='background-color:#E8E8E8;'> (ns clojure.set) <br> (<a href=''>union</a> s1 s2 &amp; sets )</tt>	return a set that is the union of the input sets
<tt style='background-color:#E8E8E8;'> (ns clojure.stacktrace) <br> (<a href=''>e</a>  )</tt>	repl utility
<tt style='background-color:#E8E8E8;'> (ns clojure.stacktrace) <br> (<a href=''>print-cause-trace</a> tr n )</tt>	like print-stack-trace but prints chained exceptions causes
<tt style='background-color:#E8E8E8;'> (ns clojure.stacktrace) <br> (<a href=''>print-stack-trace</a> tr n )</tt>	prints a clojure-oriented stack trace of tr a throwable
<tt style='background-color:#E8E8E8;'> (ns clojure.stacktrace) <br> (<a href=''>print-throwable</a> tr )</tt>	prints the class and message of a throwable
<tt style='background-color:#E8E8E8;'> (ns clojure.stacktrace) <br> (<a href=''>print-trace-element</a> e )</tt>	prints a clojure-oriented view of one element in a stack trace
<tt style='background-color:#E8E8E8;'> (ns clojure.stacktrace) <br> (<a href=''>root-cause</a> tr )</tt>	returns the last 'cause' throwable in a chain of throwables
<tt style='background-color:#E8E8E8;'> (ns clojure.string) <br> (<a href=''>blank?</a> s )</tt>	true if s is nil empty or contains only whitespace
<tt style='background-color:#E8E8E8;'> (ns clojure.string) <br> (<a href=''>capitalize</a> s )</tt>	converts first character of the string to upper-case all other characters to lower-case
<tt style='background-color:#E8E8E8;'> (ns clojure.string) <br> (<a href=''>ends-with?</a> s substr )</tt>	true if s ends with substr
<tt style='background-color:#E8E8E8;'> (ns clojure.string) <br> (<a href=''>escape</a> s cmap )</tt>	return a new string using cmap to escape each character ch from s as follows: if cmap ch is nil append ch to the new string
<tt style='background-color:#E8E8E8;'> (ns clojure.string) <br> (<a href=''>includes?</a> s substr )</tt>	true if s includes substr
<tt style='background-color:#E8E8E8;'> (ns clojure.string) <br> (<a href=''>index-of</a> s value from-index )</tt>	return index of value string or char in s optionally searching forward from from-index or nil if not found
<tt style='background-color:#E8E8E8;'> (ns clojure.string) <br> (<a href=''>join</a> separator coll )</tt>	returns a string of all elements in coll as returned by seq coll separated by an optional separator
<tt style='background-color:#E8E8E8;'> (ns clojure.string) <br> (<a href=''>last-index-of</a> s value from-index )</tt>	return last index of value string or char in s optionally searching backward from from-index or nil if not found
<tt style='background-color:#E8E8E8;'> (ns clojure.string) <br> (<a href=''>lower-case</a> s )</tt>	converts string to all lower-case
<tt style='background-color:#E8E8E8;'> (ns clojure.string) <br> (<a href=''>re-quote-replacement</a> replacement )</tt>	given a replacement string that you wish to be a literal replacement for a pattern match in replace or replace-first do the necessary escaping of special characters in the replacement
<tt style='background-color:#E8E8E8;'> (ns clojure.string) <br> (<a href=''>replace</a> s match replacement )</tt>	replaces all instance of match with replacement in s
<tt style='background-color:#E8E8E8;'> (ns clojure.string) <br> (<a href=''>replace-first</a> s match replacement )</tt>	replaces the first instance of match with replacement in s
<tt style='background-color:#E8E8E8;'> (ns clojure.string) <br> (<a href=''>reverse</a> s )</tt>	returns s with its characters reversed
<tt style='background-color:#E8E8E8;'> (ns clojure.string) <br> (<a href=''>split</a> s re limit )</tt>	splits string on a regular expression
<tt style='background-color:#E8E8E8;'> (ns clojure.string) <br> (<a href=''>split-lines</a> s )</tt>	splits s on \n or \r\n
<tt style='background-color:#E8E8E8;'> (ns clojure.string) <br> (<a href=''>starts-with?</a> s substr )</tt>	true if s starts with substr
<tt style='background-color:#E8E8E8;'> (ns clojure.string) <br> (<a href=''>trim</a> s )</tt>	removes whitespace from both ends of string
<tt style='background-color:#E8E8E8;'> (ns clojure.string) <br> (<a href=''>trim-newline</a> s )</tt>	removes all trailing newline \n or return \r characters from string
<tt style='background-color:#E8E8E8;'> (ns clojure.string) <br> (<a href=''>triml</a> s )</tt>	removes whitespace from the left side of string
<tt style='background-color:#E8E8E8;'> (ns clojure.string) <br> (<a href=''>trimr</a> s )</tt>	removes whitespace from the right side of string
<tt style='background-color:#E8E8E8;'> (ns clojure.string) <br> (<a href=''>upper-case</a> s )</tt>	converts string to all upper-case
<tt style='background-color:#E8E8E8;'> (ns clojure.template) <br> (<a href=''>apply-template</a> argv expr values )</tt>	for use in macros
<tt style='background-color:#E8E8E8;'> (ns clojure.template) <br> (<a href=''>do-template</a> argv expr &amp; values )</tt>	repeatedly copies expr in a do block for each group of arguments in values
<tt style='background-color:#E8E8E8;'> (ns clojure.test) <br> (<a href=''>are</a> argv expr &amp; args )</tt>	checks multiple assertions with a template expression
<tt style='background-color:#E8E8E8;'> (ns clojure.test) <br> (<a href=''>assert-any</a> msg form )</tt>	returns generic assertion code for any test including macros java method calls or isolated symbols
<tt style='background-color:#E8E8E8;'> (ns clojure.test) <br> (<a href=''>assert-predicate</a> msg form )</tt>	returns generic assertion code for any functional predicate
<tt style='background-color:#E8E8E8;'> (ns clojure.test) <br> (<a href=''>compose-fixtures</a> f1 f2 )</tt>	composes two fixture functions creating a new fixture function that combines their behavior
<tt style='background-color:#E8E8E8;'> (ns clojure.test) <br> (<a href=''>deftest-</a> name &amp; body )</tt>	defines a test function with no arguments
<tt style='background-color:#E8E8E8;'> (ns clojure.test) <br> (<a href=''>do-report</a> m )</tt>	add file and line information to a test result and call report
<tt style='background-color:#E8E8E8;'> (ns clojure.test) <br> (<a href=''>file-position</a> n )</tt>	returns a vector filename line-number for the nth call up the stack
<tt style='background-color:#E8E8E8;'> (ns clojure.test) <br> (<a href=''>function?</a> x )</tt>	returns true if argument is a function or a symbol that resolves to a function not a macro
<tt style='background-color:#E8E8E8;'> (ns clojure.test) <br> (<a href=''>get-possibly-unbound-var</a> v )</tt>	like var-get but returns nil if the var is unbound
<tt style='background-color:#E8E8E8;'> (ns clojure.test) <br> (<a href=''>inc-report-counter</a> name )</tt>	increments the named counter in *report-counters* a ref to a map
<tt style='background-color:#E8E8E8;'> (ns clojure.test) <br> (<a href=''>is</a> form msg )</tt>	generic assertion macro
<tt style='background-color:#E8E8E8;'> (ns clojure.test) <br> (<a href=''>join-fixtures</a> fixtures )</tt>	composes a collection of fixtures in order
<tt style='background-color:#E8E8E8;'> (ns clojure.test) <br> (<a href=''>run-all-tests</a> re )</tt>	runs all tests in all namespaces; prints results
<tt style='background-color:#E8E8E8;'> (ns clojure.test) <br> (<a href=''>run-tests</a> &amp; namespaces )</tt>	runs all tests in the given namespaces; prints results
<tt style='background-color:#E8E8E8;'> (ns clojure.test) <br> (<a href=''>successful?</a> summary )</tt>	returns true if the given test summary indicates all tests were successful false otherwise
<tt style='background-color:#E8E8E8;'> (ns clojure.test) <br> (<a href=''>test-all-vars</a> ns )</tt>	calls test-vars on every var interned in the namespace with fixtures
<tt style='background-color:#E8E8E8;'> (ns clojure.test) <br> (<a href=''>test-ns</a> ns )</tt>	if the namespace defines a function named test-ns-hook calls that
<tt style='background-color:#E8E8E8;'> (ns clojure.test) <br> (<a href=''>test-var</a> v )</tt>	if v has a function in its :test metadata calls that function with *testing-vars* bound toconj *testing-vars* v
<tt style='background-color:#E8E8E8;'> (ns clojure.test) <br> (<a href=''>test-vars</a> vars )</tt>	groups vars by their namespace and runs test-vars on them with appropriate fixtures applied
<tt style='background-color:#E8E8E8;'> (ns clojure.test) <br> (<a href=''>testing</a> string &amp; body )</tt>	adds a new string to the list of testing contexts
<tt style='background-color:#E8E8E8;'> (ns clojure.test) <br> (<a href=''>testing-contexts-str</a>  )</tt>	returns a string representation of the current test context
<tt style='background-color:#E8E8E8;'> (ns clojure.test) <br> (<a href=''>testing-vars-str</a> m )</tt>	returns a string representation of the current test
<tt style='background-color:#E8E8E8;'> (ns clojure.test) <br> (<a href=''>try-expr</a> msg form )</tt>	used by the 'is' macro to catch unexpected exceptions
<tt style='background-color:#E8E8E8;'> (ns clojure.test) <br> (<a href=''>with-test</a> definition &amp; body )</tt>	takes any definition form that returns a var as the first argument
<tt style='background-color:#E8E8E8;'> (ns clojure.test) <br> (<a href=''>with-test-out</a> &amp; body )</tt>	runs body with *out* bound to the value of *test-out*
<tt style='background-color:#E8E8E8;'> (ns clojure.walk) <br> (<a href=''>keywordize-keys</a> m )</tt>	recursively transforms all map keys from strings to keywords
<tt style='background-color:#E8E8E8;'> (ns clojure.walk) <br> (<a href=''>macroexpand-all</a> form )</tt>	recursively performs all possible macroexpansions in form
<tt style='background-color:#E8E8E8;'> (ns clojure.walk) <br> (<a href=''>postwalk</a> f form )</tt>	performs a depth-first post-order traversal of form
<tt style='background-color:#E8E8E8;'> (ns clojure.walk) <br> (<a href=''>postwalk-demo</a> form )</tt>	demonstrates the behavior of postwalk by printing each form as it is walked
<tt style='background-color:#E8E8E8;'> (ns clojure.walk) <br> (<a href=''>postwalk-replace</a> smap form )</tt>	recursively transforms form by replacing keys in smap with their values
<tt style='background-color:#E8E8E8;'> (ns clojure.walk) <br> (<a href=''>prewalk</a> f form )</tt>	like postwalk but does pre-order traversal
<tt style='background-color:#E8E8E8;'> (ns clojure.walk) <br> (<a href=''>prewalk-demo</a> form )</tt>	demonstrates the behavior of prewalk by printing each form as it is walked
<tt style='background-color:#E8E8E8;'> (ns clojure.walk) <br> (<a href=''>prewalk-replace</a> smap form )</tt>	recursively transforms form by replacing keys in smap with their values
<tt style='background-color:#E8E8E8;'> (ns clojure.walk) <br> (<a href=''>stringify-keys</a> m )</tt>	recursively transforms all map keys from keywords to strings
<tt style='background-color:#E8E8E8;'> (ns clojure.walk) <br> (<a href=''>walk</a> inner outer form )</tt>	traverses form an arbitrary data structure
<tt style='background-color:#E8E8E8;'> (ns clojure.xml) <br> (<a href=''>parse</a> s startparse )</tt>	parses and loads the source s which can be a file inputstream or string naming a uri
<tt style='background-color:#E8E8E8;'> (ns clojure.zip) <br> (<a href=''>append-child</a> loc item )</tt>	inserts the item as the rightmost child of the node at this loc without moving
<tt style='background-color:#E8E8E8;'> (ns clojure.zip) <br> (<a href=''>branch?</a> loc )</tt>	returns true if the node at loc is a branch
<tt style='background-color:#E8E8E8;'> (ns clojure.zip) <br> (<a href=''>children</a> loc )</tt>	returns a seq of the children of node at loc which must be a branch
<tt style='background-color:#E8E8E8;'> (ns clojure.zip) <br> (<a href=''>down</a> loc )</tt>	returns the loc of the leftmost child of the node at this loc or nil if no children
<tt style='background-color:#E8E8E8;'> (ns clojure.zip) <br> (<a href=''>edit</a> loc f &amp; args )</tt>	replaces the node at this loc with the value of f node args
<tt style='background-color:#E8E8E8;'> (ns clojure.zip) <br> (<a href=''>end?</a> loc )</tt>	returns true if loc represents the end of a depth-first walk
<tt style='background-color:#E8E8E8;'> (ns clojure.zip) <br> (<a href=''>insert-child</a> loc item )</tt>	inserts the item as the leftmost child of the node at this loc without moving
<tt style='background-color:#E8E8E8;'> (ns clojure.zip) <br> (<a href=''>insert-left</a> loc item )</tt>	inserts the item as the left sibling of the node at this loc without moving
<tt style='background-color:#E8E8E8;'> (ns clojure.zip) <br> (<a href=''>insert-right</a> loc item )</tt>	inserts the item as the right sibling of the node at this loc without moving
<tt style='background-color:#E8E8E8;'> (ns clojure.zip) <br> (<a href=''>left</a> loc )</tt>	returns the loc of the left sibling of the node at this loc or nil
<tt style='background-color:#E8E8E8;'> (ns clojure.zip) <br> (<a href=''>leftmost</a> loc )</tt>	returns the loc of the leftmost sibling of the node at this loc or self
<tt style='background-color:#E8E8E8;'> (ns clojure.zip) <br> (<a href=''>lefts</a> loc )</tt>	returns a seq of the left siblings of this loc
<tt style='background-color:#E8E8E8;'> (ns clojure.zip) <br> (<a href=''>make-node</a> loc node children )</tt>	returns a new branch node given an existing node and new children
<tt style='background-color:#E8E8E8;'> (ns clojure.zip) <br> (<a href=''>next</a> loc )</tt>	moves to the next loc in the hierarchy depth-first
<tt style='background-color:#E8E8E8;'> (ns clojure.zip) <br> (<a href=''>node</a> loc )</tt>	returns the node at loc
<tt style='background-color:#E8E8E8;'> (ns clojure.zip) <br> (<a href=''>path</a> loc )</tt>	returns a seq of nodes leading to this loc
<tt style='background-color:#E8E8E8;'> (ns clojure.zip) <br> (<a href=''>prev</a> loc )</tt>	moves to the previous loc in the hierarchy depth-first
<tt style='background-color:#E8E8E8;'> (ns clojure.zip) <br> (<a href=''>remove</a> loc )</tt>	removes the node at loc returning the loc that would have preceded it in a depth-first walk
<tt style='background-color:#E8E8E8;'> (ns clojure.zip) <br> (<a href=''>replace</a> loc node )</tt>	replaces the node at this loc without moving
<tt style='background-color:#E8E8E8;'> (ns clojure.zip) <br> (<a href=''>right</a> loc )</tt>	returns the loc of the right sibling of the node at this loc or nil
<tt style='background-color:#E8E8E8;'> (ns clojure.zip) <br> (<a href=''>rightmost</a> loc )</tt>	returns the loc of the rightmost sibling of the node at this loc or self
<tt style='background-color:#E8E8E8;'> (ns clojure.zip) <br> (<a href=''>rights</a> loc )</tt>	returns a seq of the right siblings of this loc
<tt style='background-color:#E8E8E8;'> (ns clojure.zip) <br> (<a href=''>root</a> loc )</tt>	zips all the way up and returns the root node reflecting any changes
<tt style='background-color:#E8E8E8;'> (ns clojure.zip) <br> (<a href=''>seq-zip</a> root )</tt>	returns a zipper for nested sequences given a root sequence
<tt style='background-color:#E8E8E8;'> (ns clojure.zip) <br> (<a href=''>up</a> loc )</tt>	returns the loc of the parent of the node at this loc or nil if at the top
<tt style='background-color:#E8E8E8;'> (ns clojure.zip) <br> (<a href=''>vector-zip</a> root )</tt>	returns a zipper for nested vectors given a root vector
<tt style='background-color:#E8E8E8;'> (ns clojure.zip) <br> (<a href=''>xml-zip</a> root )</tt>	returns a zipper for xml elementsas from xml / parse) given a root element
<tt style='background-color:#E8E8E8;'> (ns clojure.zip) <br> (<a href=''>zipper</a> branch? children make-node root )</tt>	creates a new zipper structure
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.generic.arithmetic) <br> (<a href=''>*</a> x y &amp; more )</tt>	return the product of all arguments
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.generic.arithmetic) <br> (<a href=''>+</a> x y &amp; more )</tt>	return the sum of all arguments
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.generic.arithmetic) <br> (<a href=''>-</a> x y &amp; more )</tt>	return the difference of the first argument and the sum of all other arguments
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.generic.arithmetic) <br> (<a href=''>-&gt;one-type</a>  )</tt>	positional factory function for class clojure algo generic arithmetic one-type
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.generic.arithmetic) <br> (<a href=''>-&gt;zero-type</a>  )</tt>	positional factory function for class clojure algo generic arithmetic zero-type
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.generic.arithmetic) <br> (<a href=''>/</a> x y &amp; more )</tt>	return the quotient of the first argument and the product of all other arguments
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.generic.arithmetic) <br> (<a href=''>defmethod*</a> ns name &amp; args )</tt>	define a method implementation for the multimethod name in namespace ns
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.generic.arithmetic) <br> (<a href=''>map-&gt;one-type</a> m# )</tt>	factory function for class clojure algo generic arithmetic one-type taking a map of keywords to field values
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.generic.arithmetic) <br> (<a href=''>map-&gt;zero-type</a> m# )</tt>	factory function for class clojure algo generic arithmetic zero-type taking a map of keywords to field values
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.generic.arithmetic) <br> (<a href=''>qsym</a> ns sym )</tt>	create the qualified symbol corresponding to sym in namespace ns
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.generic.collection) <br> (<a href=''>assoc</a> coll &amp; key-val-pairs )</tt>	returns a new collection in which the values corresponding to the given keys are updated by the given values
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.generic.collection) <br> (<a href=''>conj</a> coll &amp; xs )</tt>	returns a new collection resulting from adding all xs to coll
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.generic.collection) <br> (<a href=''>dissoc</a> coll &amp; keys )</tt>	returns a new collection in which the entries corresponding to the given keys are removed
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.generic.collection) <br> (<a href=''>empty</a> coll )</tt>	returns an empty collection of the same kind as the argument
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.generic.collection) <br> (<a href=''>get</a> coll key not-found )</tt>	returns the element of coll referred to by key
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.generic.collection) <br> (<a href=''>into</a> to from )</tt>	returns a new coll consisting of to-coll with all of the items of from-coll conjoined
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.generic.collection) <br> (<a href=''>seq</a> s )</tt>	returns a seq on the object s
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.generic.functor) <br> (<a href=''>fmap</a> f s )</tt>	applies function f to each item in the data structure s and returns a structure of the same kind
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.generic.math-functions) <br> (<a href=''>abs</a> x math-context )</tt>	return the absolute value of x
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.generic.math-functions) <br> (<a href=''>acos</a> x )</tt>	return the acos of x
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.generic.math-functions) <br> (<a href=''>approx=</a> x y eps )</tt>	return true if the absolute value of the difference between x and y is less than eps
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.generic.math-functions) <br> (<a href=''>asin</a> x )</tt>	return the asin of x
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.generic.math-functions) <br> (<a href=''>atan</a> x )</tt>	return the atan of x
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.generic.math-functions) <br> (<a href=''>atan2</a> x y )</tt>	return the atan2 of x and y
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.generic.math-functions) <br> (<a href=''>ceil</a> x )</tt>	return the ceil of x
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.generic.math-functions) <br> (<a href=''>conjugate</a> x )</tt>	return the conjugate of x
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.generic.math-functions) <br> (<a href=''>cos</a> x )</tt>	return the cos of x
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.generic.math-functions) <br> (<a href=''>exp</a> x )</tt>	return the exp of x
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.generic.math-functions) <br> (<a href=''>floor</a> x )</tt>	return the floor of x
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.generic.math-functions) <br> (<a href=''>log</a> x )</tt>	return the log of x
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.generic.math-functions) <br> (<a href=''>pow</a> x y )</tt>	return the pow of x and y
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.generic.math-functions) <br> (<a href=''>rint</a> x )</tt>	return the rint of x
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.generic.math-functions) <br> (<a href=''>sgn</a> x )</tt>	return the sign of x -1 0 or 1
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.generic.math-functions) <br> (<a href=''>sin</a> x )</tt>	return the sin of x
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.generic.math-functions) <br> (<a href=''>sqr</a> x )</tt>	return the square of x
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.generic.math-functions) <br> (<a href=''>sqrt</a> x )</tt>	return the sqrt of x
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.generic.math-functions) <br> (<a href=''>tan</a> x )</tt>	return the tan of x
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.graph) <br> (<a href=''>add-loops</a> g )</tt>	for each node n add the edge n- > n if not already present
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.graph) <br> (<a href=''>component-graph</a> g sccs )</tt>	given a graph perhaps with cycles return a reduced graph that is acyclic
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.graph) <br> (<a href=''>dependency-list</a> g )</tt>	similar to a topological sort this returns a vector of sets
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.graph) <br> (<a href=''>fixed-point</a> data fun max equal )</tt>	repeatedly apply fun to data until equal old-data new-data returns true
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.graph) <br> (<a href=''>get-neighbors</a> g n )</tt>	get the neighbors of a node
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.graph) <br> (<a href=''>lazy-walk</a> g ns v )</tt>	return a lazy sequence of the nodes of a graph starting a node n
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.graph) <br> (<a href=''>post-ordered-nodes</a> g )</tt>	return a sequence of indexes of a post-ordered walk of the graph
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.graph) <br> (<a href=''>recursive-component?</a> g ns )</tt>	is the component recieved from scc self recursive?
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.graph) <br> (<a href=''>remove-loops</a> g )</tt>	for each node n remove any edges n- > n
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.graph) <br> (<a href=''>reverse-graph</a> g )</tt>	given a directed graph return another directed graph with the order of the edges reversed
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.graph) <br> (<a href=''>scc</a> g )</tt>	returns as a sequence of sets the strongly connected components of g
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.graph) <br> (<a href=''>self-recursive-sets</a> g )</tt>	returns as a sequence of sets the components of a graph that are self-recursive
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.graph) <br> (<a href=''>stratification-list</a> g1 g2 )</tt>	similar to dependency-list see doc except two graphs are provided
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.graph) <br> (<a href=''>transitive-closure</a> g )</tt>	returns the transitive closure of a graph
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.generic.comparison) <br> (<a href=''>&lt;</a> x y &amp; more )</tt>	return true if each argument is smaller than the following ones
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.generic.comparison) <br> (<a href=''>&lt;=</a> x y &amp; more )</tt>	return true if each arguments is smaller than or equal to the following ones
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.generic.comparison) <br> (<a href=''>=</a> x y &amp; more )</tt>	return true if all arguments are equal
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.generic.comparison) <br> (<a href=''>&gt;</a> x y &amp; more )</tt>	return true if each argument is larger than the following ones
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.generic.comparison) <br> (<a href=''>&gt;=</a> x y &amp; more )</tt>	return true if each argument is larger than or equal to the following ones
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.generic.comparison) <br> (<a href=''>max</a> x y &amp; more )</tt>	returns the greatest of its arguments
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.generic.comparison) <br> (<a href=''>min</a> x y &amp; more )</tt>	returns the least of its arguments
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.generic.comparison) <br> (<a href=''>neg?</a> x )</tt>	return true of x is negative
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.generic.comparison) <br> (<a href=''>not=</a> &amp; args )</tt>	equivalent tonot=
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.generic.comparison) <br> (<a href=''>pos?</a> x )</tt>	return true of x is positive
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.generic.comparison) <br> (<a href=''>zero?</a> x )</tt>	return true of x is zero
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.monads) <br> (<a href=''>ask</a>  )</tt>	returns the environment
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.monads) <br> (<a href=''>asks</a> f )</tt>	returns a function of the current environment
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.monads) <br> (<a href=''>call-cc</a> f )</tt>	a computation in the cont monad that calls function f with a single argument representing the current continuation
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.monads) <br> (<a href=''>cond-statement</a> expr mexpr continuation )</tt>	process a :cond steps when adding a new monadic step to the mexpr
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.monads) <br> (<a href=''>defmonad</a> name operations )</tt>	define a named monad by defining the monad operations
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.monads) <br> (<a href=''>defmonadfn</a> name docstring? attr-map? args expr ... )</tt>	like defn but for functions that use monad operations and are used inside a with-monad block
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.monads) <br> (<a href=''>fetch-state</a>  )</tt>	return a state-monad function that returns the current state and does not modify it
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.monads) <br> (<a href=''>fetch-val</a> key )</tt>	return a state-monad function that assumes the state to be a map and returns the value corresponding to the given key
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.monads) <br> (<a href=''>local</a> f g )</tt>	runs reader g in the context of an environment modified by f
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.monads) <br> (<a href=''>m-lift</a> n f )</tt>	converts a function f of n arguments into a function of n monadic arguments returning a monadic value
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.monads) <br> (<a href=''>m-when</a> test m-expr )</tt>	if test is logical true return monadic value m-expr else return m-result nil
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.monads) <br> (<a href=''>m-when-not</a> test m-expr )</tt>	if test if logical false return monadic value m-expr else return m-result nil
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.monads) <br> (<a href=''>maybe-t</a> m nothing which-m-plus )</tt>	monad transformer that transforms a monad m into a monad in which the base values can be invalidrepresented by nothing which defaults to nil
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.monads) <br> (<a href=''>monad</a> operations )</tt>	define a monad by defining the monad operations
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.monads) <br> (<a href=''>monad-transformer</a> base which-m-plus operations )</tt>	define a monad transformer in terms of the monad operations and the base monad
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.monads) <br> (<a href=''>run-cont</a> c )</tt>	execute the computation c in the cont monad and return its result
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.monads) <br> (<a href=''>sequence-t</a> m which-m-plus )</tt>	monad transformer that transforms a monad m into a monad in which the base values are sequences
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.monads) <br> (<a href=''>set-state</a> s )</tt>	return a state-monad function that replaces the current state by s and returns the previous state
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.monads) <br> (<a href=''>set-val</a> key val )</tt>	return a state-monad function that assumes the state to be a map and replaces the value associated with key by val
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.monads) <br> (<a href=''>state-m-until</a> p f x )</tt>	an optimized implementation of m-until for the state monad that replaces recursion by a loop
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.monads) <br> (<a href=''>state-t</a> m )</tt>	monad transformer that transforms a monad m into a monad of stateful computations that have the base monad type as their result
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.monads) <br> (<a href=''>update-state</a> f )</tt>	return a state-monad function that replaces the current state by the result of f applied to the current state and that returns the old state
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.monads) <br> (<a href=''>update-val</a> key f )</tt>	return a state-monad function that assumes the state to be a map and replaces the value associated with the given key by the return value of f applied to the old value
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.monads) <br> (<a href=''>with-monad</a> monad &amp; exprs )</tt>	evaluates an expression after replacing the keywords defining the monad operations by the functions associated with these keywords in the monad definition given by name
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.monads) <br> (<a href=''>with-state-field</a> key statement )</tt>	returns a state-monad function that expects a map as its state and runs statement another state-monad function on the state defined by the map entry corresponding to key
<tt style='background-color:#E8E8E8;'> (ns clojure.algo.monads) <br> (<a href=''>writer-m</a> empty-accumulator )</tt>	monad describing computations that accumulate data on the side e g
<tt style='background-color:#E8E8E8;'> (ns clojure.core.async) <br> (<a href=''>&lt;!</a> port )</tt>	takes a val from port
<tt style='background-color:#E8E8E8;'> (ns clojure.core.async) <br> (<a href=''>&lt;!!</a> port )</tt>	takes a val from port
<tt style='background-color:#E8E8E8;'> (ns clojure.core.async) <br> (<a href=''>&gt;!</a> port val )</tt>	puts a val into port
<tt style='background-color:#E8E8E8;'> (ns clojure.core.async) <br> (<a href=''>&gt;!!</a> port val )</tt>	puts a val into port
<tt style='background-color:#E8E8E8;'> (ns clojure.core.async) <br> (<a href=''>admix</a> mix ch )</tt>	adds ch as an input to the mix
<tt style='background-color:#E8E8E8;'> (ns clojure.core.async) <br> (<a href=''>alt!</a> &amp; clauses )</tt>	makes a single choice between one of several channel operations as if by alts! returning the value of the result expr corresponding to the operation completed
<tt style='background-color:#E8E8E8;'> (ns clojure.core.async) <br> (<a href=''>alt!!</a> &amp; clauses )</tt>	like alt! except as if by alts!! will block until completed and not intended for use in go blocks
<tt style='background-color:#E8E8E8;'> (ns clojure.core.async) <br> (<a href=''>buffer</a> n )</tt>	returns a fixed buffer of size n
<tt style='background-color:#E8E8E8;'> (ns clojure.core.async) <br> (<a href=''>chan</a> buf-or-n xform ex-handler )</tt>	creates a channel with an optional buffer an optional transducerlike map f filter p etc or a composition thereof) and an optional exception-handler
<tt style='background-color:#E8E8E8;'> (ns clojure.core.async) <br> (<a href=''>close!</a> chan )</tt>	closes a channel
<tt style='background-color:#E8E8E8;'> (ns clojure.core.async) <br> (<a href=''>do-alts</a> fret ports opts )</tt>	returns derefable val port if immediate nil if enqueued
<tt style='background-color:#E8E8E8;'> (ns clojure.core.async) <br> (<a href=''>dropping-buffer</a> n )</tt>	returns a buffer of size n
<tt style='background-color:#E8E8E8;'> (ns clojure.core.async) <br> (<a href=''>go</a> &amp; body )</tt>	asynchronously executes the body returning immediately to the calling thread
<tt style='background-color:#E8E8E8;'> (ns clojure.core.async) <br> (<a href=''>go-loop</a> bindings &amp; body )</tt>	likego loop
<tt style='background-color:#E8E8E8;'> (ns clojure.core.async) <br> (<a href=''>into</a> coll ch )</tt>	returns a channel containing the single collection result of the items taken from the channel conjoined to the supplied collection
<tt style='background-color:#E8E8E8;'> (ns clojure.core.async) <br> (<a href=''>map</a> f chs buf-or-n )</tt>	takes a function and a collection of source channels and returns a channel which contains the values produced by applying f to the set of first items taken from each source channel followed by applying f to the set of second items from each channel until any one of the channels is closed at which point the output channel will be closed
<tt style='background-color:#E8E8E8;'> (ns clojure.core.async) <br> (<a href=''>merge</a> chs buf-or-n )</tt>	takes a collection of source channels and returns a channel which contains all values taken from them
<tt style='background-color:#E8E8E8;'> (ns clojure.core.async) <br> (<a href=''>mix</a> out )</tt>	creates and returns a mix of one or more input channels which will be put on the supplied out channel
<tt style='background-color:#E8E8E8;'> (ns clojure.core.async) <br> (<a href=''>mult</a> ch )</tt>	creates and returns a mult iple of the supplied channel
<tt style='background-color:#E8E8E8;'> (ns clojure.core.async) <br> (<a href=''>offer!</a> port val )</tt>	puts a val into port if it's possible to do so immediately
<tt style='background-color:#E8E8E8;'> (ns clojure.core.async) <br> (<a href=''>onto-chan</a> ch coll close? )</tt>	puts the contents of coll into the supplied channel
<tt style='background-color:#E8E8E8;'> (ns clojure.core.async) <br> (<a href=''>pipe</a> from to close? )</tt>	takes elements from the from channel and supplies them to the to channel
<tt style='background-color:#E8E8E8;'> (ns clojure.core.async) <br> (<a href=''>pipeline</a> n to xf from close? ex-handler )</tt>	takes elements from the from channel and supplies them to the to channel subject to the transducer xf with parallelism n
<tt style='background-color:#E8E8E8;'> (ns clojure.core.async) <br> (<a href=''>pipeline-async</a> n to af from close? )</tt>	takes elements from the from channel and supplies them to the to channel subject to the async function af with parallelism n
<tt style='background-color:#E8E8E8;'> (ns clojure.core.async) <br> (<a href=''>pipeline-blocking</a> n to xf from close? ex-handler )</tt>	like pipeline for blocking operations
<tt style='background-color:#E8E8E8;'> (ns clojure.core.async) <br> (<a href=''>poll!</a> port )</tt>	takes a val from port if it's possible to do so immediately
<tt style='background-color:#E8E8E8;'> (ns clojure.core.async) <br> (<a href=''>promise-chan</a> xform ex-handler )</tt>	creates a promise channel with an optional transducer and an optional exception-handler
<tt style='background-color:#E8E8E8;'> (ns clojure.core.async) <br> (<a href=''>pub</a> ch topic-fn buf-fn )</tt>	creates and returns a pub lication of the supplied channel partitioned into topics by the topic-fn
<tt style='background-color:#E8E8E8;'> (ns clojure.core.async) <br> (<a href=''>put!</a> port val fn1 on-caller? )</tt>	asynchronously puts a val into port calling fn1 if supplied when complete passing false iff port is already closed
<tt style='background-color:#E8E8E8;'> (ns clojure.core.async) <br> (<a href=''>reduce</a> f init ch )</tt>	f should be a function of 2 arguments
<tt style='background-color:#E8E8E8;'> (ns clojure.core.async) <br> (<a href=''>sliding-buffer</a> n )</tt>	returns a buffer of size n
<tt style='background-color:#E8E8E8;'> (ns clojure.core.async) <br> (<a href=''>solo-mode</a> mix mode )</tt>	sets the solo mode of the mix
<tt style='background-color:#E8E8E8;'> (ns clojure.core.async) <br> (<a href=''>split</a> p ch t-buf-or-n f-buf-or-n )</tt>	takes a predicate and a source channel and returns a vector of two channels the first of which will contain the values for which the predicate returned true the second those for which it returned false
<tt style='background-color:#E8E8E8;'> (ns clojure.core.async) <br> (<a href=''>sub</a> p topic ch close? )</tt>	subscribes a channel to a topic of a pub
<tt style='background-color:#E8E8E8;'> (ns clojure.core.async) <br> (<a href=''>take</a> n ch buf-or-n )</tt>	returns a channel that will return at most n items from ch
<tt style='background-color:#E8E8E8;'> (ns clojure.core.async) <br> (<a href=''>take!</a> port fn1 on-caller? )</tt>	asynchronously takes a val from port passing to fn1
<tt style='background-color:#E8E8E8;'> (ns clojure.core.async) <br> (<a href=''>tap</a> mult ch close? )</tt>	copies the mult source onto the supplied channel
<tt style='background-color:#E8E8E8;'> (ns clojure.core.async) <br> (<a href=''>thread</a> &amp; body )</tt>	executes the body in another thread returning immediately to the calling thread
<tt style='background-color:#E8E8E8;'> (ns clojure.core.async) <br> (<a href=''>thread-call</a> f )</tt>	executes f in another thread returning immediately to the calling thread
<tt style='background-color:#E8E8E8;'> (ns clojure.core.async) <br> (<a href=''>timeout</a> msecs )</tt>	returns a channel that will close after msecs
<tt style='background-color:#E8E8E8;'> (ns clojure.core.async) <br> (<a href=''>to-chan</a> coll )</tt>	creates and returns a channel which contains the contents of coll closing when exhausted
<tt style='background-color:#E8E8E8;'> (ns clojure.core.async) <br> (<a href=''>toggle</a> mix state-map )</tt>	atomically sets the state s of one or more channels in a mix
<tt style='background-color:#E8E8E8;'> (ns clojure.core.async) <br> (<a href=''>unblocking-buffer?</a> buff )</tt>	returns true if a channel created with buff will never block
<tt style='background-color:#E8E8E8;'> (ns clojure.core.async) <br> (<a href=''>unmix</a> mix ch )</tt>	removes ch as an input to the mix
<tt style='background-color:#E8E8E8;'> (ns clojure.core.async) <br> (<a href=''>unmix-all</a> mix )</tt>	removes all inputs from the mix
<tt style='background-color:#E8E8E8;'> (ns clojure.core.async) <br> (<a href=''>unsub</a> p topic ch )</tt>	unsubscribes a channel from a topic of a pub
<tt style='background-color:#E8E8E8;'> (ns clojure.core.async) <br> (<a href=''>unsub-all</a> p topic )</tt>	unsubscribes all channels from a pub or a topic of a pub
<tt style='background-color:#E8E8E8;'> (ns clojure.core.async) <br> (<a href=''>untap</a> mult ch )</tt>	disconnects a target channel from a mult
<tt style='background-color:#E8E8E8;'> (ns clojure.core.async) <br> (<a href=''>untap-all</a> mult )</tt>	disconnects all target channels from a mult
<tt style='background-color:#E8E8E8;'> (ns clojure.core.cache) <br> (<a href=''>-&gt;BasicCache</a> cache )</tt>	positional factory function for class clojure core cache basiccache
<tt style='background-color:#E8E8E8;'> (ns clojure.core.cache) <br> (<a href=''>-&gt;FIFOCache</a> cache q limit )</tt>	positional factory function for class clojure core cache fifocache
<tt style='background-color:#E8E8E8;'> (ns clojure.core.cache) <br> (<a href=''>-&gt;FnCache</a> cache f )</tt>	positional factory function for class clojure core cache fncache
<tt style='background-color:#E8E8E8;'> (ns clojure.core.cache) <br> (<a href=''>-&gt;LIRSCache</a> cache lruS lruQ tick limitS limitQ )</tt>	positional factory function for class clojure core cache lirscache
<tt style='background-color:#E8E8E8;'> (ns clojure.core.cache) <br> (<a href=''>-&gt;LRUCache</a> cache lru tick limit )</tt>	positional factory function for class clojure core cache lrucache
<tt style='background-color:#E8E8E8;'> (ns clojure.core.cache) <br> (<a href=''>-&gt;LUCache</a> cache lu limit )</tt>	positional factory function for class clojure core cache lucache
<tt style='background-color:#E8E8E8;'> (ns clojure.core.cache) <br> (<a href=''>-&gt;SoftCache</a> cache rcache rq )</tt>	positional factory function for class clojure core cache softcache
<tt style='background-color:#E8E8E8;'> (ns clojure.core.cache) <br> (<a href=''>-&gt;TTLCache</a> cache ttl ttl-ms )</tt>	positional factory function for class clojure core cache ttlcache
<tt style='background-color:#E8E8E8;'> (ns clojure.core.cache) <br> (<a href=''>basic-cache-factory</a> base )</tt>	returns a pluggable basic cache initialied to `base`
<tt style='background-color:#E8E8E8;'> (ns clojure.core.cache) <br> (<a href=''>soft-cache-factory</a> base )</tt>	returns a softreference cache
<tt style='background-color:#E8E8E8;'> (ns clojure.core.cache) <br> (<a href=''>through</a> wrap-fn value-fn cache item )</tt>	the basic hit / miss logic for the cache system
<tt style='background-color:#E8E8E8;'> (ns clojure.core.contracts) <br> (<a href=''>provide</a> &amp; kontracts )</tt>	provides the var manipulation macro offering ex post facto application of contracts to existing functions
<tt style='background-color:#E8E8E8;'> (ns clojure.core.contracts) <br> (<a href=''>with-constraints</a> f c &amp; more )</tt>	a contract combinator
<tt style='background-color:#E8E8E8;'> (ns clojure.core.incubator) <br> (<a href=''>dissoc-in</a> m [k &amp; ks :as keys] )</tt>	dissociates an entry from a nested associative structure returning a new nested structure
<tt style='background-color:#E8E8E8;'> (ns clojure.core.incubator) <br> (<a href=''>new-by-name</a> class-name &amp; args )</tt>	constructs a java object whose class is specified by a string
<tt style='background-color:#E8E8E8;'> (ns clojure.core.incubator) <br> (<a href=''>seqable?</a> x )</tt>	returns true if seq x will succeed false otherwise
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>-&gt;AnswerCache</a> ansl anss _meta )</tt>	positional factory function for class clojure core logic answercache
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>-&gt;Choice</a> a f )</tt>	positional factory function for class clojure core logic choice
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>-&gt;ConstraintStore</a> km cm cid running )</tt>	positional factory function for class clojure core logic constraintstore
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>-&gt;LCons</a> a d cache meta )</tt>	positional factory function for class clojure core logic lcons
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>-&gt;LVar</a> id unique name oname hash meta )</tt>	positional factory function for class clojure core logic lvar
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>-&gt;PMap</a>  )</tt>	positional factory function for class clojure core logic pmap
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>-&gt;Pair</a> lhs rhs )</tt>	positional factory function for class clojure core logic pair
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>-&gt;SubstValue</a> v doms eset )</tt>	positional factory function for class clojure core logic substvalue
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>-&gt;Substitutions</a> s vs ts cs cq cqs oc _meta )</tt>	positional factory function for class clojure core logic substitutions
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>-&gt;SuspendedStream</a> cache ansv* f )</tt>	positional factory function for class clojure core logic suspendedstream
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>==</a> u v )</tt>	a goal that attempts to unify terms u and v
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>all</a> &amp; goals )</tt>	like fresh but does does not create logic variables
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>and*</a> goals )</tt>	a function version of all which takes a list of goals and succeeds only fi they all succeed
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>appendo</a> x y z )</tt>	a relation where x y and z are proper collections such that z is x appended to y
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>conde</a> &amp; clauses )</tt>	logical disjunction of the clauses
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>conjo</a> coll &amp; args )</tt>	a constraint version of conj
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>conso</a> a d l )</tt>	a relation where l is a collection such that a is the first of l and d is the rest of l
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>copy-term</a> u v )</tt>	copies a term u into v
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>defna</a> &amp; rest )</tt>	define a soft cut goal
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>defne</a> &amp; rest )</tt>	define a goal fn
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>defnu</a> &amp; rest )</tt>	define a committed choice goal
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>distincto</a> l )</tt>	a relation which guarantees no element of l will unify with another element of l
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>emptyo</a> a )</tt>	a relation where a is the empty list
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>everyg</a> g coll )</tt>	a pseudo-relation that takes a coll and ensures that the goal g succeeds on every element of the collection
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>fail</a> a )</tt>	a goal that always fails
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>featurec</a> x fs )</tt>	ensure that a map contains at least the key-value pairs in the map fs
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>firsto</a> l a )</tt>	a relation where l is a collection such that a is the first of l
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>fix-constraints</a> a )</tt>	a goal to run the constraints in cq until it is empty
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>fna</a> &amp; rest )</tt>	define an anonymous soft cut goal
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>fnc</a> args &amp; body )</tt>	define an anonymous constraint that can be used with the unifier
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>fne</a> &amp; rest )</tt>	define an anonymous goal fn
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>fnu</a> &amp; rest )</tt>	define an anonymous committed choice goal
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>fresh</a> [&amp; lvars] &amp; goals )</tt>	creates fresh variables
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>is</a> u v op )</tt>	set the value of a var to value of another var with the operation applied
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>lcons</a> a d )</tt>	constructs a sequence a with an improper tail d if d is a logic variable
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>llist</a> f s &amp; rest )</tt>	constructs a sequence from 2 or more arguments with the last argument as the tail
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>log</a> &amp; s )</tt>	goal for println
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>lvaro</a> v )</tt>	a goal that succeeds if the argument is fresh
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>map-&gt;PMap</a> m# )</tt>	factory function for class clojure core logic pmap taking a map of keywords to field values
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>map-&gt;SubstValue</a> m# )</tt>	factory function for class clojure core logic substvalue taking a map of keywords to field values
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>map-&gt;SuspendedStream</a> m# )</tt>	factory function for class clojure core logic suspendedstream taking a map of keywords to field values
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>master</a> argv cache )</tt>	take the argument to the goal and check that we don't have an alpha equivalent cached answer term in the cache
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>matcha</a> xs &amp; cs )</tt>	define a soft cut pattern match
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>matche</a> xs &amp; cs )</tt>	pattern matching macro
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>matchu</a> xs &amp; cs )</tt>	define a committed choice goal
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>member1o</a> x l )</tt>	like membero but uses to disequality further constraining the results
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>membero</a> x l )</tt>	a relation where l is a collection such that l contains x
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>nafc</a> c &amp; args )</tt>	experimental: negation as failure constraint
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>nilo</a> a )</tt>	a relation where a is nil
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>nonlvaro</a> v )</tt>	a goal that succeeds if the argument is not fresh
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>or*</a> goals )</tt>	a function version of conde which takes a list of goals and tries them as if via conde
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>partial-map</a> m )</tt>	given map m returns partial map that unifies with maps even if it doesn't share all of the keys of that map
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>permuteo</a> xl yl )</tt>	a relation that will permute xl into the yl
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>pred</a> v f )</tt>	check a predicate against the value logic var
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>project</a> [&amp; vars] &amp; goals )</tt>	extract the values bound to the specified logic vars
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>rembero</a> x l o )</tt>	a relation between l and o where x is removed from l exactly one time
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>resto</a> l d )</tt>	a relation where l is a collection such that d is the rest of l
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>run</a> n bindings &amp; goals )</tt>	executes goals until a maximum of n results are found
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>run*</a> bindings &amp; goals )</tt>	executes goals until results are exhausted
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>run-db</a> n db bindings &amp; goals )</tt>	executes goals until a maximum of n results are found
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>run-db*</a> db bindings &amp; goals )</tt>	executes goals until results are exhausted
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>run-nc</a> n bindings &amp; goals )</tt>	executes goals until a maximum of n results are found
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>run-nc*</a> &amp; goals )</tt>	executes goals until results are exhausted
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>succeed</a> a )</tt>	a goal that always succeeds
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>tabled</a> args &amp; grest )</tt>	macro for defining a tabled goal
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>trace-lvars</a> title &amp; lvars )</tt>	goal for tracing the values of logic variables
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>trace-s</a>  )</tt>	goal that prints the current substitution
<tt style='background-color:#E8E8E8;'> (ns clojure.core.logic) <br> (<a href=''>waiting-stream-check</a> w success-cont failure-cont )</tt>	take a waiting stream a success continuation and a failure continuation
<tt style='background-color:#E8E8E8;'> (ns clojure.core.match) <br> (<a href=''>-&gt;AppPattern</a> p form _meta )</tt>	positional factory function for class clojure core match apppattern
<tt style='background-color:#E8E8E8;'> (ns clojure.core.match) <br> (<a href=''>-&gt;BindNode</a> bindings node )</tt>	positional factory function for class clojure core match bindnode
<tt style='background-color:#E8E8E8;'> (ns clojure.core.match) <br> (<a href=''>-&gt;FailNode</a>  )</tt>	positional factory function for class clojure core match failnode
<tt style='background-color:#E8E8E8;'> (ns clojure.core.match) <br> (<a href=''>-&gt;GuardPattern</a> p gs _meta )</tt>	positional factory function for class clojure core match guardpattern
<tt style='background-color:#E8E8E8;'> (ns clojure.core.match) <br> (<a href=''>-&gt;LeafNode</a> value bindings )</tt>	positional factory function for class clojure core match leafnode
<tt style='background-color:#E8E8E8;'> (ns clojure.core.match) <br> (<a href=''>-&gt;LiteralPattern</a> l _meta )</tt>	positional factory function for class clojure core match literalpattern
<tt style='background-color:#E8E8E8;'> (ns clojure.core.match) <br> (<a href=''>-&gt;MapKeyPattern</a> p )</tt>	positional factory function for class clojure core match mapkeypattern
<tt style='background-color:#E8E8E8;'> (ns clojure.core.match) <br> (<a href=''>-&gt;MapPattern</a> m _meta )</tt>	positional factory function for class clojure core match mappattern
<tt style='background-color:#E8E8E8;'> (ns clojure.core.match) <br> (<a href=''>-&gt;OrPattern</a> ps _meta )</tt>	positional factory function for class clojure core match orpattern
<tt style='background-color:#E8E8E8;'> (ns clojure.core.match) <br> (<a href=''>-&gt;PatternMatrix</a> rows ocrs )</tt>	positional factory function for class clojure core match patternmatrix
<tt style='background-color:#E8E8E8;'> (ns clojure.core.match) <br> (<a href=''>-&gt;PatternRow</a> ps action bindings )</tt>	positional factory function for class clojure core match patternrow
<tt style='background-color:#E8E8E8;'> (ns clojure.core.match) <br> (<a href=''>-&gt;PredicatePattern</a> p gs _meta )</tt>	positional factory function for class clojure core match predicatepattern
<tt style='background-color:#E8E8E8;'> (ns clojure.core.match) <br> (<a href=''>-&gt;RestPattern</a> p )</tt>	positional factory function for class clojure core match restpattern
<tt style='background-color:#E8E8E8;'> (ns clojure.core.match) <br> (<a href=''>-&gt;SeqPattern</a> s _meta )</tt>	positional factory function for class clojure core match seqpattern
<tt style='background-color:#E8E8E8;'> (ns clojure.core.match) <br> (<a href=''>-&gt;SwitchNode</a> occurrence cases default )</tt>	positional factory function for class clojure core match switchnode
<tt style='background-color:#E8E8E8;'> (ns clojure.core.match) <br> (<a href=''>-&gt;VectorPattern</a> v t size offset rest? _meta )</tt>	positional factory function for class clojure core match vectorpattern
<tt style='background-color:#E8E8E8;'> (ns clojure.core.match) <br> (<a href=''>-&gt;WildcardPattern</a> sym named _meta )</tt>	positional factory function for class clojure core match wildcardpattern
<tt style='background-color:#E8E8E8;'> (ns clojure.core.match) <br> (<a href=''>emit-matrix</a> vars clauses default )</tt>	take the list of vars and sequence of unprocessed clauses and return the pattern matrix
<tt style='background-color:#E8E8E8;'> (ns clojure.core.match) <br> (<a href=''>empty-rows-case</a>  )</tt>	case 1: if there are no pattern rows to match then matching always fails
<tt style='background-color:#E8E8E8;'> (ns clojure.core.match) <br> (<a href=''>first-column-chosen-case</a> matrix col ocrs )</tt>	case 3a: the first column is chosen
<tt style='background-color:#E8E8E8;'> (ns clojure.core.match) <br> (<a href=''>first-row-empty-case</a> rows ocr )</tt>	case 2: if the first row is empty then matching always succeeds and yields the first action
<tt style='background-color:#E8E8E8;'> (ns clojure.core.match) <br> (<a href=''>first-row-wildcards-case</a> rows ocrs )</tt>	case 2: if the first row is constituted by wildcards then matching matching always succeeds and yields the first action
<tt style='background-color:#E8E8E8;'> (ns clojure.core.match) <br> (<a href=''>group-keywords</a> pattern )</tt>	returns a pattern with pattern-keywords:when and :as) properly grouped
<tt style='background-color:#E8E8E8;'> (ns clojure.core.match) <br> (<a href=''>map-&gt;BindNode</a> m# )</tt>	factory function for class clojure core match bindnode taking a map of keywords to field values
<tt style='background-color:#E8E8E8;'> (ns clojure.core.match) <br> (<a href=''>map-&gt;FailNode</a> m# )</tt>	factory function for class clojure core match failnode taking a map of keywords to field values
<tt style='background-color:#E8E8E8;'> (ns clojure.core.match) <br> (<a href=''>map-&gt;LeafNode</a> m# )</tt>	factory function for class clojure core match leafnode taking a map of keywords to field values
<tt style='background-color:#E8E8E8;'> (ns clojure.core.match) <br> (<a href=''>map-&gt;MapKeyPattern</a> m# )</tt>	factory function for class clojure core match mapkeypattern taking a map of keywords to field values
<tt style='background-color:#E8E8E8;'> (ns clojure.core.match) <br> (<a href=''>map-&gt;PatternMatrix</a> m# )</tt>	factory function for class clojure core match patternmatrix taking a map of keywords to field values
<tt style='background-color:#E8E8E8;'> (ns clojure.core.match) <br> (<a href=''>map-&gt;RestPattern</a> m# )</tt>	factory function for class clojure core match restpattern taking a map of keywords to field values
<tt style='background-color:#E8E8E8;'> (ns clojure.core.match) <br> (<a href=''>map-&gt;SwitchNode</a> m# )</tt>	factory function for class clojure core match switchnode taking a map of keywords to field values
<tt style='background-color:#E8E8E8;'> (ns clojure.core.match) <br> (<a href=''>match</a> vars &amp; clauses )</tt>	pattern match a row of occurrences
<tt style='background-color:#E8E8E8;'> (ns clojure.core.match) <br> (<a href=''>other-column-chosen-case</a> matrix col )</tt>	case 3b: a column other than the first is chosen
<tt style='background-color:#E8E8E8;'> (ns clojure.core.match) <br> (<a href=''>process-vars</a> vars )</tt>	process the vars for the pattern matrix
<tt style='background-color:#E8E8E8;'> (ns clojure.core.match) <br> (<a href=''>to-pattern-row</a> pat action )</tt>	take an unprocessed pattern expression and an action expression and return a pattern row of the processed pattern expression plus the action epxression
<tt style='background-color:#E8E8E8;'> (ns clojure.core.match) <br> (<a href=''>wildcards-and-duplicates</a> patterns )</tt>	returns a vector of two elements: the set of all wildcards and the set of duplicate wildcards
<tt style='background-color:#E8E8E8;'> (ns clojure.core.memoize) <br> (<a href=''>-&gt;PluggableMemoization</a> f cache )</tt>	positional factory function for class clojure core memoize pluggablememoization
<tt style='background-color:#E8E8E8;'> (ns clojure.core.memoize) <br> (<a href=''>-&gt;RetryingDelay</a> fun available? value )</tt>	positional factory function for class clojure core memoize retryingdelay
<tt style='background-color:#E8E8E8;'> (ns clojure.core.memoize) <br> (<a href=''>build-memoizer</a> cache-factory f &amp; args )</tt>	builds a function that given a function returns a pluggable memoized version of it
<tt style='background-color:#E8E8E8;'> (ns clojure.core.memoize) <br> (<a href=''>fifo</a> f base key threshold )</tt>	works the same as the basic memoization functioni e
<tt style='background-color:#E8E8E8;'> (ns clojure.core.memoize) <br> (<a href=''>lru</a> f base key threshold )</tt>	works the same as the basic memoization functioni e
<tt style='background-color:#E8E8E8;'> (ns clojure.core.memoize) <br> (<a href=''>lu</a> f base key threshold )</tt>	similar to the implementation of memo-lru except that this function removes all cache values whose usage value is smallest
<tt style='background-color:#E8E8E8;'> (ns clojure.core.memoize) <br> (<a href=''>memo</a> f seed )</tt>	used as a more flexible alternative to clojure's core `memoization` function
<tt style='background-color:#E8E8E8;'> (ns clojure.core.memoize) <br> (<a href=''>memo-clear!</a> f args )</tt>	reaches into an core memo-memoized function and clears the cache
<tt style='background-color:#E8E8E8;'> (ns clojure.core.memoize) <br> (<a href=''>memo-swap!</a> f base )</tt>	takes a core memo-populated function and a map and replaces the memoization cache with the supplied map
<tt style='background-color:#E8E8E8;'> (ns clojure.core.memoize) <br> (<a href=''>memoized?</a> f )</tt>	returns true if a function has an core memo-placed cache false otherwise
<tt style='background-color:#E8E8E8;'> (ns clojure.core.memoize) <br> (<a href=''>snapshot</a> memoized-fn )</tt>	returns a snapshot of a core memo-placed memoization cache
<tt style='background-color:#E8E8E8;'> (ns clojure.core.memoize) <br> (<a href=''>ttl</a> f base key threshold )</tt>	unlike many of the other core memo memoization functions `memo-ttl`'s cache policy is time-based rather than algortihmic or explicit
<tt style='background-color:#E8E8E8;'> (ns clojure.core.rrb-vector) <br> (<a href=''>catvec</a> v1 v2 v3 v4 &amp; vn )</tt>	concatenates the given vectors in logarithmic time
<tt style='background-color:#E8E8E8;'> (ns clojure.core.rrb-vector) <br> (<a href=''>subvec</a> v start end )</tt>	returns a new vector containing the elements of the given vector v lying between the start inclusive and end exclusive indices in logarithmic time
<tt style='background-color:#E8E8E8;'> (ns clojure.core.rrb-vector) <br> (<a href=''>vec</a> coll )</tt>	returns a vector containing the contents of coll
<tt style='background-color:#E8E8E8;'> (ns clojure.core.rrb-vector) <br> (<a href=''>vector</a> x1 x2 x3 x4 &amp; xn )</tt>	creates a new vector containing the args
<tt style='background-color:#E8E8E8;'> (ns clojure.core.rrb-vector) <br> (<a href=''>vector-of</a> t x1 x2 x3 x4 &amp; xn )</tt>	creates a new vector capable of storing homogenous items of type t which should be one of :object :int :long :float :double :byte :short :char :boolean
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>ASeq</a> t )</tt>	a sequential seq returned from clojure core / seq
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>AVec</a> t )</tt>	a persistent vector returned from clojure core / vector and others
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>Agent1</a> t )</tt>	an agent that can read and write type x
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>Agent2</a> t t )</tt>	an agent that can write type w and read type r
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>All</a> binder type )</tt>	a polymorphic binder
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>Assoc</a> type type-pairs* )</tt>	a type representing an assoc operation
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>Atom1</a> t )</tt>	an atom that can read and write type x
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>Atom2</a> t )</tt>	an atom that can write type w and read type r
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>BlockingDeref</a> t )</tt>	a clojure blocking derefablesee clojure core / deref
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>Coll</a> t )</tt>	a persistent collection with member type x
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>CountRange</a> Integer Integer )</tt>	a type representing a range of counts for a collection
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>Delay</a> t )</tt>	a clojure delaysee clojure core / delay force
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>Deref</a> t )</tt>	a clojure derefablesee clojure core / deref
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>Difference</a> type type type* )</tt>	difference represents a difference of types
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>Dissoc</a> type type* )</tt>	a type representing a dissoc operation
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>EmptySeqable</a> t )</tt>	a type that can be used to create a sequence of member type x with count 0
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>ExactCount</a> Integer )</tt>	a type representing a precise count for a collection
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>Future</a> t )</tt>	a clojure future
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>Get</a> type type type )</tt>	a type representing a get operation
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>HSeq</a> [fixed* drest ... bound] :filter-sets [FS*] :objects [obj*] )</tt>	hseq is a type for heterogeneous seqs
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>HSequential</a> [fixed* drest ... bound] :filter-sets [FS*] :objects [obj*] )</tt>	hsequential is a type for heterogeneous sequential collections
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>quote</a> [fixed* type ... bound] )</tt>	hvec is a type for heterogeneous vectors
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>I</a> type* )</tt>	i represents an intersection of types
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>IFn</a> ArityVec+ )</tt>	an ordered intersection type of function arities
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>List</a> t )</tt>	a clojure persistent list
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>Map</a> t t )</tt>	a persistent map with keys k and vals v
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>Nilable</a> t )</tt>	a union of x and nil
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>NilableNonEmptyASeq</a> t )</tt>	the result of clojure core / seq
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>NilableNonEmptySeq</a> t )</tt>	a persistent sequence of member type x with count greater than 0 or nil
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>NonEmptyASeq</a> t )</tt>	a sequential non-empty seq retured from clojure core / seq
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>NonEmptyAVec</a> t )</tt>	a persistent vector returned from clojure core / vector and others and count greater than 0
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>NonEmptyColl</a> t )</tt>	a persistent collection with member type x and count greater than 0
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>NonEmptyLazySeq</a> t )</tt>	a non-empty lazy sequence of type t
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>NonEmptySeq</a> t )</tt>	a persistent sequence of member type x with count greater than 0
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>NonEmptySeqable</a> t )</tt>	a type that can be used to create a sequence of member type x with count greater than 0
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>NonEmptyVec</a> t )</tt>	a persistent vector with member type x and count greater than 0
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>Option</a> t )</tt>	a union of x and nil
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>Pred</a> type )</tt>	a predicate for the given type
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>Promise</a> t )</tt>	a clojure promisesee clojure core / promise deliver
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>Rec</a> binder type )</tt>	a recursive type
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>Ref1</a> t )</tt>	a ref that can read and write type x
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>Ref2</a> w r )</tt>	a ref that can write type w and read type r
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>Reversible</a> t )</tt>	a clojure reversible collection
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>Seq</a> t )</tt>	a persistent sequence of member type x
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>Seqable</a> t )</tt>	a type that can be used to create a sequence of member type x
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>SequentialSeq</a> t )</tt>	a clojure sequential sequence
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>SequentialSeqable</a> t )</tt>	a sequential seqable collection
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>Set</a> t )</tt>	a persistent set with member type x
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>SortedSet</a> t )</tt>	a sorted persistent set with member type x
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>Stack</a> t )</tt>	a clojure stack
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>TFn</a> binder type )</tt>	a type function
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>U</a> type* )</tt>	u represents a union of types
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>quote</a> Constant )</tt>	a singleton type for a constant value
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>Var1</a> t )</tt>	an var that can read and write type x
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>Var2</a> w r )</tt>	an var that can write type w and read type r
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>Vec</a> t )</tt>	a persistent vector with member type x
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>ann</a> varsym typesyn )</tt>	annotate varsym with type
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>ann-datatype</a> binder dname [field :- type*] opts* )</tt>	annotate datatype class name dname with expected fields
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>ann-form</a> form ty )</tt>	annotate a form with an expected type
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>ann-interface</a> varsym &amp; methods )</tt>	annotate a possibly polymorphic interface created with definterface with method types
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>ann-many</a> t &amp; vs )</tt>	annotate several vars with type t
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>ann-protocol</a> varsym &amp; methods )</tt>	annotate a possibly polymorphic protocol var with method types
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>ann-record</a> binder dname [field :- type*] opts* )</tt>	annotate record class name dname with expected fields
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>atom</a> &amp; args )</tt>	like atom but with optional type annotations
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>cast</a> t x opt )</tt>	cast a value to a type
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>cf</a> form expected )</tt>	takes a form and an optional expected type and returns a human-readable inferred type for that form
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>check-form*</a> form expected type-provided? )</tt>	takes a quoted form and optional expected type syntax and type checks the form
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>check-form-info</a> form &amp; opt )</tt>	type checks a quoted form and returns a map of results from type checking the form
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>check-ns</a> ns-or-syms &amp; opt )</tt>	type check a namespace / sa symbol or namespace or collection
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>declare-alias-kind</a> sym ty )</tt>	declare a kind for an alias similar to declare but on the kind level
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>declare-datatypes</a> &amp; syms )</tt>	declare datatypes similar to declare but on the type level
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>declare-names</a> &amp; syms )</tt>	declare names similar to declare but on the type level
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>declare-protocols</a> &amp; syms )</tt>	declare protocols similar to declare but on the type level
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>def</a> name docstring? :- type? expr )</tt>	like clojure core / def with optional type annotations nb: in clojure it is impossible to refer a var called `def` as it is a special form
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>defalias</a> sym t )</tt>	define a recursive type alias
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>defn</a> kw-args? name docstring? attr-map? [param :- type *] :- type exprs* )</tt>	like defn but expands to clojure core typed / fn
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>defprotocol</a> &amp; body )</tt>	like defprotocol but with optional type annotations
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>doseq</a> seq-exprs &amp; body )</tt>	like clojure core / doseq with optional annotations
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>dotimes</a> bindings &amp; body )</tt>	like clojure core / dotimes but with optional annotations
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>envs</a>  )</tt>	returns a map of type environments according to the current state of the type checker
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>fn</a> name? [param :- type* &amp; param :- type * ?] :- type? exprs* )</tt>	like clojure core / fn but with optional annotations
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>for</a> seq-exprs &amp; maybe-ann-body-expr )</tt>	like clojure core / for with optional type annotations
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>inst</a> inst-of &amp; types )</tt>	instantiate a polymorphic type with a number of types
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>inst-ctor</a> inst-of &amp; types )</tt>	instantiate a call to a constructor with a number of types
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>install</a> features )</tt>	install the :core typed :lang
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>into-array&gt;</a> into-array-syn javat cljt coll )</tt>	make a java array with java class javat and typed clojure type cljt
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>let</a> [binding :- type? init*] exprs* )</tt>	like clojure core / let but supports optional type annotations
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>letfn&gt;</a> [fn-spec-or-annotation*] expr* )</tt>	like letfn but each function spec must be annotated
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>load-if-needed</a>  )</tt>	load and initialize all of core typed if not already
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>loop</a> [binding :- type? init*] exprs* )</tt>	like clojure core / loop and supports optional type annotations
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>method-type</a> mname )</tt>	given a method symbol print the core typed types assigned to it
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>nilable-param</a> msym mmap )</tt>	override which parameters in qualified method msym may accept nilable values
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>non-nil-return</a> msym arities )</tt>	override the return type of fully qualified method msym to be non-nil
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>override-constructor</a> ctorsym typesyn )</tt>	override all constructors for class ctorsym with type
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>override-method</a> methodsym typesyn )</tt>	override type for qualified method methodsym
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>pfn&gt;</a> &amp; forms )</tt>	define a polymorphic typed anonymous function
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>pred</a> t )</tt>	generate a flat runtime predicate for type that returns true if the argument is a subtype of the type otherwise false
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>print-env</a> debug-str )</tt>	during type checking print the type environment to *out* preceeded by literal string debug-str
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>print-filterset</a> debug-string frm )</tt>	during type checking print the filter set attached to form preceeded by literal string debug-string
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>ref</a> &amp; args )</tt>	like ref but with optional type annotations
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>reset-caches</a>  )</tt>	reset internal type caches
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>statistics</a> nsyms )</tt>	takes a collection of namespace symbols and returns a map mapping the namespace symbols to a map of data
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>tc-ignore</a> &amp; body )</tt>	ignore forms in body during type checking
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>typed-deps</a> &amp; args )</tt>	declare namespaces which should be checked before the current namespace
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>untyped-var</a> varsym typesyn )</tt>	check a given var has the specified type at runtime
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>var-coverage</a> nsyms-or-nsym )</tt>	summarises annotated var coverage statistics to *out* for namespaces nsyms a collection of symbols or a symbol / namespace
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>var&gt;</a> sym )</tt>	like var but resolves at runtime like ns-resolve and is understood by the type checker
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>warn-on-unannotated-vars</a>  )</tt>	allow unannotated vars in the current namespace
<tt style='background-color:#E8E8E8;'> (ns clojure.core.typed) <br> (<a href=''>when-let-fail</a> b &amp; body )</tt>	like when-let but fails if the binding yields a false value
<tt style='background-color:#E8E8E8;'> (ns clojure.core.unify) <br> (<a href=''>extract-lvars</a> lv-fn form )</tt>	takes a datastructure and returns a distinct set of the logical variables found within
<tt style='background-color:#E8E8E8;'> (ns clojure.core.unify) <br> (<a href=''>flatten-bindings</a> variable? binds )</tt>	flattens recursive bindings in the given map to the same ground if possible
<tt style='background-color:#E8E8E8;'> (ns clojure.core.unify) <br> (<a href=''>make-occurs-subst-fn</a> variable-fn )</tt>	given a function to recognize unification variables returns a function that will attempt to substitute unification bindings between two expressions
<tt style='background-color:#E8E8E8;'> (ns clojure.core.unify) <br> (<a href=''>make-occurs-unifier-fn</a> variable-fn )</tt>	given a function to recognize unification variables returns a function to perform the unification of two expressions
<tt style='background-color:#E8E8E8;'> (ns clojure.core.unify) <br> (<a href=''>make-occurs-unify-fn</a> variable-fn )</tt>	given a function to recognize unification variables returns a function to return a bindings map for two expressions
<tt style='background-color:#E8E8E8;'> (ns clojure.core.unify) <br> (<a href=''>make-subst-fn</a> variable-fn )</tt>	given a function to recognize unification variables returns a function that will attempt to substitute unification bindings between two expressions
<tt style='background-color:#E8E8E8;'> (ns clojure.core.unify) <br> (<a href=''>make-unifier-fn</a> variable-fn )</tt>	given a function to recognize unification variables returns a function to perform the unification of two expressions
<tt style='background-color:#E8E8E8;'> (ns clojure.core.unify) <br> (<a href=''>make-unify-fn</a> variable-fn )</tt>	given a function to recognize unification variables returns a function to return a bindings map for two expressions
<tt style='background-color:#E8E8E8;'> (ns clojure.core.unify) <br> (<a href=''>subst</a> expression bindings )</tt>	attempts to substitute the bindings in the appropriate locations in the given expression
<tt style='background-color:#E8E8E8;'> (ns clojure.core.unify) <br> (<a href=''>unifier-</a> expression1 expression2 )</tt>	attempts the entire unification process from garnering the bindings to substituting the appropriate bindings
<tt style='background-color:#E8E8E8;'> (ns clojure.core.unify) <br> (<a href=''>unify-</a> expression1 expression2 )</tt>	attempt to unify x and y with the given bindings if any
<tt style='background-color:#E8E8E8;'> (ns clojure.data.avl) <br> (<a href=''>merge</a> m1 m2 m3 &amp; more )</tt>	merges the given avl maps which should all use the same comparator
<tt style='background-color:#E8E8E8;'> (ns clojure.data.avl) <br> (<a href=''>merge-with</a> f m1 m2 m3 &amp; more )</tt>	merges the given avl maps which should all use the same comparator
<tt style='background-color:#E8E8E8;'> (ns clojure.data.avl) <br> (<a href=''>nearest</a> coll test x )</tt>	where subseq* is clojure core / subseq for test in # > > = and clojure core / rsubseq for test in # < < =
<tt style='background-color:#E8E8E8;'> (ns clojure.data.avl) <br> (<a href=''>rank-of</a> coll x )</tt>	returns the rank of x in coll or -1 if not present
<tt style='background-color:#E8E8E8;'> (ns clojure.data.avl) <br> (<a href=''>sorted-map</a> &amp; keyvals )</tt>	keyval = > key val returns a new avl map with supplied mappings
<tt style='background-color:#E8E8E8;'> (ns clojure.data.avl) <br> (<a href=''>sorted-map-by</a> comparator &amp; keyvals )</tt>	keyval = > key val returns a new sorted map with supplied mappings using the supplied comparator
<tt style='background-color:#E8E8E8;'> (ns clojure.data.avl) <br> (<a href=''>sorted-set</a> &amp; keys )</tt>	returns a new sorted set with supplied keys
<tt style='background-color:#E8E8E8;'> (ns clojure.data.avl) <br> (<a href=''>sorted-set-by</a> comparator &amp; keys )</tt>	returns a new sorted set with supplied keys using the supplied comparator
<tt style='background-color:#E8E8E8;'> (ns clojure.data.avl) <br> (<a href=''>split-key</a> k coll )</tt>	returns [left e? right] where left and right are collections of the same type as coll and containing respectively the keys below and above k in the ordering determined by coll's comparator while e? is the entry at key k for maps the stored copy of the key k for sets nil if coll does not contain k
<tt style='background-color:#E8E8E8;'> (ns clojure.data.avl) <br> (<a href=''>subrange</a> coll start-test start end-test end )</tt>	in logarithmic time
<tt style='background-color:#E8E8E8;'> (ns clojure.data.avl) <br> (<a href=''>union</a> s1 s2 s3 &amp; more )</tt>	computes the union of the given avl sets which should all use the same comparator
<tt style='background-color:#E8E8E8;'> (ns clojure.data.avl) <br> (<a href=''>unsafe-join</a> coll1 coll2 coll3 &amp; more )</tt>	attn: this function does not validate its inputs and will return malformed results if the inputs do not satisfy the contract
<tt style='background-color:#E8E8E8;'> (ns clojure.data.codec.base64) <br> (<a href=''>dec-length</a> in-length pad-length )</tt>	calculates what would be the length after decoding of an input array of length in-length with the specified padding length
<tt style='background-color:#E8E8E8;'> (ns clojure.data.codec.base64) <br> (<a href=''>decode</a> input offset length )</tt>	returns a base64 decoded byte array
<tt style='background-color:#E8E8E8;'> (ns clojure.data.codec.base64) <br> (<a href=''>decode!</a> input offset length output )</tt>	reads from the input byte array for the specified length starting at the offset index and base64 decodes into the output array starting at index 0
<tt style='background-color:#E8E8E8;'> (ns clojure.data.codec.base64) <br> (<a href=''>decoding-transfer</a> input-stream output-stream &amp; opts )</tt>	base64 decodes from input-stream to output-stream
<tt style='background-color:#E8E8E8;'> (ns clojure.data.codec.base64) <br> (<a href=''>enc-length</a> n )</tt>	calculates what would be the length after encoding of an input array of length n
<tt style='background-color:#E8E8E8;'> (ns clojure.data.codec.base64) <br> (<a href=''>encode</a> input offset length )</tt>	returns a base64 encoded byte array
<tt style='background-color:#E8E8E8;'> (ns clojure.data.codec.base64) <br> (<a href=''>encode!</a> input offset length output )</tt>	reads from the input byte array for the specified length starting at the offset index and base64 encodes into the output array starting at index 0
<tt style='background-color:#E8E8E8;'> (ns clojure.data.codec.base64) <br> (<a href=''>encoding-transfer</a> input-stream output-stream &amp; opts )</tt>	base64 encodes from input-stream to output-stream
<tt style='background-color:#E8E8E8;'> (ns clojure.data.codec.base64) <br> (<a href=''>pad-length</a> input offset length )</tt>	returns the length of padding on the end of the input array
<tt style='background-color:#E8E8E8;'> (ns clojure.data.csv) <br> (<a href=''>read-csv</a> input &amp; options )</tt>	reads csv-data from input string or java io reader into a lazy sequence of vectors
<tt style='background-color:#E8E8E8;'> (ns clojure.data.csv) <br> (<a href=''>write-csv</a> writer data &amp; options )</tt>	writes data to writer in csv-format
<tt style='background-color:#E8E8E8;'> (ns clojure.data.finger-tree) <br> (<a href=''>-&gt;CountedDoubleList</a> tree mdata )</tt>	positional factory function for class clojure data finger_tree counteddoublelist
<tt style='background-color:#E8E8E8;'> (ns clojure.data.finger-tree) <br> (<a href=''>-&gt;CountedSortedSet</a> cmpr tree mdata )</tt>	positional factory function for class clojure data finger_tree countedsortedset
<tt style='background-color:#E8E8E8;'> (ns clojure.data.finger-tree) <br> (<a href=''>-&gt;DeepTree</a> meter-obj pre mid suf mval )</tt>	positional factory function for class clojure data finger_tree deeptree
<tt style='background-color:#E8E8E8;'> (ns clojure.data.finger-tree) <br> (<a href=''>-&gt;DelayedTree</a> tree-ref mval )</tt>	positional factory function for class clojure data finger_tree delayedtree
<tt style='background-color:#E8E8E8;'> (ns clojure.data.finger-tree) <br> (<a href=''>-&gt;Digit1</a> a meter-obj measure-ref )</tt>	positional factory function for class clojure data finger_tree digit1
<tt style='background-color:#E8E8E8;'> (ns clojure.data.finger-tree) <br> (<a href=''>-&gt;Digit2</a> a b meter-obj measure-ref )</tt>	positional factory function for class clojure data finger_tree digit2
<tt style='background-color:#E8E8E8;'> (ns clojure.data.finger-tree) <br> (<a href=''>-&gt;Digit3</a> a b c meter-obj measure-ref )</tt>	positional factory function for class clojure data finger_tree digit3
<tt style='background-color:#E8E8E8;'> (ns clojure.data.finger-tree) <br> (<a href=''>-&gt;Digit4</a> a b c d meter-obj measure-ref )</tt>	positional factory function for class clojure data finger_tree digit4
<tt style='background-color:#E8E8E8;'> (ns clojure.data.finger-tree) <br> (<a href=''>-&gt;DoubleList</a> tree mdata )</tt>	positional factory function for class clojure data finger_tree doublelist
<tt style='background-color:#E8E8E8;'> (ns clojure.data.finger-tree) <br> (<a href=''>-&gt;EmptyTree</a> meter-obj )</tt>	positional factory function for class clojure data finger_tree emptytree
<tt style='background-color:#E8E8E8;'> (ns clojure.data.finger-tree) <br> (<a href=''>-&gt;Len-Right-Meter</a> len right )</tt>	positional factory function for class clojure data finger_tree len-right-meter
<tt style='background-color:#E8E8E8;'> (ns clojure.data.finger-tree) <br> (<a href=''>-&gt;SingleTree</a> meter-obj x )</tt>	positional factory function for class clojure data finger_tree singletree
<tt style='background-color:#E8E8E8;'> (ns clojure.data.finger-tree) <br> (<a href=''>map-&gt;Len-Right-Meter</a> m# )</tt>	factory function for class clojure data finger_tree len-right-meter taking a map of keywords to field values
<tt style='background-color:#E8E8E8;'> (ns clojure.data.fressian) <br> (<a href=''>associative-lookup</a> o )</tt>	build an ilookup from an associative collection
<tt style='background-color:#E8E8E8;'> (ns clojure.data.fressian) <br> (<a href=''>begin-closed-list</a> writer )</tt>	begin writing a fressianed list
<tt style='background-color:#E8E8E8;'> (ns clojure.data.fressian) <br> (<a href=''>end-list</a> writer )</tt>	ends a list begun with begin-closed-list
<tt style='background-color:#E8E8E8;'> (ns clojure.data.fressian) <br> (<a href=''>field-caching-writer</a> cache-pred )</tt>	returns a record writer that caches values for keys matching cache-pred which is typically specified as a set e g
<tt style='background-color:#E8E8E8;'> (ns clojure.data.fressian) <br> (<a href=''>inheritance-lookup</a> lookup )</tt>	returns an inheritance aware lookup based on lookup that will match subclasses as well as exact matches
<tt style='background-color:#E8E8E8;'> (ns clojure.data.fressian) <br> (<a href=''>read</a> readable &amp; options )</tt>	convenience method for reading a single fressian object
<tt style='background-color:#E8E8E8;'> (ns clojure.data.fressian) <br> (<a href=''>read-object</a> rdr )</tt>	read a single object from a fressian reader
<tt style='background-color:#E8E8E8;'> (ns clojure.data.fressian) <br> (<a href=''>tag</a> obj )</tt>	returns the tag if object is a tagged-object else nil
<tt style='background-color:#E8E8E8;'> (ns clojure.data.fressian) <br> (<a href=''>tagged-object?</a> o )</tt>	returns true if o is a tagged object which will occur when the reader does not recognized a specific type
<tt style='background-color:#E8E8E8;'> (ns clojure.data.fressian) <br> (<a href=''>tagged-value</a> obj )</tt>	returns the value an object arrray wrapped by obj or nil if obj is not a tagged object
<tt style='background-color:#E8E8E8;'> (ns clojure.data.fressian) <br> (<a href=''>write</a> obj &amp; options )</tt>	convenience method for writing a single object
<tt style='background-color:#E8E8E8;'> (ns clojure.data.fressian) <br> (<a href=''>write-object</a> writer obj )</tt>	write a single object to a fressian reader
<tt style='background-color:#E8E8E8;'> (ns clojure.data.generators) <br> (<a href=''>anything</a>  )</tt>	returns a scalar or collection based on *rnd*
<tt style='background-color:#E8E8E8;'> (ns clojure.data.generators) <br> (<a href=''>boolean</a>  )</tt>	returns a bool based on *rnd*
<tt style='background-color:#E8E8E8;'> (ns clojure.data.generators) <br> (<a href=''>boolean-array</a> f sizer )</tt>	create an array with elements from f and sized from sizer
<tt style='background-color:#E8E8E8;'> (ns clojure.data.generators) <br> (<a href=''>byte</a>  )</tt>	returns a long based on *rnd* in the byte range
<tt style='background-color:#E8E8E8;'> (ns clojure.data.generators) <br> (<a href=''>byte-array</a> f sizer )</tt>	create an array with elements from f and sized from sizer
<tt style='background-color:#E8E8E8;'> (ns clojure.data.generators) <br> (<a href=''>char</a>  )</tt>	returns a character based on *rnd* in the range 0-65536
<tt style='background-color:#E8E8E8;'> (ns clojure.data.generators) <br> (<a href=''>char-array</a> f sizer )</tt>	create an array with elements from f and sized from sizer
<tt style='background-color:#E8E8E8;'> (ns clojure.data.generators) <br> (<a href=''>collection</a>  )</tt>	returns a collection of scalar elements based on *rnd*
<tt style='background-color:#E8E8E8;'> (ns clojure.data.generators) <br> (<a href=''>date</a> base )</tt>	create a date with geometric mean around base which defaults to #inst "2007-10-16t00:00:00 000-00:00"
<tt style='background-color:#E8E8E8;'> (ns clojure.data.generators) <br> (<a href=''>default-sizer</a>  )</tt>	default sizer used to run tests
<tt style='background-color:#E8E8E8;'> (ns clojure.data.generators) <br> (<a href=''>double</a>  )</tt>	generate a double between 0 and 1 based on *rnd*
<tt style='background-color:#E8E8E8;'> (ns clojure.data.generators) <br> (<a href=''>double-array</a> f sizer )</tt>	create an array with elements from f and sized from sizer
<tt style='background-color:#E8E8E8;'> (ns clojure.data.generators) <br> (<a href=''>float</a>  )</tt>	generate a float between 0 and 1 based on *rnd*
<tt style='background-color:#E8E8E8;'> (ns clojure.data.generators) <br> (<a href=''>float-array</a> f sizer )</tt>	create an array with elements from f and sized from sizer
<tt style='background-color:#E8E8E8;'> (ns clojure.data.generators) <br> (<a href=''>geometric</a> p )</tt>	geometric distribution with mean 1 / p
<tt style='background-color:#E8E8E8;'> (ns clojure.data.generators) <br> (<a href=''>hash-map</a> fk fv sizer )</tt>	create a hash-map with keys from fk vals from fv and sized from sizer
<tt style='background-color:#E8E8E8;'> (ns clojure.data.generators) <br> (<a href=''>int</a>  )</tt>	returns a int based on *rnd* in the int range
<tt style='background-color:#E8E8E8;'> (ns clojure.data.generators) <br> (<a href=''>int-array</a> f sizer )</tt>	create an array with elements from f and sized from sizer
<tt style='background-color:#E8E8E8;'> (ns clojure.data.generators) <br> (<a href=''>keyword</a> sizer )</tt>	create a non-namespaced keyword sized from sizer
<tt style='background-color:#E8E8E8;'> (ns clojure.data.generators) <br> (<a href=''>list</a> f sizer )</tt>	create a list with elements from f and sized from sizer
<tt style='background-color:#E8E8E8;'> (ns clojure.data.generators) <br> (<a href=''>long-array</a> f sizer )</tt>	create an array with elements from f and sized from sizer
<tt style='background-color:#E8E8E8;'> (ns clojure.data.generators) <br> (<a href=''>one-of</a> &amp; specs )</tt>	generates one of the specs passed in with equal probability
<tt style='background-color:#E8E8E8;'> (ns clojure.data.generators) <br> (<a href=''>printable-ascii-char</a>  )</tt>	returns a char based on *rnd* in the printable ascii range
<tt style='background-color:#E8E8E8;'> (ns clojure.data.generators) <br> (<a href=''>rand-nth</a> coll )</tt>	replacement of core / rand-nth that allows control of the randomization basisthrough binding *rnd*
<tt style='background-color:#E8E8E8;'> (ns clojure.data.generators) <br> (<a href=''>ratio</a> num-gen denom-gen )</tt>	generate a ratio with numerator and denominator uniform longs or as specified
<tt style='background-color:#E8E8E8;'> (ns clojure.data.generators) <br> (<a href=''>reps</a> sizer f )</tt>	returns sizer repetitions of for f if f is a fn
<tt style='background-color:#E8E8E8;'> (ns clojure.data.generators) <br> (<a href=''>reservoir-sample</a> ct coll )</tt>	reservoir sample ct items from coll using *rnd*
<tt style='background-color:#E8E8E8;'> (ns clojure.data.generators) <br> (<a href=''>scalar</a>  )</tt>	returns a scalar based on *rnd*
<tt style='background-color:#E8E8E8;'> (ns clojure.data.generators) <br> (<a href=''>set</a> f sizer )</tt>	create a set with elements from f and sized from sizer
<tt style='background-color:#E8E8E8;'> (ns clojure.data.generators) <br> (<a href=''>short</a>  )</tt>	returns a short based on *rnd* in the short range
<tt style='background-color:#E8E8E8;'> (ns clojure.data.generators) <br> (<a href=''>short-array</a> f sizer )</tt>	create an array with elements from f and sized from sizer
<tt style='background-color:#E8E8E8;'> (ns clojure.data.generators) <br> (<a href=''>shuffle</a> coll )</tt>	shuffle coll based on *rnd*
<tt style='background-color:#E8E8E8;'> (ns clojure.data.generators) <br> (<a href=''>string</a> f sizer )</tt>	create a string with chars from f and sized from sizer
<tt style='background-color:#E8E8E8;'> (ns clojure.data.generators) <br> (<a href=''>symbol</a> sizer )</tt>	create a non-namespaced symbol sized from sizer
<tt style='background-color:#E8E8E8;'> (ns clojure.data.generators) <br> (<a href=''>tuple</a> &amp; generators )</tt>	generate a tuple with one element from each generator
<tt style='background-color:#E8E8E8;'> (ns clojure.data.generators) <br> (<a href=''>uniform</a> lo hi )</tt>	uniform distribution from lo inclusive to hi exclusive
<tt style='background-color:#E8E8E8;'> (ns clojure.data.generators) <br> (<a href=''>uuid</a>  )</tt>	create a uuid based on uniform distribution of low and high parts
<tt style='background-color:#E8E8E8;'> (ns clojure.data.generators) <br> (<a href=''>vec</a> f sizer )</tt>	create a vec with elements from f and sized from sizer
<tt style='background-color:#E8E8E8;'> (ns clojure.data.generators) <br> (<a href=''>weighted</a> m )</tt>	given a map of generators and weights return a value from one of the generators selecting generator based on weights
<tt style='background-color:#E8E8E8;'> (ns clojure.data.json) <br> (<a href=''>json-str</a> x &amp; options )</tt>	converts x to a json-formatted string
<tt style='background-color:#E8E8E8;'> (ns clojure.data.json) <br> (<a href=''>pprint</a> x &amp; options )</tt>	pretty-prints json representation of x to *out*
<tt style='background-color:#E8E8E8;'> (ns clojure.data.json) <br> (<a href=''>pprint-json</a> x &amp; options )</tt>	pretty-prints json representation of x to *out*
<tt style='background-color:#E8E8E8;'> (ns clojure.data.json) <br> (<a href=''>print-json</a> x &amp; options )</tt>	write json-formatted output to *out*
<tt style='background-color:#E8E8E8;'> (ns clojure.data.json) <br> (<a href=''>read</a> reader &amp; options )</tt>	reads a single item of json data from a java io reader
<tt style='background-color:#E8E8E8;'> (ns clojure.data.json) <br> (<a href=''>read-json</a> input keywordize? eof-error? eof-value )</tt>	reads one json value from input string or reader
<tt style='background-color:#E8E8E8;'> (ns clojure.data.json) <br> (<a href=''>read-str</a> string &amp; options )</tt>	reads one json value from input string
<tt style='background-color:#E8E8E8;'> (ns clojure.data.json) <br> (<a href=''>write</a> x writer &amp; options )</tt>	write json-formatted output to a java io writer
<tt style='background-color:#E8E8E8;'> (ns clojure.data.json) <br> (<a href=''>write-json</a> x out escape-unicode? )</tt>	print object to printwriter out as json
<tt style='background-color:#E8E8E8;'> (ns clojure.data.json) <br> (<a href=''>write-str</a> x &amp; options )</tt>	converts x to a json-formatted string
<tt style='background-color:#E8E8E8;'> (ns clojure.data.priority-map) <br> (<a href=''>-&gt;PersistentPriorityMap</a> priority-&gt;set-of-items item-&gt;priority _meta keyfn )</tt>	positional factory function for class clojure data priority_map persistentprioritymap
<tt style='background-color:#E8E8E8;'> (ns clojure.data.priority-map) <br> (<a href=''>priority-map</a> &amp; keyvals )</tt>	usage: priority-map key val key val returns a new priority map with optional supplied mappings
<tt style='background-color:#E8E8E8;'> (ns clojure.data.priority-map) <br> (<a href=''>priority-map-by</a> comparator &amp; keyvals )</tt>	usage: priority-map comparator key val key val returns a new priority map with custom comparator and optional supplied mappings
<tt style='background-color:#E8E8E8;'> (ns clojure.data.priority-map) <br> (<a href=''>priority-map-keyfn</a> keyfn &amp; keyvals )</tt>	usage: priority-map-keyfn keyfn key val key val returns a new priority map with custom keyfn and optional supplied mappings
<tt style='background-color:#E8E8E8;'> (ns clojure.data.priority-map) <br> (<a href=''>priority-map-keyfn-by</a> keyfn comparator &amp; keyvals )</tt>	usage: priority-map-keyfn-by keyfn comparator key val key val returns a new priority map with custom keyfn custom comparator and optional supplied mappings
<tt style='background-color:#E8E8E8;'> (ns clojure.data.zip) <br> (<a href=''>ancestors</a> loc )</tt>	returns a lazy sequence of all ancestors of location loc starting with loc and proceeding to loc's parent node and on through to the root of the tree
<tt style='background-color:#E8E8E8;'> (ns clojure.data.zip) <br> (<a href=''>children</a> loc )</tt>	returns a lazy sequence of all immediate children of location loc left-to-right
<tt style='background-color:#E8E8E8;'> (ns clojure.data.zip) <br> (<a href=''>children-auto</a> loc )</tt>	returns a lazy sequence of all immediate children of location loc left-to-right marked so that a following tag= predicate will auto-descend
<tt style='background-color:#E8E8E8;'> (ns clojure.data.zip) <br> (<a href=''>descendants</a> loc )</tt>	returns a lazy sequence of all descendants of location loc in depth-first order left-to-right starting with loc
<tt style='background-color:#E8E8E8;'> (ns clojure.data.zip) <br> (<a href=''>left-locs</a> loc )</tt>	returns a lazy sequence of locations to the left of loc starting with loc
<tt style='background-color:#E8E8E8;'> (ns clojure.data.zip) <br> (<a href=''>leftmost?</a> loc )</tt>	returns true if there are no more nodes to the left of location loc
<tt style='background-color:#E8E8E8;'> (ns clojure.data.zip) <br> (<a href=''>right-locs</a> loc )</tt>	returns a lazy sequence of locations to the right of loc starting with loc
<tt style='background-color:#E8E8E8;'> (ns clojure.data.zip) <br> (<a href=''>rightmost?</a> loc )</tt>	returns true if there are no more nodes to the right of location loc
<tt style='background-color:#E8E8E8;'> (ns clojure.java.classpath) <br> (<a href=''>classpath</a>  )</tt>	returns a sequence of file objects of the elements on the classpath
<tt style='background-color:#E8E8E8;'> (ns clojure.java.classpath) <br> (<a href=''>classpath-directories</a>  )</tt>	returns a sequence of file objects for the directories on classpath
<tt style='background-color:#E8E8E8;'> (ns clojure.java.classpath) <br> (<a href=''>classpath-jarfiles</a>  )</tt>	returns a sequence of jarfile objects for the jar files on classpath
<tt style='background-color:#E8E8E8;'> (ns clojure.java.classpath) <br> (<a href=''>filenames-in-jar</a> jar-file )</tt>	returns a sequence of strings naming the non-directory entries in the jar file
<tt style='background-color:#E8E8E8;'> (ns clojure.java.classpath) <br> (<a href=''>get-urls</a> loader )</tt>	returns a sequence of java net url objects used by this classloader or nil if the classloader does not sastify the urlclasspath protocol
<tt style='background-color:#E8E8E8;'> (ns clojure.java.classpath) <br> (<a href=''>jar-file?</a> f )</tt>	returns true if file is a normal file with a jar or jar extension
<tt style='background-color:#E8E8E8;'> (ns clojure.java.classpath) <br> (<a href=''>loader-classpath</a> loader )</tt>	returns a sequence of file paths from a classloader
<tt style='background-color:#E8E8E8;'> (ns clojure.java.classpath) <br> (<a href=''>system-classpath</a>  )</tt>	returns a sequence of file paths from the 'java class path' system property
<tt style='background-color:#E8E8E8;'> (ns clojure.java.jdbc) <br> (<a href=''>as-sql-name</a> f x )</tt>	given a naming strategy function and a keyword or string return a string per that naming strategy
<tt style='background-color:#E8E8E8;'> (ns clojure.java.jdbc) <br> (<a href=''>create-table-ddl</a> table &amp; specs )</tt>	given a table name and column specs with an optional table-spec return the ddl string for creating that table
<tt style='background-color:#E8E8E8;'> (ns clojure.java.jdbc) <br> (<a href=''>db-connection</a> db )</tt>	returns the current database connection or throws if there is none
<tt style='background-color:#E8E8E8;'> (ns clojure.java.jdbc) <br> (<a href=''>db-do-commands</a> db-spec transaction? sql-command &amp; sql-commands )</tt>	executes sql commands on the specified database connection
<tt style='background-color:#E8E8E8;'> (ns clojure.java.jdbc) <br> (<a href=''>db-do-prepared</a> db-spec transaction? sql &amp; param-groups )</tt>	executes an optionally parameterized sql prepared statement on the open database connection
<tt style='background-color:#E8E8E8;'> (ns clojure.java.jdbc) <br> (<a href=''>db-do-prepared-return-keys</a> db transaction? sql param-group )</tt>	executes an optionally parameterized sql prepared statement on the open database connection
<tt style='background-color:#E8E8E8;'> (ns clojure.java.jdbc) <br> (<a href=''>db-find-connection</a> db )</tt>	returns the current database connection or nil if there is none
<tt style='background-color:#E8E8E8;'> (ns clojure.java.jdbc) <br> (<a href=''>db-is-rollback-only</a> db )</tt>	returns true if the outermost transaction will rollback rather than commit when complete
<tt style='background-color:#E8E8E8;'> (ns clojure.java.jdbc) <br> (<a href=''>db-query-with-resultset</a> db-spec [options-map sql-string &amp; params] func )</tt>	executes a query then evaluates func passing in the raw resultset as an argument
<tt style='background-color:#E8E8E8;'> (ns clojure.java.jdbc) <br> (<a href=''>db-set-rollback-only!</a> db )</tt>	marks the outermost transaction such that it will rollback rather than commit when complete
<tt style='background-color:#E8E8E8;'> (ns clojure.java.jdbc) <br> (<a href=''>db-transaction</a> binding &amp; body )</tt>	original name for with-db-transaction
<tt style='background-color:#E8E8E8;'> (ns clojure.java.jdbc) <br> (<a href=''>db-unset-rollback-only!</a> db )</tt>	marks the outermost transaction such that it will not rollback when complete
<tt style='background-color:#E8E8E8;'> (ns clojure.java.jdbc) <br> (<a href=''>execute!</a> db-spec [sql &amp; param-groups] :multi? true :transaction? true )</tt>	given a database connection and a vector containing sql and optional parameters perform a general non-select sql operation
<tt style='background-color:#E8E8E8;'> (ns clojure.java.jdbc) <br> (<a href=''>insert!</a> db-spec table row-map :transaction? true :entities identity )</tt>	given a database connection a table name and either maps representing rows or a list of column names followed by lists of column values perform an insert
<tt style='background-color:#E8E8E8;'> (ns clojure.java.jdbc) <br> (<a href=''>metadata-query</a> meta-query &amp; opt-args )</tt>	given a java expression that extracts metadata in the context of with-db-metadata and additional optional arguments like metadata-result manage the connection for a single metadata-based query
<tt style='background-color:#E8E8E8;'> (ns clojure.java.jdbc) <br> (<a href=''>print-sql-exception</a> exception )</tt>	prints the contents of an sqlexception to *out*
<tt style='background-color:#E8E8E8;'> (ns clojure.java.jdbc) <br> (<a href=''>print-sql-exception-chain</a> exception )</tt>	prints a chain of sqlexceptions to *out*
<tt style='background-color:#E8E8E8;'> (ns clojure.java.jdbc) <br> (<a href=''>print-update-counts</a> exception )</tt>	prints the update counts from a batchupdateexception to *out*
<tt style='background-color:#E8E8E8;'> (ns clojure.java.jdbc) <br> (<a href=''>query</a> db-spec [option-map sql-string &amp; params] )</tt>	given a database connection and a vector containing sql and optional parameters perform a simple database query
<tt style='background-color:#E8E8E8;'> (ns clojure.java.jdbc) <br> (<a href=''>quoted</a> q x )</tt>	with a single argument returns a naming strategy function that quotes names
<tt style='background-color:#E8E8E8;'> (ns clojure.java.jdbc) <br> (<a href=''>with-db-connection</a> binding &amp; body )</tt>	evaluates body in the context of an active connection to the database
<tt style='background-color:#E8E8E8;'> (ns clojure.java.jdbc) <br> (<a href=''>with-db-metadata</a> binding &amp; body )</tt>	evaluates body in the context of an active connection with metadata bound to the specified name
<tt style='background-color:#E8E8E8;'> (ns clojure.java.jdbc) <br> (<a href=''>with-db-transaction</a> binding &amp; body )</tt>	evaluates body in the context of a transaction on the specified database connection
<tt style='background-color:#E8E8E8;'> (ns clojure.java.jmx) <br> (<a href=''>-&gt;Bean</a> state-ref )</tt>	positional factory function for class clojure java jmx bean
<tt style='background-color:#E8E8E8;'> (ns clojure.java.jmx) <br> (<a href=''>attribute-names</a> n )</tt>	all attribute names available on an mbean
<tt style='background-color:#E8E8E8;'> (ns clojure.java.jmx) <br> (<a href=''>create-bean</a> state-ref )</tt>	expose a reference as a jmx bean
<tt style='background-color:#E8E8E8;'> (ns clojure.java.jmx) <br> (<a href=''>invoke</a> n op &amp; args )</tt>	invoke an operation an an mbean
<tt style='background-color:#E8E8E8;'> (ns clojure.java.jmx) <br> (<a href=''>invoke-signature</a> n op signature &amp; args )</tt>	invoke an operation an an mbean
<tt style='background-color:#E8E8E8;'> (ns clojure.java.jmx) <br> (<a href=''>mbean</a> n )</tt>	like clojure core / bean but for jmx beans
<tt style='background-color:#E8E8E8;'> (ns clojure.java.jmx) <br> (<a href=''>mbean-names</a> n )</tt>	finds all mbeans matching a name on the current *connection*
<tt style='background-color:#E8E8E8;'> (ns clojure.java.jmx) <br> (<a href=''>operation-names</a> n )</tt>	all operation names available on an mbean
<tt style='background-color:#E8E8E8;'> (ns clojure.java.jmx) <br> (<a href=''>readable?</a> n attr )</tt>	is attribute readable?
<tt style='background-color:#E8E8E8;'> (ns clojure.java.jmx) <br> (<a href=''>register-mbean</a> mbean mbean-name )</tt>	register an mbean with the current *connection*
<tt style='background-color:#E8E8E8;'> (ns clojure.java.jmx) <br> (<a href=''>unregister-mbean</a> mbean-name )</tt>	unregister mbean named mbean-name with the current *connection*
<tt style='background-color:#E8E8E8;'> (ns clojure.java.jmx) <br> (<a href=''>with-connection</a> opts &amp; body )</tt>	execute body with a jmx connection created based on opts
<tt style='background-color:#E8E8E8;'> (ns clojure.java.jmx) <br> (<a href=''>write!</a> n attr value )</tt>	write an attribute value
<tt style='background-color:#E8E8E8;'> (ns clojure.math.combinatorics) <br> (<a href=''>assert-with-message</a> x message )</tt>	clojure 1 2 didn't allow asserts with a message so we roll our own here for backwards compatibility
<tt style='background-color:#E8E8E8;'> (ns clojure.math.combinatorics) <br> (<a href=''>cartesian-product</a> &amp; seqs )</tt>	all the ways to take one item from each sequence
<tt style='background-color:#E8E8E8;'> (ns clojure.math.combinatorics) <br> (<a href=''>combinations</a> items t )</tt>	all the unique ways of taking t different elements from items
<tt style='background-color:#E8E8E8;'> (ns clojure.math.combinatorics) <br> (<a href=''>count-combinations</a> items t )</tt>	but computed more directly
<tt style='background-color:#E8E8E8;'> (ns clojure.math.combinatorics) <br> (<a href=''>count-permutations</a> l )</tt>	counts the number of distinct permutations of l
<tt style='background-color:#E8E8E8;'> (ns clojure.math.combinatorics) <br> (<a href=''>count-subsets</a> items )</tt>	but computed more directly
<tt style='background-color:#E8E8E8;'> (ns clojure.math.combinatorics) <br> (<a href=''>drop-permutations</a> items n )</tt>	but calculated more directly
<tt style='background-color:#E8E8E8;'> (ns clojure.math.combinatorics) <br> (<a href=''>nth-combination</a> items t n )</tt>	the nth element of the sequence of t-combinations of items
<tt style='background-color:#E8E8E8;'> (ns clojure.math.combinatorics) <br> (<a href=''>nth-permutation</a> items n )</tt>	but calculated more directly
<tt style='background-color:#E8E8E8;'> (ns clojure.math.combinatorics) <br> (<a href=''>partitions</a> items &amp; args )</tt>	all the lexicographic distinct partitions of items
<tt style='background-color:#E8E8E8;'> (ns clojure.math.combinatorics) <br> (<a href=''>permutation-index</a> items )</tt>	input must be a sortable collection of items
<tt style='background-color:#E8E8E8;'> (ns clojure.math.combinatorics) <br> (<a href=''>permutations</a> items )</tt>	all the distinct permutations of items lexicographic by index special handling for duplicate items
<tt style='background-color:#E8E8E8;'> (ns clojure.math.combinatorics) <br> (<a href=''>selections</a> items n )</tt>	all the ways of taking n possibly the same elements from the sequence of items
<tt style='background-color:#E8E8E8;'> (ns clojure.math.combinatorics) <br> (<a href=''>subsets</a> items )</tt>	all the subsets of items
<tt style='background-color:#E8E8E8;'> (ns clojure.math.numeric-tower) <br> (<a href=''>abs</a> n )</tt>	is the absolute value of n
<tt style='background-color:#E8E8E8;'> (ns clojure.math.numeric-tower) <br> (<a href=''>expt</a> base pow )</tt>	is base to the pow power
<tt style='background-color:#E8E8E8;'> (ns clojure.math.numeric-tower) <br> (<a href=''>gcd</a> a b )</tt>	returns the greatest common divisor of a and b
<tt style='background-color:#E8E8E8;'> (ns clojure.math.numeric-tower) <br> (<a href=''>lcm</a> a b )</tt>	returns the least common multiple of a and b
<tt style='background-color:#E8E8E8;'> (ns clojure.test.generative) <br> (<a href=''>defspec</a> name fn-to-test args &amp; validator-body )</tt>	defines a function named name that expects args
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.logging) <br> (<a href=''>debug</a> throwable message &amp; more )</tt>	debug level logging using print-style args
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.logging) <br> (<a href=''>debugf</a> throwable fmt &amp; fmt-args )</tt>	debug level logging using format
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.logging) <br> (<a href=''>enabled?</a> level logger-ns )</tt>	returns true if the specific logging level is enabled
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.logging) <br> (<a href=''>error</a> throwable message &amp; more )</tt>	error level logging using print-style args
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.logging) <br> (<a href=''>errorf</a> throwable fmt &amp; fmt-args )</tt>	error level logging using format
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.logging) <br> (<a href=''>fatal</a> throwable message &amp; more )</tt>	fatal level logging using print-style args
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.logging) <br> (<a href=''>fatalf</a> throwable fmt &amp; fmt-args )</tt>	fatal level logging using format
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.logging) <br> (<a href=''>info</a> throwable message &amp; more )</tt>	info level logging using print-style args
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.logging) <br> (<a href=''>infof</a> throwable fmt &amp; fmt-args )</tt>	info level logging using format
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.logging) <br> (<a href=''>log</a> logger-factory logger-ns level throwable message )</tt>	evaluates and logs a message only if the specified level is enabled
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.logging) <br> (<a href=''>log*</a> logger level throwable message )</tt>	attempts to log a message either directly or via an agent; does not check if the level is enabled
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.logging) <br> (<a href=''>log-capture!</a> logger-ns out-level err-level )</tt>	captures system out and system err piping all writes of those streams to the log
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.logging) <br> (<a href=''>log-stream</a> level logger-ns )</tt>	creates a printstream that will output to the log at the specified level
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.logging) <br> (<a href=''>log-uncapture!</a>  )</tt>	restores system out and system err to their original values
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.logging) <br> (<a href=''>logf</a> level throwable fmt &amp; fmt-args )</tt>	logs a message using a format string and args
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.logging) <br> (<a href=''>logp</a> level throwable message &amp; more )</tt>	logs a message using print style args
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.logging) <br> (<a href=''>spy</a> level expr )</tt>	evaluates expr and may write the form and its result to the log
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.logging) <br> (<a href=''>spyf</a> level fmt expr )</tt>	evaluates expr and may write format fmt result to the log
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.logging) <br> (<a href=''>trace</a> throwable message &amp; more )</tt>	trace level logging using print-style args
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.logging) <br> (<a href=''>tracef</a> throwable fmt &amp; fmt-args )</tt>	trace level logging using format
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.logging) <br> (<a href=''>warn</a> throwable message &amp; more )</tt>	warn level logging using print-style args
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.logging) <br> (<a href=''>warnf</a> throwable fmt &amp; fmt-args )</tt>	warn level logging using format
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.logging) <br> (<a href=''>with-logs</a> [logger-ns out-level err-level] &amp; body )</tt>	evaluates exprs in a context in which *out* and *err* write to the log
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.analyzer) <br> (<a href=''>-&gt;Const</a> literal? val meta type op form env children )</tt>	positional factory function for class clojure tools analyzer const
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.analyzer) <br> (<a href=''>-&gt;Local</a> assignable? name op form env )</tt>	positional factory function for class clojure tools analyzer local
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.analyzer) <br> (<a href=''>-&gt;Map</a> keys vals op form env children )</tt>	positional factory function for class clojure tools analyzer map
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.analyzer) <br> (<a href=''>-&gt;MaybeClass</a> class op form env )</tt>	positional factory function for class clojure tools analyzer maybeclass
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.analyzer) <br> (<a href=''>-&gt;MaybeHostForm</a> class field op form env )</tt>	positional factory function for class clojure tools analyzer maybehostform
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.analyzer) <br> (<a href=''>-&gt;Set</a> items op form env children )</tt>	positional factory function for class clojure tools analyzer set
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.analyzer) <br> (<a href=''>-&gt;TransientConst</a> literal? val meta type op form env children extmap )</tt>	positional factory function for class clojure tools analyzer transientconst
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.analyzer) <br> (<a href=''>-&gt;TransientLocal</a> assignable? name op form env extmap )</tt>	positional factory function for class clojure tools analyzer transientlocal
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.analyzer) <br> (<a href=''>-&gt;TransientMap</a> keys vals op form env children extmap )</tt>	positional factory function for class clojure tools analyzer transientmap
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.analyzer) <br> (<a href=''>-&gt;TransientMaybeClass</a> class op form env extmap )</tt>	positional factory function for class clojure tools analyzer transientmaybeclass
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.analyzer) <br> (<a href=''>-&gt;TransientMaybeHostForm</a> class field op form env extmap )</tt>	positional factory function for class clojure tools analyzer transientmaybehostform
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.analyzer) <br> (<a href=''>-&gt;TransientSet</a> items op form env children extmap )</tt>	positional factory function for class clojure tools analyzer transientset
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.analyzer) <br> (<a href=''>-&gt;TransientVar</a> assignable? var meta op form env extmap )</tt>	positional factory function for class clojure tools analyzer transientvar
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.analyzer) <br> (<a href=''>-&gt;TransientVector</a> items op form env children extmap )</tt>	positional factory function for class clojure tools analyzer transientvector
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.analyzer) <br> (<a href=''>-&gt;TransientWithMeta</a> meta expr op form env children extmap )</tt>	positional factory function for class clojure tools analyzer transientwithmeta
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.analyzer) <br> (<a href=''>-&gt;Var</a> assignable? var meta op form env )</tt>	positional factory function for class clojure tools analyzer var
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.analyzer) <br> (<a href=''>-&gt;Vector</a> items op form env children )</tt>	positional factory function for class clojure tools analyzer vector
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.analyzer) <br> (<a href=''>-&gt;WithMeta</a> meta expr op form env children )</tt>	positional factory function for class clojure tools analyzer withmeta
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.analyzer) <br> (<a href=''>analyze</a> form env )</tt>	given a form to analyze and an environment a map containing: * :locals a map from binding symbol to ast of the binding value * :context a keyword describing the form's context from the :ctx / * hierarchy
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.analyzer) <br> (<a href=''>analyze-in-env</a> env )</tt>	takes an env map and returns a function that analyzes a form in that env
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.analyzer) <br> (<a href=''>create-var</a> sym env )</tt>	creates a var for sym and returns it
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.analyzer) <br> (<a href=''>empty-env</a>  )</tt>	returns an empty env
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.analyzer) <br> (<a href=''>macroexpand</a> form env )</tt>	repeatedly calls macroexpand-1 on form until it no longer represents a macro form then returns it
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.analyzer) <br> (<a href=''>macroexpand-1</a> form env )</tt>	if form represents a macro form returns its expansion else returns form
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.analyzer) <br> (<a href=''>map-&gt;Const</a> m# )</tt>	factory function for class clojure tools analyzer const taking a map of keywords to field values
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.analyzer) <br> (<a href=''>map-&gt;Local</a> m# )</tt>	factory function for class clojure tools analyzer local taking a map of keywords to field values
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.analyzer) <br> (<a href=''>map-&gt;Map</a> m# )</tt>	factory function for class clojure tools analyzer map taking a map of keywords to field values
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.analyzer) <br> (<a href=''>map-&gt;MaybeClass</a> m# )</tt>	factory function for class clojure tools analyzer maybeclass taking a map of keywords to field values
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.analyzer) <br> (<a href=''>map-&gt;MaybeHostForm</a> m# )</tt>	factory function for class clojure tools analyzer maybehostform taking a map of keywords to field values
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.analyzer) <br> (<a href=''>map-&gt;Set</a> m# )</tt>	factory function for class clojure tools analyzer set taking a map of keywords to field values
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.analyzer) <br> (<a href=''>map-&gt;Var</a> m# )</tt>	factory function for class clojure tools analyzer var taking a map of keywords to field values
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.analyzer) <br> (<a href=''>map-&gt;Vector</a> m# )</tt>	factory function for class clojure tools analyzer vector taking a map of keywords to field values
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.analyzer) <br> (<a href=''>map-&gt;WithMeta</a> m# )</tt>	factory function for class clojure tools analyzer withmeta taking a map of keywords to field values
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.analyzer) <br> (<a href=''>parse</a> [op &amp; args] env )</tt>	multimethod that dispatches on op should default to -parse
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.analyzer) <br> (<a href=''>var?</a> obj )</tt>	returns true if obj represent a var form as returned by create-var
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.analyzer.jvm) <br> (<a href=''>-&gt;ExceptionThrown</a> e )</tt>	positional factory function for class clojure tools analyzer jvm exceptionthrown
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.analyzer.jvm) <br> (<a href=''>analyze</a> form env opts )</tt>	analyzes a clojure form using tools analyzer augmented with the jvm specific special ops and returns its ast after running #'run-passes on it
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.analyzer.jvm) <br> (<a href=''>analyze+eval</a> form env opts )</tt>	like analyze but evals the form after the analysis and attaches the returned value in the :result field of the ast node
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.analyzer.jvm) <br> (<a href=''>analyze-ns</a> ns env opts )</tt>	analyzes a whole namespace returns a vector of the asts for all the top-level asts of that namespace
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.analyzer.jvm) <br> (<a href=''>empty-env</a>  )</tt>	returns an empty env map
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.analyzer.jvm) <br> (<a href=''>macroexpand-1</a> form env )</tt>	if form represents a macro form or an inlineable function returns its expansion else returns form
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.analyzer.jvm) <br> (<a href=''>macroexpand-all</a> form env opts )</tt>	like clojure walk / macroexpand-all but correctly handles lexical scope
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.analyzer.jvm) <br> (<a href=''>parse</a> form env )</tt>	extension to tools analyzer / -parse for jvm special forms
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.analyzer.jvm) <br> (<a href=''>run-passes</a> ast )</tt>	function that will be invoked on the ast tree immediately after it has been constructed by default runs the passes declared in #'default-passes should be rebound if a different set of passes is required
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.cli) <br> (<a href=''>get-default-options</a> option-specs )</tt>	extract the map of default options from a sequence of option vectors
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.cli) <br> (<a href=''>parse-opts</a> args option-specs &amp; options )</tt>	parse arguments sequence according to given option specifications and the gnu program argument syntax conventions
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.cli) <br> (<a href=''>summarize</a> specs )</tt>	reduce options specs into a options summary for printing at a terminal
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.emitter.jvm) <br> (<a href=''>eval</a> form )</tt>	form is a read clojure s expression represented as a list
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.emitter.jvm) <br> (<a href=''>load</a> res )</tt>	resource is a string identifier for a clojure resource on the classpath
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.macro) <br> (<a href=''>defsymbolmacro</a> symbol expansion )</tt>	define a symbol macro
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.macro) <br> (<a href=''>deftemplate</a> name params &amp; forms )</tt>	define a macro that expands into forms after replacing the symbols in params a vector by the corresponding parameters given in the macro call
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.macro) <br> (<a href=''>macrolet</a> fn-bindings &amp; exprs )</tt>	define local macros that are used in the expansion of exprs
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.macro) <br> (<a href=''>mexpand</a> form )</tt>	like clojure core / macroexpand but takes into account symbol macros
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.macro) <br> (<a href=''>mexpand-1</a> form )</tt>	like clojure core / macroexpand-1 but takes into account symbol macros
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.macro) <br> (<a href=''>mexpand-all</a> form )</tt>	perform a full recursive macro expansion of a form
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.macro) <br> (<a href=''>name-with-attributes</a> name macro-args )</tt>	to be used in macro definitions
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.macro) <br> (<a href=''>symbol-macrolet</a> symbol-bindings &amp; exprs )</tt>	define local symbol macros that are used in the expansion of exprs
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.macro) <br> (<a href=''>with-symbol-macros</a> &amp; exprs )</tt>	fully expand exprs including symbol macros
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.namespace) <br> (<a href=''>clojure-source-file?</a> file )</tt>	returns true if file is a normal file with a .clj or .cljc extension.
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.namespace) <br> (<a href=''>clojure-sources-in-jar</a> jar-file )</tt>	returns a sequence of filenames ending in .clj or .cljc found in the jar file.
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.namespace) <br> (<a href=''>comment?</a> form )</tt>	returns true if form is a comment ...
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.namespace) <br> (<a href=''>find-clojure-sources-in-dir</a> dir )</tt>	searches recursively under dir for clojure source files
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.namespace) <br> (<a href=''>find-namespaces-in-dir</a> dir )</tt>	searches dir recursively for ns ... declarations in clojure source files; returns the symbol names of the declared namespaces.
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.namespace) <br> (<a href=''>find-namespaces-in-jarfile</a> jarfile )</tt>	searches the jar file for clojure source files containing ns ... declarations
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.namespace) <br> (<a href=''>find-namespaces-on-classpath</a>  )</tt>	source files containing ns ... declarations
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.namespace) <br> (<a href=''>find-ns-decls-in-dir</a> dir )</tt>	searches dir recursively for ns ... declarations in clojure source files; returns the unevaluated ns declarations.
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.namespace) <br> (<a href=''>find-ns-decls-in-jarfile</a> jarfile )</tt>	searches the jar file for clojure source files containing ns ... declarations; returns the unevaluated ns declarations.
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.namespace) <br> (<a href=''>find-ns-decls-on-classpath</a>  )</tt>	source files containing ns ... declarations
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.namespace) <br> (<a href=''>ns-decl?</a> form )</tt>	returns true if form is a ns ... declaration.
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.namespace) <br> (<a href=''>read-file-ns-decl</a> file )</tt>	attempts to read a ns ... declaration from file and returns the unevaluated form
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.namespace) <br> (<a href=''>read-ns-decl</a> rdr )</tt>	attempts to read a ns ... declaration from rdr and returns the unevaluated form
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.namespace) <br> (<a href=''>read-ns-decl-from-jarfile-entry</a> jarfile entry-name )</tt>	attempts to read a ns ... declaration from the named entry in the jar file and returns the unevaluated form
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.nrepl) <br> (<a href=''>client</a> transport response-timeout )</tt>	returns a fn of zero and one argument both of which return the current head of a single response-seq being read off of the given client-side transport
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.nrepl) <br> (<a href=''>code</a> &amp; body )</tt>	expands into a string consisting of the macro's body's formsliterally no interpolation / quasiquoting of locals or other references) suitable for use in an :eval message e g
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.nrepl) <br> (<a href=''>code*</a> &amp; expressions )</tt>	returns a single string containing the pr-str'd representations of the given expressions
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.nrepl) <br> (<a href=''>combine-responses</a> responses )</tt>	combines the provided seq of response messages into a single response map
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.nrepl) <br> (<a href=''>response-seq</a> transport timeout )</tt>	returns a lazy seq of messages received via the given transport
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.nrepl) <br> (<a href=''>response-values</a> responses )</tt>	given a seq of responses as from response-seq or returned from any function returned by client or client-session returns a seq of values read from :value slots found therein
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.reader) <br> (<a href=''>map-func</a> coll )</tt>	decide which map type to use array-map if less than 16 elements
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.reader) <br> (<a href=''>read</a> reader eof-error? eof-value )</tt>	reads the first object from an ipushbackreader or a java io pushbackreader
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.reader) <br> (<a href=''>read-string</a> opts s )</tt>	reads one object from the string s
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.reader) <br> (<a href=''>resolve-symbol</a> s )</tt>	resolve a symbol s into its fully qualified namespace version
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.reader) <br> (<a href=''>syntax-quote</a> form )</tt>	macro equivalent to the syntax-quote reader macro`
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.trace) <br> (<a href=''>deftrace</a> name &amp; definition )</tt>	use in place of defn; traces each call / return of this fn including arguments
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.trace) <br> (<a href=''>dotrace</a> fnames &amp; exprs )</tt>	given a sequence of function identifiers evaluate the body expressions in an environment in which the identifiers are bound to the traced functions
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.trace) <br> (<a href=''>trace</a> name value )</tt>	sends name optional and value to the tracer function then returns value
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.trace) <br> (<a href=''>trace-forms</a> &amp; body )</tt>	trace all the forms in the given body
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.trace) <br> (<a href=''>trace-ns</a> n )</tt>	trace all fns in the given name space
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.trace) <br> (<a href=''>trace-vars</a> &amp; vs )</tt>	trace each of the specified vars
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.trace) <br> (<a href=''>traceable?</a> v )</tt>	returns true if the given var can be traced false otherwise
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.trace) <br> (<a href=''>traced?</a> v )</tt>	returns true if the given var is currently traced false otherwise
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.trace) <br> (<a href=''>untrace-ns</a> n )</tt>	untrace all fns in the given name space
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.trace) <br> (<a href=''>untrace-vars</a> &amp; vs )</tt>	untrace each of the specified vars
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.analyzer.passes.js.annotate-tag) <br> (<a href=''>annotate-tag</a> ast )</tt>	if the ast node type is a constant object or contains :tag metadata attach the appropriate :tag to the node
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.analyzer.passes.js.collect-keywords) <br> (<a href=''>collect-keywords</a> ast )</tt>	assoc compilation-unit shared id to each :const node with :type :keyword the keyword to id map is available in the global env under ::keywords
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.analyzer.passes.js.emit-form) <br> (<a href=''>emit-form</a> ast opts )</tt>	return the form represented by the given ast opts is a set of options valid options are
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.analyzer.passes.js.emit-form) <br> (<a href=''>emit-hygienic-form</a> ast )</tt>	return an hygienic form represented by the given ast
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.analyzer.passes.js.validate) <br> (<a href=''>validate</a> ast )</tt>	validate tags and symbols
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.analyzer.passes.jvm.constant-lifter) <br> (<a href=''>constant-lift</a> ast )</tt>	like clojure tools analyzer passes constant-lifter / constant-lift but transforms also :var nodes where the var has :const in the metadata into :const nodes and preserves tag info
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.analyzer.passes.jvm.emit-form) <br> (<a href=''>emit-form</a> ast opts )</tt>	return the form represented by the given ast opts is a set of options valid options are
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.analyzer.passes.jvm.emit-form) <br> (<a href=''>emit-hygienic-form</a> ast )</tt>	return an hygienic form represented by the given ast
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.analyzer.passes.jvm.fix-case-test) <br> (<a href=''>fix-case-test</a> ast )</tt>	if the node is a :case-test annotates in the atom shared by the binding and the local node with :case-test
<tt style='background-color:#E8E8E8;'> (ns clojure.tools.analyzer.passes.jvm.validate-loop-locals) <br> (<a href=''>validate-loop-locals</a> analyze )</tt>	returns a pass that validates the loop locals calling analyze on the loop ast when a mismatched loop-local is found
<tt style='background-color:#E8E8E8;'> (ns gloss) <br> (<a href=''>bit-map</a> & args )</tt>	defines an ordered map of signed integers with the specified bit-lengths
<tt style='background-color:#E8E8E8;'> (ns gloss) <br> (<a href=''>bit-seq</a> & bit-lengths )</tt>	defines a sequence of unsigned integers with the specified bit-lengths
<tt style='background-color:#E8E8E8;'> (ns gloss) <br> (<a href=''>byte-count</a> b )</tt>	returns the number of bytes in the value
<tt style='background-color:#E8E8E8;'> (ns gloss) <br> (<a href=''>compile-frame</a> framecompile-frame frame pre-encoder post-decoder )</tt>	takes a frame and returns a codec
<tt style='background-color:#E8E8E8;'> (ns gloss) <br> (<a href=''>defcodec-</a> name frame & coders )</tt>	defines a compiled frame
<tt style='background-color:#E8E8E8;'> (ns gloss) <br> (<a href=''>delimited-block</a> delimiters strip-delimiters? )</tt>	defines a frame which is just a byte sequence terminated by one or more delimiters
<tt style='background-color:#E8E8E8;'> (ns gloss) <br> (<a href=''>delimited-frame</a> delimiters frame )</tt>	defines a frame which is terminated by delimiters
<tt style='background-color:#E8E8E8;'> (ns gloss) <br> (<a href=''>enum</a> primitive-type & map-or-seq )</tt>	takes a list of enumerations or a map of enumerations onto values and returns a codec which associates each enumeration with a unique encoded value
<tt style='background-color:#E8E8E8;'> (ns gloss) <br> (<a href=''>finite-block</a> prefix-or-len )</tt>	defines a byte sequence which is either of fixed length or has a prefix which describes its length
<tt style='background-color:#E8E8E8;'> (ns gloss) <br> (<a href=''>finite-frame</a> prefix-or-len frame )</tt>	defines a frame which is either of finite length or has a prefix which describes its length
<tt style='background-color:#E8E8E8;'> (ns gloss) <br> (<a href=''>header</a> frame header->body body->header )</tt>	a header is a frame which describes the frame that follows
<tt style='background-color:#E8E8E8;'> (ns gloss) <br> (<a href=''>ordered-map</a> & key-value-pairs )</tt>	creates a codec which consumes and emits standard clojure hash-maps but ensures that the values are encoded in the specified order
<tt style='background-color:#E8E8E8;'> (ns gloss) <br> (<a href=''>prefix</a> primitiveprefix signature to-count from-count )</tt>	a prefix is a specialized form of header which only describes the length of the sequence that follows
<tt style='background-color:#E8E8E8;'> (ns gloss) <br> (<a href=''>repeated</a> frame & {:as options} )</tt>	describes a sequence of frames
<tt style='background-color:#E8E8E8;'> (ns gloss) <br> (<a href=''>sizeof</a> this )</tt>	returns the number of bytes this codec will encode to or nil if it is value-dependent
<tt style='background-color:#E8E8E8;'> (ns gloss) <br> (<a href=''>string</a> charset & {:as options} )</tt>	defines a frame which contains a string
<tt style='background-color:#E8E8E8;'> (ns gloss.io) <br> (<a href=''>contiguous</a> buf-seq )</tt>	takes a sequence of bytebuffers and returns a single contiguous bytebuffer
<tt style='background-color:#E8E8E8;'> (ns gloss.io) <br> (<a href=''>decode</a> frame bytesdecode frame bytes no-remainder? )</tt>	turns bytes into a single frame value
<tt style='background-color:#E8E8E8;'> (ns gloss.io) <br> (<a href=''>decode-all</a> frame bytes )</tt>	turns bytes into a sequence of frame values
<tt style='background-color:#E8E8E8;'> (ns gloss.io) <br> (<a href=''>decode-stream</a> src frame )</tt>	given a stream that emits bytes returns a channel that emits decoded frames whenever there are sufficient bytes
<tt style='background-color:#E8E8E8;'> (ns gloss.io) <br> (<a href=''>decode-stream-headers</a> src & frames )</tt>	given a channel that emits bytes returns a channel that will emit one decoded frame for each frame passed into the function
<tt style='background-color:#E8E8E8;'> (ns gloss.io) <br> (<a href=''>encode</a> frame val )</tt>	turns a frame value into a sequence of bytebuffers
<tt style='background-color:#E8E8E8;'> (ns gloss.io) <br> (<a href=''>encode-all</a> frame vals )</tt>	turns a sequence of frame values into a sequence of bytebuffers
<tt style='background-color:#E8E8E8;'> (ns gloss.io) <br> (<a href=''>encode-to-buffer</a> frame buf vals )</tt>	encodes a sequence of values and writes them to a bytebuffer
<tt style='background-color:#E8E8E8;'> (ns gloss.io) <br> (<a href=''>encode-to-stream</a> frame output-stream vals )</tt>	encodes a sequence of values and writes them to an outputstream
<tt style='background-color:#E8E8E8;'> (ns gloss.io) <br> (<a href=''>lazy-decode-all</a> frame bytes )</tt>	turns bytes into a lazy sequence of frame values
<tt style='background-color:#E8E8E8;'> (ns gloss.io) <br> (<a href=''>to-buf-seq</a> x )</tt>	converts the value to a sequence of bytebuffers
<tt style='background-color:#E8E8E8;'> (ns gloss.io) <br> (<a href=''>to-byte-buffer</a> x )</tt>	converts the value to a bytebuffer
<tt style='background-color:#E8E8E8;'> (ns medley) <br> (<a href=''>abs</a> x )</tt>	returns the absolute value of a number
<tt style='background-color:#E8E8E8;'> (ns medley) <br> (<a href=''>assoc-some</a> m k vassoc-some m k v & kvs )</tt>	associates a key with a value in a map if and only if the value is not nil
<tt style='background-color:#E8E8E8;'> (ns medley) <br> (<a href=''>boolean?</a> x )</tt>	returns true if x is a boolean
<tt style='background-color:#E8E8E8;'> (ns medley) <br> (<a href=''>deref-reset!</a> atom newval )</tt>	sets the value of the atom without regard for the current value then returns the original value of the atom
<tt style='background-color:#E8E8E8;'> (ns medley) <br> (<a href=''>deref-swap!</a> atom f & args )</tt>	atomically swaps the value of the atom to be apply f x args where x is the current value of the atom then returns the original value of the atom
<tt style='background-color:#E8E8E8;'> (ns medley) <br> (<a href=''>dissoc-in</a> m ks )</tt>	dissociate a value in a nested assocative structure identified by a sequence of keys
<tt style='background-color:#E8E8E8;'> (ns medley) <br> (<a href=''>distinct-by</a> fdistinct-by f coll )</tt>	returns a lazy sequence of the elements of coll removing any elements that return duplicate values when passed to a function f
<tt style='background-color:#E8E8E8;'> (ns medley) <br> (<a href=''>drop-upto</a> preddrop-upto pred coll )</tt>	returns a lazy sequence of the items in coll starting after the first item for which pred item returns true
<tt style='background-color:#E8E8E8;'> (ns medley) <br> (<a href=''>ex-cause</a> ex )</tt>	returns the cause attached to the given exceptioninfo / throwable object
<tt style='background-color:#E8E8E8;'> (ns medley) <br> (<a href=''>ex-message</a> ex )</tt>	returns the message attached to the given error / throwable object
<tt style='background-color:#E8E8E8;'> (ns medley) <br> (<a href=''>filter-keys</a> pred coll )</tt>	returns a new associative collection of the items in coll for whichpred key item returns true
<tt style='background-color:#E8E8E8;'> (ns medley) <br> (<a href=''>filter-kv</a> pred coll )</tt>	returns a new associative collection of the items in coll for whichpred key item val item returns true
<tt style='background-color:#E8E8E8;'> (ns medley) <br> (<a href=''>filter-vals</a> pred coll )</tt>	returns a new associative collection of the items in coll for whichpred val item returns true
<tt style='background-color:#E8E8E8;'> (ns medley) <br> (<a href=''>find-first</a> pred coll )</tt>	finds the first item in a collection that matches a predicate
<tt style='background-color:#E8E8E8;'> (ns medley) <br> (<a href=''>greatest</a> & xs )</tt>	find the greatest argument as defined by the compare function in o n time
<tt style='background-color:#E8E8E8;'> (ns medley) <br> (<a href=''>indexed</a> coll )</tt>	returns an ordered lazy sequence of vectors index item where item is a value in coll and index its position starting from zero
<tt style='background-color:#E8E8E8;'> (ns medley) <br> (<a href=''>interleave-all</a> & colls )</tt>	returns a lazy seq of the first item in each coll then the second etc
<tt style='background-color:#E8E8E8;'> (ns medley) <br> (<a href=''>least</a> & xs )</tt>	return the least argument as defined by the compare function in o n time
<tt style='background-color:#E8E8E8;'> (ns medley) <br> (<a href=''>map-entry</a> k v )</tt>	create a map entry for a key and value pair
<tt style='background-color:#E8E8E8;'> (ns medley) <br> (<a href=''>map-keys</a> f coll )</tt>	maps a function over the keys of an associative collection
<tt style='background-color:#E8E8E8;'> (ns medley) <br> (<a href=''>map-kv</a> f coll )</tt>	maps a function over the key / value pairs of an associate collection
<tt style='background-color:#E8E8E8;'> (ns medley) <br> (<a href=''>map-vals</a> f coll )</tt>	maps a function over the values of an associative collection
<tt style='background-color:#E8E8E8;'> (ns medley) <br> (<a href=''>mapply</a> f & args )</tt>	applies a function f to the argument list formed by concatenating everything but the last element of args with the last element of args
<tt style='background-color:#E8E8E8;'> (ns medley) <br> (<a href=''>queuequeue</a> coll )</tt>	creates an empty persistent queue or one populated with a collection
<tt style='background-color:#E8E8E8;'> (ns medley) <br> (<a href=''>queue?</a> x )</tt>	returns true if x implements clojure
<tt style='background-color:#E8E8E8;'> (ns medley) <br> (<a href=''>random-uuid</a>  )</tt>	generates a new random uuid
<tt style='background-color:#E8E8E8;'> (ns medley) <br> (<a href=''>remove-keys</a> pred coll )</tt>	returns a new associative collection of the items in coll for whichpred key item returns false
<tt style='background-color:#E8E8E8;'> (ns medley) <br> (<a href=''>remove-kv</a> pred coll )</tt>	returns a new associative collection of the items in coll for whichpred key item val item returns false
<tt style='background-color:#E8E8E8;'> (ns medley) <br> (<a href=''>remove-vals</a> pred coll )</tt>	returns a new associative collection of the items in coll for whichpred val item returns false
<tt style='background-color:#E8E8E8;'> (ns medley) <br> (<a href=''>take-upto</a> predtake-upto pred coll )</tt>	returns a lazy sequence of successive items from coll up to and including the first item for which pred item returns true
<tt style='background-color:#E8E8E8;'> (ns medley) <br> (<a href=''>uuid</a> s )</tt>	returns a uuid generated from the supplied string
<tt style='background-color:#E8E8E8;'> (ns medley) <br> (<a href=''>uuid?</a> x )</tt>	returns true if the value is a uuid
<tt style='background-color:#E8E8E8;'> (ns fs.compression) <br> (<a href=''>bunzip2</a> source target )</tt>	takes a path to a bzip2 file source and uncompresses it
<tt style='background-color:#E8E8E8;'> (ns fs.compression) <br> (<a href=''>gunzip</a> source target )</tt>	takes a path to a gzip file source and unzips it
<tt style='background-color:#E8E8E8;'> (ns fs.compression) <br> (<a href=''>make-zip-stream</a> & filename-content-pairs )</tt>	create zip file s stream
<tt style='background-color:#E8E8E8;'> (ns fs.compression) <br> (<a href=''>untar</a> source target )</tt>	takes a tarfile source and untars it to target
<tt style='background-color:#E8E8E8;'> (ns fs.compression) <br> (<a href=''>unxz</a> source target )</tt>	takes a path to a xz file source and uncompresses it
<tt style='background-color:#E8E8E8;'> (ns fs.compression) <br> (<a href=''>unzip</a> source target-dir )</tt>	takes the path to a zipfile source and unzips it to target-dir
<tt style='background-color:#E8E8E8;'> (ns fs.compression) <br> (<a href=''>zip</a> filename & filename-content-pairs )</tt>	create zip file s on the fly
<tt style='background-color:#E8E8E8;'> (ns fs) <br> (<a href=''>absolute</a> path )</tt>	return absolute file
<tt style='background-color:#E8E8E8;'> (ns fs) <br> (<a href=''>absolute?</a> path )</tt>	return true if path is absolute
<tt style='background-color:#E8E8E8;'> (ns fs) <br> (<a href=''>base-name</a> path trim-ext )</tt>	return the base namefinal segment / file part) of a path
<tt style='background-color:#E8E8E8;'> (ns fs) <br> (<a href=''>chdir</a> path )</tt>	set!s the value of *cwd* to path
<tt style='background-color:#E8E8E8;'> (ns fs) <br> (<a href=''>child-of?</a> p c )</tt>	takes two paths and checks to see if the first path is a parent of the second
<tt style='background-color:#E8E8E8;'> (ns fs) <br> (<a href=''>chmod</a> mode path )</tt>	change file permissions
<tt style='background-color:#E8E8E8;'> (ns fs) <br> (<a href=''>copy</a> from to )</tt>	copy a file from 'from' to 'to'
<tt style='background-color:#E8E8E8;'> (ns fs) <br> (<a href=''>copy+</a> src dest )</tt>	copy src to dest create directories if needed
<tt style='background-color:#E8E8E8;'> (ns fs) <br> (<a href=''>copy-dir</a> from to )</tt>	copy a directory from 'from' to 'to'
<tt style='background-color:#E8E8E8;'> (ns fs) <br> (<a href=''>create</a> f )</tt>	create a new file
<tt style='background-color:#E8E8E8;'> (ns fs) <br> (<a href=''>delete</a> path )</tt>	delete path
<tt style='background-color:#E8E8E8;'> (ns fs) <br> (<a href=''>delete-dir</a> root )</tt>	delete a directory tree
<tt style='background-color:#E8E8E8;'> (ns fs) <br> (<a href=''>directory?</a> path )</tt>	return true if path is a directory
<tt style='background-color:#E8E8E8;'> (ns fs) <br> (<a href=''>exec</a> & body )</tt>	execute a shell command in the current directory
<tt style='background-color:#E8E8E8;'> (ns fs) <br> (<a href=''>executable?</a> path )</tt>	return true if path is executable
<tt style='background-color:#E8E8E8;'> (ns fs) <br> (<a href=''>exists?</a> path )</tt>	return true if path exists
<tt style='background-color:#E8E8E8;'> (ns fs) <br> (<a href=''>expand-home</a> path )</tt>	if path begins with a tilde ~) expand the tilde to the value of the user
<tt style='background-color:#E8E8E8;'> (ns fs) <br> (<a href=''>extension</a> path )</tt>	return the extension part of a file
<tt style='background-color:#E8E8E8;'> (ns fs) <br> (<a href=''>file</a> path & paths )</tt>	if path is a period replaces it with cwd and creates a new file object out of it and paths
<tt style='background-color:#E8E8E8;'> (ns fs) <br> (<a href=''>file?</a> path )</tt>	return true if path is a file
<tt style='background-color:#E8E8E8;'> (ns fs) <br> (<a href=''>find-files</a> path pattern )</tt>	find files matching given pattern
<tt style='background-color:#E8E8E8;'> (ns fs) <br> (<a href=''>find-files*</a> path pred )</tt>	find files in path by pred
<tt style='background-color:#E8E8E8;'> (ns fs) <br> (<a href=''>glob</a> root pattern )</tt>	returns files matching glob pattern
<tt style='background-color:#E8E8E8;'> (ns fs) <br> (<a href=''>hidden?</a> path )</tt>	return true if path is hidden
<tt style='background-color:#E8E8E8;'> (ns fs) <br> (<a href=''>home</a> user )</tt>	with no arguments returns the current value of the user
<tt style='background-color:#E8E8E8;'> (ns fs) <br> (<a href=''>iterate-dir</a> path )</tt>	return a sequence root dirs files starting from 'path' in depth-first order
<tt style='background-color:#E8E8E8;'> (ns fs) <br> (<a href=''>link</a> path target )</tt>	create a "hard" link from path to target
<tt style='background-color:#E8E8E8;'> (ns fs) <br> (<a href=''>link?</a> path )</tt>	return true if path is a link
<tt style='background-color:#E8E8E8;'> (ns fs) <br> (<a href=''>list-dir</a> path )</tt>	list files and directories under path
<tt style='background-color:#E8E8E8;'> (ns fs) <br> (<a href=''>mkdir</a> path )</tt>	create a directory
<tt style='background-color:#E8E8E8;'> (ns fs) <br> (<a href=''>mkdirs</a> path )</tt>	make directory tree
<tt style='background-color:#E8E8E8;'> (ns fs) <br> (<a href=''>mod-time</a> path )</tt>	return file modification time
<tt style='background-color:#E8E8E8;'> (ns fs) <br> (<a href=''>name</a> path )</tt>	return the name part of a file
<tt style='background-color:#E8E8E8;'> (ns fs) <br> (<a href=''>normalized</a> path )</tt>	return normalized canonical file
<tt style='background-color:#E8E8E8;'> (ns fs) <br> (<a href=''>ns-path</a> n )</tt>	takes a namespace symbol and creates a path to it
<tt style='background-color:#E8E8E8;'> (ns fs) <br> (<a href=''>parent</a> path )</tt>	return the parent path
<tt style='background-color:#E8E8E8;'> (ns fs) <br> (<a href=''>parents</a> f )</tt>	get all the parent directories of a path
<tt style='background-color:#E8E8E8;'> (ns fs) <br> (<a href=''>path-ns</a> path )</tt>	takes a path to a clojure file and constructs a namespace symbol out of the path
<tt style='background-color:#E8E8E8;'> (ns fs) <br> (<a href=''>read-sym-link</a> path )</tt>	return the target of a 'soft' link
<tt style='background-color:#E8E8E8;'> (ns fs) <br> (<a href=''>readable?</a> path )</tt>	return true if path is readable
<tt style='background-color:#E8E8E8;'> (ns fs) <br> (<a href=''>rename</a> old-path new-path )</tt>	rename old-path to new-path
<tt style='background-color:#E8E8E8;'> (ns fs) <br> (<a href=''>size</a> path )</tt>	return size in bytes of file
<tt style='background-color:#E8E8E8;'> (ns fs) <br> (<a href=''>split</a> path )</tt>	split path to components
<tt style='background-color:#E8E8E8;'> (ns fs) <br> (<a href=''>split-ext</a> path )</tt>	returns a vector of name extension
<tt style='background-color:#E8E8E8;'> (ns fs) <br> (<a href=''>sym-link</a> path target )</tt>	create a "soft" link from path to target
<tt style='background-color:#E8E8E8;'> (ns fs) <br> (<a href=''>temp-dir</a> prefix suffix tries )</tt>	create a temporary directory
<tt style='background-color:#E8E8E8;'> (ns fs) <br> (<a href=''>temp-file</a> prefix suffix tries )</tt>	create a temporary file
<tt style='background-color:#E8E8E8;'> (ns fs) <br> (<a href=''>temp-name</a> prefix suffix )</tt>	create a temporary file name like what is created for temp-file and temp-dir
<tt style='background-color:#E8E8E8;'> (ns fs) <br> (<a href=''>tmpdir</a>  )</tt>	the temporary file directory looked up via the java
<tt style='background-color:#E8E8E8;'> (ns fs) <br> (<a href=''>touch</a> path & [time] )</tt>	set file modification time default to now
<tt style='background-color:#E8E8E8;'> (ns fs) <br> (<a href=''>walk</a> func path )</tt>	lazily walk depth-first over the directory structure starting at 'path' calling 'func' with three arguments root dirs files
<tt style='background-color:#E8E8E8;'> (ns fs) <br> (<a href=''>with-cwd</a> cwd & body )</tt>	execute body with a changed working directory
<tt style='background-color:#E8E8E8;'> (ns fs) <br> (<a href=''>with-mutable-cwd</a> & body )</tt>	execute the body in a binding with *cwd* bound to *cwd*
<tt style='background-color:#E8E8E8;'> (ns fs) <br> (<a href=''>writeable?</a> path )</tt>	return true if path is writeable
<tt style='background-color:#E8E8E8;'> (ns plumbing) <br> (<a href=''>-unless-update</a> body )</tt>	execute and yield body only if clojure version preceeds introduction of 'update' into core namespace
<tt style='background-color:#E8E8E8;'> (ns plumbing) <br> (<a href=''><-</a> & body )</tt>	converts a ->> to a -> ->> range 10 map inc <- doto prn reduce +
<tt style='background-color:#E8E8E8;'> (ns plumbing) <br> (<a href=''>?></a> arg do-it? & rest )</tt>	conditional single-arrow operation -> m?> add-kv?assoc :k :v))
<tt style='background-color:#E8E8E8;'> (ns plumbing) <br> (<a href=''>?>></a> do-it? & args )</tt>	conditional double-arrow operation ->> nums?>> inc-all? map inc
<tt style='background-color:#E8E8E8;'> (ns plumbing) <br> (<a href=''>aconcat</a> s )</tt>	like apply concat s but lazier and shorter
<tt style='background-color:#E8E8E8;'> (ns plumbing) <br> (<a href=''>as->></a> name & forms-and-expr )</tt>	like as-> but can be used in double arrow
<tt style='background-color:#E8E8E8;'> (ns plumbing) <br> (<a href=''>assoc-when</a> m & kvs )</tt>	like assoc but only assocs when value is truthy
<tt style='background-color:#E8E8E8;'> (ns plumbing) <br> (<a href=''>conj-when</a> coll x & xs )</tt>	like conj but ignores non-truthy values
<tt style='background-color:#E8E8E8;'> (ns plumbing) <br> (<a href=''>cons-when</a> x s )</tt>	like cons but does nothing if x is non-truthy
<tt style='background-color:#E8E8E8;'> (ns plumbing) <br> (<a href=''>count-when</a> pred xs )</tt>	returns # of elements of xs where pred holds
<tt style='background-color:#E8E8E8;'> (ns plumbing) <br> (<a href=''>dissoc-in</a> m [k & ks] )</tt>	dissociate this keyseq from m removing any empty maps created as a result including at the top-level
<tt style='background-color:#E8E8E8;'> (ns plumbing) <br> (<a href=''>distinct-by</a> f xs )</tt>	returns elements of xs which return unique values according to f
<tt style='background-color:#E8E8E8;'> (ns plumbing) <br> (<a href=''>distinct-id</a> xs )</tt>	like distinct but uses reference rather than value identity very clojurey
<tt style='background-color:#E8E8E8;'> (ns plumbing) <br> (<a href=''>fnk</a> & args )</tt>	keyword fn using letk
<tt style='background-color:#E8E8E8;'> (ns plumbing) <br> (<a href=''>for-map</a> m-sym seq-exprs key-expr val-expr )</tt>	like 'for' for building maps
<tt style='background-color:#E8E8E8;'> (ns plumbing) <br> (<a href=''>get-and-set!</a> a new-val )</tt>	like reset! but returns old-val
<tt style='background-color:#E8E8E8;'> (ns plumbing) <br> (<a href=''>grouped-map</a> key-fn map-fn coll )</tt>	like group-by but accepts a map-fn that is applied to values before collected
<tt style='background-color:#E8E8E8;'> (ns plumbing) <br> (<a href=''>if-letk</a> bindings then else )</tt>	if test is true evaluates then with binding-form bound to the value of test if not yields else
<tt style='background-color:#E8E8E8;'> (ns plumbing) <br> (<a href=''>indexed</a> s )</tt>	returns idx x for x in seqable s
<tt style='background-color:#E8E8E8;'> (ns plumbing) <br> (<a href=''>keywordize-map</a> x )</tt>	recursively convert maps in m including itself to have keyword keys instead of string
<tt style='background-color:#E8E8E8;'> (ns plumbing) <br> (<a href=''>lazy-get</a> m k d )</tt>	like get but lazy about default
<tt style='background-color:#E8E8E8;'> (ns plumbing) <br> (<a href=''>letk</a> bindings & body )</tt>	keyword let
<tt style='background-color:#E8E8E8;'> (ns plumbing) <br> (<a href=''>map-from-keys</a> f ks )</tt>	build map k -> f k for keys in ks
<tt style='background-color:#E8E8E8;'> (ns plumbing) <br> (<a href=''>map-from-vals</a> f vs )</tt>	build map f v -> v for vals in vs
<tt style='background-color:#E8E8E8;'> (ns plumbing) <br> (<a href=''>map-keys</a> f m )</tt>	build map f k -> v for k v in map m
<tt style='background-color:#E8E8E8;'> (ns plumbing) <br> (<a href=''>map-vals</a> f m )</tt>	build map k -> f v for k v in map preserving the initial type
<tt style='background-color:#E8E8E8;'> (ns plumbing) <br> (<a href=''>mapply</a> f arg & args )</tt>	like apply but applies a map to a function with positional map arguments
<tt style='background-color:#E8E8E8;'> (ns plumbing) <br> (<a href=''>memoized-fn</a> name args & body )</tt>	like fn but memoized including recursive calls
<tt style='background-color:#E8E8E8;'> (ns plumbing) <br> (<a href=''>positions</a> f s )</tt>	returns indices idx of sequence s wheref nth s idx
<tt style='background-color:#E8E8E8;'> (ns plumbing) <br> (<a href=''>safe-get</a> m k )</tt>	like get but throw an exception if not found
<tt style='background-color:#E8E8E8;'> (ns plumbing) <br> (<a href=''>safe-get-in</a> m ks )</tt>	like get-in but throws exception if not found
<tt style='background-color:#E8E8E8;'> (ns plumbing) <br> (<a href=''>singleton</a> xs )</tt>	returns first xs when xs has only 1 element
<tt style='background-color:#E8E8E8;'> (ns plumbing) <br> (<a href=''>sum</a> xs )</tt>	return sum of f x for each x in xs
<tt style='background-color:#E8E8E8;'> (ns plumbing) <br> (<a href=''>swap-pair!</a> a f & args )</tt>	like swap! but returns a pair old-val new-val
<tt style='background-color:#E8E8E8;'> (ns plumbing) <br> (<a href=''>unchunk</a> s )</tt>	takes a seqable and returns a lazy sequence that is maximally lazy and doesn't realize elements due to either chunking or apply
<tt style='background-color:#E8E8E8;'> (ns plumbing) <br> (<a href=''>update</a> m k f x1 x2 & xs )</tt>	updates the value in map m at k with the function f
<tt style='background-color:#E8E8E8;'> (ns plumbing) <br> (<a href=''>update-in-when</a> m key-seq f & args )</tt>	like update-in but returns m unchanged if key-seq is not present
<tt style='background-color:#E8E8E8;'> (ns plumbing) <br> (<a href=''>when-letk</a> bindings & body )</tt>	when test is true evaluates body with binding-form bound to the value of test
<tt style='background-color:#E8E8E8;'> (ns plumbing.fnk.impl) <br> (<a href=''>efficient-call-forms</a> fnk arg-form-map )</tt>	get f arg-forms that can be used to call a fnk most efficiently using the positional version if available or otherwise the raw fnk
<tt style='background-color:#E8E8E8;'> (ns plumbing.fnk.impl) <br> (<a href=''>fnk-form</a> env name? bind body )</tt>	take an optional name binding form and body for a fnk and make an ifn / pfnk for these arguments
<tt style='background-color:#E8E8E8;'> (ns plumbing.fnk.impl) <br> (<a href=''>letk-arg-bind-sym-and-body-form</a> env map-sym binding key-path body-form )</tt>	given a single element of a single letk binding form and a current body form return a map :schema-entry :body-form where schema-entry is a tuple [bound-key schema external-schema?] and body-form wraps body with destructuring for this binding as necessary
<tt style='background-color:#E8E8E8;'> (ns plumbing.fnk.impl) <br> (<a href=''>letk-input-schema-and-body-form</a> env binding-form key-path body-form )</tt>	given a single letk binding form value form key path and body form return a map :input-schema :external-input-schema :map-sym :body-form where input-schema is the schema imposed by binding-form external-input-schema is like input-schema but includes user overrides for binding vectors map-sym is the symbol which it expects the bound value to be bound to and body-form wraps body in the bindings from binding-form from map-sym
<tt style='background-color:#E8E8E8;'> (ns plumbing.fnk.impl) <br> (<a href=''>name-sym</a> x )</tt>	returns symbol of x's name
<tt style='background-color:#E8E8E8;'> (ns plumbing.fnk.impl) <br> (<a href=''>positional-arg-bind-sym-and-body</a> env binding body-form )</tt>	given a single element of a fnk binding form and a current body form return a pair [ k bind-sym new-body-form] where bind-sym is a suitable symbol to bind to k in the fnk arglist including tag metadata if applicable and new-body-form is wrapped with destructuring for this binding as necessary
<tt style='background-color:#E8E8E8;'> (ns plumbing.fnk.impl) <br> (<a href=''>positional-arg-bind-syms-and-body</a> env bind body-form )</tt>	given a fnk binding form and body form return a pair bind-sym-map new-body-form where bind-sym-map is a map from keyword args to binding symbols and and new-body-form wraps body to do any extra processing of nested or optional bindings above and beyond the bindings achieved by bind-sym-vector
<tt style='background-color:#E8E8E8;'> (ns plumbing.fnk.impl) <br> (<a href=''>positional-fn</a> fnk arg-ks )</tt>	given argument order in arg-ks produce an ordinary fn that can be called with arguments in this order
<tt style='background-color:#E8E8E8;'> (ns plumbing.fnk.impl) <br> (<a href=''>positional-fnk-form</a> fn-name external-input-schema ordered-ks->opt arg-sym-map body )</tt>	takes an optional name input schema seq of ordered [key optional?] pairs an arg-sym-map from these keywords to symbols and and a positional fn body that can reference these symbols
<tt style='background-color:#E8E8E8;'> (ns plumbing.fnk.impl) <br> (<a href=''>positional-info</a> fnk )</tt>	if fnk has a positional function implementation return the pair positional-fn positional-arg-ks such that if positional-arg-ks is [:a :b :c] calling positional-fn a b c is equivalent to callingfnk :a a :b b :c c ) but faster
<tt style='background-color:#E8E8E8;'> (ns plumbing.fnk.impl) <br> (<a href=''>qualified-sym</a> x )</tt>	returns qualified symbol of x an instance of named
<tt style='background-color:#E8E8E8;'> (ns plumbing.fnk.pfnk) <br> (<a href=''>fn->fnk</a> f [input-schema output-schema :as io] )</tt>	make a keyword function into a pfnk by associating input and output schema metadata
<tt style='background-color:#E8E8E8;'> (ns plumbing.fnk.pfnk) <br> (<a href=''>io-schemata</a> this )</tt>	return a pair of input-schema output-schema as specified in plumbing
<tt style='background-color:#E8E8E8;'> (ns plumbing.fnk.schema) <br> (<a href=''>assert-distinct</a> things )</tt>	likeassertdistinct? things)) but with a more helpful error message
<tt style='background-color:#E8E8E8;'> (ns plumbing.fnk.schema) <br> (<a href=''>assert-iae</a> form & format-args )</tt>	like assert but throws a runtimeexception in clojure not an assertionerror and also takes args to format
<tt style='background-color:#E8E8E8;'> (ns plumbing.fnk.schema) <br> (<a href=''>guess-expr-output-schema</a> expr )</tt>	guess an output schema for an expr
<tt style='background-color:#E8E8E8;'> (ns plumbing.fnk.schema) <br> (<a href=''>non-map-diff</a> s1 s2 )</tt>	return a difference of schmas s1 and s2 where one is not a map
<tt style='background-color:#E8E8E8;'> (ns plumbing.fnk.schema) <br> (<a href=''>safe-get</a> m k key-path )</tt>	like get m k but throws if k is not present in m
<tt style='background-color:#E8E8E8;'> (ns plumbing.fnk.schema) <br> (<a href=''>schema-diff</a> input-schema output-schema )</tt>	subtract output-schema from input-schema returning nil if it's possible that an object satisfying the output-schema satisfies the input-schema or otherwise a description of the part s of input-schema not met by output-schema
<tt style='background-color:#E8E8E8;'> (ns plumbing.graph-async) <br> (<a href=''>asyncify</a> f )</tt>	take a fnk f and return an async version by wrapping non-channel return values in a channel
<tt style='background-color:#E8E8E8;'> (ns plumbing.graph) <br> (<a href=''>->graph</a> graph-nodes )</tt>	convert a graph specification into a canonical well-formed 'graph' which is an array-map with nodes in a correct topological order that will respond to 'io-schemata' with a specification of the graph inputs and outputs
<tt style='background-color:#E8E8E8;'> (ns plumbing.graph) <br> (<a href=''>check-comp-partial!</a> g instance-fn )</tt>	check that instance-fn is a valid fn to comp-partial with graph g
<tt style='background-color:#E8E8E8;'> (ns plumbing.graph) <br> (<a href=''>comp-partial-fn</a> f other )</tt>	return a new pfnk representing the composition # fmerge %other %))
<tt style='background-color:#E8E8E8;'> (ns plumbing.graph) <br> (<a href=''>compile</a> g )</tt>	compile graph specification g to a corresponding fnk using the a default compile strategy for host
<tt style='background-color:#E8E8E8;'> (ns plumbing.graph) <br> (<a href=''>eager-compile</a> g )</tt>	compile graph specification g to a corresponding fnk that is optimized for speed
<tt style='background-color:#E8E8E8;'> (ns plumbing.graph) <br> (<a href=''>graph</a> & nodes )</tt>	an ordered constructor for graphs which enforces that the graph is provided in a valid topological ordering
<tt style='background-color:#E8E8E8;'> (ns plumbing.graph) <br> (<a href=''>interpreted-eager-compile</a> g )</tt>	compile graph specification g to a corresponding fnk that returns an ordinary clojure map of the node result fns on a given input
<tt style='background-color:#E8E8E8;'> (ns plumbing.graph) <br> (<a href=''>lazy-compile</a> g )</tt>	compile graph specification g to a corresponding fnk that returns a lazymap of the node result fns on a given input
<tt style='background-color:#E8E8E8;'> (ns plumbing.graph) <br> (<a href=''>positional-eager-compile</a> g arg-ks )</tt>	like eager-compile but produce a non-keyword function that can be called with args in the order provided by arg-ks avoiding the overhead of creating and destructuring a top-level map
<tt style='background-color:#E8E8E8;'> (ns plumbing.graph) <br> (<a href=''>profiled</a> profile-key g )</tt>	modify graph spec g producing a new graph spec with a new top-level key 'profile-key'
<tt style='background-color:#E8E8E8;'> (ns plumbing.graph) <br> (<a href=''>restricted-call</a> f in-m )</tt>	call fnk f on the subset of keys its input schema explicitly asks for
<tt style='background-color:#E8E8E8;'> (ns plumbing.graph) <br> (<a href=''>run</a> g input )</tt>	eagerly run a graph on an input by compiling and then executing on this input
<tt style='background-color:#E8E8E8;'> (ns plumbing.graph) <br> (<a href=''>simple-flat-compile</a> g check-input? make-map assoc-f )</tt>	helper method for simple non-nested graph compilations that convert a graph specification to a fnk that returns a clojure map of the graph node values
<tt style='background-color:#E8E8E8;'> (ns plumbing.graph) <br> (<a href=''>simple-hierarchical-compile</a> g check-input? make-map assoc-f )</tt>	hierarchical extension of simple-nonhierarchical-compile
<tt style='background-color:#E8E8E8;'> (ns plumbing.graph) <br> (<a href=''>working-array-map</a> & args )</tt>	array-map in cljs no longer preserves ordering replicate the old functionality
<tt style='background-color:#E8E8E8;'> (ns plumbing.graph.positional) <br> (<a href=''>def-graph-record</a> g record-type-name )</tt>	define a record for the output of a graph
<tt style='background-color:#E8E8E8;'> (ns plumbing.graph.positional) <br> (<a href=''>eval-bound</a> form bindings )</tt>	evaluate a form with some symbols bound to some values
<tt style='background-color:#E8E8E8;'> (ns plumbing.graph.positional) <br> (<a href=''>graph-form</a> g arg-keywords )</tt>	construct body-form bindings-needed-for-eval for a positional graph
<tt style='background-color:#E8E8E8;'> (ns plumbing.graph.positional) <br> (<a href=''>graph-let-bindings</a> g g-value-syms )</tt>	compute the bindings for functions and intermediates needed to form the body of a positional graph e
<tt style='background-color:#E8E8E8;'> (ns plumbing.graph.positional) <br> (<a href=''>positional-flat-compile</a> g )</tt>	positional compile for a flat non-nested graph
<tt style='background-color:#E8E8E8;'> (ns plumbing.map) <br> (<a href=''>collate</a> flat-counts )</tt>	take a seq of k v counts and sum them up into a hashmap on k
<tt style='background-color:#E8E8E8;'> (ns plumbing.map) <br> (<a href=''>deep-collate</a> nested-counts )</tt>	take a seq of kseq v counts and sum them up into nested hashmaps
<tt style='background-color:#E8E8E8;'> (ns plumbing.map) <br> (<a href=''>flatten</a> m )</tt>	transform a nested map into a seq of keyseq leaf-val pairs
<tt style='background-color:#E8E8E8;'> (ns plumbing.map) <br> (<a href=''>get!</a> m k default-expr )</tt>	get the value in java
<tt style='background-color:#E8E8E8;'> (ns plumbing.map) <br> (<a href=''>inc-key!</a> m k d )</tt>	increment the value in java
<tt style='background-color:#E8E8E8;'> (ns plumbing.map) <br> (<a href=''>inc-key-in!</a> m ks d )</tt>	increment the value in java
<tt style='background-color:#E8E8E8;'> (ns plumbing.map) <br> (<a href=''>keep-leaves</a> f m )</tt>	takes a nested map and returns a nested map with the same shape where each non-map leaf v is transformed to f v or removed if it returns nil
<tt style='background-color:#E8E8E8;'> (ns plumbing.map) <br> (<a href=''>keep-leaves-and-path</a> f ks m )</tt>	takes a nested map and returns a nested map with the same shape where each non-map leaf v is transformed to f key-seq v or removed if it returns nil
<tt style='background-color:#E8E8E8;'> (ns plumbing.map) <br> (<a href=''>keyword-map</a> & syms )</tt>	expands to a map whose keys are keywords with the same name as the given symbols e
<tt style='background-color:#E8E8E8;'> (ns plumbing.map) <br> (<a href=''>map-leaves</a> f m )</tt>	takes a nested map and returns a nested map with the same shape where each non-map leaf v is transformed to f v
<tt style='background-color:#E8E8E8;'> (ns plumbing.map) <br> (<a href=''>map-leaves-and-path</a> f ks m )</tt>	takes a nested map and returns a nested map with the same shape where each non-map leaf v is transformed to f key-seq v
<tt style='background-color:#E8E8E8;'> (ns plumbing.map) <br> (<a href=''>merge-disjoint</a> m1 m2 & maps )</tt>	like merge but throws with any key overlap between maps
<tt style='background-color:#E8E8E8;'> (ns plumbing.map) <br> (<a href=''>merge-with-key</a> f & maps )</tt>	like merge-with but the merging function takes the key being merged as the first argument
<tt style='background-color:#E8E8E8;'> (ns plumbing.map) <br> (<a href=''>safe-select-keys</a> m ks )</tt>	like select-keys but asserts that all keys are present
<tt style='background-color:#E8E8E8;'> (ns plumbing.map) <br> (<a href=''>topological-sort</a> child-map & [include-leaves?] )</tt>	take an adjacency list representation of a graph a map from node names to sequences of child node names and return a topological ordering of the node names in linear time or throw an error if the graph is cyclic
<tt style='background-color:#E8E8E8;'> (ns plumbing.map) <br> (<a href=''>unflatten</a> s )</tt>	transform a seq of keyseq leaf-val pairs into a nested map
<tt style='background-color:#E8E8E8;'> (ns plumbing.map) <br> (<a href=''>update-key!</a> m k f & args )</tt>	transform value in java
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>abuts?</a> i-a i-b )</tt>	returns true if interval i-a abuts i-b i
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>ago</a> period )</tt>	returns a datetime a supplied period before the present
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>date-midnight</a> year month day )</tt>	constructs and returns a new datemidnight in utc
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>date-time</a> year month day hour minute second millis )</tt>	constructs and returns a new datetime in utc
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>after?</a> this that )</tt>	returns true if readabledatetime 'this' is strictly after date / time 'that'
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>before?</a> this that )</tt>	returns true if readabledatetime 'this' is strictly before date / time 'that'
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>day</a> this )</tt>	return the day of month component of the given date / time
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>day-of-week</a> this )</tt>	return the day of week component of the given date / time
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>hour</a> this )</tt>	return the hour of day component of the given date / time
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>milli</a> this )</tt>	return the millisecond of second component of the given date / time
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>minus-</a> this period )</tt>	returns a new date / time corresponding to the given date / time moved backwards by the given period s
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>minute</a> this )</tt>	return the minute of hour component of the given date / time
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>month</a> this )</tt>	return the month component of the given date / time
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>plus-</a> this period )</tt>	returns a new date / time corresponding to the given date / time moved forwards by the given period s
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>sec</a> this )</tt>	return the second of minute component of the given date / time
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>second</a> this )</tt>	return the second of minute component of the given date / time
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>year</a> this )</tt>	return the year component of the given date / time
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>days</a> n )</tt>	given a number returns a period representing that many days
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>days?</a> val )</tt>	returns true if the given value is an instance of days
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>default-time-zone</a>  )</tt>	returns the default datetimezone for the current environment
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>earliest</a> dts )</tt>	returns the earliest of the supplied datetimes
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>end</a> in )</tt>	returns the end datetime of an interval
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>epoch</a>  )</tt>	returns a datetime for the begining of the unix epoch in the utc time zone
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>extend</a> in & by )</tt>	returns an interval with an end readabledatetime the specified period after the end of the given interval
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>from-now</a> period )</tt>	returns a datetime a supplied period after the present
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>from-time-zone</a> dt tz )</tt>	returns a new readabledatetime corresponding to the same point in calendar time as the given readabledatetime but for a correspondingly different absolute instant in time
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>hours</a> n )</tt>	given a number returns a period representing that many hours
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>hours?</a> val )</tt>	returns true if the given value is an instance of hours
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>in-days</a> in )</tt>	returns the number of standard days in the given interval
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>in-hours</a> in )</tt>	returns the number of standard hours in the given interval
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>in-millis</a> in )</tt>	returns the number of milliseconds in the given interval
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>in-minutes</a> in )</tt>	returns the number of standard minutes in the given interval
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>in-months</a> in )</tt>	returns the number of standard months in the given interval
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>in-msecs</a> in )</tt>	deprecated: returns the number of milliseconds in the given interval
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>in-seconds</a> in )</tt>	returns the number of standard seconds in the given interval
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>in-secs</a> in )</tt>	deprecated: returns the number of standard seconds in the given interval
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>in-weeks</a> in )</tt>	returns the number of standard weeks in the given interval
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>in-years</a> in )</tt>	returns the number of standard years in the given interval
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>interval</a> dt-a dt-b )</tt>	returns an interval representing the span between the two given readabledatetimes
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>latest</a> dts )</tt>	returns the latest of the supplied datetimes
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>local-date</a> year month day )</tt>	constructs and returns a new localdate
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>local-date-time</a> year month day hour minute second millis )</tt>	constructs and returns a new localdatetime
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>millis</a> n )</tt>	given a number returns a period representing that many milliseconds
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>minus</a> dt p & ps )</tt>	returns a new date / time object corresponding to the given date / time moved backwards by the given period s
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>minutes</a> n )</tt>	given a number returns a period representing that many minutes
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>minutes?</a> val )</tt>	returns true if the given value is an instance of minutes
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>months</a> n )</tt>	given a number returns a period representing that many months
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>months?</a> val )</tt>	returns true if the given value is an instance of months
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>now</a>  )</tt>	returns a datetime for the current instant in the utc time zone
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>overlaps?</a> start-a end-a start-b end-b )</tt>	with 2 arguments: returns true of the two given intervals overlap
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>plus</a> dt p & ps )</tt>	returns a new date / time corresponding to the given date / time moved forwards by the given period s
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>seconds</a> n )</tt>	given a number returns a period representing that many seconds
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>seconds?</a> val )</tt>	returns true if the given value is an instance of seconds
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>start</a> in )</tt>	returns the start datetime of an interval
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>time-zone-for-id</a> id )</tt>	returns a datetimezone for the given id which must be in long form e
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>time-zone-for-offset</a> hours minutes )</tt>	returns a datetimezone for the given offset specified either in hours or hours and minutes
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>to-time-zone</a> dt tz )</tt>	returns a new readabledatetime corresponding to the same absolute instant in time as the given readabledatetime but with calendar fields corresponding to the given timezone
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>today</a>  )</tt>	constructs and returns a new localdate representing today's date
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>today-at-midnight</a> tz )</tt>	returns a datemidnight for today at midnight in the utc time zone
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>weeks</a> n )</tt>	given a number returns a period representing that many weeks
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>weeks?</a> val )</tt>	returns true if the given value is an instance of weeks
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>within?</a> start end test )</tt>	with 2 arguments: returns true if the given interval contains the given readabledatetime
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>year-month</a> year month )</tt>	constructs and returns a new yearmonth
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>years</a> n )</tt>	given a number returns a period representing that many years
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>years?</a> val )</tt>	returns true if the given value is an instance of years
<tt style='background-color:#E8E8E8;'> (ns clj-time) <br> (<a href=''>yesterday</a>  )</tt>	returns a datetime for yesterday relative to now
<tt style='background-color:#E8E8E8;'> (ns clj-time.coerce) <br> (<a href=''>from-date</a> date )</tt>	returns a datetime instance in the utc time zone corresponding to the given java date object
<tt style='background-color:#E8E8E8;'> (ns clj-time.coerce) <br> (<a href=''>from-long</a> millis )</tt>	returns a datetime instance in the utc time zone corresponding to the given number of milliseconds after the unix epoch
<tt style='background-color:#E8E8E8;'> (ns clj-time.coerce) <br> (<a href=''>from-sql-date</a> sql-date )</tt>	returns a datetime instance in the utc time zone corresponding to the given java
<tt style='background-color:#E8E8E8;'> (ns clj-time.coerce) <br> (<a href=''>from-sql-time</a> sql-time )</tt>	returns a datetime instance in the utc time zone corresponding to the given java
<tt style='background-color:#E8E8E8;'> (ns clj-time.coerce) <br> (<a href=''>from-string</a> s )</tt>	return datetime instance from string using formatters in clj-time
<tt style='background-color:#E8E8E8;'> (ns clj-time.coerce) <br> (<a href=''>to-date-time</a> obj )</tt>	convert `obj` to a joda datetime instance
<tt style='background-color:#E8E8E8;'> (ns clj-time.coerce) <br> (<a href=''>to-date</a> obj )</tt>	convert `obj` to a java date instance
<tt style='background-color:#E8E8E8;'> (ns clj-time.coerce) <br> (<a href=''>to-epoch</a> obj )</tt>	convert `obj` to unix epoch
<tt style='background-color:#E8E8E8;'> (ns clj-time.coerce) <br> (<a href=''>to-local-date</a> obj )</tt>	convert `obj` to a org
<tt style='background-color:#E8E8E8;'> (ns clj-time.coerce) <br> (<a href=''>to-local-date-time</a> obj )</tt>	convert `obj` to a org
<tt style='background-color:#E8E8E8;'> (ns clj-time.coerce) <br> (<a href=''>to-long</a> obj )</tt>	convert `obj` to the number of milliseconds after the unix epoch
<tt style='background-color:#E8E8E8;'> (ns clj-time.coerce) <br> (<a href=''>to-sql-date</a> obj )</tt>	convert `obj` to a java
<tt style='background-color:#E8E8E8;'> (ns clj-time.coerce) <br> (<a href=''>to-sql-time</a> obj )</tt>	convert `obj` to a java
<tt style='background-color:#E8E8E8;'> (ns clj-time.coerce) <br> (<a href=''>to-string</a> obj )</tt>	returns a string representation of obj in utc time-zone usingisodatetimeformat / datetime) date-time representation
<tt style='background-color:#E8E8E8;'> (ns clj-time.coerce) <br> (<a href=''>to-timestamp</a> obj )</tt>	convert `obj` to a java sql timestamp instance
<tt style='background-color:#E8E8E8;'> (ns clj-time.format) <br> (<a href=''>formatter</a> dtz fmts & more )</tt>	returns a custom formatter for the given date-time pattern
<tt style='background-color:#E8E8E8;'> (ns clj-time.format) <br> (<a href=''>formatter-local</a> fmt )</tt>	returns a custom formatter with no time zone info
<tt style='background-color:#E8E8E8;'> (ns clj-time.format) <br> (<a href=''>instant->map</a> instant )</tt>	returns a map representation of the given instant
<tt style='background-color:#E8E8E8;'> (ns clj-time.format) <br> (<a href=''>parse</a> s )</tt>	returns a datetime instance in the utc time zone obtained by parsing the given string according to the given formatter
<tt style='background-color:#E8E8E8;'> (ns clj-time.format) <br> (<a href=''>parse-local</a> s )</tt>	returns a localdatetime instance obtained by parsing the given string according to the given formatter
<tt style='background-color:#E8E8E8;'> (ns clj-time.format) <br> (<a href=''>parse-local-date</a> s )</tt>	returns a localdate instance obtained by parsing the given string according to the given formatter
<tt style='background-color:#E8E8E8;'> (ns clj-time.format) <br> (<a href=''>show-formatters</a> dt )</tt>	shows how a given datetime or by default the current time would be formatted with each of the available printing formatters
<tt style='background-color:#E8E8E8;'> (ns clj-time.format) <br> (<a href=''>unparse</a> fmt dt )</tt>	returns a string representing the given datetime instance in utc and in the form determined by the given formatter
<tt style='background-color:#E8E8E8;'> (ns clj-time.format) <br> (<a href=''>unparse-local</a> fmt dt )</tt>	returns a string representing the given localdatetime instance in the form determined by the given formatter
<tt style='background-color:#E8E8E8;'> (ns clj-time.format) <br> (<a href=''>unparse-local-date</a> fmt ld )</tt>	returns a string representing the given localdate instance in the form determined by the given formatter
<tt style='background-color:#E8E8E8;'> (ns clj-time.format) <br> (<a href=''>with-chronology</a> f c )</tt>	return a copy of a formatter that uses the given chronology
<tt style='background-color:#E8E8E8;'> (ns clj-time.format) <br> (<a href=''>with-locale</a> f l )</tt>	return a copy of a formatter that uses the given locale
<tt style='background-color:#E8E8E8;'> (ns clj-time.format) <br> (<a href=''>with-pivot-year</a> f pivot-year )</tt>	return a copy of a formatter that uses the given pivot year
<tt style='background-color:#E8E8E8;'> (ns clj-time.format) <br> (<a href=''>with-zone</a> f dtz )</tt>	return a copy of a formatter that uses the given datetimezone
<tt style='background-color:#E8E8E8;'> (ns clj-time.local) <br> (<a href=''>format-local-time</a> obj format-key )</tt>	format obj as local time using the local formatter corresponding to format-key
<tt style='background-color:#E8E8E8;'> (ns clj-time.local) <br> (<a href=''>to-local-date-time</a> obj )</tt>	convert `obj` to a local joda datetime instance retaining time fields
<tt style='background-color:#E8E8E8;'> (ns clj-time.local) <br> (<a href=''>local-now</a>  )</tt>	returns a datetime for the current instant in the default time zone
<tt style='background-color:#E8E8E8;'> (ns clj-time.predicates) <br> (<a href=''>same-date?</a> this-date-time that-date-time )</tt>	compares two date times to see if they are the same date
<tt style='background-color:#E8E8E8;'> (ns clj-time.periodic) <br> (<a href=''>periodic-seq</a> start period-like )</tt>	returns an infinite sequence of date-time values growing over specific period
