function	parents ||| parents	count=1
function	[function_1] stream ||| [function_2] [function_1]	count=2
module	[module] finger_tree ||| [module]	count=6
function	attempts to read ||| read file	count=1
arg	of two channels the ||| t buf or n f buf or	count=1
function_arg	[function_1] n coll ||| [function_1] [arg_2]	count=4
function	acos ||| acos	count=1
arg	items from ch ||| ch	count=1
arg	[arg_1] body ||| core with redefs bindings [arg_1] [arg_2]	count=1
arg	keyval ||| keyvals	count=3
arg	s is a newline ||| s	count=1
function	in the jar ||| in	count=1
arg	preceeded by literal string ||| debug string	count=1
function_arg	stack trace [arg_2] ||| [arg_2] [function_1]	count=3
arg	in a ||| &amp; args	count=2
arg	the given transport ||| transport timeout	count=1
function	with a ||| assert with	count=1
arg	comparator and optional ||| comparator &amp;	count=2
arg	test ||| test start key end test end	count=2
arg	calls cf default ||| cf	count=1
function	assumes ||| fetch val	count=1
function_arg	define [function_1] [arg_2] ||| [function_1] [arg_2]	count=3
module	a new collection in ||| generic collection	count=1
module	return true ||| algo generic comparison	count=2
function	[function] per urlclassloader ||| [function]	count=2
function_arg	[function_1] p ||| [function_1] [arg_2]	count=2
function	attempts to read a ||| read	count=3
arg	error-mode of agent ||| mode keyword	count=1
arg	step to [arg_2] ||| [arg_2] [arg_1]	count=4
module	a sequence ||| java	count=1
arg	channels the first ||| t buf or n f buf or n	count=1
arg	of f on ||| f	count=1
function	with ||| assert with message	count=2
function_arg	[function_1] supplied ||| [function_1] coll [arg_2]	count=1
module	sequence of ||| classpath	count=1
arg	name is declared as ||| name	count=1
function	[function_1] method ||| [function_1] [function_2]	count=1
function_arg	[function_1] the timeout ||| [arg_2] [function_1]	count=3
arg	java io writer ||| writer &amp; options	count=1
module	ast when a ||| analyzer passes	count=1
arg	and optional ||| string &amp;	count=1
function_arg	[function_1] comparator and ||| [arg_2] [function_1]	count=3
function_arg	[function_1] heterogeneous vectors ||| [function_1] [arg_2]	count=1
arg	at the time ||| &amp;	count=1
arg	fun ||| fun	count=1
arg	a proxy instance and ||| proxy	count=1
arg	of the same ||| &amp; args	count=1
arg	of functions and returns ||| f g &amp; fs	count=1
arg	of x [arg_2] ||| [arg_2] [arg_1]	count=9
arg	s ||| opts s	count=2
arg	of functions and ||| &amp; fs	count=2
arg	vector of two channels ||| n f buf or	count=1
arg	the index ||| idx idx2 &amp;	count=7
function	prints the contents ||| print	count=1
arg	coerces coll [arg_2] ||| [arg_1] [arg_2]	count=2
function_arg	key val returns a [function_1] [arg_2] ||| data priority-map [function_1] by [arg_2]	count=6
function	to stop ||| thread stopper	count=1
function	stop ||| thread stopper	count=1
function_arg	stream [arg_2] ||| [arg_2] [function_1]	count=4
arg	in a ||| &amp;	count=2
function	the left sibling of ||| left	count=1
arg	test s ||| test start key end test end key	count=2
arg	collection test s ||| key end test	count=2
arg	positional factory function ||| _meta	count=4
function	longs ||| long	count=1
arg	key ||| map key	count=1
function_arg	[function_1] is ||| [function_1] [arg_2]	count=2
module	possibly ||| main	count=1
arg	atom to be: apply ||| atom	count=1
function	bindings in the given ||| flatten bindings	count=1
arg	body in a ||| &amp; body	count=1
arg	[arg] by ||| [arg]	count=4
function	assumes the ||| fetch val	count=1
function	[function_1] with that ||| [function_2] [function_1]	count=2
function	return the form represented ||| form	count=1
function	currently loaded libs ||| loaded libs	count=1
function_arg	keyed by [arg_2] ||| [function_1] [arg_2]	count=1
arg	types ||| types	count=2
arg	x to *out* ||| x &amp;	count=1
arg	for class ||| class op form env extmap	count=1
arg	compiler when it is ||| doc string? attr map? params* body	count=1
arg	offset ||| offset	count=1
arg	maximum of n ||| n	count=2
module	evaluates expr [module] throws an ||| [module]	count=1
function	all of [function_2] ||| [function_1] [function_2]	count=2
function	using the extend ||| extend	count=1
arg	creates and installs ||| val &amp; fn tail	count=1
function	new sorted map with ||| sorted map	count=1
arg	key not ||| key	count=1
arg	n [arg_2] ||| [arg_2] [arg_1]	count=3
arg	establishes a [arg_1] [arg_2] ||| [arg_1] [arg_2]	count=2
function	rational value of ||| rationalize	count=1
function	zipper for nested ||| zip	count=1
function	[function_1] without sign-extension ||| [function_2] [function_1]	count=4
function	asin of ||| asin	count=1
arg	exprs and any ||| exprs	count=1
arg	any one of the ||| &amp;	count=2
arg	body ||| &amp; body	count=1
arg	sorted collection test ||| test end	count=2
function	of one element ||| element	count=1
arg	message ||| message	count=2
function	[function_1] [function_2] ||| [function_2] bit [function_1]	count=1
arg	given [arg_1] [arg_2] parameters perform ||| [arg_1] [arg_2] params	count=1
arg	any x [arg] else true ||| pred [arg]	count=1
module	sequence of file paths ||| java classpath	count=1
arg	true [arg] is a ||| [arg]	count=3
arg	to fn1 ||| fn1	count=1
module	of logic variables ||| core logic	count=1
arg	multimethod associated with ||| multifn dispatch val	count=2
arg	/ rsubseq for test ||| test	count=1
function	the async ||| async	count=1
function	default options ||| default options	count=1
arg	which the ||| which	count=1
function	[function_1] [function_2] for a var / ||| [function_1] [function_2] iref	count=2
function_arg	while [arg_2] ||| [function_1] [arg_2]	count=4
arg	[arg_1] collection ||| [arg_2] [arg_1]	count=6
function_arg	in [arg_2] ||| [function_1] [arg_2]	count=2
function_arg	[function_1] test ||| [arg_2] [function_1]	count=1
arg	to printwriter out as ||| out escape unicode?	count=1
function	immediate and indirect children ||| descendants	count=1
function_arg	[function_1] n default ||| [arg_2] [function_1]	count=5
function	transitive closure ||| transitive closure	count=2
arg	tr ||| tr n	count=1
module	channel and supplies ||| core async	count=1
module	clojure core match ||| core match	count=6
function	of local javadoc paths ||| local javadoc	count=1
function	the given client-side ||| client	count=1
function_arg	len-right-meter [arg_2] ||| [function_1] meter [arg_2]	count=2
function_arg	[function_1] taking a ||| [function_1] meter [arg_2]	count=1
function	sequence ||| seq	count=3
function	a value in a ||| in	count=1
arg	[arg_1] to that ||| [arg_2] [arg_1]	count=4
arg	s and returns ||| s	count=1
module	[module] with ||| [module]	count=1
module	[module_1] a is ||| [module_1] [module_2]	count=1
arg	of arguments in values ||| &amp; values	count=1
function	creates a new vector ||| vector	count=1
function	the [function] named ||| [function]	count=1
arg	obj withapply f ||| f	count=1
arg	specified length ||| length	count=1
function_arg	maybeclass [arg_2] ||| [arg_2] [function_1]	count=2
arg	optional expected type syntax ||| type provided?	count=1
arg	of f index ||| f	count=1
arg	to end ||| end	count=1
function	bound to [function_2] ||| [function_2] [function_1]	count=1
function_arg	check [arg_2] ||| [function_1] ns ns or [arg_2]	count=1
function	of longs ||| long	count=1
arg	atomically swaps the value ||| &amp;	count=1
arg	nums are in ||| x y &amp; more	count=1
function	simple database query ||| query	count=1
function	load ||| load	count=1
arg	java io writer ||| writer	count=1
module	inspector ||| inspector	count=3
arg	class name dname with ||| binder dname field : type* opts*	count=2
arg	annotations ||| &amp; args	count=2
arg	function for class ||| name type declaring class	count=1
function	bytes[] ||| bytes	count=1
arg	test s one ||| end test end	count=2
arg	single response-seq being ||| response	count=1
function	both [function_2] ||| [function_1] divide [function_2]	count=1
arg	create [arg] indent ||| [arg]	count=1
function	a full recursive ||| mexpand all	count=1
arg	coll [arg_2] ||| [arg_1] [arg_2]	count=1
function_arg	[function_1] of ||| [arg_2] [function_1]	count=7
arg	to writer ||| writer data	count=1
function_arg	[function_1] [arg_2] by ||| core match [function_1] [arg_2]	count=2
arg	[arg_1] f and ||| [arg_2] arg1 [arg_1]	count=3
function	transformer in ||| transformer	count=1
function	flattens recursive bindings ||| bindings	count=1
arg	the agent state to ||| new state &amp;	count=1
arg	with an [arg] ||| [arg] &amp;	count=1
arg	[arg_1] custom comparator ||| [arg_2] [arg_1]	count=3
module	of ||| data generators	count=1
function	possibly ||| stack element str	count=2
module	of contracts to ||| contracts	count=1
function	annotated var ||| var coverage	count=1
arg	set of functions and ||| f g &amp; fs	count=1
function	possibly ||| stack	count=2
arg	message only if ||| throwable message	count=1
arg	jar [arg_2] ||| [arg_1] [arg_2]	count=1
arg	class ||| class op form	count=1
function_arg	supplied comparator ||| by comparator &amp;	count=4
arg	if key not ||| key not	count=1
function	[function_1] from the ||| [function_2] [function_1]	count=1
arg	to newval if and ||| newval	count=1
function	[function_1] [function_2] ||| [function_1] multiply [function_2]	count=1
function_arg	one-type [arg_2] ||| [function_1] [arg_2]	count=2
arg	ctor and creates ||| ctor	count=1
function_arg	asin of [arg_2] ||| [function_1] [arg_2]	count=1
function	for two expressions ||| make	count=1
function	print [function] function ||| set pprint [function]	count=1
function	for nested sequences given ||| zip	count=1
arg	[arg] equivalent ||| x y [arg]	count=1
function	[function_1] methods of ||| [function_2] [function_1]	count=2
function_arg	[function_1] of tag ||| [arg_2] [function_1]	count=7
arg	[arg_1] comparator ||| [arg_2] [arg_1]	count=3
module	loc starting with ||| data	count=1
function	[function_1] fresh stringwriter ||| [function_1] [function_2]	count=1
module	reader ||| tools reader	count=1
arg	multimethod associated with dispatch-value ||| multifn	count=2
arg	n default 1 items ||| n s	count=1
arg	from ch ||| ch	count=1
function_arg	[function_1] object ||| [arg_2] [function_1]	count=2
arg	then evaluates func ||| string &amp; params func	count=1
arg	[arg] monotonically non-increasing ||| x [arg]	count=1
arg	[arg] equivalent ||| x [arg]	count=1
function	the value in a ||| get in	count=1
arg	message only if ||| level throwable message	count=1
arg	[arg] with the ||| function &amp; [arg]	count=1
arg	[arg_1] [arg_2] fn that takes a ||| [arg_2] arg1 [arg_1]	count=3
arg	[arg] between ||| [arg] tag	count=3
arg	executes goals until results ||| bindings &amp; goals	count=1
function_arg	patternmatrix [arg_2] ||| [function_1] [arg_2]	count=2
arg	test s one ||| test	count=2
function	returns ||| stack element	count=2
module	avl ||| data avl	count=4
function	returns the value in ||| get in	count=1
arg	[arg] class ||| [arg]	count=3
arg	or name contains ||| or	count=1
arg	[arg_1] [arg_2] ||| [arg_2] &amp; args [arg_1]	count=1
arg	atom [arg_2] ||| [arg_2] [arg_1]	count=1
arg	f applied to the ||| f	count=1
arg	swaps the ||| &amp;	count=1
function	from the named entry ||| from	count=1
arg	mean around [arg] which ||| [arg]	count=1
arg	to coerce its ||| x &amp; opts	count=2
arg	the given keys ||| keys	count=1
arg	arguments as [arg] has ||| [arg]	count=1
arg	to *out* ||| &amp;	count=1
function	non-directory entries [function_2] ||| [function_1] [function_2]	count=2
function_arg	floor of [arg_2] ||| [arg_2] [function_1]	count=1
module	monad describing ||| algo monads	count=1
arg	the gnu program argument ||| args option specs &amp; options	count=1
arg	the map with ||| map	count=1
function	*ns* to the namespace ||| ns	count=2
arg	instantiate a ||| inst of &amp;	count=1
arg	collection test s ||| test end	count=2
arg	step ||| step	count=2
arg	message using ||| level throwable message &amp;	count=1
function	object [function] will invoke ||| future [function]	count=1
function	checks a quoted form ||| check	count=1
module	the type ||| typed	count=3
function	when a mismatched loop-local ||| locals	count=1
function	keyword with the given ||| keyword	count=2
function_arg	floor of x ||| floor x	count=2
arg	map with the ||| map	count=1
arg	or a composition ||| buf or n	count=1
function	form represented by the ||| form	count=1
function	for ||| seq	count=1
function	the composition ||| comp	count=1
function	sequence ||| classpath	count=1
function	needed ||| in	count=1
function_arg	contents [arg_2] ||| [arg_2] [function_1]	count=4
arg	[arg_1] n ||| [arg_2] [arg_1]	count=6
module	uuid based ||| data	count=1
arg	epxression ||| pat	count=1
arg	body in the ||| &amp; body	count=2
arg	the rel [arg_2] ||| [arg_2] [arg_1]	count=1
module	[module_1] true if ||| [module_1] [module_2]	count=2
arg	by nothing which defaults ||| nothing which	count=1
arg	channels the ||| f buf or	count=1
arg	commands ||| command	count=1
arg	collection test s one ||| test start key end test end key	count=2
arg	and the gnu ||| &amp; options	count=1
function	zipper for nested ||| seq zip	count=1
function	a possibly unmunged ||| str	count=2
module	output channel will be ||| async	count=1
function	tagged ||| tagged	count=4
arg	logs a message using ||| level throwable message &amp; more	count=1
arg	test ||| test start key end test end key	count=2
function	with [function_2] ||| [function_2] [function_1]	count=2
arg	opts is a set ||| opts	count=1
arg	with ||| &amp; methods	count=1
arg	executes [arg_2] ||| [arg_2] [arg_1]	count=1
module	new collection in ||| collection	count=1
module	of ||| generic	count=1
function	[function] the ||| emit hygienic [function]	count=1
function	print dispatch function ||| dispatch	count=1
arg	a message only if ||| level throwable message	count=1
arg	function for class ||| declaring class parameter types exception types flags	count=1
function	read [function_2] ||| [function_2] [function_1]	count=2
function_arg	sql resultset rs ||| resultset seq rs	count=1
arg	the error-mode of ||| mode	count=1
arg	use in ||| body	count=1
function	[function_1] the method ||| [function_2] [function_1]	count=1
function	returns a possibly unmunged ||| stack	count=2
arg	more interfaces ||| &amp; bases	count=1
arg	evaluates func ||| func	count=1
arg	and the gnu ||| specs &amp; options	count=1
arg	x [arg] ||| pred [arg]	count=3
function	asserts with a ||| with	count=1
function	number ||| num	count=1
function	[function_1] options from ||| [function_1] [function_2]	count=4
arg	[arg_1] body ||| core lazy seq [arg_1] [arg_2]	count=3
arg	no-arg [arg] in parallel ||| &amp; [arg]	count=1
arg	class clojure ||| class op form env	count=1
function_arg	[function_1] array ||| [function_1] [arg_2]	count=2
arg	set1 a ||| set1	count=1
module	a [module] variable ||| core [module]	count=1
arg	is a sequence of ||| not found	count=1
arg	if [arg] names a ||| [arg]	count=1
function_arg	agent to the agents [function_1] [arg_2] ||| [function_1] [arg_2]	count=1
function	coerce to byte ||| unchecked byte	count=1
arg	loc in the hierarchy ||| loc	count=1
arg	[arg_1] commands ||| [arg_2] [arg_1]	count=1
function	of shorts ||| short	count=1
function	ddl string ||| ddl	count=1
arg	collection test s ||| start key end test end key	count=2
module	type x with ||| core typed	count=3
module	of logic variables ||| logic	count=1
function	is the composition of ||| comp	count=1
function_arg	bindnode [arg_2] ||| [function_1] [arg_2]	count=2
module	file paths from a ||| java classpath	count=1
module	class clojure reflect ||| reflect	count=3
arg	if [arg] names ||| [arg]	count=1
arg	of f index ||| f coll	count=1
arg	padding length ||| in length pad length	count=1
function	of file ||| classpath	count=1
function	transformer in terms of ||| transformer	count=1
function	class followed by zero ||| get proxy class	count=1
function	with [function_2] ||| [function_1] [function_2]	count=2
arg	the specified length starting ||| length	count=1
arg	class is specified ||| class	count=1
arg	supplied keys ||| &amp; keys	count=2
arg	a topic of ||| p topic	count=2
module	methods [module] functions ||| [module]	count=1
function	with components set ||| into	count=1
arg	expr evaluates the ||| expr	count=1
arg	[arg_1] and y ||| [arg_2] [arg_1]	count=10
function	print ||| print env	count=1
function	symbol ||| with symbol	count=1
function	namespace ||| find ns	count=1
arg	vector of two channels ||| or n f buf or	count=1
arg	expands ||| kw args? name docstring? attr map? param	count=1
module	returns a new collection ||| collection	count=2
arg	coll ||| coll &amp;	count=1
arg	channels the first of ||| buf or n f buf or n	count=1
arg	[arg_1] ch ||| [arg_2] buf or [arg_1]	count=1
function	value in a ||| in	count=2
module	new collection in ||| algo generic collection	count=1
function	is failed ||| agent	count=1
function	stack trace ||| stack trace	count=2
module	type with ||| typed	count=1
function	assumes the state to ||| fetch val	count=1
module	of ||| java	count=1
function	attempt to substitute unification ||| occurs subst	count=1
module	ast ||| tools analyzer passes jvm	count=1
arg	[arg_1] to ||| [arg_2] [arg_1]	count=14
function	single class followed ||| get proxy class	count=1
arg	syntax and ||| expected type provided?	count=1
arg	or a composition ||| or	count=1
arg	to ||| &amp; colls	count=1
function	single class ||| get proxy class	count=1
function	returns the first item ||| first	count=1
function	prints ||| print	count=5
function_arg	the [function_1] [arg_2] ||| [function_1] [arg_2]	count=39
function	connection [function] there ||| db [function]	count=1
module	a goal to ||| core logic	count=2
function	is the juxtaposition ||| juxt	count=1
function	checks a quoted form ||| check form info	count=1
arg	a clojure form ||| form env opts	count=1
function	message to stop the ||| thread stopper	count=1
function	of all but the ||| drop	count=1
arg	the agent state ||| state	count=1
arg	[arg_1] with java ||| [arg_2] [arg_1]	count=4
arg	redefines vars while executing [arg_1] [arg_2] ||| core with redefs bindings [arg_1] [arg_2]	count=1
module	based on uniform ||| data	count=1
arg	for class ||| type declaring class flags	count=1
function_arg	[function_1] x and ||| [function_1] int [arg_2]	count=2
function	[function_1] ns ||| [function_2] [function_1]	count=6
module	contracts to ||| contracts	count=1
module	class clojure core ||| core	count=7
module	analyzes ||| tools analyzer jvm	count=1
arg	[arg] fn ||| [arg] arg1 arg2 arg3	count=1
function	unmunged string representation of ||| element	count=2
function_arg	returns [function_1] [arg_2] ||| [function_1] [arg_2]	count=5
arg	step [arg_2] ||| core range [arg_2] [arg_1]	count=2
function_arg	evaluates [arg_2] ||| [function_1] [arg_2]	count=1
arg	a sorted collection test ||| key end test end	count=2
function_arg	the var [arg_2] ||| [arg_2] [function_1]	count=1
arg	function for class clojure ||| class field op form env extmap	count=1
arg	test ||| test &amp;	count=1
arg	and the gnu ||| specs &amp;	count=1
module	of member type ||| core typed	count=1
function	non-directory entries in the ||| filenames in jar	count=1
arg	a string if ||| x	count=1
module	during type checking ||| typed	count=2
function	reads the next ||| read	count=2
function	all immediate children ||| children	count=1
arg	database [arg] ||| [arg] spec option map	count=3
arg	sql commands on the ||| spec transaction? sql command &amp;	count=1
arg	of x ||| x &amp;	count=1
arg	func passing in ||| func	count=1
function_arg	[function_1] loc in ||| [arg_2] [function_1]	count=4
function_arg	constructor taking a ||| &gt;constructor m#	count=1
function_arg	[function_1] function af ||| pipeline [function_1] n to [arg_2] from close?	count=4
arg	if the value ||| value	count=2
function	ddl string for creating ||| table ddl	count=1
module	returns an object ||| core	count=1
arg	the jar file ||| jarfile entry name	count=1
arg	keyval = > key ||| &amp; keyvals	count=3
function_arg	[function_1] of value ||| [function_1] s [arg_2]	count=1
function	[function_1] of bytes ||| [function_2] [function_1]	count=2
function	a sequence ||| loader classpath	count=1
function_arg	between [arg_2] ||| [arg_2] [function_1]	count=2
module	a channel to ||| core async	count=1
module	extension to tools analyzer ||| tools analyzer	count=1
function	substitute unification bindings ||| occurs subst	count=1
arg	evaluates func ||| string &amp; params func	count=1
arg	with supplied keys ||| keys	count=1
arg	set of functions and ||| h &amp; fs	count=1
arg	if [arg_2] ||| [arg_2] [arg_1]	count=3
arg	expression or stringable ||| or pattern	count=2
module	a goal to run ||| core logic	count=1
module	source channel and ||| async	count=1
function	to char ||| unchecked char	count=1
module	sequence ||| zip	count=1
function	join ||| join	count=1
arg	expands to ||| kw args? name docstring? attr map? param :	count=1
arg	in the jar file ||| jarfile entry name	count=1
function	type checks a quoted ||| check form info	count=1
arg	[arg] data ||| data [arg]	count=3
arg	column specs [arg_2] ||| [arg_2] [arg_1]	count=8
function	object [function] will ||| future [function]	count=1
arg	m-result nil ||| m expr	count=2
function	tests if ||| instance?	count=1
function	declaration from ||| decl from jarfile entry	count=1
arg	with key by ||| key	count=1
function_arg	[function_1] [arg_2] parallelism ||| [function_1] [arg_2]	count=4
function	validator-fn ||| validator	count=1
arg	[arg] with ||| n to [arg] from	count=1
arg	item ||| item	count=2
arg	sorted collection test s ||| key end test end key	count=2
function_arg	[function_1] prob ||| [arg_2] [function_1]	count=1
function_arg	[function_1] [arg_2] ||| [function_1] comparator [arg_2]	count=3
module	of contracts ||| core contracts	count=1
arg	that z [arg_2] ||| [arg_2] y [arg_1]	count=1
arg	a function of ||| f	count=1
function_arg	[function_1] by val ||| [function_1] key [arg_2]	count=1
function	paths from a ||| loader classpath	count=1
function_arg	string s ||| string opts s	count=2
arg	the [arg_2] ||| [arg_2] x y [arg_1]	count=1
arg	commands on ||| command &amp;	count=1
function_arg	and y ||| subtract x y	count=1
arg	nums [arg_2] ||| [arg_2] [arg_1]	count=2
arg	qualified method msym ||| msym	count=1
arg	test s one ||| start test start key end test end	count=2
function_arg	sum [arg_2] ||| [function_1] x y &amp; [arg_2]	count=1
arg	output ||| output	count=1
arg	error-mode ||| mode keyword	count=1
arg	string debug-string ||| string frm	count=2
function	waiting stream a ||| waiting stream check	count=1
module	memoization ||| memoize	count=2
arg	but supports optional ||| binding : type? init* exprs*	count=1
function	field ||| -&gt;field	count=1
arg	[arg_1] atom ||| [arg_2] [arg_1]	count=2
function	and optional supplied ||| keyfn by	count=1
arg	takes a map of ||| map &amp;	count=1
arg	[arg] transient ||| coll [arg]	count=1
function	sequence of member ||| seq	count=1
function_arg	executes [arg_2] ||| [function_1] db [arg_2]	count=5
arg	sorted collection test ||| end test	count=2
arg	action ||| action	count=1
function	a quoted form and ||| check	count=1
module	type environment to *out* ||| core typed	count=1
arg	the ||| &amp;	count=41
function	flattens recursive bindings ||| flatten bindings	count=1
arg	if it can find ||| x	count=1
module	and ||| core	count=22
function_arg	least of [arg_2] ||| [arg_2] [function_1]	count=2
module	macro expansion of ||| tools macro	count=1
function_arg	supplied [arg_2] ||| [arg_2] [function_1]	count=6
function	by a string ||| by	count=1
function_arg	[function_1] an object ||| [function_1] [arg_2]	count=1
arg	executes goals until a ||| &amp; goals	count=1
arg	executes goals until a ||| goals	count=1
module	the given type ||| core typed	count=1
arg	[arg_1] [arg_2] *out* ||| out [arg_2] [arg_1]	count=1
function	column ||| column	count=1
function_arg	[function_1] location loc ||| [function_1] auto [arg_2]	count=1
module	of file paths from ||| java classpath	count=1
module	class clojure core memoize ||| core memoize	count=1
module	a sequence ||| classpath	count=1
function	sequence of file paths ||| loader classpath	count=1
arg	the gnu ||| args option specs &amp;	count=1
arg	the colls is exhausted ||| &amp; colls	count=2
function	a version of loop ||| length loop	count=1
arg	returns the rel ||| xrel	count=1
function_arg	the namespace [arg_2] ||| [arg_2] [function_1]	count=9
arg	[arg_1] colls is ||| [arg_2] [arg_1]	count=8
arg	given transport ||| transport timeout	count=1
arg	pub or a topic ||| topic	count=1
function_arg	the next [arg_2] ||| [function_1] [arg_2]	count=4
arg	in values ||| values	count=1
arg	and the ||| specs &amp;	count=1
function	an anonymous committed choice ||| fnu	count=1
arg	connection and a ||| db	count=1
function	declarations ||| find namespaces on	count=1
arg	that returns the first ||| &amp;	count=1
arg	the items in coll ||| coll	count=4
arg	x to ||| x	count=1
function	juxtaposition of those fns ||| juxt	count=1
arg	equal ||| max equal	count=1
arg	the error-mode ||| mode	count=1
arg	is ||| v	count=1
function	an optional single class ||| proxy class	count=1
function	snapshot of ||| snapshot	count=1
module	paths from a ||| classpath	count=1
arg	the ||| f &amp;	count=1
module	type representing ||| core typed	count=1
arg	as [arg] has the ||| [arg]	count=1
function	return the form ||| form	count=1
arg	[arg] is ||| [arg]	count=6
module	member type ||| core typed	count=1
arg	port ||| port	count=5
arg	to a topic of ||| topic ch close?	count=1
function	zipper for nested ||| seq	count=1
arg	the gnu program argument ||| option specs &amp;	count=1
arg	nil [arg] ||| expr [arg]	count=3
function	column [function_2] ||| [function_2] [function_1]	count=1
function	possibly ||| stack element	count=2
function_arg	[function_1] protocol ||| [function_1] [arg_2]	count=2
function	default options from a ||| get default options	count=1
function	print the filter set ||| print filterset	count=1
function_arg	[function_1] supplied collection ||| [function_1] [arg_2]	count=1
function	paths ||| loader classpath	count=1
function	clear ||| clear	count=1
arg	f applied ||| f	count=1
function	bound to the value ||| with	count=1
arg	sum of x and ||| x	count=1
arg	and installs a ||| fn tail	count=1
module	return the difference of ||| algo generic arithmetic	count=1
function	sorted set with ||| sorted set	count=1
arg	values ||| &amp; values	count=1
function_arg	non-namespaced symbol [arg_2] ||| [function_1] [arg_2]	count=1
arg	collection test s ||| key end test end	count=2
arg	the metadata ||| metadata	count=1
function_arg	[function_1] [arg_2] ||| [function_1] db [arg_2]	count=5
function	nil ||| get	count=1
module	based ||| data generators	count=1
function	new sorted set ||| sorted set	count=2
arg	newval if and ||| newval	count=1
function	the nth ||| nth	count=1
function	sequences ||| seq zip	count=1
function	[function_1] is chosen ||| [function_2] [function_1]	count=3
arg	difference of x and ||| x	count=1
module	is a [module] variable ||| core [module]	count=1
function	class followed by zero ||| class	count=1
function	negation of ||| negate	count=1
arg	test ||| test &amp; body	count=1
arg	[arg_1] val ||| [arg_1] [arg_2]	count=3
module	uniform distribution of low ||| data	count=1
arg	form to ||| form	count=1
function_arg	[function_1] [arg_2] a ||| [function_1] [arg_2]	count=16
module	string on ||| string	count=1
arg	template expression ||| expr &amp; args	count=1
arg	yields ||| oldform	count=1
arg	val ||| val	count=6
function	array of booleans ||| boolean array	count=3
function_arg	[function_1] coll which ||| [arg_2] [function_1]	count=7
function	potentially-ragged 2-dimensional [function_2] ||| [function_2] [function_1]	count=12
function	[function_1] from the ||| [function_1] [function_2]	count=1
function	class ||| class	count=2
module	unmunged string representation of ||| main	count=1
arg	[arg_1] [arg_2] new-state ||| [arg_1] [arg_2]	count=4
arg	for class ||| declaring class	count=2
arg	writer ||| writer data &amp;	count=1
module	returns a possibly ||| main	count=1
arg	if it can ||| x	count=1
arg	a [arg] between ||| [arg] tag	count=1
arg	asynchronously puts a ||| on caller?	count=1
arg	printwriter out as ||| out escape unicode?	count=1
arg	a sorted collection test ||| key end test end key	count=2
arg	function for class clojure ||| class op	count=1
module	returns a sequence of ||| java	count=1
arg	channels ||| f buf or n	count=1
module	taken from the channel ||| async	count=1
arg	[arg_1] [arg_2] provided as arguments have ||| core bound? [arg_1] [arg_2]	count=1
arg	class clojure ||| t	count=1
function_arg	val returns a new [function_1] [arg_2] ||| data priority-map [function_1] by [arg_2]	count=6
function_arg	[function_1] object subject ||| [arg_2] [function_1]	count=1
function	long ||| unchecked	count=3
function	of bindings pushed ||| bindings	count=1
arg	factory function for class ||| class parameter types exception types flags	count=1
function_arg	[function_1] that table ||| [function_1] [arg_2]	count=1
arg	d is the rest ||| d	count=1
function_arg	appended to [arg_2] ||| [arg_2] [function_1]	count=1
function	gets the [function_2] ||| [function_2] [function_1]	count=1
function	pop one set ||| pop thread	count=1
function	extracts metadata in the ||| metadata	count=1
arg	nil if key not ||| map key not	count=1
arg	g in the ||| g	count=1
function	of ||| loader classpath	count=1
arg	sc must be ||| sc start test	count=2
arg	supports optional ||| binding : type? init* exprs*	count=1
function	pretty print [function_2] ||| [function_1] [function_2] function &amp;	count=1
function	a zipper for ||| zip	count=1
function	print the ||| print filterset	count=1
function	arguments are equal ||| =	count=1
arg	representation of a stacktraceelement ||| el	count=2
arg	writes data to writer ||| writer data &amp;	count=1
arg	xf ||| xf	count=1
module	goal ||| core logic	count=7
function	string ||| write str	count=1
arg	to printwriter out ||| x out escape unicode?	count=1
function	the [function] ||| [function]	count=15
module	the type environment to ||| typed	count=1
arg	start ||| start	count=1
function_arg	[function_1] is constituted ||| [arg_2] [function_1]	count=1
function	a new sorted map ||| sorted map	count=1
function	check ||| check	count=1
arg	non-nil [arg_1] [arg_2] monotonically non-decreasing order otherwise ||| [arg_1] [arg_2]	count=1
arg	[arg_1] with ||| out [arg_2] [arg_1]	count=1
arg	expands to clojure ||| kw args? name docstring? attr map?	count=1
function	rational value ||| rationalize	count=1
rep	type [function_arg_2] ||| [function_arg_2] [module_1]	count=1
arg	any x [arg] else nil ||| pred [arg]	count=1
arg	the ||| idx idx2 &amp;	count=7
arg	functions and returns a ||| &amp; fs	count=2
module	type checks ||| core typed	count=1
arg	runs reader g in ||| g	count=1
arg	a success ||| w success	count=1
function_arg	closure of a ||| closure g	count=1
arg	[arg] index ||| [arg] idx ret	count=3
function_arg	[function_1] [arg_2] ||| [function_1] cancelled? [arg_2]	count=1
arg	by the compiler when ||| doc string? attr map? params* body + attr	count=1
function_arg	by the [arg_2] ||| [function_1] [arg_2]	count=2
arg	prob 0 0 - ||| prob	count=1
arg	func passing in the ||| func	count=1
module	of file ||| java classpath	count=1
arg	the action ||| action	count=1
arg	compiler when it ||| doc string? attr map? params* body	count=1
arg	or a composition ||| buf or	count=1
function	file paths ||| classpath	count=1
arg	collection test s ||| test	count=2
arg	for class clojure ||| class	count=2
function	unmunged string representation ||| element	count=2
function_arg	conjoined to [arg_2] ||| [function_1] [arg_2]	count=1
function	ddl string for ||| table ddl	count=1
module	contracts to existing ||| core contracts	count=1
arg	the ||| x y &amp; more	count=1
function_arg	[function_1] the nums ||| [arg_2] [function_1]	count=2
function	hash map with supplied ||| hash map	count=1
function_arg	key [arg_2] ||| [function_1] [arg_2]	count=1
arg	fn ||| fn name	count=1
function_arg	sum of [arg_2] ||| [arg_2] [function_1]	count=1
module	in the macro ||| tools macro	count=1
arg	the gnu program ||| &amp; options	count=1
arg	when [arg] is ||| [arg]	count=1
function_arg	[function_1] data ||| [arg_2] [function_1]	count=1
function	byte ||| unchecked byte	count=2
arg	expands ||| kw args? name docstring?	count=1
arg	the error-mode of ||| mode keyword	count=1
function	int ||| int	count=6
arg	the agent state ||| new state	count=1
function	all but [function_2] ||| [function_2] [function_1]	count=1
module	load ||| core typed	count=1
arg	state [arg_2] ||| [arg_2] [arg_1]	count=1
module	string representation of ||| repl	count=1
arg	keyval = ||| keyvals	count=3
function	takes a ||| &lt;!	count=1
arg	factory function for class ||| class	count=5
function_arg	reduced [arg_2] ||| [arg_2] [function_1]	count=1
module	returns the empty ||| core	count=1
function	current value of ||| pr	count=1
arg	[arg_1] by y ||| [arg_1] [arg_2]	count=6
arg	multimethod name in ||| name &amp;	count=1
function	no two of the ||| distinct?	count=1
arg	factory function for class ||| class field op form	count=1
arg	and yields a seqable [arg_1] [arg_2] ||| [arg_1] [arg_2]	count=4
arg	[arg_1] containing sql ||| [arg_1] spec option map [arg_2]	count=1
function	[function_1] the namespace ||| [function_2] [function_1]	count=1
function	with the [function_1] [function_2] function ||| [function_1] [function_2] function &amp;	count=1
function	the agent's state ||| release pending sends	count=1
arg	for class ||| declaring class parameter	count=1
function	reset ||| reset	count=1
function	a collection such ||| firsto	count=1
function_arg	[function_1] function af ||| [arg_2] [function_1]	count=4
arg	x [arg] else ||| pred [arg]	count=3
module	file ||| java classpath	count=2
arg	returns x ||| x	count=1
arg	a using an ||| a	count=1
function_arg	local [arg_2] ||| [function_1] [arg_2]	count=2
function	representation ||| element	count=2
function	nested sequences given a ||| seq zip	count=1
function	sorted ||| sorted	count=2
module	of several [module] operations as ||| [module]	count=1
arg	a single response-seq being ||| response timeout	count=1
function	/ loop and ||| loop	count=1
function	options from ||| options	count=1
module	creates and returns ||| core	count=1
arg	given thread ||| thread	count=1
arg	with the ||| &amp;	count=3
function	[function_1] column ||| [function_1] [function_2]	count=1
function	metadata on the atom ||| atom	count=1
function	[function] field ||| [function]	count=1
function	to read a ||| read file	count=1
arg	a namespace / sa ||| &amp; opt	count=1
arg	of n items each ||| n	count=1
module	create a ||| data	count=1
arg	positional factory function for ||| op form env children	count=1
module	appended ||| core logic	count=1
module	type with ||| core typed	count=1
arg	the file ||| f &amp;	count=1
arg	or ||| string or	count=1
arg	executes body presumably ||| body	count=1
function_arg	[function_1] sql ||| [function_1] db [arg_2]	count=1
arg	evaluates func passing ||| string &amp; params func	count=1
arg	fn ||| fn	count=1
module	[module] after running ||| [module]	count=3
function	the file ||| file	count=1
arg	[arg_1] table name ||| [arg_2] [arg_1]	count=1
function_arg	the string [arg_2] ||| [arg_2] [function_1]	count=2
arg	that dispatches on ||| &amp; args env	count=3
module	define local [module] that are ||| [module]	count=1
arg	test ||| start key end test	count=2
arg	loc in the ||| loc	count=1
arg	as per reduce of [arg_1] [arg_2] init ||| [arg_2] [arg_1]	count=1
arg	of a fn ||| fn name	count=1
function	[function_1] bindings ||| [function_1] [function_2]	count=1
arg	test s ||| test	count=2
arg	executes goals until ||| goals	count=3
module	object which will ||| data fressian	count=1
arg	[arg] fn that ||| [arg] arg1 arg2 arg3	count=1
arg	[arg_1] [arg_2] ||| [arg_1] [arg_2]	count=415
function	min-history ||| min history	count=1
arg	keyfn [arg_2] ||| [arg_2] [arg_1]	count=3
function	resultset as an argument ||| resultset	count=1
function	of default options ||| default options	count=1
arg	object [arg] to the ||| &amp; [arg]	count=1
function	create a vec with ||| vec	count=1
arg	the same type ||| &amp;	count=1
module	generic [module_2] ||| [module_2] [module_1]	count=4
arg	with supplied keys using ||| keys	count=1
arg	sets the ||| &amp;	count=1
function	to analyze and an ||| analyze	count=1
arg	mexpr ||| expr mexpr	count=1
function	the supplied ||| by	count=4
function	representation of a ||| element	count=2
function_arg	[function_1] corresponding vals ||| [arg_2] [function_1]	count=1
arg	[arg_1] the value ||| [arg_2] [arg_1]	count=1
function	the ddl string ||| create table ddl	count=1
arg	u ||| u	count=1
arg	[arg_1] are in ||| [arg_2] [arg_1]	count=6
function	[function_1] a watch ||| [function_2] [function_1]	count=1
function_arg	set [arg_2] ||| [function_1] by comparator [arg_2]	count=2
arg	[arg_1] replacement ||| string replace [arg_1] [arg_2]	count=2
arg	channels the first of ||| t buf or n f buf or	count=1
function	returns a new ||| sorted	count=1
function_arg	appended to [arg_2] ||| [function_1] x [arg_2]	count=1
arg	every x [arg] else ||| pred [arg]	count=1
arg	vector of two channels ||| buf or n f buf or n	count=1
arg	the given keys ||| coll &amp; keys	count=1
module	read [module] evaluate the ||| [module]	count=2
function	the [function] named by ||| [function]	count=1
arg	binds name to ||| name &amp; forms	count=2
function	zipper for nested sequences ||| zip	count=1
function	info ||| info	count=1
arg	from input ||| input	count=1
module	[module] call ||| [module]	count=2
function_arg	agent to the agents [function_1] [arg_2] ||| [function_1] [arg_2] agents	count=1
function	[function_1] [function_2] ||| [function_1] [function_2]	count=331
function	inserts the ||| insert	count=1
function	ns ||| ns	count=6
function_arg	[function_1] tag either ||| [arg_2] [function_1]	count=3
function	the java sql resultset ||| resultset seq	count=1
arg	of n items ||| n	count=1
function	returns ||| zip	count=1
arg	agent state [arg_2] ||| [arg_2] [arg_1]	count=1
module	the output channel ||| core async	count=1
function	a depth-first post-order ||| postwalk	count=1
arg	classloader ||| loader	count=1
arg	collection test ||| test end	count=2
function	version of loop that ||| length loop	count=1
arg	of two channels the ||| f buf or	count=1
function	replacement ||| re quote replacement	count=1
rep	returns a [module_1] [function_arg_2] ||| [module_1] [function_arg_2]	count=2
function	coerce to char ||| char	count=2
arg	an object of the ||| &amp;	count=1
function_arg	the supplied [arg_2] ||| [arg_2] [function_1]	count=4
function_arg	supplied [arg_2] ||| [function_1] comparator [arg_2]	count=1
arg	of the [arg_2] ||| core bound? [arg_1] [arg_2]	count=1
module	paths from a ||| java	count=1
function_arg	future [arg_2] ||| [arg_2] [function_1]	count=1
function	both [function_2] ||| [function_1] [function_2]	count=2
arg	evaluates func passing ||| sql string &amp; params func	count=1
arg	[arg_1] debug-string ||| [arg_2] [arg_1]	count=3
function_arg	datatype [arg_2] ||| [arg_2] [function_1]	count=2
arg	positional factory function ||| op form	count=1
function	no two ||| distinct?	count=1
arg	p etc or ||| or n	count=1
function	map keys ||| keys	count=1
function	[function_1] initialize all ||| [function_1] [function_2]	count=1
arg	exception to the depth ||| depth	count=1
arg	installs a new method ||| &amp; fn tail	count=1
function_arg	[function_1] prob 0 ||| [function_1] [arg_2]	count=1
module	a [module] the ||| algo [module]	count=1
function	mappings using the supplied ||| by	count=2
function	repeating for ||| as &gt;	count=1
arg	[arg_1] colls is ||| [arg_1] [arg_2]	count=8
module	of low ||| data generators	count=1
arg	the value ||| found	count=1
function_arg	right of [arg_2] ||| [function_1] locs [arg_2]	count=1
arg	the contents [arg] closing when ||| [arg]	count=1
function	return last ||| last index	count=1
arg	supplied keys using ||| &amp; keys	count=1
arg	then ||| then	count=1
arg	item as the ||| item	count=2
function	bound to a ||| with	count=1
function_arg	map with [arg_2] ||| [arg_2] [function_1]	count=8
arg	topic of a pub ||| topic ch	count=1
arg	[arg_1] x ||| doto [arg_2] [arg_1]	count=1
module	in which *out* is ||| core	count=1
arg	returns the ref ||| ref	count=2
arg	[arg] into ||| port [arg] fn1 on	count=2
arg	two channels the ||| t buf or n f buf or n	count=1
arg	m ||| m	count=2
arg	test ||| test	count=8
function	sequence of all but ||| drop	count=1
function	object from the string ||| string	count=1
function	a list begun ||| end list	count=1
arg	[arg_1] with replacement ||| [arg_2] [arg_1]	count=4
arg	success ||| success	count=1
arg	given a root sequence ||| root	count=1
arg	the base ||| base which m plus	count=1
arg	a sorted collection test ||| test	count=2
function	of all namespaces ||| all ns	count=1
arg	java io reader ||| reader &amp; options	count=1
module	channel and returns a ||| core async	count=1
function	resulting from adding all ||| conj	count=1
function	a zipper for ||| seq	count=1
module	ops [module] ||| [module]	count=1
arg	the jar file ||| jarfile entry	count=1
function	bitwise shift [function_2] ||| [function_2] [function_1]	count=2
arg	and installs ||| &amp; fn tail	count=1
module	low and ||| data generators	count=1
function_arg	namespace named by ||| ns name	count=1
function_arg	[function_1] f ||| [arg_2] [function_1]	count=6
arg	to a topic of ||| p topic ch close?	count=1
arg	object of the same ||| &amp; args	count=1
module	channel to ||| core async	count=1
function	to read a ns ||| read ns	count=2
function	possibly unmunged string ||| stack element str	count=2
rep	sorted [function_arg_2] ||| [module_1] [function_arg_2]	count=4
module	possibly unmunged string representation ||| main	count=1
function	the contents of ||| vec	count=1
function	of a tagged ||| tagged	count=1
arg	symbol [arg] ||| [arg]	count=3
function	a ||| element str	count=4
arg	commands ||| command &amp;	count=1
function_arg	[function_1] value ||| [arg_2] [function_1]	count=1
arg	class ||| class flags	count=1
arg	namespace and name ||| ns name	count=6
arg	vectors given a root ||| root	count=1
function	sets ||| sets	count=1
module	json data ||| data json	count=2
arg	step to the mexpr ||| expr mexpr	count=1
function	of a ||| element	count=2
arg	[arg] value true ||| [arg]	count=1
arg	the cache ||| cache	count=2
rep	clojure reflect [function_arg_2] ||| [module_1] [function_arg_2]	count=2
function	max-history of a ||| max history	count=1
module	[module_1] ast ||| [module_1] [module_2]	count=4
function_arg	post-ordered walk [arg_2] ||| [arg_2] [function_1]	count=1
function	list begun with begin-closed-list ||| list	count=1
arg	structure of data ||| data	count=1
arg	accumulate data on the ||| empty accumulator	count=1
module	and supplies them ||| core async	count=1
arg	[arg] index named ||| [arg] idx ret	count=3
function_arg	local taking a ||| &gt;local m#	count=1
arg	y ||| y	count=8
arg	optional expected type syntax ||| expected type provided?	count=1
function	[function_1] shift right ||| [function_2] [function_1]	count=1
function	composition of ||| comp	count=1
arg	root sequence ||| root	count=1
function_arg	[function_1] from port ||| [function_1] [arg_2]	count=2
function	returns a snapshot of ||| snapshot	count=1
function	special ||| special	count=1
arg	that returns the ||| &amp; ps	count=1
function	zero-type ||| -&gt;zero-type	count=1
arg	cf ||| cf	count=1
function	[function_1] left ||| [function_2] [function_1]	count=2
function	representation ||| stack element str	count=2
arg	connection and [arg_2] ||| [arg_2] [arg_1]	count=1
module	to right [module] ||| [module]	count=3
function	[function_1] a watch ||| [function_1] [function_2]	count=1
function	fn that would apply ||| get method	count=1
module	zipper for nested ||| zip	count=1
module	distribution of low and ||| data generators	count=1
function	string representation ||| str	count=2
function	product ||| multiply	count=1
function	a quoted form ||| check	count=1
arg	[arg_1] a table ||| [arg_1] spec [arg_2]	count=1
function	record ||| record	count=1
arg	evaluates body in the ||| &amp; body	count=1
function	aliases for the ||| ns aliases	count=1
function_arg	by [arg_2] ||| [function_1] [arg_2]	count=1
function_arg	define a [function_1] [arg_2] ||| algo monads [function_1] base [arg_2]	count=3
arg	base ||| base	count=3
arg	end of the input ||| input offset	count=1
arg	body only the ||| body	count=1
function	[function_1] doubles ||| [function_2] [function_1]	count=2
arg	of functions ||| f g &amp; fs	count=1
function	takes ||| &lt;!!	count=1
arg	the given ||| &amp; args	count=1
module	special ops [module] after ||| [module]	count=1
module	goal that ||| core logic	count=1
arg	of the file they ||| &amp;	count=1
module	[module_1] a is ||| [module_2] [module_1]	count=1
arg	of a stacktraceelement ||| el	count=2
arg	the item ||| item	count=2
function	a ||| loader	count=2
arg	or stringable thing return ||| or	count=1
module	creates a channel with ||| async	count=1
arg	nil and yields a [arg_1] [arg_2] ||| core lazy seq [arg_1] [arg_2]	count=4
arg	a sorted collection test ||| start key end test	count=2
arg	metadata ||| metadata	count=1
function_arg	[function_1] corresponding vals ||| [function_1] keys [arg_2]	count=1
arg	[arg_1] vars ||| core bound? [arg_1] [arg_2]	count=4
function	file ||| file	count=1
arg	expression plus the action ||| action	count=1
arg	test s one of ||| start test start key end test end	count=2
arg	for the argument ||| class or	count=1
arg	apply f its-current-meta args ||| args	count=1
function	specified by a ||| by	count=1
function	new ||| sorted	count=1
function_arg	one-type taking a ||| &gt;one type m#	count=1
arg	if needed ||| docstring? attr map? references*	count=1
module	on uniform distribution of ||| data generators	count=1
function	the first ||| first	count=1
arg	a set of functions ||| f g h &amp; fs	count=1
arg	executes body ||| body	count=1
module	graph that ||| algo graph	count=1
function_arg	contents of [arg_2] ||| [arg_2] [function_1]	count=5
arg	a set of functions ||| &amp; fs	count=2
function	the value in a ||| in	count=1
function	[function_1] [function_2] function ||| [function_1] [function_2]	count=1
arg	completed ||| clauses	count=1
function_arg	methods of [arg_2] ||| [function_1] [arg_2]	count=1
function	the contents of ||| to	count=2
function	to analyze ||| analyze	count=1
arg	vector of two channels ||| or n f buf or n	count=1
module	a possibly unmunged string ||| main	count=1
function	[function_1] the namespace ||| [function_1] [function_2]	count=1
arg	reads all its ||| &amp; opts	count=1
arg	monad m into a ||| m plus	count=1
arg	random permutation [arg] ||| [arg]	count=1
arg	is a sequence ||| not	count=1
module	channel to a ||| core async	count=1
arg	m into ||| m	count=1
function_arg	closure of ||| closure g	count=1
arg	asynchronously takes a val ||| on caller?	count=1
arg	the corresponding parameters ||| params &amp;	count=1
arg	cache system ||| cache	count=1
arg	colls is exhausted ||| colls	count=2
arg	success ||| w success	count=1
module	ensures [module] ||| [module]	count=1
function	declarations in clojure ||| find	count=1
arg	evaluates body in ||| &amp; body	count=1
function	lazy ||| lazy	count=2
module	returns a possibly unmunged ||| main	count=1
arg	the monad operations ||| operations	count=1
module	create a ||| data generators	count=1
arg	tr a ||| tr	count=1
function_arg	asin [arg_2] ||| [function_1] [arg_2]	count=1
module	source channel and returns ||| core async	count=1
function_arg	[function_1] tag ||| [arg_2] [function_1]	count=5
function	ceil of ||| ceil	count=1
arg	returns true if all [arg_1] [arg_2] provided as arguments have ||| [arg_1] [arg_2]	count=1
module	analyzes ||| analyzer jvm	count=1
arg	an ||| relative to n	count=1
arg	calls cf ||| cf	count=1
arg	that dispatches ||| &amp; args	count=2
function	of ||| stack	count=2
arg	annotations ||| exprs &amp; maybe ann	count=1
function	for [function_2] ||| [function_2] [function_1]	count=1
function	the log ||| log	count=1
arg	[arg_1] [arg_2] ||| into array&gt; [arg_2] [arg_1] syn javat cljt coll	count=16
function	returns a possibly ||| element str	count=2
arg	start inclusive [arg_2] ||| [arg_1] [arg_2]	count=1
module	rows to [module] ||| [module]	count=3
function_arg	write an [arg_2] ||| [arg_2] [function_1]	count=10
arg	that dispatches [arg_2] ||| [arg_1] [arg_2]	count=1
arg	topic of a ||| p topic	count=2
arg	from a classloader ||| loader	count=1
arg	a fn ||| fn name	count=1
function_arg	[function_1] coll which ||| [function_1] array 2d [arg_2]	count=3
function	from a ||| classpath	count=1
arg	n ||| n bindings	count=1
arg	channels the first of ||| or n f buf or	count=1
arg	of two channels the ||| buf or n	count=1
function_arg	stop the [arg_2] ||| [function_1] [arg_2]	count=1
module	sequence of file paths ||| java	count=1
arg	to 1 and end ||| end	count=1
arg	of location loc left-to-right ||| loc	count=1
arg	the file they represent ||| f &amp;	count=1
function	single class followed ||| proxy class	count=1
function	initialize all ||| if needed	count=1
function	on the loop ||| validate loop	count=1
function_arg	[function_1] namespace and ||| [function_1] [arg_2]	count=1
arg	the given fntail which ||| fntail	count=1
module	create a uuid ||| data	count=1
function	info ||| infof	count=1
function	in a ||| assoc in	count=1
arg	its contents ||| opts	count=1
function	a stack trace ||| trace	count=1
function	a quoted form ||| check form info	count=1
arg	the value [arg_2] ||| [arg_2] f x y [arg_1]	count=3
module	type representing ||| typed	count=2
arg	the bindings ||| bindings	count=1
arg	to that ||| &amp;	count=1
arg	[arg_1] from ch ||| [arg_2] [arg_1]	count=7
function	from the named ||| from jarfile entry	count=1
module	and supplies them to ||| core	count=2
arg	that returns ||| &amp; body	count=1
function	string ||| element str	count=2
arg	heterogeneous vectors ||| fixed* type ... bound	count=1
function	obj [function] object ||| [function]	count=1
function_arg	[function_1] [arg_2] ||| [function_1] key [arg_2]	count=1
function	an empty ||| empty	count=2
function_arg	[function_1] tr a ||| [function_1] [arg_2]	count=2
arg	length starting [arg_2] ||| [arg_2] [arg_1]	count=4
module	monad and return ||| algo monads	count=1
arg	lists of n items ||| n	count=1
arg	sets the error-mode ||| a mode keyword	count=1
function	[function_1] bindings pushed ||| [function_1] [function_2]	count=1
arg	[arg_1] fn1 ||| [arg_1] [arg_2]	count=2
arg	fns ||| fns	count=1
function	return the ddl string ||| ddl	count=1
function	the namespace ||| ns	count=3
function	product of ||| multiply	count=1
module	on ||| generators	count=1
module	the return type ||| typed	count=1
module	create ||| generators	count=1
arg	to a topic ||| p topic ch	count=1
function	unification bindings between two ||| make occurs	count=1
arg	the value ||| &amp;	count=1
function	reads the first ||| read	count=1
function	recursive bindings in ||| bindings	count=1
arg	function for class clojure ||| class op form env extmap	count=1
arg	an object of the ||| &amp; args	count=1
arg	3a: ||| matrix col ocrs	count=1
arg	length starting at the ||| length	count=1
function	stack [function_2] ||| [function_2] [function_1]	count=2
arg	have the ||| &amp;	count=1
arg	two channels the first ||| f buf or n	count=1
module	transient collection [module] return ||| [module]	count=1
function_arg	[function_1] [arg_2] ||| [function_1] m k [arg_2]	count=3
function	the currently loaded libs ||| loaded libs	count=1
function	the aliases for ||| aliases	count=1
function	takes a ||| &lt;!!	count=1
function	to char ||| char	count=2
arg	applying f to ||| f	count=1
function	from the named ||| from	count=1
arg	x by ||| x	count=2
function	it's already a pretty ||| get pretty	count=1
function_arg	ceil of [arg_2] ||| [arg_2] [function_1]	count=1
function	[function_1] of shorts ||| [function_2] [function_1]	count=2
arg	proxy instance and returns ||| proxy	count=1
function_arg	[function_1] object to ||| [function_1] [arg_2]	count=1
function	representation of a ||| stack element str	count=2
function	of ||| element str	count=2
rep	channel [function_arg_2] ||| [module_1] [function_arg_2]	count=4
module	of member type x ||| typed	count=1
arg	sc must be a ||| sc start test	count=2
arg	structure where ks ||| ks	count=1
function	failed ||| agent error	count=2
arg	sql commands on the ||| spec transaction? sql command &amp; sql commands	count=1
arg	threads ||| forms	count=1
function_arg	trace of [arg_2] ||| [function_1] [arg_2]	count=3
arg	specs with an ||| &amp; specs	count=2
function	column is chosen ||| column chosen	count=3
arg	of tr ||| tr n	count=1
function	new hash [function_2] ||| [function_1] [function_2]	count=1
function	removes all ||| remove all	count=2
function	representation ||| str	count=2
arg	all its contents returning ||| opts	count=1
arg	the ref ||| ref n	count=2
arg	of two channels ||| f buf or n	count=1
function_arg	snapshot of [arg_2] ||| [arg_2] [function_1]	count=1
arg	replaces [arg_1] [arg_2] in ||| [arg_1] [arg_2]	count=2
arg	returns true if [arg_1] [arg_2] provided as arguments have ||| core bound? [arg_1] [arg_2]	count=1
arg	of tr a ||| tr n	count=1
function	soft cut ||| defna	count=1
arg	data until [arg] old-data ||| data fun [arg]	count=1
function_arg	restpattern [arg_2] ||| [function_1] [arg_2]	count=2
arg	form preceeded by literal ||| debug	count=1
arg	[arg_1] table name ||| [arg_1] spec [arg_2]	count=1
arg	repeatedly executes body ||| &amp; body	count=2
function	[function_1] the left ||| [function_2] [function_1]	count=6
arg	[arg_1] of l ||| [arg_2] [arg_1]	count=2
arg	every x [arg] else true ||| pred [arg]	count=1
arg	sc must ||| sc start test	count=2
arg	n default 1 ||| n	count=1
arg	connection and ||| db	count=1
function_arg	reduced x ||| reduced x	count=1
arg	multimethod associated ||| multifn dispatch val &amp;	count=1
arg	at end defaults ||| end	count=1
function	lazy seq ||| response seq	count=1
arg	agent state ||| state	count=1
arg	function for class clojure ||| class	count=2
function	during type checking print ||| print	count=1
module	with ||| data	count=1
function	specified by a string ||| by	count=1
module	ast ||| analyzer passes	count=3
function	is the juxtaposition of ||| juxt	count=1
function	depth-first post-order ||| postwalk	count=1
function	to the set of ||| map	count=1
module	uniform distribution of ||| data generators	count=1
arg	data ||| data	count=2
arg	x to *out* ||| x &amp; options	count=2
function	array of objects ||| array	count=1
function	[function_1] fresh stringwriter ||| [function_2] [function_1]	count=1
arg	sets the error-mode of ||| a mode keyword	count=1
arg	class is ||| class	count=1
arg	type syntax and ||| provided?	count=1
function	object [function] per ||| [function]	count=1
function	a waiting stream a ||| waiting stream check	count=1
arg	changes [arg] ||| a [arg] &amp;	count=1
function	a new sorted ||| sorted	count=2
module	.cljc ||| tools namespace	count=1
arg	of tag either ||| tag	count=1
arg	multimethod associated ||| multifn dispatch	count=2
arg	value from ||| value	count=1
arg	where [arg] removed ||| [arg] l	count=1
arg	the dispatch ||| dispatch	count=1
arg	response-seq ||| response	count=1
function_arg	[function_1] tag ||| [function_1] h [arg_2]	count=5
module	a graph that ||| algo graph	count=1
arg	if [arg] is ||| [arg]	count=2
function	initial cause ||| cause	count=2
function_arg	[function_1] [arg_2] ||| [function_1] ns ns or [arg_2]	count=3
arg	collection test ||| end test end key	count=2
arg	checked before [arg] current ||| [arg]	count=1
function	min-history of a ||| ref min history	count=1
module	type representing a range ||| core typed	count=1
function	creates a var ||| var	count=1
function	an array with ||| double array	count=1
arg	x to ||| x &amp;	count=3
function	to a fresh stringwriter ||| out str	count=1
function	error-mode ||| error mode	count=2
arg	class ||| class field op form env	count=1
function	s have occurred ||| await	count=1
rep	waiting [function_arg_2] ||| [module_1] [function_arg_2]	count=5
function	optional supplied ||| keyfn by	count=1
arg	the colls is ||| &amp; colls	count=4
function	all arguments are equal ||| =	count=1
function	have occurred or the ||| await for	count=1
function_arg	closure [arg_2] ||| [function_1] [arg_2]	count=2
arg	with the ||| &amp; forms	count=1
arg	test s ||| test end	count=2
function	a sequence of file ||| loader	count=1
function	a waiting stream a ||| waiting stream	count=1
function	[function] first ||| first row wildcards [function]	count=1
arg	map with the keys ||| keys	count=1
arg	f ||| f &amp;	count=1
arg	each group [arg] ||| argv expr [arg]	count=1
function	checks a quoted form ||| check form	count=1
arg	error-mode ||| mode	count=1
function	the var ||| var	count=1
module	a [module_2] ||| [module_1] [module_2]	count=12
function	[function_1] closure ||| [function_1] [function_2]	count=3
arg	to [arg_2] ||| [arg_1] [arg_2]	count=1
function	paths ||| loader	count=1
arg	the same type and ||| &amp; args	count=1
module	uuid based on ||| data	count=1
module	of ||| main	count=1
arg	binding then binds name ||| name	count=1
function_arg	coll drop [arg_2] ||| [function_1] [arg_2]	count=2
function	keys ||| keys	count=2
module	else return ||| algo	count=1
function	from the ||| from jarfile	count=1
module	creates a channel with ||| core async	count=1
arg	[arg_1] string debug-string ||| [arg_1] [arg_2]	count=2
function	string representation of a ||| stack element	count=2
function	pretty print [function] function to ||| set pprint [function]	count=1
arg	the output ||| output	count=1
arg	[arg] is the ||| [arg]	count=3
arg	newval if and only ||| newval	count=1
function_arg	ceil [arg_2] ||| [function_1] [arg_2]	count=1
arg	of x to *out* ||| x &amp;	count=1
arg	the dispatch ||| dispatch val	count=1
function	a query ||| query	count=1
function	possibly unmunged string ||| stack element	count=2
function	gets the min-history ||| ref min history	count=1
arg	with binding-form bound to ||| bindings &amp;	count=1
arg	annotations ||| &amp; maybe ann body	count=1
arg	named methods ||| name	count=1
arg	body presumably for side-effects ||| body	count=1
arg	of ||| g	count=4
arg	func ||| string &amp; params func	count=1
function	returns a sequence ||| classpath	count=1
function	waiting ||| waiting	count=1
arg	the agent state to ||| new state &amp; options	count=1
module	logic ||| logic	count=9
function	an array [function_2] ||| [function_2] [function_1]	count=6
arg	opts is a ||| ast opts	count=1
arg	channels the first ||| f buf or n	count=1
arg	by nothing which defaults ||| m nothing which	count=1
arg	of tag through a ||| tag	count=1
arg	[arg_1] to *out* ||| [arg_2] [arg_1]	count=2
arg	factory function for class ||| type declaring class parameter types exception types flags	count=1
module	channel that will ||| async	count=1
arg	given keys ||| keys	count=1
function	data a map if ||| data	count=1
function	is specified by ||| by	count=1
arg	nums all have the ||| y &amp; more	count=1
arg	opts is a set ||| ast opts	count=1
arg	expands to ||| kw args? name docstring? attr map? param	count=1
module	otherwise [module] false ||| [module]	count=1
arg	map of ||| map cause	count=1
arg	passes the given ||| &amp; args	count=1
function	send-off ||| off	count=1
function_arg	/ loop [arg_2] ||| [arg_2] [function_1]	count=1
function_arg	tan of [arg_2] ||| [function_1] [arg_2]	count=1
arg	multimethod that dispatches ||| &amp; args	count=2
arg	the ||| y &amp; more	count=1
function	version of loop that ||| print length loop	count=1
function	representation ||| stack	count=2
arg	return at most n ||| buf or n	count=1
function	version of loop ||| length loop	count=1
function	right [function_2] ||| [function_2] bit shift [function_1]	count=1
function_arg	local taking ||| &gt;local m#	count=1
arg	all [arg] provided as ||| [arg]	count=1
arg	of the input ||| input	count=1
function	binding-form bound ||| let	count=1
module	string or char in ||| string	count=2
arg	[arg_1] and name ||| [arg_2] [arg_1]	count=2
module	output channel will ||| async	count=1
arg	than the normal arguments ||| more	count=1
arg	the index ||| &amp;	count=7
arg	passes the given strings ||| &amp;	count=1
module	of logic ||| logic	count=1
arg	evaluates func passing ||| params func	count=1
arg	commands on the ||| command &amp; sql	count=1
function	default [function_2] ||| [function_1] [function_2]	count=4
function	create an array with ||| double array	count=1
arg	context of an active ||| binding	count=1
arg	that dispatches [arg_2] ||| [arg_2] [arg_1]	count=1
arg	collection test ||| key end test	count=2
function	remove ||| remove	count=1
arg	the jar file and ||| jarfile entry name	count=1
module	true if ||| comparison	count=1
arg	body with binding-form ||| bindings &amp; body	count=2
arg	n default ||| n	count=1
arg	for test [arg_2] ||| [arg_2] [arg_1]	count=2
arg	to writer ||| writer data &amp;	count=1
function	exception message to stop ||| stopper	count=1
function	untouched ||| if eol	count=1
function	new sorted [function_2] ||| [function_1] [function_2]	count=8
function_arg	[function_1] custom comparator ||| data priority-map priority [function_1] by [arg_2]	count=1
arg	to the given keys ||| &amp; keys	count=1
arg	end of the input ||| input	count=1
arg	if x is ||| x	count=1
rep	[module_1] substvalue taking ||| [module_1] [function_arg_2]	count=4
function_arg	acos [arg_2] ||| [arg_2] [function_1]	count=1
arg	by key ||| key	count=1
module	and is understood ||| core	count=1
arg	representing ||| type type type	count=1
function	sql resultset ||| resultset	count=1
arg	multimethod name [arg_2] ||| [arg_1] [arg_2]	count=1
module	sequentially read [module] evaluate ||| [module]	count=2
arg	forms after replacing ||| forms	count=1
arg	runs reader g ||| g	count=1
function	[function_1] array of ||| [function_2] [function_1]	count=6
arg	d is the ||| d	count=1
function	result of a call ||| reduced?	count=1
arg	class ||| type declaring class parameter	count=1
function_arg	[function_1] f index ||| [function_1] [arg_2]	count=2
function	sum of nums ||| +'	count=1
arg	if [arg] a ||| [arg]	count=2
arg	[arg_1] commands on ||| [arg_1] [arg_2]	count=1
function	for ||| quote	count=1
arg	an optional exception-handler ||| xform ex handler	count=1
arg	vector containing sql and ||| sql	count=1
arg	items from coll ||| coll	count=2
function	positive ||| pos?	count=1
function	for nested sequences ||| seq	count=1
arg	namespace and [arg_2] ||| [arg_1] [arg_2]	count=5
rep	[module_1] constructor taking ||| [module_1] map [function_arg_2]	count=3
function	read a ||| read file	count=1
arg	error-mode of agent ||| a mode keyword	count=1
function	declarations ||| find	count=1
function_arg	[function_1] [arg_2] ||| [function_1] x y &amp; [arg_2]	count=2
function	optional supplied ||| by	count=2
module	avl maps which should ||| data avl	count=1
function	is the current value ||| pr	count=1
arg	associates a value ||| k &amp;	count=1
module	true if all arguments ||| comparison	count=1
arg	topic of a pub ||| topic	count=2
function	of the structure-basis ||| struct map	count=1
arg	the compiler when it ||| doc string? attr map? params* body +	count=1
arg	function for class ||| type declaring class parameter types exception types flags	count=1
module	list ||| data generators	count=1
module	clojure-oriented view ||| stacktrace	count=1
function	a quoted form ||| check form	count=1
arg	[arg_1] value ||| [arg_2] [arg_1]	count=1
function	are sequences ||| sequence t	count=1
arg	if ||| x y &amp; more	count=1
function	chosen ||| chosen	count=1
function	the methods of ||| methods	count=1
function	predicate for the given ||| pred	count=1
arg	loc starting with loc ||| loc	count=2
arg	and the ||| specs &amp; options	count=1
arg	spec must be annotated ||| or annotation* expr*	count=1
arg	true if [arg] is ||| [arg]	count=2
function	[function_1] map ||| [function_2] [function_1]	count=3
arg	location loc left-to-right marked ||| loc	count=1
arg	commands on ||| command	count=1
module	and return its ||| algo monads	count=1
function_arg	ceil of x ||| ceil x	count=2
module	goal to run ||| logic	count=1
module	zipper for ||| zip	count=1
arg	a topic of ||| p topic ch	count=1
arg	takes a coll ||| coll	count=1
arg	collection test s ||| test start key end test end	count=2
function_arg	[function_1] coll ||| [function_1] [arg_2]	count=5
module	clojure-oriented view of ||| stacktrace	count=1
arg	is x ||| x	count=1
arg	by the compiler when ||| doc string? attr map? params* body +	count=1
arg	true if o ||| o	count=1
function	not a tagged ||| tagged	count=1
arg	sorted collection test s ||| start test start key end test end key	count=2
function	transformer in terms ||| transformer	count=1
function	removes a ||| remove	count=1
arg	a message only ||| level throwable message	count=1
arg	debug-string ||| frm	count=1
arg	of the mix ||| mix	count=1
arg	[arg_1] side-effects with ||| [arg_2] [arg_1]	count=4
arg	positional factory function for ||| op	count=1
module	goal [module] check that ||| [module]	count=1
arg	[arg] of a ||| [arg]	count=1
arg	the gnu ||| &amp; options	count=1
arg	the form ||| form &amp;	count=1
arg	of a single response-seq ||| response timeout	count=1
function	the atom ||| atom	count=1
arg	[arg_1] f ||| [arg_1] [arg_2]	count=1
arg	jar file and returns ||| jarfile entry	count=1
arg	the transducer ||| ex handler	count=1
function	possibly unmunged string representation ||| stack	count=2
arg	functions [arg] ||| x [arg]	count=3
function	returns a bool ||| boolean	count=1
arg	value is ||| value	count=1
function	agent's state ||| release pending sends	count=1
arg	match with ||| match	count=1
function_arg	between [arg_2] ||| [function_1] h tag [arg_2]	count=1
function	a possibly unmunged string ||| stack element	count=2
module	replacement string that you ||| string	count=1
arg	[arg_1] is x ||| [arg_2] y [arg_1]	count=4
module	and y with ||| core	count=2
arg	[arg_1] if ||| [arg_2] [arg_1]	count=1
module	clojure-oriented ||| stacktrace	count=2
function_arg	the methods [arg_2] ||| [arg_2] [function_1]	count=1
function	exhausted ||| nc*	count=1
arg	construct a data ||| form splicing?	count=1
arg	paths from a classloader ||| loader	count=1
function_arg	tan [arg_2] ||| [arg_2] [function_1]	count=1
function	all of [function_2] ||| [function_2] [function_1]	count=2
function	create a list ||| list	count=1
arg	fun to ||| fun	count=1
function_arg	to stop [arg_2] ||| [function_1] [arg_2]	count=1
function	right ||| right	count=2
function	returns the error-mode of ||| error mode	count=1
module	set ||| set	count=4
function	print ||| print	count=2
arg	a vector of class ||| class	count=1
module	goal to run the ||| logic	count=1
arg	f and reads ||| f	count=1
arg	the gnu ||| args option specs &amp; options	count=1
module	ast when a ||| analyzer passes jvm validate-loop-locals	count=1
function	both [function_2] ||| [function_1] remainder [function_2]	count=1
module	[module] finger_tree digit4 ||| [module]	count=3
arg	filter p etc or ||| or n	count=1
module	match then matching ||| core match	count=1
function	a watch ||| watch	count=1
arg	given name and method ||| name	count=1
arg	[arg_1] n ||| pipeline [arg_2] [arg_1]	count=3
arg	test s one ||| end test end key	count=2
arg	[arg_1] epxression ||| [arg_2] [arg_1]	count=8
arg	kmap ||| kmap	count=2
module	the return value of ||| algo	count=1
module	source channel and returns ||| async	count=1
module	[module] passes constant-lifter ||| [module] passes jvm	count=2
module	class clojure algo generic ||| algo generic	count=4
arg	sql and ||| sql string	count=1
function	string representation of a ||| str	count=2
function	unmunged ||| stack	count=2
arg	a java io writer ||| writer &amp;	count=1
arg	associates a value ||| m k	count=1
arg	func passing in ||| params func	count=1
function_arg	[function_1] of num ||| [function_1] [arg_2]	count=2
function	result repeating for each ||| as &gt;	count=1
function	of file paths from ||| loader classpath	count=1
module	memoization ||| core memoize	count=2
function	single object ||| object	count=2
arg	asynchronously takes ||| on caller?	count=1
function	quoted ||| check	count=1
function_arg	string [arg_2] ||| [arg_2] [function_1]	count=2
function	to substitute [function_2] ||| [function_2] [function_1]	count=8
arg	map of additional ||| map cause	count=1
arg	func ||| params func	count=1
function	in the ||| in jar	count=2
arg	the gnu program argument ||| specs &amp;	count=1
arg	f [arg] ||| p1 p2 p3 [arg]	count=3
function	pretty ||| pretty	count=1
arg	parameters ||| params &amp;	count=1
arg	with the value ||| &amp;	count=1
arg	takes a map ||| map &amp; body	count=1
function	of all descendants of ||| descendants	count=1
function_arg	[function_1] [arg_2] ||| [function_1] template [arg_2]	count=1
arg	monitor of x ||| x &amp; body	count=1
arg	collection test s ||| start key end test end	count=2
function_arg	the contents [arg_2] ||| [function_1] [arg_2]	count=1
function	array ||| int array	count=1
arg	executes sql commands on ||| db spec transaction? sql command &amp; sql	count=1
arg	if all [arg] ||| [arg]	count=2
function	recursive bindings in ||| flatten bindings	count=1
function	[function_1] set ||| [function_1] [function_2]	count=3
function	a list with ||| list	count=1
function	dispatch function ||| dispatch	count=1
arg	the ||| &amp; namespaces	count=1
function_arg	[function_1] of coll ||| [function_1] [arg_2]	count=5
function	var coverage ||| var	count=1
arg	plus the action ||| action	count=1
function_arg	[function_1] oldval ||| [arg_2] [function_1]	count=1
arg	its arguments ||| x y &amp; more	count=1
arg	opts is ||| opts	count=1
module	a channel ||| core async	count=2
arg	name [arg_2] ||| [arg_1] [arg_2]	count=4
module	and type checks ||| typed	count=1
arg	[arg_1] string debug-str ||| [arg_1] [arg_2]	count=2
arg	and o [arg_2] ||| core logic rembero [arg_2] [arg_1]	count=3
function	sequences given ||| seq zip	count=1
module	recursively transforms ||| walk	count=2
function	vector ||| vector zip	count=1
arg	attempts to coerce its ||| x &amp; opts	count=2
function	file paths from ||| classpath	count=1
arg	error-mode of agent ||| a mode	count=1
function	return last index of ||| last index of	count=1
arg	[arg] an ||| &amp; [arg]	count=3
function_arg	[function_1] [arg_2] the ||| [function_1] [arg_2]	count=6
arg	a [arg] ||| msg [arg]	count=3
module	like when-let but ||| typed	count=1
function	rounding mode to be ||| with	count=1
arg	in which the ||| which	count=1
function_arg	[function_1] num ||| [function_1] [arg_2]	count=2
arg	element of l ||| l	count=1
arg	associated with key by ||| key	count=1
arg	the error-mode of agent ||| mode keyword	count=1
arg	given name [arg_2] ||| [arg_2] [arg_1]	count=1
function	by ||| new	count=1
arg	installs a new ||| fn tail	count=1
arg	[arg_1] with an ||| [arg_2] [arg_1]	count=8
arg	two channels ||| t buf or n f buf or n	count=1
function	to the classpath ||| add classpath	count=1
module	new collection ||| collection	count=2
arg	two channels the ||| f buf or n	count=1
arg	binds name [arg_2] ||| [arg_2] [arg_1]	count=3
module	clojure core memoize ||| core memoize	count=1
arg	specs with ||| &amp; specs	count=2
function	hash set with ||| hash set	count=2
arg	p etc or a ||| buf or n	count=1
function	a query then evaluates ||| query	count=1
arg	of two channels the ||| n f buf or n	count=1
arg	and optional ||| &amp;	count=1
arg	jar file ||| jarfile	count=1
function_arg	[function_1] [arg_2] ||| [function_1] array 2d [arg_2]	count=24
module	representation of ||| main	count=1
arg	the cache system ||| cache	count=1
function	an array ||| long array	count=1
module	a type representing a ||| core typed	count=1
arg	associates a ||| k &amp;	count=1
function_arg	[function_1] rs ||| [function_1] [arg_2]	count=4
function	unmunged string representation ||| stack element	count=2
function	[function_1] of bindings ||| [function_1] [function_2]	count=1
function	with random probability ||| random sample	count=1
arg	annotations ||| maybe ann	count=1
arg	core memo-placed memoization ||| memoized fn	count=1
module	representation of a ||| repl	count=1
function	array [function_2] ||| [function_2] [function_1]	count=14
function	[function_1] last ||| [function_2] [function_1]	count=2
arg	val s ||| val	count=1
arg	input array ||| input offset	count=1
function	and initialize all of ||| if needed	count=1
function	boolean[] ||| booleans	count=1
module	returns its ast ||| analyzer	count=1
arg	p etc or a ||| or n	count=1
function	a zipper for nested ||| seq zip	count=1
arg	to 0 [arg] ||| start end [arg]	count=3
function_arg	conjoined [arg_2] ||| [function_1] coll [arg_2]	count=1
arg	containing sql and ||| sql string	count=1
arg	function for class clojure ||| class op form env	count=1
arg	function for class ||| class field op form	count=1
function	bool ||| boolean	count=1
function	reads a single ||| read	count=1
function	the left of ||| left	count=1
module	create a uuid based ||| generators	count=1
arg	and [arg] default ||| [arg]	count=1
function	leftmost [function] ||| insert [function]	count=3
function	both int ||| unchecked divide int	count=1
arg	and installs a new ||| fn tail	count=1
module	during type ||| typed	count=2
function	take a waiting stream ||| waiting stream	count=1
arg	monad operations and ||| operations	count=1
function	runs ||| test	count=1
arg	the value is ||| value	count=1
arg	true if [arg] type clojure ||| [arg]	count=1
arg	in [arg] expansion of ||| fn bindings [arg]	count=1
function	least ||| min	count=1
arg	x ||| x &amp; body	count=1
arg	not nil [arg] ||| expr [arg]	count=3
arg	channels ||| buf or n f buf or n	count=1
arg	[arg_1] debug-string ||| [arg_1] [arg_2]	count=3
function_arg	[function_1] heterogeneous vectors ||| [arg_2] [function_1]	count=1
function	core / for ||| for	count=1
function_arg	[function_1] port ||| [arg_2] [function_1]	count=2
function	attempt to substitute unification ||| make occurs subst	count=1
arg	rel [arg_2] ||| [arg_1] [arg_2]	count=1
function	ddl string for ||| ddl	count=1
function	unmunged string representation ||| str	count=2
function_arg	[function_1] [arg_2] ||| core [function_1] [arg_2]	count=5
function	[function_1] map with ||| [function_2] [function_1]	count=3
arg	object to printwriter ||| escape unicode?	count=1
arg	exprs ||| bindings &amp; exprs	count=1
module	uniform distribution of ||| generators	count=1
function	checking print ||| print	count=2
function	[function_1] [function_2] for a var / ||| [function_1] [function_2]	count=2
function	checks a quoted ||| check form	count=1
arg	an initial [arg] ||| [arg]	count=1
function	a set with ||| set	count=1
arg	the ref ||| ref	count=2
arg	[arg_1] val ||| core async put! port [arg_2] fn1 [arg_1]	count=1
function	take a waiting stream ||| waiting stream check	count=1
function	using the extend construct ||| extend	count=1
function	nested ||| seq zip	count=1
arg	annotations ||| &amp; maybe ann body expr	count=1
function	resultset ||| resultset	count=2
module	channel to ||| async	count=1
function	extend construct ||| extend	count=1
arg	value is the ||| value	count=1
function	child of the node ||| child	count=1
arg	commands on the specified ||| command &amp; sql commands	count=1
function	will attempt to substitute ||| subst	count=1
function	return last index of ||| last	count=1
function	keyed [function_2] ||| [function_2] [function_1]	count=4
function	load and [function_2] ||| [function_2] [function_1]	count=3
function_arg	stream a [arg_2] ||| [function_1] [arg_2]	count=5
function	negation ||| negate	count=1
arg	[arg_1] dispatches on ||| [arg_1] [arg_2]	count=2
arg	lib ||| lib	count=1
arg	v lying between ||| v	count=1
module	of a ||| repl	count=1
function_arg	[function_1] location loc ||| [arg_2] [function_1]	count=1
arg	expands to ||| kw args? name docstring?	count=1
function	[function_1] stream ||| [function_1] [function_2]	count=2
arg	o is a ||| o	count=1
arg	of class ||| class	count=1
function	is not a tagged ||| tagged	count=1
arg	keys ||| coll &amp; keys	count=1
arg	goals ||| goals	count=1
function_arg	product [arg_2] ||| [function_1] int [arg_2]	count=3
arg	name if ||| name	count=1
arg	expansion [arg] ||| symbol [arg]	count=1
arg	non-nil [arg_1] [arg_2] monotonically non-decreasing order otherwise ||| &lt;= [arg_1] [arg_2]	count=1
function	all ||| ns	count=1
arg	set of named methods ||| name	count=1
arg	sorted collection test ||| key end test end key	count=2
arg	a sorted collection test ||| key end test	count=2
function	stop the ||| thread stopper	count=1
function	with ||| with	count=2
arg	[arg_1] method sigs ||| [arg_1] &amp; [arg_2]	count=1
function	metadata in the context ||| metadata	count=1
arg	at the offset ||| offset	count=1
arg	sets the error-mode ||| mode	count=1
function_arg	indirect children [arg_2] ||| [function_1] h [arg_2]	count=3
module	of a graph ||| algo graph	count=1
arg	or a composition thereof) ||| or	count=1
function	data structurenot text!) ||| eval	count=1
arg	[arg] optionally ||| [arg] transaction? sql param	count=1
arg	annotate [arg] interface created ||| [arg]	count=1
function	which guarantees no element ||| distincto	count=1
function	does not recognized a ||| object?	count=1
arg	the monad operations and ||| plus operations	count=1
function	to read ||| read file	count=1
arg	ref ||| ref n	count=2
arg	returns true if ||| x	count=1
function	conjoined to the ||| into	count=1
arg	subject [arg_1] [arg_2] with parallelism ||| to [arg_2] from close? [arg_1]	count=1
function	metadata in ||| metadata	count=1
function	[function_1] of doubles ||| [function_2] [function_1]	count=2
arg	n [arg_2] ||| [arg_2] buf or [arg_1]	count=1
module	returns a ||| main	count=1
arg	step to 1 and ||| step	count=1
module	create a uuid based ||| data generators	count=1
arg	of the file ||| f &amp;	count=1
function	of loop that ||| print length loop	count=1
arg	supplied keys using the ||| keys	count=1
module	returns a zipper ||| zip	count=1
arg	threads it ||| forms	count=1
function	is a branch ||| branch?	count=1
module	from the channel ||| core async	count=1
module	string that ||| string	count=1
function	returns a sequence ||| loader classpath	count=1
arg	that returns a ||| &amp; body	count=1
arg	an expression and ||| expr &amp; clauses	count=2
function	version of loop that ||| loop	count=1
function	of a [function] conditional ||| [function]	count=1
module	given [module] ||| [module]	count=4
function	do ||| do	count=1
function	of a ||| element str	count=2
module	type level ||| core typed	count=3
arg	and the ||| option specs &amp; options	count=1
function	returns [function_1] [function_2] can be any collection ||| [function_2] [function_1]	count=1
module	return its ||| algo	count=1
function	sequence of the nodes ||| seq	count=1
function	conjoined to ||| into	count=1
function	with that ||| find	count=1
function	create an array ||| boolean array	count=1
function_arg	mapped to [arg_2] ||| [arg_2] [function_1]	count=1
module	monad describing computations that ||| algo monads	count=1
module	of several [module] operations ||| [module]	count=1
arg	that expands into forms ||| forms	count=1
arg	equal ||| equal	count=1
function	of a [function_1] [function_2] ||| core [function_1] [function_2]	count=2
function	root ||| seq zip	count=1
arg	vector of two channels ||| f buf or n	count=1
function_arg	the least [arg_2] ||| [function_1] [arg_2]	count=1
arg	an ||| relative	count=1
arg	[arg_1] [arg_2] ||| [arg_1] &amp; [arg_2]	count=4
arg	x [arg] else true ||| pred [arg]	count=2
arg	[arg_1] s ||| string replace [arg_2] [arg_1]	count=1
function	summarises annotated var coverage ||| var	count=1
arg	sorted collection test ||| end test end	count=2
module	ast when ||| analyzer passes	count=1
arg	of the file ||| &amp; more	count=1
function	locations to the left ||| left locs	count=1
arg	the first of l ||| l	count=1
module	of json [module_2] ||| [module_2] [module_1]	count=3
arg	the jar [arg_2] ||| [arg_1] [arg_2]	count=1
function	representation of ||| stack element str	count=2
arg	logs a message using ||| level throwable message &amp;	count=1
module	the specified level ||| tools logging	count=1
arg	swaps the [arg_2] ||| [arg_2] f x y [arg_1]	count=2
arg	class ||| class field op form env extmap	count=1
function	declaration from the ||| decl from	count=1
module	a channel to a ||| core async	count=1
arg	that ||| &amp; body	count=1
module	contracts to existing ||| contracts	count=1
function	sequence of ||| loader	count=1
function	the immediate parents of ||| parents	count=1
module	a type representing ||| typed	count=1
function	sequences ||| zip	count=1
arg	a topic of ||| topic ch close?	count=1
arg	tag either via a ||| tag	count=1
arg	[arg_1] the context ||| [arg_2] [arg_1]	count=4
function	clojure version as a ||| clojure version	count=1
module	of type ||| core typed	count=1
arg	for class ||| class parameter types	count=1
function	nested sequences given a ||| seq	count=1
module	clojure data ||| data	count=7
module	of json [module_2] ||| [module_1] [module_2]	count=3
function_arg	returns a [function_1] [arg_2] ||| core [function_1] [arg_2]	count=5
arg	for use [arg] go blocks ||| [arg]	count=1
arg	clojure ||| t	count=1
arg	given fntail which ||| fntail	count=1
arg	from-coll ||| to xform from	count=1
arg	of nums ||| more	count=1
arg	if d ||| d	count=1
function	a query ||| db query	count=1
function	first column [function_2] ||| [function_2] [function_1]	count=1
module	that a ||| core logic	count=2
function	[function_1] options ||| [function_1] [function_2]	count=4
arg	with binding-form bound ||| bindings &amp;	count=1
arg	representing a ||| type type type	count=1
arg	method of multimethod ||| multifn	count=1
function	loop ||| validate loop	count=1
module	clojure ||| tools	count=1
arg	test s ||| key end test end key	count=2
arg	monad m into a ||| m	count=1
function	annotate ||| ann	count=3
function	the result ||| reduced?	count=1
function_arg	negation of [arg_2] ||| [arg_2] [function_1]	count=1
arg	thread ||| thread	count=1
function_arg	product of [arg_2] ||| [arg_2] [function_1]	count=3
function	binding-form bound to ||| let	count=1
arg	of the monad operations ||| m plus operations	count=1
function	a post-ordered walk ||| post ordered nodes	count=1
arg	a set of clauses ||| clauses	count=1
function	keyword with the given ||| find keyword	count=1
function	load and initialize all ||| load if needed	count=1
arg	for the cache ||| cache item	count=1
function	loop that iterates at ||| loop	count=1
arg	test s one ||| start key end test end key	count=2
module	w [module] read type ||| [module]	count=1
function	transitive ||| transitive	count=1
function	returns the previous state ||| set state	count=1
module	and return ||| algo	count=1
arg	source [arg] which ||| [arg]	count=1
function	stream ||| stream	count=1
arg	value of the ||| &amp;	count=1
module	when-let but ||| core typed	count=1
arg	core memo-placed memoization cache ||| memoized fn	count=1
arg	two channels the first ||| or n f buf or	count=1
arg	value of val ||| val	count=1
function_arg	[function_1] with loc ||| [function_1] locs [arg_2]	count=2
arg	and the base ||| base which m plus	count=1
arg	takes a proxy instance ||| proxy	count=1
function	var ||| var coverage	count=2
arg	monad operations ||| plus operations	count=1
function	namespace returns ||| ns	count=1
function_arg	sql resultset [arg_2] ||| [function_1] [arg_2]	count=1
arg	new method of multimethod ||| multifn dispatch val &amp;	count=1
arg	custom keyfn custom comparator ||| keyfn comparator &amp;	count=1
function	min-history of a ref ||| ref min history	count=1
arg	a java io writer ||| writer	count=1
function	s ||| index of	count=2
function	representation of a ||| stack element	count=2
arg	on [arg_2] ||| [arg_2] [arg_1]	count=1
arg	a sorted collection test ||| start key end test end	count=2
module	object which will occur ||| fressian	count=1
arg	class ||| declaring class parameter types exception types flags	count=1
module	uuid ||| data	count=1
arg	loc without moving ||| loc	count=2
arg	variables ||| &amp; lvars	count=1
arg	[arg_1] and tag ||| [arg_2] [arg_1]	count=4
arg	casts to ||| xs	count=6
function	sql resultset ||| resultset seq	count=1
function	for with optional ||| for	count=1
module	logic ||| core logic	count=1
arg	stacktraceelement ||| el	count=2
module	but with optional type ||| typed	count=2
arg	factory function for class ||| name type declaring class flags	count=1
function	snapshot ||| snapshot	count=1
arg	state [arg_2] ||| [arg_1] [arg_2]	count=1
arg	the gnu ||| &amp;	count=1
arg	length starting at ||| length	count=1
arg	the ||| args option specs &amp; options	count=1
function	unification ||| make occurs	count=1
arg	custom comparator and ||| comparator &amp;	count=2
module	uuid based on ||| data generators	count=1
arg	type syntax and ||| expected type provided?	count=1
arg	positional factory ||| op form env	count=1
arg	the corresponding vals ||| vals	count=1
function_arg	ddl string [arg_2] ||| [function_1] [arg_2]	count=1
module	a sequence of file ||| classpath	count=1
function	max-history of a ||| ref max history	count=1
function	with sh see sh ||| with sh env	count=1
arg	[arg_1] [arg_2] ||| [arg_2] x y [arg_1]	count=8
arg	[arg_1] by y ||| [arg_2] [arg_1]	count=6
function	string representation ||| element	count=2
arg	generic assertion code ||| msg form	count=2
arg	sql commands on the ||| spec transaction? sql command &amp; sql	count=1
function	a lazy sequence ||| seq	count=1
module	distribution of ||| data generators	count=1
arg	element of coll ||| coll	count=1
function	[function] for a ||| get [function]	count=1
arg	collection test ||| start test start key end test end key	count=2
arg	[arg_1] [arg_2] from l exactly one ||| core logic rembero [arg_2] [arg_1]	count=4
arg	into port ||| port	count=1
arg	input array ||| input	count=1
arg	for class ||| type declaring class parameter	count=1
function_arg	[function_1] loc ||| [function_1] [arg_2]	count=4
function	returns [function_1] [function_2] ||| [function_2] [function_1]	count=2
module	takes ||| core async	count=2
module	based on uniform distribution ||| data	count=1
arg	clojure form ||| form	count=1
function_arg	trace [arg_2] ||| [arg_2] [function_1]	count=3
function_arg	return last [arg_2] ||| [function_1] s [arg_2]	count=1
function	while ||| while	count=1
function_arg	negation [arg_2] ||| [arg_2] [function_1]	count=2
arg	the file they ||| &amp; more	count=1
function	like atom ||| atom	count=1
function	string ||| element	count=2
module	create a uuid based ||| data	count=1
arg	expression ||| expr &amp; args	count=1
function	a pretty ||| get pretty	count=1
arg	goals until a maximum ||| &amp; goals	count=1
arg	function for class ||| declaring class parameter types exception types	count=1
function_arg	[function_1] x by ||| [function_1] int [arg_2]	count=4
function	shorts ||| short	count=1
arg	expands to clojure core ||| kw args? name docstring? attr map? param	count=1
arg	symbol [arg] into ||| [arg]	count=1
arg	which the base values ||| m which	count=1
module	possibly unmunged string ||| main	count=1
arg	class ||| declaring class parameter types exception	count=1
module	from a ||| java classpath	count=1
arg	collection test s one ||| key end test end	count=2
arg	collection test ||| end test	count=2
arg	containing sql and optional ||| sql string &amp;	count=1
function	string ||| string	count=3
arg	start inclusive [arg_2] ||| [arg_2] [arg_1]	count=1
arg	a sorted collection test ||| end test end	count=2
arg	defaults to 0 [arg_1] [arg_2] ||| [arg_2] [arg_1]	count=3
arg	expression or stringable thing ||| or pattern	count=1
module	snapshot ||| core memoize	count=1
arg	a sorted collection test ||| start test start key end test	count=2
function	nil false otherwise ||| nil?	count=1
function_arg	drop [arg_2] ||| [function_1] [arg_2]	count=2
function	returns the negation ||| negate	count=1
arg	instantiate a call ||| inst of	count=1
arg	[arg_1] to fn1 ||| [arg_1] [arg_2]	count=3
function	repeating ||| as &gt;	count=1
function_arg	parents of [arg_2] ||| [function_1] h [arg_2]	count=4
function	a [function] form ||| [function]	count=1
function	prints a ||| print	count=1
module	of a ||| main	count=1
arg	func passing in the ||| params func	count=1
arg	a success continuation and ||| w success	count=1
arg	object of the ||| &amp; args	count=1
arg	success continuation and a ||| success	count=1
arg	func passing in the ||| &amp; params func	count=1
arg	n if ||| n x	count=2
arg	multimethod ||| multifn dispatch val	count=2
function	test if not ||| if	count=1
arg	topic of a pub ||| topic ch close?	count=1
arg	the args ||| d e f &amp; args	count=1
function	[function_1] of bindings ||| [function_2] [function_1]	count=1
function	prints a chain of ||| print	count=1
function	declaration [function_2] ||| [function_2] [function_1]	count=4
module	[module] with an ||| [module]	count=1
module	type w [module] read type ||| [module]	count=1
arg	for the ||| class or object	count=1
arg	and column specs ||| specs	count=1
function	rint of ||| rint	count=1
arg	if [arg] is a ||| [arg]	count=1
rep	[module_1] maybeclass taking ||| [module_1] map [function_arg_2]	count=2
arg	creates an ||| size init val or seq	count=8
arg	a sorted collection test ||| start key end test end key	count=2
arg	heterogeneous vectors ||| fixed*	count=1
function	aliases for ||| ns aliases	count=1
arg	true [arg] is ||| [arg]	count=3
module	representation of a ||| main	count=1
module	that ||| jdbc	count=1
module	algo [module_2] ||| [module_1] [module_2]	count=16
function	a list begun with ||| list	count=1
module	override the return type ||| core typed	count=1
arg	be: apply f ||| f	count=1
arg	all [arg] ||| [arg]	count=2
arg	[arg_1] dispatches ||| [arg_1] [arg_2]	count=2
function	keys of the structure-basis ||| struct	count=1
function	[function_1] shift left ||| [function_1] [function_2]	count=1
function	first column is ||| first column	count=1
arg	functions and ||| h &amp; fs	count=1
arg	its contents ||| &amp; opts	count=1
arg	value of f ||| f	count=1
module	replacement string ||| string	count=1
function	to stop the given ||| stopper	count=1
function_arg	[function_1] parent ||| [arg_2] [function_1]	count=1
function	whitespace characters ||| whitespace	count=1
arg	of multimethod ||| multifn dispatch	count=2
function	sum ||| +'	count=1
function_arg	in the [arg_2] ||| [arg_2] [function_1]	count=2
arg	[arg_1] parent ||| core derive [arg_1] [arg_2]	count=5
arg	[arg_1] class clojure ||| [arg_2] [arg_1]	count=1
function	> binding-form init-expr ||| let	count=1
function	the name string of ||| name	count=1
arg	test ||| test start key end test	count=2
arg	[arg] else true ||| pred [arg]	count=2
function_arg	[function_1] of prob ||| [arg_2] [function_1]	count=1
arg	stream s ||| s	count=1
arg	string if it is ||| x	count=1
arg	of types ||| types	count=2
function	lazy seq of messages ||| response seq	count=1
arg	collection test s ||| start test start key end test end	count=2
arg	and the base ||| base which	count=1
arg	collection ||| coll	count=1
function	[function_1] from ||| [function_1] [function_2]	count=1
function	override all constructors for ||| override	count=1
function	exception message to stop ||| thread stopper	count=1
module	and supplies ||| core	count=2
arg	sorted collection test s ||| test start key end test end key	count=2
function_arg	remainder [arg_2] ||| [arg_2] [function_1]	count=2
arg	its arguments ||| &amp; more	count=1
module	output channel will be ||| core async	count=1
arg	of from-coll ||| to xform from	count=1
module	[module_1] goal ||| [module_1] [module_2]	count=2
arg	collection test s one ||| test end	count=2
arg	[arg_1] [arg_2] fn that takes a ||| [arg_2] [arg_1]	count=7
module	nested ||| zip	count=1
arg	connection and a vector ||| db	count=1
module	of ||| generators	count=1
function	composition of those fns ||| comp	count=1
function	gets the ||| get	count=2
module	from ||| java	count=1
function_arg	zero-type taking a ||| &gt;zero type m#	count=1
arg	compiler when it is ||| doc string? attr map? params*	count=1
arg	the given keys ||| &amp; keys	count=1
arg	exprs and any nested ||| exprs	count=1
arg	named set of named ||| name	count=1
arg	[arg_1] x ||| [arg_2] [arg_1]	count=1
arg	map of ||| map	count=2
function	of all immediate children ||| children	count=1
arg	dispatches [arg_2] ||| [arg_1] [arg_2]	count=1
arg	at this loc ||| loc	count=3
function	recursively under ||| find clojure sources in	count=1
module	file paths ||| java	count=1
function	the contents ||| to	count=2
arg	the file ||| f &amp; more	count=1
arg	associates a ||| m k &amp;	count=1
arg	the supplied [arg_2] ||| [arg_2] [arg_1]	count=2
function	values are sequences ||| sequence t	count=1
arg	template expression ||| expr	count=1
arg	goals until ||| bindings &amp; goals	count=2
arg	evaluates body in ||| body	count=2
arg	args [arg_2] ||| [arg_2] &amp; [arg_1]	count=1
function	expression that extracts metadata ||| metadata	count=1
function	in ||| in	count=4
arg	tests in [arg] given ||| [arg]	count=1
function	local [function_2] ||| [function_1] [function_2]	count=1
arg	f to ||| f	count=1
function_arg	[function_1] jar ||| [arg_2] [function_1]	count=4
function	of the methods of ||| methods	count=1
arg	named by the symbol ||| name	count=1
arg	to by key ||| key	count=1
arg	of key ||| key	count=1
function	[function_1] method of ||| [function_2] [function_1]	count=1
arg	[arg_1] string debug-string ||| [arg_2] [arg_1]	count=2
arg	map of ||| map &amp;	count=1
arg	the operation completed ||| clauses	count=1
function	to the classpath ||| classpath	count=1
arg	given a root ||| root	count=3
function	bindings pushed with ||| bindings	count=1
rep	hvec is a [module_1] [function_arg_2] ||| [module_1] [function_arg_2]	count=1
arg	an object subject ||| object	count=1
function	takes a val from ||| &lt;!!	count=1
arg	multimethod associated with ||| multifn dispatch	count=2
function	representation of a ||| str	count=2
arg	that z [arg_2] ||| [arg_2] [arg_1]	count=1
arg	for class clojure ||| class field op form env extmap	count=1
arg	x and ||| x	count=4
arg	method of multimethod ||| multifn dispatch	count=1
module	for class clojure algo ||| algo	count=4
arg	string if it ||| x	count=1
arg	repeatedly copies [arg] in ||| argv [arg]	count=1
arg	creates and installs a ||| val &amp; fn tail	count=1
function_arg	class [arg_2] ||| [function_1] [arg_2]	count=1
function_arg	sin [arg_2] ||| [function_1] [arg_2]	count=1
function_arg	[function_1] sql ||| [arg_2] [function_1]	count=1
function	implements ipersistentlist ||| list?	count=1
function	composition ||| comp	count=1
arg	proxy instance and ||| proxy	count=1
function	new sorted set with ||| sorted set	count=1
arg	printwriter out as ||| x out escape unicode?	count=1
arg	fn1 if supplied when ||| fn1	count=1
arg	and v ||| v	count=1
module	clojure algo generic arithmetic ||| algo generic arithmetic	count=4
arg	sorted collection test s ||| test	count=2
function	[function_1] of booleans ||| [function_2] [function_1]	count=2
arg	variables ||| &amp; lvars &amp;	count=1
module	and type ||| core typed	count=1
module	a [module] ||| [module]	count=2
module	avl sets which should ||| data avl	count=1
module	channel with an optional ||| async	count=1
arg	func passing in the ||| string &amp; params func	count=1
arg	and o [arg_2] ||| [arg_2] [arg_1]	count=3
function	an assoc ||| assoc	count=1
arg	of coll coll ||| coll	count=1
function	to the ||| map	count=1
function	async ||| async	count=1
function	coerce to char ||| unchecked char	count=1
module	polymorphic type ||| core typed	count=1
function	unmunged string representation ||| stack element str	count=2
arg	channels the first ||| n f buf or	count=1
arg	on stream s ||| s	count=1
arg	its contents returning a ||| opts	count=1
module	ast when a ||| tools analyzer passes	count=1
arg	comparator ||| comparator	count=6
arg	the args ||| c d e f &amp; args	count=1
arg	class clojure ||| class op form	count=1
arg	and b ||| b	count=2
function_arg	[function_1] the ||| [function_1] x y [arg_2]	count=2
function	sorted set ||| sorted set	count=1
arg	[arg_1] end ||| [arg_2] [arg_1]	count=2
module	a ||| data	count=1
function	of loop that iterates ||| length loop	count=1
arg	[arg_1] [arg_2] ||| [arg_2] name [arg_1]	count=1
module	a type ||| core typed	count=3
arg	syntax and ||| provided?	count=1
module	type environment ||| core typed	count=1
arg	to a topic ||| topic ch	count=1
arg	atom to newval ||| newval	count=1
arg	it if needed ||| docstring? attr map? references*	count=1
function_arg	[function_1] map entry ||| [arg_2] [function_1]	count=2
arg	an active ||| binding	count=1
function	var with that name ||| find var	count=1
module	type environment to ||| typed	count=1
arg	asynchronously [arg_2] ||| core async put! port [arg_2] fn1 [arg_1]	count=1
function	the min-history ||| min history	count=1
function	metadata in the ||| metadata	count=1
function	initialize all of core ||| if needed	count=1
function_arg	[function_1] pred item ||| [function_1] [arg_2]	count=1
arg	3a: the ||| matrix col ocrs	count=1
function	returns ||| seq zip	count=1
arg	to a topic of ||| topic	count=1
module	return the difference of ||| algo generic	count=1
function	the initial cause of ||| cause	count=2
arg	java io reader ||| reader &amp;	count=1
function_arg	substvalue [arg_2] ||| [arg_2] [function_1]	count=2
function	not nil false otherwise ||| some?	count=1
function	indirect children ||| descendants	count=1
arg	evaluates func passing in ||| func	count=1
module	and returns its ast ||| tools analyzer	count=1
arg	test s one of ||| start test start key end test end key	count=2
arg	collection test s ||| end test end	count=2
function	sorted map with supplied ||| sorted map	count=2
arg	the value at ||| not found	count=1
arg	the monad operations and ||| operations	count=1
arg	syntax ||| expected type provided?	count=1
function_arg	the async [arg_2] ||| pipeline [function_1] [arg_2] close?	count=2
arg	a [arg] ||| [arg] tag	count=1
function_arg	[function_1] u into ||| [function_1] [arg_2]	count=1
module	type with a number ||| typed	count=1
arg	of f applied ||| f	count=1
arg	yields a seqable object [arg_1] [arg_2] ||| [arg_1] [arg_2]	count=4
arg	the input array ||| input	count=1
function	method ||| method	count=2
arg	returns the map ||| map	count=1
arg	channels ||| f buf or	count=1
arg	of functions ||| g h &amp; fs	count=1
function	default ||| default	count=1
arg	[arg_1] commands on ||| [arg_2] [arg_1]	count=1
function	an array ||| array	count=8
module	bean but for jmx ||| java jmx	count=1
arg	ns ||| ns sym	count=1
arg	the file ||| &amp; more	count=1
arg	functions and returns a ||| h &amp; fs	count=1
module	a fressian reader ||| fressian	count=2
arg	fn1 ||| fn1	count=2
arg	if ||| x	count=9
module	that ||| java jdbc	count=1
arg	of match [arg_2] ||| [arg_2] [arg_1]	count=1
function_arg	async [arg_2] ||| pipeline [function_1] n to [arg_2] from close?	count=1
arg	of the input array ||| input offset	count=1
function	implements ipersistentcollection ||| coll?	count=1
arg	establishes a [arg_1] [arg_2] ||| core derive [arg_1] [arg_2]	count=2
arg	jar ||| jar	count=1
arg	any x [arg] ||| pred [arg]	count=2
arg	output writer ||| writer	count=1
arg	the ||| option specs &amp;	count=1
function	the old ||| update	count=1
function	an instance of ||| class?	count=1
arg	key by val ||| key val	count=2
function	core / let ||| let	count=1
arg	transducer [arg_2] ||| to [arg_2] from close? [arg_1]	count=1
arg	return [arg] a ||| [arg]	count=1
module	but for jmx ||| java jmx	count=1
arg	installs a ||| val &amp; fn tail	count=1
module	[module] count ||| [module]	count=4
arg	if [arg_2] ||| &lt;= [arg_1] [arg_2]	count=1
arg	format ||| fmt &amp; args	count=1
arg	the evaluation of expr ||| expr	count=1
function	or ||| error	count=1
arg	the value ||| value	count=2
arg	test ||| test end	count=2
arg	a topic of ||| topic ch	count=1
arg	o [arg_2] ||| [arg_2] [arg_1]	count=3
arg	clojure delaysee clojure ||| t	count=1
function_arg	contents of [arg_2] ||| [function_1] array 2d [arg_2]	count=4
arg	of num ||| num	count=2
function_arg	[function_1] supplied ||| [arg_2] [function_1]	count=1
module	containing ns ... ||| tools namespace	count=2
function	an array with ||| byte array	count=1
function	lazy sequence of the ||| seq	count=1
arg	the file they ||| f &amp;	count=1
arg	passes the given strings ||| &amp; args	count=1
function	returns a ||| stack	count=2
function	[function_1] the contents ||| [function_2] [function_1]	count=8
function	[function_1] map with ||| [function_1] [function_2]	count=3
function	to stop ||| stopper	count=1
arg	that ||| &amp;	count=3
arg	a java array ||| array	count=1
arg	given a [arg_1] [arg_2] parameters perform ||| [arg_1] [arg_2]	count=1
function	bindings in ||| bindings	count=1
arg	a namespace / sa ||| syms &amp; opt	count=1
module	nested sequences given a ||| zip	count=1
function	extracts metadata in ||| metadata	count=1
arg	the given strings to ||| &amp;	count=1
arg	function f of 2 ||| f	count=1
arg	syntax ||| type provided?	count=1
arg	the source [arg] which ||| [arg]	count=1
arg	with the given name ||| name &amp;	count=1
function	didn't allow asserts with ||| assert with message	count=1
arg	channels the ||| t buf or n f buf or	count=1
module	distribution of ||| data	count=1
function_arg	[function_1] vals ||| [arg_2] [function_1]	count=1
module	channel will be closed ||| async	count=1
function_arg	conjugate of [arg_2] ||| [function_1] [arg_2]	count=1
arg	to newval if ||| newval	count=1
module	generic [module_2] ||| [module_1] [module_2]	count=4
arg	executes an ||| db	count=2
function	annotated var coverage ||| var coverage	count=1
module	channel and returns a ||| async	count=1
function	like deftest but creates ||| deftest	count=1
module	the return value ||| algo	count=1
module	returns ||| java classpath	count=2
rep	[module_1] zero-type taking ||| [module_1] map [function_arg_2]	count=6
function	array of longs ||| long array	count=3
arg	functions ||| f g &amp; fs	count=1
function_arg	[function_1] arguments ||| [arg_2] [function_1]	count=4
function	keyed [function_2] ||| [function_1] [function_2]	count=4
function	asserts with ||| assert with	count=1
arg	opts ||| opts	count=1
function	ddl string for creating ||| create table ddl	count=1
module	true if all ||| comparison	count=1
arg	a vector containing sql ||| sql	count=1
function	map of default options ||| get default options	count=1
function_arg	[function_1] the supplied ||| [function_1] coll [arg_2]	count=1
module	value is ||| core	count=1
arg	[arg] transient collection ||| coll [arg]	count=1
arg	[arg_1] [arg_2] ||| [arg_2] arg1 [arg_1]	count=6
arg	channels the first ||| buf or n	count=1
function	message to stop ||| thread stopper	count=1
arg	filters ||| filters	count=1
function	single class ||| class	count=1
arg	class clojure ||| class field op form	count=1
arg	end ||| end	count=4
function	[function] function ||| with [function]	count=1
arg	returns true if a ||| x	count=1
function	min-history of ||| min history	count=1
arg	monad in which ||| which	count=1
function	symbol with the ||| symbol	count=1
arg	for class ||| class flags	count=1
function	test / form pairs ||| cond &gt;&gt;	count=1
function_arg	agent to the agents [function_1] [arg_2] in ||| [function_1] [arg_2]	count=4
function	left of ||| left	count=1
function	first column is chosen ||| first column chosen	count=1
arg	factory function ||| f	count=1
function_arg	[function_1] of f ||| [function_1] [arg_2]	count=5
function	a new hash ||| hash	count=1
arg	given [arg_1] [arg_2] parameters perform ||| [arg_1] [arg_2]	count=1
arg	[arg_1] [arg_2] into port calling ||| core async put! port [arg_2] fn1 [arg_1]	count=3
function	[function_1] stream a ||| [function_1] [function_2]	count=2
arg	division of x ||| x	count=1
arg	return index of value ||| value	count=1
function_arg	[function_1] [arg_2] ||| [function_1] with resultset [arg_2]	count=2
module	channel will be closed ||| core async	count=1
arg	defaults to 0 [arg_1] [arg_2] infinity ||| [arg_2] [arg_1]	count=3
arg	port [arg_2] ||| [arg_2] [arg_1]	count=1
module	[module] g ||| [module]	count=1
module	distribution of ||| generators	count=1
arg	in the ||| &amp; args	count=1
arg	invoke the [arg] ||| &amp; [arg]	count=3
arg	executes sql commands ||| db spec transaction? sql command &amp;	count=1
arg	maps in xrel with ||| xrel	count=1
function	from the named entry ||| from jarfile	count=1
function	left sibling ||| left	count=1
arg	to that result ||| &amp;	count=1
arg	test ||| key end test end	count=2
arg	[arg_1] symbol ||| [arg_1] [arg_2]	count=1
arg	the value at ||| found	count=1
module	right [module] ||| [module]	count=3
arg	of multimethod associated with ||| multifn dispatch val	count=2
function_arg	contents [arg_2] ||| [function_1] array 2d [arg_2]	count=3
function	[function_1] literal ||| [function_2] [function_1]	count=1
function	string representation of ||| stack element str	count=2
arg	of x [arg_2] ||| [arg_1] [arg_2]	count=7
function	of test if not ||| if	count=1
arg	a sorted collection test ||| test start key end test	count=2
arg	set of functions ||| fs	count=2
arg	true if [arg] names ||| [arg]	count=1
function	with a ||| with	count=1
arg	port [arg_2] ||| [arg_1] [arg_2]	count=1
function	[function_1] int ||| [function_1] remainder [function_2]	count=1
arg	stream s is a ||| s	count=1
function	hash ||| hash	count=1
arg	to the given key ||| key	count=1
function	clojure [function_2] ||| [function_2] [function_1]	count=3
function	of file paths ||| loader	count=1
arg	port passing to ||| port	count=1
module	args ||| logging	count=1
function	sequences given a ||| seq zip	count=1
module	of low ||| data	count=1
module	several [module] operations as ||| [module]	count=1
function	that result repeating for ||| as &gt;	count=1
arg	that z ||| z	count=1
function	column [function_2] ||| [function_1] [function_2]	count=1
function	zipper ||| seq	count=1
module	with optional type ||| core typed	count=1
module	uniform ||| generators	count=1
arg	nums are in ||| y &amp; more	count=3
function	var with ||| find var	count=2
function_arg	rint [arg_2] ||| [arg_2] [function_1]	count=1
arg	a and b ||| b	count=2
module	class clojure core match ||| core match	count=8
function_arg	[function_1] oldval ||| [function_1] atom [arg_2]	count=1
arg	expands to clojure ||| kw args? name docstring? attr	count=1
function	coerce to number ||| num	count=1
module	monad and return its ||| algo monads	count=1
arg	or name ||| string or	count=1
arg	v ||| v	count=4
arg	fntail which will ||| fntail	count=1
function	[function_1] array ||| [function_2] [function_1]	count=6
arg	resets [arg] for ||| iref [arg]	count=1
function	[function_1] validator-fn ||| [function_1] [function_2] iref	count=1
arg	construct a data representation ||| form splicing?	count=1
module	pretty ||| pprint	count=1
arg	table name and ||| table	count=1
arg	multimethod that [arg_2] ||| [arg_1] [arg_2]	count=2
module	clojure core logic ||| core logic	count=12
arg	collection test ||| start test start key end test end	count=2
arg	for use in ||| body	count=1
arg	class ||| type declaring class parameter types exception	count=1
module	with member type ||| core typed	count=2
arg	pred ||| pred	count=2
function	one element ||| element	count=1
module	match then matching ||| match	count=1
arg	if ||| x y &amp;	count=1
arg	construct a ||| form splicing?	count=1
function	for any ||| assert any	count=2
arg	a clojure delaysee clojure ||| t	count=1
arg	evaluation of [arg] returning ret ||| idx ret init [arg]	count=1
module	of [module] ||| [module]	count=1
function	allow asserts with a ||| with	count=1
arg	the atom ||| atom	count=1
arg	buff ||| buff	count=1
function	a zipper ||| seq	count=1
function	dispatch [function_2] ||| [function_2] [function_1]	count=2
arg	for class clojure ||| class op form env	count=1
arg	the form ||| form expected type	count=1
function_arg	[function_1] a success ||| [arg_2] [function_1]	count=4
module	a function to ||| unify	count=2
function_arg	[function_1] jar file ||| [function_1] [arg_2]	count=4
function	appended ||| appendo	count=1
arg	object to ||| object	count=1
arg	string debug-str ||| str	count=1
function	obj [function] ||| [function]	count=1
function	stop the given ||| thread stopper	count=1
arg	the [arg] or nil ||| [arg]	count=1
module	on uniform ||| data	count=1
function	quoted ||| check form info	count=1
function	a map ||| map	count=14
arg	an expected ||| ty	count=1
arg	x [arg_2] ||| [arg_2] [arg_1]	count=11
arg	the namespace ||| ns	count=2
function	potentially-ragged 2-dimensional array ||| array 2d	count=2
function	by [function] ||| first row [function]	count=3
arg	test ||| start test start key end test	count=2
arg	body during ||| body	count=1
arg	in [arg_2] ||| [arg_2] [arg_1]	count=1
function_arg	[function_1] given thread ||| [function_1] [arg_2]	count=3
arg	expands into forms after ||| forms	count=1
function	possibly unmunged ||| stack element str	count=2
arg	of f ||| f coll	count=1
arg	d is ||| d	count=1
arg	the cache ||| cache item	count=1
function	bitwise shift ||| bit shift	count=4
module	json ||| json	count=1
arg	x in coll ||| coll x	count=2
function	returns the name string ||| name	count=1
arg	message only ||| level throwable message	count=1
module	[module] finger_tree digit3 ||| [module]	count=3
function	annotated var coverage statistics ||| var coverage	count=1
arg	ch ||| ch	count=1
function_arg	mapped [arg_2] ||| [arg_2] [function_1]	count=1
arg	with custom comparator ||| comparator	count=1
function	structure basis object ||| create struct	count=1
arg	sc must be ||| sc start test start	count=2
function	is in keys ||| keys	count=1
arg	logs a message only ||| level throwable message	count=1
function_arg	[function_1] f on ||| [arg_2] [function_1]	count=2
module	starting with ||| data	count=1
module	the type environment ||| typed	count=1
module	file ||| classpath	count=1
module	of a graph that ||| algo graph	count=1
function_arg	transitive closure [arg_2] ||| [arg_2] [function_1]	count=2
arg	its-current-meta args [arg_2] ||| [arg_2] &amp; [arg_1]	count=1
arg	possibly polymorphic ||| varsym &amp; methods	count=1
arg	that returns ||| &amp;	count=1
module	uniform ||| data generators	count=1
function	all but the ||| drop	count=1
function	was called ||| bound	count=1
function	print the filter set ||| print	count=1
module	define local [module] that ||| [module]	count=1
arg	test s one of ||| start key end test end	count=2
arg	which the base ||| m which	count=1
arg	puts a [arg] into ||| port [arg]	count=2
function	recognized a specific ||| object?	count=1
arg	table ||| table row map	count=1
function	single class followed by ||| get proxy class	count=1
arg	[arg_1] name ||| [arg_1] [arg_2]	count=2
arg	as [arg] has ||| [arg]	count=1
arg	[arg_1] with ||| [arg_2] [arg_1]	count=17
module	is the current value ||| core	count=1
arg	[arg_1] vars ||| [arg_2] [arg_1]	count=4
arg	and installs a new ||| dispatch val &amp; fn tail	count=1
arg	sql commands on ||| spec transaction? sql command	count=1
module	and ||| generators	count=1
function_arg	hierarchical [arg_2] ||| [arg_2] [function_1]	count=1
module	clojure tools analyzer ||| tools analyzer	count=14
module	low and ||| generators	count=1
function	a possibly unmunged ||| stack element	count=2
arg	for class ||| declaring class flags	count=1
function	all [function_2] ||| [function_2] [function_1]	count=2
module	avl maps ||| data avl	count=1
function	unbound ||| unbound	count=1
function	data ||| ex data	count=1
arg	into forms after replacing ||| forms	count=1
arg	u into v ||| u v	count=3
arg	vector containing sql and ||| sql string	count=1
module	macros ||| tools macro	count=4
module	var ||| core typed	count=1
arg	value at the ||| found	count=1
function_arg	given client-side [arg_2] ||| [arg_2] [function_1]	count=1
function	under ||| clojure sources	count=1
function	ref ||| ref	count=1
function	a simple database query ||| query	count=1
function_arg	[function_1] x ||| [function_1] [arg_2]	count=16
arg	replaces all [arg_1] [arg_2] in ||| [arg_1] [arg_2]	count=2
arg	constructs ||| keyvals	count=1
arg	a maximum of n ||| n bindings &amp;	count=1
module	taken from the channel ||| core async	count=1
arg	collection test ||| key end test end	count=2
function	possibly unmunged string representation ||| stack element str	count=2
rep	logic [function_arg_2] ||| [module_1] map [function_arg_2]	count=4
arg	class ||| class op form env	count=1
module	value m-expr else return ||| algo monads	count=1
arg	[arg_1] [arg_2] that takes a variable ||| [arg_2] &amp; [arg_1]	count=4
arg	arguments ||| more	count=3
function_arg	inserts [arg_2] ||| [function_1] left loc [arg_2]	count=3
arg	[arg_1] xf ||| [arg_2] [arg_1]	count=3
arg	new method of multimethod ||| multifn dispatch val	count=1
arg	pattern ||| pattern	count=1
function	collection such ||| resto	count=1
arg	if o is a ||| o	count=1
function_arg	define a monad [function_1] [arg_2] ||| [function_1] [arg_2]	count=3
module	channel will be ||| core async	count=1
arg	for side-effects with ||| &amp;	count=1
function	sequences ||| seq	count=1
module	returns a sequence of ||| java classpath	count=1
function_arg	loop and [arg_2] ||| [function_1] [arg_2]	count=1
module	string or ||| string	count=2
arg	this loc without ||| loc	count=2
arg	given name ||| name	count=1
arg	in [arg] ||| timeout [arg] &amp;	count=1
arg	forms after ||| forms	count=1
function_arg	[function_1] u ||| [arg_2] [function_1]	count=1
arg	operations ||| operations	count=2
function	one element in ||| element	count=1
function	/ for with ||| for	count=1
function	the classpath ||| classpath	count=1
arg	loc ||| loc	count=10
function	[function_1] dispatch ||| [function_2] [function_1]	count=4
arg	of functions and ||| fs	count=2
arg	encodes into the output ||| output	count=1
function	on the loop ||| loop	count=1
function	empty string ||| str	count=1
module	jvm ||| jvm	count=1
arg	the agent state to ||| state &amp;	count=1
arg	associated with key ||| key	count=1
arg	m-result nil ||| m	count=2
arg	x [arg] else nil ||| pred [arg]	count=1
rep	returns a [module_1] [function_arg_2] ||| core [module_1] [function_arg_2]	count=2
arg	for test in ||| coll test	count=1
arg	a message only ||| throwable message	count=1
function_arg	[function_1] the nums ||| [function_1] [arg_2]	count=2
module	representation of ||| repl	count=1
arg	that returns the first ||| &amp; ps	count=1
arg	functions [arg_1] [arg_2] supplied at the front ||| [arg_2] [arg_1]	count=3
arg	installs a new method ||| val &amp; fn tail	count=1
function	gets the max-history of ||| max history	count=1
arg	name to that ||| name &amp;	count=1
arg	multimethod ||| multifn dispatch	count=2
arg	in [arg] expansion ||| fn bindings [arg]	count=1
arg	channels the first ||| t buf or n f buf or	count=1
arg	make a java array ||| array	count=1
arg	sized from sizer ||| sizer	count=2
arg	dispatches on ||| args env	count=2
arg	parent either via ||| parent	count=1
arg	exprs ||| exprs	count=3
function	class followed by ||| get proxy class	count=1
module	[module_1] arithmetic ||| [module_1] [module_2]	count=36
arg	sets the error-mode of ||| a mode	count=1
arg	[arg_1] n items ||| [arg_2] [arg_1]	count=3
arg	test s one of ||| test	count=2
function	asserts with a ||| assert with	count=1
function	sh see sh for ||| sh	count=1
function	sets the value ||| set	count=1
module	[module_1] logic ||| [module_1] [module_2]	count=48
arg	n [arg_2] ||| [arg_1] [arg_2]	count=2
module	channel and returns ||| core async	count=1
function_arg	suspendedstream [arg_2] ||| [function_1] [arg_2]	count=2
function	sin of ||| sin	count=1
arg	[arg_1] comparator and ||| [arg_2] [arg_1]	count=3
arg	test s one of ||| test start key end test end	count=2
arg	test s one ||| start test start key end test end key	count=2
arg	array with java ||| into array	count=1
function	argument is [function] than the ||| [function]	count=1
module	tools analyzer ||| tools analyzer	count=4
arg	[arg_1] f ||| [arg_2] &amp; [arg_1]	count=4
function	create an array with ||| byte array	count=1
arg	if [arg] is nil ||| [arg]	count=1
arg	f index item ||| f	count=1
arg	its contents returning a ||| &amp; opts	count=1
module	member type x ||| typed	count=1
module	given ||| zip	count=1
function_arg	map [arg_2] ||| data priority-map priority [function_1] by [arg_2]	count=2
arg	custom keyfn ||| keyfn	count=1
arg	[arg] names ||| [arg] and interfaces args	count=3
function	expose a reference as ||| create	count=1
function	summarises annotated var coverage ||| var coverage	count=1
module	and y ||| core	count=2
arg	of functions and returns ||| &amp; fs	count=2
arg	namespace with fixtures ||| ns	count=1
arg	of the same type ||| &amp; args	count=1
arg	expands into forms ||| &amp; forms	count=1
arg	n items [arg_2] ||| [arg_2] buf or [arg_1]	count=1
arg	fn1 if supplied ||| fn1	count=1
function	write ||| write	count=1
function	[function] pretty ||| [function] pprint	count=1
module	to given ||| tools	count=1
module	get ||| algo graph	count=1
arg	the object [arg] to ||| &amp; [arg]	count=1
function	list of local ||| local	count=1
arg	function for class ||| class	count=5
function	const ||| &gt;const	count=1
arg	key not present ||| key	count=1
arg	channels the first of ||| f buf or n	count=1
arg	if the value is ||| value	count=1
rep	vector containing [function_arg_2] ||| [function_arg_2] [module_1]	count=1
arg	object subject to the ||| object	count=1
arg	monad m into ||| m	count=1
arg	o ||| o	count=2
function	var coverage statistics ||| var coverage	count=1
function	by the ||| by	count=1
arg	table name ||| table row map	count=1
function	representation of a tagged ||| tagged	count=1
arg	method of multimethod associated ||| multifn dispatch	count=1
function	of chars ||| char	count=1
arg	[arg_1] coll ||| core sequence [arg_1] [arg_2]	count=1
module	avl sets which ||| data avl	count=1
function	sum of ||| +	count=1
arg	array [arg_2] ||| [arg_2] [arg_1]	count=4
module	channel with an optional ||| core async	count=1
arg	copies [arg] in ||| argv [arg]	count=1
function_arg	annotate record [arg_2] ||| [function_1] [arg_2]	count=2
function	a lazy sequence of ||| seq	count=1
function	[function_1] the methods ||| [function_1] [function_2]	count=2
arg	the items of from-coll ||| to xform from	count=1
module	on ||| data generators	count=1
function	value false false otherwise ||| false?	count=1
arg	that expands into forms ||| &amp; forms	count=1
arg	presumably for side-effects with ||| &amp;	count=1
arg	evaluates func passing in ||| map sql string &amp; params func	count=1
arg	topic of ||| topic	count=2
arg	:cond steps when adding ||| continuation	count=1
arg	val from port passing ||| port	count=1
function_arg	remainder [arg_2] ||| [function_1] int [arg_2]	count=2
arg	of the file they ||| f &amp; more	count=1
module	[module] count greater ||| [module]	count=4
arg	executes sql commands on ||| db spec transaction? sql command	count=1
arg	[arg_1] with binding-form ||| [arg_2] [arg_1]	count=2
arg	associates a ||| m k	count=1
arg	the ||| &amp; exprs	count=1
function	the transitive [function_2] ||| [function_2] [function_1]	count=1
function	[function] pretty print ||| [function] pprint	count=1
arg	with the given key ||| key	count=1
module	new collection in which ||| collection	count=1
arg	two channels the ||| f buf or	count=1
function	possibly ||| element	count=2
arg	which ||| m which	count=1
module	a [module] ||| algo [module]	count=4
function	sequence of the ||| seq	count=1
function_arg	conjoined [arg_2] ||| [arg_2] [function_1]	count=2
function_arg	waiting stream [arg_2] ||| [arg_2] [function_1]	count=4
arg	of [arg] ||| idx ret init [arg]	count=3
function	possibly cached value of ||| force	count=1
function	for ||| for	count=1
arg	sorted collection test s ||| test end	count=2
function	performs a depth-first post-order ||| postwalk	count=1
arg	step to the mexpr ||| mexpr	count=1
arg	[arg] data until ||| data [arg]	count=3
function	take a waiting ||| waiting	count=1
function	to substitute unification bindings ||| make occurs subst	count=1
arg	s is a ||| s	count=1
arg	a monad m into ||| m	count=1
arg	by [arg] starting with ||| [arg] init	count=1
function	sequence of all descendants ||| descendants	count=1
module	which *out* is ||| core	count=1
function	[function] of ||| get default [function]	count=1
function	recursively under ||| clojure sources	count=1
arg	keyfn custom [arg_2] ||| [arg_1] [arg_2]	count=3
arg	the error-mode of ||| a mode keyword	count=1
module	returns an ||| core	count=2
function	dispatch ||| dispatch	count=2
arg	specified padding length ||| length pad length	count=1
function	a value in ||| assoc in	count=1
arg	similar ||| syms	count=3
function	to stop the ||| stopper	count=1
arg	of x and y ||| x y	count=3
function	clojure core / for ||| for	count=1
arg	an optional exception-handler ||| n xform ex handler	count=1
module	a ||| zip	count=2
function	nested sequences given ||| zip	count=1
arg	successive items from coll ||| coll	count=1
arg	if [arg] if logical ||| [arg] m	count=1
arg	then evaluates func passing ||| sql string &amp; params func	count=1
arg	create [arg] indent at ||| [arg]	count=1
arg	a val ||| val	count=2
arg	[arg_1] failure continuation ||| [arg_1] [arg_2]	count=1
arg	table name and ||| table row	count=1
function	database connection [function] there is ||| db [function]	count=1
module	returns a [module] of ||| [module]	count=1
function	conditional ||| conditional	count=1
arg	functions ||| fs	count=2
arg	printing stream ||| kind colnum colinc	count=1
arg	tail [arg] is a ||| a [arg]	count=1
arg	at the index ||| index not	count=1
module	[module] passes ||| [module] passes jvm	count=2
arg	annotations ||| args	count=2
arg	n default 1 ||| n s	count=1
function	that are self-recursive ||| self recursive	count=1
function	returns a ||| classpath	count=1
function	the non-directory entries in ||| filenames in jar	count=1
arg	positional factory function ||| op form env children	count=1
arg	[arg_1] a table ||| [arg_2] [arg_1]	count=1
function	zipper for nested sequences ||| seq	count=1
arg	resulting function name ||| name	count=1
arg	monitor of x ||| x &amp;	count=1
module	facto application [module] ||| [module]	count=3
module	a source channel and ||| async	count=1
function_arg	[function_1] supports optional ||| [arg_2] [function_1]	count=3
arg	a java io writer ||| writer &amp; options	count=1
arg	memo-placed memoization ||| memoized fn	count=1
arg	the error-mode ||| a mode	count=1
arg	with ||| bindings &amp;	count=1
arg	a topic ||| p topic ch	count=1
function	of ||| element	count=2
arg	reduce of [arg] by ||| f init [arg]	count=1
function	left sibling of ||| left	count=1
module	distribution of low and ||| data	count=1
arg	set1 a superset ||| set1	count=1
arg	the binding yields ||| &amp; body	count=1
rep	core logic [function_arg_2] ||| [module_1] [function_arg_2]	count=4
arg	two channels the first ||| buf or	count=1
arg	set of clauses ||| clauses	count=1
arg	[arg] to ||| arg2 arg3 &amp; [arg]	count=3
function	starts with ||| starts with?	count=1
arg	the file they represent ||| &amp; more	count=1
function	keyed by ||| group by	count=2
arg	the input [arg_2] ||| [arg_2] [arg_1]	count=1
arg	its ||| opts	count=1
function	attempts to read a ||| read file	count=1
function	class ||| proxy class	count=2
arg	the gnu program ||| args option specs &amp; options	count=1
function	loop ||| length loop	count=2
arg	[arg] array starting ||| input offset length [arg]	count=3
function	summarises annotated var ||| var	count=1
function	first column ||| first column	count=1
arg	the offset index and ||| offset	count=1
arg	format ||| fmt &amp;	count=1
module	new collection ||| generic collection	count=2
arg	error-mode of agent ||| mode	count=1
function	floor ||| floor	count=1
arg	xs to coll ||| coll &amp; xs	count=1
arg	f and ||| f &amp;	count=1
module	clojure algo [module_2] ||| [module_1] [module_2]	count=16
function	[function_1] stack trace ||| [function_2] [function_1]	count=2
arg	the gnu program ||| args option specs &amp;	count=1
arg	factory function for class ||| class field	count=1
arg	non-nil [arg_1] [arg_2] equivalent value type-independent otherwise ||| == [arg_1] [arg_2]	count=1
arg	test s ||| start test start key end test end	count=2
arg	[arg_1] [arg_2] ||| [arg_2] db [arg_1]	count=3
arg	a topic of ||| p topic ch close?	count=1
arg	binds name to ||| name &amp;	count=1
function	yields a [function] ||| [function]	count=2
module	a type representing ||| core typed	count=1
module	a graph ||| graph	count=2
function	paths from ||| loader classpath	count=1
function	initial cause of ||| cause	count=2
arg	[arg_1] from port ||| [arg_2] fn1 [arg_1]	count=1
arg	collection test ||| test start key end test end key	count=2
module	[module] field ||| [module]	count=3
arg	a sequence of ||| g	count=1
function	local ||| &gt;local	count=1
function	object ||| object	count=2
function	file paths from ||| loader classpath	count=1
function	tagged [function_2] ||| [function_2] [function_1]	count=1
arg	the source [arg] which can ||| [arg]	count=1
arg	the context of an ||| &amp;	count=1
function	returns a ||| element	count=2
function	tan of ||| tan	count=1
module	returns ||| zip	count=1
arg	cf default ||| cf	count=1
module	distribution of low and ||| generators	count=1
arg	sorted collection test ||| test	count=2
function	agents [function] ||| [function]	count=2
function	a lazy seq of ||| response seq	count=1
module	type checks ||| typed	count=1
function	var coverage statistics ||| var	count=1
arg	[arg] an implicit ||| [arg]	count=3
module	a uuid ||| generators	count=1
rep	generic arithmetic [function_arg_2] ||| [module_1] map [function_arg_2]	count=4
function	watch ||| watch	count=1
function_arg	parents of tag ||| parents h tag	count=2
module	priority ||| data priority-map	count=1
arg	*out* preceeded by literal ||| debug	count=1
function_arg	[function_1] [arg_2] ||| [function_1] root [arg_2]	count=3
function	[function_1] ns ||| [function_1] [function_2]	count=6
arg	sorted collection test s ||| test start key end test	count=2
function_arg	loop [arg_2] ||| [arg_2] [function_1]	count=1
module	a ||| main	count=2
module	for nested sequences ||| zip	count=1
function	loop that iterates ||| loop	count=1
arg	match with [arg_2] ||| [arg_1] [arg_2]	count=1
arg	function for class ||| class field op form env extmap	count=1
rep	clojure reflect [function_arg_2] ||| [module_1] map [function_arg_2]	count=2
rep	[module_1] substvalue taking ||| [module_1] map [function_arg_2]	count=5
function	remainder of division ||| remainder	count=1
arg	from port passing to ||| port	count=1
function_arg	asin of x ||| asin x	count=2
arg	for class ||| type declaring class parameter types exception	count=1
module	a [module] which ||| core [module]	count=1
arg	nothing which defaults to ||| nothing which	count=1
arg	the gnu program argument ||| option specs &amp; options	count=1
arg	method of multimethod associated ||| multifn	count=1
module	of member type x ||| core typed	count=1
module	on uniform distribution ||| generators	count=1
function	solo ||| solo	count=1
function	tests if it is ||| instance?	count=1
arg	for class ||| class field op	count=1
arg	its contents returning ||| &amp; opts	count=1
function_arg	left of [arg_2] ||| [function_1] locs [arg_2]	count=1
arg	the ||| &amp; options	count=1
module	channel and supplies them ||| core async	count=1
arg	etc or ||| buf or	count=1
function	analyze on the loop ||| loop	count=1
rep	[module_1] constructor taking ||| [module_1] [function_arg_2]	count=3
arg	rel [arg_2] ||| [arg_2] [arg_1]	count=1
function_arg	[function_1] tr ||| [function_1] [arg_2]	count=2
function	maybeclass ||| &gt;maybeclass	count=1
function	[function_1] in the ||| [function_2] [function_1]	count=3
arg	of tr a throwable ||| tr n	count=1
arg	length ||| length	count=1
arg	for class ||| class parameter	count=1
function_arg	term [arg_2] ||| [arg_2] [function_1]	count=3
arg	a possibly polymorphic ||| varsym &amp;	count=1
function	query then evaluates ||| query	count=1
function_arg	[function_1] v ||| [function_1] root [arg_2]	count=3
module	polymorphic type with a ||| typed	count=1
function	a zipper ||| zip	count=1
arg	test ||| test end key	count=2
function	[function_1] is chosen ||| [function_1] [function_2]	count=3
arg	or a composition thereof) ||| buf or	count=1
arg	which the base values ||| which	count=1
arg	the metadata ||| metadata map	count=1
arg	the input ||| input	count=2
module	output channel ||| async	count=1
module	ast when ||| tools analyzer passes jvm	count=1
module	create a uuid ||| data generators	count=1
function	a sequence of file ||| classpath	count=1
module	the return type ||| core typed	count=1
function	a mismatched loop-local is ||| locals	count=1
function	locations to the right ||| right locs	count=1
function	in the jar ||| in jar	count=1
arg	offset index and ||| offset	count=1
module	uniform distribution of ||| data	count=1
function	bound to ||| with	count=2
arg	[arg] collection ||| [arg]	count=1
arg	for the cache system ||| cache	count=1
function_arg	[function_1] the jar ||| [function_1] [arg_2]	count=4
arg	x ||| x	count=36
rep	[module_1] suspendedstream taking ||| [module_1] map [function_arg_2]	count=5
arg	commands ||| command &amp; sql commands	count=1
arg	executes body [arg_2] ||| [arg_2] [arg_1]	count=2
function_arg	check a [arg_2] ||| [arg_2] [function_1]	count=1
arg	a message using ||| throwable message &amp; more	count=1
arg	of atom ||| atom	count=1
arg	connection [arg_2] ||| [arg_2] [arg_1]	count=3
module	and typed clojure type ||| core typed	count=1
module	m-expr else return ||| algo monads	count=1
arg	and the gnu ||| args option specs &amp;	count=1
module	a new collection ||| collection	count=2
function	all [function_2] ||| [function_1] [function_2]	count=2
function	lazy seq of ||| seq	count=1
function	number one greater than ||| unchecked inc	count=1
arg	for class ||| class field	count=1
function_arg	[function_1] item ||| [function_1] left loc [arg_2]	count=1
arg	given a regular expression ||| pattern	count=1
function	perform a full recursive ||| mexpand all	count=1
function	return last index ||| last index of	count=1
arg	printwriter ||| escape unicode?	count=1
module	of logic ||| core logic	count=1
arg	p etc or ||| or	count=1
function	a query then ||| query	count=1
function	[function_1] from ||| [function_2] [function_1]	count=1
function_arg	async [arg_2] ||| pipeline [function_1] [arg_2] close?	count=2
module	match then matching always ||| core match	count=1
arg	functions and returns ||| h &amp; fs	count=1
function	both int ||| unchecked multiply int	count=1
function	[function] proxy's ||| [function]	count=1
function_arg	[function_1] [arg_2] parallelism ||| pipeline [function_1] [arg_2] close?	count=4
function_arg	least [arg_2] ||| [function_1] x y [arg_2]	count=1
arg	calling [arg] ||| port val [arg] on	count=3
arg	the error-mode ||| a mode keyword	count=1
function	names a [function] form ||| [function]	count=1
module	object ||| data fressian	count=1
rep	returns [function_arg_2] ||| [module_1] [function_arg_2]	count=32
function_arg	runs [arg_2] ||| [arg_2] [function_1]	count=3
module	the return type of ||| typed	count=1
arg	agent state to ||| new state &amp;	count=1
module	of a graph ||| graph	count=1
arg	factory function for class ||| class field op form env extmap	count=1
module	that [module_2] ||| [module_2] [module_1]	count=4
function	read a ns ||| read ns	count=6
module	to ||| core unify	count=3
arg	functions and ||| f g &amp; fs	count=1
arg	first of l ||| l	count=1
arg	connection a [arg_2] ||| [arg_1] spec [arg_2]	count=3
arg	of two channels ||| f buf or	count=1
arg	items in coll ||| coll	count=5
function_arg	last [arg_2] ||| [arg_2] [function_1]	count=4
arg	[arg_1] atom to ||| [arg_2] f x y [arg_1]	count=2
module	type w [module] read ||| [module]	count=1
function	> binding-form init-expr evaluates ||| let	count=1
arg	if [arg_2] ||| == [arg_1] [arg_2]	count=1
function	checks a quoted ||| check form info	count=1
function_arg	[function_1] [arg_2] ||| [function_1] by [arg_2]	count=15
arg	that table ||| table	count=1
arg	set of named ||| name	count=1
function	prints the contents of ||| print	count=1
function	a single object ||| object	count=2
arg	of match with ||| match	count=1
function	both long ||| unchecked	count=1
arg	[arg] monad ||| [arg]	count=3
arg	with the value ||| &amp; forms	count=1
function	reads ||| read	count=4
function	left ||| left	count=2
function	unification bindings between two ||| occurs	count=1
arg	channels the ||| n f buf or	count=1
function_arg	division of [arg_2] ||| [function_1] int [arg_2]	count=3
arg	all instance [arg] ||| s [arg]	count=3
arg	for class ||| declaring class parameter types exception	count=1
arg	spec must be annotated ||| fn spec or annotation* expr*	count=1
function	results are exhausted ||| run*	count=1
arg	accumulate data on ||| empty accumulator	count=1
arg	[arg] removed ||| [arg] l	count=1
function	unmunged ||| str	count=2
arg	sym and returns ||| sym	count=1
arg	test s one of ||| test end key	count=2
arg	[arg] equivalent value ||| x [arg]	count=1
function	a possibly ||| stack element str	count=2
arg	if o ||| o	count=1
function	analyze on the loop ||| validate loop	count=1
arg	expected type syntax ||| expected type provided?	count=1
function	returns [function] ||| to [function]	count=3
arg	executes goals until results ||| goals	count=1
function	adds to [function_2] ||| [function_1] [function_2]	count=2
arg	[arg_1] of n ||| [arg_2] db [arg_1]	count=1
arg	class ||| class parameter types	count=1
module	vector containing the ||| rrb-vector	count=1
arg	non-nil [arg] monotonically non-increasing ||| [arg]	count=1
module	type checking ||| core typed	count=2
arg	of items ||| items	count=3
function	optional single class followed ||| class	count=1
arg	[arg_1] [arg_2] ||| [arg_2] f x y [arg_1]	count=23
function	sorted map ||| sorted map	count=1
arg	source [arg] which can ||| [arg]	count=1
function	by ||| by	count=3
function_arg	non-nil results [arg_2] ||| [arg_2] [function_1]	count=3
function_arg	rational value [arg_2] ||| [arg_2] [function_1]	count=1
function	create a set ||| set	count=1
function	in keys ||| select keys	count=1
function	n coll drop ||| split at	count=1
arg	non-nil [arg] ||| [arg]	count=2
module	sequence ||| classpath	count=1
arg	replaces all instance [arg_1] [arg_2] in ||| [arg_1] [arg_2]	count=4
arg	its arguments ||| y &amp; more	count=1
function_arg	[function_1] of tr ||| [function_1] [arg_2]	count=2
function_arg	contents of coll ||| vec coll	count=2
module	of low and ||| data	count=1
function	/ loop ||| loop	count=1
arg	x to a ||| x &amp; options	count=2
arg	the transducer [arg_2] ||| to [arg_2] from close? [arg_1]	count=1
module	macros that are used ||| macro	count=1
arg	test ||| key end test	count=2
function	right of loc ||| right	count=1
arg	functions and ||| g h &amp; fs	count=1
function	possibly unmunged string representation ||| str	count=2
arg	given a multimethod and ||| multifn	count=1
function	transientmaybeclass ||| -&gt;transientmaybeclass	count=1
function_arg	[function_1] [arg_2] ||| [function_1] auto [arg_2]	count=7
function	argument is [function] than ||| [function]	count=1
arg	[arg_1] with ||| into array&gt; [arg_2] [arg_1] syn javat cljt coll	count=4
function	loop ||| print length loop	count=2
module	and return ||| algo monads	count=1
module	unmunged string representation ||| repl	count=1
module	and is [module_2] ||| [module_1] [module_2]	count=2
function	new hash [function_2] ||| [function_2] [function_1]	count=1
function	executes ||| db do commands	count=1
arg	with custom keyfn custom ||| keyfn	count=1
arg	[arg] using ||| [arg]	count=3
arg	etc or a ||| buf or n	count=1
arg	channels the first of ||| or n f buf or n	count=1
module	a replacement string ||| string	count=1
function	unevaluated ns declarations. ||| ns decls	count=1
arg	associates ||| k	count=1
arg	[arg_1] coll ||| [arg_1] [arg_2]	count=1
module	collection [module] ||| [module]	count=2
module	given a function to ||| unify	count=2
arg	class ||| declaring class parameter	count=1
function	all but the last ||| drop last	count=1
arg	name if one already ||| name	count=1
module	with member type x ||| core typed	count=2
module	of contracts to existing ||| core contracts	count=1
rep	[module_1] suspendedstream taking ||| [module_1] [function_arg_2]	count=4
arg	of g ||| g	count=1
function_arg	the var [arg_2] ||| [function_1] [arg_2]	count=1
arg	expands to clojure core ||| kw args? name docstring? attr map?	count=1
arg	an ||| relative to	count=1
function	several vars ||| many	count=1
arg	path ||| path	count=1
function	from ||| from jarfile entry	count=1
arg	to the supplied collection ||| coll ch	count=1
arg	expr at each step ||| expr	count=1
function_arg	[function_1] f ||| [function_1] cancelled? [arg_2]	count=1
arg	the [arg] or ||| [arg]	count=1
arg	the gnu program ||| option specs &amp;	count=1
function	target ||| untap	count=1
arg	opts is ||| ast opts	count=1
function	thread-local bindings for ||| with bindings	count=2
arg	of the [arg] or ||| [arg]	count=1
arg	collection test s ||| start test start key end test end key	count=2
function_arg	non-namespaced keyword [arg_2] ||| [arg_2] [function_1]	count=1
arg	the [arg_2] ||| core with redefs bindings [arg_1] [arg_2]	count=1
arg	the same ||| &amp;	count=1
function_arg	[function_1] n ||| [function_1] [arg_2]	count=9
arg	applying f to its ||| f	count=1
arg	channels the first ||| buf or	count=1
arg	collection test ||| start key end test	count=2
module	returns a ||| classpath	count=1
function	potentially-ragged 2-dimensional array of ||| array 2d	count=1
arg	functions and returns a ||| f g &amp; fs	count=1
arg	and installs a ||| &amp; fn tail	count=1
function	contents of ||| vec	count=1
function	read ||| read	count=3
arg	function for class ||| class parameter types	count=1
arg	[arg_1] [arg_2] that takes a variable ||| [arg_2] [arg_1]	count=4
function	clojure core / loop ||| loop	count=1
function	check a ||| check	count=1
function	[function_1] the last ||| [function_2] [function_1]	count=3
arg	to *out* ||| &amp; options	count=1
function	= > binding-form init-expr ||| let	count=1
function	the method ||| method	count=1
arg	variables ||| lvars	count=1
arg	function for class ||| declaring class parameter types	count=1
arg	mix ||| mix	count=2
arg	the map ||| map	count=1
function	sets the ||| sets	count=1
function	keys ||| select keys	count=1
function	a snapshot ||| snapshot	count=1
arg	logs a message only ||| throwable message	count=1
arg	returns true [arg] is a ||| [arg]	count=3
function	priority [function] ||| priority [function]	count=2
function_arg	suspendedstream [arg_2] ||| [arg_2] [function_1]	count=2
arg	[arg] or ||| [arg]	count=2
function_arg	stop [arg_2] ||| [arg_2] [function_1]	count=1
function	clojure core / let ||| let	count=1
arg	that takes a coll ||| coll	count=1
module	symbol creating it if ||| core	count=1
function	tests ||| instance?	count=1
arg	of functions and returns ||| g h &amp; fs	count=1
module	[module] cljt ||| [module]	count=3
arg	vector of two channels ||| buf or	count=1
function	value in a ||| get in	count=1
function_arg	drop n ||| split at n	count=1
arg	sorted collection test s ||| test start key end test end	count=2
arg	or more interfaces ||| bases	count=1
arg	value at ||| found	count=1
function_arg	[function_1] of a ||| [arg_2] [function_1]	count=4
arg	non-nil if nums ||| more	count=1
arg	passes the ||| &amp;	count=1
arg	of an active ||| binding	count=1
arg	named methods and their ||| name	count=1
arg	a message using ||| level throwable message &amp;	count=1
arg	function af ||| af	count=1
function	returns the negation of ||| negate	count=1
function	from ||| loader	count=1
function_arg	the async [arg_2] ||| pipeline [function_1] n to [arg_2] from close?	count=1
function	type checks a quoted ||| check form	count=1
function	a [function] sequence ||| [function]	count=1
module	return a [module] ||| algo [module]	count=1
arg	named by ||| sym	count=1
arg	collection test s ||| test start key end test	count=2
arg	of multimethod associated with ||| multifn dispatch	count=2
arg	function f of ||| f	count=1
arg	if key not ||| map key not	count=1
function	for nested sequences ||| seq zip	count=1
module	a possibly unmunged string ||| repl	count=1
function_arg	substvalue taking a ||| &gt;substvalue m#	count=1
arg	operations ||| m plus operations	count=1
function	type checks a quoted ||| check	count=1
arg	etc or ||| or	count=1
function	column is [function_2] ||| [function_2] [function_1]	count=1
function	applied to the old ||| update	count=1
arg	if [arg] a rational ||| [arg]	count=1
arg	sql [arg_2] ||| [arg_1] [arg_2]	count=4
function	of loop that iterates ||| print length loop	count=1
arg	test s ||| end test	count=2
arg	custom comparator and optional ||| comparator &amp;	count=2
module	of file ||| java	count=1
arg	threads it into the ||| forms	count=1
module	given type ||| core typed	count=1
arg	sequence of items ||| items	count=1
arg	goals until [arg_2] ||| [arg_2] [arg_1]	count=1
arg	into forms ||| forms	count=1
arg	base ||| base which m plus	count=1
arg	custom comparator and ||| comparator	count=2
function	max-history of ||| max history	count=1
arg	[arg_1] body ||| [arg_2] [arg_1]	count=6
function	a possibly unmunged string ||| stack element str	count=2
function_arg	const [arg_2] ||| [function_1] [arg_2]	count=2
arg	specs with an optional ||| &amp; specs	count=1
arg	the compiler when it ||| doc string? attr map? params* body	count=1
arg	atom ||| atom	count=2
function	the left ||| left	count=1
function	[function] for a ||| [function]	count=1
module	of file paths ||| classpath	count=1
function	of loop ||| length loop	count=1
arg	of functions ||| h &amp; fs	count=1
arg	the given thread ||| thread	count=1
function_arg	left of [arg_2] ||| [arg_2] [function_1]	count=1
arg	annotations ||| &amp; maybe ann	count=1
function	the map of default ||| get default	count=1
arg	returns true [arg] ||| [arg]	count=3
arg	the compiler when it ||| doc string? attr map? params*	count=1
function	a new sorted set ||| sorted set	count=1
arg	of f index item ||| f	count=1
arg	state by s ||| s	count=1
arg	body [arg_2] ||| [arg_2] [arg_1]	count=11
arg	n ||| n s	count=1
arg	of two channels ||| n f buf or	count=1
arg	provides [arg] var manipulation ||| [arg]	count=1
function_arg	[function_1] of x ||| [arg_2] [function_1]	count=16
arg	class ||| declaring class parameter types exception types	count=1
arg	multimethod name ||| name	count=1
arg	an instance of the ||| &amp;	count=1
function_arg	annotate datatype [arg_2] ||| [arg_2] [function_1]	count=2
arg	the base ||| base	count=1
function_arg	the method [arg_2] ||| [function_1] [arg_2]	count=3
arg	functions and returns ||| f g &amp; fs	count=1
function	asserts with a ||| with message	count=1
function	returns a new sorted ||| sorted	count=2
arg	sc must ||| sc	count=2
arg	[arg_1] to *out* ||| [arg_1] [arg_2]	count=2
function	appended to ||| appendo	count=1
function	sequences given ||| seq	count=1
arg	filter p etc or ||| or	count=1
arg	apply fun ||| fun max	count=1
function_arg	[function_1] comparator ||| [arg_2] [function_1]	count=23
arg	topic of ||| topic ch close?	count=1
arg	in ||| body	count=1
function	removes the [function_2] ||| [function_1] [function_2]	count=3
module	and returns an ||| core	count=1
arg	that returns ||| &amp; ps	count=1
arg	test s ||| start test start key end test end key	count=2
arg	for creating that table ||| table	count=1
module	a source channel ||| core async	count=1
arg	[arg_1] clauses ||| [arg_1] [arg_2]	count=2
function	array of [function_2] ||| [function_2] [function_1]	count=16
function	like ref ||| ref	count=1
function	options from a sequence ||| options	count=1
function_arg	division [arg_2] ||| [function_1] int [arg_2]	count=3
function	are equal ||| =	count=1
module	contracts ||| core contracts	count=1
function	let ||| let	count=1
function	data a ||| ex data	count=1
arg	symbol corresponding to sym ||| sym	count=1
function	annotated var coverage statistics ||| var	count=1
module	and a source channel ||| core async	count=1
module	a is the first ||| core	count=1
arg	channels the first ||| buf or n f buf or n	count=1
module	evaluates expr [module] throws ||| [module]	count=1
arg	function name is declared ||| name	count=1
function	of the declared namespaces. ||| namespaces	count=1
arg	multimethod associated with dispatch-value ||| multifn dispatch val	count=2
arg	function for class clojure ||| class field	count=1
arg	collection test ||| test start key end test end	count=2
module	string on a regular ||| string	count=1
arg	two channels the first ||| t buf or n f buf or	count=1
function	a get operation ||| get	count=1
function	of file ||| loader classpath	count=1
module	returns an instance ||| core	count=1
module	process ||| core match	count=1
function_arg	[function_1] thread ||| [arg_2] [function_1]	count=2
function	values ||| values	count=1
module	[module_1] data from ||| [module_1] [module_2]	count=4
function_arg	class of [arg_2] ||| [function_1] [arg_2]	count=1
function	resultset as ||| resultset	count=1
module	a possibly ||| repl	count=1
module	output channel will ||| core async	count=1
arg	collection test s ||| start test start key end test	count=2
arg	vector of two channels ||| n f buf or n	count=1
arg	given [arg_1] [arg_2] ||| [arg_1] [arg_2]	count=10
arg	[arg_1] name ||| [arg_2] [arg_1]	count=2
function	the list of local ||| local	count=1
arg	any x [arg] else ||| pred [arg]	count=2
function	a [function] ||| [function]	count=11
module	return true if ||| algo generic comparison	count=2
module	object which will ||| fressian	count=1
arg	to a topic ||| topic	count=1
arg	with an optional ||| &amp;	count=1
arg	for test ||| test	count=1
function	the previous state ||| set state	count=1
arg	operations and ||| which m plus operations	count=1
module	ns-resolve and is understood ||| core	count=1
arg	every x [arg] ||| pred [arg]	count=1
arg	creates and installs a ||| &amp; fn tail	count=1
arg	a single response-seq ||| response timeout	count=1
module	item of json ||| json	count=1
function_arg	indirect children [arg_2] ||| [arg_2] [function_1]	count=4
arg	[arg_1] filters ||| [arg_1] [arg_2]	count=1
arg	name and column specs ||| specs	count=1
module	generic arithmetic ||| generic arithmetic	count=8
module	a function to ||| core unify	count=2
function	adds to the ||| add	count=1
arg	takes a map ||| map &amp;	count=1
arg	asynchronously takes [arg_2] ||| [arg_2] [arg_1]	count=3
function_arg	[function_1] the item ||| [function_1] left loc [arg_2]	count=1
arg	name to expr evaluates ||| expr	count=1
arg	takes a map of ||| map	count=1
function	for ||| make	count=2
arg	expression [arg_2] ||| [arg_2] [arg_1]	count=8
function_arg	[function_1] [arg_2] ||| [function_1] locs [arg_2]	count=10
arg	data to writer ||| writer data &amp; options	count=1
function	annotate datatype ||| ann datatype	count=1
arg	for use [arg] go ||| [arg]	count=1
arg	of the file ||| &amp;	count=1
function_arg	[function_1] the namespace ||| [function_1] [arg_2]	count=3
arg	named by the ||| sym	count=1
function	[function] there is ||| db [function]	count=1
function	gets the validator-fn ||| get validator	count=1
arg	[arg_1] body only ||| [arg_2] [arg_1]	count=3
arg	a table name and ||| table row map	count=1
arg	evaluates x ||| x	count=1
module	a sequence of file ||| java classpath	count=1
function	a new vector ||| vector	count=1
function	[function_1] [function_2] ||| [function_1] divide [function_2]	count=1
arg	around [arg] which defaults ||| [arg]	count=1
module	string ||| main	count=1
arg	[arg] leftmost ||| loc [arg]	count=2
function	an array of ||| array	count=1
arg	installs ||| fn tail	count=1
function	a fresh stringwriter ||| out str	count=1
arg	swaps the value of ||| &amp;	count=1
function	the agent is failed ||| agent error	count=1
arg	the monitor of x ||| x &amp;	count=1
arg	of the colls is ||| &amp; colls	count=2
module	fresh ||| core logic	count=1
module	results from type ||| core typed	count=1
function	map ||| map keyfn	count=1
arg	the specified padding length ||| length pad length	count=1
arg	[arg_1] ch ||| [arg_2] [arg_1]	count=7
function	adds to [function_2] ||| [function_2] [function_1]	count=2
function_arg	[function_1] timeout ||| [function_1] [arg_2]	count=3
function	identical to ||| compare and set!	count=1
module	for class clojure reflect ||| reflect	count=3
arg	the jar file ||| jar file	count=2
module	of file paths ||| java	count=1
arg	test ||| end test end key	count=2
arg	new method of multimethod ||| multifn dispatch	count=1
function	create a set with ||| set	count=1
function	under ||| find clojure sources in	count=1
arg	the compiler when ||| doc string? attr map? params* body +	count=1
module	[module] loc ||| [module]	count=3
arg	to val s ||| val &amp;	count=2
arg	the ||| specs &amp; options	count=1
function	sequence of ||| loader classpath	count=1
function	[function_1] a ns ||| [function_1] [function_2]	count=6
arg	of x and zero ||| x	count=1
function	restpattern ||| &gt;restpattern	count=1
arg	installs a ||| &amp; fn tail	count=1
arg	the binding yields a ||| &amp;	count=1
arg	java array [arg_2] ||| [arg_2] [arg_1]	count=4
function	a non-namespaced keyword ||| keyword	count=1
arg	[arg_1] [arg_2] if it is not ||| [arg_1] [arg_2]	count=1
function	create a list with ||| list	count=1
function	name string ||| name	count=1
function	removes all [function_2] ||| [function_2] [function_1]	count=2
arg	for class ||| class parameter types exception types flags	count=1
arg	map of additional ||| map	count=1
function	unmunged ||| element	count=2
arg	test s one of ||| start key end test	count=2
module	elements based on *rnd* ||| data generators	count=1
arg	[arg_1] [arg_2] array starting at index ||| [arg_1] [arg_2]	count=3
arg	the depth ||| depth	count=1
arg	jar [arg_2] ||| [arg_2] [arg_1]	count=1
function	substitute unification bindings between ||| occurs subst	count=1
function	file paths ||| loader classpath	count=1
rep	[module_1] local taking ||| [module_1] [function_arg_2]	count=2
arg	[arg_1] sigs ||| [arg_1] [arg_2]	count=3
arg	name in ||| name &amp;	count=1
function	possibly unmunged string ||| element	count=2
module	data from a ||| data	count=1
arg	[arg_1] value at ||| [arg_1] index [arg_2]	count=1
arg	in coll ||| coll	count=11
function_arg	[function_1] [arg_2] ||| [function_1] s [arg_2]	count=3
arg	function for class ||| type declaring class parameter types exception types	count=1
arg	a topic of ||| topic	count=2
arg	optional expected type syntax ||| provided?	count=1
arg	factory function for class ||| class op form env	count=1
function	initialize all of ||| if needed	count=1
arg	promise ||| promise val	count=1
function	representation of ||| element	count=2
module	clojure tools analyzer jvm ||| tools analyzer jvm	count=1
arg	[arg_1] comparator ||| [arg_1] [arg_2]	count=3
arg	executes ||| db	count=6
arg	[arg] closing when ||| [arg]	count=1
module	[module_1] arithmetic ||| [module_2] [module_1]	count=4
function_arg	[function_1] item as ||| [arg_2] [function_1]	count=1
arg	class clojure ||| class field op	count=1
arg	sc must be a ||| sc start test start key	count=2
module	channel and supplies them ||| core	count=1
function	left of loc starting ||| left	count=1
function	groups from ||| re groups	count=1
arg	inserts [arg] leftmost ||| loc [arg]	count=1
function_arg	[function_1] supplied keys ||| [function_1] [arg_2]	count=5
module	a possibly unmunged ||| repl	count=1
arg	[arg] byte ||| [arg] offset length	count=3
arg	zero or more interfaces ||| &amp; bases	count=1
function_arg	case [arg_2] ||| [arg_2] [function_1]	count=2
arg	a sorted collection test ||| start test start key end test end key	count=2
arg	collection test s one ||| test	count=2
function	gets the value in ||| get	count=1
function	result ||| reduced?	count=1
arg	taking ||| m#	count=12
function	a ||| seq zip	count=2
arg	sql ||| sql	count=1
arg	reader g in ||| g	count=1
arg	the input array ||| input offset	count=1
arg	body in a context ||| body	count=1
function	unmunged string ||| stack	count=2
arg	of named methods ||| name	count=1
arg	test s one ||| start key end test end	count=2
function_arg	[function_1] named by ||| [arg_2] [function_1]	count=7
function	of a post-ordered walk ||| post ordered nodes	count=1
arg	a database [arg] ||| [arg] spec option map	count=3
arg	map of additional data ||| map	count=1
module	application [module] ||| [module]	count=3
rep	... [function_arg_2] ||| [module_1] read ns [function_arg_2]	count=1
arg	[arg_1] of atom ||| [arg_2] f x y [arg_1]	count=3
function_arg	[function_1] with loc ||| [arg_2] [function_1]	count=6
function	of loop ||| loop	count=1
arg	sc must ||| sc start	count=2
arg	[arg] supplied at ||| [arg] &amp;	count=2
arg	func passing in the ||| sql string &amp; params func	count=1
function_arg	[function_1] namespace ||| [function_1] [arg_2]	count=3
module	sequence of ||| java classpath	count=1
arg	checked before [arg] current namespace ||| [arg]	count=1
function	trace ||| tracef	count=1
function_arg	[function_1] x and ||| [arg_2] [function_1]	count=2
function	the methods ||| methods	count=1
arg	collection test ||| start test start key end test	count=2
function	[function_1] map ||| [function_1] [function_2]	count=3
arg	true [arg] ||| [arg]	count=5
arg	for class ||| class parameter types exception types	count=1
function	is specified by a ||| by	count=1
function	declaration from the named ||| decl from	count=1
function_arg	[function_1] 3a: the ||| [function_1] [arg_2]	count=1
function	with components set to ||| into	count=1
arg	and the gnu program ||| specs &amp;	count=1
module	json-formatted ||| data json	count=3
arg	sql commands ||| spec transaction? sql command	count=1
arg	u into ||| u	count=1
function	count greater than 0 ||| nonemptyseqable	count=1
arg	type syntax and ||| type provided?	count=1
arg	executes [arg_2] ||| [arg_1] [arg_2]	count=1
arg	repeatedly executes body presumably ||| body	count=1
module	channel and ||| core async	count=2
module	classpath ||| java classpath	count=2
arg	topic of ||| p topic	count=2
arg	custom keyfn custom ||| keyfn	count=1
arg	the input [arg_2] ||| data codec base64 encode! [arg_1] [arg_2]	count=1
function	the loop ||| validate loop	count=1
arg	end defaults to length ||| end	count=1
arg	the value at the ||| not found	count=1
arg	the gnu program ||| specs &amp;	count=1
arg	f on ||| f	count=1
module	*out* ||| data json	count=1
arg	writer ||| writer	count=1
arg	function for class ||| type declaring class flags	count=1
function	mapped to the corresponding ||| zipmap	count=1
module	with optional type ||| typed	count=1
function	an optional single class ||| class	count=1
function_arg	next [arg_2] ||| [arg_2] [function_1]	count=4
arg	[arg] a possibly ||| xform [arg]	count=1
arg	sorted collection test ||| start test start key end test end key	count=2
function	hash code of ||| hash	count=1
arg	a table ||| table row	count=1
function	context ||| contexts	count=1
arg	a topic ||| p topic	count=2
arg	[arg_1] [arg_2] ||| data codec base64 encode! [arg_1] [arg_2]	count=4
function_arg	rint of [arg_2] ||| [arg_2] [function_1]	count=1
function_arg	[function_1] pred ||| [arg_2] [function_1]	count=1
arg	the multimethod name in ||| name &amp; args	count=1
function	with the [function] ||| with [function]	count=2
arg	function for class clojure ||| class op form	count=1
arg	evaluation of expr ||| expr	count=1
function	paths ||| classpath	count=1
function	removes the [function_2] ||| [function_2] [function_1]	count=3
function	value in ||| assoc in	count=1
arg	returns generic assertion code ||| msg form	count=2
arg	multimethod that dispatches on ||| &amp; args env	count=1
arg	[arg_1] [arg_2] if it is not ||| core sequence [arg_1] [arg_2]	count=1
arg	the specified ||| &amp; vs	count=2
arg	into forms after replacing ||| &amp; forms	count=1
module	annotate ||| core typed	count=3
function	checking print the ||| print filterset	count=1
module	level ||| logging	count=1
function	a possibly unmunged ||| stack element str	count=2
arg	given a database [arg_1] [arg_2] ||| [arg_1] [arg_2] params	count=1
function	symbol with ||| symbol	count=1
module	return true if all ||| algo generic comparison	count=1
arg	representation of a fn ||| fn name	count=1
function	a sequence of ||| loader	count=1
arg	key by [arg_2] ||| [arg_2] [arg_1]	count=1
function_arg	a term u ||| term u	count=1
arg	collection test ||| test end key	count=2
module	right ||| data zip	count=1
function	file paths from a ||| classpath	count=1
function_arg	var is ||| var v	count=1
module	a replacement string that ||| string	count=1
arg	start inclusive ||| start	count=1
arg	of two channels ||| buf or	count=1
function	a lazy seq ||| response seq	count=1
function	string representation of a ||| stack element str	count=2
module	client-side ||| tools nrepl	count=1
function	from the string ||| string	count=1
arg	no-arg [arg] in ||| &amp; [arg]	count=1
arg	annotations ||| maybe ann body expr	count=1
arg	value returns the dispatch ||| dispatch	count=1
arg	evaluates func passing in ||| &amp; params func	count=1
function	both int ||| unchecked add int	count=2
arg	memo-placed memoization cache ||| memoized fn	count=1
arg	or child ||| child	count=1
function	reify ||| reify	count=1
arg	channels the first ||| or n f buf or n	count=1
module	a zipper ||| zip	count=1
function	returns a ||| str	count=2
function	unmunged string representation ||| element str	count=2
arg	[arg] of ||| [arg]	count=1
function	the next ||| next	count=1
arg	class clojure ||| class op	count=1
function	string representation ||| stack	count=2
arg	v lying ||| v	count=1
function	specified by ||| by	count=1
function_arg	[function_1] 3a: ||| [function_1] [arg_2]	count=1
arg	keyfn custom comparator and ||| keyfn comparator &amp;	count=1
module	a uuid based ||| generators	count=1
module	data ||| data	count=10
function	local javadoc paths ||| local javadoc	count=2
arg	in which ||| which	count=1
arg	the specified length ||| length	count=1
arg	in the jar file ||| jarfile	count=1
function	both ||| unchecked subtract	count=1
arg	java array with ||| into array	count=1
function_arg	var v ||| var root v	count=1
module	fressian reader ||| data fressian	count=2
function	key of ||| key	count=1
function	returns a new hash ||| hash	count=1
arg	step where [arg] defaults to ||| [arg] end	count=1
arg	[arg_1] by val ||| [arg_2] [arg_1]	count=3
function	recognized a specific type ||| object?	count=1
module	components of a graph ||| graph	count=1
function_arg	mapped to [arg_2] ||| [function_1] keys [arg_2]	count=1
function	by the result of ||| by	count=1
function	a possibly unmunged ||| element	count=2
arg	and the ||| &amp;	count=1
arg	to filters ||| sym &amp; filters	count=2
arg	[arg] array ||| input offset length [arg]	count=3
module	string that you ||| string	count=1
module	core logic ||| core logic	count=12
function	returns a seq on ||| seq	count=1
function	a possibly ||| stack	count=2
arg	the binding yields ||| &amp;	count=1
arg	class ||| declaring class	count=2
function	paths from a ||| loader	count=1
arg	syntax and ||| type provided?	count=1
rep	[module_1] zero-type taking ||| [module_1] [function_arg_2]	count=4
function	[function_1] options from ||| [function_2] [function_1]	count=4
module	core memoize ||| core memoize	count=1
arg	reads all its contents ||| opts	count=1
module	a possibly ||| main	count=1
module	return a [module] the ||| algo [module]	count=1
arg	the map with the ||| map	count=1
function_arg	[function_1] taking ||| [function_1] [arg_2]	count=11
arg	given fntail which will ||| fntail	count=1
function	passed ||| the	count=1
arg	[arg] and ||| c [arg]	count=1
function	time bound-fn was called ||| bound fn	count=1
arg	[arg] raw ||| db spec options [arg]	count=1
arg	[arg] monotonically ||| [arg]	count=2
module	avl maps which ||| data avl	count=1
module	new-state [module] then un-fails ||| [module]	count=1
module	of the type ||| core typed	count=1
arg	function for class ||| class parameter	count=1
module	like ns-resolve and is ||| core	count=1
arg	base ||| base which m	count=1
arg	for class ||| name type declaring class	count=1
arg	function ||| f	count=2
function	asserts with ||| with message	count=1
arg	logs a message using ||| throwable message &amp;	count=1
arg	body only ||| body	count=1
arg	map ||| map &amp; body	count=1
module	return the ||| algo generic	count=1
module	vec ||| data generators	count=1
function	the proxy's fn map ||| proxy mappings	count=1
module	local symbol [module] ||| [module]	count=3
arg	[arg_1] [arg_2] ||| core derive [arg_1] [arg_2]	count=6
arg	[arg] for ||| iref [arg]	count=1
arg	test s one ||| test start key end test	count=2
arg	[arg_1] name if ||| [arg_2] [arg_1]	count=1
function	groups from the most ||| groups	count=1
function	for nested ||| seq zip	count=1
arg	mappings ||| keyvals	count=2
arg	value returns the dispatch ||| dispatch val	count=1
arg	of two channels ||| t buf or n f buf or	count=1
arg	of items ||| items t	count=1
arg	of tag ||| tag	count=2
arg	of n ||| n	count=4
function	max-history of a ref ||| ref max history	count=1
function	or ||| set error	count=1
function_arg	[function_1] keys using ||| [function_1] by comparator [arg_2]	count=6
function	[function_1] [function_2] function ||| [function_2] [function_1] function &amp;	count=1
function	map of keywords ||| map	count=14
arg	the gnu program ||| &amp;	count=1
arg	at end ||| end	count=1
function_arg	the string s ||| string opts s	count=2
arg	as per reduce of [arg_1] [arg_2] with init ||| core reductions [arg_2] [arg_1]	count=1
function_arg	[function_1] f and ||| [arg_2] [function_1]	count=1
function	an array with components ||| into array	count=1
arg	transport ||| transport	count=1
function	case 2: if the ||| case	count=1
function	name string of ||| name	count=1
module	match then ||| match	count=1
arg	a core memo-placed memoization ||| memoized fn	count=1
function	a possibly unmunged string ||| element	count=2
function	[function_1] right ||| [function_2] [function_1]	count=2
function_arg	[function_1] keys using ||| [arg_2] [function_1]	count=6
arg	[arg_1] v ||| [arg_1] [arg_2]	count=1
arg	value associated with key ||| key	count=1
function	declaration from ||| decl from jarfile	count=1
module	from a ||| classpath	count=1
function	possibly unmunged string ||| stack	count=2
arg	a function ||| f	count=1
function	one-type ||| &gt;one type	count=1
function	optional single class followed ||| get proxy class	count=1
function	sum ||| +	count=1
arg	[arg] type clojure ||| [arg]	count=1
module	returns a [module] which contains ||| core [module]	count=1
arg	body presumably [arg_2] ||| [arg_2] [arg_1]	count=2
arg	active ||| binding	count=1
arg	cf default - identity ||| cf	count=1
function	class followed ||| class	count=1
function	optional single class followed ||| proxy class	count=1
function_arg	[function_1] transport ||| [arg_2] [function_1]	count=3
arg	analyzes a clojure form ||| form env	count=1
arg	a set of functions ||| g &amp; fs	count=1
arg	monad operations ||| which m plus operations	count=1
arg	true if [arg] type ||| [arg]	count=1
arg	s ||| s	count=16
arg	two channels the ||| or n f buf or	count=1
module	monad describing computations ||| algo monads	count=1
arg	test s one of ||| key end test end	count=2
function	not recognized a ||| object?	count=1
arg	start inclusive and ending ||| start	count=1
arg	two channels the ||| or n f buf or n	count=1
arg	a vector containing sql ||| sql string	count=1
arg	div ||| div	count=1
arg	monad operations ||| m plus operations	count=1
function	a lazy seq ||| seq	count=1
function	that is the composition ||| comp	count=1
module	value m-expr else return ||| algo	count=1
arg	positional factory function for ||| op form env	count=1
arg	set of functions ||| g &amp; fs	count=1
module	polymorphic type ||| typed	count=1
arg	two channels the first ||| n f buf or	count=1
arg	connection and [arg_2] ||| [arg_1] spec option map [arg_2]	count=1
module	channel with an ||| core async	count=1
arg	filter p etc or ||| buf or	count=1
arg	named by the ||| name	count=1
function	trace ||| trace	count=3
function	of loop that ||| loop	count=1
function	returns an empty ||| empty	count=1
module	the goal [module] check ||| [module]	count=1
module	and type ||| typed	count=1
function	unmunged ||| stack element str	count=2
module	of file ||| classpath	count=1
function	map of keywords to ||| map	count=15
arg	executes sql commands ||| db spec transaction? sql command	count=1
function	method of ||| method	count=1
arg	returns the ref ||| ref n	count=2
arg	[arg_1] parent ||| [arg_2] [arg_1]	count=5
function	old ||| update	count=1
function_arg	the string [arg_2] ||| [function_1] [arg_2]	count=2
arg	of the monad operations ||| plus operations	count=1
arg	error-mode of ||| a mode keyword	count=1
function	of the non-nil results ||| keep indexed	count=1
arg	elements of coll ||| coll	count=2
arg	factory function for class ||| declaring class parameter	count=1
function	of values ||| values	count=1
module	algo generic arithmetic ||| algo generic arithmetic	count=12
function	lazy sequence of ||| lazy	count=1
arg	to the mexpr ||| expr mexpr	count=1
arg	g in ||| g	count=1
arg	in kmap ||| kmap	count=2
arg	channels the first of ||| buf or	count=1
function	suspendedstream ||| &gt;suspendedstream	count=1
module	optional type ||| core typed	count=1
arg	asynchronously takes a ||| on caller?	count=1
arg	symbol [arg] into a ||| [arg]	count=1
function_arg	executes [arg_2] ||| [arg_2] [function_1]	count=5
function	print style ||| logp	count=1
function_arg	the last [arg_2] ||| [arg_2] [function_1]	count=4
function	url object [function] per ||| [function]	count=1
module	results ||| core logic	count=4
arg	c ||| c	count=1
arg	[arg_1] out ||| [arg_2] [arg_1]	count=8
arg	xs to ||| xs	count=1
arg	applying f ||| f	count=1
function	[function_1] methods ||| [function_1] [function_2]	count=2
function	quoted form and ||| check	count=1
arg	creating it if needed ||| docstring? attr map? references*	count=1
arg	a sorted collection test ||| end test end key	count=2
function	with the keys ||| keys	count=1
arg	object to *out* ||| object	count=1
arg	function for class ||| class parameter types exception types flags	count=1
function	a quoted ||| check	count=1
function	[function_1] by ||| [function_2] [function_1]	count=1
module	like ns-resolve and ||| core	count=1
function_arg	floor [arg_2] ||| [function_1] [arg_2]	count=1
function	prints the ||| print	count=2
function	json ||| write json	count=2
arg	string [arg_2] ||| [arg_1] [arg_2]	count=1
function	a target ||| untap	count=1
arg	the error-mode ||| mode keyword	count=1
arg	test s one ||| start test start key end test	count=2
function	min-history of a ||| min history	count=1
arg	class ||| class field op form	count=1
arg	topic ||| p topic ch	count=1
module	new collection ||| algo generic collection	count=2
function	in a ||| get in	count=1
arg	representation of a fn ||| fn	count=1
function	both int ||| unchecked remainder int	count=1
function	collection such ||| firsto	count=1
function	a query then evaluates ||| db query	count=1
function	pretty print ||| pprint	count=1
function	to substitute unification ||| make occurs subst	count=2
arg	/ rsubseq for test ||| test x	count=1
arg	test ||| end test	count=2
function	[function_1] trace ||| [function_2] [function_1]	count=1
arg	test s one of ||| end test end	count=2
arg	repeatedly executes ||| &amp;	count=1
function	returns ||| stack element str	count=2
function	[function_1] of longs ||| [function_2] [function_1]	count=2
function	objects containing the contents ||| to	count=2
arg	for class ||| type declaring class	count=2
module	ast when ||| analyzer passes jvm validate-loop-locals	count=1
arg	positional factory ||| op form env children	count=1
arg	map ||| map	count=4
arg	clojure promisesee clojure core ||| t	count=1
arg	a number of types ||| types	count=2
function_arg	[function_1] of x ||| [function_1] int [arg_2]	count=4
function	wildcards then matching matching ||| wildcards	count=1
arg	[arg_1] file ||| [arg_2] [arg_1]	count=2
function_arg	sin of [arg_2] ||| [function_1] [arg_2]	count=1
function_arg	aliases for [arg_2] ||| [function_1] [arg_2]	count=1
arg	function for class ||| class op form env	count=1
function	reader conditional ||| reader conditional	count=1
arg	redefines vars while executing [arg_1] [arg_2] ||| [arg_1] [arg_2]	count=1
arg	factory function for class ||| type declaring class parameter types exception types	count=1
function	the last ||| last	count=1
arg	[arg] interface created ||| [arg]	count=2
module	a new collection in ||| algo generic collection	count=1
arg	[arg] is a ||| a [arg]	count=2
arg	multimethod associated ||| multifn	count=2
function	if it's possible to ||| offer!	count=1
function_arg	[function_1] [arg_2] ||| [function_1] keyfn comparator [arg_2]	count=3
arg	string if ||| x	count=1
function	recursive bindings in the ||| bindings	count=1
function	unmunged string ||| element	count=2
function	array of bytes ||| byte array	count=3
module	by [module] ||| [module]	count=3
function	[function_1] conditional ||| core [function_1] [function_2]	count=1
arg	single response-seq ||| response	count=1
function	with [function_1] [function_2] function ||| [function_1] [function_2]	count=1
arg	into the output ||| output	count=1
module	a polymorphic type with ||| core typed	count=1
rep	[module_1] [function_arg_2] ||| [module_1] waiting [function_arg_2]	count=5
function	takes a val from ||| &lt;!	count=1
function	version of loop ||| loop	count=1
module	[module_1] generic arithmetic ||| [module_1] [module_2]	count=32
function	removes all of ||| remove all	count=2
arg	arguments [arg_2] ||| [arg_2] [arg_1]	count=5
function	in ||| get in	count=1
function	unmunged string representation of ||| stack	count=2
arg	for the cache ||| cache	count=1
function_arg	acos [arg_2] ||| [function_1] [arg_2]	count=1
function	raw [function] ||| db query with [function]	count=3
function	a get ||| get	count=1
arg	the multimethod name ||| name	count=1
arg	the file they ||| &amp;	count=1
module	a zipper for ||| zip	count=1
arg	two channels the ||| buf or	count=1
module	contracts ||| contracts	count=1
function	new hash map with ||| hash map	count=1
arg	function for class ||| declaring class parameter types exception	count=1
function_arg	namespace [arg_2] ||| [arg_2] [function_1]	count=9
arg	two channels the first ||| buf or n	count=1
arg	collection test ||| test start key end test	count=2
function	binding of var ||| var	count=1
function_arg	method [arg_2] ||| [function_1] [arg_2]	count=3
arg	the monad operations and ||| m plus operations	count=1
function	the declared namespaces. ||| namespaces	count=1
function	stack [function_2] ||| [function_1] [function_2]	count=2
function	create a non-namespaced keyword ||| keyword	count=1
function	file ||| loader classpath	count=1
arg	v is ||| v	count=1
arg	of two channels the ||| buf or	count=1
arg	m-result ||| m	count=1
arg	factory function for class ||| class field op	count=1
arg	a success continuation ||| w success	count=1
arg	specified length starting ||| length	count=1
function	[function_1] [function_2] ||| [function_2] [function_1] function &amp;	count=1
module	a graph ||| algo graph	count=2
function	override ||| override	count=1
module	and returns ||| core	count=3
arg	mean around [arg] which defaults ||| [arg]	count=1
arg	[arg_1] op ||| [arg_2] &amp; [arg_1]	count=1
arg	logs a message ||| message	count=2
function_arg	[function_1] namespace ||| core [function_1] [arg_2]	count=3
function	[function] per ||| [function]	count=2
module	required ||| tools analyzer jvm	count=1
function_arg	[function_1] body with ||| [arg_2] [function_1]	count=1
arg	instance [arg] in ||| s [arg]	count=1
arg	items ||| items t	count=1
arg	apply f ||| f	count=1
function	from the named ||| from jarfile	count=1
arg	tr a throwable ||| tr n	count=1
arg	executes body ||| &amp; body	count=2
function	have occurred or the ||| await	count=1
arg	monad m into ||| m plus	count=1
function	returns a possibly unmunged ||| element str	count=2
arg	expands to ||| kw args? name docstring? attr	count=1
function_arg	for [arg_2] ||| [function_1] [arg_2]	count=1
function	unmunged string ||| stack element	count=2
arg	a database [arg] ||| [arg] spec table row	count=1
function	that is the juxtaposition ||| juxt	count=1
arg	specs [arg_2] ||| [arg_2] [arg_1]	count=8
arg	corresponding vals ||| vals	count=1
arg	test s ||| test start key end test end	count=2
function	returns a ||| stack element	count=2
arg	in ||| &amp; args	count=3
arg	class ||| class	count=7
function	print ||| print filterset	count=1
arg	channels the first ||| buf or n f buf or	count=1
function	from ||| loader classpath	count=1
arg	error-mode ||| a mode keyword	count=1
arg	monad operations and the ||| operations	count=1
module	possibly ||| repl	count=1
arg	vector of class ||| class	count=1
arg	[arg_1] [arg_2] with parallelism ||| [arg_2] [arg_1]	count=2
arg	if nums [arg_2] ||| [arg_2] [arg_1]	count=2
arg	for the ||| class	count=1
function	of ||| stack element	count=2
function	data a map if ||| ex data	count=1
module	solo ||| core async	count=1
arg	data until [arg] old-data new-data ||| data fun [arg]	count=1
arg	variables ||| &amp; lvars &amp; goals	count=1
arg	or a ||| buf or n	count=1
function	create an array ||| double array	count=1
arg	a classloader ||| loader	count=1
arg	value to the promise ||| promise	count=1
arg	functions and returns ||| g h &amp; fs	count=1
arg	[arg] else ||| pred [arg]	count=3
arg	transducer ||| ex handler	count=1
arg	function for ||| f	count=1
function	gets the min-history ||| min history	count=1
arg	adds [arg] transient ||| coll [arg]	count=1
arg	a map ||| map &amp;	count=1
function	of ||| loader	count=1
arg	bindings ||| bindings	count=1
function	connection [function] there is ||| db [function]	count=1
function_arg	first item [arg_2] ||| [function_1] [arg_2]	count=1
arg	a set of functions ||| g h &amp; fs	count=1
module	a goal ||| core logic	count=2
arg	of a and b ||| b	count=2
function	allow asserts with ||| with	count=1
module	macro ||| tools macro	count=1
arg	vector of two channels ||| buf or n f buf or	count=1
function	[function_1] all of ||| [function_1] [function_2]	count=1
arg	a topic of a ||| topic	count=2
function	wildcards then ||| wildcards	count=1
module	components of a graph ||| algo graph	count=1
arg	x by y ||| x y	count=6
function_arg	[function_1] xs to ||| [function_1] coll [arg_2]	count=1
arg	in which the base ||| which	count=1
module	[module_1] a ||| [module_1] [module_2]	count=1
function	removes all [function_2] ||| [function_1] [function_2]	count=2
function_arg	division [arg_2] ||| [arg_2] [function_1]	count=3
arg	returns ||| coll	count=1
function	time bound-fn was called ||| bound	count=1
arg	sql commands on ||| spec transaction? sql command &amp; sql	count=1
arg	a root sequence ||| root	count=1
arg	the jar ||| jar	count=1
arg	[arg_1] into v ||| [arg_1] [arg_2]	count=1
arg	to the promise ||| promise val	count=1
function	unmunged string representation ||| stack	count=2
function	substitute unification ||| occurs subst	count=1
arg	collection test s one ||| start test start key end test end	count=2
arg	env ||| env	count=1
function_arg	supplied [arg_2] ||| [function_1] [arg_2]	count=4
arg	of functions and ||| f g h &amp; fs	count=1
arg	to printwriter out ||| out escape unicode?	count=1
arg	padding length ||| length pad length	count=1
function	object [function] ||| [function]	count=1
arg	[arg_1] [arg_2] ||| [arg_2] [arg_1]	count=400
arg	coll is exhausted ||| coll	count=1
function_arg	[function_1] memo-placed memoization ||| [arg_2] [function_1]	count=1
arg	class ||| name type declaring class flags	count=1
function	of bytes ||| byte	count=1
module	special ops [module] ||| [module]	count=1
arg	two channels ||| buf or n f buf or n	count=1
arg	of match ||| match	count=1
function_arg	let [arg_2] ||| [arg_2] [function_1]	count=1
function	post-ordered walk ||| post ordered nodes	count=1
arg	oldval ||| oldval	count=1
arg	the compiler when ||| doc string? attr map? params*	count=1
function	returns the initial cause ||| cause	count=2
arg	value ||| not found	count=1
arg	[arg_1] [arg_2] with parallelism ||| to [arg_2] from close? [arg_1]	count=2
arg	associated [arg] function ||| docstring? attr map? [arg] fn &amp;	count=1
function	of bindings pushed with ||| bindings	count=1
function_arg	[function_1] n coll ||| [arg_2] [function_1]	count=4
function_arg	last n default ||| last n s	count=1
function	[function] proxy's fn ||| [function]	count=1
arg	[arg_1] string ||| [arg_1] [arg_2]	count=2
arg	the compiler when ||| doc string? attr map? params* body	count=1
arg	num ||| num	count=2
function_arg	stack trace [arg_2] ||| [function_1] [arg_2]	count=3
arg	[arg] equivalent value ||| x y [arg]	count=1
function	subscribes ||| sub	count=1
function	like defn ||| defn	count=1
function	an anonymous soft cut ||| fna	count=1
function	quoted form and returns ||| check form	count=1
arg	n coll ||| n coll	count=2
arg	the index ||| index not	count=1
function	options from a ||| options	count=1
module	that a is the ||| core logic	count=1
arg	test s one of ||| key end test	count=2
arg	channels ||| t buf or n f buf or n	count=1
function	nested ||| zip	count=1
arg	n items ||| n	count=2
function	returns ||| classpath	count=1
arg	table name and ||| table row map	count=1
function_arg	[function_1] p ||| [arg_2] [function_1]	count=2
function	[function_1] of floats ||| [function_2] [function_1]	count=2
function	write an ||| write	count=2
function	returns a ||| seq	count=1
module	contracts to existing functions ||| contracts	count=1
arg	the compiler when it ||| doc string? attr map? params* body + attr	count=1
function	untrace all fns in ||| untrace ns	count=1
arg	this loc without moving ||| loc	count=2
function	for ||| with	count=1
function	char ||| char	count=2
function	string representation ||| stack element	count=2
function	substitute unification ||| make occurs subst	count=2
module	return type of ||| core typed	count=1
arg	arguments in values ||| values	count=1
function_arg	patternmatrix [arg_2] ||| [arg_2] [function_1]	count=2
module	the from [module] ||| [module]	count=3
arg	operations and ||| m plus operations	count=1
arg	of the same ||| &amp;	count=1
module	from a ||| java	count=1
arg	channels ||| or n f buf or n	count=1
arg	etc or a composition ||| buf or n	count=1
arg	factory function for class ||| type declaring class parameter types exception	count=1
module	file paths from ||| java classpath	count=1
function	array of ints ||| int array	count=1
function	data a map ||| data	count=1
function_arg	[function_1] the timeout ||| [function_1] [arg_2]	count=3
module	returns a possibly unmunged ||| repl	count=1
arg	repeatedly apply fun to ||| fun max	count=1
function	val returns a new ||| sorted	count=1
arg	map entry ||| e	count=1
arg	success continuation ||| w success	count=1
arg	[arg_1] method sigs ||| [arg_2] [arg_1]	count=4
arg	true if a ||| x	count=1
function	the composition of those ||| comp	count=1
arg	collection test s one ||| start key end test end	count=2
function	string ||| stack element	count=2
function	the same [function] all at ||| extend [function]	count=1
function	booleans ||| boolean	count=1
function	the extend ||| extend	count=1
arg	with binding-form ||| bindings &amp;	count=1
function_arg	identical to [arg_2] ||| [function_1] atom [arg_2]	count=1
arg	monad operations ||| operations	count=1
arg	items of from-coll ||| to xform from	count=1
function	keyed ||| group	count=1
arg	of [arg] returning ||| idx ret init [arg]	count=1
function	all of the methods ||| all methods	count=1
module	channel and returns ||| async	count=1
function	didn't allow asserts with ||| with	count=1
function	ends a list begun ||| list	count=1
arg	forms after replacing the ||| &amp; forms	count=1
arg	array ||| array	count=3
module	file paths from a ||| classpath	count=1
arg	of multimethod ||| multifn	count=3
function	high parts ||| uuid	count=1
function	[function_1] set with ||| [function_2] [function_1]	count=7
function	pop one set of ||| pop thread	count=1
function	rounding mode to ||| with	count=1
arg	symbol ||| sym	count=1
arg	format fmt ||| fmt	count=1
function	if it's possible ||| offer!	count=1
arg	and returns the ref ||| ref n	count=2
function_arg	keyed by [arg_2] ||| [arg_2] [function_1]	count=1
arg	prob 0 ||| prob	count=1
arg	evaluates func passing ||| func	count=1
arg	the value [arg_2] ||| [arg_2] [arg_1]	count=4
arg	[arg_1] forms ||| [arg_1] [arg_2]	count=2
function	of default [function_2] ||| [function_2] [function_1]	count=4
arg	proxy instance ||| proxy	count=1
function	single class followed ||| class	count=1
arg	the symbol [arg] into ||| [arg]	count=1
function	[function_1] [function_2] function ||| [function_1] [function_2] function &amp;	count=1
arg	test s one of ||| start key end test end key	count=2
arg	of the file they ||| &amp; more	count=1
arg	f and ||| f	count=11
function_arg	[function_1] sql commands ||| [function_1] db [arg_2]	count=1
function	database query ||| query	count=1
arg	a monad in which ||| which	count=1
function	is a collection such ||| firsto	count=1
function	[function_1] right ||| [function_1] [function_2]	count=2
arg	and [arg] default 1 ||| [arg]	count=1
arg	map ||| map cause	count=1
function	creates a var ||| create var	count=1
arg	from port [arg_2] ||| [arg_2] [arg_1]	count=1
arg	body only the first ||| body	count=1
function	a collection such ||| resto	count=1
function	a sequence of ||| classpath	count=1
function	replacement ||| quote replacement	count=1
arg	jar file and returns ||| jarfile entry name	count=1
arg	given a database [arg_1] [arg_2] perform ||| [arg_1] [arg_2]	count=1
arg	and installs a new ||| &amp; fn tail	count=1
rep	hvec is a [module_1] [function_arg_2] ||| core [module_1] [function_arg_2]	count=1
function	string representation of a ||| stack	count=2
arg	[arg] parameters perform ||| option map sql [arg]	count=1
arg	non-nil [arg] monotonically non-decreasing ||| [arg]	count=1
arg	[arg_1] apply f ||| [arg_1] [arg_2]	count=2
arg	type syntax ||| provided?	count=1
arg	possibly polymorphic ||| varsym	count=1
arg	around [arg] which ||| [arg]	count=1
function_arg	[function_1] custom comparator ||| [arg_2] [function_1]	count=3
module	[module_1] goal that ||| [module_1] [module_2]	count=4
arg	coll to ||| coll &amp; colls	count=1
arg	[arg] interface ||| [arg]	count=2
module	of the given avl ||| data avl	count=1
function	checking print ||| print env	count=1
arg	that returns a var ||| &amp; body	count=1
function	the contents ||| vec	count=1
function	agent is failed ||| agent	count=1
arg	executes ||| &amp;	count=1
arg	with the value of ||| &amp; forms	count=1
function	returns a ||| seq zip	count=1
function	[function_1] for ||| [function_2] [function_1]	count=8
module	object which ||| data fressian	count=1
module	log ||| tools logging	count=1
function	unification bindings between ||| occurs	count=1
function_arg	while [arg_2] ||| [arg_2] [function_1]	count=4
module	source channel and ||| core async	count=1
arg	coerces [arg_2] ||| core sequence [arg_1] [arg_2]	count=3
function	take n coll drop ||| split at	count=1
arg	atomically sets the metadata ||| &amp;	count=1
arg	name in namespace ns ||| ns name &amp; args	count=1
function	not nil ||| some	count=1
function	array of shorts ||| short array	count=3
module	channel ||| core async	count=9
function_arg	all other [arg_2] ||| [function_1] [arg_2]	count=1
function_arg	[function_1] test ||| [function_1] [arg_2]	count=1
function	with sh see sh ||| with sh	count=1
module	collection [module] return ||| [module]	count=1
arg	where ks ||| ks	count=1
arg	yields a seqable object [arg_1] [arg_2] ||| core lazy seq [arg_1] [arg_2]	count=4
arg	installs ||| val &amp; fn tail	count=1
function	bitwise ||| bit	count=3
function	vars ||| vars	count=2
module	the methods [module] functions ||| [module]	count=1
arg	test in ||| coll test	count=1
function	streams to [function] ||| [function]	count=1
function_arg	leftmost [function_1] [arg_2] ||| zip insert [function_1] [arg_2]	count=3
function	min-history ||| ref min history	count=1
function	removes [function_2] ||| [function_2] [function_1]	count=9
function	files containing ns ||| ns	count=1
arg	of functions and returns ||| h &amp; fs	count=1
function_arg	future [arg_2] ||| [function_1] cancelled? [arg_2]	count=1
arg	or name contains ||| string or	count=1
arg	child relationship [arg_2] ||| [arg_2] [arg_1]	count=1
arg	[arg] else nil ||| pred [arg]	count=1
arg	evaluates func ||| &amp; params func	count=1
module	[module_1] level ||| [module_1] [module_2]	count=2
arg	reader g in the ||| g	count=1
module	creates and returns an ||| core	count=1
function	and ||| do	count=1
function	[function_1] javadoc paths ||| [function_2] [function_1]	count=5
arg	class ||| class op form env extmap	count=1
function	all descendants of location ||| descendants	count=1
arg	monitor of x ||| x	count=1
function	mapped ||| zipmap	count=1
function_arg	[function_1] [arg_2] ||| [function_1] by comparator [arg_2]	count=43
module	type representing a ||| typed	count=1
arg	by the compiler when ||| doc string? attr map? params*	count=1
arg	channels ||| n f buf or n	count=1
arg	keys are updated by ||| key val pairs	count=1
function_arg	returns a new priority [function_1] [arg_2] ||| [function_1] [arg_2]	count=8
arg	for the argument ||| class	count=1
arg	connection a [arg_2] ||| [arg_2] [arg_1]	count=3
arg	if x ||| x	count=4
module	override the return type ||| typed	count=1
arg	pub or a topic ||| p topic	count=1
arg	[arg_1] [arg_2] in ||| [arg_1] [arg_2]	count=4
arg	value at the ||| not found	count=1
arg	[arg] returning the ||| a idx ret [arg]	count=3
function	stream a ||| stream check	count=1
arg	instantiate a ||| inst of	count=1
function_arg	namespace named by ||| ns sym	count=1
function	hash [function_2] ||| [function_1] [function_2]	count=1
arg	namespace / sa ||| &amp; opt	count=1
function_arg	next loc in ||| next loc	count=1
function_arg	[function_1] of ||| [function_1] [arg_2]	count=7
arg	installs ||| dispatch val &amp; fn tail	count=1
function	substitute [function_2] ||| [function_2] [function_1]	count=8
arg	0 [arg] ||| start end [arg]	count=3
module	a graph that ||| graph	count=1
function_arg	[function_1] multimethod associated ||| [arg_2] [function_1]	count=3
function	possibly unmunged string ||| element str	count=2
function_arg	[function_1] keyfn custom ||| [function_1] by [arg_2]	count=1
arg	string ||| string	count=2
arg	given a database [arg_1] [arg_2] ||| [arg_1] [arg_2]	count=12
function	[function_1] literal ||| core [function_1] [function_2]	count=1
function	allow asserts with a ||| assert with message	count=1
arg	[arg] in ||| s [arg]	count=1
function	returns a possibly unmunged ||| str	count=2
arg	and the gnu program ||| &amp;	count=1
arg	function for class clojure ||| class field op form env	count=1
module	macros ||| macro	count=2
function_arg	[function_1] keyfn ||| [function_1] by [arg_2]	count=1
function	for nested sequences ||| zip	count=1
arg	message only if ||| message	count=1
arg	a message ||| message	count=2
arg	functions and ||| fs	count=2
arg	the time ||| &amp;	count=1
function_arg	takes a [arg_2] ||| [arg_2] [function_1]	count=2
arg	the transducer [arg_2] ||| [arg_2] [arg_1]	count=1
arg	forms ||| &amp; forms	count=1
function	of file paths ||| loader classpath	count=1
function	check a namespace ||| check	count=1
arg	a java io reader ||| reader &amp;	count=1
arg	of multimethod associated ||| multifn dispatch val &amp;	count=1
arg	optional ||| string &amp;	count=1
function	searches recursively under ||| find clojure sources in	count=1
function	test / form pairs ||| cond &gt;	count=1
arg	establishes [arg_1] [arg_2] ||| core derive [arg_1] [arg_2]	count=1
function_arg	[function_1] object ||| [function_1] [arg_2]	count=2
arg	of exprs ||| bindings &amp; exprs	count=1
arg	threads it into ||| forms	count=1
function	juxtaposition ||| juxt	count=1
rep	arithmetic [function_arg_2] ||| [function_arg_2] [module_1]	count=4
arg	of clauses ||| clauses	count=1
arg	of coll ||| coll	count=7
arg	from rdr ||| rdr	count=1
function	number one less than ||| dec	count=1
arg	rsubseq for test in ||| coll test	count=1
arg	apply fun to ||| fun	count=1
arg	installs a ||| fn tail	count=1
arg	sym ||| sym	count=2
function	recognized ||| object?	count=1
function	not recognized a specific ||| object?	count=1
module	returns a sequence of ||| classpath	count=1
arg	[arg_1] n ||| [arg_1] [arg_2]	count=3
function	an instance ||| class?	count=1
arg	map ||| map &amp;	count=1
arg	in [arg] ||| argv [arg]	count=1
arg	for class clojure ||| class field op form env	count=1
function	string representation of ||| element str	count=2
function	bindings pushed with push-binding ||| bindings	count=1
arg	goals until a ||| goals	count=1
arg	sorted collection test s ||| start test start key end test end	count=2
arg	name if one ||| name	count=1
arg	monad operations and the ||| m plus operations	count=1
module	arithmetic ||| arithmetic	count=4
function	read a ns ||| read file ns	count=1
arg	sorted collection test s ||| start key end test end key	count=2
arg	a coll and ||| coll	count=1
arg	types ||| &amp; types	count=2
arg	the pretty [arg] ||| [arg]	count=1
function	loop that iterates ||| print length loop	count=1
arg	action epxression ||| pat action	count=2
arg	an ipushbackreader or a ||| reader eof error? eof value	count=1
function	bindings in the ||| flatten bindings	count=1
module	a uuid based ||| data generators	count=1
arg	[arg] a ||| [arg]	count=5
function_arg	the least [arg_2] ||| [arg_2] [function_1]	count=2
arg	topic of ||| topic ch	count=1
function_arg	methods [arg_2] ||| [function_1] [arg_2]	count=1
arg	the namespace with ||| ns	count=1
function_arg	[function_1] s ||| [arg_2] [function_1]	count=6
module	polymorphic type with ||| core typed	count=1
arg	function for class ||| name type declaring class flags	count=1
function_arg	zero-type [arg_2] ||| [arg_2] [function_1]	count=2
function	the right of loc ||| right	count=1
arg	keyfn custom ||| keyfn	count=1
module	for jmx ||| java jmx	count=1
arg	func ||| sql string &amp; params func	count=1
arg	namespace [arg_2] ||| [arg_1] [arg_2]	count=4
function_arg	contents [arg_2] ||| [function_1] [arg_2]	count=1
function	dispatch [function_2] ||| [function_2] [function_1] function &amp;	count=2
function	pretty print dispatch ||| pprint dispatch	count=1
function	returns a ||| stack element str	count=2
arg	to [arg] fn ||| [arg] arg1 arg2 arg3	count=1
function_arg	a [function_1] [arg_2] ||| [function_1] [arg_2]	count=6
function	bindings map [function] ||| [function] unify	count=2
arg	connection [arg_2] ||| [arg_1] spec [arg_2]	count=3
arg	stream s is ||| s	count=1
arg	true if o is ||| o	count=1
arg	[arg] provided ||| [arg]	count=2
function_arg	[function_1] the item ||| [arg_2] [function_1]	count=1
arg	executes goals until ||| bindings &amp; goals	count=2
function_arg	resultset [arg_2] ||| [arg_2] [function_1]	count=1
function_arg	takes a [arg_2] ||| [function_1] [arg_2]	count=2
function	and ||| subtract	count=1
arg	of f index item ||| f coll	count=1
arg	child ||| child	count=1
module	return its result ||| algo	count=1
arg	p ||| p	count=1
function	a version of loop ||| loop	count=1
arg	parent) or child ||| child	count=1
function_arg	resultset [arg_2] ||| [function_1] [arg_2]	count=1
arg	operations ||| which m plus operations	count=1
arg	of [arg] returning ret ||| idx ret init [arg]	count=1
arg	monad operations and the ||| which m plus operations	count=1
arg	collection test s one ||| end test	count=2
function	type checking print the ||| print env	count=1
arg	as a sequence of ||| g	count=1
module	a new collection in ||| collection	count=1
function	an array ||| double array	count=1
arg	logs a message using ||| throwable message &amp; more	count=1
arg	keyfn ||| keyfn	count=2
arg	resets [arg] ||| iref [arg]	count=1
function	a sequence ||| classpath	count=1
function	first ||| first	count=1
arg	of value ||| value	count=2
arg	function for class ||| class parameter types exception types	count=1
function	possibly unmunged string representation ||| element	count=2
arg	rsubseq for test ||| test x	count=1
module	runtime like ns-resolve and ||| core	count=1
function	[function_1] with components ||| [function_2] [function_1]	count=2
function	char ||| unchecked char	count=2
function	a possibly unmunged ||| stack	count=2
arg	of two channels ||| buf or n f buf or	count=1
function_arg	[function_1] array ||| [arg_2] [function_1]	count=5
arg	at the time bound-fn ||| &amp;	count=1
module	of its ||| algo generic	count=1
module	left ||| data zip	count=1
arg	or name contains a ||| string or	count=1
function	with ||| assert with	count=1
function	division ||| divide	count=1
function	returns a ||| loader classpath	count=1
function	read [function_2] ||| [function_1] [function_2]	count=2
function	var ||| var	count=6
function	recognized a ||| object?	count=1
arg	coll and ||| coll	count=1
function_arg	record [arg_2] ||| [function_1] [arg_2]	count=2
function	of local [function_2] ||| [function_1] [function_2]	count=1
function	[function] *out* ||| [function]	count=1
module	the given [module] ||| [module]	count=3
arg	expands to clojure ||| kw args? name docstring? attr map? param	count=1
arg	of two channels the ||| or n f buf or n	count=1
function	the solo ||| solo	count=1
arg	returns the dispatch ||| dispatch	count=1
arg	nothing which defaults ||| nothing which	count=1
arg	[arg_1] [arg_2] ||| core sequence [arg_1] [arg_2]	count=1
module	during type ||| core typed	count=2
function	of floats ||| float	count=1
arg	is ||| a	count=1
arg	of ns ||| ns	count=1
arg	test s one of ||| test end	count=2
function	gets the min-history of ||| min history	count=1
function	[function_1] all of ||| [function_2] [function_1]	count=1
arg	class ||| type declaring class parameter types	count=1
function_arg	the least [arg_2] ||| [function_1] x y [arg_2]	count=1
arg	test ||| test x	count=1
arg	keyfn custom [arg_2] ||| [arg_2] [arg_1]	count=3
function	a possibly ||| element str	count=2
module	creates a channel ||| async	count=1
rep	waiting [function_arg_2] ||| [module_1] waiting [function_arg_2]	count=5
arg	or a ||| or	count=1
rep	[module_1] [function_arg_2] ||| [module_1] [function_arg_2]	count=169
function	client-side ||| client	count=1
function_arg	methods of multimethod ||| methods multifn	count=2
function_arg	restpattern taking ||| &gt;restpattern m#	count=1
function	clone of the java ||| aclone	count=1
arg	step to ||| step	count=1
function	substvalue ||| &gt;substvalue	count=1
arg	[arg] returning ||| idx ret init [arg]	count=1
module	file paths ||| java classpath	count=1
function	have occurred or ||| await	count=1
module	for ns ... ||| tools namespace	count=1
function	was called ||| bound fn	count=1
module	special ops [module] after running ||| [module]	count=1
arg	x [arg_2] ||| [arg_1] [arg_2]	count=9
arg	or a composition ||| or n	count=1
module	read [module] evaluate ||| [module]	count=2
function	returns a sequence of ||| loader	count=1
function	get operation ||| get	count=1
function_arg	[function_1] [arg_2] ||| zip [function_1] [arg_2]	count=3
function	the left sibling ||| left	count=1
module	a ||| generators	count=1
arg	associates ||| k &amp;	count=1
function	full recursive ||| mexpand all	count=1
function	form represented by ||| form	count=3
function	evaluates ||| when not	count=1
function	returns a sequence of ||| loader classpath	count=1
module	given [module_2] ||| [module_1] [module_2]	count=4
arg	or a ||| buf or	count=1
module	test including macros ||| test	count=1
arg	from port [arg_2] ||| [arg_1] [arg_2]	count=1
module	like when-let but ||| core typed	count=1
function	sequence ||| zip	count=1
arg	[arg_1] value ||| [arg_1] index [arg_2]	count=1
module	a channel with an ||| core async	count=1
arg	true if [arg] a floating ||| [arg]	count=1
arg	function and ||| f	count=1
arg	byte array [arg_1] [arg_2] ||| [arg_2] [arg_1]	count=2
module	returns non-nil ||| core	count=1
arg	custom comparator ||| comparator &amp;	count=2
function	floats ||| float	count=1
function	[function_1] version as ||| [function_2] [function_1]	count=1
arg	in the collection ||| coll	count=1
arg	children ||| children	count=1
arg	array with ||| into array	count=1
arg	a message only if ||| throwable message	count=1
arg	body in [arg_2] ||| [arg_2] [arg_1]	count=10
arg	custom keyfn [arg_2] ||| [arg_2] [arg_1]	count=3
module	a uuid based on ||| data generators	count=1
arg	[arg_1] containing sql ||| [arg_2] [arg_1]	count=3
function	get ||| get	count=2
arg	f and reads all ||| f &amp;	count=1
module	ast ||| tools analyzer	count=1
arg	by the compiler when ||| doc string? attr map? params* body	count=1
arg	the supplied collection ||| coll ch	count=2
arg	collection test s one ||| start test start key end test	count=2
arg	of functions ||| g &amp; fs	count=1
arg	a regular expression or ||| or pattern	count=1
arg	f applied to ||| f	count=1
function	in [function] ||| [function]	count=1
function	a string ||| str	count=1
arg	sorted collection test s ||| end test	count=2
function	data a map ||| ex data	count=1
function	the min-history of ||| ref min history	count=1
function	checks a quoted ||| check	count=1
function	representation of the current ||| testing vars	count=1
function	an array ||| byte array	count=1
arg	test [arg_2] ||| [arg_2] [arg_1]	count=2
module	type checks the ||| typed	count=1
module	based on ||| generators	count=1
function	[function_1] the last ||| [function_1] [function_2]	count=3
function	one element in a ||| element	count=1
arg	is a ||| not found	count=1
function_arg	[function_1] is constituted ||| core match [function_1] [arg_2]	count=1
function	[function_1] [function_2] of ||| [function_1] [function_2]	count=8
module	goal ||| logic	count=8
function	takes a val ||| &lt;!	count=1
function	map of default options ||| default options	count=1
function	[function_1] column is ||| [function_2] [function_1]	count=1
module	but with optional type ||| core typed	count=2
function	returns a ||| loader	count=1
arg	a sorted collection test ||| end test	count=2
arg	annotations ||| seq exprs &amp; maybe ann body expr	count=1
function	array of chars ||| char array	count=3
module	sorted ||| data avl	count=2
arg	sc must be ||| sc start test start key	count=2
arg	a namespace / sa ||| opt	count=1
arg	success continuation and ||| w success	count=1
module	type annotations ||| typed	count=2
function	list begun ||| end list	count=1
module	of ||| repl	count=1
arg	cache ||| cache	count=2
function	proxy's fn map ||| mappings	count=1
arg	key ||| coll key	count=1
arg	[arg_1] with replacement ||| string replace [arg_1] [arg_2]	count=2
arg	the binding ||| &amp; body	count=1
module	returns ||| main	count=1
module	sequence ||| java classpath	count=2
arg	and column specs with ||| &amp; specs	count=1
module	a sequence of ||| classpath	count=1
function	[function_1] of chars ||| [function_2] [function_1]	count=2
module	clojure type ||| typed	count=1
arg	withapply f ||| f	count=1
arg	the offset index ||| offset	count=1
function	of default [function_2] ||| [function_1] [function_2]	count=4
arg	error-mode of agent a ||| a mode	count=1
arg	or a composition thereof) ||| buf or n	count=1
function	of all descendants ||| descendants	count=1
function_arg	set [arg_2] ||| [arg_2] [function_1]	count=2
function_arg	[function_1] [arg_2] ||| [function_1] x y [arg_2]	count=4
arg	are ||| &amp;	count=1
arg	given keys ||| &amp; keys	count=1
arg	channels the ||| n f buf or n	count=1
function	/ for ||| for	count=1
function	context of thread-local bindings ||| bindings	count=1
function_arg	[function_1] prob ||| [function_1] [arg_2]	count=1
arg	a map ||| map &amp; body	count=1
arg	specs ||| specs	count=1
arg	of the clauses ||| &amp; clauses	count=2
function	[function_1] by ||| [function_1] [function_2]	count=1
arg	commands on the specified ||| command &amp; sql	count=1
function	of default options from ||| default options	count=1
function	returns a zipper for ||| seq	count=1
module	distribution ||| data	count=1
function	methods ||| methods	count=1
arg	with complement ||| y &amp; more	count=1
arg	out as ||| x out	count=1
arg	expands to ||| kw args? name docstring? attr map?	count=1
function_arg	[function_1] multimethod ||| [function_1] [arg_2]	count=8
function	a potentially-ragged 2-dimensional array ||| array 2d	count=1
function	nested sequences given ||| seq	count=1
arg	the ||| option specs &amp; options	count=1
function_arg	[function_1] [arg_2] ||| [function_1] atom [arg_2]	count=1
arg	in values ||| &amp; values	count=1
arg	and the gnu program ||| specs &amp; options	count=1
function	it's already a pretty ||| pretty	count=1
arg	establishes [arg_1] [arg_2] ||| [arg_1] [arg_2]	count=1
arg	match ||| match	count=1
arg	object [arg] ||| [arg]	count=1
arg	heterogeneous vectors ||| fixed* type ...	count=1
function_arg	least [arg_2] ||| [function_1] [arg_2]	count=1
function	sh see sh ||| sh	count=1
arg	object to *out* subject ||| object	count=1
arg	unify x ||| expression1 expression2	count=2
arg	expected type syntax ||| provided?	count=1
function	core / loop and ||| loop	count=1
arg	from an ipushbackreader or ||| reader eof error? eof value	count=1
arg	[arg] present ||| [arg]	count=2
module	understood by the type ||| typed	count=1
function	the loop ||| loop	count=1
function_arg	least of [arg_2] ||| [function_1] [arg_2]	count=1
arg	jar file ||| jarfile entry name	count=1
arg	functions ||| g h &amp; fs	count=1
module	return the ||| algo generic arithmetic	count=1
function	returns a possibly ||| str	count=2
function_arg	[function_1] an object ||| [arg_2] [function_1]	count=1
arg	with supplied keys using ||| &amp; keys	count=1
arg	of functions and returns ||| f g h &amp; fs	count=1
function	have occurred or ||| await for	count=1
function	result repeating ||| as &gt;	count=1
function	[function_1] shift ||| [function_1] [function_2]	count=2
arg	test s ||| start key end test end	count=2
function	string ||| stack	count=2
function_arg	constructor [arg_2] ||| [arg_2] [function_1]	count=2
arg	class ||| type declaring class	count=2
function_arg	the next [arg_2] ||| [arg_2] [function_1]	count=4
arg	or ||| buf or	count=1
arg	milliseconds has elapsed ||| ms	count=1
arg	collection test s one ||| test start key end test	count=2
arg	rdr ||| rdr	count=1
arg	sorted collection test s ||| key end test	count=2
arg	func passing in the ||| map sql string &amp; params func	count=1
function	to substitute unification ||| occurs subst	count=1
module	local [module] that are ||| [module]	count=1
arg	functions ||| g &amp; fs	count=1
function	of default ||| get default	count=1
function	sequence of file ||| classpath	count=1
arg	named by ||| name	count=1
module	stream that [module] ||| [module]	count=3
arg	to the mexpr ||| mexpr	count=1
function	non-nil results ||| keep indexed	count=1
arg	return [arg] ||| [arg]	count=1
arg	initial value of x ||| x	count=1
module	is returned ||| core	count=1
arg	compiler when ||| doc string? attr map? params* body	count=1
arg	into forms ||| &amp; forms	count=1
arg	namespace and [arg_2] ||| [arg_2] [arg_1]	count=5
module	uuid ||| data generators	count=1
arg	[arg_1] [arg_2] into port calling ||| [arg_2] [arg_1]	count=3
arg	collection test s ||| end test end key	count=2
module	this and ||| core	count=1
function	to read [function_2] ||| [function_2] [function_1]	count=2
function	of ||| str	count=2
function_arg	rint of x ||| rint x	count=2
arg	expands into forms ||| forms	count=1
function	the max-history ||| ref max history	count=1
function	from ||| from jarfile	count=1
function_arg	[function_1] supplied collection ||| [arg_2] [function_1]	count=1
arg	of the map entry ||| e	count=1
arg	multimethod associated with ||| multifn dispatch val &amp;	count=1
arg	evaluation of [arg] returning ||| idx ret init [arg]	count=1
arg	if [arg] type ||| [arg]	count=1
function	of locations to the ||| locs	count=2
arg	asynchronously puts [arg_2] ||| [arg_2] [arg_1]	count=1
arg	response-seq being ||| response	count=1
function_arg	method of [arg_2] ||| [function_1] [arg_2]	count=4
function	removes all of the ||| remove all	count=1
arg	function f ||| f	count=1
arg	if o is ||| o	count=1
module	monad ||| algo monads	count=2
arg	returns true if all [arg_1] [arg_2] provided as arguments have ||| core bound? [arg_1] [arg_2]	count=1
arg	the index ||| array idx idx2 &amp;	count=7
function	[function_1] [function_2] function ||| [function_2] [function_1]	count=1
function	patternmatrix ||| &gt;patternmatrix	count=1
function	error-mode of agent a ||| error mode	count=1
function_arg	in [function_1] [arg_2] ||| [function_1] template [arg_2]	count=1
function	default options ||| get default options	count=2
module	of file paths ||| java classpath	count=1
arg	byte array [arg] ||| input offset [arg]	count=1
function_arg	[function_1] coll which ||| [function_1] [arg_2]	count=3
arg	annotations ||| exprs &amp; maybe ann body expr	count=1
module	based on uniform distribution ||| generators	count=1
function	removes the ||| remove	count=2
arg	factory function for class ||| class parameter types exception types	count=1
arg	a [arg] into ||| port [arg]	count=2
arg	functions and returns ||| fs	count=2
arg	true if [arg] ||| [arg]	count=4
arg	[arg_1] [arg_2] ||| [arg_2] buf or [arg_1]	count=3
function_arg	[function_1] tag through ||| [function_1] h [arg_2]	count=2
function	and indirect children ||| descendants	count=1
function_arg	thread or agent to [function_1] [arg_2] ||| [function_1] [arg_2]	count=1
module	a sequence of file ||| java	count=1
arg	two channels the first ||| n f buf or n	count=1
arg	a table name ||| table row	count=1
arg	instantiate a call ||| inst of &amp;	count=1
arg	to the given keys ||| coll &amp; keys	count=1
arg	the same type ||| &amp; args	count=1
function	[function_1] namespace ||| [function_1] [function_2]	count=1
module	a [module] of the ||| [module]	count=2
function_arg	[function_1] object subject ||| [function_1] [arg_2]	count=1
arg	interface with the ||| &amp;	count=1
function	unmunged string ||| element str	count=2
arg	[arg_1] on ||| [arg_1] [arg_2]	count=3
function_arg	[function_1] that table ||| [arg_2] [function_1]	count=1
arg	channels the ||| t buf or n f buf or n	count=1
arg	or more interfaces ||| &amp; bases	count=1
module	first ||| core match	count=1
function	possibly unmunged ||| element	count=2
arg	[arg] parameters ||| option map sql [arg]	count=1
function	the juxtaposition ||| juxt	count=1
arg	x and [arg_2] ||| [arg_1] [arg_2]	count=3
arg	for class clojure ||| class field op form	count=1
arg	sc must ||| sc start test start key	count=2
arg	with complement ||| x y &amp; more	count=1
function_arg	[function_1] taking a ||| [arg_2] [function_1]	count=12
arg	[arg] associated ||| map? dispatch fn [arg]	count=3
arg	the mult ||| mult	count=1
arg	offset index ||| offset	count=1
function	a query then ||| db query	count=1
module	uuid ||| generators	count=1
function_arg	maybeclass taking ||| &gt;maybeclass m#	count=1
function	failed ||| agent	count=1
arg	expected type syntax and ||| type provided?	count=1
arg	expands into forms after ||| &amp; forms	count=1
arg	test s ||| start key end test	count=2
arg	regular expression ||| pattern	count=1
function	representation of a ||| stack	count=2
module	var metadata [module] calls ||| [module]	count=1
arg	establishes a [arg] ||| [arg] tag	count=1
function	of doubles ||| double	count=1
module	new collection in ||| generic collection	count=1
module	a possibly unmunged ||| main	count=1
arg	are updated by ||| key val pairs	count=1
function	thread-local bindings ||| bindings	count=1
function_arg	by the [arg_2] ||| [arg_2] [function_1]	count=2
arg	a topic ||| p topic ch close?	count=1
function	unification bindings ||| occurs	count=1
arg	prob ||| prob	count=1
function	single class ||| proxy class	count=1
arg	test s ||| end test end	count=2
function_arg	patternmatrix taking a ||| &gt;patternmatrix m#	count=1
arg	before [arg] current ||| [arg]	count=1
arg	multimethod and a dispatch ||| multifn	count=1
arg	a multimethod and a ||| multifn	count=1
arg	operations and ||| plus operations	count=1
arg	response-seq being read ||| response	count=1
module	but ||| typed	count=2
module	to a [module] of ||| [module]	count=1
arg	takes a map ||| map	count=1
function_arg	[function_1] keys ||| [arg_2] [function_1]	count=6
arg	[arg_1] from port ||| [arg_2] [arg_1]	count=1
arg	for class ||| class op	count=1
function	result and call report ||| do report	count=1
function	a mismatched loop-local ||| locals	count=1
arg	to newval ||| newval	count=1
function	monad [function] ||| monad [function]	count=3
arg	the gnu ||| specs &amp;	count=1
arg	function of ||| f	count=1
arg	taking n ||| n	count=1
arg	and installs ||| val &amp; fn tail	count=1
arg	goals until a ||| bindings &amp; goals	count=1
arg	of the input sets ||| sets	count=2
function_arg	reduced [arg_2] ||| [function_1] [arg_2]	count=1
function	[function_1] of local ||| [function_2] [function_1]	count=1
function	returns ||| stack	count=2
arg	p etc or a ||| buf or	count=1
arg	or a topic of ||| p topic	count=1
arg	named by name ||| name	count=1
arg	and logs a message ||| throwable message	count=1
arg	containing sql ||| sql string	count=1
function_arg	[function_1] [arg_2] ||| [function_1] int [arg_2]	count=16
arg	functions and returns ||| g &amp; fs	count=1
function	tab ||| tab	count=1
function	file ||| classpath	count=1
arg	a monad m into ||| m plus	count=1
arg	for ||| class	count=1
arg	port calling [arg] ||| port val [arg] on	count=3
module	given type ||| typed	count=1
module	-1 ||| data avl	count=1
arg	a [arg] ||| argv [arg]	count=1
arg	zero or more interfaces ||| bases	count=1
arg	dispatches on [arg_2] ||| [arg_2] [arg_1]	count=1
function	of ||| classpath	count=1
function	keys of the structure-basis ||| struct map	count=1
arg	a sorted collection test ||| test start key end test end	count=2
arg	spec must be annotated ||| spec or annotation* expr*	count=1
function	max-history ||| max history	count=1
arg	a reducing [arg] ||| [arg]	count=3
arg	corresponding values of ks ||| ks	count=1
function	string representation ||| element str	count=2
module	of a graph that ||| graph	count=1
function	for [function_2] ||| [function_1] [function_2]	count=1
function	to analyze and ||| analyze	count=1
arg	of tr a throwable ||| tr	count=1
function_arg	[function_1] coll which ||| [function_1] 2d [arg_2]	count=1
function	with a ||| with message	count=1
function_arg	[function_1] success ||| [arg_2] [function_1]	count=4
arg	replacement ||| replacement	count=1
arg	body with binding-form bound ||| bindings &amp; body	count=1
arg	evaluates func passing in ||| params func	count=1
arg	structure where ks ||| &amp; ks	count=1
function	new vector ||| vector	count=1
arg	values ||| values	count=1
arg	[arg_1] fn1 ||| [arg_2] [arg_1]	count=2
arg	[arg] is ||| a [arg]	count=2
function	to the old ||| update	count=1
arg	form ||| form env	count=3
module	attempts to ||| core unify	count=1
function	the current value ||| pr	count=1
function	returns nil ||| get	count=1
function	form ||| form info	count=1
arg	and the base ||| base	count=1
function	from the named entry ||| from jarfile entry	count=1
arg	for class ||| type declaring class parameter types exception types	count=1
function	form ||| check form*	count=1
function	map with custom ||| map keyfn	count=1
arg	sql ||| spec transaction? sql	count=1
arg	of coll which ||| coll	count=1
function	non-namespaced keyword ||| keyword	count=1
function_arg	in the jar ||| in jar jar	count=2
arg	sql commands on ||| spec transaction? sql command &amp;	count=1
rep	core logic [function_arg_2] ||| [module_1] map [function_arg_2]	count=4
arg	the ||| array idx idx2 &amp;	count=7
arg	keyfn custom comparator ||| keyfn comparator &amp;	count=3
arg	returns items from coll ||| coll	count=1
arg	class ||| class parameter types exception	count=1
arg	installs ||| &amp; fn tail	count=1
arg	persistent ||| t	count=6
arg	sets the metadata ||| &amp;	count=1
arg	and the gnu ||| args option specs &amp; options	count=1
function	[function_1] by the ||| [function_1] [function_2]	count=1
function	implements fn i e ||| fn?	count=1
function	binding-form init-expr evaluates ||| let	count=1
module	ensures [module] g succeeds ||| [module]	count=1
arg	a map of ||| map &amp;	count=1
function	returns the transitive closure ||| transitive closure	count=1
function	from ||| from	count=1
function	the transitive closure ||| transitive closure	count=2
function	the form represented ||| form	count=1
module	match then ||| core match	count=1
function	stack trace ||| trace	count=1
arg	to sym ||| sym	count=1
function	of file paths from ||| classpath	count=1
function	substitute unification bindings between ||| make occurs subst	count=1
function	conjoined ||| into	count=3
arg	opts is a ||| opts	count=1
function	file paths from ||| loader	count=1
arg	table ||| table	count=2
arg	vector containing sql ||| sql	count=1
function_arg	the supplied [arg_2] ||| [function_1] [arg_2]	count=4
arg	rank of x ||| x	count=1
arg	keys using ||| keys	count=2
arg	sql ||| sql string	count=1
function	error-mode of agent ||| error mode	count=1
arg	comparator and optional ||| comparator	count=2
module	ast when ||| tools analyzer passes jvm validate-loop-locals	count=1
function	rounding ||| with	count=1
function_arg	datatype [arg_2] ||| [function_1] [arg_2]	count=2
arg	the gnu program argument ||| args option specs &amp;	count=1
function_arg	conjugate [arg_2] ||| [function_1] [arg_2]	count=1
function	the non-nil results of ||| keep indexed	count=1
function	row ||| row	count=1
function_arg	[function_1] prob 0 ||| [arg_2] [function_1]	count=1
function	non-directory entries in ||| filenames in jar	count=2
arg	a table ||| table	count=1
arg	for class ||| type declaring class parameter types	count=1
function	set ||| set	count=4
arg	atom to newval if ||| newval	count=1
function_arg	[function_1] [arg_2] ||| [function_1] 2d [arg_2]	count=7
arg	to an agent ||| &amp; args	count=2
arg	which the ||| m which	count=1
function	create an array ||| byte array	count=1
function	gets [function_2] ||| [function_2] [function_1]	count=1
function	in keys ||| keys	count=1
module	string representation of a ||| main	count=1
module	[module_1] data ||| [module_2] [module_1]	count=4
function	sets the value in ||| set	count=1
module	its ast ||| analyzer	count=1
module	from type ||| core typed	count=1
arg	or ||| or	count=3
arg	comparator ||| comparator &amp;	count=6
function_arg	write [arg_2] ||| [arg_2] [function_1]	count=3
function	[function_1] int ||| [function_1] divide [function_2]	count=1
arg	class ||| class parameter	count=1
arg	[arg_1] [arg_2] from l exactly one ||| [arg_2] [arg_1]	count=4
arg	true [arg] value ||| [arg]	count=1
function	classpath ||| add classpath	count=1
function	[function_1] [function_2] ||| [function_2] [function_1]	count=240
module	and is understood by ||| core	count=1
module	type environment to *out* ||| typed	count=1
function	[function_1] int ||| [function_2] [function_1]	count=5
function	class followed by ||| proxy class	count=1
rep	logic [function_arg_2] ||| [function_arg_2] [module_1]	count=4
module	core match ||| core match	count=7
arg	all instance [arg] in ||| s [arg]	count=1
arg	executes goals until ||| db bindings &amp; goals	count=2
arg	factory function for class ||| class flags	count=1
module	given avl ||| data avl	count=1
arg	the given strings ||| &amp; args	count=1
function_arg	[function_1] y ||| [arg_2] [function_1]	count=2
function	representing an assoc operation ||| assoc	count=1
arg	a maximum of n ||| n bindings	count=1
function	version as ||| version	count=1
function_arg	[function_1] f ||| [function_1] [arg_2]	count=5
arg	jar file and ||| jarfile entry	count=1
module	returns a ||| repl	count=1
arg	the ||| specs &amp;	count=1
arg	installs a new method ||| fn tail	count=1
arg	state to ||| new state &amp;	count=1
arg	of a ||| g	count=2
module	possibly unmunged ||| main	count=1
arg	pretty [arg] ||| [arg]	count=1
arg	func passing ||| map sql string &amp; params func	count=1
function_arg	returns a new priority [function_1] [arg_2] ||| data priority-map priority [function_1] by [arg_2]	count=8
function	superclass constructor ||| proxy	count=1
arg	the [arg_1] [arg_2] ||| [arg_1] [arg_2]	count=8
arg	node [arg_2] ||| [arg_2] [arg_1]	count=2
function	given client-side ||| client	count=1
function	the max-history of a ||| ref max history	count=1
arg	a root ||| root	count=2
function	for nested ||| seq	count=1
arg	value of x and ||| x	count=1
arg	evaluates body in a ||| &amp; body	count=1
function	[function_1] all ||| [function_1] [function_2]	count=1
function	exhausted ||| db*	count=1
arg	define a ||| &amp; rest	count=2
module	a uuid ||| data	count=1
arg	the vars ||| &amp; vars	count=1
function	query then ||| query	count=1
function_arg	post-ordered walk [arg_2] ||| [function_1] [arg_2]	count=1
function	declarations in clojure source ||| find	count=1
module	type representing an ||| typed	count=1
arg	name in namespace ns ||| ns name &amp;	count=1
function	containing the contents of ||| to	count=2
arg	etc or a ||| or n	count=1
arg	sql commands on the ||| spec transaction? sql command	count=1
module	specified [module_2] ||| [module_1] [module_2]	count=2
arg	between l and o ||| o	count=1
module	relation that ||| logic	count=1
module	channel with ||| core async	count=1
function_arg	key of [arg_2] ||| [function_1] [arg_2]	count=1
arg	the input sets ||| sets	count=2
function	allow asserts with ||| assert with message	count=1
module	return its ||| algo monads	count=1
function_arg	[function_1] from port ||| [arg_2] [function_1]	count=2
arg	annotate [arg] interface ||| [arg]	count=1
arg	test s one ||| test end	count=2
arg	a clojure form ||| form env	count=1
arg	the compiler when ||| doc string? attr map? params* body + attr	count=1
arg	method of multimethod ||| multifn dispatch val &amp;	count=1
arg	as per reduce of [arg_1] [arg_2] with init ||| [arg_2] [arg_1]	count=1
arg	x and y ||| x y	count=9
arg	response-seq being read off ||| response timeout	count=1
arg	all [arg] provided ||| [arg]	count=1
function	dir ||| in dir	count=1
function	adds to ||| add	count=1
function_arg	[function_1] of value ||| [arg_2] [function_1]	count=1
function_arg	supplied [arg_2] ||| [function_1] keyfn comparator [arg_2]	count=1
arg	node at this loc ||| loc	count=4
arg	to [arg] ||| [arg] arg1 arg2 arg3	count=3
function	chars[] ||| chars	count=1
arg	map of ||| map &amp; body	count=1
function	returns [function_1] [function_2] coll which can be ||| [function_2] [function_1] coll	count=1
arg	out ||| x out	count=1
function	default [function_2] ||| [function_2] [function_1]	count=4
arg	and the gnu ||| option specs &amp; options	count=1
function	[function_1] unification bindings ||| [function_2] [function_1]	count=8
arg	of the specified ||| &amp; vs	count=2
arg	collection test s one ||| key end test end key	count=2
function_arg	by [arg_2] ||| [arg_2] [function_1]	count=1
function	negative ||| neg?	count=1
function	[function_1] bindings pushed ||| [function_2] [function_1]	count=1
function	future object [function] will invoke ||| future [function]	count=1
function	query ||| query	count=2
arg	the corresponding parameters ||| params	count=1
function	return the ddl string ||| table ddl	count=1
function	with ||| with message	count=2
arg	the jar [arg_2] ||| [arg_2] [arg_1]	count=1
arg	or ||| buf or n	count=1
arg	as obj withapply f ||| f	count=1
arg	first row [arg] by ||| [arg]	count=1
function	representation of ||| stack	count=2
module	state-monad function that ||| monads	count=2
arg	set of functions ||| f g &amp; fs	count=1
arg	channels the ||| or n f buf or n	count=1
function	an optional single class ||| get proxy class	count=1
arg	a message only if ||| message	count=1
function	stop the ||| stopper	count=1
arg	message using ||| throwable message &amp;	count=1
arg	and logs a message ||| message	count=1
module	return the difference ||| algo generic arithmetic	count=1
arg	test s one of ||| end test	count=2
function	returns a zipper ||| seq zip	count=1
module	create ||| data generators	count=1
arg	[arg] ensures ||| g [arg]	count=3
arg	single response-seq ||| response timeout	count=1
function	attempts to read ||| read	count=3
function	loop that iterates at ||| print length loop	count=1
arg	v lying between the ||| v	count=1
arg	node ||| node	count=1
arg	expands to clojure core ||| kw args? name docstring?	count=1
function	transitive [function_2] ||| [function_2] [function_1]	count=1
arg	the specified padding length ||| in length pad length	count=1
function_arg	methods of [arg_2] ||| [arg_2] [function_1]	count=1
arg	binds name [arg_2] ||| [arg_1] [arg_2]	count=3
function	a waiting [function_2] ||| [function_2] [function_1]	count=2
arg	converts x [arg_2] ||| [arg_2] [arg_1]	count=2
function	create a non-namespaced symbol ||| symbol	count=1
arg	the namespace with fixtures ||| ns	count=1
function	sequence ||| seq zip	count=1
function	a java [function] ||| [function]	count=1
function	sets the solo ||| solo	count=1
function	[function_1] left ||| [function_1] [function_2]	count=2
module	returns a possibly ||| repl	count=1
arg	n ||| n	count=23
arg	[arg_1] clauses ||| [arg_2] [arg_1]	count=2
arg	[arg] parameters ||| spec option map [arg]	count=2
function_arg	acos of [arg_2] ||| [arg_2] [function_1]	count=1
module	option vectors ||| tools cli	count=1
arg	class ||| class parameter types exception types flags	count=1
function	[function_1] column is ||| [function_1] [function_2]	count=1
function	immediate parents ||| parents	count=1
module	string representation of ||| main	count=1
rep	[module_1] const taking ||| [module_1] [function_arg_2]	count=2
arg	sorted collection test s ||| start key end test end	count=2
function	child ||| child	count=1
arg	all its ||| opts	count=1
module	and returns the ||| core	count=1
function	loop that iterates ||| length loop	count=1
function	[function] for ||| get [function]	count=1
arg	message using ||| level throwable message &amp; more	count=1
function	ddl string ||| table ddl	count=1
function	annotated var ||| var	count=1
arg	f and reads ||| f &amp;	count=1
function	searches recursively under ||| clojure sources in	count=1
arg	starting with loc ||| loc	count=3
module	goal that ||| logic	count=6
function	single class followed by ||| proxy class	count=1
function_arg	asin [arg_2] ||| [arg_2] [function_1]	count=1
arg	child relationship [arg_2] ||| core derive [arg_1] [arg_2]	count=1
function_arg	[function_1] custom keyfn ||| [function_1] by [arg_2]	count=1
arg	a symbol ||| symbol	count=1
module	polymorphic type with a ||| core typed	count=1
module	var metadata [module] calls it ||| [module]	count=1
arg	function for class ||| class op	count=1
module	string that you wish ||| string	count=1
arg	the monad operations ||| which m plus operations	count=1
arg	of x to ||| x &amp;	count=1
arg	the mexpr ||| expr mexpr	count=1
function	waiting stream a ||| waiting stream	count=1
function	methods of ||| methods	count=1
module	channel that ||| async	count=1
function_arg	write an [arg_2] ||| [function_1] [arg_2]	count=10
arg	a topic of a ||| p topic ch	count=1
arg	/ sa ||| syms &amp; opt	count=1
module	location loc starting with ||| data	count=1
arg	for class ||| name type declaring class flags	count=1
arg	for the specified length ||| length	count=1
arg	and name ||| name	count=2
function_arg	stop the [arg_2] ||| [arg_2] [function_1]	count=1
function	potentially-ragged 2-dimensional ||| 2d	count=1
arg	swaps the value ||| &amp;	count=1
module	ast when a ||| tools analyzer passes jvm validate-loop-locals	count=1
module	ast when ||| analyzer passes jvm	count=1
function	a potentially-ragged 2-dimensional ||| 2d	count=1
arg	to ||| x &amp;	count=2
arg	executes sql commands ||| db spec transaction? sql command &amp; sql	count=1
arg	calls cf default - ||| cf	count=1
module	the output channel will ||| async	count=1
arg	channels ||| buf or n f buf or	count=1
function	removes a [function_2] ||| [function_2] [function_1]	count=1
arg	to ||| &amp; options	count=5
function_arg	[function_1] namespace and ||| [arg_2] [function_1]	count=4
arg	defaults to 0 [arg_1] [arg_2] ||| core range [arg_2] [arg_1]	count=3
function	provided using the extend ||| extend	count=1
module	fressian reader ||| fressian	count=2
function_arg	[function_1] body ||| [arg_2] [function_1]	count=1
arg	to printwriter ||| escape unicode?	count=1
arg	calls function [arg] with ||| [arg]	count=1
function	are removed ||| dissoc	count=1
function	reader ||| reader	count=3
arg	its arguments ||| more	count=1
module	a ||| java classpath	count=4
function_arg	identical to [arg_2] ||| [arg_2] [function_1]	count=1
function	[function_1] the right ||| [function_2] [function_1]	count=6
function	the class named by ||| new	count=1
function	print the ||| print	count=2
function	indirect children of ||| descendants	count=1
arg	transport ||| transport timeout	count=1
function_arg	floor of [arg_2] ||| [function_1] [arg_2]	count=1
function	bound to the ||| with	count=1
arg	and installs ||| fn tail	count=1
arg	a coll ||| coll	count=1
arg	[arg] parameters perform ||| spec option map [arg]	count=2
function	to the async ||| async	count=1
arg	error-mode of ||| mode	count=1
arg	the ||| y &amp;	count=2
function_arg	[function_1] [arg_2] ||| [function_1] array [arg_2]	count=1
arg	a topic of a ||| topic ch	count=1
function	nth ||| nth	count=1
arg	[arg] value ||| [arg]	count=3
function_arg	[function_1] tr a ||| [arg_2] [function_1]	count=2
arg	the given key ||| key	count=2
arg	name to ||| name &amp; forms	count=2
arg	state to ||| new state &amp; options	count=1
function	shorts[] ||| shorts	count=1
function_arg	[function_1] of multimethod ||| [function_1] [arg_2]	count=8
function_arg	set with [arg_2] ||| [arg_2] [function_1]	count=4
arg	define a symbol ||| symbol	count=1
arg	at the key ||| key	count=1
arg	body in a ||| body	count=1
arg	of items ||| items t n	count=1
function	groups from the most ||| re groups	count=1
function_arg	parents [arg_2] ||| [function_1] h [arg_2]	count=3
function	constructor ||| &gt;constructor	count=1
module	on uniform distribution of ||| generators	count=1
module	a channel with ||| async	count=1
arg	coll which can be ||| coll	count=1
arg	the map entry ||| e	count=1
function	nested sequences given a ||| zip	count=1
arg	then evaluates func ||| map sql string &amp; params func	count=1
arg	tr a ||| tr n	count=1
function	reads the next object ||| read	count=2
module	based on ||| data	count=1
module	return its result ||| algo monads	count=1
arg	tag either via ||| tag	count=1
arg	[arg] or nil ||| [arg]	count=2
function	returns a zipper for ||| seq zip	count=1
arg	the result of f ||| f	count=1
rep	[module_1] substvalue taking ||| [function_arg_2] [module_1]	count=1
arg	of x ||| x	count=22
arg	the context [arg_2] ||| [arg_2] [arg_1]	count=2
function	a version of loop ||| print length loop	count=1
arg	sorted collection test s ||| end test end key	count=2
arg	tail [arg] is ||| a [arg]	count=1
arg	function for class ||| class field op form env	count=1
function	all descendants ||| descendants	count=1
function	given ||| seq zip	count=1
arg	define ||| &amp; rest	count=5
function	a waiting [function_2] ||| [function_1] [function_2]	count=2
function	in a ||| in	count=2
function_arg	the negation [arg_2] ||| [function_1] [arg_2]	count=2
function	transitive [function_2] ||| [function_1] [function_2]	count=1
arg	a success continuation ||| success	count=1
module	ast when a ||| tools analyzer passes jvm	count=1
function	string ||| stack element str	count=2
function	result of ||| reduced?	count=1
function	and indirect children of ||| descendants	count=1
arg	arguments ||| &amp; more	count=2
function_arg	[function_1] object to ||| [arg_2] [function_1]	count=1
arg	channels ||| or n f buf or	count=1
arg	the promise ||| promise	count=1
arg	body in another thread ||| body	count=1
arg	the protocol ||| protocol	count=1
arg	success continuation [arg_2] ||| [arg_2] [arg_1]	count=1
module	channel with an ||| async	count=1
arg	to a topic ||| topic ch close?	count=1
arg	asynchronously ||| on caller?	count=2
arg	adds [arg] transient collection ||| coll [arg]	count=1
function	chars ||| char	count=1
module	prints ||| java jdbc	count=2
module	files containing ns ... ||| tools namespace	count=2
arg	the args ||| f &amp; args	count=1
arg	the binding yields a ||| &amp; body	count=1
arg	sets the metadata for ||| &amp;	count=1
function	database connection [function] ||| db [function]	count=1
function	proxy's fn map ||| proxy mappings	count=1
arg	[arg_1] string ||| [arg_2] [arg_1]	count=2
arg	of x to ||| x &amp; options	count=2
arg	to a topic ||| p topic	count=1
function	*out* ||| print	count=1
function	array-map ||| map	count=1
module	returns an instance of ||| core	count=1
arg	function for class ||| type declaring class	count=2
arg	that ||| &amp; ps	count=1
function	paths from ||| classpath	count=1
rep	generic arithmetic [function_arg_2] ||| [function_arg_2] [module_1]	count=4
rep	[module_1] one-type taking ||| [function_arg_2] [module_1]	count=2
function	returns the value in ||| in	count=1
arg	printwriter [arg_2] ||| [arg_2] [arg_1]	count=4
arg	the value [arg_2] ||| [arg_2] x y [arg_1]	count=1
function	string representation ||| stack element str	count=2
function_arg	stream [arg_2] ||| [function_1] [arg_2]	count=4
arg	promise ||| promise	count=1
arg	its contents returning ||| opts	count=1
module	[module] the ||| [module]	count=1
function	base values are sequences ||| sequence	count=1
arg	the promise ||| promise val	count=1
function	representation ||| stack element	count=2
module	on uniform ||| data generators	count=1
function	of thread-local bindings for ||| with bindings	count=1
function	both int ||| unchecked subtract int	count=2
module	[module] the ||| algo [module]	count=1
function	binding-form bound to the ||| let	count=1
function	mean 1 / ||| geometric	count=1
function_arg	[function_1] is ||| [arg_2] [function_1]	count=2
function	pretty print [function_2] ||| [function_2] [function_1]	count=1
arg	evaluates body ||| &amp; body	count=1
function_arg	substvalue taking ||| &gt;substvalue m#	count=1
rep	the channel [function_arg_2] ||| [module_1] [function_arg_2]	count=4
arg	f ||| f &amp; silently	count=1
module	of low ||| generators	count=1
function_arg	[function_1] of the ||| [function_1] x y [arg_2]	count=2
function	remainder ||| remainder	count=1
function	result of a ||| reduced?	count=1
function	analyze and ||| analyze	count=1
function	in a nested associative ||| assoc in	count=1
arg	the metadata for a ||| &amp;	count=1
module	an open java io ||| java io	count=1
function	list begun with ||| list	count=1
arg	expr at each ||| expr	count=1
module	contracts to existing functions ||| core contracts	count=1
arg	[arg] monotonically ||| x [arg]	count=2
function	[function_1] shift right ||| [function_1] [function_2]	count=1
arg	all its contents ||| opts	count=1
function_arg	[function_1] success continuation ||| [function_1] [arg_2]	count=4
function	a var ||| var	count=1
arg	with key by val ||| key val	count=1
arg	of atom to be: ||| atom	count=1
arg	coll ||| coll	count=22
function	[function_1] [function_2] ||| [function_2] bit shift [function_1]	count=1
arg	m into a ||| m	count=1
function	is in keys ||| select keys	count=1
arg	namespace with ||| ns	count=1
module	the type ||| core typed	count=2
arg	func ||| map sql string &amp; params func	count=1
arg	of [arg] by ||| f init [arg]	count=1
module	a ||| java	count=2
arg	sql commands ||| spec transaction? sql command &amp; sql commands	count=1
function	predicate for the ||| pred	count=1
function	takes ||| &lt;!	count=1
function	remainder of division of ||| remainder	count=1
arg	etc until [arg] ||| f [arg]	count=2
function_arg	product of [arg_2] ||| [function_1] int [arg_2]	count=3
arg	test s ||| key end test end	count=2
rep	is [function_arg_2] ||| [module_1] [function_arg_2]	count=2
arg	of multimethod ||| multifn dispatch val &amp;	count=1
arg	form ||| form expected type	count=1
function_arg	the var is ||| var v	count=1
module	type with a ||| typed	count=1
module	member type x with ||| typed	count=3
arg	function for class ||| class field op	count=1
function	error ||| error	count=1
function	datatype ||| datatype	count=1
arg	two channels the first ||| or n f buf or n	count=1
function	sequence of file paths ||| classpath	count=1
module	[module_1] data from ||| [module_2] [module_1]	count=4
arg	java io writer ||| writer &amp;	count=1
function	warn ||| warn	count=1
arg	to val ||| val	count=1
arg	jar file ||| jarfile entry	count=1
module	of member type ||| typed	count=1
arg	sorted collection test ||| test end key	count=2
arg	parameters ||| params	count=1
module	given a function to ||| core unify	count=2
module	to [module] ||| [module]	count=3
module	returns an object of ||| core	count=1
arg	f index ||| f	count=1
module	a channel ||| async	count=2
function	to byte ||| byte	count=2
function_arg	in [arg_2] ||| [arg_2] [function_1]	count=2
function_arg	[function_1] [arg_2] ||| [function_1] left loc [arg_2]	count=6
arg	of the file they ||| f &amp;	count=1
function	file paths ||| loader	count=1
function	a zipper ||| seq zip	count=1
arg	table name ||| table row	count=1
function	seq on ||| seq	count=1
function	stack trace of ||| stack trace	count=2
function_arg	[function_1] n default ||| [function_1] [arg_2]	count=5
function	union of the given ||| union	count=1
arg	the jar file and ||| jarfile entry	count=1
function	row of the ||| row	count=1
arg	class ||| type declaring class parameter types exception types	count=1
arg	with ||| into	count=1
arg	of tr a ||| tr	count=1
function_arg	[function_1] [arg_2] by ||| [function_1] [arg_2]	count=4
arg	n items [arg_2] ||| [arg_2] [arg_1]	count=1
function	the proxy's fn map ||| mappings	count=1
arg	pred item returns ||| pred	count=1
function	a sequence of file ||| loader classpath	count=1
function_arg	coll drop [arg_2] ||| [arg_2] [function_1]	count=2
arg	the ||| &amp; fs	count=1
arg	f and reads all ||| f	count=1
arg	logs a message only ||| message	count=1
arg	collection test s ||| test start key end test end key	count=2
module	is the ||| core	count=1
function	proxy ||| proxy	count=2
arg	a table ||| table row map	count=1
function_arg	runs [arg_2] ||| [function_1] out &amp; [arg_2]	count=1
module	trace ||| tools trace	count=1
function	a map of keywords ||| map	count=14
function	pretty print [function] function ||| set pprint [function]	count=1
arg	in which the ||| m which	count=1
function_arg	ceil [arg_2] ||| [arg_2] [function_1]	count=1
function	form represented ||| form	count=3
arg	[arg_1] specified ||| [arg_2] [arg_1]	count=3
function	map with custom ||| map	count=2
arg	success continuation ||| success	count=1
arg	or a topic ||| p topic	count=1
arg	by the corresponding parameters ||| params &amp;	count=1
arg	of functions and ||| f g &amp; fs	count=1
arg	agent state to ||| state &amp;	count=1
function	a ||| str	count=4
arg	at this loc without ||| loc	count=2
arg	this loc ||| loc	count=2
module	to ||| unify	count=3
function	/ promise deliver ||| promise	count=1
function	[function_1] without sign-extension ||| [function_2] bit shift [function_1]	count=1
arg	of atom to newval ||| newval	count=1
function	assumes the state ||| fetch val	count=1
function_arg	[function_1] [arg_2] ||| [function_1] meter [arg_2]	count=2
arg	forms ||| forms	count=3
arg	of data ||| data	count=1
module	relation ||| logic	count=1
arg	and supports optional ||| binding : type? init* exprs*	count=1
function	type checking print ||| print	count=1
arg	factory function for class ||| type declaring class parameter types	count=1
arg	the action epxression ||| pat action	count=2
arg	channels the first ||| n f buf or n	count=1
function	repeating for each ||| as &gt;	count=1
arg	if [arg] ||| [arg]	count=4
module	ns-resolve and ||| core	count=1
function_arg	immediate parents [arg_2] ||| [function_1] h [arg_2]	count=3
function_arg	tan of [arg_2] ||| [arg_2] [function_1]	count=1
module	its value [module] ||| [module]	count=1
module	member type x ||| core typed	count=1
module	ensures [module] g ||| [module]	count=1
function	[function_1] without sign-extension ||| [function_2] bit [function_1]	count=1
arg	in the ||| &amp;	count=1
function_arg	one-type [arg_2] ||| [arg_2] [function_1]	count=2
arg	sorted collection test ||| key end test end	count=2
arg	the ||| args option specs &amp;	count=1
function_arg	asin of [arg_2] ||| [arg_2] [function_1]	count=1
function	class followed ||| get proxy class	count=1
function	var object ||| var	count=1
arg	object subject ||| object	count=1
module	of results from type ||| core typed	count=1
arg	printer control variables ||| kw args	count=1
function	reads the first object ||| read	count=1
arg	changes [arg_1] [arg_2] new-state ||| [arg_1] [arg_2]	count=2
function	sum of all other ||| -	count=1
function	for println ||| log	count=1
function	proxy ||| construct proxy	count=1
arg	newval if ||| newval	count=1
function	[function] there ||| db [function]	count=1
function	source files containing ns ||| ns	count=1
arg	mult ||| mult	count=3
function	a ||| seq	count=2
arg	fntail which ||| fntail	count=1
module	goal [module] check ||| [module]	count=1
function	the max-history of a ||| max history	count=1
arg	supplied ||| ch	count=1
arg	of two channels the ||| or n f buf or	count=1
arg	p etc or ||| buf or	count=1
arg	n possibly the same ||| n	count=1
function	the classpath ||| add classpath	count=1
arg	coll is ||| coll	count=1
arg	variables ||| lvars &amp;	count=1
module	if ||| core	count=3
function_arg	[function_1] num ||| [arg_2] [function_1]	count=2
arg	collection test ||| start key end test end	count=2
arg	/ sa ||| opt	count=1
module	type ||| core typed	count=34
arg	function for class ||| type declaring class parameter types	count=1
arg	if x is the ||| x	count=1
arg	using an ||| a	count=1
arg	array a using an ||| a	count=1
arg	and a failure continuation ||| cont failure cont	count=1
function	the transitive [function_2] ||| [function_1] [function_2]	count=1
arg	keyfn custom comparator ||| keyfn comparator	count=1
arg	returns true [arg_1] [arg_2] provided as arguments have ||| [arg_1] [arg_2]	count=1
arg	possibly polymorphic ||| varsym &amp;	count=1
function_arg	[function_1] f index ||| [arg_2] [function_1]	count=2
arg	positional factory function for ||| f	count=1
arg	map with ||| map	count=1
function	declaration from the ||| decl from jarfile entry	count=1
arg	set of functions ||| &amp; fs	count=2
arg	positional factory function ||| op form env	count=1
function	atom ||| atom	count=2
arg	/ sa ||| &amp; opt	count=1
arg	the offset ||| offset	count=1
arg	at most n items ||| buf or n	count=1
function	possibly unmunged ||| str	count=2
function	given ||| seq	count=1
arg	name to ||| name &amp;	count=1
function	map with supplied mappings ||| map	count=2
function	first column [function_2] ||| [function_1] [function_2]	count=1
arg	c in ||| c	count=1
function	left sibling of the ||| left	count=1
arg	two channels ||| f buf or n	count=1
arg	of two channels ||| buf or n	count=1
function	possibly unmunged string representation ||| stack element	count=2
arg	coll [arg_2] ||| core reductions [arg_2] [arg_1]	count=2
arg	of functions and returns ||| fs	count=2
module	during type checking ||| core typed	count=2
arg	a sorted collection test ||| start test start key end test end	count=2
arg	of a node ||| g	count=1
arg	form is ||| form	count=1
arg	two channels the first ||| f buf or	count=1
arg	if ||| x y	count=2
function_arg	[function_1] nums ||| [function_1] x y &amp; [arg_2]	count=1
arg	of the [arg] ||| [arg]	count=3
arg	map of additional data ||| map cause	count=1
function	array of doubles ||| double array	count=3
arg	that accumulate data on ||| empty accumulator	count=1
arg	type syntax ||| expected type provided?	count=1
function	a possibly unmunged ||| element str	count=2
arg	the mexpr ||| mexpr	count=1
arg	defaults to 0 [arg_1] [arg_2] infinity ||| core range [arg_2] [arg_1]	count=3
module	member type ||| typed	count=1
arg	specified length starting at ||| length	count=1
arg	timeout ||| timeout	count=1
function	same [function] all ||| extend [function]	count=1
arg	by y ||| y	count=2
function	[function_1] the methods ||| [function_2] [function_1]	count=2
module	of file paths from ||| java	count=1
rep	[module_1] [function_arg_2] ||| [module_1] ann [function_arg_2]	count=4
arg	port passing ||| port	count=1
function	seq on [function_2] ||| core [function_2] [function_1]	count=1
module	a new collection ||| algo generic collection	count=2
arg	[arg_1] comparator and ||| [arg_1] [arg_2]	count=3
arg	b ||| b	count=2
function	are sequences ||| sequence	count=1
function_arg	restpattern taking a ||| &gt;restpattern m#	count=1
function_arg	[function_1] coll ||| [arg_2] [function_1]	count=9
function	term ||| term	count=1
function	the [function] ||| with [function]	count=2
arg	func passing in ||| sql string &amp; params func	count=1
arg	the binding ||| &amp;	count=1
function	binding-form init-expr ||| let	count=1
arg	fntail which will install ||| fntail	count=1
arg	set1 ||| set1	count=1
module	unmunged string representation ||| main	count=1
arg	its-current-meta args [arg_2] ||| [arg_2] [arg_1]	count=1
arg	passes the ||| &amp; args	count=1
function	unmunged ||| stack element	count=2
arg	the node [arg_2] ||| [arg_2] [arg_1]	count=2
arg	taking n possibly ||| n	count=1
function_arg	suspendedstream taking ||| &gt;suspendedstream m#	count=1
module	clojure type ||| core typed	count=1
arg	test ||| start test start key end test end	count=2
function	with ||| find	count=1
arg	executes goals until results ||| &amp; goals	count=1
arg	to writer ||| writer data &amp; options	count=1
arg	name to that result ||| name &amp; forms	count=1
function	that extracts metadata ||| metadata	count=1
function	zipper ||| zip	count=1
function	of bindings ||| bindings	count=1
module	distribution of low ||| generators	count=1
function	vector ||| vector	count=2
arg	[arg_1] [arg_2] *out* ||| [arg_2] [arg_1]	count=1
arg	the elements of coll ||| coll	count=2
arg	commands ||| command &amp; sql	count=1
module	nth ||| math combinatorics	count=1
module	type annotations ||| core typed	count=2
function_arg	bindnode [arg_2] ||| [arg_2] [function_1]	count=2
arg	f and returns ||| f	count=1
function	class of ||| class	count=1
arg	expression ||| pattern	count=1
arg	and the gnu ||| option specs &amp;	count=1
arg	checking [arg_2] ||| [arg_2] [arg_1]	count=4
arg	instantiate a call to ||| inst of &amp;	count=1
function	declared namespaces. ||| namespaces	count=1
function_arg	[function_1] body ||| [function_1] out &amp; [arg_2]	count=1
function	zipper for nested sequences ||| seq zip	count=1
arg	single response-seq being read ||| response	count=1
arg	parent and tag ||| tag parent	count=3
module	nested sequences ||| zip	count=1
arg	the mult ||| mult ch close?	count=1
function_arg	[function_1] the supplied ||| [arg_2] [function_1]	count=1
function	data a ||| data	count=1
module	from [module] ||| [module]	count=3
function	the first column ||| first column	count=2
rep	[module_1] one-type taking ||| [module_1] [function_arg_2]	count=4
function	[function_1] namespace ||| [function_2] [function_1]	count=1
arg	two channels ||| or n f buf or n	count=1
function	gets the [function_2] ||| [function_1] [function_2] iref	count=1
function	all ||| all	count=4
function	[function_1] [function_2] function to a function ||| [function_1] [function_2]	count=1
module	of ||| algo generic	count=2
function	a seq on ||| seq	count=1
function	create an array with ||| long array	count=1
function	structures of equal length ||| table	count=1
arg	normal arguments [arg_2] ||| [arg_2] &amp; [arg_1]	count=5
arg	arguments [arg_2] ||| [arg_2] &amp; [arg_1]	count=5
arg	[arg_1] failure continuation ||| [arg_2] [arg_1]	count=1
arg	sorted collection test ||| start test start key end test	count=2
arg	a fn ||| fn	count=1
arg	non-nil [arg_1] [arg_2] monotonically non-increasing order otherwise ||| [arg_1] [arg_2]	count=1
module	that ||| logic	count=3
function	loaded ||| loaded	count=1
arg	loc left-to-right marked ||| loc	count=1
arg	pattern ||| xs &amp; cs	count=1
arg	namespace and ||| ns	count=3
arg	the ||| f &amp; more	count=1
arg	n default ||| n s	count=1
function	bound [function_2] ||| [function_1] [function_2]	count=1
arg	function [arg] with ||| [arg]	count=1
arg	where [arg] defaults to ||| [arg] end	count=1
arg	the ||| &amp; body	count=1
function_arg	remainder of [arg_2] ||| [arg_2] [function_1]	count=3
arg	from coll ||| coll	count=3
function	result repeating for ||| as &gt;	count=1
arg	collection test ||| test	count=2
module	state-monad function that replaces ||| monads	count=1
arg	refers to ||| args	count=1
function	a waiting stream ||| waiting stream	count=1
arg	namespace and name if ||| ns name	count=1
module	monad and return its ||| algo	count=1
arg	[arg_1] replacement ||| [arg_1] [arg_2]	count=2
arg	factory function for ||| f	count=1
arg	[arg_1] by val ||| [arg_1] [arg_2]	count=3
module	a is ||| core	count=1
arg	sc must be ||| sc start	count=2
module	member type x with ||| core typed	count=3
module	type x ||| typed	count=4
function_arg	[function_1] / sa ||| [function_1] ns ns or [arg_2]	count=1
arg	if [arg] a floating ||| [arg]	count=1
function	parents of ||| parents	count=1
module	type with a ||| core typed	count=1
function	the ddl string ||| ddl	count=1
arg	the index ||| idx2 &amp;	count=7
module	ast ||| analyzer passes jvm validate-loop-locals	count=2
function	create a vec ||| vec	count=1
arg	sorted collection test ||| test start key end test	count=2
function_arg	evaluates [arg_2] ||| [arg_2] [function_1]	count=1
arg	d ||| d	count=2
arg	[arg_1] op ||| [arg_2] [arg_1]	count=6
function_arg	the contents [arg_2] ||| [arg_2] [function_1]	count=4
arg	before [arg] current namespace ||| [arg]	count=1
module	given avl sets ||| data avl	count=1
arg	multimethod that [arg_2] ||| [arg_2] [arg_1]	count=2
arg	expr ||| expr &amp;	count=2
arg	set of functions ||| g h &amp; fs	count=1
arg	the action [arg_2] ||| [arg_2] [arg_1]	count=2
arg	array [arg_2] ||| into array&gt; [arg_2] [arg_1] syn javat cljt coll	count=4
arg	topic of a ||| topic ch close?	count=1
module	a fressian reader ||| data fressian	count=2
function	a vec with ||| vec	count=1
module	a sequence of ||| java	count=1
function	declarations ||| find namespaces	count=1
function_arg	[function_1] of coll ||| [arg_2] [function_1]	count=10
arg	will return at most ||| buf or	count=1
arg	of the ||| &amp; more	count=1
rep	type [function_arg_2] ||| [module_1] [function_arg_2]	count=2
function	var ||| create var	count=1
function	bindings in the ||| bindings	count=1
arg	compiler when ||| doc string? attr map? params*	count=1
arg	[arg] to ||| start [arg]	count=3
arg	the gnu program argument ||| &amp;	count=1
function_arg	[function_1] loc in ||| [function_1] [arg_2]	count=4
function_arg	the namespace [arg_2] ||| [function_1] [arg_2]	count=9
arg	installs a new ||| dispatch val &amp; fn tail	count=1
module	reads ||| tools reader	count=1
function	a predicate for the ||| pred	count=1
arg	arguments ||| y &amp; more	count=2
function	map of default ||| default	count=1
arg	for the cache system ||| cache item	count=1
arg	r ||| r	count=1
arg	by applying f ||| f c1 c2 c3	count=1
module	[module] after ||| [module]	count=3
arg	used in [arg] expansion of ||| fn bindings [arg]	count=1
arg	all the ||| &amp;	count=1
arg	sc must be ||| sc start test start key end	count=2
arg	f index ||| f coll	count=1
function	list ||| list	count=3
arg	the printer control variables ||| &amp; kw args	count=1
function_arg	product [arg_2] ||| [arg_2] [function_1]	count=3
arg	term in [arg] ||| argv [arg]	count=1
function	override all ||| override	count=1
arg	o [arg_2] ||| core logic rembero [arg_2] [arg_1]	count=3
arg	[arg_1] name if ||| [arg_1] [arg_2]	count=1
function	*out* [function] ||| [function] test	count=3
function	removes the namespace ||| remove ns	count=3
function	version as a ||| version	count=1
module	file ||| java	count=1
module	macros that ||| macro	count=1
function	message to stop the ||| stopper	count=1
arg	namespace / sa ||| opt	count=1
arg	jar file and returns ||| jarfile	count=1
function	tan ||| tan	count=1
arg	collection test s one ||| end test end key	count=2
function	parse ||| parse	count=1
arg	two channels the ||| n f buf or n	count=1
arg	the metadata ||| &amp;	count=1
arg	then evaluates func ||| func	count=1
function_arg	[function_1] rs ||| [arg_2] [function_1]	count=4
function	subject to the async ||| async	count=1
function	already a pretty ||| pretty	count=1
arg	class ||| class parameter types exception types	count=1
arg	class clojure ||| class op form env extmap	count=1
arg	ending at end ||| end	count=1
function	to read a ns ||| read file ns	count=1
arg	true [arg] value true ||| [arg]	count=1
function	already a pretty ||| get pretty	count=1
rep	priority [function_arg_2] ||| [module_1] [function_arg_2]	count=5
arg	for class ||| class field op form env	count=1
arg	[arg_1] v ||| [arg_2] [arg_1]	count=1
function	[function_1] validator-fn ||| [function_2] [function_1]	count=1
function	returns [function_1] [function_2] coll which can be ||| [function_2] [function_1]	count=1
arg	of arguments in values ||| values	count=1
arg	of prob ||| prob	count=1
arg	[arg_1] s ||| [arg_2] [arg_1]	count=1
arg	true if [arg] is nil ||| [arg]	count=1
arg	given name [arg_2] ||| [arg_1] &amp; [arg_2]	count=1
arg	single response-seq being ||| response timeout	count=1
function	bitwise shift right ||| bit shift right	count=3
function	sorted set with supplied ||| sorted set	count=2
arg	in [arg_2] ||| [arg_2] name [arg_1]	count=1
arg	factory function for class ||| class op form env extmap	count=1
module	of json data ||| data json	count=2
function	moves to the next ||| next	count=1
arg	[arg_1] into v ||| [arg_2] [arg_1]	count=1
arg	[arg_1] or stringable ||| [arg_2] [arg_1]	count=8
function_arg	[function_1] namespace and ||| core [function_1] [arg_2]	count=3
arg	collection test ||| start key end test end key	count=2
arg	value of atom ||| atom	count=1
arg	repeatedly apply fun ||| fun max	count=1
module	create a uuid ||| generators	count=1
function	of the structure-basis ||| struct	count=1
arg	of the nums ||| x y &amp; more	count=1
arg	goals until a maximum ||| bindings &amp; goals	count=1
arg	[arg_1] [arg_2] removed from l exactly ||| [arg_2] [arg_1]	count=4
function	splitting it each time ||| partition by	count=1
module	core ||| core	count=8
arg	parent ||| parent	count=3
module	clojure reflect ||| reflect	count=6
function	coll drop ||| split at	count=1
arg	and the gnu program ||| args option specs &amp;	count=1
arg	given a [arg_1] [arg_2] ||| [arg_1] [arg_2]	count=10
function	that extracts metadata in ||| metadata	count=1
arg	of tag either via ||| tag	count=1
arg	executes ||| db bindings	count=2
module	metadata [module] calls it ||| [module]	count=1
function	create an array with ||| char array	count=1
module	of ||| classpath	count=1
function	to stop the given ||| thread stopper	count=1
arg	[arg_1] dispatches on ||| [arg_2] [arg_1]	count=2
function	attempt to substitute ||| subst	count=1
function	updates via assoc the ||| update	count=1
arg	with key [arg_2] ||| [arg_2] [arg_1]	count=1
function	[function_1] shift ||| [function_2] [function_1]	count=2
function	asserts with ||| assert with message	count=1
arg	action [arg_2] ||| [arg_2] [arg_1]	count=2
function	representation of ||| stack element	count=2
arg	[arg_1] [arg_2] ||| [arg_2] &amp; [arg_1]	count=13
arg	keyval = ||| &amp; keyvals	count=3
arg	and installs ||| dispatch val &amp; fn tail	count=1
function	new sorted map ||| sorted map	count=2
module	[module_1] data ||| [module_1] [module_2]	count=4
function	while ||| take while	count=1
arg	l and o ||| o	count=1
arg	normal arguments ||| more	count=1
function	[function_1] method of ||| [function_1] [function_2]	count=1
function	with the [function_1] [function_2] function ||| [function_1] [function_2]	count=1
arg	the gnu ||| specs &amp; options	count=1
arg	functions and returns ||| f g h &amp; fs	count=1
function	structure-basis ||| struct	count=1
function_arg	last n ||| last n s	count=1
arg	[arg_1] [arg_2] ||| [arg_1] index [arg_2]	count=6
arg	[arg] monotonically non-decreasing ||| [arg]	count=1
module	specified ||| tools	count=1
function	a sequence of ||| loader classpath	count=1
arg	named by name unevaluated ||| name	count=1
function	an array ||| int array	count=1
function	not recognized ||| object?	count=1
arg	nil if key not ||| key not	count=1
function	clojure ||| clojure	count=1
arg	true if ||| x y &amp; more	count=1
arg	arguments in values ||| &amp; values	count=1
arg	[arg] given ||| name [arg]	count=3
arg	[arg] closing ||| [arg]	count=1
arg	[arg_1] [arg_2] fn that takes a ||| [arg_2] &amp; [arg_1]	count=4
module	on uniform distribution ||| data	count=1
module	possibly unmunged ||| repl	count=1
arg	operations and the ||| operations	count=1
arg	mult ||| mult ch	count=2
arg	at the index ||| index	count=1
function_arg	[function_1] protocol ||| [arg_2] [function_1]	count=2
function	the initial cause ||| root cause	count=2
arg	forms after replacing ||| &amp; forms	count=1
function	tagged [function_2] ||| core [function_1] [function_2]	count=1
function	ddl string ||| create table ddl	count=1
function	adds ||| add	count=1
module	file paths from ||| classpath	count=1
function	returns a possibly unmunged ||| element	count=2
function	annotate record ||| ann record	count=1
module	but ||| core typed	count=2
arg	sym and ||| sym	count=1
arg	two channels ||| or n f buf or	count=1
arg	provides [arg] var ||| [arg]	count=1
arg	of two channels ||| t buf or n f buf or n	count=1
function_arg	tan [arg_2] ||| [function_1] [arg_2]	count=1
function_arg	[function_1] xs to ||| [arg_2] [function_1]	count=1
module	ast ||| analyzer	count=1
arg	error-mode of agent a ||| mode	count=1
arg	a java io reader ||| reader	count=1
arg	expands ||| kw args? name docstring? attr	count=1
arg	swaps the [arg_2] ||| [arg_2] x y [arg_1]	count=1
function	possibly unmunged ||| stack element	count=2
arg	variables ||| lvars &amp; goals	count=1
module	object which will occur ||| data fressian	count=1
function	the non-directory entries ||| filenames	count=1
arg	expression ||| expr	count=1
arg	into forms after ||| forms	count=1
function	stack ||| stack	count=2
arg	if all [arg] provided as ||| [arg]	count=1
function_arg	sorted set [arg_2] ||| [arg_2] [function_1]	count=2
arg	[arg_1] file ||| [arg_1] [arg_2]	count=2
function	returns ||| str	count=2
function	repeating for each successive ||| as &gt;	count=1
arg	at most ||| buf or	count=1
function	a zipper for nested ||| seq	count=1
arg	format ||| fmt	count=1
function	the extend construct ||| extend	count=1
arg	then evaluates func passing ||| string &amp; params func	count=1
arg	and returns the ref ||| ref	count=2
arg	topic of a pub ||| p topic ch	count=1
function	[function_1] unification ||| [function_2] [function_1]	count=8
arg	a [arg] ||| [arg]	count=1
module	type environment to ||| core typed	count=1
function	naming the non-directory entries ||| filenames	count=1
arg	[arg_1] and end ||| [arg_2] [arg_1]	count=2
arg	data structure of data ||| data	count=1
function	print the filter ||| print filterset	count=1
module	the macro ||| tools macro	count=1
module	by the type ||| typed	count=1
function	query then ||| db query	count=1
arg	operation completed ||| clauses	count=1
function	to read a ||| read	count=3
function	core / for with ||| for	count=1
function	the future ||| future	count=1
arg	coerces coll to ||| xform coll &amp;	count=1
arg	all arguments ||| y &amp; more	count=1
module	create a ||| generators	count=1
rep	[module_1] const taking ||| [module_1] map [function_arg_2]	count=2
rep	[module_1] [function_arg_2] ||| [module_1] sorted [function_arg_2]	count=4
module	return ||| algo generic	count=3
arg	nums ||| more	count=2
module	zipper for nested sequences ||| zip	count=1
function	removes ||| remove	count=4
arg	non-nil [arg_1] [arg_2] equivalent value type-independent otherwise ||| [arg_1] [arg_2]	count=1
arg	[arg_1] commands ||| [arg_1] [arg_2]	count=1
arg	the error-mode of agent ||| a mode keyword	count=1
function_arg	[function_1] of coll ||| [function_1] array 2d [arg_2]	count=4
function_arg	zero-type taking ||| &gt;zero type m#	count=1
function_arg	immediate parents [arg_2] ||| [arg_2] [function_1]	count=3
function	in [function] ||| load [function]	count=2
arg	keys ||| keys	count=5
arg	fn1 if ||| fn1	count=1
arg	[arg_1] and y ||| [arg_1] [arg_2]	count=10
arg	asynchronously takes [arg_2] ||| [arg_2] fn1 [arg_1]	count=1
module	paths ||| classpath	count=1
arg	adds [arg] ||| coll [arg]	count=2
arg	of two channels the ||| buf or n f buf or n	count=1
function	flip ||| flip	count=1
function	possibly unmunged string ||| str	count=2
module	a channel to a ||| async	count=1
arg	atom to ||| atom	count=1
module	replacement string that ||| string	count=1
module	the output channel will ||| core async	count=1
module	*out* is ||| core	count=1
function	in a nested associative ||| in	count=1
arg	x and [arg_2] ||| [arg_2] [arg_1]	count=3
module	ast when a ||| analyzer passes jvm	count=1
arg	commands on the ||| command &amp; sql commands	count=1
rep	type [function_arg_2] ||| core [module_1] [function_arg_2]	count=1
arg	a table name ||| table row map	count=1
function	[function_1] trace of ||| [function_2] [function_1]	count=1
function	unification bindings ||| make occurs	count=1
arg	a table name and ||| table row	count=1
module	m-expr else return ||| algo	count=1
function_arg	conjoined to [arg_2] ||| [arg_2] [function_1]	count=2
function_arg	key [arg_2] ||| [arg_2] [function_1]	count=2
arg	object to printwriter out ||| out escape unicode?	count=1
arg	cache system ||| cache item	count=1
arg	print object to printwriter ||| escape unicode?	count=1
arg	depth ||| depth	count=1
module	returns a sequence ||| java	count=1
arg	class clojure ||| class	count=2
arg	factory function for class ||| declaring class parameter types exception types flags	count=1
function	return last index ||| last index	count=1
arg	f ||| f coll	count=1
arg	operations and the ||| which m plus operations	count=1
arg	a single response-seq being ||| response	count=1
function	get the ||| get	count=1
arg	or name contains a ||| or	count=1
arg	annotations ||| maybe ann body	count=1
module	based ||| generators	count=1
arg	given key ||| key	count=2
function	mapped to the ||| zipmap	count=1
arg	a topic of a ||| topic ch close?	count=1
function	removes the method ||| remove method	count=3
arg	input ||| input offset	count=1
arg	the [arg] ||| [arg]	count=10
arg	exprs and ||| exprs	count=1
function_arg	of var [arg_2] ||| [function_1] root [arg_2]	count=1
module	returns a sequence ||| classpath	count=1
arg	step [arg_2] ||| [arg_2] [arg_1]	count=4
arg	positional factory ||| op form	count=1
arg	atom to be: ||| atom	count=1
arg	sc must be ||| sc	count=2
function_arg	[function_1] [arg_2] with parallelism ||| [function_1] [arg_2]	count=4
function	map with supplied ||| map	count=2
arg	either maps representing rows ||| row map :transaction? true :entities identity	count=1
arg	the contents [arg] ||| [arg]	count=1
module	from ||| java classpath	count=2
arg	binds name to that ||| name &amp;	count=1
function	future ||| future	count=3
function_arg	[function_1] x ||| [function_1] int [arg_2]	count=7
function_arg	check [arg_2] ||| [arg_2] [function_1]	count=1
arg	state ||| state	count=1
module	true ||| comparison	count=1
arg	of two channels ||| n f buf or n	count=1
function	[function_1] right of ||| [function_2] [function_1]	count=4
arg	where [arg] ||| [arg] l	count=1
function_arg	of var [arg_2] ||| [arg_2] [function_1]	count=1
arg	executes a ||| db	count=1
arg	instantiate ||| inst of &amp;	count=1
module	[module_1] a ||| [module_2] [module_1]	count=1
function	a soft cut ||| defna	count=1
arg	then evaluates func passing ||| &amp; params func	count=1
function	function [function] to function ||| [function] pprint	count=1
function_arg	ddl string [arg_2] ||| [arg_2] [function_1]	count=1
function	snapshot of a core ||| snapshot	count=1
function	map of ||| map	count=14
function	log ||| log	count=1
arg	evaluates func passing ||| map sql string &amp; params func	count=1
function	least of ||| min	count=1
function_arg	the [function_1] [arg_2] ||| [function_1] int [arg_2]	count=23
arg	coerce ||| x	count=2
function	sh see sh for ||| sh env	count=1
function	to int ||| int	count=1
function	of a ||| stack element str	count=2
arg	[arg_1] atom ||| [arg_2] f x y [arg_1]	count=2
function	[function_1] a ns ||| [function_2] [function_1]	count=6
arg	a val [arg_2] ||| [arg_2] [arg_1]	count=2
function	[function_1] methods of ||| [function_1] [function_2]	count=2
arg	if nums are in ||| y &amp; more	count=1
function	returns a sequence of ||| classpath	count=1
arg	v is of ||| v	count=1
arg	that will invoke the ||| &amp;	count=1
function	the first column is ||| first column	count=1
function	var coverage statistics to ||| var	count=1
function_arg	[function_1] loc ||| [arg_2] [function_1]	count=4
arg	the gnu program ||| specs &amp; options	count=1
function	new sorted [function_2] ||| [function_2] [function_1]	count=8
function	binding-form init-expr evaluates the ||| let	count=1
module	of ||| java classpath	count=2
function	of default options ||| get default options	count=2
function	print the ||| print env	count=1
function	reads a ||| read	count=1
module	given ||| tools	count=4
arg	the monitor of x ||| x &amp; body	count=1
function	parse ||| parse opts	count=2
arg	division of x by ||| x	count=1
function_arg	while pred ||| take while pred	count=1
arg	class ||| class op	count=1
function	untrace all fns in ||| untrace	count=1
module	file paths from ||| java	count=1
function	with random probability of ||| random sample	count=1
arg	test ||| end test end	count=2
arg	for test ||| test x	count=1
module	string ||| repl	count=1
function	string representation of ||| stack	count=2
arg	[arg] monotonically non-decreasing ||| x [arg]	count=1
arg	its ||| &amp; opts	count=1
arg	operations and the base ||| base which m plus operations	count=1
module	with member type ||| typed	count=2
function	on the atom ||| atom	count=1
function	an array with ||| long array	count=1
arg	a topic of a ||| p topic ch close?	count=1
function_arg	/ let [arg_2] ||| [arg_2] [function_1]	count=1
arg	the no-arg [arg] in parallel ||| &amp; [arg]	count=1
arg	sql commands ||| spec transaction? sql command &amp;	count=1
module	new collection in which ||| algo generic collection	count=1
function	[function_1] watch ||| [function_1] [function_2]	count=1
arg	topic of ||| p topic ch	count=1
function_arg	drop [arg_2] ||| [arg_2] [function_1]	count=2
arg	set of functions and ||| &amp; fs	count=2
arg	expands to clojure core ||| kw args? name docstring? attr map? param :	count=1
arg	of the same type ||| &amp;	count=1
arg	jar file and ||| jarfile	count=1
arg	location loc left-to-right ||| loc	count=1
module	creating it if ||| core	count=1
function	[function] block for ||| [function]	count=1
module	file paths from a ||| java	count=1
function	under ||| clojure sources in	count=1
arg	evaluates func ||| map sql string &amp; params func	count=1
arg	that calls cf ||| cf	count=1
function	sequence of ||| seq	count=2
function	of a [function_1] [function_2] ||| [function_1] [function_2]	count=2
arg	vector containing sql ||| sql string	count=1
function_arg	leftmost [function_1] [arg_2] ||| [function_1] [arg_2]	count=3
arg	with key [arg_2] ||| [arg_1] [arg_2]	count=1
arg	to val ||| val &amp;	count=2
arg	of a single response-seq ||| response	count=1
arg	named methods and ||| name	count=1
function	message to stop ||| stopper	count=1
module	uuid based on uniform ||| data	count=1
function	pretty ||| get pretty	count=1
function_arg	[function_1] comparator ||| data priority-map priority [function_1] by [arg_2]	count=1
arg	threads it into the ||| &amp; forms	count=1
arg	via the given transport ||| transport timeout	count=1
arg	side-effects with ||| &amp;	count=1
arg	[arg_1] [arg_2] takes a variable number ||| [arg_2] [arg_1]	count=4
arg	to y ||| y	count=1
function	whose key [function] ||| [function]	count=1
arg	for ||| class or object	count=1
function_arg	[function_1] / sa ||| [arg_2] [function_1]	count=1
function	list begun with begin-closed-list ||| end list	count=1
arg	functions and returns a ||| g &amp; fs	count=1
arg	[arg_1] body ||| [arg_1] [arg_2]	count=2
arg	of functions and ||| h &amp; fs	count=1
module	type checks the ||| core typed	count=1
arg	to ||| &amp; forms	count=1
function	string representation of ||| stack element	count=2
function_arg	method of [arg_2] ||| [arg_2] [function_1]	count=4
arg	state by s and ||| s	count=1
function	an array with ||| array	count=6
module	ops [module] after running ||| [module]	count=1
arg	functions and ||| &amp; fs	count=2
arg	executes body in the ||| &amp; body	count=1
module	given ast ||| tools analyzer passes	count=2
function	shift right [function_2] ||| [function_2] bit [function_1]	count=1
module	polymorphic type with ||| typed	count=1
arg	value to the promise ||| promise val	count=1
arg	vector of two channels ||| buf or n	count=1
arg	the value ||| not found	count=1
arg	coll coll ||| coll	count=1
arg	a function of the ||| f	count=1
arg	object [arg] to ||| &amp; [arg]	count=1
module	[module_1] [module_2] ||| [module_2] [module_1]	count=32
arg	commands on the specified ||| command	count=1
function	first item ||| first	count=1
arg	varsym ||| varsym typesyn	count=1
arg	for ||| class or	count=1
arg	etc or a composition ||| or n	count=1
function	locations to the ||| locs	count=2
arg	use [arg] go ||| [arg]	count=1
function	does not recognized ||| object?	count=1
arg	body with *out* ||| out &amp; body	count=1
function_arg	parents [arg_2] ||| [arg_2] [function_1]	count=3
arg	tail [arg] ||| a [arg]	count=1
arg	metadata ||| metadata map	count=1
arg	body in another ||| body	count=1
arg	filter p etc or ||| buf or n	count=1
arg	[arg_1] of n ||| [arg_2] [arg_1]	count=1
function	the composition of ||| comp	count=1
module	for ||| core unify	count=1
function	representation ||| element str	count=2
module	given avl sets which ||| data avl	count=1
arg	[arg_1] with replacement ||| [arg_1] [arg_2]	count=2
arg	the pow ||| pow	count=1
function_arg	[function_1] of prob ||| [function_1] [arg_2]	count=1
module	returns ||| java	count=1
function	a value in ||| in	count=1
function	collection ||| coll	count=1
arg	thread at the time ||| &amp;	count=1
arg	object to printwriter out ||| x out escape unicode?	count=1
function	class ||| get proxy class	count=2
arg	the values in aseq ||| type aseq	count=1
arg	the monitor of x ||| x	count=1
arg	syntax ||| provided?	count=1
arg	the gnu program ||| option specs &amp; options	count=1
function	mismatched loop-local is ||| locals	count=1
function	[function_1] int ||| [function_1] multiply [function_2]	count=1
arg	comparator and ||| comparator &amp;	count=2
arg	env [arg_2] ||| [arg_2] [arg_1]	count=1
function_arg	key val returns a [function_1] [arg_2] ||| [function_1] [arg_2]	count=6
function	prints a chain ||| print	count=1
arg	form ||| form	count=16
function	class followed by zero ||| proxy class	count=1
arg	asynchronously [arg_2] ||| [arg_2] [arg_1]	count=1
arg	func passing ||| func	count=1
function	nested sequences given ||| seq zip	count=1
arg	arguments ||| x y &amp; more	count=2
arg	with no args ||| x &amp; ys	count=1
function	are self-recursive ||| self recursive	count=1
arg	factory function for class ||| declaring class	count=2
module	returns a [module] of the ||| [module]	count=1
arg	ctor and creates and ||| ctor	count=1
module	that [module] ||| [module]	count=3
arg	or a ||| or n	count=1
arg	the timeout ||| timeout	count=1
function	a ||| zip	count=2
arg	multimethod associated with dispatch-value ||| multifn dispatch	count=2
function	a collection of scalar ||| collection	count=1
module	file paths ||| classpath	count=1
function	returns a lazy sequence ||| seq	count=1
arg	a set of functions ||| fs	count=2
arg	reads from the input ||| input	count=1
arg	with an optional table-spec ||| &amp;	count=1
arg	[arg] removed from ||| [arg] l	count=1
function	of thread-local bindings ||| bindings	count=1
function_arg	waiting stream [arg_2] ||| [function_1] [arg_2]	count=4
function	create an array ||| array	count=6
arg	the same ||| &amp; args	count=1
arg	seqable object [arg] ||| [arg]	count=1
module	a type representing a ||| typed	count=1
arg	tag ||| tag	count=2
arg	body with ||| &amp; body	count=1
module	the ||| algo	count=1
module	match ||| core match	count=1
arg	sql and optional ||| sql string &amp;	count=1
arg	compiler when it ||| doc string? attr map? params* body +	count=1
arg	maximum of n ||| n bindings &amp;	count=1
arg	where [arg] defaults ||| [arg] end	count=1
function	representation of the current ||| testing	count=1
module	representation ||| repl	count=1
function	returns ||| loader classpath	count=1
arg	body in ||| body	count=4
arg	a map ||| map	count=1
function	string ||| str	count=6
arg	[arg_1] the ||| [arg_2] [arg_1]	count=6
arg	test s one of ||| key end test end key	count=2
function_arg	sin [arg_2] ||| [arg_2] [function_1]	count=1
arg	sets the error-mode ||| mode keyword	count=1
module	type t ||| typed	count=1
arg	to the supplied ||| ch	count=1
function_arg	patternmatrix taking ||| &gt;patternmatrix m#	count=1
arg	or stringable ||| or	count=1
function	to ||| map	count=1
function_arg	namespace [arg_2] ||| [function_1] [arg_2]	count=9
module	returns a [module] ||| core [module]	count=5
arg	function for class ||| declaring class parameter	count=1
function_arg	the next loc ||| next loc	count=1
arg	keyfn custom comparator and ||| keyfn comparator	count=1
arg	test s one ||| key end test	count=2
module	and supplies ||| core async	count=1
arg	from port ||| port	count=3
arg	writer ||| writer data	count=1
function	returns a potentially-ragged 2-dimensional ||| 2d	count=1
function_arg	contents of [arg_2] ||| [function_1] [arg_2]	count=1
function	to read [function_2] ||| [function_1] [function_2]	count=2
arg	containing sql ||| sql	count=1
arg	value plus any args ||| args	count=1
module	channel will ||| async	count=1
module	core / deref ||| core	count=1
function	or ||| of	count=1
function	a predicate for ||| pred	count=1
arg	xs to ||| &amp; xs	count=1
module	on uniform ||| generators	count=1
module	type with a number ||| core typed	count=1
function	args) as its ||| vary	count=1
function	error ||| errorf	count=1
function_arg	[function_1] custom comparator ||| data priority-map [function_1] by [arg_2]	count=2
function	map with ||| map keyfn	count=1
arg	needed ||| docstring? attr map? references*	count=1
function	loop ||| loop	count=3
arg	rel ||| xrel	count=1
module	set ||| data generators	count=1
arg	error-mode of ||| mode keyword	count=1
module	the channel ||| core async	count=1
arg	sorted collection test s ||| start test start key end test	count=2
arg	operations and the ||| plus operations	count=1
arg	executes goals until a ||| bindings &amp; goals	count=1
module	args ||| tools logging	count=1
function	disconnects a target ||| untap	count=1
arg	the file they represent ||| &amp;	count=1
arg	channels ||| n f buf or	count=1
arg	the yl ||| yl	count=1
arg	functions and ||| g &amp; fs	count=1
function_arg	sum [arg_2] ||| [arg_2] [function_1]	count=1
arg	to a topic of ||| topic ch	count=1
function	[function_1] last ||| [function_1] [function_2]	count=2
function	core / loop ||| loop	count=1
arg	func passing ||| sql string &amp; params func	count=1
function	union ||| union	count=1
function	seq on [function_2] ||| [function_2] [function_1]	count=1
function	the structure-basis ||| struct map	count=1
function	monotonically decreasing order ||| &gt;	count=1
arg	at the offset index ||| offset	count=1
function_arg	substvalue [arg_2] ||| [function_1] [arg_2]	count=2
function_arg	[function_1] [arg_2] ||| [function_1] keys [arg_2]	count=4
arg	of match [arg_2] ||| [arg_1] [arg_2]	count=1
arg	function for class ||| class field	count=1
function	shift ||| shift	count=2
function	quoted form and returns ||| check	count=1
arg	named ||| name	count=1
arg	body in ||| &amp; body	count=2
function	send-off ||| agent send off	count=1
arg	the args ||| b c d e f &amp; args	count=1
function	returns a [function] ||| [function]	count=5
arg	subject [arg] ||| xf from close? [arg]	count=1
arg	forms after ||| &amp; forms	count=1
arg	of atom to ||| atom	count=1
function_arg	[function_1] u into ||| [arg_2] [function_1]	count=1
function	to the next ||| next	count=1
arg	the args ||| e f &amp; args	count=1
arg	with the value of ||| &amp;	count=1
arg	multimethod associated ||| multifn dispatch val	count=2
arg	expands to clojure core ||| kw args? name docstring? attr	count=1
arg	sorted collection test s ||| end test end	count=2
module	type t ||| core typed	count=1
function_arg	inserts the [arg_2] ||| [function_1] left loc [arg_2]	count=3
arg	form ||| form expected	count=1
arg	name to that ||| name &amp; forms	count=2
function	removes the method of ||| remove method	count=1
arg	[arg_1] y ||| [arg_1] [arg_2]	count=15
arg	of x in coll ||| coll x	count=1
module	optional type ||| typed	count=1
function	a possibly ||| element	count=2
arg	given keys ||| coll &amp; keys	count=1
arg	the [arg_2] ||| [arg_1] [arg_2]	count=7
function_arg	of var v ||| var root v	count=1
arg	goals until a ||| &amp; goals	count=1
module	paths from ||| java classpath	count=1
function	[function_1] any ||| [function_1] [function_2]	count=1
function	annotate a ||| ann	count=1
function_arg	var [arg_2] ||| [function_1] [arg_2]	count=1
arg	installs a ||| dispatch val &amp; fn tail	count=1
function	bindings for ||| with bindings	count=2
function	agent s have occurred ||| await	count=1
arg	dispatches [arg_2] ||| [arg_2] [arg_1]	count=1
function_arg	other [arg_2] ||| [function_1] [arg_2]	count=1
function	unmunged ||| element str	count=2
function	a quoted ||| check form info	count=1
function	quoted form ||| check	count=1
arg	to that ||| &amp; forms	count=1
module	a polymorphic type ||| typed	count=1
arg	of the input array ||| input	count=1
function	var [function_2] ||| [function_2] [function_1]	count=6
arg	associative structure where ks ||| ks	count=1
arg	prob 0 0 ||| prob	count=1
arg	tests in [arg] given namespaces; ||| [arg]	count=1
function	vec ||| vec	count=1
arg	one of the ||| &amp;	count=2
function	the [function] function ||| with [function]	count=1
arg	when [arg] is not ||| [arg]	count=1
function	other ||| -	count=1
function	reads the ||| read	count=3
function	returns a possibly ||| stack element str	count=2
arg	executes goals until ||| &amp; goals	count=2
arg	atom to [arg_2] ||| [arg_2] [arg_1]	count=1
arg	sorted collection test s ||| key end test end	count=2
function	new hash ||| hash	count=1
function	representation of ||| element str	count=2
function_arg	division of [arg_2] ||| [arg_2] [function_1]	count=3
module	that ||| core logic	count=2
module	return the ||| algo generic math-functions	count=9
arg	instance [arg] ||| s [arg]	count=3
function	java sql resultset ||| resultset seq	count=1
function	representation of the current ||| testing vars str	count=1
arg	namespace [arg_2] ||| [arg_2] [arg_1]	count=4
module	usage value is ||| core	count=1
arg	the mix ||| mix	count=2
arg	number of types ||| types	count=2
arg	keyfn [arg_2] ||| [arg_1] [arg_2]	count=3
arg	true if ||| x y &amp;	count=1
module	a uuid based on ||| generators	count=1
module	distribution of low ||| data generators	count=1
function	summarises annotated var ||| var coverage	count=1
function	by the result ||| by	count=1
function	ends a list begun ||| end list	count=1
module	match ||| match	count=1
function	double[] ||| doubles	count=1
function	quoted ||| check form	count=1
function	an array with ||| char array	count=1
function_arg	[function_1] [arg_2] with parallelism ||| pipeline [function_1] n to [arg_2] from close?	count=4
function_arg	[function_1] arguments ||| [function_1] [arg_2]	count=4
arg	to expr evaluates the ||| expr	count=1
arg	agent state [arg_2] ||| [arg_1] [arg_2]	count=1
arg	topic of ||| p topic ch close?	count=1
module	a type ||| typed	count=3
arg	values in aseq ||| type aseq	count=1
arg	apply fun to ||| fun max	count=1
arg	two channels the ||| t buf or n f buf or	count=1
module	type representing a ||| core typed	count=1
arg	between [arg_1] [arg_2] ||| [arg_2] [arg_1]	count=2
module	and passed to the ||| core	count=1
function	shift [function_2] ||| [function_2] [function_1]	count=2
arg	in coll in ||| coll	count=1
module	a zipper for nested ||| zip	count=1
arg	[arg] byte array ||| [arg] offset length	count=3
function	load and [function_2] ||| [function_1] [function_2]	count=3
function	hash [function_2] ||| [function_2] [function_1]	count=1
arg	corresponding to the natural ||| yrel km	count=1
function	create an array ||| int array	count=1
arg	if it is a ||| x	count=1
function	resultset as an ||| resultset	count=1
arg	[arg] the ||| factory logger ns [arg]	count=2
arg	given a root element ||| root	count=1
arg	sc must be a ||| sc start	count=2
arg	into forms after ||| &amp; forms	count=1
arg	[arg] class as ||| [arg]	count=3
arg	forms after replacing the ||| forms	count=1
arg	of s ||| s	count=1
function	optional single class ||| get proxy class	count=1
function_arg	trace of [arg_2] ||| [arg_2] [function_1]	count=3
function	returns a zipper for ||| zip	count=1
function	number one greater than ||| inc	count=1
arg	[arg_1] coll to ||| [arg_2] [arg_1]	count=1
function	gets the max-history of ||| ref max history	count=1
function_arg	[function_1] of f ||| [arg_2] [function_1]	count=5
function	a ||| stack element	count=4
arg	[arg_1] a val ||| [arg_2] [arg_1]	count=1
arg	factory function for class ||| declaring class flags	count=1
arg	state to ||| state &amp;	count=1
arg	function for class ||| class op form	count=1
function	create an array with ||| boolean array	count=1
arg	a sorted collection test ||| test end	count=2
arg	vals ||| vals	count=1
arg	and ending at end ||| end	count=1
module	of the type ||| typed	count=1
arg	signature [arg] ||| f [arg]	count=2
module	a channel with ||| core async	count=1
arg	a success continuation and ||| success	count=1
arg	protocol ||| protocol	count=2
rep	[module_1] [function_arg_2] ||| [module_1] read ns [function_arg_2]	count=1
function	of a ||| stack	count=2
function	if not ||| if	count=1
arg	factory function for class ||| type declaring class flags	count=1
function	map of default ||| get default	count=1
function_arg	in [function_1] [arg_2] ||| [function_1] [arg_2]	count=1
function	reader does not recognized ||| object?	count=1
function	superclass ||| proxy	count=1
function_arg	snapshot of [arg_2] ||| [function_1] [arg_2]	count=1
function	base values are sequences ||| sequence t	count=1
function_arg	restpattern [arg_2] ||| [arg_2] [function_1]	count=2
arg	column specs with ||| &amp; specs	count=2
module	the output channel ||| async	count=1
function_arg	len-right-meter [arg_2] ||| [arg_2] [function_1]	count=2
arg	repeatedly apply fun ||| fun	count=1
function_arg	[function_1] comparator ||| data priority-map [function_1] by [arg_2]	count=2
module	macros that ||| tools macro	count=1
module	java ||| java	count=1
arg	the rel ||| xrel	count=1
arg	response-seq being read off ||| response	count=1
function	declarations ||| find namespaces on classpath	count=1
function	a pretty ||| pretty	count=1
function	the juxtaposition of ||| juxt	count=1
arg	goals until [arg_2] ||| [arg_2] db [arg_1]	count=1
arg	operations and ||| operations	count=1
function_arg	[function_1] of nums ||| [function_1] x y &amp; [arg_2]	count=1
function	map with ||| map	count=4
arg	returns the [arg_2] ||| [arg_1] index [arg_2]	count=3
function_arg	[function_1] [arg_2] ||| [function_1] h [arg_2]	count=40
function	key ||| set val	count=1
function	returns a lazy seq ||| seq	count=1
module	and return its result ||| algo monads	count=1
arg	threads it ||| &amp; forms	count=1
function	[function] value ||| [function]	count=3
function_arg	rint [arg_2] ||| [function_1] [arg_2]	count=1
function	asin ||| asin	count=1
arg	atomically resets [arg] for ||| iref [arg]	count=1
function_arg	runs [arg_2] ||| [function_1] out [arg_2]	count=1
function	a possibly unmunged string ||| str	count=2
function	loop that ||| length loop	count=1
function	sets the components of ||| sets	count=1
arg	collection test s one ||| test start key end test end	count=2
arg	test s one ||| key end test end key	count=2
rep	clojure-oriented [function_arg_2] ||| [module_1] [function_arg_2]	count=3
arg	method of multimethod associated ||| multifn dispatch val	count=1
function	a waiting ||| waiting	count=1
function	transformer ||| transformer	count=1
function	returns ||| seq	count=1
arg	[arg_1] [arg_2] l exactly one time ||| core logic rembero [arg_2] [arg_1]	count=4
arg	s and returns the ||| s	count=1
arg	or a topic ||| topic	count=1
function_arg	[function_1] item as ||| [function_1] left loc [arg_2]	count=1
function	as json ||| json	count=1
function	bindings in the given ||| bindings	count=1
arg	rest of l ||| l	count=1
function	[function] block ||| [function]	count=1
arg	a pattern ||| pattern	count=1
arg	a table name ||| table	count=1
function	fatal ||| fatalf	count=1
function	json ||| json	count=2
function	the agent is failed ||| agent	count=1
arg	cf default - ||| cf	count=1
arg	reader g ||| g	count=1
arg	topic of a ||| p topic ch close?	count=1
function	file paths from a ||| loader	count=1
arg	of tr ||| tr	count=1
function_arg	[function_1] a success ||| [function_1] [arg_2]	count=4
arg	val [arg_2] ||| [arg_2] [arg_1]	count=2
arg	of division of x ||| x	count=1
function	local ||| local	count=1
arg	for class ||| class field op form env extmap	count=1
module	a polymorphic type ||| core typed	count=1
function	given a ||| seq	count=1
function	both [function_2] ||| [function_2] [function_1]	count=5
function	create an array ||| char array	count=1
function	namespace returns it ||| ns	count=1
arg	column specs with an ||| &amp; specs	count=1
function_arg	bindnode taking ||| &gt;bindnode m#	count=1
function	[function] coll ||| [function]	count=3
function	structures of equal ||| table	count=1
function	gets ||| get	count=2
function_arg	closure [arg_2] ||| [arg_2] [function_1]	count=2
function	the unevaluated ns declarations. ||| ns decls	count=1
arg	ending at end defaults ||| end	count=1
arg	multimethod associated with dispatch-value ||| multifn dispatch val &amp;	count=1
function	aliases for ||| aliases	count=1
module	w [module] read ||| [module]	count=1
arg	body presumably ||| body	count=1
module	[module_1] goal to ||| [module_1] [module_2]	count=2
arg	java array ||| array	count=1
module	the supplied channel ||| async	count=1
arg	[arg_1] a val ||| core async put! port [arg_2] fn1 [arg_1]	count=1
function_arg	[function_1] comparator and ||| data priority-map [function_1] by [arg_2]	count=2
arg	sc must be a ||| sc	count=2
function	waiting stream ||| waiting stream	count=1
arg	multimethod with the ||| &amp;	count=1
function	a non-namespaced symbol ||| symbol	count=1
arg	maximum of n ||| n bindings	count=1
function	time-based rather than algortihmic ||| ttl	count=1
module	on ||| data	count=2
function	searches recursively under ||| find clojure sources	count=1
function	the least of ||| min	count=1
function	right of loc starting ||| right	count=1
arg	table ||| table row	count=1
arg	two channels ||| buf or n	count=1
function	the first [function_2] ||| [function_1] [function_2]	count=3
arg	functions and returns ||| &amp; fs	count=2
function	send-off ||| set agent send off	count=1
function	remainder of ||| remainder	count=1
function	unmunged string representation of ||| stack element str	count=2
arg	[arg_1] to fn1 ||| [arg_2] [arg_1]	count=3
arg	form to ||| form env	count=1
function	[function_1] int ||| [function_1] [function_2]	count=2
arg	channels ||| buf or	count=1
arg	coll [arg_2] ||| [arg_2] [arg_1]	count=3
function	the initial cause ||| cause	count=2
arg	o is ||| o	count=1
arg	of two channels the ||| buf or n f buf or	count=1
arg	of two channels ||| or n f buf or n	count=1
function	of a ||| str	count=2
function_arg	[function_1] f on ||| [function_1] [arg_2]	count=2
function_arg	transitive closure [arg_2] ||| [function_1] [arg_2]	count=2
module	returns a sequence ||| java classpath	count=1
function	sh see sh ||| sh env	count=1
arg	repeatedly executes body ||| body	count=1
function	returns the immediate parents ||| parents	count=1
arg	given a database [arg_1] [arg_2] perform ||| [arg_1] [arg_2] params	count=1
arg	for class ||| class	count=5
arg	parent [arg_2] ||| [arg_2] [arg_1]	count=4
arg	binds name to expr ||| expr	count=1
arg	a single response-seq ||| response	count=1
function	mismatched loop-local is found ||| locals	count=1
arg	the file ||| &amp;	count=1
module	query ||| java jdbc	count=1
arg	expands ||| kw args? name docstring? attr map? param :	count=1
function_arg	suspendedstream taking a ||| &gt;suspendedstream m#	count=1
arg	inserts [arg] ||| loc [arg]	count=3
function	types explicitly extending ||| extenders	count=1
function	[function_1] the validator-fn ||| [function_2] [function_1]	count=1
arg	ns ||| ns	count=1
arg	commands on ||| command &amp; sql	count=1
arg	relationship [arg_2] ||| core derive [arg_1] [arg_2]	count=1
arg	for class clojure ||| t	count=1
function	bytes ||| byte	count=1
function_arg	/ loop [arg_2] ||| [function_1] [arg_2]	count=1
function_arg	hierarchical [arg_2] ||| [function_1] [arg_2]	count=1
function	returns a ||| zip	count=1
module	channel and ||| core	count=1
arg	a map of ||| map	count=1
function	quoted form and returns ||| check form info	count=1
arg	[arg_1] [arg_2] takes a variable number ||| [arg_2] &amp; [arg_1]	count=4
function	right of ||| right	count=1
arg	positional factory function ||| f	count=1
arg	and y ||| y	count=3
module	algo ||| algo	count=4
rep	annotate [function_arg_2] ||| [module_1] ann [function_arg_2]	count=4
arg	but also refers to ||| args	count=1
module	channel that will return ||| async	count=1
module	core / ||| core	count=1
function	the same [function] all ||| extend [function]	count=1
function	a possibly unmunged string ||| element str	count=2
arg	all its ||| &amp; opts	count=1
arg	where ks ||| &amp; ks	count=1
arg	inclusive and [arg] default 1 ||| [arg]	count=1
function_arg	[function_1] x ||| [arg_2] [function_1]	count=23
arg	nil and yields a [arg_1] [arg_2] ||| [arg_1] [arg_2]	count=4
module	a ||| classpath	count=2
function	shift right [function_2] ||| [function_2] [function_1]	count=1
arg	coerces coll to ||| xform coll &amp; colls	count=1
arg	the given strings to ||| &amp; args	count=1
arg	items ||| items t n	count=1
function	the right ||| right	count=1
arg	factory function for class ||| type declaring class parameter	count=1
arg	[arg_1] [arg_2] a possibly empty sequence ||| [arg_1] [arg_2]	count=5
arg	match with [arg_2] ||| [arg_2] [arg_1]	count=1
arg	to the operation completed ||| clauses	count=1
function	[function_1] bytes ||| [function_2] [function_1]	count=2
arg	class ||| class field op	count=1
function_arg	[function_1] [arg_2] ||| [function_1] x [arg_2]	count=2
arg	if [arg] if ||| [arg] m	count=1
arg	[arg_1] [arg_2] a possibly empty sequence ||| core sequence [arg_1] [arg_2]	count=1
function	contents ||| to	count=2
arg	regular expression [arg_2] ||| [arg_2] [arg_1]	count=8
function	[function_1] dispatch ||| [function_1] [function_2] function &amp;	count=3
function	executes ||| do commands	count=1
function_arg	non-namespaced keyword [arg_2] ||| [function_1] [arg_2]	count=1
function	min-history of a ref ||| min history	count=1
function	/ for with optional ||| for	count=1
function_arg	[function_1] [arg_2] ||| core match [function_1] [arg_2]	count=2
arg	start inclusive and ||| start	count=1
arg	multimethod and ||| multifn	count=1
arg	data to writer ||| writer	count=1
arg	[arg_1] xf ||| to [arg_2] from close? [arg_1]	count=3
function_arg	loop and [arg_2] ||| [arg_2] [function_1]	count=1
function	analyze and an environment ||| analyze	count=1
function	the string ||| string	count=3
function	[function] *out* for ||| [function]	count=1
arg	the ||| &amp; args	count=4
arg	index of value ||| value	count=2
arg	returns true [arg] is ||| [arg]	count=3
arg	reads all its ||| opts	count=1
arg	annotate [arg] ||| [arg]	count=1
function	bindings [function_2] ||| [function_2] [function_1]	count=2
arg	a success ||| success	count=1
arg	operations ||| plus operations	count=1
function	array of floats ||| float array	count=3
arg	the nums ||| x y &amp; more	count=1
arg	fun ||| fun max	count=1
module	metadata [module] calls ||| [module]	count=1
function	contents of ||| to	count=2
arg	end defaults ||| end	count=1
module	low ||| generators	count=1
arg	atomically sets the ||| &amp;	count=1
arg	the agent state to ||| state &amp; options	count=1
arg	multimethod name [arg_2] ||| [arg_2] [arg_1]	count=1
arg	monad operations and ||| plus operations	count=1
arg	channels the first of ||| buf or n f buf or	count=1
arg	a maximum of n ||| n	count=2
arg	plus the action epxression ||| pat action	count=1
arg	replaces all [arg_1] [arg_2] in ||| string replace [arg_1] [arg_2]	count=2
arg	[arg_1] val ||| [arg_2] [arg_1]	count=6
function	lazy sequence ||| lazy	count=1
arg	optional ||| &amp;	count=1
module	json data from ||| data json	count=2
arg	the input ||| input offset	count=1
arg	match with replacement ||| match replacement	count=1
module	returns the ||| core	count=2
module	when-let but ||| typed	count=1
function	the max-history ||| max history	count=1
function	under ||| find clojure sources	count=1
arg	xl ||| xl	count=1
arg	returns the [arg_2] ||| [arg_1] [arg_2]	count=1
arg	[arg] sequence ||| [arg]	count=2
function	substitute unification bindings ||| make occurs subst	count=2
arg	java array with java ||| into array	count=1
function_arg	transitive closure of ||| transitive closure g	count=1
function	sequence of all namespaces ||| all ns	count=1
function	from ||| classpath	count=1
arg	if [arg] type clojure ||| [arg]	count=1
function	smaller ||| &lt;	count=1
module	of contracts to existing ||| contracts	count=1
function	for nested sequences given ||| seq	count=1
function	the max-history of ||| ref max history	count=1
arg	z [arg_2] ||| [arg_2] y [arg_1]	count=1
arg	another element of l ||| l	count=1
arg	collection test s one ||| start test start key end test end key	count=2
function	parameters perform [function] ||| [function]	count=1
arg	for class clojure ||| class op form	count=1
module	uuid based on uniform ||| data generators	count=1
arg	ks ||| &amp; ks	count=1
module	the channel ||| async	count=1
function	a sequence ||| loader	count=1
arg	the item as the ||| item	count=2
function_arg	the async [arg_2] ||| [arg_2] [function_1]	count=3
function	or nil if ||| find	count=1
function	bindings ||| bindings	count=3
arg	the rank of x ||| x	count=1
arg	two channels the ||| buf or n f buf or	count=1
arg	checking ||| opt	count=1
function	clojure [function_2] ||| [function_1] [function_2]	count=3
arg	and name if ||| name	count=1
function	returns ||| element str	count=2
module	unmunged ||| repl	count=1
arg	creating that table ||| table	count=1
module	symbol [module] ||| [module]	count=3
arg	[arg] in ||| [arg] ms &amp;	count=1
function	gets the value ||| get	count=1
arg	new method of multimethod ||| multifn	count=1
arg	sets ||| sets	count=2
function	quoted form ||| check form info	count=1
module	return the difference ||| algo generic	count=1
arg	executes sql ||| db spec transaction? sql	count=1
function	value in a ||| assoc in	count=1
arg	given a database [arg_1] [arg_2] ||| [arg_1] spec option map [arg_2]	count=5
function_arg	returns a [function_1] [arg_2] ||| [function_1] [arg_2]	count=5
module	a polymorphic type with ||| typed	count=1
arg	message using ||| throwable message &amp; more	count=1
function	trace of ||| trace	count=1
function	the agents [function] ||| [function]	count=2
arg	true if [arg] is a ||| [arg]	count=1
function_arg	the methods [arg_2] ||| [function_1] [arg_2]	count=1
function	future object [function] will ||| future [function]	count=1
module	value [module] ||| [module]	count=1
arg	test s ||| start key end test end key	count=2
function	[function_1] [function_2] ||| core [function_2] [function_1]	count=3
arg	the clauses ||| &amp; clauses	count=2
function_arg	to stop [arg_2] ||| [arg_2] [function_1]	count=1
module	string representation ||| repl	count=1
arg	the given ||| &amp;	count=1
module	the given avl ||| data avl	count=1
function	[function_1] all ||| [function_2] [function_1]	count=1
function	returns a ||| element str	count=2
arg	or a composition thereof) ||| or n	count=1
module	and passed to ||| core	count=1
function	union of ||| union	count=1
function	initial cause of ||| root cause	count=2
module	[module_1] jvm ||| [module_1] [module_2]	count=4
function	resultset ||| resultset seq	count=1
arg	of the [arg_2] ||| [arg_2] [arg_1]	count=8
arg	an [arg] ||| [arg] &amp;	count=1
function	var coverage ||| var coverage	count=1
arg	a message ||| throwable message	count=1
arg	data to writer ||| writer data &amp;	count=1
function_arg	other [arg_2] ||| [arg_2] [function_1]	count=1
function_arg	or agent to the [function_1] [arg_2] in ||| [function_1] [arg_2]	count=4
arg	if it ||| x	count=2
function	create an array with ||| array	count=6
arg	else returns x ||| x	count=1
function_arg	[function_1] of num ||| [arg_2] [function_1]	count=2
arg	reducing [arg] ||| [arg]	count=3
function	given ||| zip	count=1
module	logic variables ||| logic	count=1
function	[function_1] [function_2] ||| [function_1] remainder [function_2]	count=1
arg	associates ||| m k	count=1
function	an instance of class ||| class?	count=1
arg	namespace ||| ns	count=5
arg	of multimethod associated ||| multifn dispatch val	count=2
function_arg	optional supplied [arg_2] ||| [function_1] comparator [arg_2]	count=1
function_arg	string [arg_2] ||| [function_1] [arg_2]	count=2
arg	function for class ||| class parameter types exception	count=1
function	return last ||| last	count=1
function	the left of loc ||| left	count=1
arg	[arg] optionally parameterized ||| [arg] transaction? sql param	count=1
arg	test s one ||| key end test end	count=2
function	the result of a ||| reduced?	count=1
function	a ||| classpath	count=2
arg	for class ||| class op form env	count=1
arg	[arg] provided as ||| [arg]	count=2
function_arg	[function_1] parent ||| [function_1] h tag [arg_2]	count=1
arg	creates and installs a ||| fn tail	count=1
function_arg	val returns a new [function_1] [arg_2] ||| [function_1] [arg_2]	count=6
arg	[arg_1] to that ||| [arg_1] [arg_2]	count=4
function	releasing any pending derefs ||| deliver	count=1
arg	a topic ||| topic ch	count=1
rep	[module_1] zero-type taking ||| [function_arg_2] [module_1]	count=2
module	channel to a ||| async	count=1
function	unmunged string representation of ||| element str	count=2
arg	u into [arg_2] ||| [arg_1] [arg_2]	count=1
function	transientmaybehostform ||| -&gt;transientmaybehostform	count=1
arg	the multimethod name in ||| name &amp;	count=1
function	the immediate parents ||| parents	count=1
arg	of match with replacement ||| match replacement	count=1
function_arg	define [function_1] [arg_2] ||| algo monads [function_1] base [arg_2]	count=3
function	checking print ||| print filterset	count=1
function_arg	last [arg_2] ||| [function_1] [arg_2]	count=4
module	its ast ||| tools analyzer	count=1
arg	coerces ||| xform	count=1
arg	returns the dispatch ||| dispatch val	count=1
function	gets the min-history of ||| ref min history	count=1
function	to the namespace ||| ns	count=2
arg	to the depth ||| depth	count=1
function_arg	[function_1] of coll ||| [function_1] 2d [arg_2]	count=1
arg	a multimethod and ||| multifn	count=1
module	clojure algo ||| algo	count=4
function	[function_1] the validator-fn ||| [function_1] [function_2] iref	count=1
arg	test s one of ||| start test start key end test	count=2
function	[function_1] method ||| [function_2] [function_1]	count=1
function_arg	[function_1] supports optional ||| [function_1] [arg_2]	count=3
function_arg	bindnode taking a ||| &gt;bindnode m#	count=1
module	function to ||| unify	count=2
arg	to [arg_2] ||| [arg_2] [arg_1]	count=5
arg	which ||| which	count=2
function	create an array with ||| int array	count=1
arg	for class ||| declaring class parameter types exception types flags	count=1
arg	sum of x ||| x	count=1
function	len-right-meter ||| &gt;len right	count=1
arg	[arg_1] at end ||| [arg_1] [arg_2]	count=1
function	are exhausted ||| db*	count=1
arg	then evaluates func passing ||| params func	count=1
module	a sequence of ||| java classpath	count=1
function_arg	given client-side transport ||| client transport	count=1
arg	functions and returns a ||| f g h &amp; fs	count=1
function	checking print the filter ||| print filterset	count=1
function	initial cause of an ||| root cause	count=2
arg	corresponding parameters ||| params &amp;	count=1
module	collection otherwise [module] false ||| [module]	count=1
function	allow asserts with a ||| assert with	count=1
function	[function] for ||| [function]	count=1
function	[function] coll which ||| [function]	count=3
arg	evaluates func passing in ||| string &amp; params func	count=1
arg	[arg_1] string debug-str ||| [arg_2] [arg_1]	count=2
arg	file ||| file	count=3
function	the aliases for ||| ns aliases	count=1
function	create an array ||| long array	count=1
arg	of the ||| f &amp;	count=1
arg	clauses ||| clauses	count=2
arg	true if [arg] a rational ||| [arg]	count=1
arg	out ||| out	count=1
arg	a message ||| level throwable message	count=1
arg	or name ||| or	count=1
function	map ||| map	count=21
arg	for class ||| type declaring class parameter types exception types flags	count=1
arg	maps in xrel ||| xrel	count=1
arg	applying ||| c1 c2 c3	count=1
arg	an object subject to ||| object	count=1
function	a possibly ||| str	count=2
function	for repl ||| repl	count=1
arg	function for class ||| class flags	count=1
arg	rsubseq for test in ||| coll test x	count=1
arg	channels the first of ||| f buf or	count=1
arg	taking n possibly the ||| n	count=1
function	the ddl string ||| table ddl	count=1
arg	etc or ||| or n	count=1
function	[function_1] any ||| [function_2] [function_1]	count=1
arg	of key ||| coll key	count=1
function	row of the processed ||| row	count=1
arg	test ||| start test start key end test end key	count=2
arg	body ||| body	count=10
arg	function for class clojure ||| class field op form	count=1
arg	threads ||| &amp; forms	count=1
function_arg	[function_1] body with ||| [function_1] out [arg_2]	count=1
arg	value ||| value	count=6
arg	func passing in ||| &amp; params func	count=1
arg	sorted collection test ||| key end test	count=2
function_arg	maybeclass [arg_2] ||| [function_1] [arg_2]	count=2
function	left of loc ||| left	count=1
function	min-history of ||| ref min history	count=1
function	rounding mode ||| with	count=1
arg	compiler when ||| doc string? attr map? params* body + attr	count=1
function_arg	key [arg_2] ||| [function_1] key [arg_2]	count=1
function_arg	sum of [arg_2] ||| [function_1] x y &amp; [arg_2]	count=1
arg	g ||| g	count=1
module	graph ||| algo graph	count=2
arg	dispatches ||| args	count=1
arg	state ||| new state	count=1
function_arg	[function_1] port ||| [function_1] [arg_2]	count=2
arg	takes a map of ||| map &amp; body	count=1
function	previous state ||| set state	count=1
function	options ||| options	count=1
function_arg	optional supplied [arg_2] ||| [function_1] keyfn comparator [arg_2]	count=1
arg	template expression ||| expr &amp;	count=1
arg	improper tail [arg] is a ||| a [arg]	count=1
function	non-directory entries [function_2] ||| [function_2] [function_1]	count=2
function	bitwise [function_2] ||| [function_2] [function_1]	count=4
function	a list ||| list	count=1
rep	[module_1] suspendedstream taking ||| [function_arg_2] [module_1]	count=1
arg	returns [arg_2] ||| [arg_2] [arg_1]	count=3
arg	factory function for class ||| f	count=1
function	from the ||| from jarfile entry	count=1
arg	of functions ||| &amp; fs	count=2
function	perform [function] ||| [function]	count=1
function	query then evaluates ||| db query	count=1
arg	to that result ||| &amp; forms	count=1
arg	sorted collection test s ||| test end key	count=2
function_arg	[function_1] v ||| [arg_2] [function_1]	count=3
arg	body in a context ||| &amp; body	count=1
arg	commands on the ||| command &amp;	count=1
arg	of multimethod associated with ||| multifn dispatch val &amp;	count=1
arg	a val into port ||| port val	count=1
function_arg	stream a [arg_2] ||| [arg_2] [function_1]	count=5
arg	l ||| l	count=4
arg	a failure continuation ||| cont failure cont	count=1
module	sequences given a ||| zip	count=1
function	path ||| path	count=1
arg	given symbol [arg] ||| [arg]	count=3
arg	[arg_1] sigs ||| [arg_2] [arg_1]	count=4
function	connection [function] ||| db [function]	count=1
arg	atomically resets [arg] ||| iref [arg]	count=1
arg	the base ||| base which m	count=1
arg	[arg] monotonically non-increasing ||| [arg]	count=1
function	last ||| last	count=1
arg	sorted collection test ||| test start key end test end key	count=2
function_arg	[function_1] taking ||| [function_1] meter [arg_2]	count=1
arg	that returns the ||| &amp;	count=1
function	key of the ||| key	count=1
module	several [module] operations ||| [module]	count=1
function_arg	term [arg_2] ||| [function_1] [arg_2]	count=3
module	point the output channel ||| async	count=1
arg	with supplied keys ||| &amp; keys	count=1
function_arg	[function_1] [arg_2] *out* ||| [function_1] [arg_2]	count=1
arg	exprs ||| &amp; exprs	count=2
arg	collection test s ||| test end key	count=2
arg	calls function [arg] with a ||| [arg]	count=1
function	juxtaposition of those ||| juxt	count=1
arg	set of functions and ||| f g h &amp; fs	count=1
arg	value ||| found	count=1
module	macros that are ||| macro	count=1
arg	class ||| declaring class flags	count=1
module	return type ||| typed	count=1
arg	of location loc ||| loc	count=1
function	with duplicates removed ||| distinct	count=1
arg	set1 a superset of ||| set1	count=1
function_arg	[function_1] [arg_2] ||| [function_1] coll [arg_2]	count=4
arg	keyval = > key ||| keyvals	count=3
function	class named by ||| new	count=1
function	contained in [function] ||| load [function]	count=2
arg	n possibly the ||| n	count=1
function_arg	inserts [arg_2] ||| [arg_2] [function_1]	count=3
function	reduced ||| reduced	count=1
function	assoc operation ||| assoc	count=1
function	containing ns ||| ns	count=1
function	value in ||| in	count=2
rep	vector containing [function_arg_2] ||| core [module_1] [function_arg_2]	count=1
module	type of ||| core typed	count=1
function	if obj [function] ||| [function]	count=1
function_arg	[function_1] the jar ||| [arg_2] [function_1]	count=4
function	sets ||| set	count=1
function_arg	parents of [arg_2] ||| [arg_2] [function_1]	count=4
arg	returns a function of ||| f	count=1
arg	compiler when it ||| doc string? attr map? params*	count=1
arg	from file ||| file	count=1
module	paths from ||| java	count=1
arg	returns true if o ||| o	count=1
arg	args ||| args	count=4
function_arg	[function_1] mappings ||| [function_1] comparator [arg_2]	count=3
module	from the channel ||| async	count=1
arg	evaluates func ||| sql string &amp; params func	count=1
function	metadata ||| metadata	count=2
arg	the cache system ||| cache item	count=1
arg	body with ||| bindings &amp; body	count=2
arg	x is ||| x	count=1
function	[function_1] stream a ||| [function_2] [function_1]	count=2
function_arg	[function_1] [arg_2] ||| pipeline [function_1] [arg_2] close?	count=4
function	bitwise shift [function_2] ||| [function_1] [function_2]	count=2
module	of json data from ||| data json	count=1
arg	n items each ||| n	count=1
arg	sorted collection test ||| start key end test	count=2
module	typed clojure type ||| typed	count=1
arg	[arg] returning ret ||| idx ret init [arg]	count=1
arg	a message using ||| level throwable message &amp; more	count=1
arg	supplied keys using the ||| &amp; keys	count=1
function_arg	inserts the [arg_2] ||| [arg_2] [function_1]	count=3
function	the structure-basis ||| struct	count=1
module	returns a zipper for ||| zip	count=1
function_arg	acos of x ||| acos x	count=2
arg	[arg_1] from ch ||| [arg_2] buf or [arg_1]	count=1
function	with components ||| into	count=1
arg	a set of functions ||| f g &amp; fs	count=1
module	representation ||| main	count=1
arg	multimethod and a ||| multifn	count=1
arg	to the transducer ||| ex handler	count=1
arg	sorted collection test s ||| start key end test	count=2
function_arg	[function_1] coll ||| [function_1] array 2d [arg_2]	count=3
arg	test s ||| key end test	count=2
arg	function for class ||| f	count=1
function	groups from ||| groups	count=1
arg	to expr evaluates ||| expr	count=1
arg	func passing in ||| string &amp; params func	count=1
arg	failure continuation ||| cont failure cont	count=1
arg	that [arg_2] ||| [arg_1] [arg_2]	count=2
module	class clojure data ||| data	count=7
module	given ast ||| tools analyzer passes jvm	count=2
arg	group [arg] ||| argv expr [arg]	count=1
arg	of x to *out* ||| x &amp; options	count=1
arg	of n ||| n bindings &amp;	count=1
module	results from type ||| typed	count=1
module	uniform distribution of low ||| generators	count=1
arg	l ||| l a	count=1
arg	the monad operations ||| m plus operations	count=1
module	specified level ||| tools logging	count=1
arg	[arg_1] [arg_2] ||| pipeline [arg_2] [arg_1]	count=3
arg	either maps representing rows ||| map :transaction? true :entities identity	count=1
arg	or a topic of ||| topic	count=1
module	ops [module] after ||| [module]	count=1
function	lazy sequence ||| seq	count=1
arg	topic of a ||| p topic ch	count=1
arg	function f [arg] ||| p1 p2 p3 [arg]	count=3
arg	sorted collection test ||| end test end key	count=2
function	the min-history ||| ref min history	count=1
arg	collection test s ||| key end test end key	count=2
arg	java io reader ||| reader	count=1
arg	agent state to ||| state &amp; options	count=1
function	[function_1] trace of ||| [function_1] [function_2]	count=1
arg	factory function for class ||| name type declaring class	count=1
module	is ||| core	count=9
function	list begun with ||| end list	count=1
rep	returns [module_1] [function_arg_2] ||| [module_1] [function_arg_2]	count=4
arg	expected type syntax and ||| expected type provided?	count=1
arg	parent either ||| parent	count=1
arg	char in s ||| s	count=2
function	expose ||| create	count=1
function	assoc ||| assoc	count=1
arg	the item as ||| item	count=2
function	url object [function] ||| [function]	count=1
function	default options from a ||| default options	count=1
function	[function_1] version as ||| [function_1] [function_2]	count=1
arg	by s and ||| s	count=1
arg	sql [arg_2] ||| [arg_2] [arg_1]	count=4
arg	and the gnu ||| &amp;	count=1
module	is the current ||| core	count=1
arg	used in [arg] expansion ||| fn bindings [arg]	count=1
arg	are in ||| y &amp;	count=1
arg	sequences given a root ||| root	count=1
module	test including ||| test	count=1
arg	c in the ||| c	count=1
arg	function for class ||| declaring class flags	count=1
function_arg	write an object ||| write object	count=2
arg	loc left-to-right marked so ||| loc	count=1
arg	improper tail [arg] ||| a [arg]	count=1
arg	expr ||| expr	count=6
function	new priority [function] ||| priority [function]	count=2
function	[function_1] in ||| [function_2] [function_1]	count=3
module	a source channel ||| async	count=1
arg	at most [arg_2] ||| [arg_2] [arg_1]	count=3
function	next ||| next	count=1
arg	[arg_1] of x ||| doto [arg_2] [arg_1]	count=1
module	and type checks the ||| core typed	count=1
function_arg	the negation [arg_2] ||| [arg_2] [function_1]	count=2
arg	state to ||| state &amp; options	count=1
arg	of functions and ||| g h &amp; fs	count=1
function	required ||| run	count=1
function	the keys ||| keys	count=1
function	a waiting stream ||| waiting stream check	count=2
arg	an ||| a	count=3
function	process ||| process	count=1
function	row of ||| row	count=1
function	java sql resultset ||| resultset	count=1
arg	of a fn ||| fn	count=1
arg	list of goals ||| goals	count=1
function_arg	[function_1] of tr ||| [arg_2] [function_1]	count=2
arg	n items from ||| n	count=1
arg	functions and returns a ||| fs	count=2
module	match then matching always ||| match	count=1
function_arg	thread or agent to [function_1] [arg_2] in ||| [function_1] [arg_2]	count=4
arg	function for class clojure ||| f	count=1
function_arg	sql resultset [arg_2] ||| [arg_2] [function_1]	count=1
module	of contracts to ||| core contracts	count=1
function	paths from a ||| classpath	count=1
module	whose usage value is ||| core	count=1
function	of all but ||| drop	count=1
module	unmunged string ||| repl	count=1
function	returns a sequence ||| loader	count=1
function	initial cause ||| root cause	count=2
arg	such that z ||| z	count=1
arg	to [arg] fn that ||| [arg] arg1 arg2 arg3	count=1
arg	name in [arg_2] ||| [arg_2] [arg_1]	count=2
function	array of objects containing ||| array	count=1
function	recursive bindings in the ||| flatten bindings	count=1
arg	repeatedly executes [arg_2] ||| [arg_1] [arg_2]	count=1
arg	a sorted collection test ||| test end key	count=2
function	column is [function_2] ||| [function_1] [function_2]	count=1
arg	newval ||| newval	count=1
arg	in ||| coll	count=1
function	returns the error-mode ||| error mode	count=1
function_arg	set with [arg_2] ||| [function_1] by comparator [arg_2]	count=3
arg	name in ||| name &amp; args	count=2
arg	each of the ||| &amp;	count=1
arg	first of l ||| l a	count=1
arg	u [arg_2] ||| [arg_1] [arg_2]	count=1
arg	all its contents ||| &amp; opts	count=1
arg	index ||| index	count=1
module	creates a channel ||| core async	count=1
arg	topic ||| p topic ch close?	count=1
arg	test s ||| end test end key	count=2
arg	functions ||| &amp; fs	count=2
arg	with the [arg_2] ||| [arg_2] [arg_1]	count=7
arg	of the monad operations ||| operations	count=1
arg	nothing which defaults to ||| m nothing which	count=1
arg	associates a value ||| k	count=1
arg	fntail ||| fntail	count=1
function	atomically alters ||| alter	count=1
function	symbol ||| symbol	count=2
arg	for the argument ||| class or object	count=1
module	from type ||| typed	count=1
module	low and ||| data	count=1
function	nested sequences ||| seq	count=1
arg	expands to clojure ||| kw args? name docstring? attr map? param :	count=1
function	a zipper for nested ||| zip	count=1
function	a monad [function] ||| monad [function]	count=3
module	monad and return ||| algo	count=1
module	expr [module] throws ||| [module]	count=1
function	[function_1] by the ||| [function_2] [function_1]	count=1
arg	of f on each ||| f	count=1
arg	a form ||| form	count=2
function_arg	trace [arg_2] ||| [function_1] [arg_2]	count=3
function	of loop that ||| length loop	count=1
arg	sorted collection test ||| start key end test end key	count=2
rep	arithmetic [function_arg_2] ||| [module_1] map [function_arg_2]	count=4
arg	relationship established via derive ||| h	count=3
arg	f on each element ||| f	count=1
module	object which ||| fressian	count=1
function	bound [function_2] ||| [function_2] [function_1]	count=1
arg	with loc ||| loc	count=3
function	supplied ||| by	count=6
arg	test ||| key end test end key	count=2
function	string representation of ||| element	count=2
arg	dispatch ||| dispatch val	count=1
function	print the filter ||| print	count=1
function	one-type ||| -&gt;one-type	count=1
function	the initial cause of ||| root cause	count=2
function	a [function] sequence of ||| [function]	count=1
arg	topic of a pub ||| p topic ch close?	count=1
arg	for class ||| declaring class parameter types	count=1
function	structure-basis ||| struct map	count=2
function_arg	[function_1] n ||| [arg_2] [function_1]	count=9
arg	current state by s ||| s	count=1
arg	containing sql and ||| sql	count=1
function	a new ||| sorted	count=1
module	of file paths from ||| classpath	count=1
function	returns ||| loader	count=1
function	committed choice ||| defnu	count=1
arg	f on each ||| f	count=1
function	allow asserts with a ||| with message	count=1
arg	specified ||| vs	count=1
function	zero-type ||| &gt;zero type	count=1
arg	s and ||| s	count=1
arg	error-mode of agent a ||| a mode keyword	count=1
arg	as per reduce of [arg_1] [arg_2] init ||| core reductions [arg_2] [arg_1]	count=1
function	ceil ||| ceil	count=1
module	ns ... ||| tools namespace	count=4
arg	end defaults to ||| end	count=1
function	length of the java ||| alength	count=1
arg	also refers to ||| args	count=1
function	single class followed by ||| class	count=1
function	a vec ||| vec	count=1
arg	ch ||| n ch	count=1
arg	a message only ||| message	count=1
arg	the expr through the ||| &amp;	count=2
function	is [function] than ||| [function]	count=1
arg	table name ||| table	count=1
function	the non-nil results ||| keep indexed	count=1
arg	the monad operations and ||| which m plus operations	count=1
arg	x and zero ||| x	count=1
function	loop that ||| print length loop	count=1
arg	f and returns a ||| f	count=1
arg	for class clojure ||| class field op	count=1
function	takes a val ||| &lt;!!	count=1
arg	if all [arg] provided ||| [arg]	count=1
function_arg	stop [arg_2] ||| [function_1] [arg_2]	count=1
module	paths from a ||| java classpath	count=1
arg	channels the ||| buf or n	count=1
arg	preceeded by literal ||| debug	count=2
arg	for class ||| declaring class parameter types exception types	count=1
arg	[arg] supplied ||| [arg] &amp;	count=2
function_arg	local [arg_2] ||| [arg_2] [function_1]	count=2
arg	[arg] an ||| [arg]	count=3
arg	[arg] a floating ||| [arg]	count=1
module	algo generic ||| algo generic	count=8
arg	input sets ||| sets	count=2
function	recursively under ||| clojure sources in	count=1
function	updates via assoc ||| update	count=1
module	... ||| tools namespace	count=7
function_arg	sin of x ||| sin x	count=2
function	[function_1] of local ||| [function_1] [function_2]	count=1
arg	where [arg] removed from ||| [arg] l	count=1
function	print [function] function to ||| set pprint [function]	count=1
arg	a java array with ||| into array	count=1
arg	data to writer ||| writer data	count=1
function	throwable ||| throwable	count=1
function	a ||| stack	count=4
arg	the error-mode of agent ||| a mode	count=1
arg	[arg_1] atom to ||| [arg_2] [arg_1]	count=2
function	possibly unmunged string representation ||| element str	count=2
module	of contracts ||| contracts	count=1
function	bean ||| bean	count=1
module	a uuid based ||| data	count=1
arg	rels returns the rel ||| xrel	count=1
function	the value in ||| in	count=1
function	[function_1] the method ||| [function_1] [function_2]	count=1
arg	analyzes a clojure form ||| form	count=1
arg	two channels ||| n f buf or n	count=1
function	all immediate children of ||| children	count=1
function_arg	in the [arg_2] ||| [function_1] [arg_2]	count=2
arg	the error-mode of agent ||| mode	count=1
arg	tr ||| tr	count=1
module	sequences ||| zip	count=1
arg	of multimethod ||| multifn dispatch val	count=2
module	channel and supplies ||| core	count=1
arg	to printwriter [arg_2] ||| [arg_2] [arg_1]	count=4
module	data from ||| data	count=1
arg	set of functions ||| f g h &amp; fs	count=1
arg	any args ||| args	count=1
arg	x to the ||| x	count=1
function	sequence of locations to ||| locs	count=2
arg	the error-mode of ||| a mode	count=1
module	like clojure tools analyzer ||| tools analyzer	count=1
function	a ||| element	count=4
arg	[arg] a rational ||| [arg]	count=1
arg	are in ||| x y &amp;	count=1
arg	the time bound-fn ||| &amp;	count=1
module	class clojure core logic ||| core logic	count=6
module	a channel with an ||| async	count=1
module	a [module] of ||| [module]	count=2
arg	[arg_1] dispatches ||| [arg_2] [arg_1]	count=2
function	during type checking print ||| print env	count=1
function	a ||| stack element str	count=4
function	[function_1] bindings ||| [function_2] [function_1]	count=1
arg	thread at the ||| &amp;	count=1
arg	n is ||| n	count=3
arg	associates ||| m k &amp;	count=1
arg	installs a new ||| val &amp; fn tail	count=1
module	the supplied channel ||| core async	count=1
rep	a [module_1] [function_arg_2] ||| [module_1] print [function_arg_2]	count=3
function	non-namespaced symbol ||| symbol	count=1
arg	and tag ||| tag	count=2
function	stream a ||| stream	count=1
module	with member type x ||| typed	count=2
function	column is ||| column	count=1
function_arg	[function_1] of x ||| [function_1] [arg_2]	count=12
arg	x by [arg_2] ||| [arg_1] [arg_2]	count=2
arg	return a string if ||| x	count=1
function	child of the ||| child	count=1
function	the ddl string for ||| table ddl	count=1
function	to substitute ||| subst	count=1
function_arg	[function_1] y ||| [function_1] x [arg_2]	count=2
function_arg	the method [arg_2] ||| [arg_2] [function_1]	count=3
arg	left-to-right starting with loc ||| loc	count=1
arg	then evaluates func ||| &amp; params func	count=1
function	for with ||| for	count=1
arg	of functions and ||| g &amp; fs	count=1
arg	u into [arg_2] ||| [arg_2] [arg_1]	count=1
arg	node at this loc ||| loc node	count=1
function	all but [function_2] ||| [function_1] [function_2]	count=1
arg	with an ||| &amp;	count=1
function	of default options from ||| get default options	count=1
function_arg	[function_1] comparator ||| [function_1] [arg_2]	count=20
arg	sc must ||| sc start test start key end	count=2
arg	error-mode ||| a mode	count=1
arg	factory function for class ||| class field op form env	count=1
arg	[arg_1] [arg_2] array starting at index ||| [arg_1] length [arg_2]	count=1
arg	specified padding length ||| in length pad length	count=1
function	returns [function_1] [function_2] can be any collection ||| [function_2] [function_1] coll	count=1
function	return last ||| last index of	count=1
arg	keyfn item ||| keyfn	count=1
arg	response-seq being read ||| response timeout	count=1
function	recursive bindings ||| bindings	count=1
function	the min-history of a ||| ref min history	count=1
module	[module_1] the type ||| [module_1] [module_2]	count=2
function	of ||| stack element str	count=2
function_arg	[function_1] jar ||| [function_1] [arg_2]	count=4
module	type x ||| core typed	count=2
function	the map of default ||| default	count=1
arg	class ||| declaring class parameter types	count=1
arg	value of the atom ||| atom	count=1
arg	[arg_1] forms ||| [arg_2] [arg_1]	count=2
function_arg	the last n ||| last n s	count=1
arg	of f applied to ||| f	count=1
module	channel and ||| async	count=1
arg	given name and ||| name	count=1
arg	first row [arg] ||| [arg]	count=1
arg	test ||| start key end test end	count=2
function_arg	right of [arg_2] ||| [arg_2] [function_1]	count=1
module	type ||| typed	count=38
arg	func passing ||| &amp; params func	count=1
arg	etc or ||| buf or n	count=1
arg	collection test s ||| end test	count=2
arg	value at the index ||| index not found	count=1
function	javadoc paths ||| javadoc	count=1
module	uuid based ||| generators	count=1
arg	a string if it ||| x	count=1
arg	g in the context ||| g	count=1
arg	object ||| object	count=2
arg	comparator and ||| comparator	count=2
arg	form ||| form &amp;	count=1
arg	values of ks ||| ks	count=1
arg	loc in ||| loc	count=1
arg	of coll which can ||| coll	count=1
arg	for the ||| class or	count=1
function_arg	[function_1] thread ||| [function_1] [arg_2]	count=2
arg	test s ||| test start key end test	count=2
arg	[arg] value has ||| [arg]	count=2
function_arg	class of [arg_2] ||| [arg_2] [function_1]	count=1
arg	a list of goals ||| goals	count=1
function	write an ||| write out	count=1
function	declaration [function_2] ||| [function_1] [function_2]	count=4
arg	and the base ||| base which m	count=1
arg	apply fun ||| fun	count=1
arg	the [arg] ||| &amp; [arg]	count=3
function_arg	[function_1] [arg_2] ||| [function_1] [arg_2]	count=1186
function	sequence of file ||| loader	count=1
function	optional single class ||| proxy class	count=1
function	the name string ||| name	count=1
module	type checking ||| typed	count=2
function	[function_1] set with ||| [function_1] [function_2]	count=7
arg	and o ||| o	count=1
function	optional single class ||| class	count=1
arg	class ||| type declaring class parameter types exception types flags	count=1
function	didn't allow asserts with ||| with message	count=1
arg	by [arg] starting ||| [arg] init	count=1
function	locations to [function_2] ||| [function_2] [function_1]	count=12
arg	the node ||| node	count=1
arg	column specs ||| specs	count=1
arg	function name is ||| name	count=1
arg	[arg_1] n items ||| [arg_1] [arg_2]	count=3
function	pretty print dispatch function ||| dispatch	count=1
module	ns-resolve and is ||| core	count=1
arg	keyval ||| &amp; keyvals	count=3
function_arg	[function_1] [arg_2] ||| [function_1] h tag [arg_2]	count=1
function_arg	indirect children [arg_2] ||| [function_1] [arg_2]	count=1
function	the [function] ||| unchecked [function]	count=5
function	analyze ||| analyze	count=1
function	groups from the ||| groups	count=1
function	byte ||| byte	count=2
function	conjugate ||| conjugate	count=1
arg	given a database [arg_1] [arg_2] parameters perform ||| [arg_1] spec option map [arg_2] params	count=1
arg	of types ||| &amp; types	count=2
arg	s ||| more	count=1
function	sequences given a ||| zip	count=1
module	avl sets ||| data avl	count=1
function_arg	optional supplied [arg_2] ||| [arg_2] [function_1]	count=2
function_arg	[function_1] the namespace ||| [arg_2] [function_1]	count=3
module	based on uniform ||| generators	count=1
arg	[arg] with parallelism ||| n to [arg] from	count=1
arg	x to ||| x &amp; options	count=4
function_arg	mapped [arg_2] ||| [function_1] keys [arg_2]	count=1
module	completed [module] not ||| [module]	count=1
function	low and high parts ||| uuid	count=1
module	possibly unmunged string ||| repl	count=1
arg	a map of ||| map &amp; body	count=1
module	test including macros java ||| test	count=1
arg	op ||| op	count=1
arg	[arg] into port ||| port [arg] fn1 on	count=2
arg	of the [arg] or nil ||| [arg]	count=1
arg	supplied keys ||| keys	count=2
arg	the gnu program argument ||| &amp; options	count=1
function_arg	returns [function_1] [arg_2] ||| core [function_1] [arg_2]	count=5
arg	two channels the ||| buf or n	count=1
arg	1 and end ||| end	count=1
arg	x and zero or ||| x	count=1
module	item of json data ||| data json	count=1
function	array ||| array	count=9
arg	all arguments ||| &amp; more	count=1
function	returns [function_1] [function_2] which can be any ||| [function_2] [function_1]	count=1
arg	positional factory ||| op	count=1
function_arg	[function_1] timeout ||| [arg_2] [function_1]	count=3
function	with a ||| assert with message	count=1
arg	of functions ||| fs	count=2
arg	vars ||| vars	count=1
arg	[arg] in ||| s match [arg]	count=1
rep	[module_1] maybeclass taking ||| [module_1] [function_arg_2]	count=2
arg	channels the ||| buf or	count=1
arg	and the gnu program ||| option specs &amp;	count=1
function	the right of ||| right	count=1
arg	functions [arg_1] [arg_2] supplied at the front ||| doto [arg_2] [arg_1]	count=3
arg	multimethod associated with ||| multifn	count=2
function	the types explicitly extending ||| extenders	count=1
function	is failed ||| agent error	count=1
arg	evaluates body ||| body	count=1
arg	channels the first ||| f buf or	count=1
arg	keyval = > ||| &amp; keyvals	count=3
function	prints the class ||| print	count=1
module	uniform ||| data	count=1
module	clojure algo generic ||| algo generic	count=8
function	union of the ||| union	count=1
arg	passing to fn1 ||| fn1	count=1
module	based on *rnd* ||| data generators	count=3
arg	parent / child relationship ||| h	count=2
function	for two ||| make	count=1
module	remove ||| algo graph	count=1
arg	factory function for class ||| class parameter types	count=1
arg	on [arg_2] ||| [arg_2] &amp; args [arg_1]	count=1
module	returns non-nil if ||| core	count=1
function_arg	[function_1] map entry ||| [function_1] [arg_2]	count=2
module	contracts to ||| core contracts	count=1
arg	[arg] an :eval ||| &amp; [arg]	count=3
arg	function [arg] with a ||| [arg]	count=1
arg	monad in which the ||| m which	count=1
arg	arity-1 signature [arg] ||| f [arg]	count=2
arg	of goals ||| goals	count=1
function	max-history of ||| ref max history	count=1
arg	custom keyfn [arg_2] ||| [arg_1] [arg_2]	count=3
function_arg	sorted set [arg_2] ||| [function_1] by comparator [arg_2]	count=2
function	[function_1] watch ||| [function_2] [function_1]	count=1
arg	suitable for use in ||| body	count=1
function	test ||| test	count=1
function	file paths from a ||| loader classpath	count=1
function	sequences given ||| zip	count=1
function	no two of ||| distinct?	count=1
arg	an object ||| object	count=1
function_arg	conjugate of [arg_2] ||| [arg_2] [function_1]	count=1
arg	function for class ||| type declaring class parameter	count=1
arg	commands on the specified ||| command &amp;	count=1
arg	in [arg] given namespaces; ||| [arg]	count=1
arg	func passing ||| string &amp; params func	count=1
module	the given avl sets ||| data avl	count=1
module	given ||| tools analyzer	count=1
module	and return its ||| algo	count=1
arg	sc must be a ||| sc start test start	count=2
function	declarations ||| find namespaces in	count=1
arg	[arg] where ||| x l [arg]	count=3
module	and supplies them ||| core	count=2
module	a ||| data generators	count=1
arg	match [arg_2] ||| [arg_2] [arg_1]	count=1
function	an array with ||| boolean array	count=1
function	[function] the ||| emit [function]	count=2
arg	with java ||| into	count=1
function	right [function_2] ||| [function_2] [function_1]	count=1
arg	input [arg_2] ||| data codec base64 encode! [arg_1] [arg_2]	count=1
function	a quoted ||| check form	count=1
arg	by s and returns ||| s	count=1
module	json [module_2] ||| [module_2] [module_1]	count=3
arg	atom to [arg_2] ||| [arg_1] [arg_2]	count=1
function	in the var object ||| var	count=1
arg	dispatch an ||| a	count=1
arg	of exprs ||| &amp; exprs	count=1
function	default ||| get default	count=1
function	stacktraceelement ||| element str	count=2
arg	[arg] type ||| [arg]	count=1
arg	match [arg_2] ||| [arg_1] [arg_2]	count=1
function	to number ||| num	count=1
arg	factory function for class ||| class op	count=1
arg	and an optional exception-handler ||| xform ex handler	count=1
arg	[arg_1] body only ||| core lazy seq [arg_1] [arg_2]	count=3
arg	obj ||| obj	count=1
arg	[arg_1] if ||| [arg_1] [arg_2]	count=1
function	type checking print the ||| print	count=1
arg	then binds name to ||| name &amp;	count=1
function	from the ||| from	count=1
function	current value ||| pr	count=1
arg	to ||| args	count=1
function_arg	[function_1] namespace ||| [arg_2] [function_1]	count=6
arg	class ||| class field	count=1
module	of json ||| json	count=1
function	list with ||| list	count=1
function_arg	or agent to the [function_1] [arg_2] ||| [function_1] [arg_2]	count=1
arg	a message using ||| throwable message &amp;	count=1
arg	bindings of the ||| &amp;	count=1
arg	of the monad operations ||| which m plus operations	count=1
arg	monad operations and the ||| plus operations	count=1
arg	m into a monad ||| m	count=1
function	fresh stringwriter ||| out str	count=1
arg	takes a coll and ||| coll	count=1
function_arg	[function_1] 3a: the ||| [arg_2] [function_1]	count=1
function	predicate for ||| pred	count=1
arg	relationship [arg_2] ||| [arg_2] [arg_1]	count=1
function	[function_1] left of ||| [function_2] [function_1]	count=4
arg	[arg_1] in ||| [arg_1] [arg_2]	count=3
function	aliases for the ||| aliases	count=1
arg	[arg_1] offset index ||| [arg_2] [arg_1]	count=2
function_arg	[function_1] success continuation ||| [arg_2] [function_1]	count=4
arg	key by ||| key	count=1
arg	goals until ||| goals	count=2
arg	name ||| name	count=6
arg	of the [arg_2] ||| [arg_1] [arg_2]	count=7
function	agent is failed ||| agent error	count=1
function	by a ||| by	count=1
arg	factory function for class ||| class parameter	count=1
arg	until [arg] old-data ||| data fun [arg]	count=1
arg	[arg_1] coll to ||| core sequence [arg_1] [arg_2]	count=1
arg	an expression and a ||| expr &amp;	count=1
arg	of x ||| x &amp; body	count=1
arg	dispatches on [arg_2] ||| [arg_2] &amp; [arg_1]	count=1
arg	to a topic of ||| p topic ch	count=1
function	nested sequences ||| seq zip	count=1
function	case ||| case	count=2
arg	of x by ||| x	count=2
module	class clojure tools analyzer ||| tools analyzer	count=8
function_arg	[function_1] array ||| core [function_1] [arg_2]	count=3
function_arg	sin of [arg_2] ||| [arg_2] [function_1]	count=1
arg	goals until ||| &amp; goals	count=2
function_arg	[function_1] sql commands ||| [arg_2] [function_1]	count=1
arg	func passing ||| params func	count=1
arg	writes data to writer ||| writer data &amp; options	count=1
function_arg	[function_1] pred ||| [function_1] [arg_2]	count=1
function	map [function] ||| [function] unify	count=2
function	class followed ||| proxy class	count=1
function	juxtaposition of ||| juxt	count=1
arg	[arg_1] namespace ns ||| [arg_2] [arg_1]	count=7
function	returns a lazy seq ||| response seq	count=1
module	type x with ||| typed	count=3
module	[module_1] generic ||| [module_1] [module_2]	count=32
function	removes a watch ||| remove watch	count=3
module	the return type of ||| core typed	count=1
module	sequence of file ||| java	count=1
arg	then evaluates func passing ||| func	count=1
function	in [function] block for ||| [function]	count=1
function_arg	conjugate [arg_2] ||| [arg_2] [function_1]	count=1
function	drop ||| split at	count=1
arg	of l ||| l	count=3
arg	functions ||| h &amp; fs	count=1
function	for any functional predicate ||| assert predicate	count=1
function_arg	conjugate of x ||| conjugate x	count=2
arg	in a transaction ||| &amp;	count=2
function	local [function_2] ||| [function_2] [function_1]	count=1
arg	two channels ||| t buf or n f buf or	count=1
function	of var ||| var	count=1
module	and returns its ast ||| analyzer	count=1
arg	[arg_1] the offset ||| [arg_2] [arg_1]	count=4
function	the ddl string for ||| create table ddl	count=1
arg	from ||| from	count=2
arg	env symbol ||| env sym	count=2
arg	name [arg_2] ||| [arg_2] [arg_1]	count=4
function	to a string ||| str	count=1
arg	true if x ||| x	count=6
arg	error-mode of ||| a mode	count=1
arg	to printwriter out as ||| x out escape unicode?	count=1
arg	result of f on ||| f	count=1
module	and return its result ||| algo	count=1
arg	index ||| index not	count=1
rep	[module_1] one-type taking ||| [module_1] map [function_arg_2]	count=6
function	read a ||| read	count=3
arg	test s one ||| test start key end test end	count=2
module	of low and ||| generators	count=1
module	sequence of file paths ||| classpath	count=1
arg	returns the map with ||| map	count=1
arg	args f ||| f &amp; args	count=1
module	class clojure algo ||| algo	count=4
function_arg	[function_1] jar file ||| [arg_2] [function_1]	count=4
arg	evaluates func ||| params func	count=1
arg	the keys ||| keys	count=1
arg	subject [arg_1] [arg_2] with parallelism ||| [arg_2] [arg_1]	count=1
arg	execute body ||| body	count=1
arg	expression else returns x ||| x	count=1
arg	operations and the ||| m plus operations	count=1
function_arg	[function_1] value ||| [function_1] s [arg_2]	count=1
function_arg	[function_1] 3a: ||| [arg_2] [function_1]	count=1
arg	all arguments ||| more	count=1
arg	its-current-meta args ||| args	count=1
function	to byte ||| unchecked byte	count=1
arg	channels the first of ||| n f buf or n	count=1
function_arg	const taking ||| &gt;const m#	count=1
function	sequence of ||| classpath	count=1
function_arg	[function_1] given thread ||| [arg_2] [function_1]	count=3
function	and initialize all ||| if needed	count=1
arg	sql commands on ||| spec transaction? sql command &amp; sql commands	count=1
module	goal to ||| logic	count=1
arg	a regular expression ||| pattern	count=1
arg	evaluation of [arg] ||| idx ret init [arg]	count=3
arg	topic of a pub ||| p topic	count=2
function	a possibly unmunged string ||| stack	count=2
arg	functions and ||| f g h &amp; fs	count=1
arg	in which ||| m which	count=1
function	override all constructors ||| override	count=1
function	named by ||| new	count=1
arg	of multimethod associated ||| multifn	count=2
module	on uniform distribution of ||| data	count=1
function	checking print the filter ||| print	count=1
function	bound to [function_2] ||| [function_1] [function_2]	count=1
arg	the contents [arg] closing ||| [arg]	count=1
function_arg	resultset rs ||| resultset seq rs	count=1
function_arg	[function_1] supplied keys ||| [arg_2] [function_1]	count=10
arg	two channels the first ||| buf or n f buf or	count=1
function_arg	write an object ||| write out object	count=1
arg	name to expr ||| expr	count=1
function	the var object ||| var	count=1
arg	the sequence of items ||| items	count=1
arg	[arg] for a ||| iref [arg]	count=1
function	child of ||| child	count=1
arg	commands on ||| command &amp; sql commands	count=1
arg	s is ||| s	count=1
arg	improper tail [arg] is ||| a [arg]	count=1
arg	of n ||| n bindings	count=1
function	[function_1] longs ||| [function_2] [function_1]	count=2
function	non-directory entries in the ||| filenames in	count=1
function	from a ||| loader classpath	count=1
arg	and yields a seqable [arg_1] [arg_2] ||| core lazy seq [arg_1] [arg_2]	count=4
function_arg	[function_1] mappings ||| [function_1] keyfn comparator [arg_2]	count=3
arg	for class ||| class field op form	count=1
function	both [function_2] ||| [function_1] multiply [function_2]	count=1
function_arg	[function_1] taking ||| [arg_2] [function_1]	count=12
rep	returns the [function_arg_2] ||| [module_1] [function_arg_2]	count=4
module	create ||| data	count=1
arg	z is x ||| x y z	count=1
arg	n default 1 items ||| n	count=1
arg	method sigs ||| sigs	count=1
function_arg	[function_1] of the ||| [arg_2] [function_1]	count=2
arg	for class clojure ||| class op	count=1
function	any ||| any	count=1
arg	a sorted collection test ||| test start key end test end key	count=2
function	all descendants of ||| descendants	count=1
arg	[arg_1] specified ||| [arg_1] [arg_2]	count=3
function	seq on java ||| seq	count=1
function	the error-mode of agent ||| error mode	count=1
arg	associative structure where ks ||| &amp; ks	count=1
function_arg	remainder of [arg_2] ||| [function_1] int [arg_2]	count=3
function	new hash set with ||| hash set	count=1
function	sample ||| sample	count=1
function	a bool ||| boolean	count=1
function	sequences given a ||| seq	count=1
arg	input ||| input	count=3
arg	plus any args ||| args	count=1
function	zipper ||| seq zip	count=1
module	clojure core ||| core	count=7
function	locations to ||| locs	count=2
function_arg	conjoined to [arg_2] ||| [function_1] coll [arg_2]	count=1
arg	[arg_1] value at ||| [arg_2] [arg_1]	count=1
arg	number of types ||| &amp; types	count=2
function	tests if it ||| instance?	count=1
arg	with custom keyfn ||| keyfn	count=1
arg	error-mode of agent a ||| mode keyword	count=1
arg	its superclass [arg] ||| c &amp; [arg]	count=3
function_arg	hierarchical data ||| tree data	count=1
function_arg	given client-side [arg_2] ||| [function_1] [arg_2]	count=1
arg	of functions and returns ||| g &amp; fs	count=1
module	required ||| analyzer jvm	count=1
module	returns ||| repl	count=1
arg	all the ||| &amp; args	count=1
arg	row [arg] by ||| [arg]	count=1
arg	coerces coll ||| xform coll	count=1
arg	difference of x ||| x	count=2
arg	executes goals until a ||| db bindings &amp; goals	count=1
arg	true if x is ||| x	count=6
function	hash map with ||| hash map	count=1
arg	key ||| key	count=6
arg	two channels ||| buf or	count=1
arg	monad in which the ||| which	count=1
arg	or ||| or n	count=1
module	point the output channel ||| core async	count=1
function	didn't allow asserts with ||| assert with	count=1
arg	test s ||| start test start key end test	count=2
module	of ||| data	count=1
module	for nested ||| zip	count=1
arg	monad in which ||| m which	count=1
function	unmunged string representation of ||| str	count=2
module	given [module] call ||| [module]	count=1
rep	[module_1] [function_arg_2] ||| [module_1] map [function_arg_2]	count=62
arg	associates a value ||| m k &amp;	count=1
function_arg	async [arg_2] ||| [arg_2] [function_1]	count=3
arg	sequence of ||| g	count=1
arg	collection test s one ||| test end key	count=2
function	of the methods ||| methods	count=1
module	and ||| core async	count=1
module	returns a ||| zip	count=1
module	the type environment to ||| core typed	count=1
function	stream ||| stream check	count=2
function	subscribes a ||| sub	count=1
function_arg	[function_1] of nums ||| [arg_2] [function_1]	count=1
function	with that name ||| find	count=1
function	case 2: if ||| case	count=1
function_arg	[function_1] u ||| [function_1] [arg_2]	count=1
function	the possibly cached value ||| force	count=1
function	for nested sequences given ||| seq zip	count=1
function	sets the ||| set	count=1
function_arg	[function_1] transport ||| [function_1] [arg_2]	count=3
function	of locations to ||| locs	count=2
arg	logs a message ||| throwable message	count=1
function_arg	one-type taking ||| &gt;one type m#	count=1
arg	length starting ||| length	count=1
module	reader ||| reader	count=1
function_arg	[function_1] supplied keys ||| [function_1] by comparator [arg_2]	count=5
function	[function_1] closure ||| [function_2] [function_1]	count=3
rep	sorted [function_arg_2] ||| [module_1] sorted [function_arg_2]	count=4
arg	of two channels the ||| n f buf or	count=1
module	distribution ||| data generators	count=1
arg	[arg_1] method sigs ||| [arg_1] [arg_2]	count=3
module	a goal that ||| core logic	count=4
function	coerce to byte ||| byte	count=2
function_arg	[function_1] custom keyfn ||| [arg_2] [function_1]	count=1
function	of file paths from ||| loader	count=1
arg	agent state to ||| new state &amp; options	count=1
module	macro expansion ||| tools macro	count=1
arg	p etc or a ||| or	count=1
module	graph ||| graph	count=3
arg	by val ||| val	count=1
arg	to a topic of ||| p topic	count=1
arg	atom [arg_2] ||| [arg_1] [arg_2]	count=1
arg	factory function for class ||| class op form	count=1
arg	value of atom to ||| atom	count=1
function	[function_1] initialize all ||| [function_2] [function_1]	count=1
function	[function] read ||| response [function]	count=3
arg	and logs a message ||| level throwable message	count=1
function	clojure version as ||| clojure version	count=2
function	stacktraceelement ||| stack element str	count=2
module	a ||| repl	count=2
module	the goal [module] check that ||| [module]	count=1
arg	expression or ||| or pattern	count=2
arg	p etc or ||| buf or n	count=1
module	a [module] ||| core [module]	count=11
arg	and the ||| option specs &amp;	count=1
arg	jar file ||| jar file	count=2
arg	object of the same ||| &amp;	count=1
arg	printwriter out ||| x out escape unicode?	count=1
arg	factory function for class ||| declaring class parameter types exception	count=1
arg	[arg] is a ||| [arg]	count=3
module	a ||| core	count=5
arg	binds name ||| name	count=1
arg	topic ||| topic ch	count=1
module	macros that are ||| tools macro	count=1
module	uniform distribution ||| data	count=1
function	completeschanges the agent's state ||| release pending sends	count=1
arg	on ||| env	count=1
module	sequentially read [module] evaluate the ||| [module]	count=2
function_arg	[function_1] [arg_2] ||| [function_1] out &amp; [arg_2]	count=1
function_arg	/ let [arg_2] ||| [function_1] [arg_2]	count=1
arg	taking a ||| m#	count=12
function_arg	the last [arg_2] ||| [function_1] [arg_2]	count=4
module	uniform distribution of low ||| data generators	count=1
function	a lazy seq of ||| seq	count=1
arg	the form ||| form	count=2
arg	channels ||| t buf or n f buf or	count=1
arg	expands to clojure ||| kw args? name docstring?	count=1
arg	expr at ||| expr	count=1
function	floor of ||| floor	count=1
arg	[arg_1] filters ||| [arg_2] [arg_1]	count=1
arg	superclass [arg] ||| c &amp; [arg]	count=3
arg	item as ||| item	count=2
function	snapshot of a ||| snapshot	count=1
arg	n possibly ||| n	count=1
function	if obj [function] object ||| [function]	count=1
function_arg	[function_1] tag either ||| [function_1] h [arg_2]	count=3
arg	a topic of a ||| p topic	count=2
arg	its-current-meta args f ||| f &amp; args	count=1
module	source channel ||| async	count=1
function_arg	floor [arg_2] ||| [arg_2] [function_1]	count=1
function	monotonically decreasing order otherwise ||| &gt;	count=1
arg	puts a val ||| val	count=2
arg	then binds name to ||| name &amp; forms	count=1
arg	the key ||| key	count=1
arg	to coerce its argument ||| x &amp; opts	count=1
arg	instance of the ||| &amp;	count=1
arg	contents [arg] closing ||| [arg]	count=1
function	recursively under ||| find clojure sources	count=1
arg	the monad operations ||| plus operations	count=1
arg	[arg_1] [arg_2] ||| string replace [arg_2] [arg_1]	count=1
arg	commands on the ||| command	count=1
arg	n is 0 ||| n	count=1
module	low ||| data generators	count=1
function	[function] first row ||| first row wildcards [function]	count=1
arg	message ||| level throwable message	count=1
function	the aliases for the ||| ns aliases	count=1
module	that the goal ||| logic	count=1
function	structures ||| table	count=1
function	return last index of ||| last index	count=1
arg	evaluates func passing ||| &amp; params func	count=1
module	type environment ||| typed	count=1
arg	set of functions and ||| fs	count=2
function	zipper for ||| zip	count=1
arg	swaps the [arg_2] ||| [arg_2] [arg_1]	count=3
module	returns a new collection ||| algo generic collection	count=2
function_arg	annotate record [arg_2] ||| [arg_2] [function_1]	count=2
module	of results from type ||| typed	count=1
arg	[arg_1] of x ||| [arg_2] [arg_1]	count=1
arg	[arg] with ||| function &amp; [arg]	count=1
function	immediate parents of ||| parents	count=1
arg	is a sequence ||| not found	count=1
arg	that dispatches on op ||| op &amp; args env	count=1
arg	class clojure ||| class field op form env	count=1
module	return [module_2] ||| [module_1] [module_2]	count=8
arg	the form ||| form expected	count=1
arg	format fmt result to ||| fmt	count=1
function_arg	tan of x ||| tan x	count=2
arg	returns the [arg_2] ||| [arg_2] [arg_1]	count=4
arg	tag through ||| tag	count=1
function_arg	or agent to the [function_1] [arg_2] ||| [function_1] [arg_2] agents	count=1
function	sequence ||| loader classpath	count=1
function	is the composition ||| comp	count=1
function	string representation of ||| str	count=2
module	channel ||| async	count=13
function	returns a possibly unmunged ||| stack element	count=2
arg	coll to ||| coll &amp;	count=1
arg	in coll where the ||| coll	count=1
arg	yields ||| &amp; oldform	count=1
arg	an expression and ||| expr &amp;	count=1
function	structures of ||| table	count=1
function	max-history ||| ref max history	count=1
arg	reads all its contents ||| &amp; opts	count=1
function_arg	class [arg_2] ||| [arg_2] [function_1]	count=1
arg	corresponding to sym ||| sym	count=1
module	new-state [module] then ||| [module]	count=1
module	and type checks the ||| typed	count=1
function	debug ||| debug	count=1
arg	the context ||| &amp;	count=1
arg	channels the ||| buf or n f buf or n	count=1
function	a seq of values ||| values	count=1
arg	opts ||| ast opts	count=1
arg	with the [arg_2] ||| doto [arg_2] [arg_1]	count=1
function	prints the class and ||| print	count=1
function_arg	return last [arg_2] ||| [arg_2] [function_1]	count=1
arg	to ||| &amp;	count=11
arg	which the base ||| which	count=1
arg	[arg_1] to ||| [arg_1] [arg_2]	count=16
arg	atomically resets [arg] for a ||| iref [arg]	count=1
arg	multimethod that ||| &amp;	count=1
module	based ||| data	count=1
function_arg	map with [arg_2] ||| data priority-map priority [function_1] by [arg_2]	count=3
arg	executes sql commands ||| db spec transaction? sql command &amp; sql commands	count=1
function	the first [function_2] ||| [function_2] [function_1]	count=3
function	of a [function] ||| [function]	count=1
arg	repeatedly executes [arg_2] ||| [arg_2] [arg_1]	count=1
arg	[arg_1] of atom ||| [arg_2] [arg_1]	count=3
function	view of one element ||| element	count=1
function	adds to the list ||| add	count=1
arg	d is [arg_2] ||| [arg_2] [arg_1]	count=2
module	return ||| algo	count=6
function	function [function] to ||| [function] pprint	count=1
rep	priority [function_arg_2] ||| [module_1] priority [function_arg_2]	count=5
function	value in a nested ||| assoc in	count=1
function	bound-fn was called ||| bound	count=1
arg	class name dname ||| binder dname field : type* opts*	count=2
function	in ||| assoc in	count=2
function_arg	and [arg_2] ||| [arg_2] [function_1]	count=1
arg	returns the ||| coll	count=1
function	gets [function_2] ||| [function_1] [function_2] iref	count=1
function	non-directory entries in ||| filenames in	count=1
function	nested sequences ||| zip	count=1
function	in a nested ||| assoc in	count=1
arg	into v ||| v	count=1
arg	the no-arg [arg] in ||| &amp; [arg]	count=1
function	to stop the ||| thread stopper	count=1
arg	step to 1 ||| step	count=1
arg	val from port ||| port	count=3
function	asserts with ||| with	count=1
function	possibly unmunged ||| element str	count=2
arg	[arg_1] y ||| [arg_2] [arg_1]	count=15
function_arg	[function_1] pred item ||| [arg_2] [function_1]	count=1
function	hash code of its ||| hash	count=1
module	it if ||| core	count=1
module	json data from a ||| data json	count=1
module	and typed clojure type ||| typed	count=1
function_arg	[function_1] data ||| [function_1] [arg_2]	count=1
arg	given a [arg_1] [arg_2] parameters perform ||| [arg_1] [arg_2] params	count=1
arg	test ||| start key end test end key	count=2
function	to [function] ||| [function]	count=1
arg	non-nil [arg_1] [arg_2] monotonically non-increasing order otherwise ||| &gt;= [arg_1] [arg_2]	count=1
rep	a [module_1] [function_arg_2] ||| [module_1] [function_arg_2]	count=3
arg	creates and installs ||| dispatch val &amp; fn tail	count=1
function_arg	least of [arg_2] ||| [function_1] x y [arg_2]	count=1
arg	the thread at the ||| &amp;	count=1
function	one ||| thread	count=1
function	returns the initial cause ||| root cause	count=2
arg	connection a ||| db	count=1
arg	function for class clojure ||| class field op	count=1
function	both ||| unchecked add	count=1
function	send-off ||| send off	count=1
module	a [module] which contains ||| core [module]	count=1
module	supplied channel ||| async	count=1
arg	of two channels the ||| f buf or n	count=1
module	the given type ||| typed	count=1
function	returns a zipper ||| seq	count=1
arg	a clojure form ||| form	count=1
arg	true if [arg] a ||| [arg]	count=2
module	string representation ||| main	count=1
function_arg	[function_1] [arg_2] *out* ||| [function_1] out [arg_2]	count=1
arg	colls ||| colls	count=1
function_arg	[function_1] nums ||| [arg_2] [function_1]	count=1
arg	with the keys ||| keys	count=1
arg	z [arg_2] ||| [arg_2] [arg_1]	count=1
function	of all other ||| -	count=1
module	to a [module] of the ||| [module]	count=1
arg	ctor and ||| ctor	count=1
arg	expected type syntax and ||| provided?	count=1
arg	[arg] new-state ||| a [arg]	count=1
module	channel will ||| core async	count=1
module	graph that ||| graph	count=1
function	[function_1] chosen ||| [function_2] [function_1]	count=3
arg	a java io reader ||| reader &amp; options	count=1
module	for class clojure data ||| data	count=7
function	an array ||| boolean array	count=1
arg	channels the first ||| or n f buf or	count=1
arg	n items in coll ||| coll	count=1
arg	of multimethod associated with ||| multifn	count=2
arg	an ipushbackreader or ||| reader eof error? eof value	count=1
module	and a source channel ||| async	count=1
function	read a [function_2] ||| [function_1] [function_2]	count=2
arg	the index ||| index	count=1
arg	true if the value ||| value	count=2
arg	until [arg] old-data new-data ||| data fun [arg]	count=1
module	sequence of file ||| java classpath	count=1
module	clojure core [module_2] ||| [module_1] [module_2]	count=12
function	[function] field values ||| [function]	count=1
arg	at offsets step apart ||| step pad coll	count=1
arg	writes data to writer ||| writer	count=1
arg	evaluates body in a ||| body	count=1
function	to substitute unification bindings ||| occurs subst	count=1
function	possibly ||| element str	count=2
arg	method of multimethod associated ||| multifn dispatch val &amp;	count=1
arg	two channels ||| f buf or	count=1
function_arg	[function_1] memo-placed memoization ||| [function_1] [arg_2]	count=1
arg	sets the error-mode ||| a mode	count=1
module	a sequence ||| java classpath	count=1
module	based on ||| data generators	count=2
module	returns its ast ||| tools analyzer	count=1
function	var with that ||| find var	count=2
arg	resets [arg] for a ||| iref [arg]	count=1
arg	class ||| name type declaring class	count=1
function_arg	loop [arg_2] ||| [function_1] [arg_2]	count=1
arg	sql commands ||| spec transaction? sql command &amp; sql	count=1
arg	keys ||| &amp; keys	count=4
arg	given namespace and name ||| ns name	count=1
arg	test s one ||| end test	count=2
function	checking print the ||| print	count=2
function	of a ||| stack element	count=2
arg	regular expression or stringable ||| or pattern	count=1
module	uniform distribution ||| generators	count=1
function	zipper for ||| seq zip	count=1
function	all other ||| -	count=1
function	equal ||| =	count=1
function_arg	map [arg_2] ||| [function_1] by [arg_2]	count=5
arg	function for class ||| type declaring class parameter types exception	count=1
function	bindings ||| flatten bindings	count=1
arg	to the promise ||| promise	count=1
arg	the gnu ||| option specs &amp;	count=1
function_arg	check a [arg_2] ||| [function_1] ns ns or [arg_2]	count=1
arg	lists of n ||| n	count=1
function	declaration from the named ||| decl from jarfile	count=1
arg	that calls cf default ||| cf	count=1
module	corresponding to this and ||| core	count=1
arg	of tag through ||| tag	count=1
function	stop the given ||| stopper	count=1
function_arg	[function_1] tr ||| [arg_2] [function_1]	count=2
arg	else runs body in ||| &amp; body	count=1
function	of booleans ||| boolean	count=1
function	the current value of ||| pr	count=1
arg	form is a ||| form	count=1
function	unification ||| occurs	count=1
arg	[arg_1] symbol ||| [arg_2] [arg_1]	count=1
arg	[arg_1] out as ||| [arg_2] [arg_1]	count=8
arg	are updated by the ||| key val pairs	count=1
function	both ||| unchecked	count=3
arg	message only ||| message	count=1
arg	the rest of l ||| l	count=1
function_arg	[function_1] keyfn custom ||| [arg_2] [function_1]	count=1
arg	pred item ||| pred	count=1
function	lazy seq of ||| response seq	count=1
module	until completed [module] not intended ||| [module]	count=1
arg	or char in s ||| s	count=2
module	function to ||| core unify	count=2
arg	class clojure ||| class field op form env extmap	count=1
function_arg	map [arg_2] ||| [arg_2] [function_1]	count=7
function	array of ints ||| array	count=1
module	completed [module] not intended ||| [module]	count=1
arg	all its contents returning ||| &amp; opts	count=1
arg	[arg_1] an active ||| [arg_2] [arg_1]	count=6
arg	of expr ||| expr	count=1
arg	function for class ||| class op form env extmap	count=1
function	returns [function_1] [function_2] which can be any ||| [function_2] [function_1] coll	count=1
arg	root ||| root	count=2
function	the java sql resultset ||| resultset	count=1
function	context ||| contexts str	count=1
arg	from ch ||| n ch	count=1
function	a var ||| create var	count=1
arg	[arg_1] [arg_2] removed from l exactly ||| core logic rembero [arg_2] [arg_1]	count=4
arg	topic of a ||| topic	count=2
arg	[arg_1] offset ||| [arg_2] [arg_1]	count=2
function	that result repeating ||| as &gt;	count=1
module	a is the ||| core	count=1
arg	until [arg] ||| f [arg]	count=2
arg	[arg_1] sigs ||| [arg_1] &amp; [arg_2]	count=1
function_arg	coll drop n ||| split at n	count=1
function	is chosen ||| chosen	count=1
function_arg	the contents [arg_2] ||| [function_1] array 2d [arg_2]	count=3
function	of local ||| local	count=1
module	uuid based ||| data generators	count=1
arg	monad operations and ||| which m plus operations	count=1
function	value in a nested ||| in	count=1
arg	form ||| form env opts	count=1
function	a ns ||| file ns	count=1
arg	[arg] using tools ||| [arg]	count=3
function	shift left ||| shift left	count=2
module	distribution ||| generators	count=1
function	zipper for ||| seq	count=1
module	for nested sequences given ||| zip	count=1
function_arg	var [arg_2] ||| [arg_2] [function_1]	count=2
arg	of the vars ||| &amp; vars	count=1
arg	the [arg_2] ||| [arg_2] f x y [arg_1]	count=2
function	for ||| seq zip	count=1
arg	[arg_1] [arg_2] ||| [arg_2] fn1 [arg_1]	count=6
module	ast ||| tools analyzer passes	count=1
function	ddl string for ||| create table ddl	count=1
arg	use [arg] go blocks ||| [arg]	count=1
function	the method of ||| method	count=1
function_arg	negation of [arg_2] ||| [function_1] [arg_2]	count=1
arg	offset index and base64 ||| offset	count=1
arg	converts x to ||| x &amp;	count=2
function_arg	map with [arg_2] ||| [function_1] by [arg_2]	count=5
arg	the values in aseq ||| aseq	count=1
arg	to ||| sym &amp;	count=1
function	a map of ||| map	count=14
arg	array [arg] ||| input offset [arg]	count=1
arg	and the ||| args option specs &amp;	count=1
function_arg	thread or agent to [function_1] [arg_2] ||| [function_1] [arg_2] agents	count=1
module	returns ||| core	count=59
arg	a topic ||| topic	count=2
arg	on stream s is ||| s	count=1
function	gets the max-history ||| ref max history	count=1
function	the least ||| min	count=1
module	and ||| data	count=1
function	return the ddl string ||| create table ddl	count=1
function	the error-mode of ||| error mode	count=1
function_arg	runs [arg_2] ||| [function_1] [arg_2]	count=1
module	typed clojure type ||| core typed	count=1
arg	keys using the ||| &amp; keys	count=2
function	the validator-fn ||| validator	count=1
arg	creates and installs ||| &amp; fn tail	count=1
function_arg	[function_1] coll ||| [function_1] 2d [arg_2]	count=1
arg	the supplied ||| ch	count=1
arg	of the input ||| input offset	count=1
function	representation of a ||| element str	count=2
arg	[arg_1] containing sql ||| [arg_1] [arg_2]	count=2
arg	starting at the offset ||| offset	count=1
function	non-nil results of ||| keep indexed	count=1
arg	summary ||| summary	count=1
arg	topic ||| topic	count=2
arg	the ||| idx2 &amp;	count=7
arg	the body ||| &amp; body	count=1
arg	dispatch ||| dispatch	count=2
arg	changes [arg] ||| a [arg]	count=1
function	representing an assoc ||| assoc	count=1
arg	items from ch ||| n ch	count=1
arg	parent either via a ||| parent	count=1
function	annotated var coverage ||| var	count=1
arg	sets the error-mode of ||| mode keyword	count=1
arg	s ||| s &amp;	count=1
function	the empty string ||| str	count=1
arg	given a database [arg_1] [arg_2] ||| [arg_1] spec [arg_2]	count=6
function	for ||| assert	count=1
module	a channel to ||| async	count=1
arg	etc or a ||| or	count=1
arg	[arg_1] on ||| [arg_2] [arg_1]	count=3
function	of the aliases for ||| ns aliases	count=1
arg	the ||| &amp; kontracts	count=1
arg	nothing which defaults ||| m nothing which	count=1
function	checking print the ||| print env	count=1
arg	that [arg_2] ||| [arg_2] [arg_1]	count=2
function	default options from ||| default options	count=1
function	exhausted ||| run*	count=1
arg	[arg_1] f and ||| [arg_2] [arg_1]	count=3
arg	takes an expression and ||| expr &amp; clauses	count=2
function	sequence of file paths ||| loader	count=1
module	uniform distribution ||| data generators	count=1
arg	f ||| f	count=17
arg	[arg_1] op ||| [arg_2] &amp; args [arg_1]	count=1
function_arg	all other [arg_2] ||| [arg_2] [function_1]	count=1
arg	of x and ||| x	count=4
arg	x ||| x &amp;	count=1
arg	custom comparator ||| comparator	count=2
arg	collection test ||| key end test end key	count=2
arg	sets the error-mode of ||| mode	count=1
arg	of prob 0 0 ||| prob	count=1
function	a quoted form and ||| check form info	count=1
function_arg	case [arg_2] ||| [function_1] [arg_2]	count=2
arg	test s one of ||| test start key end test end key	count=2
function_arg	[function_1] vals ||| [function_1] keys [arg_2]	count=1
function	closure ||| closure	count=1
function	unification bindings between ||| make occurs	count=1
module	[module] a ||| core [module]	count=1
arg	channels the ||| f buf or n	count=1
rep	[module_1] local taking ||| [module_1] map [function_arg_2]	count=2
arg	of the ||| &amp; args	count=1
arg	format fmt result ||| fmt	count=1
module	given a replacement string ||| string	count=1
arg	compiler when it ||| doc string? attr map? params* body + attr	count=1
function_arg	non-nil results [arg_2] ||| [function_1] [arg_2]	count=3
arg	pow ||| pow	count=1
function_arg	rational value [arg_2] ||| [function_1] [arg_2]	count=1
arg	of atom [arg_2] ||| [arg_1] [arg_2]	count=1
arg	monad operations and ||| m plus operations	count=1
arg	the resulting function name ||| name	count=1
arg	namespace ns ||| ns	count=2
arg	[arg_1] [arg_2] l exactly one time ||| [arg_2] [arg_1]	count=4
function	quoted form and ||| check form	count=1
module	channel from ||| async	count=1
arg	f its-current-meta args ||| args	count=1
function	form ||| form	count=3
arg	supplied [arg_2] ||| [arg_2] [arg_1]	count=2
arg	relationship ||| h	count=2
function	recursive bindings ||| flatten bindings	count=1
module	from ||| classpath	count=1
arg	single response-seq being read ||| response timeout	count=1
function	file ||| loader	count=1
function	collection of scalar ||| collection	count=1
function	for nested ||| zip	count=1
arg	and installs a new ||| val &amp; fn tail	count=1
function	sin ||| sin	count=1
arg	coerces [arg_2] ||| [arg_2] [arg_1]	count=3
module	type level ||| typed	count=3
arg	success continuation and a ||| w success	count=1
arg	with java class javat ||| into	count=1
arg	response-seq ||| response timeout	count=1
arg	then evaluates func ||| sql string &amp; params func	count=1
function_arg	[function_1] multimethod associated ||| [function_1] [arg_2]	count=3
module	a source channel and ||| core async	count=1
arg	of two channels the ||| t buf or n f buf or n	count=1
arg	associates a ||| k	count=1
arg	keyval = > ||| keyvals	count=3
arg	[arg_1] and name ||| [arg_1] [arg_2]	count=2
function	query ||| db query	count=1
arg	converts x to ||| x &amp; options	count=2
module	until completed [module] not ||| [module]	count=1
arg	message only ||| throwable message	count=1
arg	port passing to fn1 ||| port fn1	count=1
arg	at most [arg_2] ||| [arg_1] [arg_2]	count=3
arg	the object [arg] to the ||| &amp; [arg]	count=1
function	mapped to ||| zipmap	count=1
function	unmunged string ||| stack element str	count=2
arg	two channels ||| buf or n f buf or	count=1
arg	factory function for class ||| declaring class parameter types exception types	count=1
arg	collections such that z ||| z	count=1
arg	to expr ||| expr	count=1
arg	checking the ||| &amp; opt	count=2
function	bound-fn was called ||| bound fn	count=1
arg	the file they ||| f &amp; more	count=1
arg	two channels the first ||| t buf or n f buf or n	count=1
arg	if nums are in ||| x y &amp; more	count=3
arg	type syntax ||| type provided?	count=1
arg	the value is the ||| value	count=1
function	of one element in ||| element	count=1
module	sequence of ||| java	count=1
arg	of the atom ||| atom	count=1
arg	of the file ||| f &amp; more	count=1
function	[function_1] methods ||| [function_2] [function_1]	count=2
function	keyed by the result ||| group by	count=1
arg	the base ||| base which	count=1
arg	to filters ||| &amp; filters	count=1
module	that the goal ||| core logic	count=1
arg	topic ||| p topic	count=2
function	database connection [function] there ||| db [function]	count=1
arg	supplied collection ||| coll ch	count=2
module	expr [module] throws an ||| [module]	count=1
function	the error-mode ||| error mode	count=1
arg	in [arg] given ||| [arg]	count=1
module	distribution of low ||| data	count=1
arg	runs body in ||| &amp; body	count=1
function	unmunged string ||| str	count=2
arg	the element of coll ||| coll	count=1
arg	expands ||| kw args? name docstring? attr map?	count=1
function	to read ||| read	count=3
module	to this and ||| core	count=1
module	the return ||| algo	count=1
arg	and installs a ||| val &amp; fn tail	count=1
function	[function] classname ||| [function]	count=3
module	sequence of file ||| classpath	count=1
function	possibly ||| str	count=2
arg	of atom [arg_2] ||| [arg_2] [arg_1]	count=1
function	name string of a ||| name	count=1
arg	mexpr ||| mexpr	count=1
arg	with custom comparator and ||| comparator &amp;	count=1
arg	executes sql commands on ||| db spec transaction? sql command &amp; sql commands	count=1
arg	by s ||| s	count=1
arg	two channels ||| n f buf or	count=1
module	and supplies them to ||| core async	count=1
function	division of ||| divide	count=1
function	prints the current substitution ||| trace s	count=1
function	stop ||| stopper	count=1
function_arg	[function_1] mappings ||| [arg_2] [function_1]	count=6
arg	[arg_1] coll ||| [arg_2] [arg_1]	count=2
arg	/ child relationship ||| h	count=2
function_arg	[function_1] keyfn ||| [arg_2] [function_1]	count=1
function	wildcards ||| wildcards	count=2
function	rint ||| rint	count=1
arg	of a form ||| form	count=1
function_arg	non-namespaced symbol [arg_2] ||| [arg_2] [function_1]	count=1
function	a zipper for ||| seq zip	count=1
arg	of named ||| name	count=1
arg	for class ||| class parameter types exception	count=1
function	using the supplied ||| by	count=4
module	return type ||| core typed	count=1
rep	new collection [function_arg_2] ||| [module_1] [function_arg_2]	count=4
arg	the ||| x y &amp;	count=2
function_arg	methods [arg_2] ||| [arg_2] [function_1]	count=1
module	uuid based on ||| generators	count=1
arg	a persistent ||| t	count=5
function_arg	[function_1] s ||| [function_1] [arg_2]	count=6
arg	sc must be a ||| sc start test start key end	count=2
function	initial cause of an ||| cause	count=2
function	same [function] all at ||| extend [function]	count=1
arg	and method sigs ||| sigs	count=1
module	object ||| fressian	count=1
function	as the left sibling ||| left	count=1
function_arg	zero-type [arg_2] ||| [function_1] [arg_2]	count=2
function	is a tagged ||| tagged	count=1
arg	[arg] to infinity ||| start [arg]	count=3
function	declaration ||| decl	count=1
arg	is a ||| not	count=1
function	expose a ||| create	count=1
arg	more interfaces ||| bases	count=1
function	[function_1] in the ||| [function_1] [function_2]	count=3
function	all of the ||| all	count=1
module	return type of ||| typed	count=1
arg	values in aseq ||| aseq	count=1
arg	channels the ||| or n f buf or	count=1
arg	etc or a ||| buf or	count=1
function	and high parts ||| uuid	count=1
function	substitute ||| subst	count=1
function	[function_1] dispatch ||| [function_1] [function_2] function	count=1
arg	either maps representing rows ||| :transaction? true :entities identity	count=1
arg	logs a message ||| level throwable message	count=1
arg	in ||| &amp;	count=6
arg	port passing [arg_2] ||| [arg_2] [arg_1]	count=1
arg	[arg_1] table ||| [arg_2] [arg_1]	count=1
function	process the ||| process	count=1
module	unmunged string ||| main	count=1
function_arg	[function_1] of a ||| [function_1] [arg_2]	count=4
function	a possibly ||| stack element	count=2
function	nested ||| seq	count=1
function	case 2: ||| case	count=1
arg	of the ||| f &amp; more	count=1
function	in the ||| in	count=2
arg	jar file and ||| jarfile entry name	count=1
function	containing the contents ||| to	count=2
arg	channels ||| buf or n	count=1
function	set with supplied ||| set	count=1
arg	positional factory function for ||| _meta	count=4
function	set with ||| set	count=6
function	a list begun with ||| end list	count=1
function	proxy method ||| proxy	count=1
arg	if nums ||| more	count=1
arg	message ||| throwable message	count=1
module	returns a new collection ||| generic collection	count=2
function	bindings in ||| flatten bindings	count=1
arg	normal arguments [arg_2] ||| [arg_2] [arg_1]	count=5
module	given a ||| zip	count=1
arg	to a topic ||| p topic ch close?	count=1
function	declaration from ||| decl from	count=1
module	low ||| data	count=1
arg	the gnu ||| option specs &amp; options	count=1
arg	func ||| &amp; params func	count=1
arg	java interface with the ||| &amp;	count=1
function	list begun ||| list	count=1
function	reader [function_2] ||| core [function_1] [function_2]	count=1
arg	n ||| n bindings &amp;	count=1
function	key ||| key	count=1
function	quoted form ||| check form	count=1
arg	heterogeneous vectors ||| fixed* type	count=1
function	asserts with a ||| assert with message	count=1
arg	test s one ||| start key end test	count=2
arg	with ||| &amp;	count=5
module	attempts to ||| unify	count=1
function_arg	[function_1] x by ||| [arg_2] [function_1]	count=4
module	output channel ||| core async	count=1
arg	step where [arg] defaults ||| [arg] end	count=1
module	string ||| string	count=8
arg	current bindings of the ||| &amp;	count=1
function_arg	record [arg_2] ||| [arg_2] [function_1]	count=2
module	and returns an atom ||| core	count=1
module	state-monad function that assumes ||| monads	count=1
function_arg	const [arg_2] ||| [arg_2] [function_1]	count=2
function	set the ||| set	count=1
arg	and the ||| &amp; options	count=1
function	the first item ||| first	count=1
arg	the metadata for ||| &amp;	count=1
arg	construct ||| form splicing?	count=1
function	a tagged ||| tagged	count=3
arg	of l ||| l a	count=1
function	to the set ||| map	count=1
arg	the value at the ||| found	count=1
function	returns a possibly ||| element	count=2
arg	response-seq being ||| response timeout	count=1
arg	[arg_1] replacement ||| [arg_2] [arg_1]	count=4
arg	the given strings ||| &amp;	count=1
arg	a val from port ||| port	count=3
arg	rsubseq for test ||| test	count=1
arg	functions and returns a ||| g h &amp; fs	count=1
function	groups from the ||| re groups	count=1
module	nested sequences given ||| zip	count=1
arg	checks the form ||| form	count=1
arg	with java class ||| into	count=1
arg	inclusive and [arg] default ||| [arg]	count=1
function	returns the transitive ||| transitive	count=1
arg	clojure form ||| form env opts	count=1
arg	[arg] a possibly ||| [arg]	count=1
function	wildcards then matching ||| wildcards	count=1
function_arg	annotate datatype [arg_2] ||| [function_1] [arg_2]	count=2
module	a new collection ||| generic collection	count=2
function	long[] ||| longs	count=1
function	inserts ||| insert	count=1
function	version as a printable ||| version	count=1
function	allow asserts with ||| with message	count=1
module	unmunged string representation of ||| repl	count=1
module	paths ||| java classpath	count=2
arg	character on stream s ||| s	count=1
arg	in coll where ||| coll	count=1
function	a ||| loader classpath	count=2
arg	channels the first of ||| n f buf or	count=1
arg	function for class ||| declaring class	count=2
arg	[arg_1] [arg_2] ||| [arg_2] size offset rest? [arg_1]	count=2
arg	at the ||| &amp;	count=1
arg	factory function for class ||| declaring class parameter types	count=1
function	ns ||| file ns	count=1
arg	test s one ||| test end key	count=2
arg	input [arg_2] ||| [arg_2] [arg_1]	count=1
arg	yl ||| yl	count=1
arg	a stacktraceelement ||| el	count=2
function	coerce to int ||| int	count=1
function	thread-local bindings [function_2] ||| [function_2] [function_1]	count=2
arg	compiler when ||| doc string? attr map? params* body +	count=1
function	outputstream ||| output stream	count=1
arg	the symbol [arg] into a ||| [arg]	count=1
function	bitwise [function_2] ||| [function_1] [function_2]	count=4
arg	and the ||| args option specs &amp; options	count=1
function	[function_1] options ||| [function_2] [function_1]	count=4
function	lazy seq of messages ||| seq	count=1
function	the form ||| form	count=1
arg	[arg_1] active ||| [arg_2] [arg_1]	count=6
function	waiting stream ||| waiting stream check	count=1
arg	f ||| f val	count=1
arg	is constituted ||| rows ocrs	count=1
arg	object subject to ||| object	count=1
function	an array with ||| int array	count=1
function	returns [function_1] [function_2] ||| [function_2] [function_1] coll	count=2
arg	func passing in ||| map sql string &amp; params func	count=1
arg	value is the data ||| value	count=1
arg	returns true [arg_1] [arg_2] provided as arguments have ||| core bound? [arg_1] [arg_2]	count=1
arg	the vals in kmap ||| kmap	count=2
function_arg	negation [arg_2] ||| [function_1] [arg_2]	count=2
arg	topic of a ||| topic ch	count=1
function	sequence of file ||| loader classpath	count=1
arg	[arg_1] the value ||| [arg_1] index [arg_2]	count=1
arg	expected type syntax ||| type provided?	count=1
arg	step to [arg_2] ||| core range [arg_2] [arg_1]	count=2
arg	goals until a maximum ||| goals	count=1
arg	env [arg_2] ||| [arg_1] [arg_2]	count=1
arg	keys using ||| &amp; keys	count=2
arg	[arg_1] at end ||| [arg_2] [arg_1]	count=1
function_arg	ceil of [arg_2] ||| [function_1] [arg_2]	count=1
rep	... [function_arg_2] ||| [module_1] [function_arg_2]	count=1
function	returns a possibly ||| stack	count=2
function_arg	[function_1] of tag ||| [function_1] h [arg_2]	count=7
function	should default to -parse ||| parse	count=1
function_arg	[function_1] the ||| [arg_2] [function_1]	count=2
function	shift [function_2] ||| [function_1] [function_2]	count=2
function	value in ||| get in	count=1
arg	multimethod ||| multifn	count=4
function	a committed choice ||| defnu	count=1
arg	[arg] names args ||| [arg] and interfaces args	count=3
module	a uuid based on ||| data	count=1
function	[function_1] booleans ||| [function_2] [function_1]	count=2
rep	annotate [function_arg_2] ||| [module_1] [function_arg_2]	count=4
arg	creates and installs a ||| dispatch val &amp; fn tail	count=1
module	[module] loc and ||| [module]	count=3
function	/ let ||| let	count=1
function_arg	[function_1] keys ||| [function_1] by comparator [arg_2]	count=6
function	tagged literal ||| tagged literal?	count=1
function	returns a possibly ||| stack element	count=2
function	version of loop ||| print length loop	count=1
function	declarations in ||| find	count=1
arg	vals in kmap ||| kmap	count=2
arg	a proxy instance ||| proxy	count=1
arg	args [arg_2] ||| [arg_2] [arg_1]	count=1
arg	method of multimethod ||| multifn dispatch val	count=1
arg	[arg_1] the form ||| [arg_2] [arg_1]	count=2
module	unmunged ||| main	count=1
function	an int ||| int	count=1
rep	[module_1] [function_arg_2] ||| [module_1] priority [function_arg_2]	count=5
function	for ||| zip	count=1
arg	[arg_1] table ||| [arg_1] spec [arg_2]	count=1
arg	annotations ||| seq exprs &amp; maybe ann body	count=1
function	with mean 1 / ||| geometric	count=1
module	macros that are used ||| tools macro	count=1
function	[function_1] chars ||| [function_2] [function_1]	count=2
arg	same ground if possible ||| variable? binds	count=1
function	of the aliases for ||| aliases	count=1
arg	f index item ||| f coll	count=1
function_arg	future f ||| future cancelled? f	count=1
arg	mappings ||| &amp; keyvals	count=2
function	unmunged string representation of ||| stack element	count=2
function	literal ||| literal?	count=1
arg	factory function for class ||| type declaring class	count=2
function	ddl string for creating ||| ddl	count=1
function	returns ||| element	count=2
arg	object of the ||| &amp;	count=1
arg	and an optional exception-handler ||| n xform ex handler	count=1
module	[module] field taking ||| [module]	count=3
arg	custom comparator and optional ||| comparator	count=2
module	logic variables ||| core logic	count=1
arg	the same type and ||| &amp;	count=1
function	string representation of a ||| element	count=2
module	algo generic [module_2] ||| [module_1] [module_2]	count=8
function	from a ||| loader	count=1
function_arg	define a [function_1] [arg_2] ||| [function_1] [arg_2]	count=3
arg	m-result ||| m expr	count=1
function	returns a zipper ||| zip	count=1
module	ast ||| tools analyzer passes jvm validate-loop-locals	count=2
arg	tag through a ||| tag	count=1
arg	vector of two channels ||| f buf or	count=1
function	bound ||| with	count=3
function	loop and ||| loop	count=1
arg	checks the form ||| form expected	count=1
arg	positional factory function ||| op	count=1
module	javadoc ||| java javadoc	count=1
function_arg	constructor taking ||| &gt;constructor m#	count=1
module	paths from ||| classpath	count=1
arg	function of the ||| f	count=1
function	a snapshot of a ||| snapshot	count=1
module	ast ||| analyzer passes jvm	count=3
function_arg	[function_1] multimethod ||| [arg_2] [function_1]	count=8
module	and passed ||| core	count=1
function	searches recursively under ||| clojure sources	count=1
arg	expr evaluates ||| expr	count=1
arg	func ||| func	count=1
arg	f ||| f val coll	count=1
arg	topic ||| topic ch close?	count=1
arg	rs ||| rs	count=1
arg	positional factory function for ||| op form	count=1
function	defn ||| defn	count=1
module	string or char ||| string	count=2
module	[module] g succeeds ||| [module]	count=1
function	read a [function_2] ||| [function_2] [function_1]	count=2
function_arg	least [arg_2] ||| [arg_2] [function_1]	count=2
function	the juxtaposition of those ||| juxt	count=1
function	lazy seq ||| seq	count=1
function	of local [function_2] ||| [function_2] [function_1]	count=1
function_arg	[function_1] item ||| [arg_2] [function_1]	count=1
function	contents ||| vec	count=1
function	in a nested ||| in	count=1
function	[function] object ||| [function]	count=3
arg	sql and ||| sql	count=1
function	supplied ||| keyfn by	count=1
arg	is ||| not	count=1
arg	in which the base ||| m which	count=1
arg	given vector [arg] ||| [arg] start	count=3
function_arg	and [arg_2] ||| [function_1] x [arg_2]	count=1
function	[function_1] chosen ||| [function_1] [function_2]	count=3
function	without sign-extension ||| unsigned	count=1
function_arg	var [arg_2] ||| [function_1] root [arg_2]	count=1
function	java [function] ||| [function]	count=1
function	an array of objects ||| array	count=1
arg	with custom comparator and ||| comparator	count=1
module	the [module_1] [module_2] ||| [module_1] [module_2]	count=6
arg	channels the first of ||| buf or n	count=1
arg	mult ||| mult ch close?	count=1
arg	to be: apply f ||| f	count=1
function	possibly cached value ||| force	count=1
function	java util enumeration ||| enumeration	count=1
arg	repeatedly apply fun to ||| fun	count=1
arg	items in coll where ||| coll	count=1
arg	of two channels ||| or n f buf or	count=1
arg	asynchronously puts [arg_2] ||| core async put! port [arg_2] fn1 [arg_1]	count=1
function_arg	constructor [arg_2] ||| [function_1] [arg_2]	count=2
function	possibly unmunged ||| stack	count=2
function	the max-history of ||| max history	count=1
arg	or stringable thing ||| or	count=1
function	given a ||| zip	count=1
function	of loop ||| print length loop	count=1
module	source channel ||| core async	count=1
module	new collection in which ||| generic collection	count=1
rep	return the [function_arg_2] ||| [module_1] [function_arg_2]	count=16
function	returns a snapshot ||| snapshot	count=1
function	[function_1] [function_2] function to a function ||| [function_1] [function_2] function	count=1
function_arg	conjoined [arg_2] ||| [function_1] [arg_2]	count=1
arg	row [arg] ||| [arg]	count=1
arg	ctor ||| ctor	count=1
function_arg	between [arg_2] ||| [function_1] h [arg_2]	count=1
function_arg	while pred item ||| take while pred	count=1
module	channel with ||| async	count=1
arg	set of functions ||| h &amp; fs	count=1
function	seq of values ||| values	count=1
module	of low and ||| data generators	count=1
function	of file paths ||| classpath	count=1
arg	transducer [arg_2] ||| [arg_2] [arg_1]	count=1
function	as json ||| write json	count=1
arg	cache ||| cache item	count=1
function	classpath ||| classpath	count=1
module	and returns the result ||| core	count=1
function	composition of those ||| comp	count=1
arg	of ks ||| ks	count=1
function	[function_1] set ||| [function_2] [function_1]	count=3
arg	channels the first of ||| t buf or n f buf or n	count=1
function	default options from ||| get default options	count=2
function	classloader ||| loader classpath	count=1
module	single item of json ||| json	count=1
function_arg	acos of [arg_2] ||| [function_1] [arg_2]	count=1
function	reader [function_2] ||| [function_2] [function_1]	count=1
arg	given fntail ||| fntail	count=1
function_arg	[function_1] named by ||| [function_1] [arg_2]	count=7
arg	the gnu program argument ||| specs &amp; options	count=1
arg	evaluates expr ||| expr	count=1
arg	of lists of n ||| n	count=1
function	[function_1] with ||| [function_2] [function_1]	count=2
function	bitwise shift left ||| bit shift left	count=3
arg	vector [arg] ||| [arg] start	count=3
arg	value of x ||| x	count=2
arg	java array [arg_2] ||| into array&gt; [arg_2] [arg_1] syn javat cljt coll	count=4
function_arg	the supplied comparator ||| by comparator &amp;	count=4
arg	[arg_1] [arg_2] ||| [arg_2] y [arg_1]	count=4
function	all but ||| drop	count=1
function_arg	[function_1] with loc ||| [function_1] [arg_2]	count=4
arg	executes sql commands on ||| db spec transaction? sql command &amp;	count=1
arg	name is ||| name	count=1
function	return last index ||| last	count=1
arg	evaluates the form ||| form	count=1
module	supplied channel ||| core async	count=1
arg	set of functions and ||| g h &amp; fs	count=1
module	macro expansion of a ||| tools macro	count=1
module	type of ||| typed	count=1
arg	to the given keys ||| keys	count=1
arg	vector of two channels ||| t buf or n f buf or	count=1
function_arg	const taking a ||| &gt;const m#	count=1
module	json [module_2] ||| [module_1] [module_2]	count=3
arg	symbol ||| symbol	count=1
function_arg	maybeclass taking a ||| &gt;maybeclass m#	count=1
function_arg	define a monad [function_1] [arg_2] ||| algo monads monad [function_1] base [arg_2]	count=3
function	reads a single item ||| read	count=1
arg	collection test ||| end test end	count=2
function	[function_1] shift left ||| [function_2] [function_1]	count=1
arg	of the ||| &amp;	count=11
function	sets the components ||| sets	count=1
function	lazy sequence of ||| seq	count=1
module	that [module_2] ||| [module_1] [module_2]	count=4
arg	of ns ||| ns sym	count=1
arg	name to that result ||| name &amp;	count=1
arg	set of functions and ||| g &amp; fs	count=1
module	possibly unmunged string representation ||| repl	count=1
arg	child relationship ||| h	count=2
arg	a possibly polymorphic ||| varsym	count=1
arg	[arg_1] is x ||| [arg_2] [arg_1]	count=4
function_arg	next [arg_2] ||| [function_1] [arg_2]	count=4
function	a ns ||| ns	count=4
arg	a monad in which ||| m which	count=1
arg	returns a pattern ||| pattern	count=1
arg	of f ||| f	count=3
module	[module] the result ||| [module]	count=1
arg	array with java class ||| into array	count=1
function_arg	rint of [arg_2] ||| [function_1] [arg_2]	count=1
arg	[arg_1] in ||| [arg_2] [arg_1]	count=11
module	sequence ||| java	count=1
function	new sorted ||| sorted	count=2
function	a value in a ||| assoc in	count=1
arg	for class clojure ||| class field	count=1
function	declaration from the ||| decl from jarfile	count=1
function	and [function] ||| [function]	count=3
module	vector containing ||| rrb-vector	count=1
arg	collection test s one ||| end test end	count=2
arg	sigs ||| sigs	count=1
module	returns a ||| java	count=1
function	max-history of a ref ||| max history	count=1
module	else return ||| algo monads	count=1
arg	collection test s one ||| key end test	count=2
arg	a topic ||| topic ch close?	count=1
function	a quoted form and ||| check form	count=1
arg	string [arg_2] ||| [arg_2] [arg_1]	count=1
arg	sc must ||| sc start test start	count=2
function	of the given client-side ||| client	count=1
arg	to writer ||| writer	count=1
function_arg	[function_1] taking a ||| [function_1] [arg_2]	count=11
module	the type environment ||| core typed	count=1
arg	value at ||| not found	count=1
arg	converts x [arg_2] ||| [arg_1] [arg_2]	count=2
function	string representation of a ||| element str	count=2
arg	executes body presumably for ||| body	count=1
arg	annotations ||| seq exprs &amp; maybe ann	count=1
arg	[arg_1] class clojure ||| [arg_2] size offset rest? [arg_1]	count=1
arg	test in ||| coll test x	count=2
arg	writer ||| writer data &amp; options	count=1
arg	the file they represent ||| f &amp; more	count=1
arg	coll which can ||| coll	count=1
function	computes the [function] ||| [function]	count=3
arg	of multimethod associated ||| multifn dispatch	count=2
module	type representing a range ||| typed	count=1
function	keyed by the ||| group by	count=2
arg	compiler when it is ||| doc string? attr map? params* body +	count=1
arg	multimethod name in ||| name &amp; args	count=2
function	extracts metadata ||| metadata	count=1
arg	f to its ||| f	count=1
arg	vector of two channels ||| t buf or n f buf or n	count=1
arg	of x by y ||| x y	count=2
arg	true if [arg] names a ||| [arg]	count=1
function	bindings pushed ||| bindings	count=1
arg	non-nil [arg] monotonically ||| [arg]	count=2
arg	pred item returns true ||| pred	count=1
module	and is ||| core	count=1
arg	sorted collection test ||| test start key end test end	count=2
arg	evaluates func passing in ||| sql string &amp; params func	count=1
module	test ||| test	count=5
arg	installs a new ||| &amp; fn tail	count=1
arg	corresponding parameters ||| params	count=1
arg	[arg_1] [arg_2] a ||| [arg_1] [arg_2]	count=8
module	core [module_2] ||| [module_1] [module_2]	count=12
arg	the normal arguments ||| more	count=1
function	protocol ||| protocol	count=2
arg	then evaluates func ||| params func	count=1
function	the negation ||| negate	count=1
module	returns a [module] which ||| core [module]	count=1
arg	returns true if [arg_1] [arg_2] provided as arguments have ||| [arg_1] [arg_2]	count=1
arg	a multimethod ||| multifn	count=1
function	[function_1] floats ||| [function_2] [function_1]	count=2
module	uuid based on uniform ||| generators	count=1
function	[function_1] in ||| [function_1] [function_2]	count=3
function	expose a reference ||| create	count=1
function	shift right ||| shift right	count=2
function	a set ||| set	count=1
arg	channels the ||| buf or n f buf or	count=1
arg	function name ||| name	count=1
arg	at end defaults to ||| end	count=1
function	removes [function_2] ||| [function_1] [function_2]	count=9
function	all namespaces ||| all ns	count=1
arg	and the gnu program ||| &amp; options	count=1
function	declaration from the named ||| decl from jarfile entry	count=1
function	sorted map with ||| sorted map	count=1
arg	of exprs ||| exprs	count=1
arg	by the given fntail ||| fntail	count=1
arg	then binds name ||| name	count=1
module	exhausted ||| core logic	count=1
arg	in a transaction ||| &amp; args	count=2
arg	two channels the first ||| buf or n f buf or n	count=1
module	paths ||| java	count=1
arg	success continuation and ||| success	count=1
arg	creates and installs ||| fn tail	count=1
arg	with custom comparator ||| comparator &amp;	count=1
arg	the given fntail ||| fntail	count=1
arg	permutation [arg] ||| [arg]	count=1
arg	while executing [arg] ||| bindings [arg]	count=1
arg	class ||| type declaring class flags	count=1
function	that ||| call	count=1
arg	a number of types ||| &amp; types	count=2
arg	converts x ||| x	count=2
arg	then evaluates func passing ||| map sql string &amp; params func	count=1
arg	replaces [arg_1] [arg_2] in ||| string replace [arg_1] [arg_2]	count=2
function	between ||| underive	count=1
arg	form ||| form &amp; more	count=1
arg	of functions ||| f g h &amp; fs	count=1
function	all of ||| all	count=1
arg	agent state ||| new state	count=1
arg	the mult ||| mult ch	count=1
arg	checks the form ||| form expected type	count=1
arg	test s ||| test end key	count=2
arg	expression ||| expr &amp;	count=1
arg	loc left-to-right ||| loc	count=1
arg	in s ||| s	count=2
arg	is ||| not found	count=1
arg	executing [arg] ||| bindings [arg]	count=1
function	of file ||| loader	count=1
module	[module_1] true ||| [module_1] [module_2]	count=2
arg	[arg_1] in coll ||| [arg_2] [arg_1]	count=8
function	is [function] than the ||| [function]	count=1
module	string on a ||| string	count=1
function	a [function] conditional ||| [function]	count=1
arg	given a multimethod ||| multifn	count=1
function_arg	[function_1] success ||| [function_1] [arg_2]	count=4
function	gets the max-history ||| max history	count=1
module	on uniform distribution ||| data generators	count=1
function	[function_1] column ||| [function_2] [function_1]	count=1
module	ast when ||| tools analyzer passes	count=1
function_arg	trace of tr ||| trace tr n	count=2
arg	[arg] a ||| xform [arg]	count=1
function	removes a [function_2] ||| [function_1] [function_2]	count=1
function	[function_1] trace ||| [function_1] [function_2]	count=1
arg	out as ||| out	count=1
function	extend ||| extend	count=1
arg	body [arg_2] ||| out [arg_2] [arg_1]	count=1
function	[function_1] shorts ||| [function_2] [function_1]	count=2
arg	to an ||| &amp; args	count=2
arg	tr a throwable ||| tr	count=1
function	quoted form and ||| check form info	count=1
arg	resulting function name is ||| name	count=1
function_arg	[function_1] f and ||| [function_1] [arg_2]	count=1
function	loop that iterates at ||| length loop	count=1
arg	returns [arg_2] ||| [arg_1] index [arg_2]	count=3
function	are exhausted ||| run*	count=1
arg	collection test s ||| start key end test	count=2
function	and optional supplied ||| by	count=2
arg	establishes a [arg] between ||| [arg] tag	count=1
module	sequences given ||| zip	count=1
arg	tag either ||| tag	count=1
arg	[arg_1] given name ||| [arg_2] [arg_1]	count=6
arg	body in the context ||| &amp; body	count=1
function	core / delay force ||| delay	count=1
function	current value of *out* ||| pr	count=1
module	returns a ||| java classpath	count=1
function_arg	[function_1] by val ||| [arg_2] [function_1]	count=1
arg	sorted collection test ||| start key end test end	count=2
module	for class clojure core ||| core	count=7
arg	z ||| z	count=1
function	hash code ||| hash	count=1
arg	custom keyfn custom comparator ||| keyfn comparator	count=1
arg	new multimethod with the ||| &amp;	count=1
function	the non-directory entries in ||| filenames in	count=1
function	an assoc operation ||| assoc	count=1
function	the form represented by ||| form	count=1
arg	of prob 0 ||| prob	count=1
arg	the value of ||| &amp;	count=1
arg	[arg_1] or ||| [arg_2] [arg_1]	count=8
arg	success continuation [arg_2] ||| [arg_1] [arg_2]	count=1
function	hierarchical ||| tree	count=1
arg	arguments as [arg] has the ||| [arg]	count=1
arg	at most n ||| buf or n	count=2
function	paths from ||| loader	count=1
arg	port passing [arg_2] ||| [arg_1] [arg_2]	count=1
function	sequence ||| loader	count=1
arg	and name if one ||| name	count=1
arg	and end ||| end	count=2
function	a [function] ||| the [function]	count=2
arg	d if d ||| d	count=1
module	[module_1] [module_2] ||| [module_1] [module_2]	count=188
module	returns ||| classpath	count=1
arg	of named methods and ||| name	count=1
function	opens a reader on ||| slurp	count=1
arg	test s one ||| test start key end test end key	count=2
arg	writes data to writer ||| writer data	count=1
arg	true if ||| x y	count=1
arg	test s one of ||| end test end key	count=2
function	a do ||| do	count=1
arg	given a database [arg_1] [arg_2] parameters perform ||| [arg_1] [arg_2]	count=1
arg	an expression and a ||| expr &amp; clauses	count=2
arg	[arg_1] namespace ns ||| [arg_2] name [arg_1]	count=1
arg	child parent) or child ||| child	count=1
module	and type checks ||| core typed	count=1
function	loop that ||| loop	count=1
function	returns a possibly unmunged ||| stack element str	count=2
function_arg	write [arg_2] ||| [function_1] [arg_2]	count=3
function_arg	[function_1] tag through ||| [arg_2] [function_1]	count=2
arg	contents [arg] closing when ||| [arg]	count=1
arg	instantiate a call to ||| inst of	count=1
arg	from port passing ||| port	count=1
arg	keys using the ||| keys	count=2
function	error-mode of ||| error mode	count=1
arg	location loc ||| loc	count=1
arg	named by the symbol ||| sym	count=1
function	mismatched loop-local ||| locals	count=1
function	the value in ||| get in	count=1
arg	installs a new method ||| dispatch val &amp; fn tail	count=1
arg	returns a function ||| f	count=1
function	[function_1] conditional ||| [function_2] [function_1]	count=1
function	read ||| read file	count=1
arg	[arg_1] apply f ||| [arg_2] [arg_1]	count=2
arg	for class ||| class op form	count=1
function	non-directory entries ||| filenames	count=1
arg	fun to ||| fun max	count=1
arg	with key ||| key	count=1
function	analyze and an ||| analyze	count=1
arg	and installs a ||| dispatch val &amp; fn tail	count=1
module	waiting ||| core logic	count=1
arg	is a sequence of ||| not	count=1
arg	etc or a composition ||| buf or	count=1
arg	multimethod ||| multifn dispatch val &amp;	count=1
arg	the jar file and ||| jarfile	count=1
arg	x by [arg_2] ||| [arg_2] [arg_1]	count=2
function	is a collection such ||| resto	count=1
function	acos of ||| acos	count=1
arg	the rel [arg_2] ||| [arg_1] [arg_2]	count=1
arg	the ||| &amp; more	count=2
function	a [function] entry ||| [function]	count=1
function	in ||| in jar	count=3
module	channel will be ||| async	count=1
arg	val into port ||| port val	count=2
arg	for class clojure ||| class op form env extmap	count=1
function	flattens recursive bindings in ||| flatten bindings	count=1
arg	collection test s one ||| start key end test	count=2
arg	atomically swaps the ||| &amp;	count=1
module	and ||| data generators	count=1
arg	class clojure ||| class field	count=1
arg	ref ||| ref	count=2
arg	clojure form ||| form env	count=1
arg	connection ||| db	count=2
arg	and the gnu program ||| option specs &amp; options	count=1
function	values are sequences ||| sequence	count=1
module	zipper ||| zip	count=1
module	a uuid ||| data generators	count=1
module	based on uniform ||| data generators	count=1
arg	[arg_1] val s ||| [arg_2] [arg_1]	count=2
arg	checking the form ||| form &amp; opt	count=2
function_arg	aliases for [arg_2] ||| [arg_2] [function_1]	count=1
function_arg	key of [arg_2] ||| [arg_2] [function_1]	count=1
arg	the context of ||| &amp;	count=1
arg	[arg_1] f ||| [arg_2] [arg_1]	count=5
function	one element [function_2] ||| [function_2] [function_1]	count=2
module	that a is ||| core logic	count=2
function	given a ||| seq zip	count=1
arg	specified length [arg_2] ||| [arg_2] [arg_1]	count=2
arg	true if ||| x	count=2
arg	analyzes a clojure form ||| form env opts	count=1
function	a list begun ||| list	count=1
arg	the first of l ||| l a	count=1
arg	functions ||| f g h &amp; fs	count=1
arg	collection test s one ||| start key end test end key	count=2
arg	a table name and ||| table	count=1
arg	[arg_1] into port ||| [arg_2] [arg_1]	count=6
function	definitions ||| name with attributes	count=1
function	of default ||| default	count=1
arg	initial [arg] ||| [arg]	count=1
function_arg	[function_1] comparator and ||| data priority-map priority [function_1] by [arg_2]	count=1
function	allow asserts with ||| assert with	count=1
arg	two channels the ||| buf or n f buf or n	count=1
arg	a set of functions ||| h &amp; fs	count=1
arg	if it is ||| x	count=1
function	namespace ||| ns	count=5
function	bindnode ||| &gt;bindnode	count=1
module	of type ||| typed	count=1
function	with [function_1] [function_2] function ||| [function_1] [function_2] function &amp;	count=1
function	vec with ||| vec	count=1
function	representation of ||| str	count=2
arg	length [arg_2] ||| [arg_2] [arg_1]	count=2
arg	loc without ||| loc	count=2
function_arg	method [arg_2] ||| [arg_2] [function_1]	count=3
function	array of ||| int array	count=1
arg	contents [arg] ||| [arg]	count=1
module	pretty printing ||| pprint	count=1
arg	the jar file ||| jarfile	count=1
rep	clojure-oriented [function_arg_2] ||| [module_1] print [function_arg_2]	count=3
arg	[arg_1] [arg_2] provided as arguments have ||| [arg_1] [arg_2]	count=1
arg	namespace / sa ||| syms &amp; opt	count=1
arg	with replacement ||| replacement	count=1
arg	of two channels ||| buf or n f buf or n	count=1
arg	defaults to 0 [arg_1] [arg_2] to infinity ||| [arg_2] [arg_1]	count=8
function_arg	appended to y ||| appendo x y	count=1
arg	executes ||| db bindings &amp;	count=2
function_arg	next loc ||| next loc	count=1
arg	for test in ||| coll test x	count=2
arg	two channels the ||| n f buf or	count=1
module	adds ||| java javadoc	count=1
module	based on uniform distribution ||| data generators	count=1
function	url object [function] per urlclassloader ||| [function]	count=1
arg	name is declared ||| name	count=1
function	sum of ||| +'	count=1
module	and y with the ||| core	count=2
arg	if [arg_2] ||| &gt;= [arg_1] [arg_2]	count=1
function	object [function] per urlclassloader ||| [function]	count=1
arg	[arg_1] custom comparator ||| [arg_1] [arg_2]	count=3
function	the result of ||| reduced?	count=1
function	the negation of ||| negate	count=1
function	the min-history of a ||| min history	count=1
function	class followed by ||| class	count=1
module	generic ||| generic	count=4
arg	from the input ||| input	count=1
arg	u [arg_2] ||| [arg_2] [arg_1]	count=1
arg	the [arg_2] ||| [arg_2] [arg_1]	count=14
arg	and the gnu program ||| args option specs &amp; options	count=1
arg	result of f ||| f	count=1
function_arg	for [arg_2] ||| [arg_2] [function_1]	count=1
arg	base ||| base which	count=1
arg	database [arg] ||| [arg] spec table row	count=1
function	annotate several vars with ||| ann many	count=1
module	string representation of a ||| repl	count=1
arg	to the corresponding vals ||| vals	count=1
module	return ||| algo monads	count=6
function	[function_1] javadoc paths ||| [function_1] [function_2]	count=5
arg	files ||| dir	count=1
arg	return at most ||| buf or	count=1
arg	coll which ||| coll	count=1
arg	f to its current ||| f	count=1
arg	regular expression or ||| or pattern	count=2
arg	threads it into ||| &amp; forms	count=1
function	type checking print ||| print env	count=1
function	the aliases for the ||| aliases	count=1
arg	binds name to that ||| name &amp; forms	count=1
function	data ||| data	count=1
function	in [function] block ||| [function]	count=1
function	doubles ||| double	count=1
arg	by the corresponding parameters ||| params	count=1
arg	annotations ||| exprs &amp; maybe ann body	count=1
arg	items ||| items	count=6
module	local [module] that ||| [module]	count=1
function	the ddl string for ||| ddl	count=1
arg	in the jar file ||| jarfile entry	count=1
function	the transitive ||| transitive	count=1
module	to tools analyzer ||| tools analyzer	count=1
function	of loop that iterates ||| loop	count=1
arg	a possibly polymorphic ||| varsym &amp; methods	count=1
function	load and ||| load	count=1
arg	asynchronously puts ||| on caller?	count=1
arg	ks ||| ks	count=2
function	array of ||| array	count=9
function	[function] a ||| enumeration [function]	count=3
arg	each of the specified ||| &amp; vs	count=1
function_arg	first item [arg_2] ||| [arg_2] [function_1]	count=1
arg	etc or a composition ||| or	count=1
arg	expr evaluates the first ||| expr	count=1
function	the min-history of ||| min history	count=1
function	in a stack trace ||| trace	count=1
function	an array ||| char array	count=1
function	flattens recursive bindings in ||| bindings	count=1
arg	factory function for class ||| class parameter types exception	count=1
function	conjugate of ||| conjugate	count=1
arg	value at the key ||| key	count=1
arg	colls is ||| colls	count=2
arg	sorted collection test ||| start test start key end test end	count=2
arg	test s one of ||| test start key end test	count=2
function	var coverage statistics to ||| var coverage	count=1
arg	printwriter out ||| out escape unicode?	count=1
arg	the value of the ||| &amp;	count=1
arg	supplied keys using ||| keys	count=1
arg	instantiate ||| inst of	count=1
arg	passes the given ||| &amp;	count=1
arg	value of f applied ||| f	count=1
arg	the [arg_2] ||| core bound? [arg_1] [arg_2]	count=1
arg	key by [arg_2] ||| [arg_1] [arg_2]	count=1
arg	[arg] returning ||| a idx ret [arg]	count=3
function	a snapshot of ||| snapshot	count=1
arg	body presumably for ||| body	count=1
function	key [function] ||| [function]	count=1
arg	compiler when it is ||| doc string? attr map? params* body + attr	count=1
function_arg	[function_1] of multimethod ||| [arg_2] [function_1]	count=8
function_arg	set with [arg_2] ||| [function_1] [arg_2]	count=1
module	for ||| zip	count=1
arg	[arg_1] with java ||| into array&gt; [arg_2] [arg_1] syn javat cljt coll	count=4
function_arg	let [arg_2] ||| [function_1] [arg_2]	count=1
