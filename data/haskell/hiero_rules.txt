args	value from the ||| a io	count=2
function	the same ||| bit	count=1
args	computation ||| io c	count=2
args	[args_1] structure to ||| [args_2] [args_1]	count=2
return	into the buffer ||| int buffer word8	count=1
function	source location of ||| src loc	count=1
function	an error ||| error	count=1
args	the either type ||| a c $f_2$ b c either a b	count=1
args	the given [args_2] ||| marshal array copy array [args_1] [args_2]	count=4
function	catch but it takes ||| catch	count=1
function	with a fresh ||| with pool	count=1
module	of the ||| data	count=13
args	a binary function to ||| $f_3$ a b c applicative a	count=1
module	allocate a fresh memory ||| foreign marshal pool	count=1
function	megabytes [function_2] ||| [function_2] [function_1]	count=3
args	the method showlist ||| show	count=1
return	argument arrow and ||| arrow $tuple_3$	count=1
function	to ||| to fun	count=1
function	is ex ||| try	count=1
args	passing any value produced ||| $f_2$ a monad	count=1
function	action with a ||| with	count=1
function	geterrno [function_2] ||| [function_2] [function_1]	count=5
args	a pointer to a ||| ptr storable io b	count=2
args	the mapmaybe function is ||| $f_2$ a maybe b	count=1
function	a list ||| list with	count=1
args	predicate and two ||| bool $list$ a $list$	count=1
module	and all ||| data	count=1
module	type-level ||| ghc typelits	count=1
function	allocation [function_2] ||| [function_2] [function_1]	count=7
module	parses p ||| text parsercombinators readprec	count=1
function	mapandunzipm function maps its ||| and unzip m	count=1
return	list into a circular ||| a	count=1
function	a duplicate of ||| h duplicate to	count=1
function	file using ||| binary file	count=1
return	just a ||| a	count=1
return	the io computation ||| io	count=2
function	type representation ||| type rep ty	count=4
args	a ||| c d e f g $list$ a	count=1
args	the given number of ||| int	count=5
function	hfilesize hdl returns the ||| h	count=1
function_return	[function_1] reads a ||| [function_1] [return_2]	count=2
function	to the corresponding ||| cast cschar to	count=1
module	error [module_2] ||| [module_2] [module_1]	count=1
args	promote a function ||| a4 a5 r monad a1 monad a2	count=1
args	value ||| a b b b $list$ a	count=2
args	applies ||| $list$ typerep	count=1
module	is a list ||| list	count=1
return	arrow and copy the ||| arrow $tuple_3$	count=1
args	the either type ||| c either	count=1
module	that an exception is ||| control exception	count=2
module	number of ||| data	count=2
function	read from ||| read stm	count=1
return	a staticptr ||| staticptr a	count=1
function	finalizer cf ||| finalizer	count=1
return	computation ||| io	count=23
function	char [function_2] ||| [function_2] [function_1]	count=1
args	value produced by the ||| a monad	count=2
args	where the second ||| ioerrortype	count=1
function	throwerrnoifretry but additionally if ||| if	count=1
module	storage ||| marshal pool	count=5
args	applied to non-empty ||| $f_3$ a a a	count=1
return	look at the pointer ||| io b	count=2
module	spacing ||| data char	count=1
args	unsigned integral ||| word#	count=1
rep	hdl [function_return_2] ||| [module_1] [function_return_2]	count=8
args	for a handle hdl ||| handle	count=1
args	a binary function ||| $f_3$ a b c applicative a	count=1
args	discarding any value produced ||| a monad b	count=1
args	with ||| $f_2$ c d arrow	count=1
function	set ||| set newline mode	count=1
function_return	to [return_2] ||| [function_1] wordptr ptr [return_2]	count=1
args	promote a function to ||| r monad a1 monad a2	count=2
args	user-supplied equality predicate instead ||| a bool $list$	count=1
module	io library portions copyright ||| io encoding	count=2
function	wait until data ||| wait	count=3
return	result as ||| monad	count=1
args	is executed with ||| mvar a $f_2$	count=1
function	only performs ||| on	count=1
function_args	sets [args_2] ||| [args_2] [function_1]	count=1
function	coerce ||| coerce	count=1
module	the ||| ghc io	count=2
return	dereferences ||| maybe v	count=1
args	argument a pointer to ||| $f_2$ ptr storable io b	count=2
args	number ||| bits int	count=5
args	inside a ||| a io	count=2
return	a string describing ||| string	count=1
function	is already ||| is already	count=3
function	haskell character to ||| char to	count=3
module	an ||| control concurrent chan	count=1
return	value zero ||| ptr a	count=1
function	of error messages ||| get opt'	count=1
args	not satisfy the predicate ||| $f_2$ a	count=1
return	[return_1] value pairs ||| [return_1] [return_2]	count=2
args	is the same as ||| int	count=1
return	the specified number ||| int	count=1
args	using openfile [args_2] ||| [args_2] [args_1]	count=8
args	a monad scanning the ||| a2 monad a3 monad a4 monad a5	count=1
args	passing any value produced ||| a $f_2$ a monad b	count=1
function	list using ||| list	count=1
function	encoding [function_2] ||| [function_2] [function_1]	count=3
function	a v format ||| v	count=1
function	denominator is ||| denominator	count=1
function	name of the ||| name	count=2
args	the given [args_2] ||| marshal array move array [args_1] [args_2]	count=4
module	programmer-defined ||| io error	count=1
return	returned tvar to true ||| tvar bool	count=1
function	concatenation ||| concat	count=2
return	computation ||| io c	count=2
function	the file in ordinary ||| file	count=1
args	with a pure function ||| $f_2$	count=2
args	handle and file ||| string maybe handle maybe	count=1
module	monad ||| control monad st safe	count=2
module	do ||| io handle	count=1
module	marshal these ||| foreign marshal	count=1
args	a ||| b c applicative a applicative b	count=1
args	hseek hdl mode ||| seekmode integer	count=1
args	equality on stablename that ||| a stablename b	count=1
module	useful in situations where ||| control exception	count=2
function	the foreign ||| foreign	count=2
function	always is ||| always	count=2
return	whether the ||| io	count=1
return	identity of ||| a	count=1
function	an unsigned integral type ||| w#	count=1
return	specified number of ||| int	count=1
function	current buffering mode ||| get buffering	count=4
args	user-supplied equality predicate instead ||| a a bool	count=1
function	is similar to mallocarray0 ||| ptr array0	count=1
module	and the ||| data	count=1
function	type ||| min bound	count=1
args	nul terminated ||| $f_2$ cstring io	count=1
return	elements ||| $list$ int	count=1
args	the either type ||| a c $f_2$ b c either a	count=1
args	either type ||| $f_2$ b c either a	count=1
function	that the foreign ||| foreign	count=2
function	interact function takes ||| interact	count=1
function	traceevent ||| event	count=2
return	exposes io errors ||| io either ioerror	count=1
return	true iff ||| bool	count=2
function	privilege to perform ||| permission	count=3
args	hseek hdl mode i ||| seekmode	count=1
return	list ||| $list$ statickey	count=1
return	value zero ||| a	count=1
module	allow ||| st lazy safe	count=1
module	the [module_2] ||| [module_1] [module_2] usage	count=1
args	for a handle ||| handle	count=1
return	that a handle is ||| io handle	count=1
module	that the machine has ||| sync	count=1
args	elemindex function returns ||| eq $list$	count=1
args	constructor to a sequence ||| tycon	count=1
args	fresh memory pool which ||| pool io b	count=1
module	computation iseof ||| ghc io handle fd	count=1
module	block of ||| foreign marshal alloc	count=1
args	list of storable values ||| $f_2$ ptr storable io	count=1
return	from the io monad ||| io	count=1
function	a fresh memory ||| new	count=1
function	show non-negative integral ||| show	count=1
return	the given size ||| io ptr a	count=1
function	real [function_2] ||| [function_2] [function_1]	count=1
args	a ||| $list$ a	count=4
module	io operation ||| system io error	count=1
return	function returns ||| $list$ $list$	count=2
return	hgetbuffering hdl returns the ||| buffermode	count=2
function	array ||| array	count=2
return	complex number from ||| complex floating	count=2
module	that the ||| ghc conc sync	count=1
args	a structure to a ||| traversable a	count=2
return	combine their output ||| b $tuple_2$ c c'	count=1
return	look at the pointer ||| io	count=2
return	of the buffer ||| buffer word8	count=1
function	catchjust is like catch ||| catch	count=1
module	sufficient operating system ||| system	count=3
function	to the ||| cchar to	count=1
function	to printf ||| printf	count=1
module	native ||| ghc io handle	count=1
function	a foreign ||| foreign	count=3
return	of the io ||| io	count=1
return	by the io action ||| io a	count=1
function	[function_1] suffix of ||| [function_2] [function_1]	count=1
return	handle or nothing if ||| maybe	count=2
function	read on the ||| read	count=1
function	current value of geterrno ||| errno	count=2
module	of ||| data	count=96
module	where the operation failed ||| system io	count=5
function_return	contents [function_1] [return_2] ||| [function_1] filepath io [return_2]	count=1
return	monadic arguments from left ||| monad r	count=1
function	limits ||| min	count=1
return	threadid of ||| threadid	count=3
function	the traceevent function ||| event	count=1
args	function takes a ||| a bool $list$ a	count=1
module	parses ||| text parsercombinators readprec	count=1
function	following the least ||| trailing	count=1
function	zipping ||| zip	count=1
function	is a prefix of ||| is prefix of	count=1
return	monad ||| monad b	count=1
return	value pairs ||| $tuple_2$	count=1
function	as ||| bit	count=1
module	[module_1] [module_2] raised ||| [module_1] [module_2]	count=3
return	from the first computation ||| io c	count=2
module	increases ||| parsercombinators readprec	count=1
args	analysis for the either ||| either a b	count=1
function	strict one ||| to strict	count=1
module	object ||| system mem weak	count=2
function	determines if all ||| all	count=1
return	pair of lists ||| $list$ a $list$	count=1
return	merging ||| b b'	count=1
module	given list which is ||| list	count=1
args	signed realfloat ||| int realfloat	count=5
function_return	[function_1] [return_2] value ||| [function_1] stableptr a [return_2]	count=4
args	string using temporary ||| textencoding string	count=1
module	yields the error ||| foreign c error	count=2
module	first list ||| list	count=3
function	numerator and ||| numerator	count=1
args	equality predicate ||| a bool	count=2
args	value produced by ||| monad a monad	count=1
args	[args] lists ||| $f_3$ a a [args]	count=1
return	[return_1] number ||| conc get num capabilities [return_1] [return_2]	count=2
return	allows io computation ||| io a	count=1
function_args	[function_1] elements ||| [args_2] [function_1]	count=4
function	the ||| w#	count=1
args	resulting handle ||| handle io	count=1
function	[function] on ||| [function]	count=2
function	the query element in ||| elem	count=1
function	stm transaction ||| on stm	count=1
function	split a type ||| split poly ty con	count=1
return	[return_1] a quadruple ||| [return_1] [return_2]	count=2
args	predicate and ||| bool $list$	count=1
args	of a finite ||| a	count=1
return	stablename for ||| io stablename	count=2
function	is about to ||| finally	count=1
args	predicate instead ||| bool $list$	count=1
return	buffer ||| io $tuple_2$ int buffer	count=1
module	the environment of ||| system environment	count=1
return	the computation f ||| io b	count=3
args	predicate ||| $f_2$ a	count=6
function	hdl s writes the ||| h	count=1
function	class method without ||| method error	count=1
return	number of the capability ||| io $tuple_2$ int	count=2
args	given ||| storable $list$ storable	count=1
function_return	the [function_1] [return_2] ||| [function_1] [return_2]	count=1
module	[module] and returns ||| [module]	count=2
function	ensures that the foreign ||| foreign	count=2
function	bytes allocated ||| bytes allocated	count=1
function	passed to the finalizer ||| ptr finalizer env	count=2
function	range 0 ||| digit	count=1
function	finalizer ||| add foreign ptr finalizer env	count=4
function	a duplicate ||| h duplicate	count=1
function	is used ||| min bound	count=1
module	posix data ||| posix	count=1
module	[module_1] io ||| [module_1] [module_2]	count=7
module	can only ||| conc	count=1
function	[function_1] [function_2] on both input and ||| [function_1] [function_2] mode newlinemode	count=2
args	used as a value ||| b traversable a	count=1
return	; [return] copied areas ||| [return]	count=1
return	pool ||| io pool	count=1
args	non-options ||| argorder a $list$ optdescr a	count=1
function_args	show [args_2] ||| [function_1] [args_2]	count=1
module	ioerror corresponding to ||| c	count=1
function	the ||| set bit	count=2
function	passed to the finalizer ||| finalizer	count=2
args	a ||| e $list$ a	count=1
args	a binary ||| applicative a	count=1
return	and merging their outputs ||| arrowchoice either b b' either c c'	count=1
module	right-to-left dual of scanl ||| data list	count=1
args	pointer to ||| storable $f_2$ ptr storable	count=1
module	an ||| exts	count=1
return	the argument arrow and ||| arrow $tuple_3$ b	count=1
args	structure ||| foldable num	count=4
args	pointer to a ||| ptr storable	count=2
args	monad scanning ||| monad a3 monad a4 monad	count=1
function	file using ||| with binary file	count=1
function_return	file [return_2] ||| [return_2] [function_1]	count=1
args	of the static pointer ||| staticptrinfo	count=1
args	pool which ||| pool io b	count=1
args	a ||| c applicative a applicative b	count=1
args	like witharray but a ||| ptr storable io b	count=1
args	handle ||| handle ptr a	count=2
args	as argument a pointer ||| storable $f_2$ ptr storable	count=1
module	direct support for ||| ghc io	count=1
module	the ||| system io	count=13
function	name the upper ||| min	count=1
function	fork a thread and ||| fork	count=1
function_args	module where [args_2] ||| [function_1] name [args_2]	count=3
module	error indicating [module_2] ||| [module_2] [module_1]	count=2
args	loop [args] interrupted posix ||| [args]	count=1
args	> string ||| string string	count=1
return	number ||| io $tuple_2$ int	count=2
module	with the same size ||| exts	count=1
args	curried function ||| $tuple_2$ a b c	count=1
function_args	[function_1] number ||| [function_1] [args_2] bits	count=2
function	is like catch ||| catch just	count=1
args	[args_1] handle to ||| [args_1] iomode $f_2$ [args_2]	count=1
rep	datatype to [function_return_2] ||| [module_1] [function_return_2]	count=16
function	substitute a v format ||| v	count=1
args	a finite list ||| a	count=1
return	and merging their ||| b' either c	count=1
function	in binary ||| binary	count=2
function	hash ||| hash	count=1
args	the ||| a a	count=1
args	the mapmaybe function is ||| maybe b $list$	count=1
return	a ||| io	count=1
function	wide string with explicit ||| cwstring	count=1
args	a pointer ||| storable $f_2$ ptr storable	count=1
return	[return_1] given ||| [return_2] [return_1]	count=7
args	second argument is executed ||| mvar a $f_2$	count=1
args	the file handle and ||| maybe handle maybe	count=1
function	timeout in ||| timeout	count=1
module	to name the upper ||| prelude	count=1
module	the ||| ghc exts	count=2
module	that an io ||| io error	count=2
args	a structure to ||| a applicative b foldable a	count=1
return	into the buffer blocking ||| int buffer word8	count=1
return	staticptr by ||| staticptr	count=1
function_return	[function_1] may be ||| [function_1] [return_2]	count=3
return	for versions ||| version	count=1
args	a ||| g $list$ a $list$ b	count=1
return	for an ||| io	count=1
module	is used to ||| prelude	count=1
args	promote a function to ||| a4 a5 r monad a1 monad	count=1
args	a character ||| char	count=1
module	maps ||| control exception	count=1
function	the numerator and denominator ||| numerator	count=1
args	of storable values ||| $f_2$ ptr storable	count=1
module	types ||| types	count=2
module	this operation use control ||| control concurrent chan	count=1
module	of constructors ||| data data	count=2
module	of length n ||| data	count=1
args	the given number ||| int	count=5
function	traceevent function behaves ||| event	count=1
args	string ||| string $f_2$	count=2
module	unicode encoding ||| encoding	count=1
return	[return_1] from ||| [return_2] [return_1]	count=3
return	shows a ||| shows	count=1
args	analysis for the either ||| a c $f_2$ b c either a b	count=1
function_return	uninterruptiblemask [return_2] ||| [function_1] [return_2]	count=6
function	suffix of the ||| suffix of	count=1
args	pool to ||| pool ptr storable	count=1
function_args	an index [args_2] ||| [args_2] [function_1]	count=1
return	lists such that ||| $list$ $list$	count=1
function	allow ||| fix st	count=6
module	same size as ||| ghc	count=1
return	[return] foreign ||| [return]	count=3
args	function takes a predicate ||| a bool $list$ a	count=1
args	promote a function to ||| a2 a3 a4 r monad a1	count=1
function	not required ||| bracket_	count=1
return	number of the ||| $tuple_2$ int	count=3
module	flush ||| ghc io bufferedio	count=2
function	map each element of ||| map	count=2
module	to any instance of ||| data	count=1
module	yields the error code ||| error	count=2
function	passed to the finalizer ||| add foreign ptr finalizer env	count=2
args	predicate ||| $f_3$ a a bool $list$	count=1
function	appends a stack ||| stack	count=1
function	variant of throw that ||| throw io	count=2
args	as x ||| int	count=1
function	thread [function_2] ||| [function_2] [function_1]	count=16
function	an stm transaction but ||| on stm	count=1
return	operating on the ||| io	count=1
args	the given type where ||| ioerrortype string maybe	count=1
args	hseek hdl ||| seekmode integer	count=1
module	of magnitude and phase ||| data	count=1
return	of mkweak where the ||| $tuple_2$ weak k	count=1
return	from ||| floating	count=1
args	handle to ||| string maybe handle	count=1
function	sort ||| sort	count=2
function	the zip4 function takes ||| zip4	count=1
args	number of bytes copied ||| gcstats	count=1
args	is a reverse application ||| $f_2$ a b	count=1
module	that the ||| sync	count=1
function_return	[function_1] a storable ||| [return_2] [function_1]	count=2
args	type constructor to ||| tycon	count=1
return	the specified number ||| io int	count=1
return	[return] non-negative integral ||| [return]	count=1
function	copied each gc by ||| copied	count=1
args	an additional parameter ||| $list$ storable $f_3$	count=1
args	structure ||| a b b foldable	count=3
function	advances the ||| plus ptr	count=1
module	allocate ||| pool	count=1
args	pool which gets ||| $f_2$ pool io	count=1
function	[function_1] binary mode ||| [function_2] [function_1]	count=8
return	rest unchanged ||| c d	count=1
args	function takes ||| bool $list$	count=1
return	given size ||| ptr	count=2
return	of a storable type ||| storable	count=3
module	the argument ||| control	count=1
args	number of elements of ||| int	count=2
function	retrieve the system ||| get system	count=1
args	the first handle ||| handle handle	count=1
return	[return_1] a threadid ||| [return_1] [return_2]	count=2
function	the zip7 ||| zip7	count=1
function	to the finalizer ||| foreign ptr finalizer	count=2
args	structure to an ||| applicative b foldable	count=1
function	other not [function_2] ||| [function_2] [function_1]	count=1
args	be applied to non-empty ||| $f_3$ a a a	count=1
function	blocking ||| blocking	count=2
args	close ||| close	count=1
function	a list [function] and ||| cat [function]	count=1
args	argument a pointer ||| storable $f_2$ ptr	count=1
function	chainl p op x ||| chainl	count=1
return	fresh memory ||| io	count=1
module	it the combination ||| utils	count=1
args	argument a pointer to ||| storable $f_2$ ptr storable io	count=1
module	useful in situations where ||| control	count=2
function_return	lex function [return_2] ||| [function_1] [return_2]	count=5
args	a version ||| $list$ a	count=1
function	the radix of ||| float radix	count=1
function	foreign object in ||| foreign	count=2
args	arguments ||| $f_2$ exception maybe b $f_2$ b	count=2
function	defining left = leftapp ||| left app	count=1
args	a list of storable ||| storable	count=1
module	thread ||| control concurrent	count=4
args	promote a function to ||| a1 monad a2 monad	count=2
args	memory pool ||| pool	count=1
module	failed because the user ||| io	count=2
args	function returns the ||| $list$ eq	count=1
module	textencoding [module] ||| [module]	count=3
function_return	duplicate of [return_2] ||| [function_1] handle [return_2]	count=2
args	number ||| int	count=24
module	variant of scanl that ||| data list	count=1
function	class method without ||| method	count=1
return	returns the threadid of ||| threadid	count=2
module	c int ||| foreign c	count=1
function	in binary mode ||| binary	count=3
function	base specified by ||| at base	count=1
args	structure to an action ||| $f_2$ a applicative b foldable	count=1
function	[function] requests to ||| [function]	count=3
module	sign ||| text printf	count=1
return	returns ||| $list$ string $list$	count=1
args	of a conversion scheme ||| io textencoder estate	count=1
return	lexed string ||| string	count=1
args	gets the number of ||| int ptr	count=1
return	reference into a ||| foreignptr a	count=1
module	type ||| prelude	count=1
return	a tuple where ||| $list$ a	count=1
function	a fresh ||| new	count=1
args	witharray but a terminator ||| storable $f_2$ ptr storable io	count=1
return	a fresh memory pool ||| pool	count=1
function	[function_1] ordinary blocking ||| [function_2] [function_1]	count=2
args	on stablename that does ||| stablename	count=1
return	returns a quadruple ||| string $list$ string $list$ string	count=1
function	character to ||| char to	count=3
return	computation hgetbuffering hdl ||| io buffermode	count=4
module	error code eagain or ||| c error	count=1
function	traceevent or ||| trace event	count=1
args	file handle and ||| handle	count=1
args	equality predicate instead ||| $f_3$ a a bool $list$	count=1
return	and ||| io a	count=1
function	only performs the final ||| on error	count=1
function_return	[function_1] an intptr ||| [function_1] ptr ptr a [return_2]	count=1
function_return	[function_1] a staticptr ||| [function_1] statickey [return_2]	count=1
return	[return_1] to ||| [return_1] [return_2]	count=6
function	polar components ||| mk polar	count=1
function_args	[function_1] realfloat ||| [function_1] float [args_2]	count=1
args	its statickey ||| statickey	count=1
function	position of hdl is ||| absolute seek	count=2
function	permissions ||| permissions	count=1
return	[return_1] non-options ||| [return_2] [return_1]	count=2
return	pair ||| $tuple_2$ realfloat realfloat	count=1
module	[module_1] c byte ||| [module_1] [module_2]	count=2
args	a binary function to ||| a b c applicative a applicative b	count=1
function	blocked ||| blocked on	count=4
module	of ||| data list	count=17
args	descriptor fd [args] ||| eventmanager iocallback fd [args]	count=2
function	[function_1] stable pointer ||| [function_2] [function_1]	count=1
function	channel begins ||| dup chan	count=1
args	monad scanning ||| monad a4 monad a5	count=1
function	unsigned integral type with ||| w#	count=1
args	as ||| string io eq/num io	count=1
function	wait until data can ||| wait	count=3
args	a pointer to a ||| ptr storable	count=2
args	value ||| $f_2$ a monad	count=1
return	a staticptr by its ||| maybe staticptr a	count=1
function	of the current ||| get	count=1
args	used as a value ||| traversable a	count=1
function	list ||| list	count=2
args	list of storable values ||| ptr storable io	count=1
return	buffer blocking if ||| int buffer word8	count=1
module	that an io operation ||| system io error	count=1
function	the module where ||| module	count=1
args	same size as ||| word#	count=1
function	number of bytes ||| bytes	count=4
function	the position of hdl ||| absolute seek	count=1
function_return	[function_1] [return_2] ||| [function_1] pool int [return_2]	count=2
function	argument right by the ||| r	count=1
args	promote a function ||| a1 monad a2 monad a3 monad	count=1
return	returning a final value ||| $tuple_2$ a	count=1
args	of storable ||| ptr storable io b	count=1
return	into the buffer blocking ||| buffer	count=1
return	value to the ||| io	count=1
return	feed marked inputs ||| arrowchoice either b d	count=1
args	to a curried function ||| $tuple_2$ a b c a	count=1
module	[module_1] the combination ||| [module_1] marshal [module_2]	count=1
return	handle is created ||| handle	count=1
module	foreign ||| foreign	count=2
args	header first argument and ||| string $list$	count=1
function	of bytes allocated ||| bytes allocated	count=2
return	a computation ||| a	count=1
return	after the action has ||| io b	count=1
module	memory ||| pool	count=1
function	i/o position of hdl ||| h	count=1
return	the action has ||| io	count=1
function	limits of ||| bound	count=1
function	is a terminal or ||| is terminal	count=1
return	that traverse is ||| traversable b	count=1
function	foldl1 is a variant ||| foldl1	count=1
return	and combine their output ||| c c'	count=1
module	the same as x ||| data	count=1
module	options and ||| system console	count=1
function	no newline [function_2] ||| [function_1] [function_2]	count=1
args	for the either ||| c either a	count=1
args	same ||| bits int	count=1
args	a fresh memory pool ||| $f_2$ pool io	count=1
function	exception type ||| exception	count=1
return	the value of the ||| io	count=1
return	sequence of io ||| io	count=2
return	a list of ||| $list$	count=2
function	foreign [function_2] ||| [function_1] [function_2] finalizerptr a	count=2
function	to ||| cast char to	count=3
function	zero ||| zero	count=1
module	notation ||| numeric	count=1
function	an ||| error	count=1
module	variant of [module_2] ||| [module_1] [module_2]	count=8
args	a wordptr ||| wordptr	count=1
function	memory ||| new	count=1
function_return	[function_1] item ||| [return_2] [function_1]	count=3
return	of the original handle ||| handle	count=1
function	drop n xs returns ||| drop	count=1
module	haskell type representing ||| types	count=2
module	block ||| foreign marshal alloc	count=1
function_return	is [return_2] ||| [return_2] [function_1]	count=2
function	[function_1] pointer ||| [function_1] [function_2] stableptr a	count=4
return	[return_1] computation to ||| [return_1] [return_2]	count=4
args	c string ie ||| string	count=1
module	allocate a fresh memory ||| pool	count=1
args	storable values in ||| storable	count=1
args	value produced by ||| a monad b	count=2
return	exception of type e ||| exception	count=1
args	function takes a ||| $f_2$ a bool $list$	count=1
function	by the ||| by	count=1
args	value ||| a b b $list$ a	count=2
return	a threadid ||| threadid	count=3
args	number within epsilon ||| realfrac realfrac	count=1
return	and ||| $tuple_2$	count=1
function	error ||| error	count=18
args	is executed ||| mvar a $f_2$ a	count=1
function	variant of throw that ||| throw	count=2
function	[function_1] exist ||| [function_1] [function_2]	count=3
module	the array ends ||| foreign marshal array	count=1
function	ie ||| len	count=3
function	has an allocation ||| allocation	count=1
args	a rational value ||| rational	count=1
module	of zero bits ||| data bits	count=2
function	for an extra element ||| array0	count=1
function	show a ||| show	count=4
args	but a ||| io b	count=1
function	[function_1] end ||| [function_2] [function_1]	count=2
function	is ||| bit	count=1
return	[return_1] the duplicate ||| [return_2] [return_1]	count=6
module	get the [module_2] ||| [module_1] [module_2]	count=2
return	the current process ||| io	count=1
module	of microseconds ghc ||| ghc	count=1
module	that can only be ||| ghc conc	count=1
module	for the ||| ghc io handle	count=2
args	value from the first ||| a io b io c	count=2
return	parser for versions in ||| readp version	count=1
module	[module_1] only be ||| [module_1] [module_2]	count=1
args	list of non-options ||| argorder	count=1
module	splits ||| typeable internal	count=1
function	a file that may ||| file	count=1
function	position of hdl to ||| h	count=1
args	passes the resulting handle ||| handle	count=1
return	in arrow ||| arrow	count=1
return	is used to ||| from buffer to	count=2
function_return	[function_1] [return_2] ||| [function_1] handle [return_2]	count=19
args	promote a function to ||| r monad a1	count=2
module	foreign function ||| foreign	count=1
args	elements of ||| bool $list$ a	count=1
args	the file handle and ||| string maybe handle	count=1
function	programmer-defined ||| user	count=1
module	application of the ||| data	count=1
return	in the target thread ||| io	count=1
function	to mallocarray0 ||| ptr array0	count=1
function	performs the final ||| on	count=1
module	that can only ||| conc	count=1
args	file handle and ||| string maybe handle maybe	count=1
args	witharray but a ||| storable io b	count=1
return	any monadplus for ||| monadplus	count=1
function	mapandunzipm function maps ||| map and unzip m	count=1
return	returns true iff ||| bool	count=1
function	of map and foldl ||| map	count=1
function	hdl s ||| h	count=2
return	thread is waiting ||| blockedindefinitelyonstm	count=1
module	between ||| parsercombinators readp	count=1
args	any value produced ||| a monad	count=2
function	name ||| min bound	count=1
module	letters of ||| data	count=1
function	heap ||| heap overflow	count=4
args	gets the ||| constr	count=4
return	and also ||| iodevicetype	count=1
args	true ||| a bool	count=1
return	within a ||| either ioerror a	count=1
return	the duplicate channel ||| io	count=1
args	handle and file ||| handle maybe filepath	count=1
function	as throwerrnoif but ||| if	count=1
function_args	show for [args_2] ||| [args_2] [function_1]	count=1
function_return	to offset [return_2] ||| [function_1] [return_2]	count=8
return	[return_1] an either ||| [return_2] [return_1]	count=3
args	a c string ie ||| string	count=1
args	and [args_2] ||| [args_1] iomode $f_2$ [args_2]	count=1
function	sparks currently ||| num sparks	count=2
return	handle is ||| handle	count=1
module	microseconds ghc only ||| ghc conc io	count=2
rep	hdl is [function_return_2] ||| [module_1] [function_return_2]	count=8
function	shift ||| unsafe shift	count=1
args	argument a pointer to ||| storable $f_2$ ptr storable io b	count=1
module	can only be ||| conc	count=1
module	fresh ||| marshal pool	count=2
module	sequence of ||| data	count=1
return	staticptr ||| staticptr	count=1
module	limits ||| prelude	count=1
return	precedence context to ||| readprec	count=1
args	a conversion scheme ||| string io textdecoder dstate io textencoder estate	count=1
function	mapandunzipm function maps ||| and unzip m	count=1
args	same ||| int	count=1
function	chainl p ||| chainl	count=1
function	of bytes [function_2] ||| [function_1] [function_2]	count=5
args	string s to ||| handle string	count=2
function	can be written to ||| write	count=3
args	mapmaybe function is ||| maybe b	count=1
function	drops the given ||| strip	count=1
return	conjunction (&amp &amp ||| all	count=1
function	when the program attempts ||| nested	count=1
args	the given ||| a ptr	count=2
function_args	public representation [args_2] ||| [function_1] [args_2]	count=2
module	hdl ||| system io	count=13
args	scanning ||| a2 monad a3 monad a4 monad	count=1
return	the functor ||| functor b	count=2
function	an ||| w#	count=1
function_return	allocate space [return_2] ||| [return_2] [function_1]	count=2
module	same as ||| data	count=1
args	contain the file handle ||| maybe handle maybe	count=1
args	promote a function ||| monad a1 monad	count=2
args	[args_1] number of ||| marshal array copy array [args_1] [args_2]	count=3
function	allocation counter that tracks ||| set allocation counter	count=1
function	same as ||| bit	count=1
return	buffer to the ||| io buffer word8	count=1
function	retry an stm transaction ||| on stm	count=1
return	returns [return] calling ||| [return]	count=1
module	error code ||| c error	count=2
function	only performs the ||| on	count=1
module	current [module] until data ||| [module]	count=1
function	of bytes ||| bytes	count=8
return	value of the ||| io maybe	count=1
args	x returns ||| realfrac	count=2
function_return	the tolist [function_1] [return_2] l from the structure ||| [function_1] [return_2]	count=1
function	private use ||| private use	count=1
function	fail with ||| fail	count=2
function	no newline ||| no newline	count=2
return	next value [return_2] ||| [return_2] [return_1]	count=2
return	asynchronous ||| maskingstate	count=2
module	resultant ||| control exception	count=1
function	thread for ||| thread	count=3
function	the zip4 function ||| zip4	count=1
args	[args_1] structure but ||| [args_2] [args_1]	count=4
module	list [module] ||| [module]	count=2
args	elements of the list ||| $list$ a	count=1
return	function returns ||| $list$	count=1
return	without blocking ||| word8	count=1
args	value typically ||| a b b $list$ a	count=1
args	a c string ie ||| textencoding string	count=1
return	[return] of an ||| [return]	count=2
function	supports seek operations ||| is seekable	count=1
args	a value ||| $f_2$ a b traversable a	count=1
args	functor ||| b functor a	count=2
return	foreignptr ||| io foreignptr	count=2
module	simultaneous ||| prelude	count=1
return	memory required ||| foreignptr	count=1
module	for use in ||| ghc io	count=3
return	evaluation such as the ||| functor	count=1
function	as ||| set	count=1
function	act opens a file ||| file	count=2
module	[module_1] of corresponding ||| [module_1] [module_2]	count=1
args	a monad scanning ||| a2 monad a3 monad a4	count=1
function	mvar ||| with mvar	count=1
module	operation failed because the ||| system io error	count=2
module	columns of ||| data list	count=2
function	hdl [function_2] ||| [function_2] [function_1]	count=2
args	any value ||| a $f_2$ a	count=1
args	a structure to an ||| a applicative b foldable a	count=1
module	overloaded version of !!, ||| data	count=1
args	scanning ||| a3 monad a4 monad	count=1
args	a nul terminated c ||| cstring	count=1
args	with a ||| a	count=2
args	scanning ||| monad a3 monad a4	count=1
function	fromenum method restricted to ||| ord	count=1
module	options and a list ||| system console	count=1
module	with the ||| ghc exts	count=1
args	a list of non-options ||| argorder a	count=1
function	always ||| always	count=2
return	actions ||| applicative	count=4
module	internal function ||| typeable internal	count=1
return	to catch but returns ||| io	count=1
module	may be marshalled ||| ghc	count=1
args	[args_1] number ||| marshal array copy array [args_1] [args_2]	count=3
args	a ||| c d e $list$ a $list$ b $list$	count=1
module	a fresh ||| pool	count=1
module	to ||| control exception	count=1
args	on stablename that ||| a stablename b	count=1
args	[args_1] handle to ||| [args_1] $f_2$ [args_2]	count=1
return	value of the io ||| io a	count=1
function	smaller than ||| r	count=1
function	returning the indices ||| indices	count=1
args	x ||| bits	count=1
module	xs of ||| data	count=2
args	wide string ||| string	count=1
module	dual of [module_2] ||| [module_1] [module_2]	count=2
args	structure but with strict ||| b b b foldable	count=1
args	[args] of ||| [args]	count=1
args	a list of marshalled ||| $list$ a $f_2$ $list$	count=1
args	lists ||| $list$ eq	count=1
function	to read from ||| read stm	count=1
function_return	[function_1] for versions ||| [function_1] readp [return_2]	count=1
args	resulting handle ||| handle	count=1
function	ex ||| try	count=1
args	promote a function ||| a5 r monad a1 monad a2	count=1
function	a file using openbinaryfile ||| binary file	count=1
function	terminated by ||| peek	count=1
args	computation ||| io a io b	count=1
function	of hdl as a ||| h	count=1
module	stack ||| control exception	count=1
function	open the [function_2] ||| [function_1] [function_2]	count=2
args	actions discarding any value ||| monad a	count=1
module	that can ||| sync	count=1
return	perform a series of ||| io a	count=1
function	radix of ||| float radix	count=1
module	a string representation of ||| data	count=1
module	where the operation ||| system io error	count=5
args	argument is executed ||| mvar a $f_2$	count=1
function	catch ||| catch just	count=1
module	of hdl is ||| handle	count=3
module	was ||| control exception base	count=3
args	storable ||| storable io b	count=2
args	executed with ||| mvar a	count=1
args	witharray but ||| storable io	count=1
return	the pair of lists ||| $list$ a $list$	count=1
function	foreign ||| foreign ptr	count=2
function_return	[function_1] [return_2] ||| [function_1] constr [return_2]	count=3
return	monadic fold ||| monad	count=2
function	sets the position ||| set	count=2
return	by the computation ||| io	count=1
args	header first argument and ||| $list$	count=1
module	limits of ||| prelude	count=1
function	to wait for ||| wait	count=1
module	sort ||| data list	count=1
args	predicate instead ||| bool	count=1
module	product ||| data list	count=1
function	the least element ||| minimum by	count=1
function	to the error ||| error	count=1
return	chan ||| chan	count=2
function	looks up ||| unsafe lookup static ptr	count=1
function	[function_1] on an ||| [function_1] indefinitely [function_2]	count=6
return	and merging their ||| b b'	count=1
function	[function_1] call ||| [function_1] [function_2]	count=2
module	fresh ||| foreign marshal	count=1
function	a list [function] ||| cat [function]	count=1
return	a circular one or ||| a	count=1
module	handle ||| control exception	count=1
return	constructor ||| $tuple_3$ tycon	count=1
function	the file [function_2] ||| [function_1] [function_2]	count=2
return	returned tvar to true ||| io tvar bool	count=1
args	witharray but a terminator ||| storable io	count=1
module	value from an mvar ||| control concurrent mvar	count=1
function	default file permissions ||| file with default permissions	count=1
module	unsigned ||| exts	count=1
module	internal function to ||| internal	count=1
function	of takemvar ||| try take	count=1
function	quot [function_2] ||| [function_1] [function_2]	count=1
function	outside its declared ||| out	count=1
return	the number of ||| $tuple_2$ int	count=3
function	base specified ||| show int at base	count=1
args	of ||| $list$	count=1
function	bytes ||| bytes	count=13
function	quot and rem ||| quot rem	count=3
module	array ends ||| foreign marshal array	count=1
args	coerce [args_2] ||| [args_2] [args_1]	count=1
module	[module] exception ||| [module]	count=1
return	predicate a ||| a	count=1
return	but returns ||| string $list$ string $list$	count=1
module	additionally prints ||| debug	count=1
args	a monad scanning ||| a2 monad a3 monad a4 monad a5	count=1
function_args	show [args_2] ||| [function_1] gfloat [args_2]	count=5
function	right to left ||| r	count=1
args	non-options ||| argorder a $list$ optdescr a $list$	count=1
return	returns true if ||| bool	count=3
args	list of ||| $list$	count=1
function	unzip4 ||| unzip4	count=1
args	scanning ||| monad a3 monad a4 monad	count=1
function	[function_1] allocated ||| [function_2] [function_1]	count=7
module	proxy type for use ||| data proxy	count=1
module	function and ||| data maybe	count=1
args	a structure to a ||| a monad b traversable a	count=2
module	same size as int ||| ghc	count=1
function	is the ||| bit	count=1
args	string ||| handle string	count=2
module	c wide ||| foreign c	count=1
args	contain the file handle ||| maybe handle maybe filepath	count=1
args	a monad scanning ||| monad a4	count=1
function	is a prefix ||| is prefix	count=3
function	mallocarray0 but yields ||| array0	count=1
function_return	[function_1] [return_2] of an ||| [function_1] mvar mvar a [return_2]	count=1
function	scanl1 is a ||| scanl1	count=1
function	mallocarray0 but yields ||| ptr array0	count=1
args	value produced ||| a monad	count=2
module	[module_1] error if ||| [module_1] [module_2]	count=6
return	a value [return_2] ||| [return_2] [return_1]	count=4
function	first component of the ||| first	count=1
return	on the contents of ||| io b	count=1
function	full precision using ||| float	count=1
return	either result ||| io either	count=1
return	the argument arrow ||| arrow $tuple_3$ b d	count=1
return	merging their ||| b' either c	count=1
function	number of bytes allocated ||| bytes allocated	count=1
function	like openfile [function_1] [function_2] ||| [function_1] [function_2]	count=2
function	a signed type ||| signed	count=1
function_args	[function_1] specified number ||| bits rotate [function_1] [args_2] bits	count=2
args	value to be returned ||| $f_2$ a io $tuple_2$	count=1
function	of elements ||| array	count=1
return	memory area ||| io foreignptr storable	count=1
return	traverse ||| applicative traversable b	count=1
args	a [args] lists and ||| $f_3$ a a [args]	count=1
function	the user ||| user	count=1
args	[args] file ||| filepath [args]	count=1
return	an integer and ||| $tuple_2$ integer	count=2
return	construct an ioerror of ||| ioerror	count=1
module	allocated with malloc mallocbytes ||| marshal alloc	count=1
function_return	[function_1] buffer ||| [function_1] buffer word8 [return_2]	count=3
args	promote a function ||| a1 a2 a3 a4 r monad a1 monad	count=1
function_args	between open [args_2] ||| [args_2] [function_1]	count=1
function	is already ||| already	count=1
args	value produced by the ||| monad a monad	count=1
args	value of the ||| a	count=1
function	evaluate these ||| m_	count=2
args	of non-options a list ||| argorder	count=1
function	name of ||| name	count=2
return	the number ||| maybe int	count=1
module	[module_1] of seven-tuples ||| [module_2] [module_1]	count=1
args	specified handle ||| handle	count=1
args	string using ||| string $f_2$	count=1
args	be applied to non-empty ||| $f_3$ a a	count=1
function_args	with a [args_2] ||| [args_2] [function_1]	count=2
module	[module_1] [module_2] and returns seven lists ||| [module_2] [module_1]	count=2
args	analysis for the either ||| a c $f_2$ b c either	count=1
function	function coerce allows ||| coerce	count=1
function_return	[function_1] [return_2] haskell value ||| [function_1] [return_2]	count=8
args	list of non-options a ||| argorder a $list$ optdescr a	count=1
return	[return_1] plain memory ||| [return_2] [return_1]	count=2
return	quadruples analogous ||| $tuple_4$	count=1
module	because ||| system	count=2
function	accumulator together ||| map accum	count=1
module	hdl is set ||| handle	count=3
function	[function_1] [function_2] associates a finalizer ||| [function_1] [function_2] finalizerptr a	count=4
module	finite list ||| oldlist	count=2
return	buffer to the ||| buffer word8	count=1
return	feed marked inputs through ||| arrowchoice either	count=1
args	like witharray but a ||| storable io	count=1
args	value of ||| a applicative	count=1
module	and the like ||| data char	count=1
function	[function_1] trace to ||| [function_2] [function_1]	count=4
args	executed ||| mvar a $f_2$ a io	count=1
args	an additional parameter ||| storable $f_3$	count=1
module	of elements to ||| data	count=1
module	of corresponding ||| data	count=1
return	buffer blocking ||| $tuple_2$ int buffer word8	count=1
function	to mallocarray0 ||| foreign ptr array0	count=1
function_return	[function_1] [return_2] the structure l ||| [function_1] islist [return_2] islist	count=4
return	parses the first one ||| readp string	count=1
module	device type but ||| io device	count=1
function	fmap in ||| fmap	count=1
module	that an exception ||| control exception base	count=2
module	with [module_1] [module_2] ||| [module_1] [module_2]	count=6
return	returns the number of ||| $tuple_2$ int bool	count=3
args	non-empty ||| $f_3$ a a a foldable	count=1
function	file ||| read file	count=1
function	constructor ||| mk ty con app	count=1
function	[function_1] terminal or ||| [function_1] [function_2]	count=1
function	the zip4 ||| zip4	count=1
module	get ||| c error	count=1
args	living inside a ||| $f_2$ ptr a io b	count=2
return	a ||| string	count=2
function	map which ||| map maybe	count=1
args	like witharray ||| storable $f_2$ ptr storable	count=1
function	extracts a list ||| to list	count=1
return	mapaccumr function behaves like ||| acc $list$ y	count=1
args	type with ||| word#	count=1
function	is the same ||| set	count=1
module	size as ||| ghc	count=1
args	a binary function to ||| b c applicative a applicative	count=1
function	a file that ||| regular file	count=1
return	returns a ||| $list$ string	count=1
function	the list by ||| by	count=1
args	a ||| c d e $list$ a $list$ b	count=1
function	take ||| generic take	count=1
args	a binary function ||| $f_3$ a b c applicative a applicative b	count=1
function	shift the argument ||| shift	count=4
function_args	[function_1] readp ||| [function_1] [args_2]	count=1
return	a character is available ||| char	count=2
return	a memory area ||| a	count=1
args	the mapmaybe function ||| a maybe b $list$	count=1
args	function takes ||| $list$	count=1
function	with asynchronous exceptions masked ||| modify mvar masked	count=1
return	the read instance ||| read	count=1
return	io computation ||| io	count=1
module	for the current platform ||| ghc io handle	count=1
function	downcasting natural [function] word ||| natural [function] word	count=1
args	exception predicate ||| $f_2$ exception maybe b	count=1
module	an io ||| io	count=4
function	polar takes ||| polar	count=1
args	resulting handle to ||| handle io	count=1
module	instance ||| control	count=1
function	[function_1] sequence ||| [function_1] [function_2]	count=2
function	temporary file in readwrite ||| open temp file	count=1
args	type constructor to ||| tycon $list$	count=1
function	to ||| fun ptr to	count=1
function	finalizer ||| add foreign ptr finalizer	count=2
function	no [function_2] ||| [function_1] [function_2]	count=2
function	current [function_2] ||| [function_2] [function_1]	count=7
args	the resulting handle ||| handle io	count=1
function_args	representation of ||| rep $list$ constr	count=1
args	monads ||| b monad c $list$ a $list$ b	count=1
function	channel begins empty ||| dup chan	count=1
return	unsafeinterleaveio allows io computation ||| io	count=1
function_return	[function_1] the ||| [function_1] ioref ioref a [return_2]	count=1
args	value ||| a io $tuple_2$ a	count=1
args	not satisfy the predicate ||| $f_2$ a bool $list$	count=1
args	promote a function to ||| a5 r monad a1	count=1
args	writes the [args] file file ||| filepath [args]	count=1
function_return	[function_1] storable ||| [function_1] pool io ptr [return_2]	count=1
args	pointer living inside a ||| ptr a	count=2
return	traverse is ||| traversable	count=1
module	[module_1] options ||| [module_1] [module_2]	count=1
args	a [args_1] [args_2] ||| [args_1] a [args_2]	count=2
args	a pointer to ||| storable $f_2$ ptr storable	count=1
return	value pairs ||| $tuple_2$ string string	count=1
function	be written to ||| write stm	count=3
args	the ||| ptr a int	count=4
args	signed realfloat ||| maybe int realfloat	count=2
function_args	read from [args_2] ||| [args_2] [function_1]	count=1
module	error code eintr - ||| error	count=1
return	a ||| io a	count=5
function	a new open ||| open	count=2
function	returns the least element ||| minimum	count=1
args	storable values ||| storable $f_2$ ptr storable io	count=1
return	bits ||| bits	count=1
function_args	[function_1] [args_2] ghc only ||| [function_1] [args_2]	count=18
function	geterrno if ||| errno if	count=6
module	is an unsigned integral ||| ghc	count=1
args	encapsulated in a ||| monad b b foldable a	count=1
args	one or more characters ||| char	count=1
return	[return_1] staticptr ||| [return_2] [return_1]	count=2
args	an exception predicate to ||| $f_2$ exception maybe	count=1
return	returns the [return_2] ||| conc get num capabilities [return_1] [return_2]	count=4
args	a conversion scheme ||| textencoder estate	count=1
return	character from the ||| io	count=1
function	if the ||| if	count=3
module	of types ||| data	count=1
function	create ||| new	count=2
args	structure to ||| applicative b foldable	count=1
module	size as int ||| ghc	count=1
args	for the either ||| c $f_2$ b c either a b	count=1
return	message to the ||| io	count=1
function	stack trace ||| with stack trace	count=2
return	the duplicate ||| io	count=1
module	is the same as ||| data bits	count=1
args	a structure but with ||| foldable a	count=1
module	current ||| control exception base	count=1
args	an exception predicate to ||| $f_2$ exception maybe b io	count=1
return	the size needed to ||| io	count=1
module	array ||| foreign marshal array	count=4
return	used ||| $tuple_2$ buffer from buffer	count=2
function	with its arguments flipped ||| for m	count=2
module	a c wide ||| foreign c	count=1
return	that traverse is defined ||| traversable b	count=1
function	foldr1 is ||| foldr1	count=1
function	index ||| index	count=7
return	the number ||| io int	count=7
return	the number of ||| maybe int	count=1
args	pointer living inside a ||| a $f_2$ ptr a io	count=2
args	the string s to ||| handle string	count=1
function	heap is reaching ||| heap overflow	count=2
return	io errors ||| io either ioerror	count=1
return	just a computation ||| io a	count=1
args	non-options a ||| argorder a $list$ optdescr a $list$	count=1
return	thrown when the ||| errorcall	count=2
function	ended early ||| short	count=1
function	file in ordinary ||| open file	count=1
module	indicates where the array ||| foreign marshal array	count=1
function	extra element to signal ||| array0	count=1
return	catch but returns an ||| io	count=1
module	an ioerror [module_2] ||| [module_2] [module_1]	count=11
args	predicate ||| $f_3$ a a bool	count=2
args	promote a function ||| r monad a1	count=2
args	handle hdl which ||| handle	count=2
return	[return_1] as a ||| [return_1] [return_2]	count=1
function	map which ||| map	count=1
return	returns true iff its ||| bool	count=1
return	convert a strict [return_1] [return_2] ||| [return_1] [return_2]	count=4
function	set the ||| set newline	count=1
module	[module] list ||| [module]	count=1
module	the given list ||| list	count=1
args	pool ||| pool ptr a int	count=1
module	like mallocarray but ||| marshal array	count=1
function	error that is programmer-defined ||| user error	count=1
module	and lower ||| prelude	count=1
function	modifying ||| modify mvar_	count=1
args	value ||| $tuple_2$ a	count=1
return	state transformer computation ||| st s	count=8
args	tvar ||| tvar	count=2
module	to a foreign ||| foreign	count=1
module	string into a c ||| foreign c string	count=1
args	promote a function to ||| a1 monad	count=2
return	a complex value with ||| complex floating	count=1
args	pointer living inside a ||| a io	count=2
return	binary function to actions ||| applicative	count=1
return	reads [return_2] ||| [return_2] [return_1]	count=7
module	marshal these ||| marshal	count=1
function_return	utf-16 unicode encoding ||| utf16 textencoding	count=1
args	witharray but a terminator ||| storable $f_2$ ptr storable io b	count=1
args	function takes ||| $list$ a	count=1
return	outputs ||| arrowchoice either	count=2
function	equivalent to free which ||| free	count=1
module	to the ||| io	count=1
args	a monad scanning ||| a4 monad	count=1
module	convert ||| marshal	count=1
args	header first argument and ||| $list$ optdescr a	count=1
function	a type ||| min bound	count=1
function	mallocarray0 but yields a ||| foreign ptr array0	count=1
function	foreign pointer ||| foreign ptr to ptr	count=1
return	mkweak where the ||| $tuple_2$ weak k	count=1
module	of ||| data dynamic	count=2
function	curry converts an ||| curry	count=1
args	the pool to the ||| pool ptr storable	count=1
return	the memory area ||| storable	count=2
function	flush all ||| flush	count=1
function	read an unsigned number ||| read	count=1
function	with ||| with	count=6
args	user-supplied equality predicate ||| a bool	count=2
args	mapmaybe function ||| a maybe b $list$	count=1
return	device without blocking ||| word8	count=1
return	associativity of a ||| associativity	count=1
args	a list of storable ||| ptr storable io	count=1
args	a predicate ||| $f_2$ a bool $list$ a	count=2
module	decimal notation ||| numeric	count=2
return	a ||| either b a	count=1
module	blocked ||| exception base	count=1
function_return	represent the fixity ||| prefix fixity	count=2
args	structure but with ||| b b foldable	count=1
return	the ||| io maybe string	count=1
function	foreign object by associating ||| foreign	count=1
function	the char type ||| char type	count=1
args	value typically ||| a	count=1
function	a ||| w#	count=1
function	file file ||| file	count=2
args	handle ||| maybe handle	count=2
module	involved in the error ||| io error	count=1
args	the either type ||| b c either a	count=1
function	chainl ||| chainl	count=1
function_args	allocate storage [args_2] ||| [function_1] array0 pool [args_2]	count=1
function	type ||| min	count=1
args	conversion scheme between sequences ||| string io textdecoder dstate io textencoder estate	count=1
function	privilege to ||| permission	count=3
args	on stablename that does ||| stablename b	count=1
args	out to the device ||| bufferedio	count=1
args	handle ||| handle maybe filepath	count=1
return	whether ||| bool	count=1
args	given marker element ||| storable	count=1
module	new ||| concurrent chan	count=1
function_args	[function_1] pool ||| [function_1] bytes [args_2]	count=2
return	state transformer ||| st	count=4
args	a pointer ||| storable $f_2$ ptr	count=1
return	makes a stablename ||| stablename a	count=2
return	to an ioerror ||| ioerror	count=1
function	the unicode general ||| general	count=1
function	[function_1] ended early ||| [function_2] [function_1]	count=2
args	[args_1] list ||| [args_2] [args_1]	count=2
function	no ||| no	count=2
module	trace but [module] ||| [module]	count=1
return	readlist method ghc only ||| read	count=1
args	describes ||| char $list$ string argdescr	count=1
function	[function_1] [function_2] ||| ghc io handle [function_2] [function_1]	count=4
args	parses open ||| open	count=1
return	buffer to ||| io buffer	count=1
args	the return value ||| a io b io	count=2
function	the unicode general category ||| general category	count=1
args	storable ||| ptr storable io	count=1
return	[return_1] either ||| [return_2] [return_1]	count=2
args	the either ||| $f_2$ a c $f_2$ b c either a	count=1
args	from the representation ||| rep generic	count=1
module	variant of foldl ||| data list	count=1
function	the current i/o position ||| get posn	count=2
module	blocked ||| control exception base	count=1
args	finalized pointer ||| finalizerenvptr env a ptr env ptr a	count=1
return	pair ||| $tuple_2$ $list$	count=1
return	an int ||| int	count=2
args	over ||| $f_2$ a b functor a	count=2
args	non-options ||| argorder a $list$	count=1
args	analysis for the either ||| either a	count=1
function	[function_1] rem ||| [function_2] [function_1]	count=1
return	computation to be used ||| s	count=4
return	make a weak pointer ||| io weak	count=1
function	[function_1] limit ||| [function_2] [function_1]	count=5
function	mfilter ||| mfilter	count=1
function_args	[function_1] the structure ||| [function_1] [args_2]	count=2
return	a storable ||| storable	count=3
return	[return_1] hgetbuffering hdl ||| [return_1] [return_2]	count=2
function	the position ||| absolute seek	count=2
return	argument arrow and ||| arrow $tuple_3$ b d c	count=1
return	for ||| io	count=1
function	of its arguments does ||| does	count=1
return	to ||| to	count=2
return	function is used to ||| $tuple_2$ buffer from buffer to	count=2
return	[return_1] a ||| [return_1] chan [return_2]	count=3
module	an internal function to ||| data typeable internal	count=1
function_args	show [args_2] ||| [function_1] ffloat maybe [args_2]	count=3
return	the first computation ||| io	count=2
function	splits a ||| split ty con	count=1
module	blocked ||| ghc conc sync	count=2
function	pair ||| pair	count=1
function	in the range 0 ||| to digit	count=1
return	pair ||| $tuple_2$	count=3
args	a binary function ||| a b c applicative a	count=1
module	an internal function ||| data typeable internal	count=1
function_args	[function_1] handle ||| [function_1] [args_2]	count=9
module	as x ||| data bits	count=1
args	user-supplied equality predicate instead ||| bool $list$	count=1
args	handle is ||| handle	count=2
module	because the end ||| system io	count=1
module	from data ||| data	count=1
module	returns whether gc stats ||| ghc stats	count=1
function	to the ||| cast cchar to char	count=1
function	new instance of ||| new	count=1
function	file ||| with file	count=1
function	an extra position ||| malloc array0	count=1
module	converting ||| text	count=1
module	between values of types ||| data	count=1
function	curry converts an uncurried ||| curry	count=1
function	asynchronous exceptions masked ||| modify mvar masked	count=1
return	also may be seekable ||| iodevicetype	count=1
args	discarding any value ||| a monad b	count=1
args	takes a [args] lists ||| $f_3$ a a [args]	count=1
return	copy the rest unchanged ||| b d c d	count=1
function	lies between 0 ||| gfloat	count=1
function	a single-use resource which ||| in use	count=2
return	fixity ||| fixity	count=3
args	is a reverse ||| a	count=1
return	the rest unchanged to ||| c d	count=1
return	also ||| iodevicetype	count=1
return	is traverse with its ||| applicative traversable	count=1
function_args	hputstr hdl [args_2] ||| [args_2] [function_1]	count=1
function	show non-negative integral numbers ||| show	count=1
function	execute an action with ||| with pool	count=1
function	throwing a usererror if ||| if	count=1
function	t ever continue ||| blocked indefinitely	count=1
function	map and ||| map	count=2
args	a binary function ||| c applicative a	count=1
module	parser into one ||| text parsercombinators	count=1
function	type in class ||| rat	count=1
module	to right and ||| data foldable	count=1
module	the c int ||| c	count=1
function	throw that ||| throw	count=2
function	and ||| min bound	count=1
return	into [return_2] ||| [return_1] [return_2]	count=3
return	returns a ||| $list$ string $list$ string	count=1
args	that takes an exception ||| exception	count=1
module	exceptions ||| control exception base	count=1
return	a tuple where first ||| a	count=1
args	equality on stablename ||| a stablename	count=1
return	parses and [return_2] ||| [return_1] [return_2]	count=1
args	a reverse ||| $f_2$ a	count=1
args	either type ||| b c either	count=1
args	nul terminated c ||| cstring io a	count=1
args	nul terminated ||| cstring io a	count=1
return	of the ||| io maybe string	count=1
function_return	utf-16 [return_2] ||| [function_1] [return_2]	count=3
function	[function_1] [function_2] ||| [function_1] [function_2]	count=900
args	openfile file mode allocates ||| iomode	count=2
args	equality predicate instead ||| a bool $list$ a	count=1
function	hdl returns the current ||| get	count=4
function	[function] and returns ||| cat [function]	count=1
module	and the ||| data char	count=1
module	mode ||| ghc io device	count=1
args	for the either ||| $f_2$ a c $f_2$ b c either a	count=1
module	the end of file ||| io	count=1
args	scanning ||| monad a4	count=1
function	zip7 function takes ||| zip7	count=1
module	write ||| data ioref	count=1
function	[function_1] a terminal ||| [function_1] [function_2]	count=1
module	the error code ||| foreign c error	count=2
module	blocked ||| ghc conc	count=3
module	an ||| control concurrent	count=5
args	conversion scheme between ||| io textdecoder dstate io textencoder estate	count=1
args	return value from ||| a io b io	count=2
function	surrogate ||| surrogate	count=1
module	not ||| data char	count=1
function	ie wide character ||| cwstring len	count=1
function	translation at all ||| translation	count=1
function_return	[function_1] value zero ||| [function_1] int [return_2]	count=1
return	retagging and merging their ||| b' either c	count=1
module	a pair of types ||| data typeable	count=1
return	returns the number ||| io int	count=7
return	a single lexeme from ||| string	count=1
args	stablename that ||| stablename a stablename b	count=1
args	a returned value ||| io a $f_2$ either someexception a	count=1
function	largest ||| maximum	count=1
function	a haskell character to ||| to cschar	count=1
args	stablename that does not ||| a stablename b	count=1
args	elements ||| $list$	count=1
args	list of non-options ||| argorder a $list$ optdescr a $list$ string	count=1
args	to a curried function ||| b c a b	count=1
function	sign ||| sign	count=1
return	also may ||| iodevicetype	count=1
return	that it encodes ||| reads	count=1
return	their outputs ||| arrowchoice either	count=2
return	[return_1] f ||| [return_1] [return_2]	count=4
module	parser into ||| text parsercombinators readp	count=1
function	[function_1] foreign ||| [function_2] [function_1]	count=2
module	given list which ||| list	count=1
return	a computation ||| either ioerror a	count=1
function	the field labels ||| constr fields	count=1
function	between open close p ||| between	count=1
args	a ||| e f g $list$ a $list$ b $list$	count=1
function	exception-safe wrapper for modifying ||| modify mvar_	count=1
module	only be ||| ghc conc	count=1
function	binary ||| binary	count=2
return	stm action ||| stm	count=3
module	for the capability on ||| ghc	count=1
module	[module_1] a haskell ||| [module_1] [module_2]	count=1
args	a signed realfloat ||| realfloat	count=1
function	a timeout ||| timeout	count=1
args	to a non-negative integral ||| integral	count=1
function	function returning the radix ||| float radix	count=1
function_args	[function_1] handle ||| [args_2] [function_1]	count=9
function	until data ||| wait	count=1
function	be written ||| write	count=3
module	pointer to a foreign ||| foreign	count=1
function	finalizer ||| foreign ptr finalizer	count=2
function	foreign object ||| with foreign	count=2
args	first argument and ||| string $list$	count=1
function	manage the file file ||| file	count=2
args	of storable values in ||| ptr storable io	count=1
args	user-supplied equality predicate instead ||| $f_3$ a a bool	count=1
args	list of non-options a ||| argorder a $list$ optdescr a $list$	count=1
return	to the given ||| io ptr a	count=2
module	[module_1] the c ||| [module_2] [module_1]	count=2
function_args	[function_1] [args_2] evaluate these actions from ||| [function_1] [args_2]	count=1
args	catch any ioerror ||| ioerror ioerror io	count=1
function	splits ||| split ty con app	count=4
function	stable [function_2] ||| [function_1] [function_2]	count=4
function	map and foldl it ||| map	count=1
args	[args] lists and ||| $f_3$ a a [args]	count=1
function	terminal? ||| terminal device	count=2
module	coerce ||| ghc exts	count=1
args	is true ||| bool shows	count=1
return	the public presentation ||| constrrep	count=1
args	of storable values in ||| storable io b	count=1
args	is the same as ||| bits	count=1
module	fresh memory ||| pool	count=1
return	[return_1] f passing ||| [return_2] [return_1]	count=4
function	foldr ||| foldr	count=1
function	throwerrnoifminus1retrymayblock but ||| if minus1retry may block_	count=1
module	an io action ||| control	count=1
args	explicit length information ||| cstringlen io	count=2
function_return	[function_1] fixity ||| [function_1] [return_2]	count=2
module	of a ||| data data	count=3
return	its value is ||| a	count=2
function	thread is [function_2] ||| [function_1] [function_2]	count=3
args	[args_1] [args_2] ||| [args_2] [args_1]	count=133
module	error [module_2] ||| [module_1] [module_2]	count=1
return	unsigned realfrac value ||| realfrac	count=1
return	memory of the ||| io	count=1
function	coercion from ||| from	count=1
module	of unicode ||| data char	count=1
module	throw ||| exception base	count=1
return	the first computation ||| io c	count=2
module	haskell value [module] ||| [module]	count=3
function	open the file ||| open binary file	count=1
args	pool ||| pool ptr	count=2
function	function computes the product ||| product	count=2
module	latin-1 subset of ||| data char	count=1
args	represents a pointer ||| addr#	count=1
args	value typically the left-identity ||| b b $list$ a	count=1
function	supplied write ||| write	count=2
function	parsing ||| min prec	count=1
args	an exception predicate to ||| $f_2$ exception	count=1
module	event ||| ghc event	count=2
function	ie wide ||| new cwstring len	count=2
module	of ||| data foldable	count=5
function	marker to ||| trace marker	count=1
function	accepts any ||| generic	count=2
args	as a value ||| a b traversable a	count=1
args	yields true ||| a bool	count=1
args	return value from the ||| io a io b	count=2
function	program s heap ||| heap overflow	count=2
module	results of a ||| data	count=1
module	device type ||| device	count=1
function	wide string with ||| cwstring len	count=1
function_return	[function_1] type constructor ||| [return_2] [function_1]	count=2
function	if the result ||| if	count=1
function	pair ||| weak pair	count=2
module	the same as x ||| bits	count=1
args	precedence-insensitive readp ||| readp	count=1
return	a foreignptr to it ||| foreignptr	count=2
return	function reads a single ||| reads string	count=1
module	io operation ||| io	count=3
return	concrete poly-kinded ||| t	count=2
return	[return] of ||| [return]	count=5
module	a variant of ||| data	count=5
return	a finalizer to ||| a	count=2
module	information available for ||| ghc	count=1
function_return	the resultant io ||| evaluate a io	count=2
args	mapmaybe function is ||| maybe b $list$	count=1
function_args	[function_1] pool which ||| [function_1] [args_2]	count=1
module	for the ||| ghc	count=10
module	for the specified ||| ghc io	count=1
args	argument is executed ||| mvar a $f_2$ a io $tuple_2$	count=1
return	to actions ||| applicative c	count=1
return	returned tvar ||| io tvar	count=1
return	returns a quadruple ||| string $list$ string	count=1
args	pool but leave room ||| pool	count=1
function	of its arguments does ||| is does	count=1
function	ordinary blocking ||| blocking	count=1
args	a [args_2] ||| [args_2] [args_1]	count=40
module	the array ||| foreign marshal array	count=1
module	applied ||| ghc oldlist	count=1
return	allows io computation to ||| io	count=1
return	of showing ||| shows	count=1
args	is executed ||| mvar	count=1
module	marshal these values into ||| marshal	count=1
function	ended early ||| error short	count=1
args	value ||| monad a monad b	count=2
return	retagging and merging ||| b' either	count=1
module	a ||| prelude	count=1
function	a pair ||| mk weak pair	count=1
module	of seven-tuples ||| data	count=1
function	file ||| with binary file	count=2
args	of a structure but ||| b b b foldable a	count=1
return	occurrences [return] p separated ||| readp [return]	count=1
function	[function_1] [function_2] the file ||| [function_1] [function_2]	count=4
return	first computation ||| io	count=2
module	an io operation failed ||| system io	count=2
function	calls error ||| error call	count=2
module	for the capability ||| ghc	count=1
function	allow the result of ||| fix	count=3
function	[function_1] blocked on ||| [function_1] [function_2]	count=4
args	a monad scanning ||| a2 monad a3 monad a4 monad	count=1
function	hash of [function_2] ||| [function_2] [function_1]	count=2
function	action with ||| with pool	count=1
function	cpu ||| cpu	count=1
args	monad scanning the ||| monad a2 monad a3 monad a4	count=1
module	of an array ||| array	count=1
args	a ||| a a $list$ a	count=1
function_return	[function_1] [return_2] l from the structure ||| [function_1] [return_2]	count=7
module	the event ||| ghc event	count=2
function	counter that tracks how ||| counter	count=1
function_args	[function_1] precedence-insensitive readp ||| [args_2] [function_1]	count=1
function	assigned ||| assigned	count=1
module	the types ||| types	count=1
function	a duplicate ||| h duplicate to	count=1
function	[function_1] end of ||| [function_2] [function_1]	count=2
module	lift ||| control applicative	count=3
args	scanning the ||| monad a3 monad a4 monad	count=1
function_args	representation [args_2] ||| [args_2] [function_1]	count=2
args	list of non-options a ||| argorder a $list$	count=1
module	latin-1 subset of unicode ||| data	count=1
module	hdl is set ||| ghc io handle	count=3
return	to the given ||| io ptr	count=3
args	string ie character ||| textencoding string	count=1
function	bits ||| bit size maybe	count=1
module	a value [module_2] ||| [module_1] marshal [module_2]	count=1
function	the same as x ||| set bit	count=1
return	encoding for the ||| io	count=1
args	list of storable values ||| storable $f_2$ ptr storable io	count=1
args	a ||| a applicative b	count=1
module	number of elements ||| data list	count=1
return	the buffer to the ||| io buffer word8	count=1
module	parser combinators ||| parsercombinators	count=1
module	the c int ||| foreign c	count=1
module	can only be used ||| ghc conc	count=1
function_return	free which may ||| free finalizerptr	count=1
function	the current i/o ||| get	count=2
args	catch any ioerror that ||| $f_2$ ioerror ioerror io a	count=1
args	a monad scanning the ||| monad a2 monad a3 monad a4	count=1
args	argument a pointer to ||| storable $f_2$ ptr	count=1
return	monadic fold over the ||| monad b	count=2
module	letters plus letters of ||| data	count=1
args	zero or more characters ||| char	count=1
function	the mapandunzipm function maps ||| map and unzip m	count=1
return	real ||| real	count=1
args	pool which gets automatically ||| pool io b	count=1
args	six-tuples ||| $tuple_6$ a b c d e f	count=1
function	given path when appropriate ||| throw errno path	count=3
return	the size of an ||| io	count=1
args	either type ||| a c $f_2$ b c either a b	count=1
return	a series of ||| a	count=1
module	right parser ||| text parsercombinators	count=1
args	a predicate ||| $f_2$ a bool	count=2
module	list which is ||| list	count=1
module	version of !!, which ||| data list	count=1
return	thread ||| threadid	count=1
function	marshal a ||| peek cstring	count=2
module	int ||| exts	count=1
function	hash of ||| hash	count=1
args	for the either ||| b c either a	count=1
return	unsafeinterleaveio allows io computation ||| io a	count=1
module	support for ||| ghc	count=1
args	tvar ||| tvar a	count=4
return	threadid ||| threadid	count=8
module	offset ||| io device	count=1
return	out and return nothing ||| maybe a	count=1
function	new ||| new chan	count=1
function	written to the ||| write	count=2
module	an attempt was made ||| control exception base	count=1
args	the [args] representation specified ||| integral/show $f_2$ int [args]	count=1
function	sets ||| set env	count=2
return	breaks a string ||| string	count=1
return	value ||| io ptr a	count=1
function_return	in class [return_2] ||| [return_2] [function_1]	count=1
function	data to read from ||| read	count=1
args	the pool to ||| pool ptr a int	count=1
function	bytes copied each ||| bytes copied	count=2
function_return	[function_1] arrow notation ||| [function_1] [return_2]	count=1
return	throw out elements ||| $list$ b	count=1
function	not possible ||| illegal	count=1
args	the either ||| either	count=1
args	to a file descriptor ||| fd	count=3
args	a ||| a applicative	count=1
return	parses the first one ||| readp	count=1
function	bytes of [function_2] ||| [function_2] [function_1]	count=3
function	the program s heap ||| heap overflow	count=2
args	a ||| d e $list$ a $list$	count=1
args	over ||| $f_2$ a b	count=2
args	computation ||| b io c	count=2
return	[return_1] the supplied ||| [return_2] [return_1]	count=2
args	a finite list as ||| a	count=1
function	a class method without ||| method error	count=1
function	the end ||| end	count=2
args	the isprefixof ||| $list$ eq	count=1
function	a foreign object by ||| foreign	count=1
function	used to wait for ||| wait	count=1
function	[function_1] to read ||| [function_2] [function_1]	count=5
function	a pair of ||| pair	count=1
args	string as its argument ||| string string	count=1
return	of value ||| io ptr a	count=1
args	readfile function ||| filepath	count=1
args	[args_1] handle ||| [args_1] [args_2]	count=1
return	a weak pointer to ||| weak	count=1
return	is used ||| buffer from buffer	count=2
return	the list ||| io	count=1
module	xs of elements ||| data	count=1
function	type [function_2] ||| [function_2] [function_1]	count=6
return	a haskell string ||| string	count=7
module	string representation of ||| data	count=1
args	promote a function ||| a3 a4 r monad a1	count=1
function	rts to run ||| run	count=1
module	parses p in ||| text parsercombinators readprec	count=1
function	shift the ||| shift l	count=1
module	processing for the current ||| ghc conc sync	count=1
function_return	count [return_2] ||| [function_1] leading zeros finitebits [return_2]	count=1
args	given [args] ghc ||| [args]	count=1
return	word is an ||| word	count=1
args	where the second argument ||| ioerrortype	count=1
module	lazy ||| lazy	count=2
args	string using temporary storage ||| string	count=1
module	into a list of ||| data list	count=2
args	arguments ||| $f_2$ a monad b monad a	count=2
function	the traceevent ||| event	count=1
function	split a ||| split poly ty con app	count=1
function	using ||| with	count=1
return	an either result which ||| either	count=2
module	allow ||| lazy safe	count=1
return	code ||| exitcode	count=1
function	[function_1] ordinary blocking ||| [function_1] [function_2]	count=2
args	witharray but a ||| storable $list$ storable $f_2$ ptr storable io	count=1
return	a tuple ||| a	count=1
function	[function_1] allocation limit ||| [function_2] [function_1]	count=2
module	decimal notation for arguments ||| numeric	count=1
return	indicating whether the ||| io	count=1
return	the value ||| $list$ a	count=1
return	consecutive ||| ptr storable	count=1
module	size as ||| ghc exts	count=1
return	monadic fold over ||| monad b	count=2
args	describes ||| $list$ char $list$ string argdescr	count=1
args	from handle ||| handle	count=1
function	a file ||| with binary file	count=1
function	marshal ||| cstring	count=2
function	a stable pointer ||| stable ptr	count=2
args	with the arguments ||| $f_2$ a monad b monad	count=1
module	ioerror corresponding to the ||| c	count=1
return	a message to the ||| io	count=1
args	conversion scheme between sequences ||| io textdecoder dstate io textencoder estate	count=1
function	throwerrnoifminus1retrymayblock but discards ||| errno if minus1retry may block_	count=1
function	to the ||| to char	count=1
function	is a [function] or ||| [function] bad	count=1
return	a textencoding is a ||| textencoding	count=1
module	and columns of ||| data list	count=2
args	which is an exception ||| exception maybe b	count=1
return	either result which ||| either	count=2
function	but additionally if the ||| throw errno if	count=1
args	the representation ||| rep generic	count=1
args	value from the first ||| io a io b io	count=2
function	accumulator together ||| accum l	count=2
module	values of types that ||| data	count=1
function	create a new ||| new	count=3
args	the file handle ||| maybe handle	count=1
function	[function_1] until ||| [function_2] [function_1]	count=12
function	wrapper stub ||| free haskell	count=1
function_return	to an [return_2] ||| [function_1] ptr ptr a [return_2]	count=1
return	returns the number ||| io $tuple_2$ int	count=2
function_return	[function_1] may be ||| [return_2] [function_1]	count=3
return	a foreignptr ||| io foreignptr	count=2
args	c string ie character ||| textencoding string	count=1
function	be used to wait ||| thread wait	count=1
args	constructor to ||| tycon	count=1
function	[function_1] buffering mode ||| [function_1] [function_2]	count=8
return	storable ||| storable	count=4
module	only ||| ghc conc	count=1
function	privilege to perform that ||| is permission	count=2
module	reverse order of ||| data	count=1
args	monad scanning ||| monad a4 monad	count=1
function	thread until data ||| thread wait	count=2
function	set the ||| h set	count=2
module	index ||| data data	count=1
module	exception is raised ||| exception base	count=1
module	the utf-32 unicode encoding ||| encoding	count=1
args	data from the handle ||| handle ptr a int	count=2
function	update ||| update	count=1
module	programmer-defined ||| system io error	count=1
function	this accumulator together ||| accum l	count=2
return	arrow and copy ||| arrow $tuple_3$ b	count=1
args	pool which gets automatically ||| $f_2$ pool	count=1
args	of non-options a ||| argorder a $list$ optdescr a $list$ string	count=1
function	register a timeout ||| register timeout	count=2
args	quadruples ||| a b c d	count=1
return	for operating on the ||| io	count=1
args	coerce a ||| stableptr a	count=2
return	io errors ||| io	count=1
return	the leftmost non-nothing ||| first	count=1
return	string which is read ||| string	count=1
return	its representation ||| rep generic	count=1
args	value ||| monad a	count=1
args	contain the file handle ||| string maybe handle maybe filepath	count=1
module	current ||| io encoding types	count=1
function	cis t is ||| cis	count=1
function	of map ||| map	count=2
args	action in the structure ||| foldable	count=1
args	monomorphic type constructor ||| tycon	count=1
module	storage ||| foreign marshal pool	count=5
args	structure but with ||| a b b b foldable	count=1
module	satisfying ||| parsercombinators readp	count=2
args	stored in a tvar ||| tvar	count=2
function	for ||| default	count=1
function	ie wide character array ||| new cwstring len	count=1
return	monoid and ||| monoid	count=1
function	preceding the most ||| leading	count=1
function	position of ||| absolute seek	count=3
args	non-options a list of ||| argorder a $list$ optdescr a	count=1
args	a pointer ||| $f_2$ ptr storable io b	count=2
return	a variant ||| b a	count=1
function	unicode general [function_2] ||| [function_2] [function_1]	count=1
return	return a foreignptr to ||| io foreignptr	count=2
return	number ||| io int	count=5
args	[args_1] handle to ||| [args_1] [args_2]	count=1
module	of !!, ||| data	count=1
args	of non-options a ||| argorder a $list$ optdescr a $list$	count=1
function_return	[function_1] the given ||| [return_2] [function_1]	count=6
function	radix ||| radix	count=1
args	of a conversion scheme ||| string io textdecoder dstate io textencoder estate	count=1
function	[function_1] buffering ||| [function_2] [function_1]	count=8
function_return	written to [return_2] ||| [function_1] fd [return_2]	count=2
function	a ||| new	count=1
module	container of [module_2] ||| [module_1] [module_2]	count=2
return	this ||| foreignptr	count=1
function	of the module where ||| info module	count=1
args	of the ||| a	count=2
args	the return value from ||| io a io b	count=2
function	[function_1] file in ||| system io [function_1] [function_2] filepath iomode io handle	count=2
args	field ||| fieldformat	count=1
args	promote a function to ||| a3 a4 r monad a1 monad a2	count=1
return	function behaves like a ||| $list$	count=1
function	the contents ||| contents	count=1
args	the given ||| ptr	count=2
return	of the ||| io ptr	count=1
function	the upper ||| min	count=1
module	upper and ||| prelude	count=1
function	the same ||| set bit	count=1
function	natural [function] word value ||| natural [function] word	count=1
return	the number ||| $tuple_2$ int bool	count=3
args	monad scanning ||| a2 monad a3 monad a4	count=1
function_return	written to [return_2] ||| [return_2] [function_1]	count=2
module	that an io operation ||| io	count=3
function	[function_1] sparks ||| [function_1] [function_2]	count=3
module	a c byte representing ||| foreign c string	count=1
function	conventional monad join operator ||| join	count=1
function	[function_1] the error ||| [function_2] stack [function_1]	count=1
args	to a monad scanning ||| monad a3 monad a4	count=1
function	function behaves like delete ||| delete	count=1
return	fresh ||| io	count=1
return	used to continue decoding ||| $tuple_2$ buffer from buffer to	count=2
function	locale ||| locale	count=1
args	from the handle ||| handle ptr a	count=2
module	that ||| conc sync	count=1
function_return	pointer [return_2] ||| [return_2] [function_1]	count=2
function	exception ||| exception	count=1
return	a variant of ||| b a	count=1
function	is used to ||| min	count=1
function	free which ||| free	count=1
function	can [function] ||| [function] is	count=1
function	made to index an ||| index	count=1
function	read the value ||| read	count=1
return	construct an ioerror ||| ioerror	count=2
return	a list of ||| $list$ a	count=1
module	meets the given ||| foreign	count=1
args	maybe value ||| $f_2$ a b maybe	count=1
args	be applied to non-empty ||| $f_3$ a a a foldable	count=1
function	concatenation of all the ||| concat	count=2
args	conversion scheme ||| io textencoder estate	count=1
function	expressed ||| float	count=1
args	their point-wise combination analogous ||| $list$ b $list$ c $list$ d $list$ e	count=1
args	returned value ||| $f_2$ either someexception a	count=1
args	a pointer to ||| $f_2$ ptr storable io b	count=2
function	of geterrno [function_2] ||| [function_2] [function_1]	count=5
module	columns [module_2] ||| [module_2] [module_1]	count=3
args	monomorphic type constructor ||| tycon $list$	count=1
return	a quadruple ||| string	count=1
args	a ||| b c applicative a	count=1
function	file that may ||| regular file	count=1
module	is ||| bits	count=1
function	trace to [function_2] ||| [function_2] stack [function_1]	count=3
function	optional ||| optional	count=1
args	is a version ||| $list$ a	count=1
return	arrow and copy the ||| arrow $tuple_3$ b	count=1
args	[args] of bits ||| [args]	count=1
function	similar to mallocarray0 but ||| foreign ptr array0	count=1
args	takes a [args] ||| $f_3$ a a [args]	count=2
args	as argument a pointer ||| storable $f_2$ ptr	count=1
function	right by the ||| r	count=1
return	returned tvar ||| tvar	count=1
function	class defines equality (==) ||| (==)	count=1
args	the same as x ||| int	count=1
args	non-options a list of ||| argorder a $list$ optdescr	count=1
args	a version ||| a	count=1
function	action with a fresh ||| with	count=1
args	a pointer ||| $f_2$ ptr	count=2
function_args	ceiling x returns ||| ceiling realfrac	count=1
return	elements of a ||| $list$ a	count=2
function_return	stable pointer [return_2] ||| [return_2] [function_1]	count=2
args	same size as int ||| word#	count=1
function_return	parser [return_2] ||| [function_1] readp [return_2]	count=3
function	[function_1] copied ||| [function_1] [function_2]	count=4
args	handle to ||| handle	count=3
return	pair ||| $tuple_2$ realfloat	count=1
return	realfloat ||| realfloat	count=1
module	[module_1] stack ||| [module_1] [module_2]	count=4
module	the c ||| foreign c	count=10
args	the elemindex function returns ||| eq $list$ eq	count=1
return	returned tvar [return_2] ||| [return_2] [return_1]	count=1
module	scanl that ||| list	count=1
module	an mvar put a ||| control	count=1
args	the return value ||| io a	count=2
module	where [module_2] ||| [module_1] [module_2]	count=2
function	quot [function_2] ||| [function_2] [function_1]	count=1
args	elements ||| $f_2$ a bool $list$ a	count=1
args	predicate ||| $f_2$ a bool string io	count=1
args	given number of ||| int $f_2$ ptr storable io	count=1
function	[function] associates ||| [function]	count=2
return	of bytes returning the ||| io	count=1
module	results of a key ||| data	count=1
return	any monadplus for example ||| monadplus	count=1
args	an exception ||| exception maybe b	count=2
return	buffer blocking if ||| io $tuple_2$ int buffer	count=1
args	scanning the ||| a3 monad a4	count=1
function	the recover ||| recover	count=2
return	item ||| $list$ item	count=1
args	a nul terminated c ||| cstring io a	count=1
module	the number of elements ||| data	count=1
module	c string ||| foreign c string	count=3
function_args	[function_1] the static ||| [function_1] name [args_2]	count=3
return	of the ||| io ptr storable	count=1
args	is a ||| a	count=1
args	[args_1] [args_2] ||| marshal array copy array [args_1] [args_2]	count=8
args	a list of marshalled ||| res $list$ a $f_2$ $list$ b	count=1
return	the [return_2] ||| [return_1] [return_2]	count=8
function	storage for the given ||| pooled	count=2
function	into a foreign pointer ||| new foreign ptr	count=1
function	allocate a fresh memory ||| new	count=1
return	a list ||| $list$ statickey	count=1
return	of the memory required ||| io foreignptr	count=1
args	given number of microseconds ||| timeoutkey int	count=1
function	geterrno ||| errno	count=4
args	promote a function ||| a2 a3 a4 r monad a1 monad	count=1
function	quot and [function_2] ||| [function_1] [function_2]	count=1
function	geterrno if the result ||| errno if	count=1
args	the given file descriptor ||| fd	count=3
return	[return] catchjust ||| io [return]	count=2
return	but allows ||| io	count=2
args	if there are no ||| bufferedio	count=1
args	readp ||| readp	count=1
args	a ||| ptr a io b	count=2
function_return	[function_1] the fixity ||| [return_2] [function_1]	count=3
function	sort function implements a ||| sort	count=1
function_return	[function_1] [return_2] ||| [function_1] fd [return_2]	count=11
function	encoding of [function_2] ||| [function_2] [function_1]	count=3
module	allocated ||| marshal array	count=1
args	given [args_2] ||| [args_1] [args_2]	count=2
module	the operation ||| io	count=5
return	to any monadplus for ||| monadplus a	count=1
args	with a pure function ||| $f_2$ c d arrow b c	count=1
return	manager ||| eventmanager	count=1
return	indicate that the ||| a	count=1
function	not [function_2] ||| [function_2] [function_1]	count=1
return	io errors which ||| io either ioerror	count=1
function_return	[function_1] of value ||| [return_2] [function_1]	count=1
function	returns nullptr ||| null	count=1
function	adjust the storage area ||| pooled realloc	count=1
args	return value from the ||| io a io b io	count=2
module	the error code ||| error	count=2
function	[function_1] assigned ||| [function_1] [function_2]	count=2
module	thread ||| conc sync	count=4
function	handle a duplicate ||| h duplicate to	count=1
function	the exception type ||| some exception	count=1
module	that the machine ||| sync	count=1
module	because the end ||| system io error	count=2
args	with the same ||| word#	count=1
args	race-safe way ||| eventmanager	count=1
function	of a type to ||| type	count=1
module	close ||| ghc event	count=1
return	all other bits ||| bits	count=1
args	with explicit length ||| cstringlen	count=1
args	structure to an ||| a applicative b foldable	count=1
args	the same ||| word#	count=1
function	[function_1] binary ||| [function_2] [function_1] filepath iomode io handle	count=2
args	as ||| string io eq/num	count=1
function	slides ||| slide	count=1
function	the user calls error ||| error	count=2
return	the lexed string ||| string	count=1
args	promote a function ||| a3 a4 r monad a1 monad	count=1
module	convert an array ||| marshal array	count=1
function	wide string ||| peek cwstring	count=1
function	and returns the index ||| index	count=1
return	stderr and ||| io a	count=1
args	the specified number ||| int	count=4
function	close ||| close	count=1
return	character if ||| readp char	count=1
function	to mallocarray0 ||| array0	count=1
args	try [args] ||| $f_2$ [args]	count=1
function_args	[function_1] structure is ||| [function_1] [args_2]	count=2
function	[function_1] trace ||| [function_1] [function_2]	count=4
args	to a monad scanning ||| monad a4 monad	count=1
return	the number ||| $tuple_2$ int	count=3
function	only performs the ||| on error	count=1
function	traceevent function ||| event	count=1
return	first destination ; the ||| io	count=2
args	[args_1] number of ||| marshal array move array [args_1] [args_2]	count=3
args	number of ||| timeoutkey int	count=1
module	container ||| list	count=2
module	and marshal [module_2] ||| [module_1] [module_2]	count=4
function	blocked in ||| blocked on	count=2
args	character ch to ||| handle char	count=1
return	evaluation such as ||| functor	count=1
function	are not fully handled ||| try ioerror	count=1
function_return	[function_1] value zero ||| [return_2] [function_1]	count=1
module	components of magnitude ||| data complex	count=1
module	array ends ||| marshal array	count=1
function_args	polar takes [args_2] ||| [args_2] [function_1]	count=2
module	the ||| prelude	count=2
module	that [module_2] ||| [module_2] [module_1]	count=6
args	promote a function ||| a5 r monad a1	count=1
args	the resulting handle ||| handle io r	count=1
function	deprecated use traceevent ||| event	count=1
args	retry loop [args] interrupted posix ||| [args]	count=1
return	used to continue ||| buffer from buffer to	count=2
args	via the specified handle ||| handle string	count=1
return	argument arrow ||| arrow $tuple_3$	count=1
function	for modifying ||| modify mvar_	count=1
args	[args] predicate a ||| $f_2$ [args] a $f_2$ b	count=3
return	all elements satisfying the ||| $list$	count=1
return	in the computation ||| io	count=1
function_args	[function_1] a memory ||| [function_1] [args_2]	count=1
args	as an additional parameter ||| storable $f_3$	count=1
return	[return_1] a ||| st [return_1] [return_2]	count=3
args	handle ||| handle handle	count=2
function	begins ||| dup	count=1
function_args	accepts any [args_2] ||| [function_1] drop [args_2]	count=1
module	collection of ||| data	count=1
function	rem ||| rem	count=1
module	exception is ||| exception	count=4
module	empty of xs of ||| data	count=1
function	same size as ||| w#	count=1
module	a list of strings ||| data list	count=1
function_args	[function_1] first handle ||| [args_2] [function_1]	count=2
return	is used ||| from buffer	count=2
module	and the like which ||| data char	count=1
function_return	free which [return_2] ||| [function_1] [return_2]	count=5
function	used to ||| bound	count=1
module	memory ||| marshal pool	count=2
function	given foreign ||| add foreign ptr	count=2
return	a staticptr ||| io maybe staticptr a	count=1
return	a list of lists ||| $list$ a	count=1
module	[module_1] exception ||| [module_1] [module_2] bracket	count=3
module	mode for ||| ghc io	count=1
args	return value from ||| io a io b	count=2
args	like witharray but ||| storable $f_2$ ptr storable io	count=1
module	from an mvar ||| control	count=1
function_return	[function_1] a complex ||| [function_1] floating [return_2]	count=1
module	the ||| control	count=5
args	with a pure function ||| $f_2$ b c	count=1
args	non-options ||| argorder a	count=1
function	[function_1] counter that ||| [function_1] [function_2]	count=4
module	values of types ||| data	count=1
args	living inside a ||| a	count=2
args	a ||| $f_3$ a b c applicative a applicative b	count=1
module	types defined by ||| types	count=1
args	constructor to a ||| tycon	count=1
module	is ||| exts	count=1
module	thread ||| ghc conc	count=5
function	hexadecimal ||| hex	count=1
return	value from the ||| io a	count=3
return	a ||| $tuple_2$ b a	count=1
function_args	[function_1] using ||| [args_2] [function_1]	count=4
module	arrows ||| arrow	count=1
function	[function_1] for hdl ||| [function_2] get [function_1]	count=1
args	in a ||| b foldable a	count=1
module	recover ||| ghc io encoding types	count=1
args	like addforeignptrfinalizerenv ||| finalizerenvptr env a ptr env foreignptr a	count=2
return	an either result ||| io either	count=1
function	a foreign [function_2] ||| [function_2] [function_1]	count=3
args	of the static ||| staticptrinfo	count=1
function	[function_1] pointer to ||| [function_1] [function_2]	count=1
return	pairs ||| $tuple_2$ string string	count=1
return	a list ||| io $list$ statickey	count=1
args	any value produced ||| a	count=2
return	an exception ||| exception	count=2
module	c string ||| c string	count=3
return	returns ||| io	count=1
args	a ||| a b c d applicative a applicative b	count=1
return	unsigned realfrac ||| realfrac	count=1
function_args	suspends [function_1] [args_2] ghc only ||| [function_1] [args_2]	count=2
return	returns a quadruple ||| $list$ string $list$ string $list$ string	count=1
function	set the ||| h set newline	count=1
function	map and foldr it ||| map	count=1
function	of a ||| bound	count=1
args	mapmaybe function ||| $f_2$ a maybe b	count=1
function	create a ||| new	count=1
module	in ||| ghc	count=1
args	list satisfy the predicate ||| $f_2$ a bool	count=1
return	the contents ||| io b	count=1
function	the current ||| get posn	count=2
function	size ||| set size	count=1
return	buffer to the beginning ||| io buffer word8	count=1
function	the [function] ||| [function]	count=5
args	witharray but a ||| storable io	count=1
args	string with explicit length ||| textencoding cstringlen	count=1
return	a tuple where first ||| $list$ a $list$ a	count=1
args	analysis for the either ||| $f_2$ b c either a	count=1
args	elemindex function returns ||| $list$	count=1
module	may be marshalled ||| ghc exts	count=1
function	[function_1] [function_2] ||| [function_2] malloc [function_1]	count=2
module	a fresh ||| foreign marshal	count=1
function	throwerrnoifminus1retrymayblock but discards the ||| if minus1retry may block_	count=1
function	the file [function_2] ||| [function_2] temp [function_1]	count=1
args	handle and file path ||| string maybe handle maybe filepath	count=1
args	a structure to ||| b foldable a	count=1
return	of the required ||| io ptr storable	count=1
function	the real part ||| real part	count=2
module	[module] is available ||| [module]	count=9
args	value to be returned ||| a $f_2$ a io $tuple_2$	count=1
module	element of ||| data foldable	count=2
return	complex value with magnitude ||| complex floating	count=1
module	the user does ||| io	count=2
return	the next value ||| a	count=1
module	but [module] ||| [module]	count=1
module	[module_1] in ||| [module_2] [module_1] char8	count=2
args	lists ||| $list$ eq $list$ eq	count=1
args	the mapmaybe ||| maybe	count=1
function	least element [function_2] ||| [function_2] [function_1]	count=1
args	actions ||| applicative b applicative c	count=1
return	but returns ||| $list$ a $list$ string $list$ string $list$	count=1
return	a variant of ||| io either b a	count=1
function	the mapandunzipm ||| map and unzip m	count=1
return	a block of memory ||| ptr storable	count=1
module	foldr ||| ghc oldlist	count=1
function	a list using square ||| list with	count=1
module	interchanged ||| control monad	count=1
args	structure but ||| b b b foldable	count=1
return	rest unchanged ||| $tuple_3$ b d c d	count=1
function	file [function_2] ||| [function_1] [function_2]	count=2
return	[return_1] ptr ||| [return_2] [return_1]	count=2
args	the either ||| c $f_2$ b c either a b	count=1
module	a ||| ghc exts	count=2
module	the argument [module_2] ||| [module_1] [module_2]	count=6
return	[return_1] and b ||| [return_1] [return_2]	count=1
function	write the supplied value ||| write	count=2
args	the structure ||| foldable applicative	count=1
args	given number of microseconds ||| timermanager int timeoutcallback	count=1
module	that an io operation ||| io error	count=2
function	of takemvar ||| take	count=1
module	in the error ||| io error	count=1
function	have getargs return args ||| args	count=1
function_return	action hsetencoding hdl encoding [function_1] [return_2] ||| [function_1] [return_2]	count=3
function	class method without a ||| method	count=1
function	is a signed ||| is signed	count=3
return	number of the capability ||| io $tuple_2$ int bool	count=2
function	the resultant ||| evaluate	count=2
function_return	[function_args_1] to actions ||| [function_args_1] [return_2]	count=1
args	exception ||| exception maybe b io a	count=2
return	first computation is ||| io	count=2
args	structure but ||| a b b b foldable	count=1
return	out and return nothing ||| maybe	count=1
function	calling [function] ghc only ||| my [function]	count=1
function	has an allocation ||| set allocation	count=1
args	their point-wise combination analogous ||| $list$ d $list$ e	count=1
function	of map and foldr ||| map	count=1
function	foreign pointer ||| foreign ptr to	count=1
module	concrete promotable proxy ||| proxy	count=1
args	equality predicate instead ||| a bool $list$	count=1
return	and merging ||| b' either c	count=1
return	for output in ||| io	count=1
module	instead of the overloaded ||| data list	count=1
function	file in binary mode ||| binary file	count=2
args	action ||| $f_2$	count=1
function	splits a ||| split ty con app	count=1
function	if all ||| all	count=1
function	unwords is an inverse ||| unwords	count=1
module	lower limits of a ||| prelude	count=1
args	to be returned ||| $f_2$ a io $tuple_2$	count=1
args	handle is in ||| handle	count=2
function	until data is ||| wait	count=1
function_args	[function_1] function takes ||| [function_1] [args_2]	count=1
return	into the monadic type ||| monad	count=1
module	that an io ||| system io	count=3
return	retagging and merging their ||| b' either	count=1
return	non-overloaded version ||| a	count=2
return	a tuple where ||| a	count=1
return	number of the ||| int bool	count=3
return	a boolean ||| bool	count=1
function	tolist [function] ||| [function]	count=1
return	to look at the ||| io b	count=2
function	file has been reached ||| eof	count=1
function	the file in ordinary ||| open file	count=1
args	with a ||| $f_2$ b c arrow c d	count=1
function	letter ||| letter	count=2
function_args	right [args_2] ||| [args_2] [function_1]	count=1
args	complex number and returns ||| complex realfloat	count=1
function_return	until [function_1] [return_2] ||| [function_1] [return_2]	count=3
return	argument arrow and copy ||| arrow $tuple_3$ b	count=1
args	this is a ||| foreignptr a $f_2$	count=2
function_return	[function_1] [return_2] ||| foreign foreignptr [function_1] foreignptr a [return_2]	count=6
return	constructor application ||| $tuple_2$ tycon $list$ typerep	count=2
function	splits a type ||| split	count=1
function	is set to offset ||| relative	count=2
return	a quadruple consisting of ||| string	count=1
function_return	cis t [return_2] ||| [function_1] floating [return_2]	count=2
function	atomically read ||| read	count=1
function	opens a file ||| binary file	count=1
return	a series of ||| io a	count=1
return	the buffer blocking if ||| buffer	count=1
module	an exception is raised ||| control exception base	count=1
return	[return_1] hgetline ||| [return_2] [return_1]	count=1
rep	foreign function [function_return_2] ||| [module_1] [function_return_2]	count=5
function_args	allocate storage [args_2] ||| [function_1] array pool [args_2]	count=1
module	zero ||| control applicative	count=1
return	bytes into the buffer ||| buffer	count=2
function	bytes from the second ||| bytes	count=2
args	of storable values in ||| ptr storable	count=1
args	number of values as ||| int	count=1
args	a binary ||| a applicative b	count=1
function_return	stable pointer [return_2] ||| [function_1] stableptr a [return_2]	count=2
return	may be [return_2] ||| [return_2] [return_1]	count=1
module	same ||| data bits	count=2
function	the concatenation of ||| concat	count=2
args	predicate ||| bool	count=3
function_args	[function_1] number of ||| [function_1] array0 pool [args_2]	count=1
args	second argument is executed ||| mvar a $f_2$ a io $tuple_2$ a	count=1
function	generalisation of div to ||| div'	count=1
module	yields the error ||| c error	count=2
module	for the io library ||| ghc io	count=3
function	[function] on both ||| native [function]	count=1
args	pointer ||| ptr storable io	count=2
function	intersect ||| intersect by	count=2
args	function returns the ||| $list$	count=1
return	the threadid ||| threadid	count=4
function	[function_1] storage for ||| [function_2] [function_1]	count=4
return	the computation [return_2] ||| [return_2] [return_1]	count=4
module	ioerror corresponding ||| c	count=1
args	header first argument and ||| string $list$ optdescr a	count=1
module	target thread ghc ||| ghc	count=1
return	return all the elements ||| $list$	count=1
function	of the current locale ||| get locale	count=1
args	c string ie character ||| textencoding string $f_2$	count=1
function	foldl1 is ||| foldl1	count=1
function	of bytes of ||| bytes	count=1
module	an array ||| array	count=2
return	state transformer computation to ||| st s	count=4
return	returns the ||| io integer	count=1
return	a list of key ||| $list$	count=1
module	target thread ghc only ||| ghc conc	count=1
args	number of values ||| int ptr	count=1
function	the finalizer ||| add foreign ptr finalizer env	count=2
module	atomically ||| conc sync	count=1
module	of the correct type ||| data	count=2
function	memory ||| new pool	count=2
return	allocate consecutive ||| io ptr storable	count=1
module	into a c wide ||| foreign c	count=1
args	number within epsilon ||| realfrac	count=1
args	promote a function ||| a2 a3 a4 r monad a1	count=1
function	evaluate these ||| traverse_	count=1
function_args	read from [args_2] ||| [function_1] [args_2]	count=1
args	file handle and ||| maybe handle maybe	count=1
function	is set to offset ||| relative seek	count=2
args	like addforeignptrfinalizerenv ||| env a ptr env foreignptr a	count=2
module	unsigned integral type with ||| ghc exts	count=1
module	xs of elements that ||| data	count=1
function	blocked ||| blocked	count=5
return	return the number ||| int	count=2
module	resultant ||| exception base	count=1
return	a variant ||| a	count=3
args	the file handle and ||| string maybe handle maybe filepath	count=1
args	a pointer ||| ptr storable io	count=2
module	of the second ||| data	count=1
return	the rest unchanged ||| $tuple_3$ b d c d	count=1
module	but uses ||| io	count=1
args	string s to the ||| string	count=2
function	the index ||| index	count=4
args	readp to ||| readp	count=1
module	only be used ||| ghc conc	count=1
function	catch but ||| catch	count=1
function	sets the [function_2] ||| [function_2] [function_1]	count=4
return	but returns ||| io	count=1
return	the rest unchanged ||| b d c d	count=1
return	complex value with ||| complex	count=1
module	c byte representing a ||| foreign c	count=1
function_return	elements of [return_2] ||| [function_1] pool int io [return_2]	count=3
args	a ||| a b c d e $list$ a $list$	count=1
function_args	storage for [args_2] ||| [args_2] [function_1]	count=4
module	two argument arrows and ||| control arrow	count=1
module	type with the ||| exts	count=1
args	string ie character ||| textencoding string $f_2$	count=1
return	duplicate a chan ||| chan a	count=2
return	pairs ||| $tuple_2$ string	count=1
args	user-supplied equality predicate ||| bool	count=2
function	unlines ||| unlines	count=1
args	exception predicate ||| $f_2$ exception maybe	count=1
args	be returned ||| a $f_2$ a io $tuple_2$	count=1
args	either type ||| $f_2$ a c $f_2$ b c either	count=1
return	number ||| $tuple_2$ int bool	count=3
return	lists ||| $list$	count=2
module	[module] functors ||| [module]	count=1
module	a fresh ||| foreign	count=1
args	a conversion scheme ||| dstate io textencoder estate	count=1
function	terminated ||| peek	count=1
module	is ||| foreign c error	count=1
module	a concrete promotable proxy ||| data proxy	count=1
return	the argument arrow and ||| arrow $tuple_3$ b d c	count=1
args	to a monad scanning ||| a2 monad a3 monad a4 monad	count=1
args	codec ||| buffercodec from to state	count=2
function	hash of a ||| hash	count=1
args	a nul terminated ||| $f_2$ cstring io	count=1
args	static pointer is defined ||| staticptrinfo	count=1
module	marshal [module_2] ||| [module_2] [module_1]	count=4
args	handle and ||| maybe handle maybe	count=1
function	of hdl to ||| h	count=1
function_return	[function_1] the associativity ||| [return_2] [function_1]	count=2
return	pool ||| pool	count=1
return	the threadid of ||| threadid	count=2
module	failed because [module_2] ||| [module_1] [module_2]	count=10
return	tycon object ||| tycon	count=2
function	bits following the least ||| trailing	count=1
return	a ||| $list$ a $list$ a	count=1
function	t ever continue ||| indefinitely	count=1
args	pool which gets automatically ||| pool	count=1
return	of value ||| a	count=1
args	[args_1] curried ||| [args_2] [args_1]	count=8
function	returns the current ||| get	count=4
module	with ||| foreign marshal array	count=1
module	an encoding [module_2] ||| [module_1] [module_2]	count=1
function	position [function] equal ||| h [function]	count=1
return	next character ||| readp char	count=1
args	[args] empty if ||| [args]	count=3
return	number of bytes ||| int	count=1
module	same as x ||| bits	count=1
return	given size of the ||| io ptr storable	count=1
function	[function_1] rem ||| [function_1] [function_2]	count=1
args	value to be returned ||| $f_2$	count=1
function_args	duplicate of [args_2] ||| [args_2] [function_1]	count=1
module	of functions from data ||| data	count=1
args	for the either type ||| $f_2$ b c either	count=1
args	handle and ||| handle maybe	count=1
module	failed because the end ||| system io error	count=1
function	hdl to the ||| h	count=1
args	the either type ||| c either a b	count=1
args	is executed ||| mvar a $f_2$ a io $tuple_2$	count=1
function	newly created ||| fork	count=2
return	a string representation ||| string	count=1
args	a pointer to ||| $f_2$ ptr storable	count=2
function	v format character ||| v	count=1
module	of ||| data typeable internal	count=1
args	function returns the ||| eq $list$ eq	count=1
function_return	pointer [return_2] ||| [function_1] stableptr a [return_2]	count=2
function	[function_1] of hdl ||| [function_2] [function_1]	count=6
function	megabytes allocated | cpu ||| megabytes allocated	count=1
return	the action has finished ||| io b	count=1
args	with a ||| $f_2$ b	count=1
module	a parser ||| text parsercombinators readp	count=1
module	the number of ||| data list	count=2
return	a predicate a ||| a	count=1
args	a signed realfloat value ||| maybe int realfloat	count=1
function	the finalizer ||| ptr finalizer env	count=2
function	to the ||| to	count=5
module	[module] value ||| foreign marshal [module]	count=1
return	waiting to retry ||| blockedindefinitelyonstm	count=1
function	catch but it takes ||| catch just	count=1
args	either type ||| b c either a b	count=1
module	the same size as ||| exts	count=1
function_args	[function_1] static pointer ||| [function_1] [args_2]	count=1
return	returns the number of ||| io $tuple_2$ int bool	count=2
function	to the corresponding ||| to	count=3
function	extracts the real ||| real	count=1
args	the ||| a io	count=3
args	mapmaybe function ||| maybe b $list$	count=1
return	that a handle ||| io handle	count=1
args	argument a pointer to ||| storable $f_2$ ptr storable	count=1
module	string into a c ||| c string	count=1
function	the sum ||| sum	count=2
args	file handle and file ||| handle maybe	count=1
function_return	[function_1] [return_2] ||| foreign foreignptr safe [function_1] foreignptr a [return_2]	count=6
module	[module_1] of its ||| [module_1] [module_2]	count=4
args	value to be returned ||| a $f_2$	count=1
return	two lists ||| $list$ eq	count=1
return	construct an ioerror value ||| ioerror	count=1
args	promote a function to ||| a4 a5 r monad a1	count=1
function	transpose function ||| transpose	count=1
args	mapmaybe [args_2] ||| [args_1] [args_2]	count=3
function	allow the result of ||| fix st	count=3
return	0 ||| shows	count=1
args	c string ie character ||| string $f_2$	count=1
function	the file file ||| file	count=2
module	unsigned ||| ghc exts	count=2
function_return	[function_1] a ||| [function_1] wordptr ptr [return_2]	count=1
args	a binary function to ||| c applicative a applicative b	count=1
args	given number of ||| int	count=5
args	a complex number ||| complex realfloat	count=1
return	words breaks a string ||| string	count=1
function	to wait ||| thread wait	count=1
module	where the operation failed ||| io	count=5
function	the upper and lower ||| bound	count=1
args	to true ||| bool	count=1
return	the bounded class ||| bounded	count=1
module	the error ||| c error	count=2
args	passing any value produced ||| a monad b	count=1
args	string ||| string string	count=1
args	issuffixof ||| eq	count=1
module	the end of ||| io	count=1
module	transforms a parser into ||| text parsercombinators	count=1
function	the disjunction ||| or	count=2
function_args	temporary storage [function_1] [args_2] ||| string [function_1] cstring len string [args_2]	count=1
args	a binary function ||| a applicative	count=1
module	native ||| io handle	count=1
return	buffer blocking ||| buffer word8	count=1
args	action [args_2] ||| [args_2] [args_1]	count=1
args	stablename that does not ||| stablename a stablename	count=1
function	[function_1] [function_2] and ||| [function_1] [function_2]	count=4
function	an allocation ||| set allocation	count=1
args	be returned ||| $f_2$ a	count=1
return	handle is created ||| io handle	count=1
module	[module_1] [module_2] to ||| [module_2] [module_1]	count=12
args	this ||| foreignptr	count=2
args	the arguments ||| $f_2$ a monad	count=1
function	are [function] ||| try [function]	count=1
function	int ||| int	count=1
args	promote a function to ||| a4 r monad a1 monad a2 monad a3	count=1
function	associating ||| foldr m	count=1
function	opens a file ||| with binary file	count=1
module	unwords ||| data string	count=1
args	to a monad scanning ||| a4 monad	count=1
function_return	read the [return_2] ||| [return_2] [function_1]	count=1
function	a [function] ||| [function] bad	count=1
function	filled with bytes ||| calloc	count=1
return	merging ||| b b' either c	count=1
function_return	the [function_1] [return_2] the structure l ||| [function_1] [return_2]	count=1
module	[module_1] [module_2] ||| [module_2] encoding [module_1]	count=1
return	is used to ||| buffer to	count=2
args	storable values ||| ptr storable	count=1
args	return value from ||| a	count=2
args	a pointer to a ||| storable $f_2$ ptr storable io	count=1
args	writes the [args] ||| filepath [args]	count=3
args	storable ||| storable io	count=1
module	to the ||| system io	count=1
function	instance of show for ||| show	count=1
return	retagging and merging ||| b' either c	count=1
args	witharray but ||| storable io b	count=1
args	takes an exception predicate ||| $f_2$ exception maybe	count=1
args	a binary ||| a b c applicative a applicative b	count=1
return	also may be ||| iodevicetype	count=1
return	returns the number of ||| $tuple_2$ int	count=3
return	buffer blocking if ||| buffer	count=1
return	is a complex value ||| complex	count=1
function	first [function] ||| [function] firsts	count=2
args	format ||| formatparse	count=1
function	reference into a foreign ||| new foreign	count=1
args	value typically the ||| $list$ a	count=1
function	accumulator together ||| map accum l	count=1
args	handle and ||| handle	count=1
args	static pointer as a ||| staticptrinfo	count=1
function	the ||| min bound	count=2
module	command-line ||| console getopt	count=2
module	encoding [module_2] ||| [module_2] [module_1] char8	count=1
function	position of hdl ||| h	count=2
function_return	[function_1] [return_2] ||| [function_1] string [return_2]	count=3
function	file in [function_2] ||| [function_2] [function_1] filepath iomode io handle	count=2
function	lazy one ||| to lazy st	count=2
module	is a variant of ||| data	count=2
args	codec ||| buffercodec from to	count=1
args	c string ||| textencoding string	count=1
return	returns an stm action ||| io $tuple_2$ stm	count=3
args	the static pointer is ||| staticptrinfo	count=1
module	converts a parser ||| text parsercombinators readp	count=1
module	list of seven-tuples ||| data list	count=1
module	name ||| prelude	count=1
args	a binary ||| b c applicative a applicative	count=1
function_args	[function_1] [args_2] ||| [function_1] timermanager [args_2]	count=3
return	all elements satisfying ||| $list$ int	count=1
args	a pointer to a ||| $f_2$ ptr	count=2
args	elements ||| a bool $list$ a	count=3
args	number ||| realfrac	count=1
module	same ||| data	count=1
return	returns a ||| string $list$ string $list$ string	count=1
args	constructor ||| tycon	count=1
return	io errors which occur ||| io	count=1
function_args	[function_1] number of ||| ghc conc [function_1] delay [args_2]	count=3
function	real [function_2] ||| [function_1] [function_2]	count=1
args	mapmaybe function is ||| $f_2$ a maybe b	count=1
rep	register [function_args_2] ||| [module_1] register [function_args_2]	count=1
args	a handle hdl ||| handle	count=1
function_return	splits a [return_2] ||| [return_2] [function_1]	count=2
module	terminated c ||| foreign c	count=2
function	iff its argument is ||| is	count=1
module	[module_1] for ||| [module_2] encoding [module_1]	count=1
return	sum of a ||| a	count=1
args	storable values in memory ||| storable $f_2$ ptr storable io b	count=1
return	list as an int ||| int	count=1
args	to a [args_2] ||| [args_2] [args_1]	count=4
return	using the [return_2] ||| [return_1] [return_2]	count=1
function	the current [function_2] ||| [function_2] [function_1]	count=8
module	memory ||| foreign	count=2
args	a list of storable ||| storable $f_2$ ptr storable io b	count=1
module	traceio ||| debug	count=1
return	constructor application ||| tycon $list$ typerep	count=2
function	the nub ||| nub	count=1
args	of the given ||| a	count=1
args	which accepts any integral ||| integral	count=1
function	downcasting natural [function] word value ||| natural [function] word	count=1
function	allocate some ||| malloc	count=2
args	pointer to a ||| $f_2$ ptr storable io	count=2
return	the number of the ||| $tuple_2$ int bool	count=3
return	a plain memory ||| foreignptr a	count=2
args	a curried function ||| $f_2$ $tuple_2$ a b c a b	count=1
args	a binary ||| a b c applicative a	count=1
function	to the ||| cast cchar to	count=1
module	use control ||| control concurrent chan	count=1
function	module where ||| info module	count=1
args	a structure but ||| b foldable a	count=1
function	a foreign pointer ||| foreign ptr	count=1
args	either type ||| b c either a	count=1
args	pointer to a ||| ptr	count=2
function	utf-16 ||| utf16	count=1
function	into a foreign pointer ||| foreign ptr	count=1
args	nul terminated c string ||| string $f_2$ cstring	count=1
function_args	[function_1] specified number ||| [args_2] [function_1]	count=2
function	a class method without ||| method	count=1
function_return	[function_1] realfloat ||| [return_2] [function_1]	count=4
function	blocked on ||| blocked	count=2
args	for the either type ||| $f_2$ a c $f_2$ b c either	count=1
module	with ||| exts	count=1
module	data ||| data	count=1
args	writes the string s ||| string	count=1
module	[module] ex ||| [module]	count=3
return	first computation ||| io c	count=2
function	to free which ||| free	count=1
return	pair in canonical ||| $tuple_2$	count=1
return	retagging and merging their ||| b'	count=1
module	control ||| control concurrent	count=1
args	promote a function ||| a1 monad a2 monad a3	count=2
return	[return_1] computation ||| [return_2] [return_1]	count=4
args	witharray but a terminator ||| storable io b	count=1
args	same size ||| word#	count=1
module	heap ||| control exception base	count=1
function	returns a duplicate ||| duplicate	count=1
function	standard ||| ffloat	count=1
module	but allocated ||| marshal array	count=1
function	[function_1] already ||| [function_2] [function_1]	count=4
return	it uses [return] ||| [return]	count=2
args	[args_1] realfloat ||| [args_1] [args_2]	count=6
function	the position of ||| absolute seek	count=2
function	[function_1] not exist ||| [function_1] [function_2]	count=2
return	either result which ||| io either	count=1
args	element in the pool ||| pool ptr a	count=1
args	promote a function ||| r monad a1 monad a2 monad	count=2
return	computes ||| fingerprint	count=1
function	the finalizer ||| foreign ptr finalizer env	count=2
return	[return_1] chan the ||| [return_2] [return_1]	count=4
function	disable [function_2] ||| [function_1] [function_2]	count=4
return	argument arrow and copy ||| arrow $tuple_3$ b d	count=1
module	option ||| console getopt	count=1
function	retrieve the system event ||| system event	count=1
return	[return_1] number ||| concurrent get num capabilities [return_1] [return_2]	count=2
module	that can only ||| ghc conc sync	count=3
module	converting a string ||| text	count=1
args	any value produced by ||| a $f_2$ a	count=1
args	is the same ||| int	count=1
args	a binary ||| applicative a applicative b	count=1
return	destination ; [return] copied ||| [return]	count=1
args	bits in the ||| bits	count=1
return	the copied ||| io	count=2
args	the ||| ptr storable $list$ storable	count=1
return	the buffer without ||| $tuple_2$ maybe int buffer word8	count=1
function_return	signed [return_2] ||| [function_1] reads real reads [return_2]	count=4
return	a storable type ||| io ptr storable	count=2
args	promote a function ||| r monad a1 monad a2 monad a3 monad	count=1
function	shift the argument left ||| i shift	count=1
function_args	truncate [args_2] ||| [args_2] [function_1]	count=3
return	for the end marker ||| io	count=1
return	allocate consecutive ||| storable	count=1
return	within a ||| ioerror a	count=1
args	storable values in ||| storable $f_2$ ptr storable io	count=1
module	corresponding to ||| c	count=1
function	a list [function] and returns ||| cat [function]	count=1
args	elemindex function returns ||| eq $list$ eq	count=1
args	a block of ||| ptr a	count=1
return	the buffer blocking if ||| $tuple_2$ int buffer word8	count=1
module	can only be ||| ghc conc	count=1
return	exception of type ||| exception	count=2
module	if there was an ||| control	count=1
return	the finalizers associated with ||| io	count=2
args	fd [args] ||| eventmanager iocallback fd [args]	count=2
module	list [module_2] ||| [module_2] [module_1]	count=19
module	the combination ||| utils	count=1
args	this is ||| foreignptr a	count=2
return	is waiting ||| blockedindefinitelyonstm	count=1
function	the unzip4 function ||| unzip4	count=1
module	heap ||| control exception	count=1
function	[function_1] and rem ||| [function_2] [function_1]	count=1
function	fully handled ||| try ioerror	count=1
function	register a [function_2] ||| [function_2] [function_1]	count=3
function	pointer ||| ptr to ptr	count=1
function	invalid or unrepresentable sequence ||| invalid sequence	count=1
function	of a ||| min	count=1
return	destination ; the copied ||| io	count=1
function	made to index ||| index	count=1
args	a ||| g $list$ a $list$	count=1
function	is given ||| foreign ptr	count=1
args	a ||| applicative a applicative b	count=1
module	of the ||| data maybe	count=1
return	the subsequences function returns ||| $list$ $list$ a	count=1
function	in the ||| fmt	count=1
module	thread ghc only ||| ghc conc	count=1
args	the structure is ||| foldable	count=2
module	of hdl is set ||| ghc io handle	count=3
function	a stable [function_2] ||| [function_1] [function_2]	count=1
function	[function_1] list by ||| [function_2] [function_1]	count=1
args	applied to non-empty lists ||| $list$	count=2
function	[function] one ||| [function]	count=2
function	wide ||| cwstring len	count=2
function	the system event ||| get system event	count=2
function	p separated [function] ||| [function]	count=1
args	discarding any value produced ||| monad a monad b	count=1
return	first computation is ||| io c	count=2
function	t waits until ||| wait for	count=4
function	[function_1] part ||| [function_1] [function_2]	count=3
return	obtain the [return_2] ||| [return_1] [return_2]	count=1
function	of div to ||| div'	count=1
args	storable values in ||| ptr storable	count=1
module	was made to ||| control exception base	count=1
module	ghc ||| ghc exts	count=2
return	a version ||| a	count=4
args	value ||| a io b io	count=2
module	utf-32 unicode encoding ||| ghc io encoding	count=1
module	[module_1] a value ||| [module_1] [module_2]	count=2
return	storable type in the ||| io ptr storable	count=2
args	argument a pointer to ||| $f_2$ ptr	count=2
args	of storable ||| storable io b	count=1
args	given number ||| int $f_2$ ptr storable io	count=1
function_args	sets [args_2] ||| [function_1] [args_2]	count=1
return	list of key value ||| $list$	count=1
module	marshal these values ||| foreign marshal	count=1
module	upper ||| prelude	count=1
function	opens a file ||| with file	count=1
args	specified number ||| bits int	count=4
function_return	written [return_2] ||| [function_1] fd [return_2]	count=2
args	there are no ||| bufferedio buffer word8	count=1
module	[module_1] [module_2] seven lists analogous to ||| [module_2] [module_1]	count=2
return	destination ; the ||| io	count=2
module	converts a parser into ||| text parsercombinators readp	count=1
return	test ||| bool	count=1
function	error indicating that an ||| error	count=1
function_args	[function_1] signed realfloat ||| [args_2] [function_1]	count=4
function	current i/o ||| get posn	count=2
function	lazy one ||| to lazy	count=2
module	the user does ||| io error	count=2
args	given ||| a ptr	count=2
return	which [return] code points ||| [return]	count=1
module	representation of a character ||| data char	count=1
return	of a ||| $list$ a	count=2
function	ie wide character ||| new cwstring len	count=2
module	parser combinators for precedence ||| text parsercombinators readprec	count=1
args	supplied chan much like ||| chan	count=1
function	of bytes [function_2] ||| [function_2] malloc [function_1]	count=2
function	additionally if the operation ||| if	count=1
return	the [return_2] ||| sync get num capabilities [return_1] [return_2]	count=4
return	mkweakpair ||| v	count=1
return	someexception type ||| someexception	count=1
module	of ||| ghc	count=1
module	unsigned integral ||| ghc exts	count=1
module	[module_1] ioerror corresponding ||| [module_2] [module_1]	count=5
args	executed with ||| mvar a $f_2$	count=1
args	of non-options ||| argorder	count=1
return	arbitrary monads ||| monad $list$ c	count=1
function	event [function_2] ||| [function_1] [function_2]	count=1
return	until a character is ||| char	count=2
module	for the ||| ghc io	count=3
args	a structure to an ||| foldable a	count=1
module	resets ||| text parsercombinators readprec	count=1
args	of non-options ||| argorder a	count=1
args	a ||| e f g $list$ a	count=1
function_args	[function_1] [args_2] ||| [function_1] array0 pool [args_2]	count=10
args	a conversion scheme ||| textdecoder dstate io textencoder estate	count=1
function	cis t is a ||| cis	count=1
args	the predicate ||| $f_2$ a bool	count=3
args	return value from ||| a io b	count=2
function_return	[function_1] realfloat ||| [function_1] rational [return_2]	count=4
function	[function] seven ||| [function]	count=2
function	stm transaction but there ||| stm	count=1
module	argument ||| bits	count=1
function	to ||| fun ptr to ptr	count=1
function_return	gets [return_2] ||| [function_1] constr [return_2]	count=3
function	to mallocarray0 but yields ||| foreign ptr array0	count=1
module	types [module_2] ||| [module_1] [module_2]	count=2
args	witharray but a terminator ||| storable $list$ storable $f_2$ ptr storable io b	count=1
module	flipped version of ||| data	count=1
module	deprecated use ||| control concurrent	count=1
return	a value into ||| a	count=1
module	the first list ||| data list	count=3
return	i ||| seekmode	count=8
return	list of key ||| $list$	count=1
return	dereferences a ||| io maybe v	count=1
return	block of memory and ||| ptr storable	count=1
function	default file [function_2] ||| [function_1] [function_2]	count=1
function	required is given ||| foreign ptr	count=1
function	of throw ||| throw	count=4
module	subset of ||| data	count=1
args	structure to a ||| a	count=2
module	device type but ||| device	count=1
return	[return] nth ||| [return]	count=2
return	the buffer ||| io buffer word8	count=1
args	storable values in memory ||| ptr storable io	count=1
args	for the either type ||| either	count=1
function	foreign pointer ||| new foreign ptr	count=1
function_return	atomically read [return_2] ||| [return_2] [function_1]	count=4
args	for the either ||| either	count=1
function	file [function_2] ||| [function_2] temp [function_1]	count=1
args	function to a curried ||| c a b	count=1
function	the system event manager ||| system event manager	count=1
function_args	representation [args_2] ||| [function_1] [args_2]	count=2
return	single string which ||| string	count=1
function	a file ||| file	count=3
args	the either type ||| c either a	count=1
function_return	[function_1] number ||| [function_1] trailing zeros finitebits [return_2]	count=1
return	passed to mkweakpair ||| v	count=1
function_args	[function_1] realfloat value ||| [args_2] [function_1]	count=1
function	base specified ||| int at base	count=1
args	a structure to a ||| foldable a	count=2
function	index of ||| index	count=2
function	type [function_2] ||| [function_1] [function_2]	count=6
function	[function_1] contents of ||| [function_1] [function_2]	count=1
args	[args] respectively i ||| [args]	count=3
args	the file handle ||| handle maybe filepath	count=1
args	a ||| a b c d e $list$ a	count=1
function	general ||| general	count=1
function	union ||| union by	count=2
module	string representation of ||| data char	count=1
args	[args_1] function ||| [args_2] [args_1]	count=12
function	shift the first argument ||| shift	count=1
module	[module] == ||| [module]	count=2
return	[return_1] [return_2] of ||| [return_1] [return_2]	count=2
return	the memory area ||| foreignptr storable	count=2
return	fully evaluate tycon ||| tycon	count=2
args	the number ||| bits int	count=1
return	seven [return] ||| [return] $tuple_7$ a b	count=1
args	value ||| a io	count=2
args	in the structure ||| foldable applicative	count=1
function	split a type ||| split poly ty	count=1
module	asynchronous exceptions ||| control exception	count=2
function	character to the corresponding ||| cuchar to	count=1
function	data to read from ||| read stm	count=1
module	of strings at newline ||| data string	count=1
function	the sign ||| sign plus	count=1
return	it ||| io	count=1
args	copy the given number ||| ptr storable ptr storable int	count=1
module	printf ||| text printf	count=1
module	[module_1] [module_2] value ||| [module_1] [module_2]	count=2
function_return	[function_1] the buffer ||| [return_2] [function_1]	count=3
function	until data [function_2] ||| [function_1] [function_2]	count=1
args	[args_1] resulting handle ||| [args_1] $f_2$ [args_2]	count=1
function	is used to ||| bound	count=1
args	of a ||| a	count=2
args	value produced by the ||| a	count=2
return	final value ||| a traversable	count=1
function_return	[function_1] [return_2] ||| [function_1] ioref ioref a [return_2]	count=1
function	managed by hdl ||| h get	count=2
return	the value of the ||| io maybe	count=1
function_return	[function_1] storable type ||| [return_2] [function_1]	count=3
args	structure to a ||| a monad b traversable a	count=2
args	pool ||| pool io	count=1
function_args	suspends the [function_1] [args_2] ghc only ||| ghc conc [function_1] delay [args_2]	count=2
module	device if possible ||| device	count=1
args	this ||| foreignptr a $f_2$	count=2
return	arrow ||| arrow $tuple_3$ b	count=1
args	writes the string ||| string	count=1
module	value a function and ||| data maybe	count=1
module	transforms a parser ||| text parsercombinators	count=1
function	wide string with explicit ||| peek cwstring len	count=1
function	pair of ||| weak pair	count=1
args	promote a function to ||| a3 a4 r monad a1 monad	count=1
return	function takes a ||| a	count=3
return	the sum of a ||| alternative a	count=1
return	to its representation ||| rep	count=1
args	value from the first ||| io a io b	count=2
module	of the correct type ||| data dynamic	count=2
args	parses open followed ||| readp open readp	count=1
function	[function] one exception ||| [function]	count=2
rep	datatype [function_return_2] ||| [module_1] [function_return_2]	count=16
args	a list of marshalled ||| $f_2$ b res $list$ a $f_2$ $list$	count=1
function	the size of the ||| set size	count=1
function	marshal a c ||| cstring len	count=1
function	lcm x y ||| lcm	count=1
return	provided that traverse ||| traversable	count=1
function	read from a ||| read	count=1
module	the non-overloaded version of ||| data	count=1
module	internal function to ||| typeable internal	count=1
function	changes the text ||| set	count=2
return	tvar to true ||| io tvar bool	count=3
function_return	[function_1] [return_2] ||| [function_1] reads real reads [return_2]	count=4
return	the contents ||| io a	count=1
return	a type constructor ||| tycon	count=2
args	in the pool ||| pool ptr a int	count=1
module	the computation iseof ||| io handle fd	count=1
args	change the ||| iodevice integer	count=1
function_args	if all [args_2] ||| [args_2] [function_1]	count=4
args	the arguments ||| $f_2$ a monad b monad a	count=1
function	modified ||| modify	count=2
function	pointer to an ||| ptr to ptr	count=1
function_args	action with [args_2] ||| [args_2] [function_1]	count=1
return	adds a finalizer ||| a	count=1
module	the given parser ||| text parsercombinators	count=1
function	the mapandunzipm ||| and unzip m	count=1
args	any value produced ||| a $f_2$ a	count=1
return	functor ||| functor	count=2
module	write ||| data stref	count=1
module	an error ||| error	count=1
args	promote a function to ||| a3 a4 a5 r monad a1	count=1
function_return	[function_1] original handle ||| [function_1] handle [return_2]	count=2
args	to a curried function ||| $tuple_2$ a b c a b	count=1
return	returning a final value ||| a traversable	count=1
function	newline ||| newline	count=2
args	executed ||| mvar a $f_2$ a	count=1
module	contents of an ||| data	count=1
function	file or channel managed ||| h get	count=2
module	variant of foldr that ||| data	count=2
function	file hfilesize hdl returns ||| h	count=1
module	thread ||| ghc conc sync	count=4
return	type constructor [return_2] ||| [return_1] [return_2]	count=3
return	the monadic arguments ||| monad r	count=1
module	to a temporarily allocated ||| foreign marshal	count=1
args	value produced by the ||| $f_2$ a	count=1
args	pointer to a temporarily ||| $f_2$ ptr storable	count=2
module	in the ||| system io	count=1
function	when the user ||| user	count=1
return	the buffer blocking if ||| io $tuple_2$ int buffer word8	count=1
function_args	[function_1] signed ||| [function_1] ffloat alt maybe [args_2]	count=1
module	an ||| control monad	count=1
args	promote a function ||| a5 r monad a1 monad	count=1
function	the sort ||| sort	count=1
args	functor ||| a b functor a	count=2
function	private ||| private	count=1
args	static pointer ||| staticptrinfo	count=2
module	into a c wide ||| c	count=1
function	between open close ||| between	count=1
function	[function_1] not ||| [function_2] [function_1]	count=2
function	show a signed ||| show	count=1
return	buffer blocking if ||| $tuple_2$ int buffer word8	count=1
function	is the same ||| set bit	count=1
module	[module_1] the machine ||| [module_2] [module_1]	count=1
module	encoding in ||| ghc io encoding	count=1
function	opens a file using ||| binary file	count=1
args	for the either ||| $f_2$ a c $f_2$ b c either	count=1
args	return value from ||| a io b io c	count=2
module	block of memory of ||| foreign marshal alloc	count=1
module	type ||| typeable internal	count=2
function	largest ||| maximum by	count=2
args	pointer ||| storable $f_2$ ptr storable	count=1
return	the contents of ||| io	count=1
function	allocate storage for ||| pooled malloc	count=4
return	a complex value ||| complex	count=1
args	handle hdl which attached ||| handle	count=2
return	and a ||| maybe a	count=1
function	marker to the eventlog ||| trace marker	count=1
args	elements of ||| $list$ a	count=1
return	magnitude phase pair ||| $tuple_2$	count=1
args	stablename that does ||| stablename a stablename	count=1
module	the environment ||| environment	count=1
return	elements ||| $list$ b	count=1
function	wide character array ||| cwstring	count=1
return	type constructor application ||| tycon $list$	count=2
function	get ||| h get	count=1
args	like addforeignptrfinalizerenv ||| finalizerenvptr env a ptr env foreignptr	count=2
module	read ||| concurrent mvar	count=1
module	use control ||| control	count=1
function_args	[function_1] for handle ||| [function_1] [args_2]	count=4
function	and lower limits of ||| min bound	count=1
return	a variant of ||| either b a	count=1
args	is a ||| $f_2$ a	count=1
module	suffix of ||| data	count=1
return	the [return_2] ||| concurrent get num capabilities [return_1] [return_2]	count=4
function	rts to run sparks ||| run sparks	count=1
args	pool ||| $f_2$ pool	count=1
function	foldl1 ||| foldl1	count=1
args	maybe a ||| maybe	count=1
args	with a pure ||| $f_2$ b c arrow c d	count=1
return	a final value ||| a	count=1
args	a binary function to ||| $f_3$ a b c applicative a applicative	count=1
return	may be used ||| finalizerptr	count=1
function	only performs the final ||| on	count=1
return	string ||| io string	count=4
function	suffix of the second ||| suffix of	count=1
args	with a string ||| string	count=1
function_args	[function_1] static ||| [function_1] [args_2]	count=1
function	the numerator ||| numerator	count=1
function	coerce allows you ||| coerce	count=1
return	bounded class is used ||| bounded	count=1
function	a stack ||| with stack	count=1
function_return	[function_args_1] by p ||| [function_args_1] close readp a [return_2]	count=1
function	bound ||| bound	count=1
function	the int type ||| int type	count=1
module	new ||| io bufferedio	count=1
args	of a structure ||| foldable	count=2
args	promote a function to ||| monad a1 monad	count=2
args	list of storable ||| storable	count=1
return	next value from ||| a	count=1
module	no ||| system console getopt	count=1
function	[function_1] terminal ||| [function_2] [function_1]	count=1
function	is similar to mallocarray0 ||| array0	count=1
args	[args] monadic ||| [args]	count=6
module	[module] list which ||| [module]	count=1
args	storable values in memory ||| storable $f_2$ ptr storable	count=1
function	of maybes ||| maybes	count=1
args	a rational ||| rational	count=1
function	actually a pair of ||| pair	count=1
function	write the supplied ||| write	count=2
args	stablename that ||| a stablename b	count=1
return	used to continue decoding ||| io $tuple_2$ buffer from buffer to	count=2
function	punctuation ||| punctuation	count=3
function	[function_1] in binary ||| [function_2] [function_1] filepath iomode io handle	count=2
function_args	polar takes [args_2] ||| [function_1] [args_2]	count=2
function	malloc ||| malloc	count=1
module	c wide ||| foreign c string	count=1
module	traceio function ||| debug	count=1
return	contents after the action ||| io	count=1
args	c string ie ||| textencoding string	count=1
args	scanning the ||| monad a3 monad a4	count=1
args	but a terminator indicates ||| io b	count=1
args	storable values in ||| ptr storable io b	count=1
function	hdl to the position ||| h	count=1
return	of the buffer to ||| io buffer word8	count=1
function	other private use ||| private use	count=2
args	the file handle ||| handle	count=1
return	is thrown when ||| errorcall	count=2
function	evaluate these actions ||| m_	count=2
args	a nul terminated ||| cstring	count=1
module	allocation ||| control exception	count=1
return	into a haskell string ||| string	count=4
args	this function casts a ||| a	count=1
args	a fresh memory pool ||| $f_2$ pool io b	count=1
module	occurrence of x from ||| data	count=1
module	name the ||| prelude	count=1
function	current buffering mode for ||| get buffering	count=1
function_return	offset i from ||| relative seek seekmode	count=1
args	pool which gets automatically ||| pool io	count=1
function	use the native ||| native	count=1
function	native newline representation ||| native newline	count=1
args	[args_1] of ||| [args_2] [args_1]	count=4
module	of !!, ||| data list	count=1
return	actions from left to ||| applicative	count=1
function	position of hdl ||| absolute seek	count=2
args	pointer to a ||| storable $f_2$ ptr storable	count=1
module	string into a c ||| foreign c	count=4
module	[module] xs returns ||| data [module]	count=2
args	an exception predicate ||| $f_2$ exception maybe	count=1
function	returns a duplicate ||| h duplicate	count=1
args	is a ||| $f_2$ a b	count=1
function	file [function_2] ||| [function_2] [function_1]	count=10
function	[function_1] pointer and ||| [function_2] [function_1]	count=4
function	opens a file ||| file	count=2
function	least element of ||| minimum	count=1
return	io actions ||| io	count=2
args	the same ||| int	count=1
return	arbitrary monads ||| monad $list$	count=1
return	buffer blocking if ||| int buffer	count=1
args	of storable values in ||| storable io	count=1
return	someexception type is the ||| someexception	count=1
args	return value from the ||| a io b io	count=2
return	a list ||| $list$ a	count=1
module	fresh ||| foreign marshal pool	count=2
return	[return_1] number ||| [return_2] [return_1]	count=6
function_args	[function_1] memory pool ||| [function_1] [args_2]	count=2
return	a string that can ||| string	count=2
function	first ||| first	count=2
function_args	resize [args_2] ||| [function_1] [args_2]	count=4
args	arrow ||| b c	count=1
function	the ||| min	count=2
return	returns [return] ||| [return]	count=1
args	unsigned integral type ||| word#	count=1
args	the arguments ||| $f_2$ a	count=1
function	write a new value ||| write	count=1
module	like mallocarray but ||| array	count=1
function	an array ||| array	count=2
module	container of lists ||| data foldable	count=2
return	traverse ||| traversable b	count=1
return	exception of ||| exception	count=2
module	of an array including ||| foreign marshal array	count=1
module	element of the ||| data	count=1
args	returned value ||| a $f_2$ either someexception a	count=1
function	upper and lower limits ||| min bound	count=1
args	non-options a list ||| argorder a $list$ optdescr a	count=1
return	that didn t ||| $tuple_3$ $list$ a $list$ string $list$ string	count=1
return	destination ; [return] ||| [return]	count=3
args	a pointer ||| $f_2$ ptr storable io	count=2
args	a pointer ||| storable $f_2$ ptr storable io b	count=1
module	attempt was ||| exception base	count=1
return	chan the ||| io chan	count=1
function	signed ||| read signed	count=2
return	the argument arrow ||| arrow $tuple_3$ b d c	count=1
function_return	until data [function_1] [return_2] ||| [function_1] fd [return_2]	count=2
return	arrow and copy ||| arrow $tuple_3$ b d	count=1
args	openfile file ||| iomode	count=2
module	fresh memory ||| foreign	count=1
function	with ||| w#	count=1
function	[function_1] event ||| [function_2] [function_1]	count=3
function	timeout to fire ||| timeout	count=1
return	[return_1] f passing ||| [return_1] [return_2]	count=4
function	operation is ||| operation	count=1
args	io ||| io a	count=1
function	unwords is ||| unwords	count=1
function	maybes ||| maybes	count=1
args	for the either ||| c either	count=1
return	[return_1] value of ||| [return_1] [return_2]	count=2
function	allocate a ||| new pool	count=1
args	catch any ioerror that ||| ioerror ioerror	count=1
args	any value ||| a	count=2
function	[function_1] a prefix ||| [function_2] [function_1]	count=1
function_args	[function_1] [args_2] action evaluate these actions ||| [function_1] [args_2] monad traversable b	count=1
function	accumulator together with ||| map accum l	count=1
function	duplicate of the original ||| h duplicate	count=1
args	like addforeignptrfinalizerenv ||| ptr env foreignptr	count=2
return	a ||| maybe a	count=1
args	for the given number ||| int $f_2$	count=1
function	and combine the ||| fold	count=1
function	unmasked ||| unmasked	count=2
module	iseof ||| handle fd	count=1
function	file [function_2] ||| [function_1] default [function_2]	count=1
args	memory pool which gets ||| pool io	count=1
return	val [return] ||| [return]	count=1
module	c byte representing ||| c	count=1
function_return	[function_1] [return_2] ||| [function_1] mvar mvar a [return_2]	count=2
function	a pair ||| weak pair	count=1
function_args	[function_1] of datatypes ||| [function_1] [args_2]	count=2
return	until a character ||| char	count=2
args	predicate ||| bool $list$	count=2
return	the someexception ||| someexception	count=1
module	same size ||| ghc exts	count=1
args	a ||| $list$ a $list$ b $list$ c	count=2
return	returns a quadruple consisting ||| $list$ a $list$ string $list$ string $list$ string	count=1
function	list by ||| by	count=1
args	is the ||| bits	count=1
return	a tuple where first ||| a $list$ a	count=1
return	returns the number of ||| int bool	count=3
function	as x ||| set	count=1
function	[function_1] of bytes ||| [function_2] [function_1]	count=1
module	proxy ||| data proxy	count=1
args	given number ||| ptr storable int	count=2
function	the file [function_2] ||| [function_2] [function_1]	count=9
module	decimal notation e ||| numeric	count=2
function	advances ||| plus ptr	count=2
return	merging their outputs ||| arrowchoice either b b' either	count=1
function_return	represent [return_2] ||| [function_1] [return_2]	count=6
args	given number ||| ptr storable ptr storable int	count=2
args	value ||| io $tuple_2$ a	count=1
return	string pairs ||| reads	count=1
function	[function_1] stack ||| [function_2] [function_1]	count=3
return	a list and ||| a	count=1
module	like mallocarray but allocated ||| marshal array	count=1
args	pool which gets ||| pool	count=1
return	returns a ||| $list$ a $list$ a	count=1
args	encapsulated in a ||| a monad b b foldable a	count=1
args	value typically ||| b b $list$ a	count=1
module	convert a ||| string	count=3
function_return	[function_1] the given ||| [function_1] fd [return_2]	count=6
function	for ||| for	count=1
module	where the ||| io error	count=5
args	signed realfloat value ||| maybe int realfloat	count=2
function_args	file [args_2] ||| [args_2] [function_1]	count=8
return	by the ||| io	count=1
return	a list of ||| $list$ statickey	count=1
return	its value ||| a	count=2
return	supplied value ||| a	count=1
function	file using openbinaryfile ||| file	count=1
function_return	represent [return_2] ||| [return_2] [function_1]	count=6
return	used [return_2] ||| [return_1] [return_2]	count=8
function	addition to the modified ||| modify	count=1
function	public ||| alg	count=1
module	of xs of elements ||| data	count=1
return	number ||| maybe int	count=1
return	or any [return] in ||| [return]	count=1
args	openfile file ||| filepath iomode	count=2
args	[args_1] number of ||| [args_1] [args_2]	count=4
function	the storage ||| pooled	count=2
function	hputchar hdl ch writes ||| h put char	count=1
args	a conversion scheme ||| io textdecoder dstate io textencoder estate	count=1
module	stats ||| ghc stats	count=1
return	executes the computation f ||| io b	count=1
function	array outside its declared ||| out	count=1
args	given ||| $list$ storable	count=1
return	does not pass a ||| io a	count=2
module	so [module] context ||| [module]	count=1
module	element of a structure ||| data traversable	count=1
return	takes a ||| $list$ a $list$	count=2
function	taken ||| swap	count=1
module	so [module] ||| [module]	count=2
args	a list of ||| $f_2$ b res $list$ a $f_2$ $list$ b	count=1
module	appropriate instance ||| control	count=1
module	lazy ||| st lazy	count=3
args	either type ||| $f_2$ b c either a b	count=1
args	the file handle ||| maybe handle maybe filepath	count=1
args	an int ||| int	count=1
return	elements of a storable ||| ptr storable	count=2
args	a maybe value ||| maybe a	count=1
return	a list and ||| maybe a	count=1
return	seven [return_1] [return_2] ||| [return_1] $tuple_7$ [return_2]	count=1
args	to a ||| b traversable a	count=2
module	for a ||| ghc	count=1
args	the either ||| c either	count=1
module	marshal a value into ||| foreign marshal	count=1
return	the next character ||| char	count=1
args	a list of ||| $list$ a $f_2$ $list$	count=1
function	current thread ||| get	count=2
args	for the either ||| a c $f_2$ b c either a	count=1
return	reads a single lexeme ||| reads string	count=1
function_return	[function_1] the fixity ||| [function_1] [return_2]	count=2
return	either result ||| either	count=2
module	[module] string ||| [module]	count=6
function	executed before retrying ||| retry may block	count=1
module	mode ||| io device	count=1
function	handle [function] ||| [function]	count=2
args	pointer to a ||| $f_2$ ptr storable io b	count=2
function	an extra element to ||| array0	count=1
args	integral type with ||| word#	count=1
args	s writes the string ||| handle string	count=1
module	list which ||| list	count=1
args	given number of ||| int $f_2$ ptr storable	count=1
args	an ||| ioerror	count=1
return	arrow ||| arrow b b	count=1
function	current buffering ||| get buffering	count=4
function	of the newly created ||| fork	count=2
module	the two argument ||| control	count=1
return	a computation ||| io a	count=1
return	the copied areas may ||| io	count=2
return	takes a ||| $list$ a	count=2
args	complex number ||| complex	count=2
args	a list of storable ||| storable io	count=1
function	required is given ||| ptr	count=1
module	c string into ||| c	count=1
args	storable ||| ptr storable	count=1
args	a ||| b c d e $list$ a $list$ b	count=1
return	a final value ||| $tuple_2$ a	count=1
function	line from the file ||| get line	count=1
function	current ||| h get	count=2
module	same size as int ||| exts	count=1
return	returns [return_2] ||| [return_1] chan [return_2]	count=1
function	marker to the ||| trace marker	count=1
function	program attempts to call ||| nested	count=1
function	the default file ||| file with default	count=1
function	the zip5 ||| zip5	count=1
function	the thread is blocked ||| blocked	count=2
function	available to read ||| read	count=2
function	same as x ||| bit	count=1
module	error code eintr ||| foreign c error	count=1
module	io operation failed because ||| system io error	count=1
module	converting a string to ||| text	count=1
function	set ||| h set	count=2
function_args	suspends [function_1] [args_2] ||| [function_1] [args_2]	count=5
function	is blocked on ||| blocked indefinitely on	count=2
function	printf ||| h printf	count=1
function_args	[function_1] a ||| [function_1] [args_2]	count=2
return	value ||| a traversable c	count=1
function	mapandunzipm function ||| and unzip m	count=1
module	blocked ||| conc sync	count=2
module	in the ||| io	count=1
args	elements of the ||| $list$	count=1
args	as a value ||| $f_2$ a b traversable a	count=1
return	[return_1] to ||| [return_2] [return_1]	count=6
module	foldl ||| ghc oldlist	count=1
return	a list of ||| a	count=1
function_args	resize [args_2] ||| [args_2] [function_1]	count=4
function	the unzip7 function ||| unzip7	count=1
module	turns ||| foreign concurrent	count=1
function	to represent ||| prefix	count=1
function	disable allocation limit ||| disable allocation limit	count=6
return	of a storable type ||| ptr storable	count=3
function_return	[function_1] reads ||| [function_1] [return_2]	count=2
function	the product of the ||| product	count=1
function	the system ||| system	count=1
function	[function_1] newline representation ||| [function_1] [function_2] mode newlinemode	count=2
args	file handle ||| handle maybe	count=1
function	signed ||| signed	count=2
function	appends a stack ||| with stack	count=1
return	cs other ||| generalcategory	count=1
args	any value produced by ||| $f_2$ a monad	count=1
args	structure to a ||| $f_2$ a monad b traversable a	count=2
module	io library ||| io	count=3
module	appropriate instance [module_2] ||| [module_1] [module_2]	count=2
args	a pointer ||| ptr storable	count=2
module	begins ||| concurrent chan	count=1
args	pointer to a ||| storable $f_2$ ptr storable io b	count=1
args	an unsigned ||| word#	count=1
args	convert from the representation ||| rep generic	count=1
function_return	[function_1] of item ||| [function_1] islist [return_2] islist	count=6
module	unrecognized options and a ||| system console	count=1
function	modifiers ||| modifiers	count=1
function	foreign object in question ||| foreign	count=2
args	-i ||| int	count=1
function	to ||| cast cchar to char	count=1
args	handle connected to a ||| handle	count=2
function	given foreign ||| foreign ptr	count=1
return	return true if the ||| bool	count=2
args	to non-empty ||| $f_3$ a a a foldable	count=1
module	position of hdl is ||| ghc io handle	count=1
args	[args] sets ||| handle [args]	count=1
module	public ||| data data	count=1
function	deprecated use traceevent or ||| event	count=1
module	non-overloaded version of ||| data	count=1
function_return	[function_1] io ||| [function_1] a [return_2]	count=6
args	like witharray but ||| $list$ storable $f_2$ ptr storable io	count=1
module	where the array ||| marshal array	count=1
function	to the corresponding haskell ||| to	count=3
function	argument is ||| is	count=1
args	equality predicate ||| a a bool $list$	count=1
function	char type ||| char type	count=1
function	locked to that capability ||| capability	count=1
args	list of storable ||| storable io	count=1
return	pair of lists ||| $tuple_2$ $list$ a $list$	count=1
function	the concatenation ||| concat	count=2
function	gets ||| constr fixity	count=1
function	file or channel managed ||| h	count=2
args	value produced by the ||| monad a monad b	count=1
module	block of memory ||| marshal alloc	count=1
return	function is used ||| buffer from buffer	count=2
args	structure to ||| b foldable	count=3
module	conversion ||| prelude	count=1
args	but with the arguments ||| $f_2$ a	count=1
args	hseek ||| seekmode integer	count=1
args	handle ||| $f_2$ handle io	count=1
args	[args_1] but ||| [args_2] [args_1]	count=2
args	value to be returned ||| a $f_2$ a	count=1
return	but returns ||| $tuple_4$ $list$ a $list$ string $list$ string $list$	count=1
return	nul terminated c ||| io cstring	count=1
function_return	[function_1] the ||| [function_1] storable/eq ptr storable/eq [return_2]	count=1
function	is ||| is	count=20
function_args	[function_1] a binary ||| [args_2] [function_1]	count=1
return	handle with ||| io handle	count=1
function	position of hdl as ||| h	count=1
function	same as ||| set	count=1
args	witharray but a terminator ||| $list$ storable $f_2$ ptr storable io	count=1
args	value from the ||| a	count=2
function	with the ||| w#	count=1
function	the position of hdl ||| h	count=1
module	the first component of ||| data	count=1
function	unlines is ||| unlines	count=1
return	through the argument arrow ||| arrow $tuple_3$ b d	count=1
args	promote a function to ||| a1	count=2
return	arrow ||| arrow $tuple_3$ b d c	count=1
module	malloc ||| marshal array	count=1
function_return	split [return_2] ||| [return_2] [function_1]	count=2
return	of the newx ||| io	count=1
function	[function_1] type ||| [function_1] [function_2]	count=6
function	a file using ||| binary file	count=1
args	monad scanning ||| monad a4	count=1
function	or channel managed by ||| h get	count=2
args	value ||| a $f_2$ a	count=1
args	conditionally prove the ||| a testcoercion b	count=1
function_args	be written [args_2] ||| [args_2] [function_1]	count=3
args	whether a character ||| char	count=1
args	a binary function to ||| a	count=1
return	may be [return_2] ||| [return_1] [return_2]	count=1
function	constructor for an index ||| index constr	count=1
args	structure to ||| a monad b foldable	count=2
return	maybetolist function returns an ||| $list$	count=1
args	into a nul terminated ||| cstring io a	count=1
module	of a container of ||| data list	count=2
module	for text ||| ghc io encoding	count=2
module	[module_1] for precedence ||| [module_1] [module_2]	count=6
function	[function_1] of ||| [function_1] [function_2]	count=3
args	a binary function to ||| applicative a applicative	count=1
function	and lower ||| min	count=1
args	actions passing any value ||| $f_2$ a	count=1
args	textencoding ||| textencoding	count=2
module	with ||| ghc exts	count=2
args	given type where ||| ioerrortype string	count=1
args	file handle ||| maybe handle maybe filepath	count=1
module	target thread ghc only ||| ghc conc sync	count=1
module	convert [module_2] ||| [module_1] [module_2]	count=1
function	single-use resource which is ||| in use	count=1
return	functor class is ||| functor b	count=2
function_return	[function_1] complex ||| [return_2] [function_1]	count=1
return	computation ||| io a	count=1
return	single string ||| string	count=1
args	binary mode [args] or ||| handle [args]	count=2
args	with a pure ||| $f_2$	count=2
function	file in ||| file	count=5
return	computation hwaitforinput ||| io bool	count=2
return	stderr and ||| a	count=1
function	list of error messages ||| get opt'	count=1
return	unicode encoding a byte-order-mark ||| textencoding	count=1
args	number [args_2] ||| [args_2] [args_1]	count=4
args	storable ||| storable $f_2$ ptr storable io b	count=2
function	swap ||| swap	count=1
module	haskell representation for ||| foreign c	count=1
args	first argument and ||| $list$ optdescr	count=1
function	allocation counter that ||| set allocation counter	count=2
return	the computation f passing ||| io b	count=2
function	map each element ||| map	count=4
function	read a string representation ||| read	count=1
function	unzip7 ||| unzip7	count=1
function	to wait for data ||| wait	count=1
return	from the first computation ||| io	count=2
function_args	allocate storage [args_2] ||| [args_2] [function_1]	count=2
function	list of ||| list	count=1
function	current ||| get	count=10
args	of non-options ||| argorder a $list$ optdescr a	count=1
function	control ||| control	count=1
args	is ||| bits	count=1
args	handle and file ||| string maybe handle maybe filepath	count=1
return	[return_1] a ||| [return_1] [return_2]	count=10
return	into the monadic ||| monad	count=1
return	and returns ||| io	count=1
return	argument arrow and copy ||| arrow $tuple_3$	count=1
return	value of returned tvar ||| io tvar	count=1
return	[return] act ||| [return]	count=2
function	accumulating parameter from right ||| r	count=1
module	that can only be ||| conc sync	count=1
function	the stable ||| free stable	count=1
args	list of non-options a ||| argorder a $list$ optdescr	count=1
function	timeout ||| timeout	count=3
args	pointer to a temporarily ||| ptr	count=2
args	where ||| ioerrortype	count=1
module	environment of ||| environment	count=1
module	monoid ||| monoid	count=2
args	of non-options a list ||| argorder a $list$	count=1
return	the size ||| io ptr	count=1
return	merging their ||| b'	count=1
function	openfile but [function] ||| [function] binary	count=1
module	of mappend ||| data monoid	count=2
args	conditionally prove the ||| testcoercion b	count=1
args	pointer to ||| $f_2$ ptr storable	count=2
function	sort function implements ||| sort	count=1
args	structure but with strict ||| a b b b foldable	count=1
args	number of ||| int $f_2$ ptr storable	count=1
args	bytes without ||| word8	count=1
return	of value zero ||| ptr a	count=1
return	integer ||| integer	count=1
args	predicate ||| $f_2$ char	count=1
return	into a ||| reads a	count=1
function	changes the text encoding ||| set	count=2
module	hdl is ||| ghc io handle	count=3
function	unsigned integral type ||| w#	count=1
function	[function_1] use ||| [function_1] [function_2]	count=2
function_args	between open [args_2] ||| [function_1] readp [args_2]	count=1
args	function takes a ||| $list$	count=1
args	like addforeignptrfinalizerenv ||| env foreignptr a	count=2
function	binary mode ||| open binary	count=1
args	monad scanning ||| a4 monad a5	count=1
args	the given type where ||| ioerrortype string	count=1
return	in the ||| io ptr	count=1
return	[return_1] pairs ||| [return_2] [return_1]	count=1
return	decodefloat in ||| realfloat	count=1
return	evaluation such ||| functor	count=1
args	of non-options a list ||| argorder a $list$ optdescr a $list$ string	count=1
args	convert a ||| a	count=1
args	to a curried function ||| b c a	count=1
args	bytes without ||| word8 int	count=1
function_return	[function_1] [return_2] ||| [function_1] pool int io [return_2]	count=16
args	into a c string ||| textencoding string $f_2$	count=1
args	number within epsilon of ||| realfrac	count=1
function_return	elements of [return_2] ||| [return_2] [function_1]	count=3
args	a binary function ||| applicative a applicative b	count=1
args	a binary function to ||| $f_3$ a b c applicative a applicative b	count=1
function_return	[function_1] with the ||| [function_1] ptr a [return_2]	count=4
args	value produced ||| monad a monad b	count=1
function	to ||| cchar to char	count=1
module	combination ||| utils	count=1
return	the readlist method ghc ||| read	count=1
function	buffering mode for ||| buffering	count=1
return	to a threadid ||| threadid	count=1
return	the unicode ||| io textencoding	count=1
module	example accents and the ||| data char	count=1
function_args	exception type [args_2] ||| [args_2] [function_1]	count=1
args	either type ||| $f_2$ a c $f_2$ b c either a	count=1
args	a ||| a $list$ b $list$ c $list$ d	count=1
args	value typically the left-identity ||| $list$ a	count=1
module	operation use control ||| control concurrent	count=1
args	witharray ||| $f_2$ ptr storable	count=1
return	the given ||| a	count=1
args	pointer ||| storable $f_2$ ptr storable io	count=1
args	is an exception ||| exception	count=1
function	product ||| product	count=2
return	the size needed ||| io	count=1
args	predicate to ||| $f_2$	count=1
args	their point-wise combination analogous ||| b $list$ c $list$ d $list$ e	count=1
args	a memory area ||| a	count=1
module	an attempt was ||| exception base	count=1
function	but additionally if ||| errno if	count=1
return	the fixity ||| fixity	count=2
function	[function_1] locale ||| [function_1] [function_2]	count=2
return	into a haskell list ||| $list$	count=1
module	was made ||| exception base	count=1
function_args	rotate [function_1] [args_2] ||| bits rotate [function_1] [args_2] bits	count=2
args	a ||| a $list$ b	count=2
args	monads ||| $list$ a $list$ b	count=1
return	to fully evaluate tycon ||| tycon	count=2
args	user-supplied equality predicate instead ||| a a bool $list$ a	count=1
function	pair of ||| pair	count=1
return	the target thread ghc ||| io	count=1
args	a returned value ||| a $f_2$ either someexception a	count=1
module	applied to a predicate ||| ghc oldlist	count=1
module	exitwith ||| system exit	count=1
return	character ||| char	count=4
return	io errors which occur ||| io either	count=1
module	list [module_2] ||| [module_1] [module_2]	count=19
return	is used to continue ||| buffer from buffer to	count=2
function_return	[function_1] arrow notation ||| [return_2] [function_1]	count=1
return	[return] usage ||| [return]	count=1
function	least element ||| minimum	count=3
function	throwing a usererror if ||| throw if	count=1
function	and lower limits of ||| min	count=1
args	satisfy the predicate ||| $f_2$ a bool $list$	count=1
args	a ||| g $list$ a $list$ b $list$ c	count=1
return	x setbit i ||| bits	count=1
return	to any monadplus for ||| monadplus	count=1
args	scanning the ||| monad a4	count=1
return	of ||| b	count=2
return	the end marker ||| io	count=1
function_return	given [return_2] ||| [function_1] foreignptr a [return_2]	count=2
args	value produced ||| monad a monad	count=1
args	of storable ||| ptr storable	count=1
function	but appends a stack ||| with stack	count=1
return	a character ||| char	count=2
module	new ||| ghc io bufferedio	count=1
module	unsigned integral ||| ghc	count=1
args	conditionally prove ||| testcoercion	count=1
return	of chan ||| chan	count=1
function_return	[function_1] a tuple ||| [function_1] int $list$ a [return_2]	count=1
module	string representation of a ||| data	count=1
function	appropriately scaled exponent ||| decode	count=1
function	capability ||| capability	count=1
args	encapsulated in a ||| foldable a	count=1
function	of sparks currently in ||| sparks	count=2
function	big-endian ||| utf32be	count=1
module	because the ||| io	count=2
args	storable values in ||| storable io b	count=1
function	unlines is an inverse ||| unlines	count=1
module	that the ||| conc sync	count=1
args	exception predicate to ||| $f_2$ exception	count=1
args	a ||| $f_2$ a b	count=2
return	monadic arguments ||| monad	count=1
return	reads ||| reads	count=3
function_return	run [return_2] ||| [return_2] [function_1]	count=2
module	variant of foldl that ||| data	count=1
module	the operation ||| system io error	count=5
args	[args_1] predicate ||| [args_2] [args_1]	count=8
args	string as its argument ||| $f_2$ string string	count=1
function	open the [function_2] ||| [function_2] [function_1]	count=8
function	a thread ||| thread id	count=2
return	that didn t ||| $tuple_3$ $list$ a	count=1
function	other private [function_2] ||| [function_2] [function_1]	count=1
function_return	file [return_2] ||| [function_1] filepath [return_2]	count=1
module	device ||| io device	count=2
args	promote a function to ||| a5 r monad a1 monad	count=1
return	all elements ||| $list$	count=1
return	but ||| io	count=3
function	[function_1] fmap in ||| [function_2] [function_1]	count=2
function_args	[function_1] the number ||| [args_2] [function_1]	count=3
return	a and [return_2] ||| [return_2] [return_1]	count=1
function	size ||| size	count=1
function	unicode general [function_2] ||| [function_1] [function_2]	count=1
return	memory ||| foreignptr storable	count=2
args	number of elements from ||| int	count=2
args	a binary function ||| $f_3$ a b c applicative a applicative	count=1
return	arrow and copy the ||| arrow $tuple_3$ b d c	count=1
args	[args_1] realfloat value ||| [args_1] [args_2]	count=6
function_args	[function_1] readp to ||| [function_1] [args_2]	count=1
function	position of ||| seek	count=5
args	a ||| a $f_2$ ptr a io	count=2
function	filled with bytes ||| calloc array	count=1
args	a rational value into ||| rational	count=1
function_args	of show [args_2] ||| [args_2] [function_1]	count=1
function	the real ||| real	count=1
return	merging their ||| b b' either c c'	count=1
return	the action ||| io b	count=1
function	as throwerrnoif but ||| errno if	count=1
args	close p parses open ||| open	count=1
return	a type constructor ||| $tuple_2$ tycon	count=1
module	marshal these values into ||| marshal pool	count=1
function	system event manager ||| get system event manager	count=1
function	allocate ||| malloc	count=4
function	the find ||| find	count=1
args	and ||| string $list$ optdescr	count=1
module	utf-32 ||| system	count=2
return	io monad and ||| io	count=1
module	other ||| data char	count=1
function	of ||| a	count=1
return	using [return_2] ||| [return_2] [return_1]	count=1
function	throwerrnoifminus1retrymayblock but ||| throw errno if minus1retry may block_	count=1
function	is used to name ||| min	count=1
module	the elements of ||| data	count=2
function	[function_1] supplied write ||| [function_1] [function_2]	count=1
return	at the pointer living ||| io	count=2
args	file handle and ||| handle maybe	count=1
return	storable type in ||| io ptr storable	count=1
function	create a [function_2] ||| [function_1] [function_2]	count=2
function	an extra position to ||| malloc array0	count=1
return	returning the ||| io	count=1
module	[module_1] of seven-tuples ||| [module_1] [module_2]	count=1
module	the encoding ||| ghc io encoding	count=4
module	a ||| typeable	count=5
return	the buffer blocking ||| buffer	count=1
function	buffering mode ||| buffering	count=2
args	convert an int ||| int	count=1
function	[function] the ||| seek from [function]	count=2
args	a ||| d e $list$ a $list$ b $list$ c	count=1
function	index an [function_2] ||| [function_1] [function_2]	count=2
module	c byte ||| c	count=1
return	rest unchanged to the ||| $tuple_3$ b d c d	count=1
module	marshal these ||| foreign marshal pool	count=1
function_return	until data [function_1] [return_2] ||| [function_1] [return_2]	count=3
args	passing any value produced ||| $f_2$ a monad b	count=1
function	but only performs the ||| on	count=1
function	fork a thread ||| fork	count=1
args	to be returned ||| a $f_2$ a io $tuple_2$	count=1
function	in ordinary blocking mode ||| blocking	count=1
args	given number of ||| int $f_2$	count=1
function	the product ||| product	count=2
function	s heap is ||| heap	count=2
module	it yields the error ||| foreign c error	count=1
module	the current [module] until ||| [module]	count=1
args	the elemindex function returns ||| $list$ eq	count=1
function	duplicate of ||| duplicate	count=1
args	executed with ||| mvar a $f_2$ a io	count=1
return	that didn t ||| $tuple_3$ $list$	count=1
args	value typically the ||| b $list$ a	count=1
function	the first ||| first	count=2
args	entire list of ||| $list$	count=1
module	[module] seven-tuples analogous ||| [module]	count=1
function	caught c ||| just	count=1
function_return	[function_1] [return_2] ||| [function_1] io a [return_2]	count=2
function	returning the radix ||| radix	count=1
function	unset name removes the ||| unset env	count=1
function	[function_1] call stack ||| [function_1] [function_2]	count=1
function	new instance ||| new	count=1
return	pair in canonical ||| $tuple_2$ realfloat realfloat	count=1
args	lists of ||| $list$	count=1
return	merging their ||| b' either c c'	count=1
return	using the [return_2] ||| [return_2] [return_1]	count=1
return	io errors which ||| io either	count=1
return	the current value of ||| io a	count=1
return	[return_1] the io ||| [return_2] [return_1]	count=6
args	or more characters ||| char bool	count=2
module	[module_1] the end ||| [module_1] [module_2]	count=8
function	and ||| min	count=1
function	open [function_2] ||| [function_2] [function_1]	count=4
function	gets ||| show constr	count=1
return	into the buffer blocking ||| $tuple_2$ int buffer word8	count=1
args	the given type where ||| ioerrortype	count=1
module	io operation failed ||| io error	count=2
function	[function_1] type ||| [function_2] [function_1]	count=6
args	the ||| $f_2$ a io b	count=1
return	[return_1] value ||| [return_2] [return_1]	count=6
function	if the operation yields ||| throw errno if	count=1
function_return	[function_1] [return_2] ||| [function_1] wordptr [return_2]	count=1
module	c string into ||| c string	count=1
args	as ||| bits int	count=1
args	stablename that does ||| stablename b	count=1
module	a temporarily allocated ||| marshal	count=1
module	a ||| data	count=3
function	read a ||| read	count=1
function	handle a duplicate of ||| h duplicate to	count=1
args	where the return value ||| io a io	count=2
args	for the either type ||| a c $f_2$ b c either	count=1
return	to the [return_2] ||| [return_2] [return_1]	count=4
args	takes an exception ||| exception maybe b io	count=1
args	predicate ||| $f_3$ a a bool $list$ a	count=2
args	for the given number ||| int $f_2$ ptr storable io	count=1
module	whether gc stats ||| stats	count=1
args	and ||| $list$ optdescr	count=1
function	(*) [function] f ||| [function]	count=1
module	an ioerror ||| error	count=4
module	allocate ||| marshal	count=1
return	retagging and merging ||| b'	count=1
function_args	written to [args_2] ||| [function_1] [args_2]	count=7
args	given ||| ptr storable ptr storable	count=2
return	a [return_2] ||| [return_2] [return_1]	count=31
args	for handle ||| handle	count=2
return	the buffer to the ||| buffer word8	count=1
args	that takes an exception ||| exception maybe b io	count=1
args	the number of values ||| int ptr	count=1
function	channel managed by hdl ||| h get	count=2
function	wide ||| with cwstring len	count=1
function_return	lines breaks [return_2] ||| [function_1] string [return_2]	count=3
args	promote a function ||| r monad a1 monad a2	count=2
args	a ||| $f_2$ a monad b traversable a	count=2
function	position of hdl is ||| seek	count=3
module	from a ||| ghc	count=1
function	integral type with ||| w#	count=1
function_args	lift a [args_2] ||| [function_1] [args_2]	count=2
return	returns an either result ||| either	count=1
return	memory ||| foreignptr	count=1
module	[module_1] list argument ||| [module_1] [module_2]	count=2
return	value of the ||| io	count=1
return	for a given ||| a	count=1
function	line from the ||| h get line	count=1
function	like catch but it ||| catch	count=1
return	on the contents ||| io b	count=1
return	a value into the ||| a	count=1
args	elements of the list ||| $list$	count=1
return	[return] of every ||| [return]	count=3
function	a usererror if ||| if	count=1
return	rest unchanged to the ||| b d c d	count=1
module	name the upper ||| prelude	count=1
function	of show for ||| show	count=1
function	t waits [function_2] ||| [function_2] [function_1]	count=4
function	wait ||| thread wait	count=1
return	of lists ||| $list$ b $list$ c	count=1
function_return	looks up [return_2] ||| [return_2] [function_1]	count=3
args	in the given number ||| timeoutkey int	count=1
module	int ||| ghc exts	count=2
return	true if the ||| bool	count=6
module	maximum value [module] list ||| [module]	count=1
return	return a string ||| string	count=1
function	any type in class ||| rat	count=1
function	action with a ||| with pool	count=1
function_args	[function_1] number ||| [function_1] array0 pool [args_2]	count=1
return	the buffer ||| io buffer	count=1
return	but returns a ||| string $list$ string $list$ string	count=1
module	[module_1] only be ||| [module_2] [module_1]	count=1
function	privilege to ||| is permission	count=2
args	any value produced ||| a monad b	count=2
args	structure but ||| foldable	count=1
function_return	the lex [return_2] ||| [function_1] [return_2]	count=5
args	real ||| real real	count=3
args	a reverse application operator ||| a $f_2$ a	count=1
args	witharray but ||| ptr storable io b	count=1
module	a value from an ||| control	count=1
args	a block of memory ||| ptr a	count=1
return	rest through unchanged to ||| b d either c d	count=1
args	in the pool ||| pool ptr a	count=1
return	is used to ||| $tuple_2$ buffer from buffer to	count=2
function_return	uninterruptiblemask asynchronous ||| uninterruptible maskingstate	count=2
function	third value ||| trace show id	count=1
module	an object of ||| data	count=1
return	buffer to ||| buffer	count=1
args	for the either ||| $f_2$ b c either a b	count=1
args	list of storable values ||| storable io	count=1
function	the list by the ||| by	count=1
args	elements of ||| bool $list$	count=1
function	used to wait ||| wait	count=1
return	an either result which ||| io either	count=1
rep	foreign function [function_return_2] ||| [module_1] marshal alloc finalizer [function_return_2]	count=5
module	a ||| data data	count=1
function	file in binary ||| binary file	count=4
module	c string into ||| foreign c string	count=1
function	default file [function_2] ||| [function_2] [function_1]	count=1
return	of a storable ||| io ptr storable	count=2
return	read [return_2] ||| [return_2] [return_1]	count=2
module	ghc only ||| ghc conc	count=8
function	first component ||| first	count=1
args	a ||| c $list$ a	count=1
function	marshal a ||| peek cstring len	count=1
function	indicating whether the thread ||| thread	count=2
args	p parses open ||| open	count=1
return	the specified number of ||| io int	count=1
function	this accumulator together with ||| accum	count=3
return	to [return] ||| [return]	count=2
args	an unsigned integral type ||| word#	count=1
function_args	[function_1] string ||| [args_2] [function_1]	count=2
return	and also may ||| iodevicetype	count=1
function	of a type ||| min bound	count=1
args	a pointer to a ||| $f_2$ ptr storable	count=2
args	a curried function ||| a b c a	count=1
function	a pair ||| pair	count=1
module	library defines parser combinators ||| text parsercombinators	count=1
return	the ||| io a	count=1
return	a non-empty string ||| string	count=1
function	opens a file using ||| with binary file	count=1
function	finalizer ||| ptr finalizer env	count=4
function	a stack [function_2] ||| [function_1] [function_2]	count=3
args	header first argument and ||| string $list$ optdescr	count=1
args	structure ||| a b b b foldable	count=3
function	storage with ||| with	count=1
args	a list of marshalled ||| res $f_2$ b res $list$ a $f_2$ $list$	count=1
function	[function_1] read from ||| [function_1] [function_2]	count=1
args	well as four ||| d	count=1
function	bracket [function] ||| bracket [function]	count=2
function	except the last one ||| init	count=1
return	final value ||| a	count=1
return	a computation and ||| a	count=1
return	the buffer blocking if ||| io $tuple_2$ int buffer	count=1
args	pointer to a temporarily ||| storable $f_2$ ptr storable io	count=1
args	lists ||| eq $list$ eq	count=1
function	handle [function] encoding ||| [function] set	count=1
module	of [module] ||| [module]	count=2
args	their point-wise combination analogous ||| e	count=1
function	the size of ||| set size	count=1
args	pointer ||| $f_2$ ptr storable io	count=2
args	a ||| foldable a	count=1
return	which occur within a ||| ioerror a	count=1
args	stm actions ||| stm	count=1
args	takewhile applied [args] ||| [args]	count=1
function	bits ||| size maybe	count=1
return	a tuple where ||| a $list$ a	count=1
function_args	satisfying the [args_2] ||| [args_2] [function_1]	count=2
args	list ||| $list$ readprec	count=1
function	sets the ||| set	count=2
function	unzip transforms a list ||| unzip	count=1
args	is executed with ||| mvar	count=1
args	function returns ||| $list$	count=1
args	handle ||| handle string	count=1
module	delete ||| data list	count=1
args	predicate instead ||| a bool $list$	count=1
args	fresh memory pool which ||| $f_2$ pool io	count=1
function	[function_1] until data ||| [function_2] [function_1]	count=4
function	limits of a ||| min bound	count=1
function_return	list [return_2] ||| [return_2] [function_1]	count=3
function	error indicating that ||| error	count=1
args	version ||| a a	count=1
module	a parser ||| text parsercombinators	count=1
module	integral type with ||| ghc	count=1
args	return value from ||| io a io	count=2
return	character is available ||| char	count=2
args	of bytes without ||| word8	count=1
module	nul terminated c ||| c string	count=1
function_return	to [return_2] ||| [function_1] wordptr [return_2]	count=1
module	eventlog if eventlog profiling ||| debug trace	count=1
function	] representing the current ||| current	count=1
module	thread ghc only ||| ghc conc sync	count=2
return	[return] foreign pointer ||| [return]	count=3
args	representation ||| rep generic	count=1
function	stable ||| stable	count=4
args	the number of ||| int ptr	count=1
args	promote a function to ||| a3 a4 r monad a1	count=1
function_args	argument right [args_2] ||| [args_2] [function_1]	count=1
module	the same as ||| data	count=1
args	list of storable ||| storable io b	count=1
return	observe the argument ||| $list$ typerep	count=2
args	inside a ||| ptr a io b	count=2
function	void ||| void	count=1
args	given default format character ||| char	count=1
module	indicates where the array ||| marshal array	count=1
function_args	suspends the [function_1] [args_2] ||| [function_1] [args_2]	count=5
return	mkweak where the ||| weak k	count=2
args	rational value into ||| rational	count=1
return	true if the given ||| bool	count=1
function	is available to read ||| read	count=2
return	at the ||| io b	count=2
function	[function_1] the end ||| [function_2] [function_1]	count=2
function	was invoked with ||| fmt	count=1
args	nul terminated ||| cstring io	count=1
function	exists ||| exists	count=2
function	hdl returns the ||| h	count=1
return	function is used to ||| buffer to	count=2
module	hdl is set to ||| handle	count=3
function	the system event manager ||| get system event manager	count=1
return	after the ||| io b	count=1
args	return value ||| io a io b io	count=2
module	[module_1] of corresponding ||| [module_2] [module_1]	count=1
function_args	[function_1] of ||| [args_2] [function_1]	count=2
module	proxy type for ||| data proxy	count=1
args	non-options ||| argorder	count=1
module	like mallocarray but add ||| marshal array	count=1
args	with a ||| $f_2$ c	count=1
args	argument a pointer ||| storable $f_2$ ptr storable io	count=1
function	add an extra position ||| malloc array0	count=1
function	hputstr hdl ||| h put str	count=2
return	the pointer living inside ||| io b	count=2
args	given file descriptor ghc ||| fd	count=2
args	equality on stablename that ||| stablename a stablename b	count=1
module	combination of ||| utils	count=1
function	allocate storage for the ||| pooled malloc	count=2
return	an ioerror ||| ioerror	count=1
args	quadruples ||| $tuple_4$ a b c d	count=1
return	return a foreignptr ||| io foreignptr	count=2
args	that takes an exception ||| exception maybe	count=1
function	returns the conjunction ||| and	count=2
return	those that didn t ||| $tuple_3$ $list$ a	count=1
module	an io operation ||| system io error	count=1
function	managed by ||| h get	count=2
args	writes the [args] file ||| filepath [args]	count=1
module	error code eintr - ||| foreign c error	count=1
module	computation iseof ||| io handle fd	count=1
module	unrecognized options ||| system console	count=1
function	advances the given address ||| plus	count=1
function	to the corresponding ||| cchar to char	count=1
args	non-options a list of ||| argorder a $list$ optdescr a $list$ string	count=1
function	hfilesize hdl returns ||| h	count=1
args	pool ||| pool ptr storable	count=1
function	capability or not ||| capability	count=3
return	retagging and merging ||| b b' either	count=1
function	file using openbinaryfile and ||| with binary file	count=1
function	sign ||| sign plus	count=2
args	x returns the least ||| realfrac	count=1
module	application of the ||| data foldable	count=1
args	size as int ||| word#	count=1
return	handle ||| io handle	count=3
function	allocate space ||| pooled malloc	count=1
return	and merging their outputs ||| arrowchoice either b b' either c	count=1
function	line from ||| h get line	count=1
module	value and and ||| data	count=1
args	witharray but a ||| ptr storable io b	count=1
module	[module_1] of lists ||| [module_1] [module_2]	count=1
function	[function_1] timeout ||| [function_1] [function_2]	count=1
function	of a third value ||| show id	count=1
args	of a structure ||| foldable a	count=1
function	upper and lower limits ||| bound	count=1
module	marshal these values ||| marshal	count=1
return	a staticptr by ||| maybe staticptr a	count=1
function	an stm transaction ||| on stm	count=1
function	to name the ||| min bound	count=1
function_return	[function_1] the associativity ||| [function_1] [return_2]	count=2
module	increases ||| text parsercombinators readprec	count=1
args	scanning the ||| a4 monad	count=1
args	monad scanning the ||| monad a3 monad a4	count=1
module	event that an exception ||| control exception base	count=1
return	the size needed to ||| io ptr	count=1
return	that traverse is defined ||| traversable	count=1
module	was an [module_2] ||| [module_1] [module_2] bracket	count=1
function	an allocation counter that ||| set allocation counter	count=1
return	new handle ||| handle	count=1
function	[function] the ||| seek [function]	count=1
function	the radix of ||| radix	count=1
args	actions passing any value ||| a $f_2$ a	count=1
module	of foldl ||| data	count=1
function	a list ||| to list	count=1
module	any instance of ||| data fixed	count=1
function	at the given ||| ptr	count=2
return	a concrete poly-kinded ||| t	count=2
return	asynchronous exceptions ||| maskingstate	count=2
args	either type ||| c either a b	count=1
args	the either ||| b c either	count=1
return	bytes returning the ||| io	count=1
module	an internal function to ||| internal	count=1
return	given size ||| ptr a	count=1
return	mkweak where the value ||| $tuple_2$ weak k	count=1
module	and currency symbols ||| data char	count=1
function_args	if all [args_2] ||| [function_1] $f_2$ [args_2]	count=4
function	the [function] ||| [function] from	count=3
function	the unzip6 function takes ||| unzip6	count=1
return	elements of a container ||| a	count=1
module	the ||| data data	count=2
args	explicit length ||| cstringlen	count=1
function_args	[function_1] [args_2] ||| [function_1] m_ [args_2]	count=1
args	the return value ||| a io b io c	count=2
module	as ||| bits	count=1
args	pool to ||| pool ptr a int	count=1
return	of memory ||| io ptr storable	count=1
function_return	[function_1] [return_2] the structure l ||| [function_1] [return_2]	count=4
function_return	[function_1] original handle ||| [return_2] [function_1]	count=2
args	a reverse ||| $f_2$ a b	count=1
function	of the exception type ||| exception	count=1
args	type char ||| char	count=1
function	or returns the disjunction ||| or	count=2
function_return	[function_1] value ||| [return_2] [function_1]	count=1
function	of megabytes allocated | ||| megabytes allocated	count=1
function	marshal a ||| cstring	count=2
function	[function_1] wide ||| [function_2] [function_1]	count=2
function	arbitrary ||| make	count=1
function	putmvar ||| put	count=1
module	chainl ||| parsercombinators readp	count=1
function	option ||| option	count=1
args	the pool to the ||| pool ptr	count=1
return	just a [return_2] ||| [return_2] [return_1]	count=2
args	manager thread ||| eventmanager fdkey	count=1
module	integral type with ||| exts	count=1
args	explicit length information ||| $f_2$ cstringlen io a	count=2
function_args	[function_1] [args_2] monadic action evaluate these ||| [function_1] [args_2] monad traversable b	count=1
function	system event manager ||| system event manager	count=1
args	fresh memory pool which ||| pool	count=1
function	thread [function_2] ||| [function_1] [function_2]	count=11
args	storable values in memory ||| storable io	count=1
args	a ||| g $list$ a $list$ b $list$	count=1
return	a ||| $list$ a $list$ b	count=2
return	a computation and ||| ioerror a	count=1
return	to true ||| bool	count=1
args	argument and ||| $list$ optdescr a	count=1
function	-0 ||| encode float	count=1
return	new handle ||| io handle	count=1
args	the field ||| fieldformat	count=1
args	for the either ||| a c $f_2$ b c either	count=1
return	key value pairs ||| $tuple_2$ string string	count=1
function	ordinary blocking mode ||| blocking	count=1
args	pointer living inside a ||| ptr a io	count=2
module	fresh memory ||| foreign marshal pool	count=1
module	strict application of the ||| data	count=1
module	and all other ||| data	count=1
return	of returned tvar to ||| io tvar	count=1
args	of storable values in ||| $f_2$ ptr storable io b	count=1
module	given parser ||| text parsercombinators readp	count=2
return	the buffer to the ||| buffer	count=1
return	can throw out elements ||| $list$	count=1
function	a file ||| regular file	count=1
return	modifies [return] ||| [return]	count=1
function	allocate a fresh ||| pool	count=1
function_return	[function_1] the datatype ||| [return_2] [function_1]	count=1
function	length into ||| peek	count=1
function	supplied write ||| write buffer0	count=1
args	string using ||| textencoding string	count=1
function	nullptr ||| null	count=1
function	written to ||| write	count=6
module	lower limits ||| prelude	count=1
args	returned ||| $f_2$ a io $tuple_2$	count=1
return	complex ||| complex floating	count=1
return	rest through unchanged to ||| c d	count=1
return	original handle ||| io handle	count=1
module	have direct support for ||| ghc io	count=1
function	the upper ||| min bound	count=1
args	integral type ||| word#	count=1
function	the given ||| ptr	count=3
args	given number of ||| int $f_2$ ptr	count=1
module	and a list ||| list	count=1
module	for the io ||| ghc io	count=4
args	file handle and file ||| maybe handle	count=1
module	io operation failed because ||| io	count=3
args	promote a function ||| a4 r monad a1 monad a2 monad a3	count=1
args	given type where the ||| ioerrortype	count=1
args	value ||| a $f_2$ a monad	count=1
function	div to any ||| div'	count=1
function	the int [function_2] ||| [function_2] [function_1]	count=1
return	a ||| a $list$	count=3
function	ie [function_2] ||| [function_2] [function_1]	count=8
function	end of ||| end	count=2
function	allocation counter ||| allocation counter	count=1
module	a list [module_2] ||| [module_1] [module_2]	count=5
return	second argument as a ||| a	count=2
args	open ||| open	count=1
args	scanning ||| a3 monad a4	count=1
args	a ||| a a	count=2
function	to the finalizer ||| foreign ptr finalizer env	count=2
function	sign of a numeric ||| sign plus	count=1
function	used ||| min	count=1
args	passing any value produced ||| a	count=1
return	traverse ||| traversable	count=1
return	[return_1] a quadruple ||| [return_2] [return_1]	count=2
return	the supplied [return_2] ||| [return_2] [return_1]	count=1
module	encode ||| ghc io encoding	count=1
function	the default ||| default	count=1
function	root of the exception ||| exception	count=1
args	handle and ||| maybe handle	count=1
return	current value ||| a	count=2
module	lists ||| list	count=1
module	convert a c byte ||| foreign c string	count=1
module	only be ||| conc	count=1
function	mark ||| mark	count=4
return	the ||| io maybe	count=1
module	is ||| ghc exts	count=2
function	a list using ||| list with	count=1
function	sequence ||| sequence	count=1
return	foreignptr to it ||| io foreignptr	count=2
args	> string ||| $f_2$ string string	count=1
return	a [return_2] ||| [return_1] [return_2]	count=1
args	takes an exception ||| exception maybe b	count=1
args	to a monad scanning ||| monad a2 monad a3 monad a4 monad a5	count=1
args	list of storable ||| $f_2$ ptr storable	count=1
function	right by the specified ||| r	count=1
function	slides the ||| slide	count=1
args	a fresh memory pool ||| pool	count=1
function_args	[function_1] [args_2] of bits in the ||| [function_1] [args_2]	count=5
function	the float [function_2] ||| [function_1] [function_2]	count=1
args	issuffixof ||| $list$ eq	count=1
args	given number of ||| ptr a int	count=2
args	where the ||| ioerrortype string maybe	count=1
return	string ||| string	count=8
module	values ||| text read	count=2
function	a usererror if the ||| if	count=1
return	comp exposes io ||| io either	count=1
args	a structure to a ||| a	count=2
function	managed by ||| h	count=2
module	applied to a ||| oldlist	count=1
return	[return_1] a monad ||| [return_2] [return_1]	count=2
function	elements to drop ||| drop	count=1
args	passes the resulting handle ||| handle io	count=1
function	accumulator together with ||| accum l	count=2
function	character to the ||| to	count=1
function_args	ceiling [args_2] ||| [function_1] [args_2]	count=3
return	given size of the ||| io ptr	count=1
args	a structure ||| foldable a	count=7
function	catch but it ||| catch	count=1
function_args	[function_1] [args_2] ||| [function_1] ffloat alt maybe [args_2]	count=6
module	this exception is raised ||| control exception	count=2
function	wall ||| wall	count=3
args	for the either type ||| $f_2$ b c either a	count=1
module	[module] context ||| [module]	count=1
function	base ||| show int at base	count=2
return	is used ||| buffer	count=2
function	[function_1] category ||| [function_1] [function_2]	count=3
args	this is a ||| foreignptr	count=2
module	within ||| conc sync	count=1
function	read from a ||| read stm	count=1
args	pointer ||| storable $f_2$ ptr	count=1
args	a signed [args_2] ||| [args_2] [args_1]	count=8
module	example accents and the ||| data	count=1
args	the pool to the ||| pool	count=1
function	of this accumulator together ||| accum l	count=1
function	int ||| w#	count=1
args	six-tuples ||| c d e f	count=1
function_return	written to the ||| write fd io	count=2
module	an overloaded version of ||| data	count=2
function	bit of the argument ||| bit	count=1
module	c byte representing ||| foreign c	count=1
module	is used ||| prelude	count=1
return	plain memory reference into ||| foreignptr	count=2
return	[return_1] number of ||| conc get num capabilities [return_1] [return_2]	count=2
args	the handle ||| handle ptr a int	count=2
args	a ||| monad b b foldable a	count=1
args	is encapsulated in a ||| b foldable a	count=1
function	a timeout in the ||| timeout	count=1
function	string [function_1] [function_2] information ||| string [function_2] [function_1] string $f_2$ cstringlen io	count=2
function	intersect ||| intersect	count=1
module	instead of the ||| data	count=1
function_args	[function_1] signed realfloat ||| [function_1] float [args_2]	count=1
function	[function_1] file ||| [function_2] [function_1]	count=6
function	if the operation ||| throw errno if	count=1
return	determines whether ||| bool	count=1
args	true ||| $f_2$ a bool	count=1
return	computation into [return_2] ||| st [return_1] [return_2]	count=3
args	function ||| b	count=2
args	copy [args_1] [args_2] ||| [args_1] [args_2]	count=4
args	a conversion scheme ||| io textencoder estate	count=1
function	[function_1] bounds ||| [function_1] [function_2]	count=5
module	same as ||| data bits	count=1
return	a collection ||| alternative a	count=1
return	into the buffer ||| io $tuple_2$ int buffer word8	count=1
function	a line from ||| h get line	count=1
function	rotate [function] ||| rotate [function]	count=2
args	the ||| $f_2$ a a	count=1
module	of that ||| data typeable	count=2
function	[function_1] allocation ||| [function_1] [function_2]	count=2
args	a reverse application operator ||| a $f_2$ a b	count=1
function	[function_1] copied each ||| [function_1] [function_2]	count=4
function	hdl as ||| h	count=1
function	error [function_2] ||| [function_2] [function_1]	count=2
args	a binary function ||| applicative a	count=1
module	marshal [module_2] ||| [module_1] [module_2]	count=4
function	version of takemvar ||| take	count=1
return	reads an unsigned realfrac ||| reads realfrac	count=1
module	of all ||| data	count=2
args	a value ||| traversable a	count=1
module	allocated ||| marshal	count=2
args	as four ||| d	count=1
args	the either type ||| either a b	count=1
module	parser ||| parsercombinators	count=2
function	a list using ||| list	count=1
return	an either result ||| either	count=2
args	handle to ||| iomode $f_2$ handle io	count=1
return	original handle with its ||| handle	count=1
args	to a monad scanning ||| a3 monad a4 monad	count=1
function	used ||| min bound	count=1
args	converts a rational value ||| rational	count=1
return	[return_1] given size ||| [return_1] [return_2]	count=2
function_args	[function_1] the ||| [function_1] mvar a [args_2]	count=4
args	into a c string ||| string $f_2$	count=1
args	any value ||| $f_2$ a monad b	count=1
module	the operation failed because ||| io error	count=5
module	object of ||| data	count=1
args	any value produced by ||| a $f_2$ a monad	count=1
args	conditionally prove the ||| testcoercion	count=1
function	getargs return args ||| args	count=1
function	until data can be ||| wait	count=2
args	adds a new invariant ||| a	count=2
args	curried function ||| $f_2$ $tuple_2$ a b c	count=1
function_return	[function_1] for the ||| [function_1] encoding handle textencoding [return_2]	count=3
args	handle ||| maybe handle maybe filepath	count=1
module	the error code eintr ||| foreign c error	count=1
function	first argument ||| first	count=1
module	[module_1] arrow ||| [module_1] [module_2]	count=4
args	handle to ||| $f_2$ handle io	count=1
args	a ||| $f_3$ a b c applicative a	count=1
function	as x ||| bit	count=1
args	typeable allows a concrete ||| typeable	count=1
args	size as ||| word#	count=1
function	[function_1] if the ||| [function_1] [function_2]	count=4
args	the mapmaybe [args_2] ||| [args_2] [args_1]	count=3
return	lists ||| $list$ $list$	count=1
function	a duplicate of the ||| h duplicate	count=1
module	new ||| ghc conc	count=1
return	value is ||| a	count=2
args	return value ||| io a io b	count=2
return	the result value ||| a	count=1
args	given number of elements ||| ptr storable ptr storable int	count=2
args	catch any ioerror ||| $f_2$ ioerror ioerror io	count=1
return	a circular one ||| $list$ a	count=1
function	the unzip7 ||| unzip7	count=1
return	merging their ||| b b'	count=1
return	for the ||| io ptr	count=1
return	occur within a computation ||| ioerror a	count=1
function	count ||| count	count=2
module	into an object of ||| data dynamic	count=1
function_return	lex function [return_2] ||| [return_2] [function_1]	count=5
function	so far ||| max	count=2
function	is the same ||| bit	count=1
return	[return_1] number of ||| concurrent get num capabilities [return_1] [return_2]	count=2
args	character ch to the ||| handle char	count=1
module	applicative functor ||| applicative	count=1
module	recover ||| encoding types	count=1
module	for the specified handle ||| ghc io	count=1
args	number of ||| int $f_2$ ptr storable io b	count=1
args	value typically ||| b $list$ a	count=1
function	but only performs ||| on	count=1
return	the ||| io bool	count=2
return	value of funptr that ||| funptr a	count=1
function	map and foldr ||| map	count=1
args	of storable ||| storable $f_2$ ptr storable	count=1
return	all the elements ||| $list$	count=1
module	right and ||| data	count=1
return	of value zero ||| io ptr a	count=1
args	stored in a tvar ||| tvar a	count=2
function_return	lex function reads ||| lex reads	count=1
module	promotable proxy ||| proxy	count=1
function	wide string with explicit ||| cwstring len	count=1
args	handle ||| handle maybe	count=1
return	returns a tuple ||| $tuple_2$ $list$ a $list$ a	count=1
function_args	[function_1] readp ||| [args_2] [function_1]	count=1
module	that [module_2] ||| [module_1] [module_2]	count=6
function	represent ||| left associative	count=1
args	the file handle and ||| handle maybe filepath	count=1
return	handle is created with ||| handle	count=1
args	integral number [args] the ||| [args] int char	count=1
function	throwerrnoifminus1retrymayblock but ||| errno if minus1retry may block_	count=1
args	witharray but a ||| $list$ storable $f_2$ ptr storable io b	count=1
function	superclass for asynchronous ||| some async	count=1
args	value ||| io a io b	count=2
args	mode [args] or ||| handle [args]	count=2
function	mallocarray0 ||| array0	count=1
return	in the ||| io	count=4
return	takes a predicate a ||| a	count=1
args	this is a way ||| foreignptr a	count=2
function	sign of a ||| sign	count=1
args	pointer ||| $f_2$ ptr	count=2
function	given path when appropriate ||| errno path	count=3
module	an io operation ||| io error	count=2
function_args	with [args_2] ||| string [function_1] cstring len string [args_2]	count=1
args	passing any value produced ||| a $f_2$ a monad	count=1
module	posix ||| system posix	count=1
function	the error message if ||| error	count=1
module	open ||| io handle fd	count=2
function	radix of the ||| float radix	count=1
module	results of ||| data	count=1
function	[function_1] permissions ||| [function_1] [function_2]	count=3
args	promote a function ||| a4 r monad a1 monad a2	count=1
args	discarding any value produced ||| monad a monad	count=1
function	extra position ||| malloc array0	count=1
return	[return_1] staticptr by ||| [return_2] [return_1]	count=2
return	phase pair ||| $tuple_2$	count=1
function	channel managed ||| h get char	count=2
args	an int in ||| int	count=1
module	value of an ||| data	count=1
function	of the module where ||| module	count=1
args	hseek hdl mode i ||| seekmode integer	count=1
module	operation yields the error ||| foreign c error	count=1
return	return a foreignptr ||| foreignptr	count=2
function	outside its declared bounds ||| out of bounds	count=1
function	given [function_2] ||| [function_2] [function_1]	count=4
module	to right and ||| data	count=1
args	structure ||| b b b foldable	count=3
return	of type ptr ||| ptr	count=1
return	returns the number ||| int	count=7
module	monoid returning the ||| data monoid	count=1
function	[function] place in ||| touch foreign [function]	count=6
args	of a structure ||| foldable num	count=2
function	used to ||| min bound	count=1
function	to ||| to char	count=1
function_args	suspends the current [function_1] [args_2] ghc only ||| [function_1] [args_2]	count=2
args	to a monad scanning ||| a3 monad a4	count=1
module	scanr that ||| list	count=1
function	about to ||| finally	count=1
args	like witharray but a ||| $list$ storable $f_2$ ptr storable io	count=1
function	sets ||| set	count=3
args	the issuffixof ||| $list$ eq	count=1
return	io computation ||| io a	count=1
return	a string describing the ||| string	count=1
return	of value zero ||| a	count=1
args	given number ||| int $f_2$ ptr	count=1
module	fmap ||| data traversable	count=1
function	[function_1] not possible ||| [function_2] [function_1]	count=2
return	the pair of lists ||| a $list$	count=1
return	the io monad ||| io string	count=1
module	in [module_2] ||| [module_2] [module_1]	count=1
return	code for the ||| io	count=2
function	file using openbinaryfile ||| binary file	count=1
return	convert a [return_1] [return_2] ||| [return_1] [return_2]	count=4
args	type string- > string ||| $f_2$ string string	count=1
return	pair in canonical ||| $tuple_2$ realfloat	count=1
function	set to offset ||| relative	count=2
module	monad ||| control monad st	count=5
return	returns a quadruple consisting ||| a $list$ string $list$ string $list$ string	count=1
args	> string as its ||| $f_2$ string string	count=1
args	list of storable ||| ptr storable	count=1
function	filled ||| calloc	count=1
module	iff the first list ||| list	count=2
function	storage in ||| pooled	count=1
module	the suffix of ||| data	count=1
args	a nul terminated ||| cstring io	count=1
args	file descriptor ||| fd	count=9
module	[module] its ||| [module]	count=2
args	[args_1] openfile ||| [args_2] [args_1]	count=2
return	in arrow notation ||| arrow b b	count=1
return	mkweak where ||| $tuple_2$ weak k	count=1
module	p [module] xs ||| data [module]	count=1
args	default format character ||| char	count=1
args	non-empty ||| $f_3$ a a	count=1
args	more characters ||| char bool	count=2
function_args	[function_1] [args_2] ||| [function_1] buf handle [args_2]	count=1
return	at the pointer living ||| io b	count=2
return	memory ||| storable	count=2
module	marshal these ||| marshal pool	count=1
args	to an action ||| $f_2$ a applicative	count=1
module	trace ||| rts flags	count=2
module	an mvar ||| control concurrent mvar	count=1
module	accents and the like ||| data	count=1
function	map and foldl ||| map	count=1
args	the ||| k maybe io	count=1
module	a valid memory ||| foreign	count=1
args	a ||| b c applicative a applicative	count=1
module	p [module] ||| data [module]	count=1
args	living inside a ||| a $f_2$ ptr a	count=2
function_args	storage for [args_2] ||| [function_1] malloc array pool [args_2]	count=2
function	new instance ||| new chan	count=1
args	[args_1] [args_2] ||| [args_1] $f_2$ [args_2]	count=7
return	size of the ||| io ptr	count=1
return	the action ||| io	count=1
function	heap is ||| heap	count=2
return	size of the required ||| io ptr storable	count=1
function	register a [function_2] ||| [function_1] [function_2]	count=3
return	[return_1] either result ||| [return_2] [return_1]	count=2
function	a [function] or ||| [function] bad	count=1
return	to continue ||| to	count=2
function	on [function_2] ||| [function_1] [function_2]	count=2
args	a returned value ||| a	count=1
return	reads an unsigned ||| reads	count=1
return	a complex number from ||| complex floating	count=1
args	on stablename ||| stablename a stablename	count=1
return	number ||| int	count=17
function	[function_1] is already ||| [function_2] [function_1]	count=8
return	a ||| a b c d e f	count=1
args	handle is in binary ||| handle	count=2
function	prefix of the second ||| prefix of	count=1
function_return	[function_1] [return_2] ||| [function_1] file size handle [return_2]	count=3
args	takes an exception ||| exception	count=1
args	a monad scanning ||| monad a3 monad a4	count=1
args	file handle and file ||| string maybe handle maybe	count=1
function	left = ||| left	count=1
args	predicate ||| a a bool $list$	count=1
function	numerator ||| numerator	count=1
module	x ||| data	count=1
return	the pointer living ||| io	count=2
args	any value produced by ||| a $f_2$ a monad b	count=1
args	inside a ||| ptr a io	count=2
args	a nul terminated ||| $f_2$ cstring	count=1
module	first occurrence of ||| data	count=1
return	returns a quadruple consisting ||| string $list$ string	count=1
args	structure ||| foldable	count=21
module	and lower limits of ||| prelude	count=1
function	all subsequences ||| subsequences	count=1
function	use traceevent or traceeventio ||| event	count=1
function	is actually a pair ||| mk weak pair	count=1
args	given number of ||| storable ptr storable int	count=2
module	current ||| ghc io encoding types	count=1
args	analysis for the either ||| c $f_2$ b c either a	count=1
function	the zip7 function takes ||| zip7	count=1
return	a chan the ||| io chan a	count=2
args	of storable values ||| ptr storable io	count=1
function_return	[function_1] complex ||| [function_1] floating [return_2]	count=1
return	arrows retagging and merging ||| b b' either c	count=1
args	the either ||| c either a b	count=1
function	sign of a numeric ||| sign	count=1
args	fresh memory pool which ||| $f_2$ pool io b	count=1
args	is an abstract ||| threadid#	count=2
function	newline [function_2] ||| [function_1] [function_2]	count=1
args	given marker element ||| storable $list$ storable	count=1
function	to a terminal? ||| terminal device	count=2
module	allocate a ||| marshal	count=1
args	a ||| $list$ a $list$ b	count=2
args	using [args_2] ||| [args_2] [args_1]	count=10
module	failed because the end ||| system io	count=1
args	monad scanning the ||| monad a3 monad a4 monad	count=1
return	evaluate tycon ||| tycon	count=2
return	the copied areas ||| io	count=2
module	from a list ||| data list	count=2
function	hgetbufnonblocking hdl buf ||| non blocking	count=2
function	system [function_2] ||| [function_2] [function_1]	count=2
function_args	[function_1] [args_2] bits in the type ||| [function_1] [args_2] bits	count=3
function_args	[function_1] hierarchy ||| [args_2] [function_1]	count=3
function	read an ||| read	count=2
function	counter that tracks ||| counter	count=1
args	a ||| a b c applicative a applicative	count=1
return	b ||| b	count=1
args	[args] line ||| [args]	count=1
args	to be returned ||| a $f_2$	count=1
args	a monad scanning the ||| monad a4	count=1
args	a structure ||| a b b foldable a	count=3
module	explicitly ||| foreign foreignptr	count=1
module	monoid ||| data monoid	count=2
function	finalizer cf foreignptr ||| finalizer	count=1
module	to a sequence of ||| data	count=1
module	position of hdl ||| ghc io handle	count=1
return	a type constructor application ||| tycon $list$	count=1
return	nul terminated c ||| cstring	count=1
args	a ||| applicative a applicative	count=1
return	threadid [return_2] ||| [return_2] [return_1]	count=4
return	[return_1] to continue ||| [return_2] [return_1]	count=6
function_return	[function_args_1] into ||| [return_2] [function_args_1]	count=1
module	applied to ||| oldlist	count=1
args	[args_1] race-safe way ||| [args_2] [args_1]	count=2
module	of a ||| data	count=9
return	output in ||| io	count=1
return	[return_1] chan ||| [return_2] [return_1]	count=4
module	getopt ||| getopt	count=1
return	can throw out elements ||| $list$ b	count=1
args	nul terminated c ||| cstring	count=1
module	into a c ||| c	count=4
module	lower limits of ||| prelude	count=1
module	into an [module] by ||| [module]	count=1
args	in a tvar ||| tvar a	count=2
module	involved in the ||| system io	count=1
function	freely intersperse ||| permute	count=1
args	copy [args] ||| [args]	count=1
args	conditionally prove ||| a testcoercion b	count=1
function	of geterrno [function_2] ||| [function_1] [function_2]	count=5
return	value as the ||| $list$ a	count=1
args	a ||| f g $list$ a $list$ b $list$ c	count=1
module	operation failed because the ||| io	count=2
function	[function_1] [function_2] ||| [function_1] for [function_2]	count=1
return	into the buffer ||| buffer	count=2
function	slides the [function_2] ||| [function_1] [function_2]	count=3
args	a ||| $f_3$ a b c applicative a applicative	count=1
return	the rest unchanged ||| d	count=1
function	-1 ||| minus1	count=1
args	lifetime lt ||| lifetime	count=1
function	and lower limits of ||| bound	count=1
return	to the specified number ||| int	count=1
args	is ||| bits int	count=1
args	maximum [args] ||| [args]	count=1
return	the computation f ||| io	count=1
return	buffer to the ||| io buffer	count=1
args	typerep ||| typerep typerep	count=2
function	a signed ||| signed	count=1
function	right ||| r	count=3
args	storable values in memory ||| storable $f_2$ ptr storable io	count=1
function_args	[function_1] elements of ||| [function_1] $f_2$ [args_2]	count=4
module	from the environment ||| system environment	count=1
args	the return value ||| io a io b io	count=2
module	into a c wide ||| c string	count=1
return	return a foreignptr to ||| foreignptr	count=2
rep	the [function_return_2] ||| [module_1] [function_return_2]	count=8
args	int ||| word#	count=1
function	find ||| find	count=1
args	a monad scanning ||| a3 monad a4 monad a5	count=1
args	scanning the ||| a4 monad a5	count=1
return	a stablename for ||| io stablename a	count=3
args	to be returned ||| a $f_2$ a io	count=1
function	the finalizer ||| ptr finalizer	count=2
function	thread s stack ||| stack	count=2
module	parser combinators for ||| parsercombinators	count=1
function	a file using ||| file	count=1
function	fresh memory ||| new pool	count=1
return	newforeignptr adds a finalizer ||| a	count=1
function	write a new ||| write	count=1
args	on stablename that does ||| a stablename b	count=1
return	of type funptr ||| funptr	count=1
module	as ||| data	count=1
module	for use ||| ghc	count=1
function	this accumulator together with ||| map accum l	count=1
args	passing any value ||| a	count=1
return	the number ||| int	count=11
return	returns the ||| io	count=4
return	as a finalizer to ||| a	count=2
function	unwords ||| unwords	count=1
args	same as ||| int	count=1
function	scanr is ||| scanr	count=1
function	timeout to ||| timeout	count=1
module	container ||| foldable	count=3
module	position of hdl ||| io handle	count=1
function	or channel managed ||| h	count=2
function	of cpus ||| get num processors	count=2
args	non-options a ||| argorder a $list$ optdescr	count=1
args	where the return value ||| a io b	count=2
args	applied [args] p ||| [args]	count=1
function	the denominator is positive ||| denominator	count=1
args	string using temporary storage ||| textencoding string	count=1
return	of ||| $list$	count=1
module	a value from an ||| control concurrent mvar	count=1
function	[function] comparison function ||| minimum [function]	count=3
args	storable ||| storable $f_2$ ptr storable	count=1
module	standard decimal notation for ||| numeric	count=2
args	integral ||| integral $list$ a	count=3
function	from hdl or for ||| h	count=1
function	all determines if all ||| all	count=1
function	and lower limits ||| min	count=1
function_args	a file [args_2] ||| [args_2] [function_1]	count=8
return	specified number ||| io int	count=1
args	a ||| b foldable a	count=1
return	a pair ||| b a	count=1
function	lex function ||| lex	count=1
function	represent the ||| prefix	count=1
function	heap is ||| heap overflow	count=2
module	allocate a fresh ||| foreign	count=1
function_args	[function_1] for handle ||| [args_2] [function_1]	count=4
return	[return] non-negative ||| [return]	count=1
function_args	[function_1] the string ||| [function_1] put str [args_2]	count=1
args	a maybe value ||| b $f_2$ a b maybe a	count=1
return	the functor class is ||| functor b	count=2
function	symmetry ||| sym	count=1
args	signed realfloat ||| realfloat	count=1
args	a ||| a $list$ b $list$ c $list$ d $list$	count=1
function	read ||| read dec	count=2
module	of a key ||| data	count=1
function	uses the default file ||| file with default	count=1
module	arrow ||| control arrow	count=1
module	that an io ||| system io error	count=1
args	bits in the argument ||| bits	count=1
return	to the given size ||| io ptr a	count=1
return	current value of ||| ptr a	count=1
function	of hdl as ||| h	count=1
function	throwerrnoifminus1retrymayblock but discards ||| throw errno if minus1retry may block_	count=1
return	parser for versions ||| readp version	count=1
return	the computation ||| io	count=6
function_return	count [return_2] ||| [return_2] [function_1]	count=2
module	unsigned integral type with ||| ghc	count=1
function	file ||| file	count=13
args	computation ||| io b	count=1
return	sum of a collection ||| alternative a	count=1
function	the traceevent function behaves ||| event	count=1
function	v ||| v	count=1
return	[return_1] threadid ||| [return_2] [return_1]	count=1
return	list of ||| $list$	count=2
return	final value ||| a traversable c	count=1
args	a ||| $f_2$	count=1
args	number [args] the ||| [args] int char	count=1
return	parses ||| readp	count=3
module	as ||| ghc	count=1
function_return	[function_1] [return_2] ||| [function_1] wordptr ptr [return_2]	count=1
args	a pointer to ||| storable $f_2$ ptr storable io b	count=1
args	a ||| a $f_2$ ptr a io b	count=2
function	the native ||| native	count=2
function_return	free which [return_2] ||| [return_2] [function_1]	count=5
module	combination of malloc and ||| utils	count=1
function	storage ||| pooled new array	count=1
args	where the return value ||| a io b io	count=2
return	[return_1] the monadic ||| [return_2] [return_1]	count=2
module	contents of ||| data ioref	count=2
function	its arguments already ||| is already	count=1
return	of funptr ||| funptr	count=1
return	and merging their outputs ||| arrowchoice either b b' either	count=1
return	storable ||| ptr storable	count=3
module	representation of ||| data	count=2
return	a character is ||| io char	count=1
function	value to full precision ||| float	count=1
module	the same ||| ghc	count=1
module	terminating the program ||| system io	count=1
return	observe the argument ||| typerep	count=2
function	hdl to [function_2] ||| [function_1] [function_2]	count=4
args	given ||| ptr a ptr	count=2
function	read on ||| read	count=1
args	a structure ||| a b b b foldable a	count=3
args	realfloat value using ||| realfloat	count=1
args	memory pool which ||| $f_2$ pool io b	count=1
args	elemindex function returns the ||| eq $list$ eq	count=1
function	thread ||| thread id	count=2
args	[args] maximum value ||| [args]	count=1
args	handle and ||| string maybe handle maybe filepath	count=1
args	the given number of ||| ptr a int	count=2
return	adds a ||| a	count=1
args	return value ||| a	count=2
function	source location ||| src loc	count=1
args	readparen [args] p parses ||| [args]	count=1
args	monads ||| a $list$ b	count=1
function	size of the ||| size	count=1
function_return	the resultant [return_2] ||| [return_2] [function_1]	count=2
args	and ||| string $list$	count=1
return	the argument arrow and ||| arrow	count=1
module	the reverse order of ||| data	count=1
return	list into a ||| a	count=1
return	buffer blocking if ||| io $tuple_2$ int buffer word8	count=1
module	the representation ||| io	count=1
function_args	[function_1] using openfile ||| [function_1] filepath [args_2]	count=4
args	structure to an ||| b foldable	count=1
function	if ||| throw errno if	count=1
args	promote a function ||| a3 a4 a5 r monad a1	count=1
args	the given number ||| int $f_2$ ptr storable io	count=1
args	function is a version ||| b $list$ a	count=1
module	the suffix of ||| data list	count=1
module	the datatype to its ||| ghc generics	count=1
module	block of memory ||| foreign marshal alloc	count=1
args	passing any value ||| a monad b	count=1
args	number ||| timeoutkey int	count=2
function	trace [function_2] ||| [function_2] stack [function_1]	count=2
module	causes ||| foreignptr safe	count=1
return	type char ||| char	count=1
args	[args] value ||| [args] a a a	count=4
args	string- > string ||| string string	count=1
function	a pair of ||| weak pair	count=1
return	computation to ||| s	count=4
function	name of [function_2] ||| [function_2] [function_1]	count=4
module	an mvar put ||| control concurrent mvar	count=1
function_args	satisfying the predicate ||| munch1 $f_2$	count=1
function	map which can ||| map maybe	count=1
args	a monad scanning the ||| a4 monad a5	count=1
function	end of the file ||| end	count=1
return	copy the rest unchanged ||| $tuple_3$ b d c d	count=1
function	is [function_2] ||| [function_1] [function_2] in use	count=4
module	recover ||| io encoding types	count=1
args	number of ||| int $f_2$ ptr storable io	count=1
module	for the specified handle ||| ghc	count=1
function	[function_1] pointer ||| [function_1] [function_2] finalizerptr a	count=4
args	and ||| $list$ optdescr a	count=1
module	value from an ||| control concurrent	count=1
args	with a pure function ||| $f_2$ c d arrow	count=1
module	the list of those ||| data list	count=1
function	size of ||| set size	count=1
function	of elements of a ||| array	count=1
function_return	[function_1] [return_2] ||| [function_1] int [return_2]	count=4
function	of show ||| show	count=2
function	[function] on ||| native [function]	count=1
function_args	[function_1] elements of ||| [args_2] [function_1]	count=4
args	a reverse application ||| a $f_2$ a	count=1
args	function to a ||| a b	count=1
function_return	the action hsetencoding hdl [function_1] [return_2] ||| [function_1] [return_2]	count=3
args	the string ||| handle string	count=1
function_args	storage for [args_2] ||| [function_1] malloc array0 pool [args_2]	count=2
args	the given number of ||| ptr storable ptr storable int	count=2
return	a ||| a b c d e f g	count=1
args	handle and file path ||| handle maybe	count=1
function	performs the final ||| on error	count=1
function	index an array ||| index	count=1
args	[args_1] handle to ||| [args_2] [args_1]	count=3
args	value from the ||| a io b io c	count=2
function	computes the product of ||| product	count=1
args	to a curried ||| c a b	count=2
module	number of elements to ||| data	count=1
return	after the action ||| io b	count=1
module	contents of ||| data	count=2
args	the [args] hdl ||| [args]	count=1
args	type with the ||| word#	count=1
args	function casts a ||| a	count=1
args	the either type ||| either a	count=1
return	is used to ||| buffer from buffer to	count=2
return	the size ||| io	count=2
return	is the non-overloaded version ||| $list$ a	count=2
function	sparks currently in ||| sparks	count=2
return	their outputs ||| arrowchoice either b c	count=1
function	with ||| with pool	count=2
args	of storable values ||| storable io	count=1
module	composition of ||| ghc	count=1
function	recover function is ||| recover	count=2
return	monadic arguments from ||| monad	count=1
return	binary function to actions ||| applicative c	count=1
module	dual of ||| data	count=1
module	ghc [module_2] ||| [module_1] [module_2]	count=14
args	file handle ||| maybe handle	count=1
function_args	[function_1] signed ||| [function_1] gfloat [args_2]	count=1
args	the given number of ||| ptr storable int	count=2
function	get the current ||| get	count=1
function	megabytes ||| megabytes	count=1
args	list of non-options ||| argorder a	count=1
args	where the return value ||| a io	count=2
return	combine their output ||| c c'	count=1
function	maximum number of megabytes ||| megabytes	count=1
function	an stm transaction ||| stm	count=1
module	returns the suffix of ||| data list	count=1
args	exception predicate to select ||| $f_2$ exception maybe b	count=1
return	and merging their ||| b b' either c c'	count=1
return	boolean ||| bool	count=1
function	and lower ||| min bound	count=1
module	of hdl ||| ghc io handle	count=3
return	number of ||| io $tuple_2$ int	count=2
function_args	[function_1] parses open ||| [function_1] readp [args_2]	count=1
args	nul terminated c ||| $f_2$ cstring io a	count=1
args	element in the pool ||| pool ptr storable	count=1
module	monoid returning ||| data monoid	count=1
return	[return_1] value ||| [return_1] [return_2]	count=5
function	thread is locked to ||| thread	count=3
module	same ||| ghc exts	count=2
return	and a list ||| a	count=1
module	fork ||| control concurrent	count=1
function_args	[function_1] file descriptor ||| [function_1] [args_2]	count=24
return	the memory required is ||| io foreignptr	count=1
module	an unsigned ||| exts	count=1
args	of non-options a ||| argorder a $list$ optdescr	count=1
args	is executed ||| mvar a	count=1
module	value from an ||| control	count=1
args	promote a function ||| $f_5$ a1 a2 a3 a4 r monad a1	count=1
return	from ||| from	count=2
function	to run sparks ||| run sparks	count=2
args	list of storable values ||| ptr storable	count=1
args	a list ||| $list$ a	count=2
return	a list of ||| io $list$	count=1
module	terminated c ||| foreign c string	count=1
args	the predicate ||| $f_2$ a bool $list$ a	count=1
function	from ||| from	count=6
function	file in [function_2] ||| [function_2] [function_1]	count=9
return	allocate a fresh ||| io	count=1
args	value from the first ||| a io	count=2
return	list into a circular ||| $list$ a	count=1
args	user-supplied equality predicate instead ||| bool $list$ a	count=1
module	asynchronous exceptions ||| control exception base	count=1
function	shift the first ||| unsafe shift	count=1
function_return	[function_1] storable type ||| [function_1] pool int io [return_2]	count=2
args	a structure but ||| foldable a	count=1
function	char ||| mk char	count=1
return	the computation [return_2] ||| [return_1] [return_2]	count=4
module	over the elements of ||| data	count=2
args	given number of ||| ptr storable int	count=2
args	returns the ||| $list$	count=2
function	on an mvar ||| on	count=2
return	the given size ||| io ptr	count=2
return	returning a final value ||| $tuple_2$ a traversable c	count=1
args	[args_1] handle ||| [args_1] iomode $f_2$ [args_2]	count=1
return	two ||| eq	count=1
return	value ||| applicative a	count=1
module	in the error if ||| system io error	count=1
function	is an unsigned integral ||| w#	count=1
args	has no starting ||| $f_3$	count=3
return	showing ||| shows	count=1
args	discarding any value produced ||| a	count=1
return	retagging and merging their ||| b b'	count=1
module	objects which may be ||| ghc exts	count=1
function	elem ||| elem	count=1
args	makes a new ||| iodevice/bufferedio/typeable filepath iomode maybe textencoding newlinemode	count=1
function_return	[function_1] [return_2] of an ||| [function_1] [return_2]	count=1
module	sum ||| data list	count=1
return	final value ||| $tuple_2$ a	count=1
function	bytes of [function_2] ||| [function_2] malloc [function_1]	count=1
module	haskell ||| foreign c	count=1
args	finalized pointer ||| a ptr env ptr a	count=1
module	the same as getopt ||| getopt	count=1
function_args	the exception [args_2] ||| [function_1] [args_2]	count=1
module	defines parser combinators for ||| parsercombinators	count=1
module	[module_1] exception is ||| [module_1] [module_2]	count=20
args	handle and ||| string maybe handle maybe	count=1
module	type with the same ||| ghc	count=1
module	foldl1 ||| ghc oldlist	count=1
return	parser ||| readp	count=1
args	the either ||| b c either a b	count=1
module	[module_1] area ||| [module_1] [module_2]	count=2
module	given list ||| list	count=1
return	memory pool ||| io pool	count=1
args	non-empty ||| $f_3$ a a a	count=1
function	new instance of ||| new chan	count=1
args	actions ||| b applicative c	count=1
function	bit of the ||| bit	count=1
args	pointer to ||| storable $f_2$ ptr storable io	count=1
function_args	suspends [function_1] [args_2] only ||| [function_1] [args_2]	count=2
module	array including an ||| foreign marshal array	count=2
args	the ||| a io b	count=1
function	called ||| no	count=1
function	the sign ||| sign	count=1
function	[function_1] [function_2] ||| [function_2] locale [function_1]	count=2
function	traceevent ||| trace event	count=2
return	perform a series of ||| a	count=1
function	program attempts to ||| nested	count=1
function_return	written [return_2] ||| [return_2] [function_1]	count=2
args	is an exception ||| exception maybe b io	count=1
args	value from ||| io a io b io	count=2
function	structures ||| foldr1	count=1
return	[return_1] a single ||| [return_1] [return_2]	count=2
return	a parser [return_2] ||| [return_1] [return_2]	count=3
module	of elements that satisfy ||| data	count=1
args	promote a function ||| monad a1 monad a2	count=2
function	a type to ||| type	count=1
args	promote a function ||| a1 a2 a3 a4 r monad a1	count=1
args	storable values in memory ||| $f_2$ ptr storable io	count=1
module	io operation ||| io error	count=2
function	splits a type ||| split ty con app	count=1
function	the native newline representation ||| native newline	count=1
return	for the ||| io	count=5
module	columns [module_2] ||| [module_1] [module_2]	count=3
function	read the ||| read	count=2
function	act opens a file ||| with file	count=1
function	binary mode ||| binary	count=3
args	type constructor ||| tycon	count=1
module	an entire ||| control concurrent chan	count=1
function	a given file ||| get file	count=1
module	because the ||| system io error	count=4
return	value ||| $tuple_2$ a traversable	count=1
return	value as the ||| a	count=2
return	with x the value ||| a	count=1
module	[module] context n ||| [module]	count=1
module	unsigned integral ||| exts	count=1
module	that can [module_2] ||| [module_2] [module_1]	count=4
args	signed realfloat value to ||| realfloat	count=1
module	[module_1] arrows ||| [module_1] [module_2]	count=8
module	components of magnitude and ||| data	count=1
function	error ||| error call	count=4
args	non-options a list of ||| argorder a	count=1
return	complex number [return_2] ||| [return_2] [return_1]	count=1
module	with the same size ||| ghc exts	count=1
function	foldl ||| foldl	count=1
module	the target thread ghc ||| ghc	count=1
args	value typically ||| b a b b $list$ a	count=1
module	marshal these values into ||| foreign marshal pool	count=1
function	scheduler ||| scheduler	count=1
module	set ||| conc sync	count=1
args	value ||| a b	count=1
return	[return_1] hgetline hdl ||| [return_2] [return_1]	count=1
module	[module_1] for text ||| [module_2] [module_1]	count=1
function	allocated | ||| allocated	count=1
module	concrete promotable proxy type ||| data proxy	count=1
function	a latin-1 character to ||| cast cuchar to	count=1
args	the mapmaybe [args_2] ||| [args_1] [args_2]	count=3
function	to offset ||| relative	count=2
args	but with the arguments ||| $f_2$ a monad b monad a	count=1
args	with a pure function ||| $f_2$ b c arrow c	count=1
args	on stablename ||| stablename	count=1
args	witharray but ||| $f_2$ ptr storable io	count=1
function	an index ||| index constr	count=1
args	value from ||| io a io b	count=2
return	monads ||| monad $list$	count=1
return	size of the required ||| io ptr	count=1
function	sum of the ||| sum	count=1
function	s heap is reaching ||| heap	count=2
function_return	utf-16 [return_2] ||| [return_2] [function_1]	count=3
args	with a pure function ||| $f_2$ b	count=1
return	the ||| io	count=80
args	discarding any value ||| a	count=1
function	hdl into the ||| h	count=2
args	four ||| d	count=1
module	a ||| foreign marshal pool	count=2
return	a foreignptr ||| foreignptr	count=2
args	function takes a predicate ||| $list$	count=1
args	either type ||| a c $f_2$ b c either	count=1
args	value typically the ||| a b b b $list$ a	count=1
return	its contents after the ||| io	count=1
function	to index ||| index	count=1
function	set ||| h set newline mode	count=1
function	a stack ||| stack	count=1
function	[function_1] hdl to ||| [function_2] [function_1]	count=2
module	an array [module_2] ||| [module_1] [module_2]	count=2
return	complex value with magnitude ||| complex	count=1
function	from hdl ||| h	count=1
args	non-options a ||| argorder a $list$ optdescr a $list$ string	count=1
args	value ||| monad a monad	count=1
args	the [args_2] ||| [args_2] [args_1]	count=2
function_args	[function_1] type hierarchy ||| [args_2] [function_1]	count=4
function	to mallocarray0 but ||| array0	count=1
return	code for the handler ||| io	count=2
args	like witharray but a ||| $f_2$ ptr storable io	count=1
args	for the either type ||| either a	count=1
return	[return_1] as a ||| [return_2] [return_1]	count=1
args	file handle and file ||| maybe handle maybe filepath	count=1
args	any value produced by ||| a monad b	count=2
module	scanr ||| list	count=1
args	for the either type ||| c either	count=1
return	value of the ||| a	count=1
module	[module_1] a value ||| [module_2] [module_1]	count=2
function	list using square ||| list	count=1
function	upper and ||| bound	count=1
module	[module_1] [module_2] ||| [module_1] [module_2] delete	count=4
module	unicode encoding ||| io encoding	count=1
return	didn t ||| $tuple_3$ $list$ a $list$ string $list$	count=1
function	maximum ||| max	count=1
args	the either ||| a c $f_2$ b c either	count=1
module	with ||| marshal array	count=1
args	string ||| textencoding string	count=4
function	an allocation [function_2] ||| [function_1] [function_2]	count=4
module	size of an array ||| array	count=1
function_return	the tolist [function_1] [return_2] the structure l ||| [function_1] islist [return_2] islist	count=1
function	[function_1] of the ||| [function_1] [function_2]	count=3
module	monoid returning ||| monoid	count=1
args	[args_1] realfloat value ||| [args_2] [args_1]	count=6
return	the permutations function returns ||| $list$ $list$ a	count=1
return	type constructor ||| tycon	count=5
return	waiting ||| blockedindefinitelyonstm	count=1
function	set the ||| h set newline mode	count=1
args	the same as x ||| bits	count=1
args	a ||| d e $list$ a $list$ b	count=1
function	unmasked the normal ||| unmasked	count=2
return	feed marked inputs ||| arrowchoice either	count=1
return	the memory ||| foreignptr storable	count=2
args	and ||| $list$	count=1
module	an array [module_2] ||| [module_2] [module_1]	count=2
function	[function] place ||| touch foreign [function]	count=6
function_args	[function_1] [args_2] ||| ghc staticptr sp info [function_1] [args_2]	count=1
args	this is a way ||| foreignptr a $f_2$	count=2
module	an exception ||| control exception	count=3
function_return	[function_1] the ||| [function_1] terminal device handle [return_2]	count=2
function	limits of a type ||| min bound	count=1
args	of storable ||| $f_2$ ptr storable io b	count=1
args	function takes a predicate ||| bool $list$	count=1
args	a list of ||| res $list$ a $f_2$ $list$ b	count=1
return	didn t ||| $tuple_3$ $list$ a	count=1
function	api kept [function] avoid ||| [function]	count=1
return	lies between 0 ||| shows	count=1
module	for use [module_2] ||| [module_1] [module_2]	count=4
return	returns the number of ||| io int	count=7
module	the computation iseof ||| fd	count=1
args	manager thread ||| eventmanager	count=1
args	fresh memory pool which ||| pool io	count=1
args	[args_1] a ||| [args_1] [args_2]	count=1
function	[function] associates ||| new foreign [function]	count=1
module	iseof ||| fd	count=1
function	allow the ||| fix	count=3
module	a type ||| prelude	count=1
return	phase pair in canonical ||| $tuple_2$	count=1
return	[return_1] either ||| [return_1] [return_2]	count=2
module	size as int ||| exts	count=1
args	exception predicate ||| $f_2$ exception maybe b io	count=1
module	the same size ||| ghc exts	count=1
args	pool but leave ||| pool	count=1
return	the someexception type is ||| someexception	count=1
args	user-supplied equality predicate ||| a bool $list$	count=1
args	argument and ||| string $list$	count=1
function	lift ||| lift	count=3
args	character ch ||| char	count=1
module	of a container of ||| data foldable	count=2
function	to the mvar ||| mvar	count=2
args	the pool to ||| pool	count=2
args	applied to non-empty ||| $f_3$ a a a foldable a	count=1
args	promote a function to ||| a4 a5 r monad a1 monad a2 monad	count=1
function	limits of a ||| min	count=1
function_return	[function_1] reads a ||| [return_2] [function_1]	count=2
function	performs ||| on	count=1
module	in the appropriate instance ||| control	count=1
module	of ||| data typeable	count=2
module	of foldr ||| data	count=2
module	io operation failed ||| system io	count=2
module	an mvar put ||| control concurrent	count=1
function	modified version ||| modify ioerror	count=1
args	list satisfy the predicate ||| $f_2$ a	count=1
args	conversion scheme between ||| string io textdecoder dstate io textencoder estate	count=1
args	of a conversion scheme ||| textdecoder dstate io textencoder estate	count=1
args	to be returned ||| $f_2$ a	count=1
function	used ||| bound	count=1
args	pointer to a temporarily ||| ptr storable io b	count=2
module	private ||| data char	count=1
module	proxy ||| proxy	count=1
args	a structure but ||| b b foldable a	count=1
function	was not possible ||| illegal	count=1
function	asynchronous exceptions masked ||| masked	count=1
args	value ||| a io b io c	count=2
module	error code ||| error	count=2
args	to a ||| a b	count=1
return	sum of a collection ||| a	count=1
args	memory pool which gets ||| pool io b	count=1
function	a type ||| type	count=1
args	either type ||| c $f_2$ b c either a	count=1
return	list of ||| $list$ statickey	count=1
args	a reverse ||| a b	count=1
function	allocation counter that ||| allocation counter	count=1
function	foldr1 is a ||| foldr1	count=1
args	same ||| bits	count=1
args	value produced by the ||| monad a	count=1
module	representation of a ||| data	count=2
module	and marshal a ||| foreign marshal	count=2
module	the event that an ||| control	count=2
module	same size ||| exts	count=1
args	of datatypes ||| $list$	count=1
return	buffer blocking ||| io $tuple_2$ int buffer	count=1
args	an abstract type representing ||| threadid#	count=2
args	the arguments ||| $f_2$ a monad b monad	count=1
args	first argument and ||| string $list$ optdescr a	count=1
return	consecutive ||| storable	count=1
module	same ||| ghc	count=1
return	of lists ||| $list$ c	count=1
rep	thread [function_return_2] ||| [module_1] [function_return_2]	count=4
return	the functor class ||| functor b	count=2
function	name the upper and ||| bound	count=1
args	handle and file path ||| handle	count=1
return	returns the number of ||| io $tuple_2$ int	count=2
function	the index of a ||| index	count=1
return	a nul terminated ||| cstring	count=1
function	zipwith ||| zip	count=2
return	to arbitrary monads ||| monad $list$ c	count=1
return	arrows retagging and merging ||| b b' either	count=1
rep	[module_1] [function_return_2] ||| [module_1] marshal alloc finalizer [function_return_2]	count=30
args	either ||| c $f_2$ b c either a b	count=2
module	io operation failed because ||| io error	count=2
args	a ||| $f_2$ ptr a io	count=2
return	or nothing if ||| io maybe	count=1
function	split a ||| split poly	count=1
module	the given parser ||| parsercombinators readp	count=1
function	call [function_2] ||| [function_2] [function_1]	count=2
return	but returns a ||| $list$ string $list$ string $list$ string	count=1
module	of microseconds ghc only ||| ghc conc	count=1
return	the rest unchanged to ||| d c d	count=1
args	the ||| string string	count=1
args	using ||| $f_2$	count=2
args	storable values in ||| storable $f_2$ ptr storable	count=1
function	defining left = ||| left	count=1
module	an io operation failed ||| system io error	count=1
return	the buffer blocking if ||| int buffer word8	count=1
function_return	[function_1] a staticptr ||| [return_2] [function_1]	count=1
args	a ||| a b c applicative a applicative b	count=1
function	int type ||| int type	count=1
args	file handle and file ||| string maybe handle	count=1
function	lcm x ||| lcm	count=1
module	begins ||| control concurrent chan	count=1
args	be used within ||| exception	count=2
module	thread ghc ||| ghc	count=1
args	alwayssucceeds adds a new ||| a	count=2
args	the either type ||| either	count=1
function	a suffix of ||| suffix of	count=1
module	a type ||| typeable	count=1
function	to ||| bound	count=1
module	object ||| system mem stablename	count=1
module	value from an mvar ||| control concurrent	count=1
args	pool which ||| pool io	count=1
args	storable values in memory ||| ptr storable io b	count=1
function	s heap is reaching ||| heap overflow	count=2
module	subset of unicode ||| data	count=1
function	string ||| string	count=1
function	thread for a ||| thread	count=2
args	the ||| maybe io	count=2
function	open the ||| open	count=2
return	mutate the contents ||| io	count=1
function	[function_1] prefix from ||| [function_1] [function_2]	count=2
function	real ||| real	count=1
args	list of storable values ||| $f_2$ ptr storable	count=1
return	isnothing function returns true ||| bool	count=1
return	bytes into the buffer ||| int buffer	count=1
args	value of the ||| a applicative	count=1
function	a duplicate ||| duplicate	count=1
function	allocate [function_2] ||| [function_2] [function_1]	count=12
module	the same ||| data bits	count=1
args	the specified number ||| bits int	count=4
module	test for a ||| data data	count=1
args	elements of the ||| a bool $list$	count=1
return	[return] run ||| io weak mvar [return]	count=2
args	value ||| either someexception a	count=1
module	error if applicable ||| error	count=1
function	transpose function transposes the ||| transpose	count=1
args	like witharray but a ||| $list$ storable $f_2$ ptr storable io b	count=1
return	six-tuples ||| $tuple_6$	count=1
return	returns a quadruple consisting ||| $list$ string $list$ string $list$ string	count=1
return	instance provided that traverse ||| traversable b	count=1
function_args	resize a memory ||| realloc ptr a	count=1
args	given number ||| storable ptr storable int	count=2
return	and merging ||| b b' either c	count=1
return	value ||| a	count=15
return	end marker into ||| storable/eq	count=1
args	a monad scanning the ||| monad a3 monad a4 monad a5	count=1
args	string ie character array ||| textencoding string	count=1
module	where the ||| system io	count=6
args	integer ||| integer	count=1
args	any value produced ||| $f_2$ a monad b	count=1
function	a foreign pointer and ||| new foreign ptr	count=1
function	but additionally if ||| if	count=1
return	occur within a computation ||| a	count=1
module	text encoding for the ||| ghc io	count=1
return	memory area ||| storable	count=2
module	of its argument ||| data	count=1
args	a signed realfloat value ||| realfloat	count=1
module	current ||| ghc stats	count=2
function	unzip transforms a ||| unzip	count=1
args	a structure to a ||| $f_2$ a monad b foldable a	count=2
return	comp exposes io errors ||| io	count=1
module	[module_1] overloaded ||| [module_1] [module_2] nub	count=2
function	to ||| cast char to cschar	count=1
function	newline representation ||| newline	count=1
function_args	[function_1] [args_2] ||| [function_1] drop [args_2]	count=3
return	without ||| word8	count=1
args	the mapmaybe ||| a maybe	count=1
function	advances ||| plus	count=1
args	a monad scanning ||| a4	count=1
function	throwerrnoifminus1retrymayblock ||| minus1retry may block_	count=1
args	the specified handle ||| handle	count=1
module	is the ||| bits	count=1
function_return	the resultant [return_2] ||| [function_1] a [return_2]	count=2
function	foreign pointer ||| foreign ptr	count=2
args	number of microseconds ||| timeoutkey int	count=1
function	to a thread ||| thread id	count=2
function	prefix from ||| prefix	count=1
args	a binary function ||| a applicative b	count=1
module	same as getopt ||| getopt	count=1
function_return	[function_args_1] [return_2] ||| [function_args_1] [return_2] r	count=8
return	to the size needed ||| io ptr storable	count=1
function	[function] retry ||| [function]	count=2
args	is the same ||| bits	count=1
return	and a ||| a	count=2
function_args	[function_1] string ||| [function_1] [args_2]	count=1
args	the return value from ||| a io	count=2
module	version of ||| data list	count=3
args	as argument a pointer ||| ptr storable io	count=2
module	[module_1] [module_2] which ||| [module_2] [module_1] char8	count=2
module	[module] is not ||| [module]	count=3
args	with a ||| $f_2$ c d arrow	count=1
args	nul terminated c ||| cstring io	count=1
args	be returned ||| $f_2$ a io	count=1
args	[args_1] function ||| [args_1] [args_2]	count=2
function_return	[function_1] fixity ||| [return_2] [function_1]	count=2
function	the sort function ||| sort	count=1
function_return	allocate space [return_2] ||| [function_1] pool io ptr [return_2]	count=2
module	the types defined ||| types	count=1
function	of megabytes [function_2] ||| [function_2] [function_1]	count=3
module	container of lists ||| data list	count=2
module	available for ||| ghc staticptr	count=1
return	the io action returns ||| io eq/num	count=1
args	handle and file ||| maybe handle maybe filepath	count=1
function	reads a line from ||| get line	count=1
args	a conversion scheme between ||| string io textdecoder dstate io textencoder estate	count=1
function	resets ||| reset	count=1
args	a monad scanning ||| monad a2 monad a3 monad a4 monad	count=1
return	tvar to true ||| tvar bool	count=1
args	like witharray but ||| storable io b	count=1
function	[function] explicit ||| [function] castring	count=3
module	list and returns ||| list	count=1
args	returns a concrete ||| proxy typeable	count=2
function	[function_1] a signed ||| [function_1] [function_2]	count=1
function	the char ||| mk char	count=1
function	the threadid [function] ||| [function]	count=2
module	promotable proxy type ||| data proxy	count=1
return	may [return_2] ||| [return_1] [return_2]	count=1
module	[module_1] scanr ||| [module_1] [module_2]	count=8
args	a ||| b c d e $list$ a $list$	count=1
function	like chainl but ||| chainl1	count=1
module	columns ||| list	count=1
module	support for ||| ghc io	count=1
function	terminate the thread ||| thread	count=1
function_return	contents of the [function_1] [return_2] ||| [function_1] filepath [return_2]	count=1
function	splits a type ||| split ty	count=1
function	name of the program ||| name	count=1
function	representation ||| rep	count=8
function	marshal a c string ||| cstring len	count=1
rep	public [function_args_2] ||| [module_1] [function_args_2]	count=2
function	of putmvar ||| put	count=1
module	type with ||| ghc	count=1
args	a structure to a ||| monad b traversable a	count=2
args	c string ||| string	count=1
module	marshal these values ||| foreign marshal pool	count=1
module	[module_1] area with ||| [module_1] [module_2]	count=2
function	appends a stack trace ||| stack trace	count=1
args	stablename that ||| stablename a stablename	count=1
function	with a ||| with pool	count=1
args	argument and ||| $list$ optdescr	count=1
args	where the second ||| ioerrortype string maybe	count=1
return	is waiting to ||| blockedindefinitelyonstm	count=1
return	the number of the ||| $tuple_2$ int	count=3
function	wide character array with ||| cwstring	count=1
function_return	[function_args_1] by p ||| [return_2] [function_args_1]	count=1
args	there are no ||| bufferedio	count=1
function	satisfying the ||| munch1	count=1
function	getargs return args ||| with args	count=1
module	an exception ||| control exception base	count=2
return	and merging ||| b b' either c c'	count=1
function	program when the user ||| user	count=1
return	returns a ||| $list$ a $list$ string $list$ string $list$ string	count=1
args	a ||| a	count=37
args	scanning ||| monad a2 monad a3 monad a4 monad a5	count=1
function	actually a pair ||| weak pair	count=1
module	convert a [module_2] ||| [module_1] [module_2]	count=6
return	occurrences [return] p ||| readp [return]	count=1
module	a type ||| data typeable	count=1
module	resultant ||| control exception base	count=1
args	of the [args] hdl ||| [args]	count=1
return	[return_1] for an ||| [return_2] [return_1]	count=6
module	as int ||| exts	count=1
return	didn t ||| $tuple_3$ $list$ a $list$ string $list$ string	count=1
function	[function_1] blocking mode ||| [function_1] [function_2]	count=2
args	input [args] ||| [args]	count=1
return	word is ||| word	count=1
return	a ||| b a	count=2
return	the required ||| io	count=1
return	phase pair in ||| $tuple_2$ realfloat realfloat	count=1
args	a structure but with ||| b foldable a	count=1
module	where the array ||| foreign marshal array	count=1
module	process the [module_2] ||| [module_1] [module_2]	count=8
args	the pool ||| pool ptr a	count=1
args	a binary function to ||| c applicative a	count=1
args	retry loop [args] interrupted ||| [args]	count=1
args	string using temporary ||| string	count=1
args	storable values ||| storable $f_2$ ptr storable	count=1
module	the argument arrow passing ||| control arrow	count=1
return	the buffer blocking if ||| buffer word8	count=1
return	a string up ||| string	count=2
args	scanning ||| a4 monad	count=1
return	the ||| io ptr storable	count=3
function	to ||| char to cschar	count=1
return	and a list and ||| maybe a	count=1
return	the type constructor ||| tycon	count=2
function	register ||| register	count=1
function	read the next ||| read	count=1
return	returns an ||| io $tuple_2$	count=3
args	of a structure ||| b b b foldable a	count=1
args	c string ie ||| textencoding string $f_2$	count=1
args	structure to a ||| b traversable a	count=2
function	adjust the size ||| realloc	count=1
args	handle and file path ||| maybe handle maybe	count=1
return	nul terminated ||| io cstring	count=1
module	foreign function equivalent to ||| foreign	count=1
function_return	[function_1] [return_2] ||| [function_1] ptr ptr a [return_2]	count=2
args	the specified handle ||| handle string	count=1
function	instance of show ||| show	count=2
return	magnitude phase pair ||| $tuple_2$ realfloat	count=1
args	used as a value ||| a	count=1
args	equality on stablename ||| stablename a stablename b	count=1
args	value produced by the ||| a $f_2$ a monad b	count=1
args	a ||| $list$ a $list$ b $list$ c $list$	count=1
module	is the same as ||| data	count=1
args	number of microseconds ||| int	count=5
args	a ||| b c d e $list$ a	count=1
args	a ||| string a	count=1
return	a circular ||| $list$ a	count=1
args	like witharray [args_2] ||| [args_2] [args_1]	count=4
args	equality predicate ||| bool	count=2
return	a variant of ||| a	count=3
module	from an mvar ||| control concurrent mvar	count=1
function_args	written to [args_2] ||| [args_2] [function_1]	count=7
function	the same ||| w#	count=1
args	predicate instead ||| a bool	count=1
args	the file handle and ||| maybe handle	count=1
args	a monad scanning the ||| a3 monad a4 monad a5	count=1
function	occurrence of each ||| delete	count=1
args	the isprefixof ||| eq	count=1
return	to indicate that the ||| a	count=1
args	pool but ||| pool	count=1
module	[module] described by ||| [module]	count=1
args	a structure ||| applicative b foldable a	count=1
return	comp exposes io ||| io either ioerror	count=1
function_args	[function_1] [args_2] ||| [function_1] mvar a [args_2]	count=4
return	that didn t ||| $tuple_3$ $list$ a $list$ string	count=1
function_args	[function_1] the static ||| [args_2] [function_1]	count=4
args	nul terminated ||| $f_2$ cstring	count=1
module	of the [module_2] ||| [module_1] [module_2] nub	count=1
module	of ||| data ioref	count=4
function	[function_1] timeout in ||| [function_1] [function_2]	count=1
function_return	duplicate of [return_2] ||| [return_2] [function_1]	count=2
function	current i/o position ||| get posn	count=2
function	left ||| left	count=1
module	involved in the error ||| system io error	count=1
module	is an unsigned ||| exts	count=1
args	with ||| $f_2$ c	count=1
function	to ||| cschar to	count=1
function	ie character ||| len	count=2
function	[function_1] assigned ||| [function_2] [function_1]	count=2
args	but a terminator ||| io	count=1
function_return	contents of [function_1] [return_2] ||| [function_1] [return_2]	count=1
function_return	[function_1] type constructor ||| [function_1] typerep [return_2]	count=2
args	with a pure ||| $f_2$ c d arrow b	count=1
return	a chan ||| chan a	count=2
args	predicate instead ||| $f_3$ a a bool $list$ a	count=1
function	quantity to ||| qsem	count=1
function_args	[function_1] [args_2] bits in the type ||| [function_1] [args_2]	count=3
module	error code eagain ||| c error	count=1
function	mapandunzipm function maps its ||| map and unzip m	count=1
module	posix data ||| system posix	count=1
args	a ||| b traversable a	count=2
return	the mapaccumr function behaves ||| $tuple_2$ acc $list$ y	count=1
return	look at the ||| io	count=2
module	that ||| ghc conc sync	count=1
args	a ||| d e $list$ a	count=1
function	merge their ||| (|||)	count=1
function	if the operation yields ||| if	count=1
function_args	the find [args_2] ||| [args_2] [function_1]	count=3
return	stm action that ||| stm io	count=3
function	taken from hdl or ||| h	count=1
module	fresh memory ||| foreign marshal	count=1
function	that is programmer-defined ||| user	count=1
args	the file handle and ||| handle	count=1
function	public representation ||| alg rep	count=1
module	output ||| ghc io handle	count=1
return	actions ||| applicative b	count=1
function	quot and ||| quot	count=1
args	a structure to an ||| b foldable a	count=1
args	additional parameter ||| storable $f_3$	count=1
module	into it the combination ||| utils	count=1
return	applicable to any monadplus ||| monadplus	count=1
args	a ||| $f_2$ a	count=1
function	to ||| word ptr to	count=1
args	return value from ||| a io	count=2
function	trace to the ||| trace	count=1
module	component ||| foreignptr unsafe	count=1
args	string using temporary storage ||| string $f_2$	count=1
function_return	[function_1] a tuple ||| [return_2] [function_1]	count=1
function_args	[function_1] pool ||| [function_1] [args_2]	count=3
module	type with ||| ghc exts	count=1
return	returns an stm action ||| $tuple_2$ stm io	count=3
return	finite list into a ||| $list$ a	count=1
return	arrow and copy ||| arrow $tuple_3$	count=1
return	for operating on the ||| io b	count=1
function	popcount ||| pop count	count=1
args	same as x ||| int	count=1
module	applicative functor based on ||| applicative	count=1
return	st [return] ||| st [return]	count=5
function	[function_1] counter that ||| [function_2] [function_1]	count=4
function_return	[function_1] handle ||| [return_2] [function_1]	count=1
return	a magnitude phase pair ||| $tuple_2$ realfloat	count=1
return	the associativity ||| associativity	count=1
rep	slides [function_return_2] ||| [module_1] [function_return_2]	count=4
module	of foldr that ||| data	count=2
function	to the finalizer ||| add foreign ptr finalizer env	count=2
module	[module_1] for text ||| [module_1] [module_2]	count=1
return	[return] run ||| io weak ioref [return]	count=2
module	[module] five-tuples analogous ||| [module]	count=1
return	[return_1] for versions ||| [return_1] [return_2]	count=1
function	constructors ||| prefix	count=1
function	[function_1] current locale ||| [function_2] [function_1]	count=2
module	of functions from data ||| data ord	count=1
module	modified ||| system io error	count=1
function	in ||| size	count=1
function	hdl t waits ||| for	count=2
module	for precedence ||| readprec	count=1
args	conversion scheme ||| textdecoder dstate io textencoder estate	count=1
module	is an ||| exts	count=1
args	the either type ||| $f_2$ a c $f_2$ b c either	count=1
return	returns ||| string $list$	count=1
module	as getopt but ||| getopt	count=1
function	is about to terminate ||| finally	count=1
return	tryioerror comp exposes io ||| io either	count=1
function_return	[function_1] storable type ||| [function_1] pool io ptr [return_2]	count=1
return	[return] converting a ||| [return]	count=1
return	allows io computation ||| io	count=1
function	marker ||| trace marker	count=1
return	number of the capability ||| int	count=3
function	sparks currently in ||| num sparks	count=2
return	the result as ||| monad	count=1
args	given marker ||| storable $list$ storable	count=1
return	a staticptr by ||| staticptr a	count=1
module	returns an ||| control concurrent	count=1
return	the number of ||| io $tuple_2$ int	count=2
args	is ||| word#	count=1
return	buffer blocking ||| int buffer	count=1
module	[module_1] of its ||| [module_2] [module_1]	count=4
args	case no result ||| a	count=1
function_return	[function_1] constructor application ||| [function_1] typerep [return_2]	count=2
module	a haskell value ||| foreign	count=1
args	[args] monadic action ||| [args]	count=6
args	non-options a ||| argorder a $list$	count=1
return	permutations function returns ||| $list$ $list$	count=1
return	the device without blocking ||| word8	count=1
function	mark ||| is mark	count=1
function	as ||| w#	count=1
function	storage for a ||| pooled new array	count=1
module	that an ||| control	count=2
return	a final value ||| a traversable c	count=1
module	monad ||| control	count=2
return	staticptrinfo ||| staticptrinfo	count=1
return	a finalizer that expects ||| a	count=1
return	the pointer living ||| io b	count=2
function_return	[function_args_1] [return_2] act ||| [function_args_1] [return_2]	count=8
function	to name ||| min bound	count=1
module	copies ||| foreign marshal utils	count=2
function	limits of ||| min bound	count=1
args	on stablename that does ||| a stablename	count=1
args	handle ||| maybe handle maybe	count=1
args	exception predicate to ||| $f_2$ exception maybe b	count=1
module	the operation failed because ||| io	count=5
args	the ||| word#	count=1
module	decimal notation for ||| numeric	count=1
args	finalized ||| env	count=1
return	value from ||| a	count=1
module	where the operation failed ||| io error	count=5
return	[return_1] a ||| [return_1] $tuple_7$ [return_2]	count=1
args	promote a function to ||| monad a1 monad a2 monad a3 monad	count=1
module	from an mvar put ||| control concurrent	count=1
function	the upper ||| bound	count=1
args	a list of storable ||| $f_2$ ptr storable io b	count=1
args	the ||| mvar a io	count=1
return	the io ||| io	count=13
return	constructor application ||| tycon $list$ kindrep $list$ typerep	count=1
module	same as ||| bits	count=1
return	a finalizer ||| a	count=3
args	the issuffixof ||| eq	count=1
function_args	right by [args_2] ||| [args_2] [function_1]	count=1
function	if ||| errno if	count=1
rep	public [function_args_2] ||| [module_1] alg [function_args_2]	count=2
function	shift ||| shift l	count=2
module	of xs after ||| data	count=1
function	stable [function_2] ||| [function_1] [function_2] stableptr a	count=1
module	for the io ||| ghc io encoding	count=4
args	promote a function ||| a4 a5 r monad a1 monad a2 monad	count=1
args	of storable ||| $f_2$ ptr storable	count=1
args	file handle ||| string maybe handle maybe	count=1
function	type with the ||| w#	count=1
return	of decodefloat in ||| realfloat	count=1
module	for the specified handle ||| ghc io handle	count=1
function	float [function_2] ||| [function_1] [function_2]	count=1
args	memory pool which ||| $f_2$ pool	count=1
return	stm action ||| stm io	count=3
args	scanning the ||| monad a4 monad a5	count=1
return	returning the number ||| int	count=1
module	[module_1] corresponding ||| [module_1] [module_2]	count=3
args	memory pool ||| pool io	count=1
function_args	show [args_2] ||| [args_2] [function_1]	count=14
return	out elements ||| $list$ b	count=1
return	a list and returns ||| maybe a	count=1
return	predicate and a ||| a	count=1
function	performs the final action ||| on	count=1
function_args	duplicate [args_2] ||| [args_2] [function_1]	count=1
module	allow ||| st safe	count=1
function	name [function_2] ||| [function_2] [function_1]	count=2
function	is already being ||| is already	count=3
args	handle and ||| maybe handle maybe filepath	count=1
args	conversion scheme between ||| textdecoder dstate io textencoder estate	count=1
args	handle and ||| string maybe handle	count=1
args	typeable ||| typeable	count=1
return	the original handle ||| io handle	count=1
module	argument types of a ||| data typeable	count=2
function	a foreign ||| new foreign	count=1
args	convert from the representation ||| rep generic x	count=1
function_args	[function_1] [args_2] ||| [function_1] index $list$ a [args_2]	count=3
args	argument a pointer ||| storable $f_2$ ptr storable io b	count=1
module	marshal a c string ||| foreign c string	count=1
return	function to actions ||| applicative d	count=1
function	the thread for some ||| thread	count=1
module	proxy type for ||| proxy	count=1
function	[function_1] of ||| [function_2] [function_1]	count=3
function_return	[function_1] returns the ||| [return_2] [function_1]	count=3
module	with the same ||| ghc exts	count=1
function	is similar to mallocarray0 ||| foreign ptr array0	count=1
module	map each element of ||| data foldable	count=1
args	with a pure function ||| $f_2$ c d	count=1
function	is [function] ||| [function]	count=3
args	[args_1] function is ||| [args_2] [args_1]	count=2
function_return	[function_1] of chan ||| [function_1] io [return_2]	count=1
args	class typeable allows a ||| typeable	count=1
args	of a structure but ||| b foldable a	count=1
args	a ||| g $list$ a	count=1
function	physical file hfilesize hdl ||| h	count=2
module	the error code eagain ||| foreign c error	count=1
args	finalized pointer ||| ptr env ptr a	count=1
args	a monad scanning the ||| a4 monad	count=1
module	letters of ||| data char	count=1
args	of buffering [args] ||| [args]	count=1
args	and always ||| a	count=1
args	of storable values in ||| storable $f_2$ ptr storable io b	count=1
function	a stack [function_2] ||| [function_2] [function_1]	count=3
function	unzip4 function ||| unzip4	count=1
function	printf except that ||| h printf	count=1
function	combination of map ||| map	count=2
function	that capability or not ||| capability	count=3
args	byte representing a latin-1 ||| cchar	count=1
function_return	a list [return_2] ||| [return_2] [function_1]	count=3
args	given number ||| int $f_2$	count=1
function	a single-use resource which [function_1] [function_2] ||| [function_1] [function_2] in use	count=4
module	block of memory of ||| alloc	count=1
args	value ||| someexception a	count=1
module	action meets the given ||| foreign	count=1
function	format ||| format	count=3
module	of ||| data complex	count=2
function_return	read [return_2] ||| [return_2] [function_1]	count=2
module	types [module_2] ||| [module_2] encoding [module_1]	count=1
module	block of ||| marshal alloc	count=1
return	traverse with its ||| applicative traversable b	count=1
module	allow ||| control monad st	count=1
args	conversion scheme between sequences ||| textdecoder dstate io textencoder estate	count=1
module	failed because ||| system	count=2
function	to ||| cchar to	count=1
function	printf except ||| h printf	count=1
function	given path when appropriate ||| path if minus1	count=1
args	promote a function ||| a5 r monad a1 monad a2 monad a3	count=1
function	the handle [function] ||| [function]	count=2
args	openfile ||| iomode	count=4
function	error message if ||| error with	count=1
return	a staticptr by its ||| io maybe staticptr a	count=1
return	convert a strict st [return_1] [return_2] ||| st [return_1] [return_2]	count=2
module	numeric representation ||| utils	count=1
function	[function_1] stable ||| [function_2] [function_1]	count=1
args	be applied to non-empty ||| $f_3$	count=1
function	be sent immediately ||| flush	count=2
function	of throw ||| throw io	count=2
function	from [function_2] ||| [function_1] [function_2]	count=5
args	parse a string ||| string	count=1
args	on stablename that does ||| stablename a stablename	count=1
args	the ||| io a io a	count=4
return	f executes the computation ||| io	count=1
module	convert [module_2] ||| [module_2] [module_1]	count=1
module	allocate a fresh ||| marshal	count=1
args	same as ||| bits int	count=1
return	[return_1] unsigned realfrac ||| [return_1] [return_2]	count=1
function	number of megabytes ||| megabytes	count=1
module	device ||| device	count=4
module	open ||| ghc io handle fd	count=2
return	buffer ||| io $tuple_2$ int buffer word8	count=1
return	staticptr by its ||| staticptr	count=1
args	promote a function ||| a2 a3 a4 a5 r monad a1	count=1
return	the pointer living inside ||| io	count=2
function	function maps ||| map exception	count=1
return	the number of ||| io int	count=7
return	the newx functions ||| io	count=1
args	this is ||| foreignptr	count=2
module	be marshalled to ||| ghc exts	count=1
function	call stack ||| call stack	count=4
function_return	count [return_2] ||| [function_1] trailing zeros finitebits [return_2]	count=1
function	trace [function_2] ||| [function_2] [function_1]	count=2
args	value produced by ||| a	count=2
function_return	[function_1] to the ||| [function_1] fd [return_2]	count=1
return	function is used to ||| from buffer to	count=2
function_args	suspends the current [function_1] [args_2] ghc only ||| ghc conc [function_1] delay [args_2]	count=2
return	at the ||| io	count=2
return	makes a [return_2] ||| [return_2] [return_1]	count=6
function_return	[function_1] complex value ||| [return_2] [function_1]	count=1
module	allow ||| monad st lazy	count=1
module	for the current platform ||| ghc io	count=1
function	create a stable pointer ||| new stable ptr	count=1
function	when the resultant ||| evaluate	count=2
function	duplicate channel begins ||| dup	count=1
args	equality predicate instead ||| bool $list$ a	count=1
function	a timeout in ||| timeout	count=1
args	a ||| g $list$ a $list$ b $list$ c $list$	count=1
module	useful in ||| control exception base	count=1
return	to i ||| seekmode	count=3
function	format string ended early ||| error short format	count=1
return	buffer ||| io buffer	count=1
args	of a conversion scheme ||| io textdecoder dstate io textencoder estate	count=1
args	case no ||| a	count=1
function	a terminal? ||| terminal device	count=2
return	into a circular one ||| $list$ a	count=1
function	stable [function_2] ||| [function_2] [function_1]	count=5
return	arrow and copy the ||| arrow	count=1
module	an io operation failed ||| io error	count=2
function	pair of ||| mk weak pair	count=1
return	[return_1] for ||| [return_2] [return_1]	count=6
function	form the numerator and ||| numerator	count=1
args	user-supplied equality predicate ||| $f_3$ a a bool $list$	count=1
args	char ||| char	count=4
args	the string s ||| handle string	count=1
args	stablename that does ||| a stablename	count=1
module	event ||| event	count=3
return	the target thread ||| io	count=1
function	the same as x ||| bit	count=1
function	is not required ||| bracket_	count=1
args	promote a function ||| monad a1 monad a2 monad	count=2
args	of a structure ||| b foldable a	count=1
function	co other private ||| private	count=1
function	open ||| open	count=5
module	[module_1] scanr that ||| [module_1] [module_2]	count=8
module	for the capability on ||| ghc event	count=1
function	return the current ||| get	count=3
function	uninterruptiblemask ||| uninterruptible	count=2
return	magnitude phase pair in ||| $tuple_2$ realfloat realfloat	count=1
return	threadid of the ||| io threadid	count=6
args	a pointer to a ||| $f_2$ ptr storable io b	count=2
args	as argument a pointer ||| $f_2$ ptr storable io	count=2
args	a structure to a ||| $f_2$ a monad b traversable a	count=2
return	word ||| word	count=1
args	returned value ||| io a $f_2$ either someexception a	count=1
module	to tyconname tyconmodule and ||| data	count=2
function	the first component of ||| first	count=1
args	to a monad scanning ||| a4 monad a5	count=1
function	bit of ||| bit	count=1
module	a ||| typeable internal	count=2
module	the rows and columns ||| list	count=1
module	[module_1] io library ||| [module_1] [module_2]	count=6
module	of hdl ||| handle	count=3
args	given marker element ||| ptr storable $list$ storable	count=1
return	value zero ||| io ptr a	count=1
function	[function_1] [function_2] ||| [function_2] temp [function_1]	count=4
module	gc by the ||| ghc	count=1
module	read ||| concurrent chan	count=1
module	variable from the environment ||| environment	count=1
args	return value from the ||| a io b	count=2
module	variant of foldl that ||| data list	count=1
args	stablename that does not ||| stablename	count=1
return	storable type ||| ptr storable	count=3
module	exception ||| exception	count=5
return	perform a ||| a	count=1
args	pointer to ||| storable $f_2$ ptr storable io b	count=1
args	equality predicate ||| a a bool	count=2
args	[args] hdl ||| [args]	count=1
module	an exception is ||| control exception	count=3
function	allocate a fresh memory ||| new pool	count=1
return	merging their ||| b b' either	count=1
return	in arrow ||| arrow b	count=1
function	[function_1] mvar ||| [function_1] [function_2]	count=2
return	the elements of a ||| a	count=2
return	a computation and which ||| ioerror a	count=1
function_args	[function_1] the number ||| [function_1] [args_2] bits	count=3
return	from [return_2] ||| [return_1] [return_2]	count=2
function	descriptor registration without waking ||| unregister fd_	count=1
function	hdl as a ||| h	count=1
return	pass [return] restore action ||| [return]	count=2
args	witharray but a ||| storable $f_2$ ptr storable io	count=1
module	for ||| ghc io	count=4
args	a ||| string	count=1
function_args	accepts any [args_2] ||| [function_1] index $list$ a [args_2]	count=1
function	a file ||| with file	count=1
return	set to offset i ||| seekmode	count=2
function_args	file [args_2] ||| [function_1] filepath iomode [args_2]	count=1
args	passes the resulting handle ||| handle io r	count=1
return	of evaluation such ||| functor	count=1
args	a reverse ||| a $f_2$ a	count=1
function	mallocarray0 but ||| array0	count=1
module	[module_1] ioerror corresponding ||| [module_1] [module_2]	count=3
args	structure is empty ||| foldable	count=2
return	the io ||| io ptr	count=1
function	replicate n x is ||| replicate	count=1
return	algebraic datatypes only ||| conindex	count=1
function	stable ||| cast stable	count=1
return	this variant of newforeignptr ||| foreignptr	count=1
args	or a returned value ||| a $f_2$ either someexception a	count=1
function_args	accepts any [args_2] ||| [args_2] [function_1]	count=2
module	a value from an ||| control concurrent	count=1
return	simplest rational ||| rational	count=1
return	given value to the ||| io	count=1
function	based on zipping ||| zip list	count=1
args	returned value ||| a	count=1
function	from the ||| from	count=2
function	prefix of ||| prefix of	count=2
return	of the required ||| io ptr	count=1
args	a monad scanning ||| monad a4 monad a5	count=1
return	to the size ||| io ptr storable	count=1
module	in memory [module_2] ||| [module_1] [module_2]	count=8
module	[module_1] of ||| [module_1] [module_2]	count=23
module	[module_1] list ||| [module_1] [module_2]	count=20
module	[module] memory ||| foreign [module]	count=3
return	an unsigned realfrac ||| realfrac	count=1
args	number ||| int $f_2$ ptr storable io b	count=2
return	by the io ||| io	count=1
return	a and [return_2] ||| [return_1] [return_2]	count=1
args	storable values ||| $f_2$ ptr storable io	count=1
return	with just a computation ||| io a	count=1
function	exception ||| some exception	count=1
args	more characters ||| char	count=2
args	non-empty ||| $f_3$ a	count=1
function	any type in class ||| from rat	count=1
module	components of ||| data	count=1
args	value from the first ||| io a io b io c	count=2
module	logical reasoning tool of ||| data	count=1
return	memory required is ||| foreignptr	count=1
function	[function_1] pointer and ||| [function_1] [function_2] finalizerptr a	count=4
function	without removing it from ||| h look ahead	count=1
return	[return_1] haskell value ||| [return_1] [return_2]	count=2
function	base specified by the ||| show int at base	count=1
module	occurrence of x ||| data	count=1
function	other not ||| not	count=1
module	[module_1] the c ||| [module_1] [module_2]	count=2
function	from the supplied write ||| write	count=2
function	haskell reads-style function ||| read p_to_s	count=1
function	traceevent or traceeventio ||| event	count=1
function	finalizer ||| finalizer	count=3
return	merging ||| b b' either	count=1
args	makes ||| iodevice/bufferedio/typeable filepath iomode maybe textencoding newlinemode	count=2
args	passing any value ||| $f_2$ a monad	count=1
args	the given number ||| timeoutkey int	count=1
return	and merging ||| b b'	count=1
return	function reads [return_2] ||| [return_2] [return_1]	count=4
args	the handle ||| handle	count=3
args	type where ||| ioerrortype string maybe	count=1
function	yield action allows forces ||| yield	count=1
return	list into a ||| $list$ a	count=1
return	or written and also ||| iodevicetype	count=1
return	the [return_2] ||| conc get num capabilities [return_1] [return_2]	count=4
function	current i/o position of ||| get	count=2
args	living inside a ||| a $f_2$ ptr a io b	count=2
function_return	elements [return_2] ||| [return_2] [function_1]	count=2
return	value from [return_2] ||| [return_2] [return_1]	count=2
function	set the ||| set newline mode	count=1
function	act opens a file ||| binary file	count=1
return	obtain the haskell ||| io	count=1
module	[module_1] in utf-16 ||| [module_1] [module_2]	count=2
module	for [module_2] ||| [module_1] [module_2]	count=6
args	[args_1] but a ||| [args_1] [args_2]	count=2
function	[function_1] threads ||| [function_2] [function_1]	count=1
return	handle is ||| io handle	count=1
return	an integer ||| integer	count=1
args	to a curried function ||| a b c a	count=1
function_args	[function_1] a signed ||| [function_1] ffloat alt maybe [args_2]	count=1
function	mallocarray0 ||| ptr array0	count=2
function	to throw ||| to	count=2
function	handle [function] ||| [function] set	count=1
return	a word is ||| word	count=1
args	like witharray but ||| ptr storable io	count=1
function	sets ||| set posn	count=2
function	without waking ||| unregister fd_	count=1
function	advances the ||| plus	count=1
function	scanl1 is ||| scanl1	count=1
args	monad scanning ||| monad a2 monad a3 monad a4 monad a5	count=1
return	result of evaluation such ||| functor	count=1
return	is traverse with ||| applicative traversable b	count=1
args	six ||| f	count=1
module	of a structure to ||| data	count=1
function	split ||| split poly ty con app	count=2
return	between 0 ||| shows	count=1
return	functor class ||| functor b	count=2
return	and combine their output ||| b $tuple_2$ c c'	count=1
args	or a returned value ||| either someexception a	count=1
return	using [return_2] ||| [return_1] [return_2]	count=1
args	where the return value ||| io a io b	count=2
function	bit i ||| bit	count=1
function	encoding of [function_2] ||| [function_2] locale [function_1]	count=1
args	a binary function to ||| b c applicative a	count=1
function	a ||| new pool	count=2
function	file in [function_2] ||| [function_2] temp [function_1]	count=1
return	of the required type ||| io ptr storable	count=1
function	latin-1 character to ||| cuchar to	count=1
function	file hfilesize hdl ||| h	count=2
module	a c string ||| c string	count=2
return	current value of ||| a	count=2
args	a ||| e $list$ a $list$	count=1
function	the thread [function_2] ||| [function_2] [function_1]	count=2
return	within a ||| a	count=1
return	argument arrow and copy ||| arrow	count=1
args	string- > string ||| $f_2$ string string	count=1
function	to name the upper ||| min	count=1
module	process the command-line and ||| system console getopt	count=1
function	program s heap is ||| heap	count=2
return	returns a tuple where ||| $list$ a $list$ a	count=1
function	with asynchronous exceptions masked ||| mvar masked	count=1
module	write ||| concurrent chan	count=1
module	a list ||| data list	count=4
function	to run [function_2] ||| [function_2] [function_1]	count=1
args	where the return value ||| io a io b io	count=2
return	phase pair ||| $tuple_2$ realfloat	count=1
module	lazy ||| lazy safe	count=2
args	a ||| applicative a	count=1
module	error ||| error	count=4
function	forever act repeats the ||| forever	count=1
module	can only be used ||| conc	count=1
return	phase pair in canonical ||| $tuple_2$ realfloat	count=1
args	witharray but ||| storable $list$ storable $f_2$ ptr storable io b	count=1
args	string ie ||| textencoding string	count=1
function	of sparks currently ||| num sparks	count=2
function	to ||| cuchar to	count=1
function	scanr1 is ||| scanr1	count=1
module	always ||| ghc conc sync	count=1
args	a monad scanning the ||| monad a3 monad a4	count=1
function	an error when ||| error	count=1
return	used to ||| buffer to	count=2
args	a conversion scheme between ||| textencoder estate	count=1
function_args	[function_1] given number ||| [args_2] [function_1]	count=4
function	action with a fresh ||| with pool	count=1
args	returned ||| $f_2$ a io	count=1
function	to the ||| cuchar to	count=1
args	return value from the ||| a io b io c	count=2
return	copy the rest unchanged ||| c d	count=1
module	the user does not ||| io error	count=2
args	a binary function to ||| a b c applicative a	count=1
function	retrieve the system event ||| get system event	count=1
function_return	[function_args_1] a storable ||| [function_args_1] [return_2]	count=2
args	or a returned value ||| io a $f_2$ either someexception a	count=1
function	to ||| ptr to	count=2
function	smaller than the ||| r	count=1
function_return	the lex [return_2] ||| [return_2] [function_1]	count=5
module	was an ||| exception base	count=1
function	name the ||| min	count=1
module	to ||| prelude	count=1
args	a block ||| a	count=1
function	occurrence of ||| delete	count=1
return	the io ||| io a	count=4
function	the index ||| constr index	count=1
args	the sense that ||| int	count=1
return	monadic fold over ||| monad	count=2
module	exception is ||| exception base	count=1
return	the mapaccumr function behaves ||| acc $list$ y	count=1
function_return	to offset [return_2] ||| [return_2] [function_1]	count=8
args	pointer living inside a ||| $f_2$ ptr a io	count=2
function	bounds ||| of bounds	count=2
module	of hdl ||| io handle	count=3
return	a storable type in ||| io ptr storable	count=1
args	and always returns () ||| readp a	count=1
args	the given number of ||| int $f_2$	count=1
return	returns the specified character ||| char	count=1
args	version ||| a $f_2$ a a	count=1
args	a ||| e f g $list$ a $list$	count=1
args	handle and file ||| handle maybe	count=1
return	the required ||| io ptr	count=1
module	datatype ||| ghc generics	count=2
function	run ||| run in bound	count=1
module	of !!, which ||| data	count=1
args	user-supplied equality predicate ||| a a bool $list$ a	count=1
function	allow the ||| fix st	count=3
function	sets the position ||| set posn	count=2
function	hdl returns the current ||| get posn	count=2
function	uses the default ||| with default	count=1
function	in binary mode ||| open binary	count=1
return	the simplest rational ||| rational	count=1
function	monad ||| monad	count=1
module	process the ||| system	count=1
args	number of ||| int ptr	count=1
module	nul terminated c ||| foreign c string	count=1
function	action with ||| with	count=1
args	return value from the ||| a io	count=2
return	buffer ||| int buffer	count=1
return	within a computation ||| a	count=1
args	witharray but ||| ptr storable io	count=1
args	with a pure ||| $f_2$ c d arrow	count=1
return	buffer ||| $tuple_2$ int buffer	count=1
args	x ||| bits int	count=1
args	value ||| io a	count=2
function	adjust the storage area ||| pooled realloc bytes	count=1
module	convert from the ||| ghc	count=1
args	a binary ||| a applicative	count=1
function	a third value ||| id	count=1
module	parser combinators [module_2] ||| [module_1] [module_2]	count=2
args	the given [args_2] ||| [args_1] a [args_2]	count=2
module	and ||| data char	count=4
return	occur within a ||| ioerror a	count=1
module	from the environment of ||| environment	count=1
return	its representation ||| rep generic x	count=1
function	by a stable ||| stable	count=1
args	[args] b ||| mvar [args] a	count=3
return	state transformer [return_2] ||| [return_2] [return_1]	count=16
args	explicit length information ||| $f_2$ cstringlen io	count=2
function	the sort function implements ||| sort	count=1
function	act opens a file ||| with binary file	count=1
return	precedence context by ||| readprec	count=1
function_return	[function_1] associativity ||| [function_1] [return_2]	count=2
return	function is used ||| $tuple_2$ buffer from buffer	count=2
module	into a c ||| c string	count=1
return	pair of lists ||| $list$	count=1
function	system event ||| system event	count=1
function_args	right by [args_2] ||| bits rotate [function_1] [args_2] bits	count=1
args	predicate and ||| bool $list$ a	count=1
function_return	[function_1] real ||| [return_2] [function_1]	count=1
function	to take ||| generic take	count=1
module	current ||| exception base	count=1
return	those that didn t ||| $tuple_3$	count=1
return	function is used ||| from buffer	count=2
return	retagging and merging ||| b b' either c	count=1
args	specified handle ||| handle string	count=1
function	handle the sign of ||| sign	count=1
return	makes a ||| a	count=1
args	from the representation ||| rep generic x	count=1
function_return	[function_args_1] the computation ||| [function_args_1] [return_2] r	count=4
args	a binary function ||| b c applicative a applicative b	count=1
return	[return_1] realfrac ||| [return_2] [return_1]	count=1
module	an encoding [module_2] ||| [module_2] [module_1] char8	count=1
function	type representation ||| type rep args	count=4
module	proxy type for use ||| proxy	count=1
args	pointer to a ||| storable $f_2$ ptr storable io	count=1
module	io ||| io	count=7
return	in arrow notation ||| arrow	count=1
function	[function_1] blocking ||| [function_1] [function_2]	count=2
function	end of the ||| end	count=1
module	of hdl is set ||| handle	count=3
function	to ||| min bound	count=1
args	to a ||| traversable a	count=2
function	this accumulator together ||| accum	count=3
args	like addforeignptrfinalizerenv ||| env a ptr env foreignptr	count=2
args	conversion scheme between ||| io textencoder estate	count=1
return	returned by the io ||| io	count=1
args	complex number and ||| complex realfloat	count=1
return	but returns a quadruple ||| $list$ string $list$ string	count=1
return	does not pass a ||| a	count=2
module	flush ||| io bufferedio	count=2
return	[return_1] stablename ||| [return_2] [return_1]	count=4
module	used to ||| prelude	count=1
return	pair in ||| $tuple_2$ realfloat	count=1
args	finally close ||| close	count=1
return	of evaluation such as ||| functor	count=1
function	concatenation of ||| concat	count=2
return	thrown when ||| errorcall	count=2
module	unicode encoding ||| ghc io encoding	count=1
module	of copying for the ||| ghc	count=1
return	the io action ||| io ptr	count=1
return	rest unchanged to the ||| d	count=1
module	as ||| ghc exts	count=2
args	string using ||| string	count=1
args	a fresh memory pool ||| $f_2$ pool	count=1
function_args	[function_1] [args_2] ||| [function_1] bytes [args_2]	count=4
module	number of ||| data list	count=2
args	[args] line column ||| [args]	count=1
return	storable type in the ||| storable	count=1
args	function to a curried ||| c a	count=1
module	scanl ||| list	count=2
module	where the array ends ||| marshal array	count=1
function	same as ||| set bit	count=1
return	return the number ||| maybe int	count=1
return	mapaccumr function behaves ||| acc $list$ y	count=1
function	but only performs ||| on error	count=1
return	used ||| buffer	count=2
function	[function] explicit length ||| [function] castring	count=3
args	yields true ||| $f_2$ a bool	count=1
function	handle the sign ||| sign	count=1
return	a version of catch ||| a	count=2
return	read ||| reads	count=1
args	to a predicate ||| $f_2$ a bool $list$ a	count=2
return	the number of the ||| io $tuple_2$ int bool	count=2
function	on zipping ||| zip	count=1
function	file ||| get file	count=1
return	returns the number ||| $tuple_2$ int	count=3
return	a variant ||| either b a	count=1
return	message to stderr and ||| a	count=1
args	scanning the ||| a4	count=1
args	monomorphic type constructor to ||| tycon	count=1
args	case no result is ||| a	count=1
module	of ||| data maybe	count=1
function	if the operation ||| if	count=1
function_return	[function_1] value ||| [function_1] int [return_2]	count=1
function	allocation limit ||| allocation limit	count=7
args	type where ||| ioerrortype	count=1
function	to the error message ||| error	count=1
function	printf ||| printf	count=1
function	stack trace to the ||| stack trace	count=1
return	function takes a ||| $list$ a $list$	count=2
args	copy the given ||| ptr storable ptr storable	count=1
args	maybe value ||| b maybe	count=1
args	executed ||| mvar	count=1
args	the file handle ||| string maybe handle maybe	count=1
function	to drop ||| drop	count=1
args	into a nul terminated ||| cstring io	count=1
function	defining left = leftapp ||| left	count=1
function	from hdl or ||| h	count=1
module	update ||| ghc event	count=1
args	a list of ||| $f_2$ b res $list$ a $f_2$ $list$	count=1
return	a pair ||| a	count=2
function	disable ||| disable	count=2
function	error that [function_2] ||| [function_2] [function_1]	count=2
args	value produced by ||| a monad	count=2
args	monad scanning the ||| monad a2 monad a3 monad a4 monad	count=1
module	io ||| system io error	count=1
args	given number of elements ||| int	count=2
args	actions discarding any value ||| a monad	count=1
function_return	[function_1] arrow ||| [return_2] [function_1]	count=1
args	the either ||| b c either a	count=1
module	within ||| ghc conc	count=1
return	associativity of a constructor ||| associativity	count=1
function	channel managed by ||| h	count=2
return	associated with the ||| io	count=1
args	inside a ||| a io b	count=2
function	first component of ||| first	count=1
return	returns ||| $list$ string $list$ string $list$	count=1
return	; the copied ||| io	count=1
function	pointer ||| ptr to	count=1
return	device without ||| word8	count=1
args	fresh memory pool ||| $f_2$ pool	count=1
args	elements ||| $list$ a	count=5
function	[function_1] [function_2] associates a finalizer ||| [function_1] [function_2]	count=4
return	return a ||| a	count=1
function	is used to name ||| bound	count=1
args	same ||| word#	count=1
function_args	lift [args_2] ||| [args_2] [function_1]	count=4
args	mapmaybe function ||| $f_2$ a maybe b $list$	count=1
function	this accumulator together ||| map accum	count=1
module	the computation iseof ||| ghc io handle fd	count=1
args	of ||| $list$ constr	count=2
function	similar to mallocarray0 ||| foreign ptr array0	count=1
args	[args] swapped around ||| [args] exception io a	count=6
return	argument arrow and ||| arrow $tuple_3$ b	count=1
args	takewhile applied [args] p ||| [args]	count=1
function	an arbitrary ||| make	count=1
module	causes ||| foreign foreignptr	count=1
function	atomically ||| atomically	count=2
args	specified ||| int	count=1
module	error ||| text printf	count=1
args	analysis for the either ||| $f_2$ b c either	count=1
args	inside a ||| $f_2$ ptr a	count=2
function	bytes of storage ||| pooled malloc bytes	count=1
module	that can [module_2] ||| [module_1] [module_2]	count=4
function	shift the argument left ||| shift l	count=1
module	[module_1] numeric representation ||| [module_2] [module_1]	count=1
module	of xs ||| data list	count=1
module	the computation iseof ||| handle fd	count=1
function	terminal ||| terminal	count=1
args	the either type ||| $f_2$ b c either a	count=1
function_args	[function_1] of datatypes ||| [args_2] [function_1]	count=2
args	number ||| int $f_2$ ptr storable	count=1
module	fresh ||| marshal	count=1
return	for versions in the ||| version	count=1
return	value lies between 0 ||| shows	count=1
args	to a ||| monad b traversable a	count=2
function	range 0 ||| to digit	count=1
args	[args] swapped ||| [args] exception io a	count=6
return	the number of ||| $tuple_2$ int bool	count=3
function	is ||| set bit	count=2
args	header first argument and ||| $list$ optdescr	count=1
return	rest unchanged to ||| d c d	count=1
function	marshal a c ||| cstring	count=1
return	value of ||| applicative a	count=1
return	a handle is ||| io handle	count=1
return	[return_1] either result ||| [return_1] [return_2]	count=2
args	string ie character ||| string	count=1
return	character if ||| char	count=1
return	elements of a container ||| $list$ a	count=1
function	to name the upper ||| min bound	count=1
function_args	with a [args_2] ||| [function_1] [args_2]	count=2
function	read a string ||| read	count=1
return	list of ||| io $list$ statickey	count=1
function	used to name ||| min bound	count=1
function	file using openbinaryfile ||| with binary file	count=1
function	the field labels ||| fields	count=1
args	second argument is executed ||| mvar a $f_2$ a	count=1
args	their point-wise combination analogous ||| c $list$ d $list$ e	count=1
function	[function_1] blocking mode ||| [function_2] [function_1]	count=2
function_args	pair of [args_2] ||| [args_2] [function_1]	count=1
module	because the user does ||| io error	count=2
args	stablename ||| stablename a stablename b	count=2
function	finalizer ||| foreign ptr finalizer env	count=4
args	predicate ||| $f_2$ a bool string io a	count=1
module	an overloaded version of ||| data list	count=2
module	failed because the ||| io	count=2
module	with the same ||| exts	count=1
module	posix data types ||| posix	count=1
module	whether gc stats ||| ghc stats	count=1
args	file handle ||| string maybe handle	count=1
function_return	contents of the [function_1] [return_2] ||| [function_1] [return_2]	count=1
module	datatype to ||| ghc generics	count=2
module	do ||| handle	count=1
args	the predicate ||| $f_2$ a bool $list$	count=1
function	limits of a type ||| min	count=1
function	extra element to ||| array0	count=1
module	that the ||| ghc conc	count=2
return	thread is ||| threadid	count=1
module	run ||| ghc conc	count=1
return	the given ||| io	count=3
return	the pair of lists ||| $list$	count=1
module	of types ||| data typeable	count=3
args	the mapmaybe function ||| maybe b	count=1
module	a sequence of ||| data	count=1
module	variant of foldl ||| data	count=1
function	[function_1] if ||| [function_1] [function_2]	count=10
return	phase pair in ||| $tuple_2$ realfloat	count=1
return	lists ||| a $list$	count=1
function	the zip5 function takes ||| zip5	count=1
return	an either ||| io either	count=1
module	type ||| exts	count=1
function	to the corresponding haskell ||| cuchar to	count=1
return	returns a tuple ||| $list$ a	count=1
function	foreign object ||| foreign ptr	count=2
function	return the current ||| h get	count=2
module	an unsigned integral ||| ghc exts	count=1
function_return	[function_1] the ||| [function_1] [return_2]	count=4
return	return the number of ||| maybe int	count=1
args	out to the ||| bufferedio	count=1
function	catchjust is like catch ||| catch just	count=1
return	returns true ||| bool	count=2
return	the target ||| io	count=1
function_args	[function_1] predicate ||| [args_2] [function_1]	count=2
module	pair of ||| data	count=1
return	[return_1] memory ||| [return_2] [return_1]	count=4
module	[module_1] c byte ||| [module_2] [module_1]	count=2
args	any integral ||| integral	count=1
module	of scanl that ||| data list	count=2
function	arbitrary ||| make stable name	count=2
return	value of ||| a	count=4
function	mallocarray0 but ||| foreign ptr array0	count=1
return	to any monadplus ||| monadplus	count=1
module	element [module_2] ||| [module_2] [module_1]	count=2
function	offset ||| relative	count=2
args	type in the pool ||| pool	count=1
function	blocked on ||| blocked on	count=3
function	foreign ||| with foreign ptr	count=2
function	unsigned ||| w#	count=1
function	performs the ||| on error	count=1
args	a list of storable ||| storable $f_2$ ptr storable io	count=1
module	the error code eintr ||| error	count=1
module	the error code eintr ||| c error	count=1
function_args	[function_1] string ||| [function_1] put str [args_2]	count=1
module	converting a ||| text	count=1
function	on an ||| on	count=2
args	handle ||| handle int	count=1
function_args	fill [args_2] ||| [args_2] [function_1]	count=2
function	list using square brackets ||| list with	count=1
return	final value ||| $tuple_2$ a traversable	count=1
function	suffix of ||| suffix of	count=1
args	file handle ||| handle maybe filepath	count=1
function_args	public representation [args_2] ||| [args_2] [function_1]	count=2
module	current ||| control exception	count=1
return	this variant [return_2] ||| [return_1] [return_2]	count=1
module	terminated c ||| c	count=2
args	six-tuples ||| e f	count=1
args	executed with ||| mvar a $f_2$ a io $tuple_2$	count=1
args	is a reverse application ||| a $f_2$ a b	count=1
function	channel managed by hdl ||| h	count=2
function	[function_1] manager ||| [function_2] [function_1]	count=4
return	a version of ||| a	count=4
function	a stack trace to ||| stack trace	count=1
args	a monad scanning the ||| monad a3 monad a4 monad	count=1
function	system ||| get system	count=1
return	through the argument arrow ||| arrow $tuple_3$	count=1
args	for the either type ||| a c $f_2$ b c either a b	count=1
args	finalized pointer ||| env a ptr env ptr a	count=1
module	c string into ||| foreign c	count=1
return	value as ||| $list$ a	count=1
function	[function_1] not exist ||| [function_2] [function_1]	count=2
args	the [args] file file ||| filepath [args]	count=1
function	memory ||| pool	count=1
return	arrows retagging and merging ||| b b' either c c'	count=1
return	the ||| io ptr	count=4
args	promote a function ||| a3 a4 r monad a1 monad a2	count=1
function	create a [function_2] ||| [function_2] [function_1]	count=2
module	given parser ||| text parsercombinators	count=2
return	arrows retagging and merging ||| b b'	count=1
args	promote a function to ||| a1 monad a2 monad a3 monad	count=1
return	arrow ||| arrow $tuple_3$	count=1
args	type where the second ||| ioerrortype	count=1
module	trace ||| ghc rts flags	count=2
return	after the action ||| io	count=1
return	text encoding for the ||| io	count=1
args	for the given number ||| int	count=4
args	in the pool ||| pool	count=3
function	[function_1] signed ||| [function_1] [function_2]	count=1
module	an unsigned integral type ||| ghc	count=1
function_args	[function_1] number ||| [args_2] [function_1]	count=10
args	rational value ||| rational	count=1
args	with a ||| $f_2$ b c	count=1
module	cpu time ||| ghc	count=1
module	in ||| sync	count=1
function	thread is blocked on ||| thread blocked	count=2
return	returned tvar to ||| io tvar	count=1
function	splits ||| split ty	count=2
args	structure ||| a applicative b foldable	count=1
function_args	modifying [args_2] ||| [args_2] [function_1]	count=1
module	traceio function outputs ||| debug	count=1
args	a nul terminated c ||| $f_2$ cstring	count=1
args	any value ||| monad a monad b	count=1
args	given number of ||| ptr a ptr a int	count=2
module	given parser ||| parsercombinators readp	count=2
function_return	[function_args_1] monadic action ||| [function_args_1] [return_2]	count=1
function	the least element of ||| minimum	count=1
function	index of a ||| constr index	count=1
args	predicate and two ||| bool	count=1
args	but with the arguments ||| $f_2$ a monad b monad	count=1
module	of foldr that has ||| data	count=2
args	the ||| bits int	count=1
args	stablename ||| stablename b	count=2
return	is used [return_2] ||| [return_2] [return_1]	count=8
args	a signed [args_2] ||| [args_1] [args_2]	count=8
args	conditionally prove ||| testcoercion b	count=1
args	fresh memory pool ||| pool	count=1
return	and returns the threadid ||| threadid	count=2
function	to handle the sign ||| sign plus	count=1
module	an error indicating that ||| error	count=1
function_return	[function_1] for the ||| [return_2] [function_1]	count=3
function	printf except that output ||| h printf	count=1
args	an active ||| timermanager timeoutkey	count=1
module	of ||| data type coercion	count=2
function_return	[function_1] i ||| [return_2] [function_1]	count=7
args	where the ||| ioerrortype string	count=1
args	a tvar ||| tvar	count=2
function	prefix of the ||| prefix of	count=2
function	appropriately scaled exponent ||| decode float	count=1
function_args	[function_1] a signed ||| [function_1] gfloat [args_2]	count=1
module	[module] function f ||| [module]	count=3
module	write ||| conc sync	count=1
module	an unsigned ||| ghc exts	count=1
function	catch ||| catch	count=1
function_args	[function_1] [args_2] ||| [function_1] filepath [args_2]	count=4
args	of a structure ||| b b foldable a	count=1
function	replicate n x ||| replicate	count=1
args	pointer to a ||| $f_2$ ptr	count=2
function	drop ||| drop	count=1
return	an exception of type ||| exception	count=2
module	c wide ||| c string	count=1
return	a type constructor application ||| $tuple_3$ tycon $list$ kindrep $list$ typerep	count=1
function	modified ||| modify ioerror	count=2
function	throw ||| throw stm	count=4
return	type constructor application ||| $tuple_3$ tycon $list$ kindrep $list$ typerep	count=1
args	handle to ||| maybe handle	count=1
function	megabytes allocated ||| megabytes allocated	count=2
return	a computation to ||| io a	count=2
function	pointer to an address ||| ptr to ptr	count=1
module	of lists ||| data list	count=2
return	the associativity of ||| associativity	count=1
module	within ||| conc	count=1
function_args	[function_1] signed realfloat ||| [function_1] gfloat [args_2]	count=1
return	string for a constructor ||| string	count=1
return	of ||| a	count=1
function	use traceevent or ||| trace event	count=1
return	the eventlog ||| io	count=1
return	and merging ||| b' either c c'	count=1
return	textencoding is a ||| textencoding	count=1
function	the file ||| open file	count=1
function	stack ||| with stack	count=1
args	non-options a ||| argorder a	count=1
return	ptr ||| ptr	count=3
return	pair in canonical form ||| $tuple_2$	count=1
args	be returned ||| a $f_2$	count=1
return	except that a handle ||| io handle	count=1
args	by -i ||| int	count=1
args	isprefixof ||| $list$ eq	count=1
module	of ||| data fixed	count=1
module	container of ||| data foldable	count=2
return	value pairs ||| $tuple_2$ string	count=1
return	the pair of lists ||| $tuple_2$ $list$ a $list$	count=1
module	io operation ||| system io	count=2
args	promote a function to ||| r monad a1 monad a2 monad	count=2
function	the newly created thread ||| fork	count=2
function	written to a ||| write	count=3
args	of the field ||| fieldformat	count=1
function	signed type ||| signed	count=1
function	system event [function_2] ||| [function_1] [function_2]	count=1
args	there are no bytes ||| bufferedio buffer word8	count=1
return	a tuple ||| $list$ a	count=1
return	the buffer without blocking ||| io $tuple_2$ maybe int buffer word8	count=1
args	signed realfloat value using ||| maybe int realfloat	count=1
args	stablename that does not ||| a stablename	count=1
return	of a storable type ||| io ptr storable	count=2
args	non-empty ||| $f_3$	count=1
args	a binary function ||| b c applicative a	count=1
function	heap is reaching its ||| heap	count=2
return	the memory ||| io foreignptr	count=2
function	like [function_1] [function_2] ||| [function_1] [function_2]	count=2
function	file ||| file with	count=1
args	on stablename ||| a stablename	count=1
module	[module_1] [module_2] five-tuples analogous to zip ||| [module_2] [module_1]	count=2
return	operating on the contents ||| io	count=1
module	primary ||| text printf	count=1
return	monadic type ||| monad	count=1
args	equality predicate instead ||| a a bool	count=1
function	bytes [function_2] ||| [function_2] malloc [function_1]	count=2
module	posix ||| posix	count=1
function	the current thread for ||| thread	count=1
args	equality predicate ||| $f_3$ a a bool $list$ a	count=1
function	stack trace to ||| stack trace	count=1
args	with the same size ||| word#	count=1
args	a predicate ||| $f_2$ a bool $list$	count=2
return	pair of lists ||| $tuple_2$ $list$ b $list$	count=1
return	x the value ||| a	count=1
function	file using openbinaryfile and ||| file	count=1
args	true and ||| bool	count=1
module	ghc only ||| ghc conc sync	count=4
function	to read from a ||| read	count=1
function	reference into a foreign ||| foreign	count=2
function	latin-1 character to the ||| cast cuchar to	count=1
return	application ||| $list$	count=2
args	conversion scheme between ||| dstate io textencoder estate	count=1
return	of the original handle ||| io handle	count=1
return	of the newx functions ||| io	count=1
return	a block of memory ||| io ptr storable	count=1
args	> string as ||| string string	count=1
function	throwerrnoifminus1retrymayblock but discards the ||| minus1retry may block_	count=1
return	a ||| either ioerror a	count=1
function_return	lift a [return_2] ||| [function_args_1] [return_2]	count=1
args	number of microseconds ghc ||| int	count=1
return	readprec ||| readprec	count=1
function	map each element of ||| map m	count=1
args	determines whether a character ||| char	count=1
module	fresh memory ||| marshal	count=1
return	argument arrow and ||| arrow	count=1
return	a and ||| a	count=1
function	to index an array ||| index	count=1
args	any value produced by ||| monad a monad	count=1
args	to a predicate ||| $f_2$ a bool $list$	count=2
return	[return_1] number ||| sync get num capabilities [return_1] [return_2]	count=2
return	to actions ||| applicative d	count=1
function	upper and lower limits ||| min	count=1
function_return	[function_args_1] [return_2] ||| [function_args_1] [return_2]	count=93
args	the [args] ||| filepath [args]	count=3
function	the foreign object ||| foreign	count=2
return	hgetbuffering ||| buffermode	count=2
function	managed ||| h	count=2
module	encode ||| io encoding types	count=1
function_args	[function_1] [args_2] ||| [function_1] malloc array pool [args_2]	count=6
function	lazy one ||| lazy st	count=2
rep	[module_1] [function_return_2] ||| [module_1] slide [function_return_2]	count=4
function_return	[function_1] chan ||| [return_2] [function_1]	count=1
args	over ||| $f_2$ a	count=2
return	the elements ||| $list$	count=1
args	the string s ||| string	count=1
module	between ||| text parsercombinators readp	count=1
function	event ||| event	count=1
return	io ||| io either	count=1
args	integral ||| integral $list$	count=2
args	finally close ||| close readp	count=1
function_args	[function_1] the structure ||| [args_2] [function_1]	count=2
args	an exception [args_2] ||| [args_2] [args_1]	count=8
function	args ||| args	count=1
module	managed ||| io handle	count=1
return	its contents after the ||| io b	count=1
return	the computation exitfailure is ||| io a	count=1
function	[function_1] [function_2] ||| [function_1] default [function_2]	count=1
args	[args] sets the ||| handle [args]	count=1
function	has been reached ||| eof	count=1
rep	of [function_args_2] ||| [module_1] [function_args_2]	count=2
args	inside a ||| $f_2$ ptr a io b	count=2
function	lazy one ||| lazy	count=2
function	combine ||| fold	count=1
function	[function_1] the end ||| [function_1] [function_2]	count=2
module	dual of scanl ||| data list	count=2
module	between values of ||| data	count=1
args	function takes a predicate ||| bool $list$ a	count=1
module	useful in situations where ||| control exception base	count=1
args	is a reverse application ||| a	count=1
args	value from ||| a io b io	count=2
args	pointer to ||| $f_2$ ptr storable io	count=2
return	into the buffer blocking ||| io $tuple_2$ int buffer word8	count=1
module	applied to a ||| ghc oldlist	count=1
return	the non-overloaded version ||| $list$ a	count=2
function	a stable [function_2] ||| [function_2] [function_1]	count=1
return	representation ||| rep generic	count=1
return	isjust function returns true ||| bool	count=1
function	hgetposn [function_1] [function_2] ||| [function_2] [function_1]	count=2
return	be used as a ||| a	count=1
args	but a terminator indicates ||| io	count=1
args	an abstract ||| threadid#	count=2
args	for ||| $f_2$ a bool string io	count=1
args	storable values in ||| storable io	count=1
module	allocate a fresh ||| pool	count=1
args	a value ||| a	count=1
function_args	smaller than [args_2] ||| [args_2] [function_1]	count=3
function	type representation ||| type rep fingerprint	count=4
return	if an exception of ||| exception	count=2
args	the string s to ||| string	count=1
function	an action with ||| with pool	count=1
module	a c byte ||| foreign c string	count=2
return	buffer without ||| io $tuple_2$ maybe int buffer word8	count=1
function	the upper and lower ||| min	count=1
args	list of storable values ||| storable $f_2$ ptr storable	count=1
function	character to the ||| cuchar to	count=1
function	foreign [function_2] ||| [function_1] [function_2]	count=1
function_return	to read [return_2] ||| [return_2] [function_1]	count=1
args	storable ||| $f_2$ ptr storable io b	count=2
module	[module] five-tuples ||| [module]	count=1
args	or a returned value ||| a	count=1
args	functor ||| functor a	count=2
args	a pointer to ||| storable $f_2$ ptr	count=1
function	zip7 ||| zip7	count=1
function	the unzip4 function takes ||| unzip4	count=1
module	where the ||| io	count=5
function	a duplicate of ||| duplicate	count=1
function	drop which accepts any ||| generic	count=1
module	as ||| data bits	count=2
function	unzip7 function ||| unzip7	count=1
return	the buffer to ||| io buffer word8	count=1
return	the buffer ||| io $tuple_2$ int buffer word8	count=1
return	a variant ||| io either b a	count=1
function_return	to read [return_2] ||| wait [function_1] fd [return_2]	count=1
args	given number of microseconds ||| timermanager int	count=1
module	from a ||| data	count=1
args	which accepts any integral ||| integral $list$ a	count=1
function	throw that can only ||| throw io	count=2
module	getopt but ||| getopt	count=1
function	[function_1] to read ||| [function_1] [function_2]	count=5
function	error message if ||| error	count=1
function	one ||| one	count=1
module	allocate a fresh memory ||| foreign marshal	count=1
args	a pointer to a ||| ptr storable io	count=2
function	by defining left ||| left	count=1
module	[module_1] utf-32 ||| [module_2] [module_1]	count=2
args	user-supplied equality predicate ||| $f_3$ a a bool $list$ a	count=1
args	[args_1] but a ||| [args_2] [args_1]	count=2
function	the position of hdl ||| seek	count=1
return	the buffer without blocking ||| $tuple_2$ maybe int buffer word8	count=1
args	of bits ||| bits	count=1
module	of hdl is set ||| io handle	count=3
module	[module] seven-tuples ||| [module]	count=1
args	a value ||| a b traversable a	count=1
function	stack trace to ||| with stack trace	count=2
return	value [return_2] ||| [return_2] [return_1]	count=6
args	actions discarding any value ||| monad a monad b	count=1
return	the number of ||| io $tuple_2$ int bool	count=2
function	left = ||| left app	count=1
args	a structure to a ||| b foldable a	count=2
module	heap ||| exception base	count=1
function	from right to ||| r	count=1
module	components ||| tuple	count=1
module	to its numeric representation ||| utils	count=1
return	value ||| $list$ a	count=2
function	given ||| foreign ptr	count=1
module	including an ||| foreign marshal	count=1
function	trace ||| trace	count=3
args	conditionally prove the ||| testcoercion a testcoercion	count=1
function	given path when appropriate ||| errno path if	count=1
module	an exception is ||| control exception base	count=2
return	monadic action ||| monad	count=2
args	list of storable ||| ptr storable io b	count=1
args	a ||| word#	count=1
args	inside a ||| $f_2$ ptr a io	count=2
function	v format ||| v	count=1
function	channel managed ||| h get	count=2
function_args	suspends the current [function_1] [args_2] only ||| [function_1] [args_2]	count=2
return	into a nul terminated ||| cstring	count=1
args	a list of non-options ||| argorder a $list$ optdescr a	count=1
function	foreign ||| foreign	count=10
function_args	fill [args_2] ||| [function_1] bytes [args_2]	count=2
function	hfilesize hdl ||| h	count=2
args	handle ||| handle ptr a int	count=2
function	same ||| w#	count=1
function	same ||| set bit	count=2
module	argument [module_2] ||| [module_1] [module_2]	count=4
return	foreignptr to ||| io foreignptr	count=2
module	columns of its ||| data list	count=2
function	a line from the ||| get line	count=1
function	wait for ||| wait	count=2
return	returned tvar to ||| tvar	count=1
args	and passes [args_2] ||| [args_2] [args_1]	count=2
args	structure to a ||| traversable a	count=2
return	returns a tuple where ||| a $list$ a	count=1
return	the io action ||| io eq/num	count=1
return	single string which is ||| string	count=1
args	value ||| $f_2$ a monad b	count=2
return	and merging ||| b'	count=1
function	returns a new open ||| open	count=2
function	a combination of map ||| map	count=2
args	type with the same ||| word#	count=1
return	comp exposes io ||| io	count=1
function_return	[function_1] for versions ||| [return_2] [function_1]	count=1
args	[args_1] structure ||| [args_2] monad [args_1]	count=1
function_args	[function_1] [args_2] of bits in the ||| [function_1] [args_2] bits	count=5
return	returns the number ||| io $tuple_2$ int bool	count=2
args	exception ||| exception	count=5
function	to ||| cast fun ptr to ptr	count=1
args	is an abstract type ||| threadid#	count=2
return	and merging their ||| b' either	count=1
function	channel begins empty ||| dup	count=1
return	pair of lists ||| $tuple_2$ $list$ b $list$ c	count=1
function	end ||| end	count=2
module	which may be marshalled ||| ghc exts	count=1
module	command-line and ||| console getopt	count=1
function	a suffix of the ||| suffix of	count=1
module	for a ||| ghc io handle	count=1
args	string ||| string	count=8
return	storable type in the ||| ptr storable	count=1
return	occurs in the computation ||| io	count=1
args	witharray ||| storable $f_2$ ptr storable	count=1
function	!!, which accepts any ||| generic	count=1
rep	version of [function_args_2] ||| [module_1] [function_args_2]	count=2
return	type funptr ||| funptr	count=1
args	executed with ||| mvar a $f_2$ a io $tuple_2$ a	count=1
function_return	given [return_2] ||| [return_2] [function_1]	count=2
args	for lifetime lt ||| event lifetime	count=1
return	application ||| $list$ typerep	count=2
return	and ||| a	count=2
args	the ||| v maybe io	count=1
function_return	[function_1] a string ||| [function_1] filepath io [return_2]	count=2
function	delete ||| delete	count=1
return	function returns true ||| bool	count=2
args	equality on stablename ||| stablename a stablename	count=1
function	function coerce ||| coerce	count=1
return	item ||| item	count=1
function	an action with a ||| with pool	count=1
return	[return_1] memory required ||| [return_1] [return_2]	count=4
module	fixed point of the ||| data	count=1
function	fork a ||| fork	count=1
function	splits ||| split	count=2
args	scanning the ||| a2 monad a3 monad a4 monad	count=1
module	equivalents of the types ||| types	count=1
function	set to offset ||| relative seek	count=2
function	the lex ||| lex	count=1
return	specified number ||| int	count=1
return	memory reference into a ||| a	count=1
args	scanning the ||| monad a2 monad a3 monad a4 monad a5	count=1
return	int ||| int	count=6
args	scanning ||| a4 monad a5	count=1
function	the exception ||| some exception	count=1
args	argument is executed with ||| mvar a $f_2$ a io $tuple_2$ a	count=1
args	readfile function reads ||| filepath	count=1
return	to the eventlog ||| io	count=1
return	through the argument arrow ||| arrow $tuple_3$ b d c	count=1
return	place in [return] ||| [return]	count=2
module	and currency symbols ||| data	count=1
return	memory area ||| foreignptr storable	count=2
return	may be ||| finalizerptr	count=1
args	within ||| exception	count=2
args	a ||| $list$ a $list$	count=2
function	[function_1] use ||| [function_2] [function_1]	count=2
function	funptr ||| fun ptr	count=1
function	list of ||| to list	count=1
function	an extra position to ||| array0	count=1
args	non-options a list ||| argorder a $list$	count=1
args	element in the pool ||| pool ptr	count=2
function_return	[function_1] with the ||| [return_2] [function_1]	count=4
function	allocation ||| allocation	count=5
function	if the operation yields ||| errno if	count=1
return	function takes a ||| a $list$	count=3
args	[args] empty ||| [args]	count=3
return	the number of the ||| int	count=3
args	with ||| $f_2$ c d	count=1
function	traceevent or ||| event	count=1
args	given ||| ptr	count=4
args	value ||| $f_2$ either someexception a	count=1
function	like [function_1] [function_2] ||| system io [function_1] [function_2] filepath iomode io handle	count=2
args	nul terminated c ||| $f_2$ cstring	count=1
return	in arrow notation ||| arrow b	count=1
return	computes the ||| io fingerprint	count=2
module	a sequence of types ||| data typeable	count=1
return	[return_1] [return_2] ||| [return_1] chan [return_2]	count=3
args	given ||| storable/eq ptr	count=1
module	hdl is set to ||| ghc io handle	count=3
args	catch any ioerror ||| $f_2$ ioerror ioerror	count=1
function	the ||| set	count=1
return	plain memory reference ||| foreignptr	count=2
function_return	[function_1] asynchronous ||| [return_2] [function_1]	count=2
module	error ||| control exception	count=1
module	[module_1] [module_2] == function ||| [module_1] [module_2]	count=2
args	a list of marshalled ||| res $list$ a $f_2$ $list$	count=1
return	to [return] ||| io [return]	count=2
module	convert a c ||| foreign c string	count=6
function	foreign object ||| foreign	count=6
function	arbitrary ||| make stable	count=1
module	do ||| ghc io handle	count=1
args	a structure to a ||| b traversable a	count=2
module	[module_1] mappend ||| [module_1] [module_2]	count=2
args	promote a function ||| a4 r monad a1 monad	count=1
module	it the combination of ||| utils	count=1
module	[module] and ||| [module]	count=2
return	the given ||| io ptr a	count=1
module	position of hdl is ||| handle	count=1
args	supplied chan much like ||| chan a	count=1
args	structure [args] ||| a monoid foldable [args]	count=1
module	its [module] ||| data [module]	count=1
args	a ||| ptr a	count=4
return	and the external ||| newlinemode	count=1
args	the pool ||| pool ptr a int	count=1
function	[function_1] threads ||| [function_1] [function_2]	count=1
args	file handle and file ||| handle maybe filepath	count=1
args	string ie ||| string	count=1
args	[args_1] structure ||| [args_2] [args_1]	count=17
function_return	[function_1] buffer ||| [return_2] [function_1]	count=3
args	like witharray ||| ptr storable	count=1
args	non-options a list ||| argorder a $list$ optdescr a $list$ string	count=1
module	used ||| prelude	count=1
function	flush data from ||| flush	count=1
return	number of ||| $tuple_2$ int bool	count=3
function	[function_1] module where ||| [function_2] [function_1]	count=2
args	representing a latin-1 ||| cchar	count=1
return	is used to continue ||| io $tuple_2$ buffer from buffer to	count=2
module	a c wide ||| c	count=1
args	the same ||| bits int	count=1
return	[return] encoding of ||| io [return]	count=1
module	components of magnitude and ||| data complex	count=1
return	for the end ||| io ptr storable	count=1
args	of non-options ||| argorder a $list$ optdescr a $list$	count=1
function	the sum of the ||| sum	count=1
function	of map and ||| map	count=2
return	rest through unchanged ||| c d	count=1
args	satisfy the predicate ||| $f_2$ a bool $list$ a	count=1
args	second argument is executed ||| mvar a	count=1
function	evaluate these actions from ||| m_	count=2
args	memory pool ||| $f_2$ pool io b	count=1
module	of strings ||| data	count=2
return	string for a ||| string	count=1
args	describes [args_2] ||| [args_1] [args_2]	count=1
return	textencoding is ||| textencoding	count=1
args	number ||| int $f_2$	count=1
module	of terminating the program ||| system io	count=1
function	duplicate of the ||| h duplicate	count=1
args	quadruples ||| c d	count=1
function	run ||| run in	count=2
args	any integral ||| integral $list$	count=1
args	in the structure ||| foldable applicative a	count=1
return	returns a tuple ||| a	count=1
function	of a ||| min bound	count=1
args	or more characters ||| char	count=2
args	describes ||| $list$ string argdescr	count=1
return	returning a final value ||| a traversable c	count=1
function	[function_1] buffering ||| [function_1] [function_2]	count=8
function	convert an array ||| array	count=1
args	function ||| $tuple_2$ a b	count=1
module	an ieee ||| prelude	count=1
return	that traverse ||| traversable b	count=1
module	test for a ||| data	count=1
function	run ||| run	count=1
function_return	read [return_2] ||| wait [function_1] fd [return_2]	count=1
args	an active ||| timermanager	count=1
function_return	[function_1] returns a ||| [function_1] int $list$ a [return_2]	count=1
module	terminating the program ||| system	count=1
function	[function_1] permissions ||| [function_2] [function_1]	count=4
function	drops the given prefix ||| strip prefix	count=1
return	the ||| io $tuple_2$	count=1
args	realfloat value ||| realfloat	count=4
module	of magnitude ||| data complex	count=1
return	for storable type ||| storable	count=1
function	the query element or ||| elem	count=1
args	handle ||| ioerror string maybe handle	count=1
module	inject ||| control monad instances	count=1
return	the first computation is ||| io	count=2
function	[function_1] contents ||| [function_2] [function_1]	count=1
args	the ||| a int	count=4
args	predicate ||| $f_2$ a bool $list$ a	count=6
function	operation ||| operation	count=1
return	a weak pointer to ||| io weak	count=1
args	any value produced by ||| monad a	count=1
function	to the corresponding haskell ||| cchar to	count=1
module	suffix of xs after ||| data list	count=1
function	write a ||| write	count=2
args	a memory area that ||| ptr a	count=1
args	hierarchy ||| e	count=1
function_return	[function_1] by the ||| [return_2] [function_1]	count=1
module	[module_1] [module_2] which ||| [module_2] [module_1]	count=2
function	fresh memory ||| new	count=1
return	memory reference into a ||| foreignptr a	count=1
function	x ||| set bit	count=2
function	to name the ||| min	count=1
return	outputs ||| arrowchoice either b	count=2
return	either result which is ||| io either	count=1
args	return value from the ||| io a io	count=2
function	of the exception type ||| some exception	count=1
function	character to the corresponding ||| cast cuchar to	count=1
module	postcomposition ||| control arrow	count=1
function_args	[function_1] number of ||| [function_1] malloc array0 pool [args_2]	count=1
function	denominator ||| denominator	count=1
args	[args_1] [args_2] ||| [args_1] a [args_2]	count=4
function	(*) [function] f = ||| [function]	count=1
module	from the environment of ||| system environment	count=1
return	function returns ||| $list$ $list$ a	count=2
return	a memory area that ||| a	count=1
args	exception ||| exception maybe b io	count=2
args	given marker element ||| $list$ storable	count=1
return	reads an [return_2] ||| [return_1] [return_2]	count=2
return	of mkweak where the ||| weak k	count=2
module	from an ||| control	count=1
module	of a ||| data typeable internal	count=4
return	arrow and copy the ||| arrow $tuple_3$ b d	count=1
args	value ||| io a $f_2$ either someexception a	count=1
function	cpus ||| get num processors	count=4
function	to an address ||| to	count=1
args	describes ||| string argdescr	count=1
module	of ||| prelude	count=1
return	and return a foreignptr ||| foreignptr	count=2
args	function takes a predicate ||| $list$ a	count=1
function	allocation counter ||| set allocation counter	count=2
module	error code eintr ||| c error	count=1
args	witharray but a terminator ||| $f_2$ ptr storable io b	count=1
return	real value ||| real	count=1
return	duplicate a chan the ||| io chan a	count=1
function	[function_1] bounds ||| [function_2] [function_1]	count=5
return	[return] try ||| [return]	count=1
args	the given ||| storable ptr storable	count=2
args	a monad scanning the ||| monad a2 monad a3 monad a4 monad a5	count=1
args	stablename that does not ||| stablename b	count=1
args	actions discarding any value ||| a monad b	count=1
return	the readlist method ||| read	count=1
function	shift the first ||| shift	count=1
function	base specified by the ||| at base	count=1
args	a monad scanning the ||| monad a4 monad	count=1
module	was an exception ||| control exception	count=1
return	returning the result as ||| monad	count=1
module	the operation ||| system io	count=5
module	an error indicating ||| error	count=1
return	a series ||| io a	count=1
args	nul terminated ||| $f_2$ cstring io a	count=1
return	that didn t ||| $tuple_3$ $list$ a $list$ string $list$	count=1
function	hdl to [function_2] ||| [function_2] [function_1]	count=4
function	foldl1 is a ||| foldl1	count=1
module	was an [module_2] ||| [module_1] [module_2]	count=1
args	list is empty ||| $list$	count=1
module	upper and lower ||| prelude	count=1
return	the elements of a ||| $list$ a	count=2
function_return	[function_1] associativity of ||| [return_2] [function_1]	count=2
function	managed by ||| h get char	count=2
module	microseconds ghc ||| ghc	count=1
return	a ||| a	count=59
function	real part ||| real part	count=2
function	default ||| test bit default	count=1
return	character is ||| io char	count=1
return	used ||| from buffer	count=2
module	marshal ||| foreign marshal pool	count=1
return	a ||| a b c d	count=3
args	a curried function ||| b c a b	count=1
args	returned ||| $f_2$	count=1
args	hseek hdl ||| seekmode	count=1
function_return	represent the [return_2] ||| [return_2] [function_1]	count=8
args	over ||| $f_2$ a b functor	count=2
args	conversion scheme ||| string io textdecoder dstate io textencoder estate	count=1
function	putmvar ||| try put	count=1
return	the supplied [return_2] ||| [return_1] mvar [return_2]	count=1
function	accumulator together ||| accum	count=3
return	merging their outputs ||| arrowchoice either b b'	count=1
args	precedence-insensitive readp to ||| readp	count=1
args	mode [args] or text ||| handle [args]	count=2
args	elements of ||| $list$	count=1
args	structure ||| a monad b foldable	count=2
module	up into a list ||| list	count=2
function	this accumulator together ||| map accum l	count=1
function	restore action to the ||| mask_	count=2
module	[module_1] c ||| [module_1] [module_2]	count=11
return	parses the ||| readp string	count=2
module	type with ||| exts	count=1
function	operation was not possible ||| is illegal operation	count=1
args	scanning ||| monad a4 monad a5	count=1
args	the mapmaybe function is ||| a maybe b $list$	count=1
args	equality on stablename that ||| stablename	count=1
args	returns ||| $list$	count=4
function	current thread ||| thread	count=3
args	handle ||| filepath iomode $f_2$ handle io	count=1
module	a temporarily allocated ||| foreign marshal	count=1
args	openfile [args_2] ||| [args_2] [args_1]	count=8
module	of types ||| data typeable internal	count=2
args	exception ||| exception maybe	count=2
module	environment of ||| system environment	count=1
module	microseconds ghc only ||| ghc conc	count=1
return	components and a ||| a	count=1
args	a list of storable ||| storable io b	count=1
function_args	[function_1] number of ||| [function_1] array pool [args_2]	count=1
function	[function_1] copied ||| [function_2] [function_1]	count=4
return	takes a ||| a $list$	count=3
return	into [return_2] ||| [return_2] [return_1]	count=3
module	in the error if ||| io error	count=1
function	current thread [function_2] ||| [function_1] [function_2]	count=11
args	a curried function ||| $tuple_2$ a b c a b	count=1
args	exception predicate ||| $f_2$ exception maybe b io a	count=1
return	representation ||| rep generic x	count=1
args	any value ||| $f_2$ a monad	count=1
args	additional parameter ||| $list$ storable $f_3$	count=1
module	library defines parser combinators ||| parsercombinators	count=1
function	the float type ||| float type	count=1
return	computation hgetline hdl reads ||| io string	count=1
function	and ended by ||| end by	count=1
module	[module_1] of lists ||| [module_2] [module_1]	count=1
args	parameter is true ||| bool shows	count=1
module	data ||| data ord	count=1
function	source location of the ||| src loc	count=1
function	until data [function] ||| thread wait [function]	count=1
function	read an unsigned ||| read	count=2
function	which [function] ||| [function] in use	count=3
args	number ||| int $f_2$ ptr storable io	count=1
return	the buffer ||| int buffer word8	count=1
module	list and ||| list	count=1
function	its arguments does ||| is does	count=1
args	list of non-options ||| argorder a $list$ optdescr	count=1
args	takes an exception ||| exception maybe	count=1
return	mapaccumr function ||| $tuple_2$ acc $list$ y	count=1
function	the module where ||| sp info module	count=1
args	an exception predicate ||| $f_2$ exception maybe b	count=1
function	add an extra position ||| array0	count=1
return	next value from the ||| io a	count=1
return	io computation to ||| io	count=1
function	encountered ||| on coding failure	count=1
module	object ||| system mem	count=2
function_return	[function_1] [return_2] l from the structure ||| [function_1] islist [return_2] islist	count=7
return	returns a ||| string $list$ string	count=1
return	is used to ||| io $tuple_2$ buffer from buffer to	count=2
args	is encapsulated in a ||| a monad b b foldable a	count=1
args	argument is executed with ||| mvar a $f_2$	count=1
function	of number of bytes ||| bytes	count=1
return	is traverse ||| applicative traversable b	count=1
args	promote a function ||| a4 r monad a1 monad a2 monad	count=1
function_return	[function_args_1] a storable ||| [return_2] [function_args_1]	count=2
function	to printf except ||| h printf	count=1
return	the maybetolist function returns ||| $list$	count=1
module	a variant of scanr ||| data list	count=1
return	value ||| $tuple_2$ a	count=1
args	on stablename that ||| a stablename	count=1
return	and throw a ||| a	count=1
args	constructor to a ||| tycon $list$	count=1
module	[module_1] numeric representation ||| [module_1] [module_2]	count=1
args	returned ||| a $f_2$ a	count=1
args	zero or more characters ||| char bool	count=1
function_args	[function_1] readp to ||| [args_2] [function_1]	count=1
function	its argument is ||| is	count=1
args	structure to a ||| monad b traversable a	count=2
args	to an action ||| $f_2$ a applicative b	count=1
module	the contents of an ||| data	count=1
return	returns ||| $list$	count=3
module	is an unsigned integral ||| exts	count=1
args	a new invariant that ||| a	count=2
module	only ||| conc sync	count=3
args	of storable values in ||| storable $f_2$ ptr storable io	count=1
module	the position of hdl ||| io handle	count=1
function	uses the default ||| default	count=1
return	the memory required ||| io foreignptr	count=2
module	from an mvar put ||| control concurrent mvar	count=1
module	integral type with the ||| ghc exts	count=1
function	to ||| char to	count=3
module	and ||| data bool	count=1
args	living inside a ||| ptr a io b	count=2
function	void value ||| void	count=1
return	into the buffer without ||| $tuple_2$ maybe int buffer word8	count=1
module	of xs after the ||| data list	count=1
return	[return_1] from ||| [return_1] [return_2]	count=3
function_args	suspends the [function_1] [args_2] ||| ghc conc [function_1] delay [args_2]	count=5
module	stack ||| exception base	count=1
function	a terminal ||| terminal	count=1
function	can be written ||| write stm	count=3
args	either ||| a c $f_2$ b c either a b	count=1
return	the rest unchanged to ||| b d c d	count=1
function	the system ||| get system	count=1
return	readlist method ||| read	count=1
function	on mvar ||| on mvar	count=4
args	as ||| word#	count=1
args	a curried function ||| $f_2$ $tuple_2$ a b c a	count=1
module	xs of length ||| data	count=1
function	satisfying the ||| munch	count=1
args	the [args] representation ||| integral/show $f_2$ int [args]	count=1
function	throwerrnoif but ||| if	count=1
module	[module_1] use in ||| [module_1] [module_2]	count=2
function	name ||| name	count=2
function	shift the argument ||| i shift	count=1
args	string as ||| string string	count=1
args	structure to ||| foldable	count=3
return	within a computation and ||| ioerror a	count=1
args	the file handle and ||| handle maybe	count=1
args	pointer to a temporarily ||| storable $f_2$ ptr storable io b	count=1
module	the latin-1 subset of ||| data char	count=1
function	hdl [function_2] ||| [function_1] [function_2]	count=2
return	allocate ||| io	count=1
function	ie wide ||| cwstring len	count=1
args	a list of ||| res $f_2$ b res $list$ a $f_2$ $list$	count=1
args	analysis for the either ||| $f_2$ a c $f_2$ b c either	count=1
args	a binary function to ||| a applicative b	count=1
module	an io ||| io error	count=2
function	[function_1] the file ||| system io [function_1] binary [function_2] filepath iomode io handle	count=1
function	of div to any ||| div'	count=1
args	predicate instead ||| $f_3$ a a bool	count=1
module	a nul terminated c ||| foreign c string	count=1
function	no [function_2] ||| [function_2] [function_1]	count=2
module	as x ||| bits	count=1
function_return	the action hsetencoding hdl [function_1] [return_2] ||| [function_1] encoding handle textencoding [return_2]	count=3
function	wish [function] ||| [function]	count=6
function	managed ||| h get	count=2
args	promote a function to ||| a1 a2 a3 a4 r monad a1	count=1
return	the io action meets ||| io	count=1
args	c string ||| string $f_2$	count=1
function	is like catch but ||| catch just	count=1
module	of a character ||| data char	count=1
function_return	[function_1] the buffer ||| [function_1] buffer word8 [return_2]	count=3
args	like addforeignptrfinalizerenv ||| ptr env foreignptr a	count=2
module	like mallocarray but ||| foreign marshal array	count=1
args	as x ||| bits int	count=1
function_return	contents [function_1] [return_2] ||| [function_1] [return_2]	count=1
module	lazy ||| st lazy safe	count=2
return	a ||| ioerror a	count=1
function	is the same as ||| set	count=1
args	value produced by ||| $f_2$ a	count=1
return	breaks a string up ||| $list$ string	count=1
return	list ||| $list$	count=5
return	monadic fold over the ||| monad	count=2
function	transpose function transposes ||| transpose	count=1
function	retry execution of the ||| retry	count=1
args	monadic ||| monad a5	count=1
args	the mapmaybe function is ||| $f_2$ a maybe b $list$	count=1
return	of lists ||| $tuple_2$ $list$ a $list$	count=1
module	recover ||| ghc io encoding	count=1
return	the reference ||| io	count=1
module	precomposition ||| control arrow	count=1
function	extra position ||| array0	count=1
function	format [function_2] ||| [function_2] [function_1]	count=2
module	io operation failed ||| system io error	count=1
return	but returns a quadruple ||| $list$ string	count=1
return	tryioerror comp exposes io ||| io either ioerror	count=1
return	the current value of ||| a	count=1
module	of magnitude ||| data	count=1
module	c int type ||| c	count=1
function_return	[function_1] the fixity ||| [function_1] constr [return_2]	count=1
function	character to ||| to cschar	count=1
args	pool to the ||| pool ptr	count=1
args	which accepts any integral ||| integral $list$	count=1
args	a monad scanning ||| monad a3 monad a4 monad	count=1
function	current thread until data ||| thread wait	count=1
args	is a reverse ||| a b	count=1
return	the sequence of io ||| io	count=2
function_args	[function_1] a ||| [args_2] [function_1]	count=2
args	nul terminated c string ||| textencoding string $f_2$ cstring io	count=1
return	f passing ||| b	count=1
module	first ||| data bifunctor	count=1
args	return value from ||| io a	count=2
function	module where the ||| sp info module	count=1
args	memory pool which gets ||| $f_2$ pool io	count=1
function	map ||| map maybe	count=2
args	any value produced ||| a $f_2$ a monad	count=1
function	the sign of a ||| sign plus	count=1
args	handle ||| filepath iomode $f_2$ handle	count=1
args	mapmaybe [args_2] ||| [args_2] [args_1]	count=3
args	an action ||| $f_2$ a	count=1
module	each element of ||| data foldable	count=1
return	that traverse is ||| traversable	count=1
return	allocate a ||| io	count=1
return	to the eventlog if ||| io	count=1
function	lift ||| lift a2	count=2
function	whether the thread is ||| thread	count=2
function_return	bytes [return_2] ||| [return_2] [function_1]	count=2
args	the given number of ||| storable ptr storable int	count=2
args	a list of marshalled ||| $list$ a $f_2$ $list$ b	count=1
return	is used ||| $tuple_2$ buffer from buffer	count=2
function	a type ||| min	count=1
return	given size of the ||| io	count=1
module	the same size as ||| ghc exts	count=1
return	realfrac ||| realfrac	count=1
module	monad ||| control monad	count=4
args	arguments ||| $f_2$ a monad	count=1
module	io operation failed because ||| system io	count=2
module	value from an ||| control concurrent mvar	count=1
return	those that didn t ||| $tuple_3$ $list$ a $list$ string	count=1
function	map each ||| map	count=4
function	counter ||| counter	count=3
module	an entire ||| control	count=1
args	function takes a predicate ||| $f_2$ a bool $list$ a	count=1
module	an ||| control exception	count=2
return	original handle with ||| io handle	count=1
return	but returns a quadruple ||| string $list$ string	count=1
return	constructor application ||| $tuple_3$ tycon $list$ kindrep $list$ typerep	count=1
return	catch but returns ||| io	count=1
args	argument a pointer ||| ptr storable io	count=2
module	the error code eagain ||| error	count=1
args	is executed with ||| mvar a $f_2$ a io	count=1
module	attempt was ||| control exception base	count=1
module	this ||| control	count=3
args	handle and ||| handle maybe filepath	count=1
return	exposes io errors ||| io either	count=1
return	function ||| $list$	count=1
function	to wait ||| wait	count=1
function	of a type ||| type	count=1
args	the resulting handle to ||| handle	count=1
args	predicate and ||| bool	count=1
module	list of strings ||| data list	count=2
return	duplicate a ||| a	count=1
function	for is ||| for	count=1
args	in the pool to ||| pool	count=2
module	lex ||| text read	count=1
module	is ||| data bits	count=2
return	tvar to ||| tvar	count=1
function	file or channel managed ||| h get char	count=2
args	a monad scanning the ||| monad a4 monad a5	count=1
return	[return] l ||| [return]	count=1
args	coerce [args_2] ||| [args_1] [args_2]	count=1
args	storable ||| ptr storable io b	count=2
module	internal function to make ||| data typeable internal	count=1
return	a ||| reads a	count=1
function	alloca ||| alloca	count=1
function	to index an ||| index	count=1
module	in the ||| data	count=1
module	as x ||| data	count=1
args	the given number ||| int $f_2$	count=1
function	is used ||| min	count=1
module	of the operator ||| data	count=1
module	all then right parser ||| text parsercombinators	count=1
return	after the ||| io	count=1
args	like witharray ||| $f_2$ ptr storable	count=1
function	the lex function ||| lex	count=1
function	an allocation [function_2] ||| [function_2] [function_1]	count=4
args	adds a new ||| a	count=2
module	[module_1] precedence ||| [module_1] [module_2]	count=4
function	the mapandunzipm function ||| and unzip m	count=1
function	using temporary ||| with	count=1
args	a binary ||| $f_3$ a b c applicative a	count=1
module	internal function to make ||| typeable internal	count=1
return	given ||| ptr	count=5
function	encoding [function] ||| h [function]	count=6
function	a haskell character to ||| char to	count=3
function	that type ||| type	count=2
function	write the ||| write	count=2
function_args	exception [args_2] ||| [function_1] [args_2]	count=1
args	[args] predicate ||| $f_2$ [args] a $f_2$ b	count=3
return	[return_1] monadic type ||| [return_2] [return_1]	count=2
args	contain the file handle ||| handle maybe	count=1
function_return	terminated [return_2] ||| [function_1] storable/eq ptr storable/eq [return_2]	count=1
module	[module_1] overloaded ||| [module_1] [module_2]	count=2
function_return	offset [return_2] ||| [function_1] [return_2]	count=4
function	[function_1] event manager ||| [function_1] [function_2]	count=3
function	marker to the eventlog ||| marker	count=1
module	computation iseof ||| handle fd	count=1
return	the identity of ||| a	count=1
function	general category ||| general category	count=2
args	and passes ||| filepath	count=1
module	to name ||| prelude	count=1
return	the ||| io string	count=1
function	function polar takes ||| polar	count=1
function	lower limits of a ||| min bound	count=1
function	for fmap in a ||| fmap default	count=1
function	limits of a type ||| bound	count=1
function	[function_1] category ||| [function_2] [function_1]	count=3
args	actions passing any value ||| a $f_2$ a monad	count=1
return	used to ||| from buffer to	count=2
args	a pointer to a ||| storable $f_2$ ptr storable io b	count=1
args	any value produced by ||| a monad	count=2
module	suffix of xs ||| data	count=1
module	that the machine has ||| conc sync	count=1
function	on a ||| on	count=2
return	[return_1] precedence context ||| [return_2] [return_1]	count=4
module	an io ||| system io	count=3
function_return	[function_args_1] value ||| [return_2] [function_args_1]	count=3
function	similar to mallocarray0 but ||| array0	count=1
function	registration without waking ||| unregister fd_	count=1
return	from the ||| io	count=2
args	x returns the ||| realfrac	count=2
function_args	[function_1] static ||| [function_1] name [args_2]	count=2
return	function is used ||| buffer	count=2
function	wide string with ||| peek cwstring	count=1
args	on stablename that ||| stablename b	count=1
return	rest unchanged to ||| b d c d	count=1
module	the [module] ||| [module]	count=4
return	bounded class is ||| bounded	count=1
args	a ||| a $list$ b $list$ c	count=2
return	but returns an ||| io	count=1
module	returns ||| system io	count=1
return	the buffer blocking if ||| int buffer	count=1
function	stable pointer to ||| stable ptr to ptr	count=1
return	on the ||| io b	count=1
module	the program ||| system	count=1
args	a pointer ||| $f_2$ ptr storable	count=2
return	list ||| io $list$ statickey	count=1
return	[return] e ||| io either [return]	count=2
args	pool to ||| pool ptr	count=2
function	bytes from ||| bytes	count=2
function	used to name the ||| min bound	count=1
return	the handler ||| io	count=2
function	zip5 function ||| zip5	count=1
function_return	the action hsetencoding [function_1] [return_2] ||| [function_1] encoding handle textencoding [return_2]	count=3
args	pool to ||| pool	count=2
return	mapaccumr function behaves like ||| $tuple_2$ acc $list$ y	count=1
module	an unsigned integral type ||| ghc exts	count=1
function	reads a line from ||| h get line	count=1
args	applied to non-empty ||| $f_3$ a a	count=1
module	of [module_2] ||| [module_1] [module_2]	count=26
function	[function_1] written to ||| [function_1] [function_2]	count=8
module	| cpu time ||| ghc	count=1
return	returns an ||| $tuple_2$	count=3
function	[function_1] event ||| [function_1] [function_2]	count=3
module	concrete promotable proxy ||| data proxy	count=1
args	character ch ||| handle char	count=1
return	[return_1] a single ||| [return_2] [return_1]	count=2
args	a monad scanning the ||| a3 monad a4 monad	count=1
args	either ||| c either	count=1
function_return	contents of [function_1] [return_2] ||| [function_1] filepath io [return_2]	count=1
function	same as x ||| set bit	count=1
return	of the buffer ||| io buffer	count=1
return	the fixity of a ||| fixity	count=1
args	like witharray ||| storable $list$ storable $f_2$ ptr storable	count=1
function	denominator is positive ||| denominator	count=1
module	the upper ||| prelude	count=1
function	[function_1] terminal or ||| [function_2] [function_1]	count=1
function	calling [function] ghc ||| my [function]	count=1
function	user ||| user	count=2
args	a binary function ||| c applicative a applicative b	count=1
return	executes the computation ||| io	count=1
module	of the overloaded ||| data list	count=1
module	defines parser combinators ||| text parsercombinators	count=1
return	a chan the duplicate ||| io chan a	count=1
function	the least element ||| minimum	count=3
return	value of ||| ptr a	count=1
module	the latin-1 subset of ||| data	count=1
function_return	[function_1] the ||| [function_1] fd [return_2]	count=6
module	managed ||| ghc io handle	count=1
args	unsigned ||| word#	count=1
args	passing any value ||| a $f_2$ a	count=1
return	[return_1] value of ||| [return_2] [return_1]	count=2
args	exception predicate to select ||| $f_2$ exception	count=1
module	where the operation ||| io error	count=5
module	[module_1] lists ||| [module_1] [module_2]	count=4
module	io ||| system io	count=3
return	argument arrow ||| arrow $tuple_3$ b d c	count=1
function_args	exception [args_2] ||| [args_2] [function_1]	count=1
args	the either type ||| $f_2$ b c either	count=1
function	[function] encoding ||| [function] set	count=2
return	a nul terminated c ||| io cstring	count=1
args	gets the number ||| int ptr	count=1
args	predicate ||| a a bool	count=2
function	map which can throw ||| map	count=1
args	of a structure but ||| a b b b foldable a	count=1
function	string [function] temporary ||| with cstring [function]	count=1
args	with the arguments ||| $f_2$ a	count=1
module	current ||| encoding types	count=1
function_args	[function_1] number ||| [function_1] malloc array0 pool [args_2]	count=1
function_args	modifying [args_2] ||| [function_1] mvar a [args_2]	count=1
return	to the device without ||| word8	count=1
function	hputstr [function_2] ||| [function_2] [function_1]	count=10
function	set ||| set newline	count=1
function	a duplicate of the ||| duplicate	count=1
module	of this ||| data	count=1
args	living inside a ||| $f_2$ ptr a io	count=2
function	right by ||| r	count=1
return	of a monad ||| a b	count=2
function_return	lift a [return_2] ||| [return_2] [function_args_1]	count=1
args	a binary function ||| applicative a applicative	count=1
args	uncurried function to a ||| a	count=1
return	exposes io ||| io either	count=1
module	lift ||| text parsercombinators readprec	count=1
args	promote a function ||| a1	count=2
function	by a sampled method ||| sampled	count=1
args	bits ||| finitebits	count=1
module	of elements which do ||| data	count=1
return	memory reference into a ||| io foreignptr a	count=1
args	openfile and passes the ||| filepath iomode	count=1
args	a binary function to ||| a applicative	count=1
args	any value produced by ||| a	count=2
function_args	[function_1] x returns ||| [args_2] [function_1]	count=2
function	defining left = ||| left app	count=1
function	prefix [function_2] ||| [function_2] [function_1]	count=3
return	outputs ||| arrowchoice either b c d	count=1
args	like witharray but a ||| storable $list$ storable $f_2$ ptr storable io	count=1
return	on the ||| io	count=1
return	phase pair in canonical ||| $tuple_2$ realfloat realfloat	count=1
return	is thrown when the ||| errorcall	count=2
args	mapmaybe ||| $f_2$ a maybe	count=1
return	[return_1] read instance ||| [return_1] [return_2]	count=1
function	restore action ||| mask_	count=2
args	storable ||| $f_2$ ptr storable	count=1
return	precedence context ||| readprec	count=2
function	lcm x y is ||| lcm	count=1
function_args	[function_1] static pointer ||| [function_1] name [args_2]	count=2
args	inside a ||| a $f_2$ ptr a io	count=2
args	argument and ||| string $list$ optdescr a	count=1
args	finalized pointer ||| env a ptr env ptr	count=1
return	on the contents of ||| io	count=1
function	to a thread ||| thread	count=2
function	of bytes [function_2] ||| [function_2] [function_1]	count=9
args	the [args_2] ||| just [args_2] [args_1]	count=2
function	error that ||| error	count=1
module	and marshal ||| marshal	count=1
module	value a function and ||| data	count=1
args	stablename that does ||| stablename	count=1
return	exposes io errors which ||| io either	count=1
function	other not assigned ||| not assigned	count=2
module	handle ||| exception base	count=1
module	current ||| conc sync	count=1
return	[return_1] for versions ||| [return_2] [return_1]	count=1
function_return	uninterruptiblemask asynchronous exceptions ||| uninterruptible maskingstate	count=2
args	either ||| $f_2$ b c either	count=1
args	an exception ||| exception maybe b io	count=2
args	to be returned ||| $f_2$ a io	count=1
return	textencoding ||| textencoding	count=1
function	privilege ||| permission	count=3
function	using temporary storage ||| with cstring	count=1
function	changes the ||| set	count=2
function	to the corresponding ||| to char	count=1
function	observe ||| ty con	count=2
return	a chan [return_2] ||| [return_2] [return_1]	count=4
module	block of memory ||| alloc	count=1
return	of a container ||| a	count=1
module	event that an exception ||| control exception	count=2
args	actions passing any value ||| $f_2$ a monad	count=1
function	[function_1] [function_2] handle ||| [function_1] [function_2] handle	count=3
args	string ie ||| string $f_2$	count=1
args	handle and file path ||| string maybe handle maybe	count=1
module	attempt was made ||| control exception base	count=1
return	memory ||| io ptr storable	count=1
module	device type but a ||| device	count=1
module	total ||| ghc stats	count=2
args	fixity ||| fixity	count=1
module	standard output device ||| system	count=1
function	always is a ||| always	count=2
args	value with a string ||| string	count=1
args	predicate instead ||| a a bool	count=1
return	all other bits clear ||| bits	count=1
function	the query element ||| elem	count=2
function	contents of the ||| contents	count=1
function	int [function_2] ||| [function_1] [function_2]	count=1
args	representation ||| rep generic x	count=2
args	a structure but ||| a b b b foldable a	count=1
function	representation ||| rep fingerprint	count=4
function	haskell character to ||| to cschar	count=1
function	like catch ||| catch just	count=1
args	string with explicit length ||| cstringlen	count=1
module	in memory ||| foreign marshal	count=1
args	predicate ||| a a bool $list$ a	count=2
args	data from the handle ||| handle	count=2
args	a list of storable ||| ptr storable	count=1
args	like witharray ||| $list$ storable $f_2$ ptr storable	count=1
function	mapandunzipm ||| map and unzip m	count=2
args	but a terminator ||| io b	count=1
args	[args] the type ||| [args]	count=2
module	copying for the ||| ghc	count=1
return	returning the leftmost non-nothing ||| first	count=1
function_return	hfilesize hdl [return_2] ||| [function_1] file size handle [return_2]	count=1
args	conditionally prove ||| testcoercion a testcoercion	count=1
return	[return_1] and b ||| [return_2] [return_1]	count=1
return	a computation ||| ioerror a	count=1
return	value as ||| a	count=2
module	latin-1 subset of ||| data	count=1
return	turns a [return] ||| io [return]	count=3
return	original handle with its ||| io handle	count=1
return	but returns an either ||| either	count=1
args	the ||| int	count=2
args	maximum [args] maximum value ||| [args]	count=1
args	a pointer to ||| ptr	count=2
function	to read on the ||| read	count=1
return	into the buffer ||| $tuple_2$ int buffer word8	count=1
args	structure but ||| b b foldable	count=1
args	predicate to select ||| $f_2$	count=1
function	error message ||| error with	count=1
function	the current buffering ||| get buffering	count=4
module	be marshalled to or ||| ghc	count=1
args	non-empty ||| $f_3$ a a a foldable a	count=2
function	[function_1] signed ||| [function_2] [function_1]	count=1
args	represents ||| addr#	count=1
function	[function_1] [function_2] ||| [function_2] stack [function_1]	count=8
args	non-options a list ||| argorder a	count=1
module	of scanr that ||| data list	count=2
return	[return_1] true ||| [return_2] [return_1]	count=3
args	the same ||| bits	count=1
args	any value ||| monad a monad	count=1
args	storable values in memory ||| ptr storable	count=1
function	to printf except that ||| printf	count=1
args	is an exception ||| exception maybe b	count=1
module	only be used within ||| conc	count=1
function	combination of map and ||| map	count=2
args	discarding any value produced ||| monad a	count=1
return	returning the number of ||| int	count=1
return	precedence context by one ||| readprec	count=1
module	optional ||| text parsercombinators readp	count=1
args	storable values in memory ||| storable	count=1
module	[module_1] event ||| [module_1] [module_2]	count=2
args	into a nul terminated ||| $f_2$ cstring io	count=1
function	wide ||| new cwstring	count=1
args	witharray but a terminator ||| $f_2$ ptr storable io	count=1
return	a character is available ||| io char	count=1
module	a parser into ||| text parsercombinators readp	count=1
function	file ||| open file	count=1
module	the machine has ||| ghc	count=1
args	predicate ||| $f_2$	count=10
return	a staticptr by its ||| staticptr a	count=1
return	rest unchanged ||| d c d	count=1
args	argument is executed ||| mvar a $f_2$ a io	count=1
args	a pointer to ||| ptr storable io	count=2
function	to throw or ||| to	count=2
function	hexadecimal ||| is hex	count=1
return	length of the ||| io	count=1
args	for the either type ||| either a b	count=1
function	zero ||| many	count=2
function	current number [function_2] ||| [function_2] [function_1]	count=1
function_return	[function_1] asynchronous exceptions ||| [function_1] [return_2]	count=2
return	memory of the given ||| io ptr	count=1
args	argument a pointer to ||| $f_2$ ptr storable io	count=2
function	system ||| system	count=1
return	to arbitrary monads ||| monad $list$	count=1
function	zipping ||| zip list	count=1
return	of the buffer to ||| buffer word8	count=1
function	the system event ||| system event	count=1
function	is a ||| is	count=4
module	convert a c byte ||| c string	count=1
function	hgetbufnonblocking ||| non blocking	count=2
function	execute an action with ||| with	count=1
module	an attempt was made ||| exception base	count=1
function	passed to the finalizer ||| finalizer env	count=2
args	to a curried function ||| $f_2$ $tuple_2$ a b c a b	count=1
return	[return_1] from the ||| [return_2] [return_1]	count=6
function	as x ||| set bit	count=1
function	the recover function is ||| recover	count=2
args	predicate ||| $f_2$ a bool $list$	count=3
function	[function_1] a prefix ||| [function_1] [function_2]	count=1
return	i from ||| seekmode	count=2
module	miscelaneous information available for ||| ghc staticptr	count=1
return	combine their output ||| $tuple_2$ c c'	count=1
module	suffix of xs ||| data list	count=1
function	heap is reaching ||| heap	count=2
return	up [return] ||| [return]	count=1
function	about to terminate with ||| finally	count=1
return	a computation and ||| either ioerror a	count=1
return	five [return_1] [return_2] ||| [return_1] [return_2]	count=1
return	exception raised [return] ||| [return]	count=1
args	the return value ||| io a io b io c	count=2
return	using the read instance ||| maybe read	count=1
function	pointer and ||| ptr	count=1
args	where the ||| ioerrortype	count=1
function	index of a ||| index	count=1
args	given number ||| int $f_2$ ptr storable	count=1
args	pointer ||| $f_2$ ptr storable io b	count=2
function	unzip transforms ||| unzip	count=1
function_args	truncate x returns ||| truncate realfrac	count=1
args	return value ||| io a io b io c	count=2
module	there was an exception ||| control exception	count=1
args	as int ||| word#	count=1
return	exposes io errors which ||| io	count=1
function	encode ||| encode	count=2
function	to ||| to word	count=1
args	value from the ||| a io b	count=2
function	allocated ||| allocated	count=2
function	is the ||| set bit	count=1
function	current [function] ||| [function]	count=2
module	total ||| stats	count=2
module	a ||| pool	count=1
args	buffering [args] ||| [args]	count=1
module	so [module] context n ||| [module]	count=1
return	into the buffer without ||| io $tuple_2$ maybe int buffer word8	count=1
function	general coercion from ||| from	count=1
function_args	[function_1] precedence-insensitive readp ||| [function_1] [args_2]	count=1
return	to the buffer to ||| to	count=2
function	match failed ||| match	count=1
function	the size of the ||| size	count=1
function_return	[function_1] may ||| [return_2] [function_1]	count=3
function	sparks ||| sparks	count=1
module	this operation use control ||| control	count=1
function_return	[function_1] a string ||| [function_1] string [return_2]	count=1
function	base specified by the ||| int at base	count=1
module	that an io operation ||| system io	count=2
args	passing any value produced ||| a $f_2$ a	count=1
args	number of ||| int $f_2$ ptr	count=1
module	into an object of ||| data	count=1
function	non-negative an smaller than ||| r	count=1
module	the error ||| error	count=2
return	number of ||| $tuple_2$ int	count=3
function	hdl or for a ||| h	count=1
args	out ||| bufferedio	count=1
function	like catch but ||| catch	count=1
function	[function_1] stack ||| [function_1] [function_2]	count=3
function	the position ||| seek	count=3
module	an [module] by the ||| [module]	count=1
module	from a [module_2] ||| [module_1] [module_2]	count=2
module	[module_1] only ||| [module_2] [module_1]	count=1
function	fix ||| fix	count=1
args	takes an exception predicate ||| $f_2$ exception	count=1
function	[function_1] signed type ||| [function_2] [function_1]	count=1
args	the mapmaybe function is ||| a maybe b	count=1
module	open ||| handle fd	count=2
args	encapsulated in a ||| b foldable a	count=1
args	as an additional parameter ||| $list$ storable $f_3$	count=1
function	coerce allows you to ||| coerce	count=1
function	input ||| input	count=1
return	inverse of decodefloat in ||| realfloat	count=1
function_return	[function_args_1] value as ||| [return_2] [function_args_1]	count=3
return	returns the [return_2] ||| sync get num capabilities [return_1] [return_2]	count=4
return	x the value ||| $list$ a	count=1
function_args	show a [args_2] ||| [function_1] ffloat alt maybe [args_2]	count=3
function_args	read on [args_2] ||| [function_1] [args_2]	count=1
module	version of ||| data	count=6
args	inside a ||| a $f_2$ ptr a	count=2
args	value ||| b $list$ a	count=2
args	return value ||| a io b	count=2
module	letter ||| data char	count=1
args	handle and file ||| maybe handle	count=1
return	[return] no further ||| io [return]	count=2
function	marshal a c string ||| cstring	count=1
return	end marker [return_2] ||| [return_2] [return_1]	count=2
module	the first element of ||| data	count=1
args	a block ||| ptr a	count=1
return	chan [return_2] ||| [return_2] [return_1]	count=4
return	a magnitude phase pair ||| $tuple_2$	count=1
args	the same as ||| int	count=1
return	comp exposes io errors ||| io either ioerror	count=1
return	type constructor application ||| tycon $list$ kindrep $list$ typerep	count=1
return	returns the [return_2] ||| concurrent get num capabilities [return_1] [return_2]	count=4
module	marshal a ||| foreign marshal	count=2
args	like witharray ||| storable	count=1
module	and ||| data bits	count=1
args	promote a function ||| r monad a1 monad	count=2
args	is a reverse ||| a $f_2$ a	count=1
function	write ||| write buffer0	count=1
return	the ||| io b	count=4
args	analysis for the either ||| b c either	count=1
args	arguments ||| $f_2$ a	count=1
args	is executed ||| mvar a $f_2$	count=1
args	if there are no ||| bufferedio buffer word8	count=1
args	for lifetime ||| event lifetime	count=1
function	[function_1] manager ||| [function_1] [function_2]	count=4
function	throw an error ||| error	count=1
function	allocate a ||| new	count=1
args	accepts any integral ||| integral $list$ a	count=1
return	foreignptr to it ||| foreignptr	count=2
module	encode ||| ghc io encoding types	count=1
args	as argument a pointer ||| $f_2$ ptr storable io b	count=2
return	of the buffer to ||| buffer	count=1
function	the fromenum method restricted ||| ord	count=1
function	take ||| take	count=1
function	but additionally if the ||| errno if	count=1
return	function reads [return_2] ||| [return_1] [return_2]	count=4
function	latin-1 character to the ||| cuchar to	count=1
function	sign of a ||| sign plus	count=1
return	the computation f passing ||| io	count=1
function_args	[function_1] first handle ||| [function_1] [args_2]	count=2
function	foreign object by ||| foreign	count=1
args	a ||| a $f_2$ ptr a	count=2
return	dereferences a ||| maybe v	count=1
module	sequence of [module_2] ||| [module_1] [module_2]	count=2
module	stack ||| stack	count=1
return	the [return_2] ||| [return_2] [return_1]	count=33
function	a type ||| bound	count=1
return	to look at the ||| io	count=2
function	exist ||| exist	count=1
function	create ||| new mvar	count=2
function	advances the given ||| plus ptr	count=1
return	set to i ||| seekmode	count=3
function	use ||| use	count=1
function_return	[function_1] for storable ||| [return_2] [function_1]	count=1
return	observe ||| $list$ typerep	count=2
function	wide ||| cwstring	count=2
function	argument right by ||| r	count=1
function	character to the ||| cast cuchar to	count=1
args	value from the ||| io a io b	count=2
args	an exception predicate ||| $f_2$ exception	count=1
args	is an exception ||| exception maybe	count=1
args	string ||| $f_2$ string string	count=1
module	is used to name ||| prelude	count=1
function_return	[function_1] [return_2] ||| [function_1] chan chan a [return_2]	count=2
module	integral type ||| exts	count=1
args	a nul terminated ||| cstring io a	count=1
function	of hdl to the ||| h	count=1
args	a monad scanning the ||| monad a2 monad a3 monad a4 monad	count=1
return	handle to ||| handle	count=2
return	bracket with just a ||| a	count=1
module	of xs after ||| data list	count=1
args	of the codec ||| buffercodec from to state	count=1
module	that the machine ||| ghc conc sync	count=1
args	file handle and ||| handle maybe filepath	count=1
function	deprecated use traceevent or ||| trace event	count=1
module	of a ||| data traversable	count=1
function	void value discards or ||| void	count=1
return	[return_1] given size ||| [return_2] [return_1]	count=2
args	value produced by ||| $f_2$ a monad	count=1
function	lower limits ||| min bound	count=1
module	of this ||| data traversable	count=1
rep	of hdl [function_return_2] ||| [module_1] [function_return_2]	count=8
function	adjust ||| realloc	count=1
args	is executed with ||| mvar a	count=1
return	memory and ||| ptr storable	count=1
function	the finalizer ||| add foreign ptr finalizer	count=2
function	extracts a list of ||| list	count=1
function	marker ||| marker	count=1
function	the product of ||| product	count=1
return	block of memory and ||| io ptr storable	count=1
args	the either ||| c $f_2$ b c either a	count=1
module	but ||| io	count=1
args	returned ||| a $f_2$ a io	count=1
return	[return_1] haskell value ||| [return_2] [return_1]	count=2
function	the index of ||| constr index	count=1
args	witharray ||| $list$ storable $f_2$ ptr storable	count=1
return	type constructor application ||| tycon $list$ typerep	count=2
return	merging ||| b' either c	count=1
function_args	[function_1] number ||| bits rotate [function_1] [args_2] bits	count=1
args	elements of the ||| a bool $list$ a	count=1
args	a structure ||| a applicative b foldable a	count=1
return	a type constructor application ||| tycon $list$ typerep	count=1
args	a ||| a io b	count=2
return	with x the value ||| $list$ a	count=1
module	the datatype to ||| ghc generics	count=2
args	as argument a pointer ||| $f_2$ ptr	count=2
function	wait ||| wait	count=2
args	user-supplied equality predicate ||| bool $list$ a	count=1
function	advances the given ||| plus	count=1
module	encoding for the ||| ghc io	count=1
module	representation of a ||| data char	count=2
return	and merging their ||| b b' either c	count=1
function	like openfile but [function_1] [function_2] ||| system io [function_1] [function_2]	count=4
args	given ||| storable/eq ptr storable/eq	count=1
module	size ||| exts	count=1
return	a complex ||| complex	count=1
function	storage for ||| pooled new array	count=1
function	limits of a ||| bound	count=1
args	the given number ||| storable ptr storable int	count=2
function	general [function_2] ||| [function_2] [function_1]	count=1
return	a ||| $tuple_2$ $list$ a $list$ a	count=1
args	for the either type ||| c either a b	count=1
args	first argument and ||| $list$ optdescr a	count=1
function	used to wait ||| thread wait	count=1
function	caseless scripts and modifiers ||| is alpha	count=1
function	[function_1] blocking ||| [function_2] [function_1]	count=2
args	for lifetime ||| lifetime	count=1
module	system ||| system	count=4
return	a finalizer that ||| a	count=1
function	system event [function_2] ||| [function_2] [function_1]	count=1
return	the buffer to ||| io buffer	count=1
function	returns the current i/o ||| get posn	count=2
args	exception predicate to select ||| $f_2$ exception maybe	count=1
args	[args_1] arguments ||| [args_2] [args_1]	count=2
function	location in the source ||| src loc	count=1
args	a signed ||| maybe int	count=1
return	actions from ||| applicative	count=1
rep	register [function_args_2] ||| [module_1] [function_args_2]	count=1
args	the either ||| c $f_2$ b c either	count=1
function	[function_1] representation ||| [function_2] [function_1]	count=6
return	[return_1] [return_2] ||| [return_1] mvar [return_2]	count=2
module	the array ends ||| array	count=1
return	for the end ||| io ptr	count=1
module	with a valid memory ||| foreign	count=1
args	for lifetime lt ||| lifetime	count=1
module	including ||| foreign marshal	count=1
args	any value ||| a monad b	count=2
module	limits of a ||| prelude	count=1
args	a c string ie ||| textencoding string $f_2$	count=1
return	the permutations function returns ||| $list$ $list$	count=1
args	conversion scheme between ||| textencoder estate	count=1
function	can be written to ||| write stm	count=3
args	the codec ||| buffercodec from to state	count=1
args	[args_1] number ||| marshal array move array [args_1] [args_2]	count=3
args	takes an exception ||| exception maybe b io a	count=1
function	[function_1] stable ||| [function_1] [function_2]	count=1
args	pointer to ||| ptr	count=2
function	of putmvar ||| try put	count=1
module	where the ||| system io error	count=7
module	representation ||| data data	count=1
function	the finalizer ||| finalizer env	count=2
args	handle to ||| iomode $f_2$ handle	count=1
function	actually a pair of ||| weak pair	count=1
args	p parses open followed ||| readp open readp	count=1
args	the either ||| $f_2$ b c either	count=1
args	conditionally prove ||| testcoercion a testcoercion b	count=1
function	cn other not assigned ||| not assigned	count=1
return	any [return] ||| [return]	count=3
module	[module_1] including an ||| [module_1] [module_2]	count=4
function	the role of return ||| return a	count=1
return	funptr ||| funptr	count=2
module	from an ||| control concurrent mvar	count=1
module	list ||| list	count=34
args	as argument a pointer ||| $f_2$ ptr storable	count=2
module	[module] block ||| [module]	count=3
args	a [args] ||| $f_3$ a a [args]	count=2
return	a textencoding is ||| textencoding	count=1
function	encoding of ||| encoding	count=1
args	the class typeable allows ||| typeable	count=1
args	with the ||| word#	count=1
args	integral ||| word#	count=1
return	the number of ||| int bool	count=3
function	channel begins empty but ||| dup	count=1
args	type ||| word#	count=1
args	argument is executed with ||| mvar a $f_2$ a io	count=1
return	bytes into the buffer ||| int buffer word8	count=1
function	the stable [function_2] ||| [function_2] [function_1]	count=1
args	value produced ||| a $f_2$ a	count=1
function	this function maps ||| map	count=1
function	just 1 mfilter ||| mfilter	count=1
args	promote a function to ||| a2 a3 a4 r monad a1 monad	count=1
args	from the representation ||| rep	count=1
args	promote a function to ||| a5 r monad a1 monad a2 monad	count=1
function	[function_1] stable pointer ||| [function_1] [function_2]	count=1
module	of lists ||| data	count=1
function	size of the ||| set size	count=1
module	convert between values of ||| data	count=1
module	by the ||| ghc	count=1
args	a curried function ||| $tuple_2$ a b c a	count=1
function	offset ||| relative seek	count=2
module	precedence ||| readprec	count=1
function	thread is [function_2] ||| [function_2] [function_1]	count=3
module	values ||| text	count=2
function	split ||| split poly	count=1
return	to the size needed ||| io ptr	count=1
return	but returns a ||| $list$ string $list$ string	count=1
module	a variant of scanl ||| data list	count=1
module	[module_1] [module_2] raised ||| [module_1] [module_2] bracket	count=3
args	actions passing any value ||| a monad	count=1
function	gets ||| constr rep	count=1
args	given number of ||| int $f_2$ ptr storable io b	count=1
module	the remainder of the ||| data	count=2
return	arrows retagging and merging ||| b' either	count=1
function	disable allocation [function_2] ||| [function_1] [function_2]	count=2
args	is encapsulated in a ||| monad b b foldable a	count=1
function	the char [function_2] ||| [function_1] [function_2]	count=1
args	a binary function to ||| applicative a	count=1
return	[return] run when ||| io weak mvar [return]	count=2
module	the operation failed ||| system io error	count=5
return	and [return] haskell ||| [return]	count=1
function	extra position to hold ||| array0	count=1
module	of ||| data type	count=1
function	[function_1] prefix ||| [function_1] [function_2]	count=3
return	a finalizer [return] ||| [return] foreignptr	count=2
return	similar ||| hprintftype	count=1
function	the conjugate ||| conjugate	count=1
module	a fresh memory ||| foreign marshal pool	count=1
module	[module_1] utf-32 ||| [module_1] [module_2]	count=2
function	[function_1] timeout ||| [function_2] [function_1]	count=1
function	hputstr hdl s writes ||| h put str	count=2
function	lines breaks ||| lines	count=2
function	the upper and ||| bound	count=1
function	function behaves like delete ||| delete by	count=1
return	returns [return_2] ||| [return_1] [return_2]	count=6
return	boolean indicating whether the ||| io $tuple_2$	count=1
module	[module_1] [module_2] == function ||| [module_1] [module_2] nub	count=2
return	and return the ||| io	count=1
return	weak pointer [return_2] ||| [return_2] [return_1]	count=1
function	given ||| ptr info	count=1
function_args	[function_1] hierarchy ||| [function_1] [args_2]	count=3
return	arrow and copy ||| arrow	count=1
function	lower limits of ||| min bound	count=1
module	a c string ||| foreign c	count=2
module	datatype to ||| generics	count=3
args	case ||| a	count=1
function	is blocked on ||| blocked	count=2
function	[function_1] prefix of ||| [function_1] [function_2]	count=1
args	this function extracts ||| foreignptr a	count=1
args	[args_1] realfloat ||| [args_2] [args_1]	count=6
function	[function_1] counter ||| [function_2] [function_1]	count=4
args	elements of the ||| bool $list$ a	count=1
return	breaks a string up ||| string	count=1
module	c string ||| foreign c	count=3
function	stack [function_2] ||| [function_2] [function_1]	count=3
module	error code eagain or ||| foreign c error	count=1
module	each element of ||| data	count=1
function	on an mvar but ||| on	count=2
function	co other private use ||| private use	count=1
return	feed marked inputs ||| arrowchoice either b d either	count=1
args	realfloat value using standard ||| realfloat	count=1
function_return	new instance [return_2] ||| [return_2] [function_1]	count=1
args	a pointer to ||| ptr storable	count=2
function_return	to [return_2] ||| [return_2] [function_1]	count=3
module	unregister ||| ghc event	count=1
function	of geterrno if ||| errno if	count=6
return	quadruples analogous to ||| $tuple_4$	count=1
args	as an additional parameter ||| $f_3$	count=1
function_args	all [args_2] ||| [args_2] [function_1]	count=4
args	explicit length information ||| cstringlen	count=2
return	number ||| io $tuple_2$ int bool	count=2
return	takes a ||| a $list$ b	count=3
module	[module_1] [module_2] ||| [module_1] marshal [module_2]	count=6
args	of storable values ||| storable io b	count=1
module	the environment ||| system environment	count=1
args	given ||| storable ptr storable	count=2
module	because the user ||| io error	count=2
module	where the array ends ||| foreign marshal array	count=1
return	value as the number ||| a	count=2
args	with ||| $f_2$ b c arrow c	count=1
return	an exception of ||| exception	count=2
module	of ||| data traversable	count=3
module	with the same size ||| ghc	count=1
module	same object ||| mem	count=1
function	type with ||| w#	count=1
module	list of strings at ||| data list	count=1
return	into a ||| a	count=3
function	of sparks currently ||| sparks	count=2
args	a signed realfloat ||| maybe int realfloat	count=2
function	of show ||| h show	count=2
function_args	[function_1] the ||| [function_1] [args_2]	count=4
return	[return_1] [return_2] ||| [return_2] [return_1]	count=194
return	a memory ||| a	count=1
module	a c string ||| foreign c string	count=2
function	type ||| bound	count=1
function	the largest ||| maximum	count=1
args	of a conversion scheme ||| dstate io textencoder estate	count=1
module	[module_1] datatype ||| [module_1] [module_2]	count=4
function	hputchar stdout ||| put	count=1
return	current value ||| ptr a	count=1
function	curry converts ||| curry	count=1
function	exponent corresponds ||| exponent	count=1
module	have sufficient operating system ||| system	count=3
args	of stm actions ||| stm	count=1
args	memory pool which ||| pool	count=1
function	tvar ||| read tvar io	count=2
function_args	smaller than [args_2] ||| [function_1] [args_2] bits	count=3
function	of geterrno if the ||| errno if	count=1
function	stm transaction but ||| on stm	count=1
return	exposes io errors which ||| io either ioerror	count=1
function	or channel managed ||| h get char	count=2
args	action in the structure ||| foldable applicative	count=1
module	operation use control ||| control concurrent chan	count=1
return	a staticptr by ||| io maybe staticptr a	count=1
return	of a collection ||| alternative a	count=1
function	[function_1] file ||| system io [function_1] binary [function_2] filepath iomode io handle	count=1
args	elements of the list ||| a bool $list$	count=1
function	to mallocarray0 but yields ||| array0	count=1
return	and merging their ||| b b' either	count=1
args	represents a ||| addr#	count=1
function	function polar takes a ||| polar	count=1
return	returns ||| a $list$ string $list$ string $list$	count=1
function	set ||| set	count=3
function	[function_1] trace ||| [function_2] [function_1]	count=4
return	to stderr and ||| io a	count=1
function	kept [function] avoid ||| [function]	count=1
function	of megabytes [function_2] ||| [function_1] [function_2]	count=3
return	all elements satisfying the ||| $list$ int	count=1
function_return	gets [return_2] ||| [return_2] [function_1]	count=3
return	size of the memory ||| io foreignptr	count=1
module	yields the error code ||| foreign c error	count=2
args	string- > string as ||| string string	count=1
args	a ||| c d e $list$ a $list$	count=1
return	a string up into ||| $list$ string	count=2
return	returns the simplest rational ||| rational	count=1
function_return	looks up [return_2] ||| [function_1] statickey [return_2]	count=3
args	in a ||| foldable a	count=1
function_return	run [return_2] ||| [function_1] io a [return_2]	count=2
function	hdl into ||| h	count=4
args	a ||| a monad b b foldable a	count=1
function	parser ||| parse version	count=1
return	of item ||| item	count=1
args	their point-wise combination analogous ||| $list$ c $list$ d $list$ e	count=1
function_return	cis t [return_2] ||| [return_2] [function_1]	count=2
function	of throw that can ||| throw	count=2
args	is a ||| a $f_2$ a b	count=1
function	used to wait for ||| thread wait	count=1
module	array [module_2] ||| [module_1] [module_2]	count=2
module	marshal a c ||| foreign c	count=2
function	to wait for ||| thread wait	count=1
return	the current value of ||| ptr a	count=1
function	appends a stack trace ||| with stack trace	count=1
function	splits a ||| split	count=1
return	to the given size ||| io ptr	count=2
args	this is a way ||| foreignptr	count=2
return	[return_1] current value ||| [return_2] [return_1]	count=1
args	a ||| e $list$ a $list$ b $list$	count=1
args	the structure ||| foldable	count=4
args	six-tuples ||| b c d e f	count=1
function_return	split a [return_2] ||| [return_2] [function_1]	count=2
module	[module_1] [module_2] seven-tuples analogous to zip ||| [module_2] [module_1]	count=2
function	of throw ||| throw stm	count=2
return	buffer to ||| io buffer word8	count=1
args	a precedence-insensitive readp ||| readp	count=1
module	with the same ||| ghc	count=1
function	[function_1] is programmer-defined ||| [function_2] [function_1]	count=2
function	unicode general ||| general	count=1
args	complex number and returns ||| complex	count=1
module	of a constructor ||| data data	count=3
module	v ||| text printf	count=1
function	fmap ||| fmap	count=1
args	promote a function to ||| a4 r monad a1 monad	count=1
function_return	[function_args_1] value ||| [function_args_1] [return_2]	count=3
function_args	[function_1] number of ||| [function_1] malloc array pool [args_2]	count=1
module	the appropriate instance was ||| control exception base	count=1
args	openfile and ||| filepath iomode	count=2
return	[return_1] specified character ||| [return_2] [return_1]	count=1
args	value ||| b a b b $list$ a	count=2
return	specialised way of showing ||| shows	count=1
args	the predicate ||| $f_2$	count=5
module	taken ||| concurrent mvar	count=1
function	accumulator together with the ||| map accum l	count=1
function	timeout in the ||| timeout	count=1
module	it yields the error ||| error	count=1
return	returns an either ||| io either	count=1
args	equality on stablename that ||| stablename b	count=1
function	[function_1] file in ||| [function_1] binary [function_2]	count=1
args	number ||| int $f_2$ ptr	count=1
module	program ||| system	count=1
args	the either type ||| $f_2$ b c either a b	count=1
return	st [return_1] [return_2] ||| st [return_1] [return_2]	count=1
module	the ||| ghc	count=10
function	character to ||| char to cschar	count=1
args	of a finite list ||| a	count=1
function	the error message ||| error with	count=1
args	to be returned ||| a $f_2$ a	count=1
function	of storage in ||| pooled	count=1
args	mapmaybe function is ||| a maybe b	count=1
args	data from the handle ||| handle ptr	count=2
module	for a ||| data data	count=1
return	buffer blocking ||| int buffer word8	count=1
function	newly created thread ||| fork	count=2
args	promote a function ||| a3 a4 a5 r monad a1 monad	count=1
args	with ||| $f_2$	count=2
return	constructor [return_2] ||| [return_1] [return_2]	count=3
module	in the given list ||| list	count=1
return	value ||| a traversable	count=1
module	size as int ||| ghc exts	count=1
function	t ever continue ||| blocked indefinitely on	count=1
return	[return_1] and ||| [return_2] [return_1]	count=8
return	contents after the action ||| io b	count=1
args	the arguments ||| $f_2$	count=3
args	the number ||| int ptr	count=1
function	duplicate channel begins ||| dup chan	count=1
return	as a finalizer ||| a	count=2
args	of storable values ||| ptr storable io b	count=1
function_args	file [args_2] ||| [function_1] filepath [args_2]	count=1
function	given path when appropriate ||| throw errno path if minus1	count=1
args	a ||| $list$ a $list$ b $list$ c $list$ d	count=1
module	[module] type ||| [module]	count=3
args	value from ||| io a io	count=2
function_return	[function_1] [return_2] ||| [function_1] ptr a [return_2]	count=8
return	a monad ||| a	count=5
function	an unsigned ||| w#	count=1
args	monad scanning ||| a2 monad a3 monad a4 monad a5	count=1
function	duplicate of ||| h duplicate	count=1
function	sum of the numbers ||| sum	count=1
args	as a value ||| b traversable a	count=1
module	overloaded version of ||| data list	count=2
return	the given ||| io ptr	count=6
function	to the corresponding haskell ||| cast cchar to	count=1
module	hdl ||| ghc io handle	count=7
function	fromenum method restricted ||| ord	count=1
return	blocking until a character ||| char	count=2
args	a curried ||| c a b	count=2
return	with the ||| io	count=3
function	operation [function_2] ||| [function_2] [function_1]	count=2
function	error message if one ||| error with	count=1
function	resize ||| realloc bytes	count=2
module	[module_1] only ||| [module_1] [module_2]	count=25
function	marker to ||| marker	count=1
function	the function polar takes ||| polar	count=1
return	returns a ||| $list$ string $list$ string $list$ string	count=1
args	a structure ||| foldable num	count=2
return	of returned tvar ||| io tvar	count=1
function_args	[function_1] signed realfloat ||| [function_1] ffloat maybe [args_2]	count=1
return	read instance ||| read	count=1
return	and combine their output ||| $tuple_2$ c c'	count=1
function	instance of show ||| h show	count=2
function	[function_1] [function_2] and ||| [function_1] [function_2] stableptr a	count=4
module	a ||| marshal pool	count=2
return	a list ||| io $list$	count=1
function_return	[function_1] the contents ||| [function_1] mvar mvar a [return_2]	count=1
function	identity ||| mempty	count=1
module	parser into ||| text parsercombinators	count=1
module	always ||| ghc conc	count=1
args	a nul terminated ||| $f_2$ cstring io a	count=1
function	interact function takes a ||| interact	count=1
args	conditionally prove the ||| a testcoercion	count=1
args	[args] p ||| [args]	count=2
function	mallocarray0 but yields a ||| array0	count=1
function_args	[function_1] parses open ||| [args_2] [function_1]	count=1
function	index ||| index constr	count=1
args	parameter is true ||| bool	count=1
return	handle ||| handle	count=6
return	haskell string ||| io string	count=4
args	pointer to a ||| ptr storable io	count=2
function	the module where the ||| module	count=1
return	f passing as argument ||| b	count=1
args	true ||| bool reads	count=1
function	begins empty ||| dup	count=1
function	left = leftapp ||| left	count=1
module	an array including an ||| foreign marshal array	count=1
args	c string ||| textencoding string $f_2$	count=1
return	return a lazy ||| a	count=1
args	a binary function to ||| c applicative a applicative	count=1
return	[return] actually ||| io maybe [return]	count=2
return	rest through unchanged to ||| d either c d	count=1
module	monad ||| control exception	count=2
function	scanr is the ||| scanr	count=1
module	swapped around [module] ||| [module]	count=6
return	integer [return_2] ||| [return_2] [return_1]	count=2
args	curried function ||| b c	count=1
function	based on zipping ||| zip	count=1
function	if the ||| throw errno if	count=1
return	into a circular ||| $list$ a	count=1
return	string for ||| string	count=1
module	this [module] ||| ghc [module]	count=3
function	open the [function_2] ||| [function_1] binary [function_2]	count=2
args	the codec ||| buffercodec from to	count=1
return	list of [return_2] ||| [return_1] [return_2]	count=1
function_return	the [function_1] [return_2] from the structure l ||| [function_1] [return_2]	count=1
function	[function_1] [function_2] ||| [function_1] [function_2] finalizerptr a	count=4
return	bits clear ||| bits	count=1
module	rows and columns of ||| data list	count=1
module	that an exception ||| control exception	count=3
module	from an ||| control concurrent	count=1
args	used within ||| exception	count=2
args	contain the file handle ||| string maybe handle	count=1
args	structure ||| monad b foldable	count=2
return	monads ||| monad $list$ c	count=1
args	promote a function to ||| a3 a4 r monad a1 monad a2 monad	count=1
return	used ||| buffer from buffer	count=2
return	and its value is ||| a	count=2
return	each optdescr ||| optdescr a	count=1
function	unzip6 function takes ||| unzip6	count=1
return	which [return] code ||| [return]	count=1
module	the same as ||| data bits	count=1
module	unsigned integral type ||| exts	count=1
args	handle to ||| handle io r	count=1
return	storable type in ||| storable	count=2
return	the haskell [return_2] ||| [return_1] [return_2]	count=1
args	monad scanning the ||| a3 monad a4	count=1
module	with ||| ghc	count=1
module	allocate a fresh ||| marshal pool	count=1
function	char ||| char	count=1
module	type ||| ghc exts	count=2
args	conversion scheme ||| dstate io textencoder estate	count=1
args	witharray but a terminator ||| ptr storable io b	count=1
module	elements of ||| data	count=2
args	writes the string ||| handle string	count=1
module	encoding may ||| encoding	count=2
module	the ||| io error	count=13
function_return	[function_1] unicode encoding ||| [function_1] [return_2]	count=1
args	either ||| b c either a	count=1
function	duplicate ||| duplicate	count=1
return	in addition to the ||| io	count=1
args	and always returns ||| readp a	count=1
args	like witharray but ||| storable io	count=1
args	in the pool but ||| pool	count=1
args	[args] file file ||| filepath [args]	count=1
module	of a structure ||| data	count=1
return	buffer to the ||| buffer	count=1
function	deprecated use traceevent ||| trace event	count=1
return	the io action ||| io a	count=2
return	but returns a ||| string $list$ string	count=1
function	event manager ||| event manager	count=2
return	takes a ||| a	count=3
return	argument arrow ||| arrow $tuple_3$ b	count=1
module	[module_1] [module_2] returns seven lists analogous ||| [module_2] [module_1]	count=2
return	end marker ||| storable/eq	count=1
args	storable values in ||| storable $f_2$ ptr storable io b	count=1
function	[function_1] [function_2] ||| [function_1] indefinitely [function_2]	count=24
args	of non-options ||| argorder a $list$ optdescr	count=1
args	the sense ||| int	count=1
args	string as ||| $f_2$ string string	count=1
function	string ||| from string	count=2
args	a memory area ||| ptr a	count=1
args	a monad scanning the ||| a3 monad a4	count=1
function	to ||| word ptr to ptr	count=1
module	memory ||| marshal	count=1
return	a ||| ptr a	count=1
module	for the current ||| ghc io	count=1
args	function is ||| b	count=1
rep	[module_1] [function_args_2] ||| [module_1] [function_args_2]	count=21
args	finalized pointer ||| finalizerenvptr env a ptr env ptr	count=1
module	fresh ||| foreign	count=1
return	by p ||| readp	count=1
return	read [return_2] ||| [return_1] [return_2]	count=2
function	numerator and denominator have ||| numerator	count=1
function_return	[function_1] constructor ||| [return_2] [function_1]	count=2
args	pool which ||| $f_2$ pool	count=1
return	a foreignptr to ||| io foreignptr	count=2
args	a handle ||| handle	count=3
return	tvar ||| tvar	count=1
return	rest unchanged to the ||| c d	count=1
args	exception predicate to ||| $f_2$ exception maybe b io	count=1
function	to the modified ||| modify	count=1
args	a list is ||| $list$ a	count=2
args	scanning ||| a4	count=1
args	pool to ||| pool ptr a	count=1
function_args	[function_1] integral ||| [function_1] drop [args_2]	count=3
return	as [return] ||| io [return]	count=1
function	a fresh memory ||| new pool	count=1
function	already ||| already	count=3
module	[module_1] can only ||| [module_1] [module_2]	count=1
function_return	[function_1] returns the ||| [function_1] file size handle [return_2]	count=3
args	promote a function ||| monad a1 monad a2 monad a3 monad	count=1
args	format character ||| char	count=1
args	value ||| io a io b io	count=2
function_args	show a [args_2] ||| [function_1] gfloat [args_2]	count=5
args	action in ||| a	count=1
module	integral type with the ||| ghc	count=1
function_args	[function_1] [args_2] in the type ||| [function_1] [args_2]	count=3
function	the same as x ||| set	count=1
module	c ||| c string	count=10
return	returns a ||| a $list$ string $list$ string $list$ string	count=1
function	root of the exception ||| some exception	count=1
args	for the either type ||| $f_2$ b c either a b	count=1
module	an encoding ||| encoding	count=1
return	monoid ||| monoid	count=1
return	chan the duplicate ||| io chan	count=2
args	with ||| $f_2$ c d arrow b c	count=2
args	the type char ||| char	count=1
function	file in ordinary blocking ||| file blocking	count=1
module	element of ||| data traversable	count=1
return	a ||| $list$ a	count=8
return	[return_1] unsigned realfrac ||| [return_2] [return_1]	count=1
function	with the same size ||| w#	count=1
function	additionally if ||| throw errno if	count=1
args	a ||| $list$ a $list$ b $list$	count=2
args	encapsulated in a ||| b b foldable a	count=1
module	an attempt was ||| control exception base	count=1
module	container [module_2] ||| [module_2] [module_1]	count=2
args	is encapsulated in a ||| b b foldable a	count=1
args	a conversion scheme between ||| io textencoder estate	count=1
module	from the environment ||| environment	count=1
return	arrow and ||| arrow $tuple_3$	count=1
args	a memory area that ||| a	count=1
module	a pair of ||| data	count=1
args	a structure but ||| b b b foldable a	count=1
module	failed because the user ||| io error	count=2
return	result value ||| a	count=1
module	left ||| control arrow	count=1
return	[return_1] realfrac value ||| [return_1] [return_2]	count=1
args	is true and ||| bool	count=1
args	living inside a ||| a io	count=2
args	function returns ||| eq $list$ eq	count=1
function	for [function_2] ||| [function_2] [function_1]	count=6
module	[module_1] arrows and ||| [module_1] [module_2]	count=8
args	a ||| a b c applicative a	count=1
module	representation of a character ||| data	count=1
function	the float ||| float	count=1
function	from right to left ||| r	count=1
function_return	the contents [return_2] ||| [return_2] [function_1]	count=2
module	for the current ||| ghc conc sync	count=1
args	by the specified number ||| int	count=3
return	their outputs ||| arrowchoice either b	count=2
args	value produced ||| $f_2$ a monad b	count=1
return	type in the ||| io	count=1
function	current i/o ||| get	count=2
args	storable values ||| $f_2$ ptr storable	count=1
module	marshal a value ||| foreign marshal	count=2
module	of a ||| data typeable	count=6
args	return value from the ||| io a	count=2
function	flush data ||| flush	count=1
module	[module] function ||| [module]	count=3
args	as ||| bits	count=1
module	and columns [module_2] ||| [module_1] [module_2]	count=3
function_args	a duplicate [args_2] ||| [function_1] [args_2]	count=1
args	user-supplied equality predicate instead ||| $f_3$ a a bool $list$	count=1
args	maximum [args] maximum ||| [args]	count=1
args	like addforeignptrfinalizerenv ||| a ptr env foreignptr a	count=2
function	managed by hdl blocking ||| h get	count=2
function_return	[function_1] function reads ||| [return_2] [function_1]	count=1
args	value from ||| a io	count=2
args	fresh memory pool ||| $f_2$ pool io	count=1
module	and marshal a value ||| foreign marshal	count=1
function	type ||| w#	count=1
module	stack ||| control exception base	count=1
return	buffer to the beginning ||| io buffer	count=1
function	usererror if the ||| throw if	count=1
function_args	[function_1] signed realfloat ||| [function_1] ffloat alt maybe [args_2]	count=1
return	magnitude phase pair in ||| $tuple_2$ realfloat	count=1
module	the user ||| io error	count=2
module	array including ||| foreign marshal array	count=2
module	right-to-left dual of ||| data	count=1
return	arrow ||| arrow b	count=1
return	a ptr ||| ptr a	count=2
function	on zipping ||| zip list	count=1
module	the same as x ||| data bits	count=1
return	a storable ||| ptr storable	count=3
args	where the return value ||| io a	count=2
args	mvar ||| mvar	count=1
function	copied each ||| copied	count=1
function	all ||| all	count=1
function	upper ||| min	count=1
args	a [args] lists ||| $f_3$ a a [args]	count=1
args	user-supplied equality predicate instead ||| bool	count=1
args	to a monad scanning ||| monad a4	count=1
function	the finalizer ||| finalizer	count=2
function	is blocked [function_2] ||| [function_1] indefinitely [function_2]	count=8
function	to throw or catch ||| to	count=2
function	like openfile but [function_1] [function_2] ||| system io [function_1] binary [function_2] filepath iomode io handle	count=4
return	stopped because ||| codingprogress	count=1
module	a c signed ||| foreign c string	count=1
function	non-blocking ||| read mvar	count=1
function	shift the first argument ||| unsafe shift	count=1
function	wide string ||| cwstring	count=1
module	object of ||| data dynamic	count=1
module	an [module_2] ||| [module_1] [module_2]	count=28
args	predicate and two ||| bool $list$ a	count=1
module	options and a ||| system console	count=1
function	the function coerce ||| coerce	count=1
args	predicate instead ||| a a bool $list$	count=1
function	mallocarray0 but ||| ptr array0	count=1
module	causes ||| foreign foreignptr safe	count=1
args	statickey ||| statickey	count=1
function	usererror if ||| if	count=1
module	the machine ||| ghc	count=1
args	of the first handle ||| handle handle	count=1
args	case no ||| io a	count=1
module	[module_1] corresponding ||| [module_2] [module_1]	count=5
return	an unsigned realfrac value ||| realfrac	count=1
function	foreign pointer and ||| new foreign ptr	count=1
return	the required type ||| io ptr	count=1
function	class ||| from rat	count=1
args	equality predicate instead ||| bool $list$	count=1
function	references to the mvar ||| mvar	count=2
function	threads ||| threads	count=1
args	in [args] ||| int [args]	count=3
function_return	[function_1] [return_2] ||| [function_1] buffer word8 [return_2]	count=27
args	but with the arguments ||| $f_2$ a monad	count=1
args	with a pure function ||| $f_2$ c d arrow b	count=1
module	useful in ||| control	count=2
args	[args] with ||| [args]	count=1
return	into the buffer ||| io $tuple_2$ int buffer	count=1
return	functor class ||| functor	count=2
args	value produced ||| a $f_2$ a monad b	count=1
function	and combine the results ||| fold	count=1
module	each gc by the ||| ghc	count=1
return	the newx ||| io	count=1
module	terminated c ||| c string	count=1
function	the native [function_2] ||| [function_2] [function_1]	count=1
return	first components and a ||| a	count=1
function	like catch but ||| catch just	count=1
args	living inside a ||| ptr a	count=2
args	a latin-1 ||| cchar	count=1
return	type constructor ||| $tuple_2$ tycon	count=2
module	a parser into one ||| text parsercombinators	count=1
function	user calls error ||| error	count=2
function	temporary storage with ||| with	count=1
function	throwerrnoifminus1retrymayblock ||| if minus1retry may block_	count=1
args	value produced by the ||| $f_2$ a monad	count=1
args	any value produced ||| monad a monad b	count=1
args	monad scanning the ||| monad a2 monad a3 monad a4 monad a5	count=1
args	catch any ioerror ||| $f_2$ ioerror ioerror io a	count=1
function	stable pointer to ||| cast stable ptr to ptr	count=1
args	in the pool ||| pool ptr storable	count=1
args	monad scanning the ||| monad a4 monad	count=1
module	which may be marshalled ||| ghc	count=1
function	[function_1] newline representation ||| [function_2] [function_1]	count=2
function	throwerrnoif but ||| errno if	count=1
return	parses the first zero ||| readp string	count=1
function	s heap ||| heap overflow	count=2
function	the group ||| group	count=1
function	polar takes a ||| polar	count=1
args	in the structure ||| foldable	count=2
function	the zip5 function ||| zip5	count=1
module	overloaded version of ||| data	count=2
args	function is ||| b $list$	count=1
return	version ||| a	count=2
return	the precedence context by ||| readprec a	count=1
function	kept [function] avoid breaking ||| [function]	count=1
args	a list of non-options ||| argorder a $list$ optdescr a $list$	count=1
return	a single ||| string	count=1
function	returning the radix of ||| float radix	count=1
module	[module_1] command-line and ||| [module_1] [module_2]	count=2
args	either ||| $f_2$ a c $f_2$ b c either	count=1
args	any value produced ||| $f_2$ a monad	count=1
return	manager ||| io eventmanager	count=1
args	elements ||| a bool $list$	count=1
args	with the arguments ||| $f_2$ a monad	count=1
args	a binary function to ||| a b c applicative a applicative	count=1
return	number ||| $tuple_2$ int	count=3
function	spacing ||| spacing	count=1
function	represent the ||| left associative	count=1
module	parser ||| text parsercombinators readp	count=4
function	to full precision using ||| float	count=1
function_return	[function_1] the ||| [function_1] mvar mvar a [return_2]	count=1
function	the same ||| set	count=1
module	type ||| ghc	count=1
module	type ||| data typeable internal	count=1
function	[function_1] on an ||| [function_2] [function_1]	count=6
function_args	[function_1] realfloat ||| [args_2] [function_1]	count=1
args	living inside a ||| a $f_2$ ptr a io	count=2
function	trace to [function_2] ||| [function_2] [function_1]	count=3
args	lists but ||| $list$	count=1
return	the specified character ||| char	count=1
return	[return_1] to true ||| [return_1] [return_2]	count=4
module	corresponding to the current ||| c	count=1
function_return	[function_1] a ||| [return_2] [function_1]	count=2
function	convert [function] ||| [function]	count=1
function_return	[function_1] fixity of ||| [return_2] [function_1]	count=2
args	right by -i ||| int	count=1
function	new ||| new	count=7
module	instance was ||| control exception base	count=2
args	a list of marshalled ||| b res $list$ a $f_2$ $list$ b	count=1
module	blocked ||| control exception	count=1
function	position ||| absolute seek	count=3
args	handle and file path ||| string maybe handle	count=1
return	buffer without blocking ||| io $tuple_2$ maybe int buffer word8	count=1
args	pointer to ||| $f_2$ ptr storable io b	count=2
function	close ||| close fd	count=1
function	current i/o position of ||| get posn	count=2
args	the given [args_2] ||| [args_2] [args_1]	count=12
return	strict ||| st	count=1
args	of storable values ||| storable	count=1
args	executed ||| mvar a $f_2$ a io $tuple_2$ a	count=1
args	to a curried function ||| a b c a b	count=1
return	[return_1] memory ||| [return_1] [return_2]	count=4
function	for fmap in ||| fmap default	count=2
return	[return] shorter ||| [return]	count=4
args	pointer to a ||| storable $f_2$ ptr	count=1
function_return	[function_1] handle ||| [function_1] handle [return_2]	count=1
return	the buffer ||| int buffer	count=1
return	rest unchanged ||| b d c d	count=1
args	value typically the ||| a b b $list$ a	count=1
function	block the current [function_1] [function_2] ||| [function_1] [function_2]	count=5
args	monads ||| $list$ b	count=1
module	[module_1] including ||| [module_2] [module_1]	count=4
return	optdescr ||| optdescr	count=1
return	of memory ||| ptr storable	count=1
module	array [module_2] ||| [module_2] [module_1]	count=2
function	to read from a ||| read stm	count=1
module	a c ||| foreign c string	count=15
return	traverse with ||| applicative traversable b	count=1
args	a maybe value ||| a b maybe a	count=1
return	the subsequences function returns ||| $list$ $list$	count=1
return	waiting to retry an ||| blockedindefinitelyonstm	count=1
args	int ||| int	count=1
return	either ||| io either	count=1
function	file that may ||| file	count=1
args	pool which gets automatically ||| $f_2$ pool io	count=1
function	storage ||| pooled	count=6
args	promote a function ||| a3 a4 a5 r monad a1 monad a2	count=1
function	upper and lower ||| bound	count=1
return	operating on the ||| io b	count=1
args	non-options a list of ||| argorder	count=1
args	this function ||| foreignptr	count=2
module	a [module_2] ||| [module_1] [module_2]	count=13
args	int in the ||| int	count=1
function	actually a pair ||| pair	count=1
function	[function_1] file ||| system io [function_1] [function_2] filepath iomode io handle	count=2
args	curried function ||| a b c	count=1
args	stablename that ||| stablename	count=1
function	quot and [function_2] ||| [function_2] [function_1]	count=1
function	current buffering [function_2] ||| [function_2] [function_1]	count=2
return	perform a series ||| io a	count=1
return	the buffer blocking ||| $tuple_2$ int buffer	count=1
args	satisfy the predicate ||| $f_2$ a bool	count=2
function	zip7 function ||| zip7	count=1
module	given parser ||| parsercombinators	count=2
return	the contents ||| io	count=5
module	io library ||| io encoding	count=2
module	exception is raised ||| exception	count=4
args	value from ||| a	count=2
function	terminate the thread for ||| thread	count=1
function	a fresh ||| new pool	count=1
args	discarding any value ||| a monad	count=1
return	merging ||| b' either	count=1
module	pair of types ||| data typeable internal	count=2
return	monadic arguments from ||| monad r	count=1
function	from the [function_2] ||| [function_1] [function_2]	count=6
args	given ||| ptr storable $list$ storable	count=1
args	promote a function to ||| r monad a1 monad	count=2
function	v format character with ||| v	count=1
function	thread is blocked ||| blocked	count=2
return	read a string representation ||| reads string	count=1
function	to the finalizer ||| finalizer env	count=2
function	accumulator together with the ||| accum l	count=2
module	component ||| foreign foreignptr unsafe	count=1
module	the same ||| exts	count=1
args	for the given number ||| int $f_2$ ptr storable	count=1
args	and ||| filepath	count=1
function	the transpose function ||| transpose	count=1
module	subset of ||| data char	count=1
function	zip4 function takes ||| zip4	count=1
args	takes an exception predicate ||| $f_2$ exception maybe b io a	count=1
function	query element or nothing ||| elem	count=1
module	error code eagain ||| error	count=1
args	this function extracts ||| foreignptr	count=1
args	monad scanning ||| a2 monad a3 monad a4 monad	count=1
args	any value produced by ||| $f_2$ a	count=1
return	five [return_1] [return_2] ||| [return_1] $tuple_5$ [return_2]	count=1
module	the end of ||| io error	count=1
module	datatype ||| generics	count=4
function	stm transaction but ||| stm	count=1
module	element of a ||| data	count=1
module	an mvar ||| control concurrent	count=1
function	call to atomically ||| atomically	count=1
return	computation hgetline ||| io string	count=2
return	constructor ||| $tuple_2$ tycon	count=2
function	hdl encoding [function] ||| h [function]	count=6
args	for the either type ||| b c either	count=1
return	handle with its ||| handle	count=1
return	[return] calling ||| [return]	count=1
function	fmap in a ||| fmap	count=1
function	read an ||| read dec	count=1
args	the given number ||| int $f_2$ ptr	count=1
args	of storable ||| $f_2$ ptr storable io	count=1
return	is used ||| io $tuple_2$ buffer from buffer	count=2
function	pointer ||| ptr	count=4
args	a nul terminated c ||| cstring io	count=1
args	pointer living inside a ||| ptr a io b	count=2
function	hgetbufnonblocking hdl buf count ||| non blocking	count=2
return	value of the second ||| a	count=1
return	f passing as ||| b	count=1
args	stablename that does ||| stablename a stablename b	count=1
args	finalizers associated with a ||| a	count=2
function	hgetposn [function] ||| h [function]	count=2
module	options ||| system console getopt	count=1
module	the results of ||| data	count=1
module	[module_1] text ||| [module_1] [module_2]	count=2
args	promote a function to ||| a5 r monad a1 monad a2	count=1
return	a possible ||| reads	count=1
args	a structure ||| b b b foldable a	count=3
function	build a new ||| new	count=1
function	[function_1] written to ||| [function_2] [function_1]	count=6
args	of non-options ||| argorder a $list$ optdescr a $list$ string	count=1
function	the native [function_2] ||| [function_1] [function_2] mode newlinemode	count=1
module	marshal ||| marshal	count=2
return	[return] list representing ||| io $list$ [return]	count=2
args	numbers of a structure ||| foldable num	count=2
function	the [function] as ||| [function]	count=1
module	of scanr ||| data list	count=2
return	used to continue ||| io $tuple_2$ buffer from buffer to	count=2
args	fresh memory pool which ||| $f_2$ pool	count=1
module	the input ||| control	count=1
return	other bits ||| bits	count=1
function	== just 1 mfilter ||| mfilter	count=1
function	unregister ||| unregister	count=1
return	handle with its ||| io handle	count=1
return	for the end marker ||| io ptr	count=1
args	memory pool which ||| pool io	count=1
args	like witharray but ||| $list$ storable $f_2$ ptr storable io b	count=1
function	file [function_2] ||| [function_2] [function_1] filepath iomode io handle	count=2
module	mallocarray but allocated ||| marshal	count=1
function	always is a variant ||| always	count=2
return	for storable ||| storable	count=1
args	applied to non-empty ||| $f_3$ a a a foldable	count=1
function	hdl into ||| h get	count=4
module	default value and and ||| data	count=1
args	list of storable ||| storable $f_2$ ptr storable io	count=1
function	by ||| end by	count=2
function	a latin-1 character to ||| cuchar to	count=1
function	is [function_2] ||| [function_1] [function_2]	count=15
args	number ||| int ptr	count=1
function	[function_1] prefix from ||| [function_2] [function_1]	count=2
return	rest through unchanged ||| either c d	count=1
module	only be used within ||| ghc conc	count=1
args	character ||| handle char	count=1
function_args	representation of datatypes ||| rep $list$ constr	count=1
function	of the [function] as ||| [function]	count=1
args	in a ||| b b foldable a	count=1
function	the traceeventio ||| event	count=1
args	pointer to a ||| $f_2$ ptr storable	count=2
return	computation [return_2] ||| [return_1] [return_2]	count=12
return	message to the eventlog ||| io	count=1
function	string [function_1] [function_2] explicit length information ||| [function_2] [function_1]	count=2
return	a foreignptr to ||| foreignptr	count=2
args	value of ||| a	count=1
function	wide character ||| cwstring	count=1
return	[return_1] stm action ||| [return_1] [return_2]	count=3
args	value of the first ||| a applicative	count=1
module	a nul terminated c ||| c string	count=1
module	instance of ||| data	count=1
module	foreign function equivalent ||| foreign	count=1
args	in the given pool ||| pool	count=1
return	handle with its own ||| handle	count=1
module	posix data types haskell ||| posix	count=1
function	the sign of a ||| sign	count=1
function	haskell reads-style ||| read p_to_s	count=1
return	[return_1] specified character ||| [return_1] [return_2]	count=1
function_return	[function_1] [return_2] ||| [function_1] storable/eq ptr storable/eq [return_2]	count=2
function	show ||| h show	count=2
module	traceio function outputs the ||| debug	count=1
return	for the handler ||| io	count=2
function	send the first component ||| first	count=1
module	slides ||| io buffer	count=1
args	for the given number ||| int $f_2$ ptr	count=1
return	actions ||| applicative d	count=1
return	may ||| finalizerptr	count=1
function	current [function] given ||| [function]	count=1
module	allocate a ||| marshal pool	count=1
return	of the required type ||| io	count=1
function	throwerrnoifretry but additionally if ||| errno if	count=1
module	[module] ex falso ||| [module]	count=3
args	value produced ||| a monad b	count=2
module	into a c wide ||| foreign c string	count=1
args	value of the first ||| a applicative b	count=1
module	c string into a ||| foreign c	count=1
args	promote a function to ||| a4 r monad a1 monad a2	count=1
module	in memory area ||| foreign marshal utils	count=2
args	predicate ||| $f_2$ a bool string	count=1
args	of storable values ||| $f_2$ ptr storable io	count=1
return	a string that ||| string	count=2
args	the elemindex function returns ||| eq $list$	count=1
return	but returns a ||| $list$ a $list$ string $list$ string $list$ string	count=1
args	monads ||| c $list$ a $list$ b	count=1
function	contents of ||| contents	count=1
function	or channel managed by ||| h	count=2
args	used as a value ||| a b traversable a	count=1
function	[function_1] contents ||| [function_1] [function_2]	count=1
return	to any monadplus ||| monadplus a	count=1
args	given [args_2] ||| marshal array move array [args_1] [args_2]	count=4
function	type in class ||| from rat	count=1
args	like witharray but a ||| $f_2$ ptr storable io b	count=1
function	default file ||| file with default	count=1
args	[args_1] [args_2] ||| marshal array move array [args_1] [args_2]	count=12
args	to a predicate ||| $f_2$	count=2
args	that has no starting ||| $f_3$	count=3
module	that ||| conc	count=1
return	a ||| $list$ a $list$	count=2
function	list using square ||| list with	count=1
function	by defining left = ||| left	count=1
module	operation yields the error ||| error	count=1
return	result value of ||| a	count=1
module	[module_1] c ||| [module_2] [module_1]	count=11
function	concatenation of all ||| concat	count=2
function	the indices ||| indices	count=1
return	result value [return_2] ||| [return_2] [return_1]	count=4
return	the size needed to ||| io ptr storable	count=1
module	of unicode ||| data	count=1
module	encoding ||| encoding	count=4
args	analysis for the either ||| c $f_2$ b c either	count=1
args	any value ||| a $f_2$ a monad b	count=1
function	the unzip6 function ||| unzip6	count=1
function	and ||| bound	count=1
module	allow ||| control monad st lazy	count=1
args	a list of non-options ||| argorder a $list$ optdescr a $list$ string	count=1
function	[function_1] the error ||| [function_2] [function_1]	count=1
return	of the required type ||| io ptr	count=1
args	with a pure function ||| $f_2$ b c arrow	count=1
function	size ||| w#	count=1
function	another call to atomically ||| atomically	count=1
args	value of ||| a applicative b	count=1
args	a monomorphic type constructor ||| tycon $list$	count=1
module	the error code ||| c error	count=2
return	staticptr by its ||| io maybe staticptr	count=1
return	of mkweak where ||| weak k	count=2
args	actions discarding any value ||| a	count=1
args	monad scanning the ||| a3 monad a4 monad a5	count=1
module	of types that have ||| data	count=1
function	register a timeout in ||| register timeout	count=1
args	is a reverse ||| $f_2$ a	count=1
return	function takes a ||| $list$ a $list$ b	count=2
function	the size ||| size	count=1
function	var or ||| lookup	count=1
return	a threadid is ||| threadid	count=2
args	to a monad scanning ||| a4	count=1
function	value of geterrno if ||| errno if	count=2
module	gc ||| ghc stats	count=2
function	[function] associates a ||| new foreign [function]	count=1
return	foreignptr to ||| foreignptr	count=2
function	variant of throw ||| throw io	count=2
function	representation ||| rep ty	count=2
return	this variant of ||| foreignptr	count=1
args	a ||| io a	count=1
function	current ||| get posn	count=4
args	a monad scanning ||| a3 monad a4 monad	count=1
module	because [module_2] ||| [module_1] [module_2]	count=10
return	with the reference ||| io	count=1
module	encoding may now ||| encoding	count=2
args	a list of storable ||| ptr storable io b	count=1
function_return	atomically read [return_2] ||| [function_1] mvar mvar a [return_2]	count=4
function	native ||| native	count=2
function	function coerce allows you ||| coerce	count=1
return	; [return] copied ||| [return]	count=1
module	[module_1] applicative functor ||| [module_1] [module_2]	count=2
function	float type ||| float type	count=1
function	the current [function] given ||| [function]	count=1
module	c string ||| c	count=3
function	module where ||| module	count=1
return	and return nothing ||| maybe	count=1
module	types defined by the ||| types	count=1
args	a new ||| a	count=2
return	of lists ||| b $list$	count=1
return	bytes into the buffer ||| buffer word8	count=1
args	memory pool which ||| pool io b	count=1
return	through the argument arrow ||| arrow	count=1
function	right to ||| r	count=1
args	this is a way ||| foreignptr a $f_2$ ptr	count=2
return	but returns ||| $list$	count=1
args	hsetbuffering hdl ||| buffermode	count=1
return	elements of a storable ||| storable	count=2
args	a handle hdl which ||| handle	count=1
function	bytes [function_2] ||| [function_2] [function_1]	count=8
args	a ||| d e $list$ a $list$ b $list$	count=1
module	file involved in the ||| system io	count=1
args	list of storable ||| storable $f_2$ ptr storable	count=1
function	s stack ||| stack	count=2
module	an internal function ||| typeable internal	count=1
return	returns a [ string ||| io $list$ string	count=2
function	to printf except ||| printf	count=1
args	value from ||| a io b	count=2
args	openfile file mode ||| iomode	count=2
args	value produced by ||| a $f_2$ a monad	count=1
return	public presentation ||| constrrep	count=1
module	but uses the ||| io	count=1
return	lists such that the ||| $list$ $list$ eq	count=1
module	of second ||| data	count=1
args	to a predicate ||| $f_2$ a bool	count=2
args	promote a function to ||| a4 r monad a1 monad a2 monad	count=1
function_args	[function_1] [args_2] ||| [function_1] $f_2$ [args_2]	count=16
return	; [return] ||| [return]	count=3
function_return	read the [return_2] ||| [function_1] chan chan a [return_2]	count=1
args	the ||| ioref a io	count=1
args	[args_1] a single ||| [args_1] [args_2]	count=1
args	either ||| either a	count=1
return	those that didn t ||| $tuple_3$ $list$ a $list$ string $list$ string	count=1
return	[return_1] the ||| [return_2] [return_1]	count=26
module	user ||| ghc rts flags	count=1
function	given path when appropriate ||| throw errno path if	count=1
return	returns a ||| $tuple_2$ $list$ a $list$ a	count=1
return	[return_1] hgetbuffering ||| [return_2] [return_1]	count=2
return	memory ||| io foreignptr storable	count=1
args	any value produced ||| $f_2$ a	count=1
function	the zip7 function ||| zip7	count=1
return	as ||| monad	count=1
return	a complex value with ||| complex	count=1
args	handle to ||| handle io	count=2
args	either type ||| either a b	count=1
function	exponent corresponds to the ||| exponent	count=1
args	the return value from ||| io a io	count=2
args	promote a function to ||| monad a1 monad a2	count=2
return	the end ||| io ptr storable	count=1
args	a list of marshalled ||| $f_2$ b res $list$ a $f_2$ $list$ b	count=1
return	into ||| io	count=3
function_args	[function_1] [args_2] action evaluate these actions ||| [function_1] [args_2]	count=1
module	types ||| typeable internal	count=2
module	in memory area with ||| foreign marshal utils	count=1
args	which is an exception ||| exception	count=1
function	string [function_1] [function_2] length information ||| string [function_2] [function_1] string $f_2$ cstringlen io	count=2
function	[function_1] in binary ||| [function_2] [function_1]	count=6
module	an io action ||| control monad	count=1
return	in the io ||| io	count=7
return	monadic ||| monad b	count=2
module	from data ||| data ord	count=1
args	the pool but leave ||| pool	count=1
function	mapandunzipm function ||| map and unzip m	count=1
function	radix of the ||| radix	count=1
args	given marker ||| $list$ storable	count=1
module	error code eagain ||| foreign c error	count=1
function	gets ||| constr type	count=1
return	the size of the ||| io	count=1
module	the operation failed because ||| system io error	count=5
args	value produced by the ||| a monad b	count=2
function	x ||| set	count=1
function	int [function_2] ||| [function_2] [function_1]	count=1
function	length into a haskell ||| peek	count=1
function	lower ||| min bound	count=1
args	a monad scanning ||| monad a4 monad	count=1
module	where the array ends ||| array	count=1
return	a [ string ||| string	count=2
args	a binary function ||| a b c applicative a applicative	count=1
module	integral type with ||| ghc exts	count=1
args	[args_1] curried function ||| [args_2] [args_1]	count=8
function	nth [function] ||| test [function]	count=3
function_args	[function_1] a binary ||| [function_1] [args_2]	count=1
args	a list of ||| res $list$ a $f_2$ $list$	count=1
return	by the io ||| io a	count=1
return	for the handler is ||| io	count=2
function	list using square brackets ||| list	count=1
function	looks up ||| unsafe lookup static	count=1
return	arrow and copy ||| arrow $tuple_3$ b d c	count=1
return	a list of lists ||| a	count=1
args	value from the ||| io a	count=2
args	argument is executed ||| mvar	count=1
return	of memory and ||| ptr storable	count=1
function	wide string with ||| cwstring	count=1
module	but allocated ||| marshal	count=1
module	type with the same ||| exts	count=1
function	foreign ||| with foreign	count=2
args	equality predicate instead ||| a a bool $list$ a	count=1
return	the finalizers associated ||| io	count=2
args	catch any ioerror that ||| ioerror ioerror io a	count=1
module	[module] exception raised ||| [module]	count=1
return	the bounded class is ||| bounded	count=1
function	string [function_1] [function_2] explicit length information ||| string [function_2] castring [function_1] string $f_2$ cstringlen io	count=2
return	returns an stm action ||| $tuple_2$ stm	count=3
args	is a ||| a $f_2$ a	count=1
return	or any [return] ||| [return]	count=3
args	a reverse application operator ||| $f_2$ a b	count=1
function	block the current thread ||| thread	count=2
args	writes the string s ||| handle string	count=1
args	of ||| a	count=4
function_return	the [function_1] [return_2] from the structure l ||| [function_1] islist [return_2] islist	count=1
function	filter applied to a ||| filter	count=1
return	character ||| readp char	count=1
return	but returns an either ||| io either	count=2
args	storable values ||| ptr storable io	count=1
function	printf except ||| printf	count=1
function	general [function_2] ||| [function_1] [function_2]	count=1
function	blocked in retry ||| blocked on	count=2
return	to the type char ||| char	count=1
module	of terminating the program ||| system	count=1
function	from right ||| r	count=1
args	takes a [args] lists and ||| $f_3$ a a [args]	count=1
function_args	[function_1] number ||| [function_1] malloc array pool [args_2]	count=1
return	lists such ||| $list$ $list$ eq	count=1
function	used to name ||| bound	count=1
function	a foreign pointer and ||| foreign ptr	count=1
return	[return] converting ||| [return]	count=1
function	wait for [function_2] ||| [function_2] [function_1]	count=1
module	a value into it ||| foreign	count=1
return	function behaves ||| $list$	count=1
function	non-blocking ||| try read mvar	count=1
args	unsigned integral type with ||| word#	count=1
args	promote a function to ||| a4 a5 r monad a1 monad a2	count=1
function	changes ||| set	count=2
function	handle the sign of ||| sign plus	count=1
module	list of corresponding ||| data list	count=1
return	buffer without blocking ||| $tuple_2$ maybe int buffer word8	count=1
args	of storable ||| storable $f_2$ ptr storable io	count=1
function	megabytes allocated | ||| megabytes allocated	count=2
function	tvar ||| tvar io	count=2
function	hdl ||| h	count=22
return	the buffer ||| buffer	count=3
return	representational equality ||| maybe coercion	count=1
function	to read ||| read	count=2
args	of a [args_2] ||| [args_2] [args_1]	count=8
function	hdl into the ||| h get	count=2
return	into the buffer ||| buffer word8	count=1
function	to the corresponding ||| cuchar to	count=1
function	upper and ||| min bound	count=1
function	extra position to hold ||| malloc array0	count=1
return	used to ||| buffer from buffer to	count=2
function	[function_1] sequence ||| [function_2] [function_1]	count=2
return	function is used ||| io $tuple_2$ buffer from buffer	count=2
args	argument a pointer to ||| ptr storable io	count=2
return	[return_1] adds a ||| [return_2] [return_1]	count=1
args	passing any value ||| a monad	count=1
module	convert a haskell ||| foreign marshal	count=2
return	type constructor application ||| $tuple_2$ tycon $list$	count=2
function_return	[function_1] a complex ||| [return_2] [function_1]	count=1
function	forever act repeats ||| forever	count=1
module	the same size ||| ghc	count=1
return	combine their output ||| arrow b $tuple_2$ c c'	count=1
function	file that ||| regular file	count=1
args	used as a value ||| $f_2$ a b traversable a	count=1
return	a type constructor application ||| $tuple_2$ tycon $list$	count=1
args	to a monad scanning ||| monad a4 monad a5	count=1
function	new open ||| open	count=2
function	[function_1] already being ||| [function_1] [function_2]	count=1
return	the specified number of ||| int	count=1
module	error code eagain or ||| error	count=1
return	[return] type ||| [return]	count=1
args	value from the ||| a io b io	count=2
function	scanr ||| scanr	count=1
return	the mapaccumr function ||| $tuple_2$ acc $list$ y	count=1
function_return	[function_1] of chan ||| [return_2] [function_1]	count=1
args	copy the given ||| storable ptr storable	count=1
args	pointer to a temporarily ||| $f_2$ ptr storable io b	count=2
args	any value ||| a $f_2$ a monad	count=1
module	two argument ||| control	count=1
function	is a [function] or similar ||| [function] bad	count=1
module	[module] block of ||| [module]	count=3
args	applied to non-empty ||| $f_3$ a	count=1
module	of ||| data data	count=6
function	allocate space for ||| pooled malloc	count=1
return	is a complex ||| complex	count=1
function	the argument right ||| r	count=1
return	or more ||| alternative $list$ a	count=1
return	a tuple ||| $tuple_2$ $list$ a $list$ a	count=1
module	array ||| array	count=4
module	the end ||| io	count=1
args	a list of marshalled ||| b res $list$ a $f_2$ $list$	count=1
function	the foreign object in ||| foreign	count=2
function	to the corresponding ||| cschar to	count=1
function_return	contents [return_2] ||| [function_1] buffer word8 [return_2]	count=2
rep	[module_1] [function_return_2] ||| [module_1] [function_return_2]	count=160
return	given ||| ptr a	count=2
function_return	[function_1] [return_2] from the structure l ||| [function_1] [return_2]	count=4
return	to the [return_2] ||| [return_1] [return_2]	count=4
args	equality predicate ||| bool $list$ a	count=1
return	mvar which contains ||| mvar	count=1
function	given path when appropriate ||| errno path if minus1	count=1
return	returns ||| $list$ a $list$ string $list$ string $list$	count=1
return	and return a foreignptr ||| io foreignptr	count=2
return	[return_1] realfrac value ||| [return_2] [return_1]	count=1
module	the utf-32 unicode encoding ||| io encoding	count=1
args	[args] hgetcontents ||| [args]	count=1
args	the pool ||| pool ptr storable	count=1
args	non-options ||| argorder a $list$ optdescr	count=1
return	pair of lists ||| a $list$	count=1
function	quantity ||| qsem n	count=1
return	[return_1] value pairs ||| [return_2] [return_1]	count=2
return	a foreignptr to it ||| io foreignptr	count=2
function	bound [function_2] ||| [function_1] [function_2]	count=1
return	didn t ||| $tuple_3$	count=1
function	written ||| write stm	count=3
function	minor ||| minor	count=1
function	about to terminate ||| finally	count=1
module	use in utf-16 ||| io	count=1
function_args	[function_1] [args_2] ||| [function_1] ffloat maybe [args_2]	count=6
return	the original handle ||| handle	count=1
function	using temporary storage ||| with	count=2
return	memory ||| io	count=1
return	the haskell ||| io	count=1
function	[function_1] contents of ||| [function_2] [function_1]	count=1
function_return	changes the [return_2] ||| [function_1] encoding handle textencoding [return_2]	count=1
args	given ||| storable	count=1
args	number of elements ||| int	count=4
function	the error message ||| error	count=1
function_args	[function_1] given number ||| [function_1] array0 pool [args_2]	count=1
module	for ||| data traversable	count=1
function	sets the ||| set posn	count=2
args	value from the first ||| a io b	count=2
args	value ||| $list$ a	count=2
function_return	[function_1] [return_2] ||| [function_1] foldable $list$ a [return_2]	count=7
function	cis t ||| cis	count=1
args	handle ||| handle	count=25
args	discarding any value ||| monad a monad b	count=1
return	weak pointer to ||| weak	count=1
function	a stack trace ||| with stack trace	count=2
function	map ||| map	count=3
function	latin-1 character to ||| cast cuchar to	count=1
args	a race-safe way ||| eventmanager $f_2$	count=2
function	[function_1] written ||| [function_2] [function_1]	count=6
module	for the specified ||| ghc	count=1
args	[args_1] [args_2] ||| [args_1] [args_2]	count=127
args	promote a function to ||| a1 a2 a3 a4 a5 r monad a1	count=1
args	file handle ||| handle	count=1
function	hash of a given ||| hash	count=1
return	retagging and merging ||| b b'	count=1
function	third value ||| show id	count=1
return	the required type ||| io	count=1
module	and ||| data foldable	count=2
function	ended by ||| end by	count=1
module	variant of ||| data	count=5
return	returns a tuple where ||| $list$ a	count=1
function	from [function_2] ||| [function_2] [function_1]	count=5
function_return	lines breaks [return_2] ||| [return_2] [function_1]	count=3
args	the given pool ||| pool	count=1
function_return	[function_1] [return_2] ||| [function_1] pool io ptr [return_2]	count=4
return	returns a tuple ||| a $list$ a	count=1
module	letters plus letters of ||| data char	count=1
return	operating on the contents ||| io b	count=1
return	arrows retagging and merging ||| b'	count=1
return	[return_1] number of ||| sync get num capabilities [return_1] [return_2]	count=2
function_return	observe [return_2] ||| [function_1] typerep [return_2]	count=2
function_return	until data [function_1] [return_2] ||| wait [function_1] fd [return_2]	count=1
return	as an integer and ||| $tuple_2$ integer	count=1
function	managed by hdl ||| h get char	count=2
return	but returns a ||| a $list$ string $list$ string $list$ string	count=1
function_args	[function_1] pool ||| [args_2] [function_1]	count=5
args	a binary ||| c applicative a	count=1
module	internal function ||| data typeable internal	count=1
return	type constructor ||| $tuple_3$ tycon	count=1
return	[return] empty list ||| [return]	count=2
function	default ||| default	count=4
function	like delete ||| delete by	count=1
function	upper and ||| min	count=1
return	takes a ||| $list$ a $list$ b	count=2
function	is actually a pair ||| weak pair	count=1
function	the real [function_2] ||| [function_1] [function_2]	count=1
args	like witharray but ||| $f_2$ ptr storable io	count=1
module	an io operation ||| io	count=3
function	to the finalizer ||| ptr finalizer env	count=2
args	a ||| c d e f g $list$ a $list$	count=1
function	[function_1] buffering mode ||| [function_2] [function_1]	count=8
function	bytes from the ||| bytes	count=2
module	[module] memory is ||| foreign [module]	count=3
function_return	[function_1] item ||| [function_1] islist [return_2] islist	count=3
return	is a complex value ||| complex floating	count=1
function	wide string ||| cwstring len	count=1
return	to arbitrary monads ||| monad	count=1
module	a c byte representing ||| c string	count=1
args	passing any value ||| a $f_2$ a monad b	count=1
args	analysis for the either ||| $f_2$ a c $f_2$ b c either a	count=1
function	marshal ||| peek cstring	count=2
return	exposes io errors ||| io	count=1
function	other private [function_2] ||| [function_1] [function_2]	count=1
return	traverse is defined ||| traversable b	count=1
function	trace spark ||| sparks	count=2
return	function returns true iff ||| bool	count=1
return	are ||| maskingstate	count=2
function	the conjunction ||| and	count=2
function	and combine ||| fold	count=1
function	printf except that output ||| printf	count=1
args	a ||| c applicative a	count=1
args	scanning the ||| a2 monad a3 monad a4 monad a5	count=1
function	chainl p op ||| chainl	count=1
function	to that capability ||| capability	count=1
args	list of non-options ||| argorder a $list$ optdescr a	count=1
function	error message if one ||| error	count=1
module	of a structure to ||| data traversable	count=1
function	allocate ||| pool	count=1
args	with a ||| $f_2$ c d arrow b	count=1
args	predicate instead ||| bool $list$ a	count=1
return	consecutive ||| io ptr storable	count=1
module	p [module] xs returns ||| data [module]	count=1
args	an exception predicate ||| $f_2$ exception maybe b io	count=1
function	lower limits of ||| min	count=1
module	concatenate ||| ghc oldlist	count=1
function	[function_1] storage in ||| [function_2] malloc [function_1]	count=2
return	message to stderr and ||| io a	count=1
args	monad scanning the ||| a2 monad a3 monad a4 monad a5	count=1
module	element of a ||| data list	count=2
args	catch any ioerror that ||| $f_2$ ioerror ioerror io	count=1
function	of ||| min bound	count=1
return	[return] list ||| $tuple_2$ $list$ [return] $list$	count=3
function	the size ||| set size	count=1
function	filled with bytes of ||| calloc	count=1
return	reads an ||| reads	count=1
args	into a c string ||| textencoding string	count=1
function	encoding ||| encoding	count=2
function	the current [function_2] ||| [function_1] [function_2]	count=6
module	printf ||| printf	count=1
return	io computation to ||| io a	count=1
args	equality predicate ||| bool $list$	count=1
return	returning a final value ||| $tuple_2$ a traversable	count=1
function	opens a file using ||| file	count=1
args	a reverse application ||| $f_2$ a	count=1
module	container [module_2] ||| [module_1] [module_2]	count=2
function_args	[function_1] [args_2] monadic action evaluate these ||| [function_1] [args_2]	count=1
function_args	[function_1] [args_2] ||| [function_1] name [args_2]	count=17
return	computation to be ||| s	count=4
module	an error [module_2] ||| [module_1] [module_2]	count=1
return	[return_1] current value ||| [return_1] [return_2]	count=1
return	parses and ||| readp	count=1
function	variant [function] ||| [function]	count=2
module	that can only be ||| ghc conc sync	count=1
args	handle ||| string maybe handle maybe	count=1
function	geterrno [function_2] ||| [function_1] [function_2]	count=5
return	someexception type is ||| someexception	count=1
return	may be used as ||| finalizerptr	count=1
module	number of elements ||| data	count=1
function_return	[function_1] to the ||| [return_2] [function_1]	count=1
function	an unsigned integral ||| w#	count=1
function	to ||| cast cuchar to	count=1
module	marshal a c string ||| c string	count=1
function_return	the [function_1] [return_2] l from the structure ||| [function_1] [return_2]	count=1
return	[return] ex ||| io either exception [return]	count=3
function	[function_1] [function_2] ||| [function_1] binary [function_2]	count=2
function_return	the contents [return_2] ||| [function_1] buffer word8 [return_2]	count=2
module	into a c ||| foreign c	count=4
return	look at the ||| io b	count=2
function	until data [function] on ||| thread wait [function]	count=1
function	marshal a c string ||| peek cstring len	count=1
args	any value produced ||| a $f_2$ a monad b	count=1
return	of a storable ||| storable	count=3
module	allocate a fresh memory ||| foreign	count=1
args	a ||| traversable a	count=2
return	stopped because there are ||| codingprogress	count=1
function_return	[function_1] handle with ||| [function_1] handle [return_2]	count=1
function_return	[function_1] i from ||| [return_2] [function_1]	count=7
module	as getopt ||| getopt	count=1
function	throwerrnoif but ||| throw errno if	count=1
return	of lists ||| b $list$ c	count=1
args	monad scanning ||| a3 monad a4	count=1
module	of the first element ||| data	count=1
function_return	[function_1] by the ||| [function_1] storable/eq ptr storable/eq [return_2]	count=1
args	yields true ||| bool	count=1
function	[function_1] counter ||| [function_1] [function_2]	count=4
return	of lists ||| $list$	count=2
return	tvar to ||| io tvar	count=1
args	a structure to a ||| monad b foldable a	count=2
function	convert from ||| from	count=1
function	already being ||| already	count=3
return	monadic arguments ||| monad r	count=1
args	a single ||| a string	count=1
function	to the ||| cast cschar to	count=1
function	integral type with the ||| w#	count=1
args	as ||| string	count=1
args	with ||| $f_2$ b c arrow c d	count=2
args	any value produced by ||| $f_2$ a monad b	count=1
module	[module_1] a ||| [module_1] [module_2]	count=10
module	value from an mvar ||| control	count=1
module	hdl is set ||| io handle	count=3
module	types of a ||| data typeable internal	count=1
module	arrow ||| arrow	count=1
function	lower limits ||| bound	count=1
args	the return value ||| a io b	count=2
function_args	[function_1] structure is ||| [args_2] [function_1]	count=2
args	a list of storable ||| storable $f_2$ ptr storable	count=1
args	constructor ||| tycon $list$	count=1
rep	block the current [module_1] [function_return_2] ||| [module_1] [function_return_2]	count=4
function_args	[function_1] [args_2] ||| bits rotate [function_1] [args_2] bits	count=7
function	the char [function_2] ||| [function_2] [function_1]	count=1
function	radix of the representation ||| float radix	count=1
return	of the io action ||| io	count=1
args	handle ||| handle io r	count=1
return	arrows retagging and merging ||| b' either c c'	count=1
function	fresh ||| new	count=1
args	file handle ||| string maybe handle maybe filepath	count=1
args	promote a function to ||| $f_5$ a1 a2 a3 a4 r monad a1	count=1
module	copies the ||| foreign marshal utils	count=1
module	from the ||| ghc	count=1
module	an ioerror [module_2] ||| [module_1] [module_2]	count=3
args	hseek hdl mode ||| seekmode	count=1
args	any value produced by ||| monad a monad b	count=1
module	element of ||| data list	count=2
function	the contents of ||| contents	count=1
module	stats ||| stats	count=1
args	pool ||| pool ptr a	count=1
args	function ||| a b	count=1
return	weak pointer ||| weak	count=1
function	trace to ||| trace	count=1
function	an allocation counter that ||| allocation counter	count=1
return	six-tuples ||| $tuple_6$ $list$	count=1
args	a c string ||| string	count=1
return	and merging ||| b' either	count=1
module	objects which may be ||| ghc	count=1
function	copied ||| copied	count=1
args	this is a ||| foreignptr a	count=2
function	base ||| at base	count=2
function	list using ||| list with	count=1
args	pointer ||| $f_2$ ptr storable	count=2
return	the monadic type ||| monad	count=1
function	[function_1] a signed ||| [function_2] [function_1]	count=1
args	int in ||| int	count=1
function	newline translation at all ||| newline translation	count=1
return	io ||| io either ioerror	count=1
args	[args_1] number of ||| [args_2] [args_1]	count=11
args	and returns a concrete ||| proxy typeable	count=2
return	computation hgetline hdl ||| io string	count=2
function	but additionally if the ||| if	count=1
function	the stable [function_2] ||| [function_1] [function_2] stableptr a	count=1
return	[return_1] application ||| [return_1] [return_2]	count=8
return	a lazy ||| a	count=1
module	be marshalled ||| ghc exts	count=1
return	optdescr ||| optdescr a	count=1
args	is encapsulated in a ||| a	count=1
function	with the same ||| w#	count=1
args	the method showlist is ||| show	count=1
return	lists ||| $list$ a $list$	count=1
args	by the specified number ||| bits int	count=3
args	promote a function to ||| a2 a3 a4 a5 r monad a1 monad	count=1
function	[function_1] file in ||| system io [function_1] binary [function_2] filepath iomode io handle	count=1
module	allocate a ||| foreign marshal	count=1
return	representation ||| rep	count=1
args	the mapmaybe function ||| $f_2$ a maybe b $list$	count=1
function_return	observe [return_2] ||| [return_2] [function_1]	count=2
function	to the error ||| error with	count=1
return	[return_1] hgetbuffering ||| [return_1] [return_2]	count=2
module	an applicative functor based ||| control applicative	count=1
return	reads a ||| reads string	count=2
args	to a ||| a	count=4
return	[return_1] a ||| [return_1] $tuple_5$ [return_2]	count=1
return	merging ||| b b' either c c'	count=1
module	an encoding in ||| ghc io encoding	count=1
function	digits ||| lex digits	count=1
module	[module] f ||| [module]	count=3
function	recover ||| recover	count=2
function	to the corresponding haskell ||| cast cuchar to	count=1
function_return	list [return_2] ||| [function_1] islist [return_2] islist	count=3
return	the associativity of a ||| associativity	count=1
return	quadruples ||| $tuple_4$ $list$	count=1
module	of that ||| data	count=2
return	at the pointer ||| io	count=2
module	results in ||| ghc io	count=1
return	returns the threadid ||| threadid	count=4
return	the representational equality ||| coercion	count=1
return	observe the fingerprint ||| fingerprint	count=2
function	length ||| length	count=1
args	of storable values in ||| $f_2$ ptr storable io	count=1
args	the ||| chan a	count=1
function	sign of ||| sign	count=1
args	for the either ||| either a	count=1
function	type to ||| type	count=1
function	union ||| union	count=1
return	used to continue ||| buffer to	count=2
module	an mvar ||| control	count=1
return	a tuple where ||| $list$ a $list$ a	count=1
args	number of ||| gcstats	count=1
function	is ||| min	count=1
function	has an allocation counter ||| allocation counter	count=1
args	handle connected ||| handle	count=2
args	first handle ||| handle handle	count=1
args	like witharray but a ||| storable $f_2$ ptr storable io	count=1
return	elements satisfying ||| $list$	count=1
args	the sense that for ||| int	count=1
args	a structure but with ||| b b b foldable a	count=1
return	handle to manage the ||| handle	count=2
module	[module_1] scanl ||| [module_1] [module_2]	count=16
module	[module_1] error ||| [module_1] [module_2]	count=6
args	a binary ||| $f_3$ a b c applicative a applicative	count=1
function	module where ||| sp info module	count=1
function	[function] five ||| [function]	count=2
function	a character ||| char	count=1
function	to ||| to ptr	count=2
return	version of mkweak where ||| weak k	count=2
module	[module_1] [module_2] described by the second ||| [module_1] [module_2] usage	count=1
args	structure to ||| $f_2$ a monad b foldable	count=2
return	the rest unchanged to ||| $tuple_3$ b d c d	count=1
function	manager ||| manager	count=1
module	only ||| conc	count=7
args	the ||| io a	count=3
args	maybe value ||| a b maybe	count=1
args	coerce ||| stableptr	count=1
return	the argument arrow ||| arrow	count=1
function	traceeventio ||| event io	count=2
module	components of ||| data complex	count=1
return	into a ||| $list$ a	count=1
module	operation failed because the ||| system io	count=2
args	element in the pool ||| pool	count=2
module	the user does not ||| io	count=2
return	value of the ||| applicative a	count=1
args	scanning the ||| a3 monad a4 monad a5	count=1
return	function behaves like ||| $list$	count=1
function	error message ||| error	count=1
args	structure to an ||| foldable	count=1
return	number of haskell threads ||| int	count=3
function	function returning the radix ||| radix	count=1
function	an smaller than ||| r	count=1
args	signed ||| maybe int	count=1
return	the io monad and ||| io string	count=1
function	length into a ||| peek	count=1
function_return	the tolist [function_1] [return_2] from the structure l ||| [function_1] islist [return_2] islist	count=1
function	get the ||| get	count=2
return	the memory ||| io foreignptr storable	count=1
function	a file ||| binary file	count=1
function	function computes the sum ||| sum	count=2
module	be ||| ghc exts	count=2
return	retagging and merging ||| b b' either c c'	count=1
args	value typically the ||| a	count=1
function	splitat n xs returns ||| split at	count=1
args	witharray but a ||| storable $list$ storable $f_2$ ptr storable io b	count=1
return	a handle ||| handle	count=2
return	observe the ||| $list$ typerep	count=2
return	similar to ||| hprintftype	count=1
return	of the memory ||| io foreignptr	count=2
args	close ||| close readp	count=1
module	of zero bits ||| data	count=2
function	t ever continue ||| indefinitely on	count=1
args	typeable allows ||| typeable	count=1
function	retrieve the system ||| system	count=1
module	in the ||| sync	count=1
module	corresponding ||| c	count=1
return	storable ||| io ptr storable	count=2
function	split ||| split poly ty con	count=1
module	of elements ||| data list	count=1
function	a file using openbinaryfile ||| file	count=1
args	signed realfloat value ||| int realfloat	count=5
module	and ||| data	count=8
args	elements ||| bool $list$ a	count=3
function	the numerator and ||| numerator	count=1
args	function returns ||| eq $list$	count=1
function	a file using openbinaryfile ||| with binary file	count=1
args	to a curried function ||| $f_2$ $tuple_2$ a b c a	count=1
args	of storable values ||| $f_2$ ptr storable io b	count=1
return	datatype ||| datatype	count=1
function_return	elements [return_2] ||| [function_1] pool int io [return_2]	count=2
module	[module_1] in ||| [module_1] [module_2]	count=4
return	lists and returns ||| $list$	count=2
args	either ||| c $f_2$ b c either a	count=1
function	to the corresponding haskell ||| to char	count=1
module	encoding [module_2] ||| [module_1] [module_2]	count=1
function	two independent buffers one ||| mk duplex handle	count=1
function	in the range 0 ||| int to digit	count=1
module	[module_1] of ||| [module_2] [module_1]	count=23
function	error indicating ||| error	count=1
module	yields the error code ||| c error	count=2
module	gc stats ||| ghc stats	count=1
return	which occur within a ||| a	count=1
module	lower ||| prelude	count=1
args	pointer living inside a ||| a	count=2
args	method showlist is ||| show	count=1
module	a c wide ||| c string	count=1
function	a prefix of the ||| prefix of	count=1
module	of the [module_2] ||| [module_1] [module_2]	count=5
args	promote a function to ||| a3 a4 a5 r monad a1 monad a2	count=1
module	types for text ||| ghc io encoding types	count=1
args	[args_1] [args_2] ||| monad lift m5 $f_6$ [args_1] [args_2]	count=3
args	elements of the list ||| bool $list$	count=1
function_return	[function_1] real value ||| [return_2] [function_1]	count=1
function	[function_1] exceptions ||| [function_2] [function_1]	count=1
module	for use in utf-16 ||| ghc io	count=1
args	the resulting handle ||| handle	count=1
args	number of ||| int timeoutcallback	count=1
module	of the first ||| data	count=1
function	data [function] ||| thread wait [function]	count=1
args	given pool ||| pool	count=1
return	the next character if ||| char	count=1
function	default ||| bit default	count=1
function_return	[function_1] [return_2] ||| [function_1] foreignptr a [return_2]	count=8
function	format string [function_2] ||| [function_2] [function_1]	count=2
return	size of the required ||| io	count=1
function	program attempts ||| nested	count=1
module	the c ||| c	count=10
args	the return value ||| a io	count=2
args	a block of ||| a	count=1
return	of mkweak where ||| $tuple_2$ weak k	count=1
return	from [return_2] ||| [return_2] [return_1]	count=2
function	[function_1] [function_2] ||| [function_2] get [function_1]	count=2
args	actions passing any value ||| a monad b	count=1
module	allocated ||| foreign marshal	count=1
return	monad ||| monad	count=1
module	involved in the ||| io	count=1
args	function takes a ||| bool $list$	count=1
module	of unrecognized options and ||| system console	count=1
function_return	[function_1] [return_2] ||| [function_1] io [return_2]	count=2
args	a complex number and ||| complex realfloat	count=1
function	findindex ||| find	count=1
module	the environment of ||| environment	count=1
module	is an unsigned integral ||| ghc exts	count=1
function	bound [function_2] ||| [function_2] [function_1]	count=1
function_return	[function_1] [return_2] ||| [function_1] a [return_2]	count=6
args	conversion scheme ||| textencoder estate	count=1
function	hgetbufnonblocking hdl ||| non blocking	count=2
args	structure but with strict ||| foldable	count=1
args	given number ||| int	count=5
args	list satisfy the predicate ||| $f_2$	count=1
return	the monadic arguments from ||| monad	count=1
module	was made to ||| exception base	count=1
function	[function_1] the current ||| [function_2] [function_1]	count=1
module	[module_1] [module_2] ||| [module_2] [module_1]	count=241
function	shift ||| shift	count=5
function	stack trace to the ||| with stack trace	count=1
function	[function] comparison ||| minimum [function]	count=3
module	list of unrecognized options ||| system console	count=1
module	suffix of ||| data list	count=1
function	is like catch ||| catch	count=1
function	hdl ||| h get	count=4
function	radix ||| float radix	count=2
args	the return value from ||| io a	count=2
return	number of the ||| int	count=3
function	lower limits of a ||| bound	count=1
args	list of non-options ||| argorder a $list$	count=1
args	function ||| $f_2$ $tuple_2$ a b	count=1
return	the rest unchanged ||| d c d	count=1
function_return	to represent [return_2] ||| [return_2] [function_1]	count=6
args	[args_1] the structure ||| [args_2] [args_1]	count=1
module	where the operation ||| system io	count=5
return	to the ||| io ptr storable	count=1
return	of item ||| $list$ item	count=1
function	written to the given ||| write	count=2
return	copy the rest unchanged ||| d	count=1
return	a string ||| string	count=7
args	number of ||| int $f_2$	count=1
args	value ||| a io b	count=2
module	with ||| marshal pool	count=1
function	input can [function] ||| [function] is	count=1
return	within a computation and ||| a	count=1
function	run ||| run in bound thread	count=2
function	fresh memory ||| pool	count=1
return	p optionally parses p ||| readp	count=1
function	separated [function] sep ||| [function]	count=1
return	functor ||| functor b	count=2
function	the argument right by ||| r	count=1
function	advances the given address ||| plus ptr	count=1
module	advances ||| foreign ptr	count=1
args	like witharray but ||| $f_2$ ptr storable io b	count=1
function	throw that can ||| throw	count=2
args	with a pure ||| $f_2$ c d	count=1
function	other ||| other	count=2
function	shift ||| i shift	count=1
function	passed as the first ||| unbound thread	count=1
function	asynchronous exceptions masked ||| mvar masked	count=1
args	list of storable ||| $f_2$ ptr storable io b	count=1
return	the argument arrow and ||| arrow $tuple_3$	count=1
function	[function_1] binary ||| [function_2] [function_1]	count=6
module	[module_1] the machine ||| [module_1] [module_2]	count=1
return	through the argument arrow ||| arrow $tuple_3$ b	count=1
args	a returned value ||| someexception a	count=1
return	of the current process ||| io	count=1
module	error code ||| foreign c error	count=2
function	is already being ||| already	count=1
args	the given number of ||| int $f_2$ ptr storable	count=1
function	the first [function] ||| [function] firsts	count=2
module	current ||| io encoding	count=1
return	function reads ||| reads	count=1
module	argument types of a ||| data typeable internal	count=1
function_return	[function_1] storable ||| [function_1] pool int io [return_2]	count=2
args	and passes [args_2] ||| [args_1] iomode $f_2$ [args_2]	count=2
function	filter applied to ||| filter	count=1
function	a fresh ||| pool	count=1
function	close a ||| close fd	count=1
args	scanning ||| a2 monad a3 monad a4	count=1
module	io operation failed ||| io	count=3
args	[args_1] and passes ||| [args_2] [args_1]	count=4
return	used to ||| $tuple_2$ buffer from buffer to	count=2
module	of foldl that ||| data list	count=1
return	a handle is created ||| handle	count=1
function	the system [function_2] ||| [function_2] [function_1]	count=2
return	for the end marker ||| io ptr storable	count=1
args	method showlist ||| show	count=1
function_args	suspends [function_1] [args_2] ||| ghc conc [function_1] delay [args_2]	count=5
function	type representation ||| type rep	count=6
return	any monadplus ||| monadplus a	count=1
module	[module_1] list ||| [module_1] [module_2] delete	count=2
args	the either type ||| b c either a b	count=1
return	weak pointer to a ||| io weak	count=1
args	two ||| eq	count=2
return	functor class is ||| functor	count=2
module	a ||| foreign	count=2
return	merging their ||| b' either	count=1
args	maybe value ||| b $f_2$ a b maybe	count=1
function	[function_1] exists ||| [function_2] [function_1]	count=4
module	the input to ||| control	count=1
function	parameter from right ||| r	count=1
function	managed by hdl blocking ||| h	count=2
args	is an unsigned ||| word#	count=1
args	is a ||| a b	count=1
return	bytes into the buffer ||| io $tuple_2$ int buffer word8	count=1
function_args	[function_1] given number ||| [function_1] malloc array0 pool [args_2]	count=1
function	shift the ||| unsafe shift	count=1
function	retry execution ||| retry	count=1
function	wait for data ||| wait	count=1
return	breaks a string ||| $list$ string	count=1
function	have getargs return args ||| with args	count=1
args	function takes a predicate ||| a bool $list$	count=1
function	test whether ||| null	count=2
return	provided that traverse ||| traversable b	count=1
module	open ||| system io	count=1
args	equality predicate ||| a bool $list$	count=1
function_args	[function_1] number of ||| [args_2] [function_1]	count=7
return	io errors which occur ||| io either ioerror	count=1
return	monadic arguments from left ||| monad	count=1
module	the [module_2] ||| [module_2] [module_1]	count=2
function	zip4 ||| zip4	count=1
args	with ||| $f_2$ b	count=1
args	the pool ||| pool	count=3
return	complex value ||| complex floating	count=1
function_return	to an [return_2] ||| [return_2] [function_1]	count=1
module	[module] xs ||| data [module]	count=2
args	structure but with ||| foldable	count=1
function	map which can throw ||| map maybe	count=1
args	argument is executed ||| mvar a $f_2$ a	count=1
function	is an ||| w#	count=1
function_args	[function_1] using ||| [function_1] filepath iomode [args_2]	count=4
args	monad scanning the ||| a2 monad a3 monad a4 monad	count=1
function_args	hdl into [args_2] ||| [function_1] buf handle [args_2]	count=1
args	the ||| bits	count=1
function	function extracts a list ||| list	count=1
module	an io operation failed ||| io	count=3
module	of foldl that has ||| data list	count=1
function	to the corresponding ||| cast cuchar to	count=1
args	return value ||| a io	count=2
args	storable ||| storable $f_2$ ptr storable io	count=1
args	string ie character array ||| string	count=1
module	a ||| foreign marshal	count=1
function	of the list by ||| by	count=1
module	operation yields the error ||| c error	count=1
args	as argument a pointer ||| storable $f_2$ ptr storable io	count=1
return	parses the first ||| readp	count=2
args	the format ||| fieldformat	count=1
return	but returns ||| a $list$ string $list$ string $list$	count=1
args	pool which gets ||| $f_2$ pool	count=1
function	can t ever continue ||| indefinitely on	count=1
function	delete ||| delete by	count=2
return	computation ||| s	count=4
function	but additionally if ||| throw errno if	count=1
module	prelude a ||| prelude	count=1
args	with explicit length ||| textencoding cstringlen	count=1
module	operation use control ||| control	count=1
function	[function_1] [function_2] on both input and ||| [function_1] [function_2]	count=2
return	returns a tuple where ||| $tuple_2$ $list$ a $list$ a	count=1
function	buffering [function_2] ||| [function_2] get [function_1]	count=1
function_args	[function_1] [args_2] ||| [function_1] put str [args_2]	count=9
args	the either type ||| c $f_2$ b c either	count=1
args	[args] the ||| [args]	count=2
function	wait for [function_2] ||| [function_1] [function_2]	count=1
args	bits in ||| bits	count=2
return	the buffer blocking ||| io $tuple_2$ int buffer	count=1
return	to its representation ||| rep generic x	count=1
args	same as x ||| bits int	count=1
function	to printf ||| h printf	count=1
function	to the finalizer ||| ptr finalizer	count=2
module	the list of ||| data list	count=1
return	the current [return_2] ||| [return_1] [return_2]	count=2
return	formatter for ||| fieldformatter	count=1
function	a new ||| new	count=5
return	into a ||| io foreignptr a	count=1
function	unsigned integral ||| w#	count=1
module	accents and the ||| data char	count=1
args	value ||| a applicative b	count=2
function	to printf except that ||| h printf	count=1
args	a binary function ||| a b c applicative a applicative b	count=1
args	character ch to the ||| char	count=1
function	a haskell character to ||| to	count=3
args	on stablename that ||| stablename a stablename b	count=1
function	used to name the ||| min	count=1
return	the threadid of the ||| io threadid	count=3
module	[module_1] io operation ||| [module_1] [module_2]	count=1
return	but returns ||| $list$ string $list$	count=1
args	promote a function to ||| a2 a3 a4 a5 r monad a1	count=1
args	for ||| $f_2$ a	count=1
return	[return_1] value ||| [return_1] mvar [return_2]	count=1
module	where the operation ||| io	count=5
return	[return_1] read instance ||| [return_2] [return_1]	count=1
function_return	action hsetencoding hdl encoding [function_1] [return_2] ||| [function_1] encoding handle textencoding [return_2]	count=3
return	[return] in ||| io [return]	count=2
return	storable type ||| storable	count=4
args	a ||| a monad b traversable a	count=2
function	[function] or ||| [function] bad	count=1
args	contain the file handle ||| string maybe handle maybe	count=1
module	arrow passing the ||| arrow	count=1
return	state transformer [return_2] ||| [return_1] [return_2]	count=16
return	rest unchanged to ||| $tuple_3$ b d c d	count=1
args	given a ||| a	count=1
function	threadid [function] ||| [function]	count=2
module	object ||| mem weak	count=2
return	didn t ||| $tuple_3$ $list$	count=1
module	string into a c ||| c	count=4
module	a [module] of ||| data [module]	count=1
function	upper and lower ||| min	count=1
args	a ||| $tuple_2$ a b	count=1
args	given number ||| int $f_2$ ptr storable io b	count=1
module	an mvar put a ||| control concurrent mvar	count=1
return	returns the [return_2] ||| [return_2] [return_1]	count=12
return	and a list and ||| a	count=1
module	the prelude a ||| prelude	count=1
module	c string into a ||| foreign c string	count=1
module	exceptions ||| control exception	count=2
function_return	the given [return_2] ||| [return_2] [function_1]	count=2
args	where ||| ioerrortype string	count=1
args	the given number of ||| int $f_2$ ptr storable io	count=1
function	from the supplied write ||| write buffer0	count=1
function_return	[function_1] [return_2] ||| [function_1] readp [return_2]	count=3
module	[module_1] exception ||| [module_1] [module_2]	count=23
function	[function_1] trace to ||| [function_1] [function_2]	count=4
return	computation hwaitforinput hdl ||| io bool	count=2
function	full precision ||| float	count=1
args	the either ||| c either a	count=1
args	to non-empty ||| $f_3$ a a a foldable a	count=1
function	module where the ||| module	count=1
module	that the machine has ||| ghc conc	count=1
return	weak pointer to a ||| weak	count=1
args	structure is empty ||| foldable a	count=2
return	hgetbuffering hdl returns ||| buffermode	count=2
return	instance of chan ||| chan	count=1
module	exception is raised during ||| exception base	count=1
function	shift the argument ||| shift l	count=1
function	throw an error when ||| error	count=1
module	c string into a ||| c	count=1
function	its arguments flipped ||| for m	count=2
return	the end marker ||| io ptr storable	count=1
function	encoding [function_2] ||| [function_2] locale [function_1]	count=1
function	usererror if the ||| if	count=1
function	current thread s stack ||| stack	count=2
args	promote a function ||| a5 r monad a1 monad a2 monad	count=1
args	b is true and ||| bool	count=1
args	definition of the static ||| staticptrinfo	count=1
function	to handle the sign ||| sign	count=1
module	standard output ||| system	count=1
args	handle and file ||| string maybe handle	count=1
args	string str ||| string	count=1
return	true ||| bool	count=5
return	the monadic ||| monad r	count=1
return	[return_1] threadid ||| [return_1] [return_2]	count=1
args	action ||| $f_2$ a	count=1
module	copies the ||| marshal utils	count=1
return	foreignptr ||| foreignptr	count=2
function	maps ||| map exception	count=2
function	the supplied write ||| write	count=2
module	allocate ||| foreign marshal	count=1
function	the position of ||| seek	count=3
args	gets the number of ||| int	count=1
module	with the ||| ghc	count=1
function	left = leftapp ||| left app	count=1
return	someexception ||| someexception	count=1
args	describes [args_2] ||| [args_2] [args_1]	count=1
return	a magnitude phase pair ||| $tuple_2$ realfloat realfloat	count=1
args	is the ||| bits int	count=1
args	with a pure ||| $f_2$ c	count=1
module	argument ||| control	count=1
module	a ||| ghc	count=3
args	and always ||| readp a	count=1
function	prefix ||| prefix	count=2
function	is the same as ||| set bit	count=1
args	executed ||| mvar a	count=1
function	invalid or unrepresentable ||| invalid	count=1
function_return	[function_1] [return_2] from the structure l ||| [function_1] islist [return_2] islist	count=4
args	non-options a list ||| argorder a $list$ optdescr a $list$	count=1
function	returns the current i/o ||| get	count=2
module	[module_1] arrow passing ||| [module_1] [module_2]	count=4
module	with ||| ghc foreign	count=1
args	value produced by ||| monad a monad b	count=1
function	api kept [function] avoid breaking ||| [function]	count=1
module	representation of ||| data char	count=2
module	of a structure ||| data traversable	count=1
args	a reverse application operator ||| $f_2$ a	count=1
return	permutations function returns ||| $list$ $list$ a	count=1
function_args	[function_1] number ||| ghc conc [function_1] delay [args_2]	count=3
args	a list of storable ||| $f_2$ ptr storable io	count=1
return	to the given ||| io	count=2
args	number of bytes ||| gcstats	count=1
module	like mallocarray but add ||| foreign marshal array	count=1
function	reduced form the numerator ||| numerator	count=1
function_args	show for [args_2] ||| [function_1] [args_2]	count=1
function	handle [function] ||| [function] buf non	count=2
args	in the pool ||| pool ptr	count=2
return	the io computation passed ||| io a	count=1
function	an allocation counter ||| allocation counter	count=1
args	scanning ||| a2 monad a3 monad a4 monad a5	count=1
module	because the ||| system io	count=2
module	encode ||| io encoding	count=1
function_args	written [args_2] ||| [function_1] [args_2]	count=3
function	wide character array ||| new cwstring	count=1
args	structure but ||| b foldable	count=1
function	on ||| on	count=8
module	right and ||| data foldable	count=1
args	true ||| bool	count=6
args	promote a function ||| a2 a3 a4 a5 r monad a1 monad	count=1
return	the functor class ||| functor	count=2
module	in [module_2] ||| [module_1] [module_2]	count=1
return	a tuple where first ||| $list$ a	count=1
function	the stable ||| stable	count=1
module	a fresh memory ||| marshal pool	count=1
module	handle ||| control exception base	count=1
return	number of the capability ||| $tuple_2$ int	count=3
args	for ||| $f_2$ a bool	count=1
function	copied areas may overlap ||| move	count=1
return	number of ||| io int	count=5
return	instance provided that traverse ||| traversable	count=1
return	stablename ||| stablename	count=1
module	hdl is set to ||| io handle	count=3
args	monad scanning ||| a3 monad a4 monad a5	count=1
function	list ||| list with	count=2
return	textencoding is a specification ||| textencoding	count=1
args	of storable values in ||| ptr storable io b	count=1
function_return	class [return_2] ||| [return_2] [function_1]	count=1
args	value typically ||| $list$ a	count=1
function	show non-negative ||| show	count=1
args	in the pool to ||| pool ptr storable	count=1
function	system [function_2] ||| [function_1] [function_2]	count=2
function	scanl1 ||| scanl1	count=1
function	character to ||| cast char to cschar	count=1
function	phase ||| phase	count=1
function	product of the numbers ||| product	count=1
args	as six ||| f	count=1
args	of storable values ||| storable $f_2$ ptr storable io b	count=1
return	but returns [return_2] ||| [return_1] [return_2]	count=7
return	retry [return] ||| [return]	count=3
args	type where the ||| ioerrortype string	count=1
return	rest unchanged to the ||| d c d	count=1
function	scanl1 is a variant ||| scanl1	count=1
module	suffix of xs after ||| data	count=1
args	string s to ||| string	count=2
return	haskell value ||| a	count=1
function	if ||| if	count=5
args	a ||| c d e $list$ a	count=1
args	the [args] file ||| filepath [args]	count=1
args	value typically ||| a b b b $list$ a	count=1
function_return	uninterruptiblemask [return_2] ||| [return_2] [function_1]	count=6
return	returns a quadruple ||| $list$ string	count=1
return	the io computation passed ||| io	count=1
function	[function_1] newline ||| [function_1] [function_2]	count=1
module	element of ||| data	count=4
return	this is thrown when ||| errorcall	count=2
function	written to ||| write stm	count=3
args	string ie ||| textencoding string $f_2$	count=1
return	returns a ||| io chan a	count=1
function	[function_1] hdl s ||| [function_2] [function_1]	count=4
function	current i/o position ||| get	count=2
args	value ||| io a io b io c	count=2
function_args	hdl into [args_2] ||| [args_2] [function_1]	count=1
args	into a nul terminated ||| $f_2$ cstring	count=1
function	of -1 ||| minus1	count=1
function	hdl s writes ||| h	count=2
function	[function_1] storage in ||| [function_2] [function_1]	count=2
args	either type ||| either	count=1
return	parses ||| readp string	count=2
module	of hdl is ||| io handle	count=3
function_args	[function_1] integral ||| [args_2] [function_1]	count=6
return	bytes into the buffer ||| $tuple_2$ int buffer word8	count=1
function	ie character array in ||| len	count=2
function	extracts a list ||| list	count=1
function	of div ||| div'	count=1
function	hputchar hdl ch writes ||| h put	count=1
function	hputstr ||| put str	count=4
function	haskell symbol ||| symbol	count=2
module	error ||| foreign c error	count=4
args	witharray but a ||| $f_2$ ptr storable io	count=1
module	an mvar put a ||| control concurrent	count=1
function	line from the ||| get line	count=1
return	quadruples ||| $tuple_4$	count=2
function_return	a duplicate [return_2] ||| [function_1] handle [return_2]	count=1
function	bound threads ||| bound threads	count=2
module	applied ||| oldlist	count=1
function	has an allocation counter ||| set allocation counter	count=1
function	sum ||| sum	count=2
args	copy the given ||| ptr storable	count=1
return	of newforeignptr adds a ||| a	count=1
args	of bytes without ||| word8 int	count=1
function	stable pointer ||| free stable ptr	count=1
function_return	terminated by [return_2] ||| [function_1] storable/eq ptr storable/eq [return_2]	count=1
function	a duplicate of the ||| h duplicate to	count=1
args	additional parameter ||| $f_3$	count=1
return	monadic ||| monad r	count=1
function_return	[function_1] [return_2] ||| [function_1] typerep [return_2]	count=12
return	the current ||| io	count=2
module	encoding may now be ||| encoding	count=2
return	the functor class is ||| functor	count=2
args	memory pool which ||| $f_2$ pool io	count=1
function	stack [function_2] ||| [function_1] [function_2]	count=3
module	an internal function to ||| typeable internal	count=1
args	stablename that does ||| a stablename b	count=1
args	string s to the ||| handle string	count=2
module	was an ||| control exception base	count=1
module	internal function ||| internal	count=1
return	used to continue decoding ||| buffer to	count=2
args	boolean ||| bool	count=1
return	buffer to the beginning ||| buffer word8	count=1
function	to the corresponding haskell ||| cschar to	count=1
module	c byte representing a ||| c	count=1
function	substitute a v ||| v	count=1
args	the either ||| $f_2$ b c either a b	count=1
function	the unzip7 function takes ||| unzip7	count=1
return	io errors ||| io either	count=1
return	merging their outputs ||| arrowchoice either b b' either c c'	count=1
function_return	[function_1] [return_2] ||| [function_1] rational [return_2]	count=4
return	returns a ||| $list$ a	count=1
return	those that didn t ||| $tuple_3$ $list$	count=1
function_args	[function_1] the ||| [function_1] buf handle [args_2]	count=1
function	managed by hdl blocking ||| h get char	count=2
function	in ||| bit size	count=1
args	a structure ||| foldable	count=2
args	the return value from ||| a io b	count=2
function	disable allocation [function_2] ||| [function_2] [function_1]	count=2
module	allocate a fresh ||| foreign marshal	count=1
args	value from ||| io a	count=2
args	for ||| $f_2$ a bool string	count=1
function	to run [function_2] ||| [function_1] [function_2]	count=1
function	returns the index ||| index	count=1
function_args	[function_1] signed ||| [function_1] ffloat maybe [args_2]	count=1
module	map ||| ghc oldlist	count=2
function	the range 0 ||| to digit	count=1
function_args	[function_1] signed ||| [args_2] [function_1]	count=3
module	size as ||| exts	count=1
args	promote a function to ||| a1 monad a2	count=2
module	a value [module_2] ||| [module_1] [module_2]	count=1
return	the memory area ||| io foreignptr storable	count=1
function	the function coerce allows ||| coerce	count=1
args	the mapmaybe function ||| maybe b $list$	count=1
args	to a curried ||| c a	count=1
args	open followed ||| readp open readp	count=1
args	factor ||| integral integral	count=1
module	[module] described ||| [module]	count=1
args	function takes a ||| bool $list$ a	count=1
function	basic concurrency stuff ||| ensure iomanager is running	count=1
args	number within ||| realfrac	count=1
args	equality predicate instead ||| a bool	count=1
module	that can only be ||| conc	count=1
args	copy [args_1] [args_2] ||| marshal array copy array [args_1] [args_2]	count=4
args	user-supplied equality predicate instead ||| a bool	count=1
module	a fresh memory ||| foreign marshal	count=1
args	living inside a ||| ptr a io	count=2
args	for input [args] ||| [args]	count=1
args	to an ||| a	count=1
function	the traceeventio ||| event io	count=1
args	[args_1] but ||| [args_1] [args_2]	count=2
module	of a ||| data foldable	count=1
return	and return nothing ||| maybe a	count=1
args	actions passing any value ||| a	count=1
function	resize ||| realloc	count=2
args	a pointer to a ||| $f_2$ ptr storable io	count=2
module	the traceio function ||| debug	count=1
function	current [function_2] ||| [function_1] [function_2]	count=5
function	prefix [function_2] ||| [function_1] [function_2]	count=3
return	thread is waiting to ||| blockedindefinitelyonstm	count=1
function	is a terminal ||| is terminal	count=3
args	to a monad scanning ||| monad a2 monad a3 monad a4 monad	count=1
return	a user-supplied ||| $list$ a	count=1
function	list [function] and returns ||| cat [function]	count=1
module	c ||| c	count=28
return	buffer without ||| $tuple_2$ maybe int buffer word8	count=1
function	hash [function_2] ||| [function_2] [function_1]	count=2
function	the first component ||| first	count=1
args	as argument a pointer ||| ptr storable io b	count=2
function	to zipwith ||| zip	count=2
function_return	[function_1] storable ||| [return_2] [function_1]	count=3
args	string s ||| string	count=2
module	block of ||| alloc	count=1
return	the end marker ||| io ptr	count=1
args	an unsigned integral ||| word#	count=1
function	a foreign pointer ||| new foreign ptr	count=1
args	c string ie character ||| string	count=1
module	is ||| data maybe	count=1
function	given ||| ptr	count=6
function	duplicate ||| h duplicate	count=2
return	[return_1] [return_2] ||| [return_1] [return_2]	count=433
module	the ||| data	count=6
args	returned value ||| someexception a	count=1
function	of storage ||| pooled	count=1
return	boolean indicating whether the ||| io	count=1
function	throw that can ||| throw io	count=2
args	function takes ||| a bool $list$ a	count=1
module	accents and the ||| data	count=1
args	monad scanning the ||| a4 monad a5	count=1
function_args	[function_1] static ||| [args_2] [function_1]	count=3
function	an allocation ||| allocation	count=1
function	but only performs the ||| on error	count=1
function	fresh ||| new pool	count=2
function	but appends a stack ||| stack	count=1
module	marshal these values into ||| foreign marshal	count=1
args	an ||| a	count=1
args	stablename ||| stablename a stablename	count=1
args	a returned value ||| $f_2$ either someexception a	count=1
args	of storable values ||| storable $f_2$ ptr storable io	count=1
args	a non-negative integral ||| integral	count=1
return	in [return] ||| [return]	count=2
module	process the command-line ||| system console getopt	count=2
args	a ||| $tuple_2$ b c $list$ a	count=1
function_return	terminated [return_2] ||| [return_2] [function_1]	count=1
args	pool ||| $f_2$ pool io	count=1
args	argument a pointer ||| ptr storable	count=2
return	memory pool ||| pool	count=1
return	value ||| ptr a	count=2
function	position ||| seek	count=5
return	obtain the haskell value ||| io a	count=1
args	a complex number and ||| complex	count=1
return	maybetolist function returns ||| $list$	count=1
function	privilege ||| is permission	count=2
args	value from the ||| io a io	count=2
return	of the [return_2] ||| [return_1] [return_2]	count=4
args	which is an exception ||| exception maybe	count=1
return	pair ||| $tuple_2$ $list$ b	count=1
function	allocated | cpu ||| allocated	count=1
module	an error [module_2] ||| [module_2] [module_1]	count=1
return	sequence of io actions ||| io	count=2
function	not exist ||| not exist	count=2
return	a list of ||| io $list$ statickey	count=1
function	zip4 function ||| zip4	count=1
args	the pool but ||| pool	count=1
return	returned by the io ||| io a	count=1
function	a given file ||| file	count=1
module	internal function to make ||| internal	count=1
args	into a c string ||| string	count=1
args	[args_1] list is ||| [args_2] [args_1]	count=2
module	foldr1 ||| ghc oldlist	count=1
function	its arguments flipped ||| for	count=3
module	version of !!, ||| data list	count=1
args	[args] bits ||| bits [args]	count=3
args	stablename that does not ||| stablename a stablename b	count=1
function	begins empty but data ||| dup	count=1
module	find ||| ghc oldlist	count=1
return	seven [return_1] [return_2] ||| [return_1] [return_2]	count=1
args	executed with ||| mvar	count=1
function_return	the tolist [function_1] [return_2] l from the structure ||| [function_1] islist [return_2] islist	count=1
function	to mallocarray0 but yields ||| ptr array0	count=1
function	to name the upper ||| bound	count=1
return	phase pair ||| $tuple_2$ realfloat realfloat	count=1
module	the operation ||| io error	count=5
args	openfile file mode allocates ||| filepath iomode	count=2
module	an ||| prelude	count=2
function	right to left and ||| r	count=1
return	arrow ||| arrow $tuple_3$ b d	count=1
return	[return_1] memory required ||| [return_2] [return_1]	count=4
function	taken from hdl ||| h	count=1
return	allocate consecutive ||| ptr storable	count=1
module	wait ||| concurrent qsemn	count=1
function	variant of throw ||| throw	count=2
return	representational equality ||| coercion	count=1
args	a reverse ||| a $f_2$ a b	count=1
return	is used to continue ||| buffer to	count=2
module	overloaded version of !!, ||| data list	count=1
function	wide character array with ||| new cwstring	count=1
return	the sum of a ||| a	count=1
args	a fresh memory pool ||| pool io	count=1
function	thread has an allocation ||| set allocation	count=1
module	the results of a ||| data	count=1
return	occur within a ||| either ioerror a	count=1
return	and returns [return_2] ||| [return_2] [return_1]	count=1
args	the same as x ||| bits int	count=1
args	inside a ||| a $f_2$ ptr a io b	count=2
return	computation hwaitforinput ||| io	count=2
return	of lists ||| $list$ a $list$	count=1
args	promote a function to ||| a4 r monad a1	count=1
return	the buffer blocking ||| int buffer	count=1
function	used to ||| min	count=1
module	recover ||| io encoding	count=1
return	the current [return_2] ||| [return_2] [return_1]	count=2
module	a valid memory location ||| foreign	count=1
function	reads a line from ||| line	count=1
function	a prefix [function_2] ||| [function_1] [function_2]	count=3
function_args	[function_1] string s ||| [function_1] [args_2]	count=1
return	into the buffer blocking ||| io $tuple_2$ int buffer	count=1
return	a storable type ||| storable	count=3
function	map each element ||| map m	count=2
return	[return] no ||| io [return]	count=2
args	analysis for the either ||| c $f_2$ b c either a b	count=1
return	specified number of ||| io int	count=1
return	to the specified number ||| io int	count=1
module	the types defined by ||| types	count=1
args	for the either type ||| c either a	count=1
return	[return] of ||| reads [return]	count=1
module	the same ||| data	count=1
module	occurrence of ||| data	count=1
function_args	lift [args_2] ||| [function_1] [args_2]	count=4
function	the char type ||| mk char type	count=2
return	number of the capability ||| $tuple_2$ int bool	count=3
function	pure instance of show ||| h show	count=2
rep	[module_1] representation of ||| [module_1] alg [function_args_2]	count=1
function	of show for ||| h show	count=1
module	number in decimal notation ||| numeric	count=1
function	string [function_1] [function_2] information ||| [function_2] [function_1]	count=2
return	a circular one ||| a	count=1
return	copy the rest unchanged ||| d c d	count=1
function	of ||| min	count=1
args	representation ||| rep	count=1
return	the size ||| io ptr storable	count=1
function_args	[function_1] of ||| [function_1] [args_2]	count=2
function	is already being used ||| already	count=1
module	memory ||| foreign marshal	count=1
module	the [module_2] ||| [module_1] [module_2]	count=31
function_args	the exception [args_2] ||| [args_2] [function_1]	count=1
args	conditionally prove the ||| testcoercion a testcoercion b	count=1
function	a terminal or ||| terminal	count=1
args	argument a pointer to ||| ptr storable io b	count=2
args	for the either ||| b c either	count=1
args	[args_1] [args_2] ||| [args_1] iomode $f_2$ [args_2]	count=7
function_args	hdl s [args_2] ||| [function_1] put str [args_2]	count=2
args	non-empty structure ||| foldable	count=2
return	elements satisfying the ||| $list$	count=1
args	non-options a list of ||| argorder a $list$	count=1
function	register a ||| register	count=1
args	as a value ||| traversable a	count=1
return	the rest through unchanged ||| d either c d	count=1
args	lifetime ||| event lifetime	count=2
args	a nul terminated c ||| $f_2$ cstring io a	count=1
return	io monad ||| io	count=1
args	for the either ||| $f_2$ b c either a	count=1
module	modified ||| control concurrent mvar	count=1
return	intptr ||| intptr	count=1
module	[module] to ||| [module]	count=3
function	the thread ||| thread	count=10
return	to [return_1] [return_2] ||| [return_1] [return_2]	count=8
function	left ||| left app	count=2
function	a line from the ||| line	count=1
args	a structure to a ||| a monad b foldable a	count=2
function_args	pair of [args_2] ||| [function_1] [args_2]	count=1
return	is traverse with its ||| applicative traversable b	count=1
module	has ||| ghc conc	count=1
function	to read on ||| read	count=1
function	is ||| bound	count=1
module	proxy type ||| proxy	count=1
module	a c ||| c	count=7
args	string as its ||| $f_2$ string string	count=1
args	is the same as ||| bits int	count=1
args	of storable values in ||| $f_2$ ptr storable	count=1
function	extracts a list of ||| to list	count=1
return	a circular one or ||| $list$ a	count=1
args	class typeable allows ||| typeable	count=1
args	a monad scanning the ||| a4	count=1
module	this operation use control ||| control concurrent	count=1
function	alphabetic ||| alpha num	count=1
function_args	[function_1] realfloat value ||| [function_1] float [args_2]	count=1
return	a list and returns ||| a	count=1
module	version of !!, which ||| data	count=1
function	performs ||| on error	count=2
args	a reverse ||| a	count=1
args	returned ||| $f_2$ a	count=1
return	bounded class ||| bounded	count=1
function	association between the stable ||| free stable	count=1
function	[function_1] already ||| [function_1] [function_2] in use	count=1
function	between ||| between	count=1
function	wait for data to ||| thread wait	count=1
module	a list ||| list	count=6
function	current number of ||| current	count=2
module	strict application of the ||| data foldable	count=1
function	[function_1] exist ||| [function_2] [function_1]	count=3
module	modified ||| io error	count=1
function	[function_1] allocated | ||| [function_1] [function_2]	count=4
module	io library portions copyright ||| io	count=3
function_return	terminated by [return_2] ||| [return_2] [function_1]	count=1
module	was an ||| base	count=1
args	a binary function ||| a	count=1
function_return	[function_1] number ||| [function_1] leading zeros finitebits [return_2]	count=1
args	the string ||| string	count=1
return	the fixity of ||| fixity	count=1
function	exponent corresponds to ||| exponent	count=1
args	either type ||| c $f_2$ b c either a b	count=1
module	mallocarray but allocated ||| marshal array	count=1
return	the type char ||| char	count=1
function_return	offset i ||| relative seek seekmode	count=1
function	its arguments already ||| already	count=2
function	index ||| constr index	count=1
return	of the buffer ||| buffer	count=1
args	using ||| integral/show $f_2$	count=1
module	&amp ||| data function	count=1
args	for the either type ||| c $f_2$ b c either	count=1
module	in numeric representation ||| marshal utils	count=2
function	by ||| by	count=3
return	write the list ||| io	count=1
return	returns the number ||| int bool	count=3
function	caseless scripts ||| is alpha	count=1
function	can t ever continue ||| blocked indefinitely on	count=1
function	set ||| h set newline	count=1
module	[module_1] of strings ||| [module_2] [module_1]	count=4
args	a pointer to a ||| storable $f_2$ ptr	count=1
args	promote a function to ||| r monad a1 monad a2 monad a3	count=2
args	number ||| gcstats	count=1
args	analysis for the either ||| a c $f_2$ b c either a	count=1
module	convert an array ||| foreign marshal array	count=1
function	hdl or ||| h	count=1
args	a ||| f g $list$ a $list$	count=1
function_return	[function_1] i from ||| [function_1] [return_2]	count=7
args	but with the arguments ||| $f_2$ a monad b	count=1
args	monad scanning ||| a4 monad	count=1
return	as an int ||| int	count=1
module	any instance of ||| data	count=1
return	complex ||| complex	count=1
return	value of the ||| io maybe string	count=1
function	fmap in a functor ||| fmap	count=1
args	and always returns () ||| a	count=1
return	number of the ||| io $tuple_2$ int bool	count=2
module	element occur in the ||| data	count=1
module	an io ||| control monad	count=1
module	of the operator ||| data foldable	count=1
args	to a monad scanning ||| a2 monad a3 monad a4 monad a5	count=1
args	pool which gets ||| $f_2$ pool io b	count=1
function_args	[function_1] [args_2] ||| [function_1] malloc array0 pool [args_2]	count=9
return	on the contents ||| io	count=1
return	pair in canonical form ||| $tuple_2$ realfloat	count=1
function	duplicate of the original ||| duplicate	count=1
args	a binary ||| b c applicative a applicative b	count=1
module	order of ||| data	count=1
args	given number of microseconds ||| int	count=1
args	of datatypes ||| $list$ constr	count=1
function	[function_1] [function_2] the ||| [function_2] [function_1]	count=4
function	shift the argument right ||| shift	count=1
return	at the pointer ||| io b	count=2
args	action in the structure ||| foldable applicative a	count=1
function_return	to [return_2] ||| [function_1] ptr ptr a [return_2]	count=1
return	the argument arrow ||| arrow $tuple_3$	count=1
module	is the same ||| data bits	count=1
module	control ||| control concurrent chan	count=2
module	fresh ||| pool	count=1
module	to any instance of ||| data fixed	count=1
function	the size of ||| size	count=1
args	format ||| fieldformat	count=1
function	of hdl ||| h	count=2
function	allow the result ||| fix	count=3
function	lower limits ||| min	count=1
function	terminated by ||| peek array0	count=1
args	a ||| a a a $list$ a	count=1
module	of elements to ||| data list	count=1
return	[return] in ||| [return]	count=2
args	equality predicate ||| a a bool $list$ a	count=1
args	witharray but ||| storable $f_2$ ptr storable io b	count=1
args	the ||| $f_2$ a io a	count=1
args	of storable ||| storable $f_2$ ptr storable io b	count=1
module	program ||| system io	count=2
module	communications channel results in ||| ghc io	count=1
function	an action with ||| with	count=1
args	storable values in ||| ptr storable io	count=1
return	a weak pointer ||| weak	count=1
module	hdl ||| io handle	count=9
args	elements of ||| a bool $list$ a	count=1
args	nul terminated ||| cstring	count=1
module	output ||| io handle	count=1
function	throw that can only ||| throw	count=2
function	current number [function_2] ||| [function_1] [function_2]	count=1
return	io monad ||| io string	count=1
args	actions passing any value ||| a $f_2$ a monad b	count=1
function	error where the ||| error	count=4
function	as throwerrnoif but ||| throw errno if	count=1
return	returns [return_2] ||| [return_2] [return_1]	count=7
args	[args_1] [args_2] ||| [args_2] monad [args_1]	count=3
function	begins empty but ||| dup	count=1
function	unset name removes ||| unset env	count=1
return	a ||| a b c d e	count=2
function	int ||| mk int	count=1
function	filled with bytes of ||| calloc array	count=1
args	there are no bytes ||| bufferedio buffer	count=1
function	takemvar ||| try take	count=1
module	to a foreign function ||| foreign	count=1
args	is a reverse ||| $f_2$ a b	count=1
function	to the ||| cschar to	count=1
args	as argument a pointer ||| storable $f_2$ ptr storable io b	count=1
function	a line from ||| get line	count=1
args	resulting handle ||| handle io r	count=1
return	constructor application ||| $tuple_2$ tycon $list$	count=2
return	predicate and a list ||| a	count=1
return	return a string describing ||| string	count=1
module	the number of elements ||| data list	count=1
args	function takes ||| bool $list$ a	count=1
args	passing any value produced ||| $f_2$ a	count=1
function	trace gc ||| trace gc	count=1
module	an ||| control concurrent mvar	count=2
function	program s heap is ||| heap overflow	count=2
function	traceevent or traceeventio ||| trace event	count=1
function_args	[function_1] memory pool ||| [args_2] [function_1]	count=2
function	current thread [function_2] ||| [function_2] [function_1]	count=11
args	type constructor to a ||| tycon	count=1
return	uses [return] ||| [return]	count=2
function	privilege to perform ||| is permission	count=2
function_return	[function_1] in arrow ||| [return_2] [function_1]	count=2
function	to the corresponding ||| cchar to	count=1
return	offset i ||| seekmode	count=2
module	[module] is ||| [module]	count=12
return	observe the ||| typerep	count=2
function	of the exception ||| exception	count=1
return	next character if ||| readp char	count=1
return	application ||| $list$ kindrep $list$ typerep	count=1
args	like addforeignptrfinalizerenv ||| a ptr env foreignptr	count=2
function	scanr1 is a variant ||| scanr1	count=1
args	handle and file path ||| handle maybe filepath	count=1
function_args	[function_1] [args_2] ||| bits [function_1] [args_2] bits	count=3
module	an unsigned integral type ||| exts	count=1
args	mapmaybe function ||| a maybe b	count=1
args	return value from the ||| io a io b io c	count=2
function	the modified ||| modify	count=1
function	operation is not possible ||| illegal operation	count=1
function	buffering ||| buffering	count=2
args	for the either ||| c $f_2$ b c either a	count=1
return	ex if an exception ||| exception	count=2
args	equality on stablename ||| stablename b	count=1
function	to represent the ||| left associative	count=1
function	return args ||| args	count=1
function	between the stable pointer ||| free stable ptr	count=1
function	name the ||| min bound	count=1
return	real value given a ||| real	count=1
function	[function_1] timeout in ||| [function_2] [function_1]	count=1
function	already being used for ||| already	count=1
module	environment ||| system environment	count=1
args	handle ||| handle ptr	count=2
function	heap is reaching its ||| heap overflow	count=2
module	optional ||| parsercombinators readp	count=1
module	may be ||| ghc exts	count=1
return	tycon object representing a ||| tycon	count=2
args	memory pool which gets ||| $f_2$ pool io b	count=1
return	may [return_2] ||| [return_2] [return_1]	count=1
module	that an exception is ||| control exception base	count=1
args	to non-empty lists ||| $list$	count=2
function	version of putmvar ||| try put	count=1
function	this accumulator together with ||| map accum	count=1
args	[args_1] number of ||| [args_1] a [args_2]	count=1
function	of the exception ||| some exception	count=1
args	promote a function to ||| monad a1	count=2
args	[args_1] maybe value ||| [args_2] [args_1]	count=2
function	the current [function] ||| [function]	count=2
function	result of -1 ||| minus1	count=1
function_return	[function_1] the datatype ||| [function_1] constr [return_2]	count=1
return	given ||| storable	count=1
function	a v format character ||| v	count=1
return	into the buffer blocking ||| $tuple_2$ int buffer	count=1
args	pool to the given ||| pool ptr	count=1
args	list of non-options a ||| argorder a	count=1
args	the structure ||| foldable a	count=2
function	index an ||| index	count=1
function_args	all [args_2] ||| [function_1] $f_2$ [args_2]	count=4
return	a new handle ||| io handle	count=1
function	be written to a ||| write stm	count=3
function	to take ||| take	count=1
module	an array including ||| foreign marshal array	count=2
args	[args_1] a single ||| [args_2] [args_1]	count=1
args	given type where ||| ioerrortype	count=1
return	computation hwaitforinput hdl ||| io	count=2
module	and currency ||| data	count=1
return	weak pointer to ||| io weak	count=1
function_args	be written [args_2] ||| [function_1] [args_2]	count=3
function	limit ||| limit	count=4
function	[function_1] prefix of ||| [function_2] [function_1]	count=1
args	wordptr ||| wordptr	count=1
function	shift the argument left ||| shift	count=3
function	catch but it ||| catch just	count=1
return	or nothing if the ||| io maybe	count=3
function	of this accumulator together ||| accum	count=2
module	because the end of ||| system io	count=1
function	the denominator is ||| denominator	count=1
function	[function_1] is ||| [function_2] already [function_1]	count=2
args	for the either ||| c $f_2$ b c either	count=1
args	list of storable ||| storable $f_2$ ptr storable io b	count=1
function	bytes copied ||| bytes copied	count=2
args	exception ||| exception maybe b	count=2
function	character to ||| cuchar to	count=1
return	returns a quadruple consisting ||| $list$ string	count=1
function	managed ||| h get char	count=4
module	a fresh memory ||| foreign	count=1
module	get the ||| ghc	count=1
function_args	file [args_2] ||| [function_1] [args_2]	count=6
args	equality predicate ||| a bool $list$ a	count=1
return	returns a quadruple ||| $list$ a $list$ string $list$ string $list$ string	count=1
return	a single lexeme ||| string	count=1
function	capability or ||| capability	count=1
module	plus letters of ||| data	count=1
module	operating system ||| system	count=4
args	latin-1 ||| cchar	count=1
module	block ||| marshal alloc	count=1
return	in ||| io	count=1
return	of memory and ||| io ptr storable	count=1
function	that capability or ||| capability	count=1
args	elements of ||| a bool $list$	count=1
function	sets [function_2] ||| [function_2] [function_1]	count=2
args	value to be returned ||| $f_2$ a io	count=1
module	the given ||| foreign	count=1
function	returning the radix of ||| radix	count=1
return	those that didn t ||| $tuple_3$ $list$ a $list$ string $list$	count=1
args	contain the file handle ||| maybe handle	count=1
function	associating ||| foldl m	count=1
return	a new handle ||| handle	count=1
args	argument is executed with ||| mvar a $f_2$ a io $tuple_2$	count=1
function	role of return ||| return a	count=1
args	fresh memory pool ||| $f_2$ pool io b	count=1
return	handle with ||| handle	count=1
return	monads ||| monad	count=1
module	encoding ||| ghc io encoding	count=1
args	exception in ||| exception	count=1
args	a ||| a $f_2$	count=1
module	of a ||| prelude	count=1
module	variant of ||| data list	count=1
function	character ||| char	count=1
function	filled with ||| calloc array	count=1
args	for input [args] hdl ||| [args]	count=1
args	analysis for the either ||| b c either a	count=1
module	of x ||| data	count=1
function	for fmap ||| fmap default	count=1
args	and passes the resulting ||| filepath	count=1
args	a conversion scheme between ||| textdecoder dstate io textencoder estate	count=1
args	as ||| int	count=1
function	strict ||| strict st	count=2
return	the fingerprint ||| fingerprint	count=2
function	a list using square ||| list	count=1
function_return	contents of [return_2] ||| [function_1] buffer word8 [return_2]	count=3
function	if the ||| throw if	count=1
module	same object ||| mem weak	count=1
function	[function_1] copied each ||| [function_2] [function_1]	count=4
function	fresh ||| pool	count=1
function	[function_1] read from ||| [function_2] [function_1]	count=1
function	stable pointer to an ||| stable ptr to ptr	count=1
return	of returned tvar ||| tvar	count=1
module	the first occurrence of ||| data	count=1
module	in ||| ghc io	count=2
args	storable ||| storable	count=1
args	a c string ||| textencoding string $f_2$	count=1
function	representation ||| rep args	count=4
args	finalized pointer ||| ptr env ptr	count=1
function	newline [function_2] ||| [function_2] [function_1]	count=1
function	strict ||| to strict	count=1
function	the unzip6 ||| unzip6	count=1
return	return the number of ||| int	count=2
return	returns an [return_2] ||| [return_2] [return_1]	count=9
function	system event ||| get system event	count=2
function	statickey ||| static ptr	count=1
function	int type ||| mk int type	count=2
args	or a returned value ||| $f_2$ either someexception a	count=1
return	final value ||| $tuple_2$ a traversable c	count=1
module	of scanl ||| data list	count=4
return	the next value from ||| a	count=1
return	[return_1] an either ||| [return_1] [return_2]	count=3
return	buffer ||| $tuple_2$ int buffer word8	count=1
args	given marker ||| storable	count=1
args	value from ||| io a io b io c	count=2
function	foldr1 ||| foldr1	count=1
module	the combination of malloc ||| utils	count=1
args	promote a function ||| a2 a3 a4 r monad a1 monad a2	count=1
function	sparks currently in the ||| num sparks	count=2
function	the upper and ||| min	count=1
args	argument a pointer to ||| ptr	count=2
args	pointer ||| ptr storable	count=2
args	given number of ||| a ptr a int	count=2
return	retagging and merging their ||| b b' either c c'	count=1
return	waiting to ||| blockedindefinitelyonstm	count=1
function	strict one ||| strict st	count=1
args	with a pure function ||| $f_2$ b c arrow c d	count=1
function	allocate a fresh ||| new	count=1
args	predicate instead ||| $f_3$ a a bool $list$	count=1
module	operating system ||| system io	count=1
args	user-supplied equality predicate instead ||| a bool $list$ a	count=1
module	variant of foldr ||| data	count=2
module	of xs ||| data	count=1
function	caseless scripts and ||| is alpha	count=1
args	witharray but ||| $f_2$ ptr storable io b	count=1
module	copies ||| marshal utils	count=2
function	file in [function_2] ||| [function_1] [function_2]	count=2
return	arrow notation ||| arrow b	count=1
module	register ||| ghc event	count=1
return	time ||| time	count=1
return	pass a ||| io a	count=2
return	the buffer without ||| io $tuple_2$ maybe int buffer word8	count=1
function_return	[function_1] returns a ||| [return_2] [function_1]	count=1
function	[function_1] list by ||| [function_1] [function_2]	count=1
args	pointer living inside a ||| a $f_2$ ptr a	count=2
function	third value ||| id	count=1
module	number of elements to ||| data list	count=1
return	key value pairs ||| $tuple_2$	count=1
args	either ||| c either a b	count=2
args	list of storable values ||| ptr storable io b	count=1
module	datatype to its ||| generics	count=1
module	through the argument arrow ||| control arrow	count=1
function_args	rotate [function_1] [args_2] ||| [function_1] [args_2]	count=2
module	of a ||| data char	count=2
module	fresh memory ||| marshal pool	count=1
args	argument is executed ||| mvar a	count=1
args	to non-empty ||| $f_3$ a a a	count=1
module	a variant of foldl ||| data list	count=1
return	parses the first zero ||| readp	count=1
args	return value ||| a io b io c	count=2
module	new ||| control concurrent chan	count=1
args	integral type with the ||| word#	count=1
args	the return value from ||| a	count=2
function	[function_1] of storage ||| [function_2] [function_1]	count=2
args	the ||| storable $list$ storable	count=1
function	to the ||| cchar to char	count=1
function	[function_1] pointer to ||| [function_2] [function_1]	count=1
args	a ||| monad $tuple_2$ b c $list$ a	count=1
return	out elements ||| $list$	count=1
args	return value from ||| io a io b io	count=2
args	a pointer to ||| $f_2$ ptr storable io	count=2
args	either ||| a c $f_2$ b c either a	count=1
function	be written ||| write stm	count=3
args	return value ||| a io b io	count=2
args	typeable allows a ||| typeable	count=1
function	additionally if ||| errno if	count=1
function	[function_1] signed type ||| [function_1] [function_2]	count=1
module	pair of types ||| data typeable	count=1
return	a nul terminated ||| io cstring	count=1
return	computation hgetbuffering ||| io buffermode	count=4
return	argument arrow and copy ||| arrow $tuple_3$ b d c	count=1
args	to a predicate ||| $f_2$ a	count=2
return	stablename for an ||| io stablename	count=2
args	as ||| string io	count=1
function	product of ||| product	count=1
module	the program ||| system io	count=1
args	user-supplied equality predicate ||| a a bool	count=2
return	raised [return] ex ||| io either exception [return]	count=1
function	finalizer ||| ptr finalizer	count=2
module	[module_1] [module_2] signed ||| [module_2] [module_1]	count=2
function_return	split a [return_2] ||| [function_1] typerep [return_2]	count=2
return	dereferences ||| io maybe v	count=1
function	of its arguments already ||| already	count=2
args	contain the file handle ||| handle	count=1
return	traverse with its ||| applicative traversable	count=1
module	of ||| data string	count=2
function	the index of ||| index	count=1
args	stm actions ||| stm a	count=1
function	to ||| min	count=1
args	string using temporary ||| string $f_2$	count=1
module	an [module] by ||| [module]	count=1
function	foreign [function_2] ||| [function_2] [function_1]	count=3
module	alloca ||| marshal array	count=1
module	prefix of xs of ||| data	count=1
args	integral ||| integral	count=4
function	[function_1] pointer ||| [function_2] [function_1]	count=12
function	read from ||| read	count=1
args	a binary ||| applicative a applicative	count=1
return	specified character ||| char	count=1
return	a final value ||| $tuple_2$ a traversable c	count=1
function	a raw mode where ||| set raw	count=1
args	quadruples ||| $list$ $tuple_4$ a b c d	count=1
args	a monomorphic type constructor ||| tycon	count=1
module	is the same as ||| bits	count=1
args	a ||| monad b traversable a	count=2
function	and lower ||| bound	count=1
return	to the size ||| io	count=1
function	line from ||| get line	count=1
args	a predicate ||| $f_2$	count=2
return	returns an stm action ||| io $tuple_2$ stm io	count=3
module	satisfying ||| text parsercombinators readp	count=2
function	and rem ||| rem	count=1
args	is the same ||| bits int	count=1
return	retagging and merging their ||| b b' either c	count=1
function_return	the given [return_2] ||| [function_1] foreignptr a [return_2]	count=2
function	channel begins ||| dup	count=1
args	promote a function ||| monad a1 monad a2 monad a3	count=2
return	number of the ||| io $tuple_2$ int	count=2
module	[module_1] options ||| [module_1] [module_2] usage	count=1
return	[return_1] supplied value ||| [return_2] [return_1]	count=2
module	shift ||| ghc exts	count=2
args	in the given number ||| int	count=1
function	range 0 ||| int to digit	count=1
args	value ||| a io $tuple_2$ a b	count=1
module	the same size ||| exts	count=1
args	and [args_2] ||| [args_2] [args_1]	count=1
args	the ||| a io a	count=3
function	read on the given ||| read	count=1
function	the current i/o ||| get posn	count=2
return	a tuple where first ||| $tuple_2$ $list$ a $list$ a	count=1
module	attempt was made ||| exception base	count=1
module	the first list ||| list	count=3
args	structure is ||| foldable a	count=2
function	resource which [function] ||| [function] in use	count=3
function_return	bytes of [return_2] ||| [function_1] int [return_2]	count=2
function_return	[function_1] function reads ||| [function_1] [return_2]	count=1
args	a maybe value ||| $f_2$ a b maybe a	count=1
function	raw mode where characters ||| set raw	count=1
return	unicode ||| io textencoding	count=1
args	a list of non-options ||| argorder a $list$	count=1
function	increases ||| step	count=1
args	a monad scanning ||| a4 monad a5	count=1
args	action in [args_2] ||| [args_2] [args_1]	count=1
args	type hierarchy ||| e	count=1
function	[function_1] error message ||| [function_2] [function_1]	count=1
args	elemindex function returns the ||| $list$ eq	count=1
return	a ||| alternative a	count=1
module	same object ||| system mem weak	count=1
args	with a pure ||| $f_2$ b c	count=1
function	the error message if ||| error with	count=1
args	string ie character array ||| textencoding string $f_2$	count=1
function	group function takes a ||| group	count=1
return	that a handle ||| handle	count=1
args	pool which gets ||| pool io b	count=1
args	is the ||| int	count=1
args	value produced ||| a	count=2
module	like mallocarray but allocated ||| marshal	count=1
module	haskell type representing the ||| types	count=2
args	a pointer to a ||| ptr	count=2
return	readlist method ghc ||| read	count=1
function	base ||| int at base	count=2
module	string representation of a ||| data char	count=1
args	function takes a predicate ||| $f_2$ a bool $list$	count=1
module	of !!, which ||| data list	count=1
function	handle ||| handle	count=2
args	given [args_2] ||| [args_1] a [args_2]	count=4
module	used to name ||| prelude	count=1
args	structure ||| $f_2$ a monad b foldable	count=2
args	as x ||| bits	count=1
function	counter that ||| counter	count=1
function	its arguments does not ||| does not	count=1
args	bool parameter is true ||| bool	count=1
args	conversion scheme between sequences ||| io textencoder estate	count=1
return	mvar which contains the ||| io mvar	count=1
function	bit ||| bit	count=3
function	drop n xs ||| drop	count=1
return	constructor application ||| tycon $list$	count=2
function	can t ever continue ||| indefinitely	count=1
return	[return] run when ||| io weak ioref [return]	count=2
return	the io monad ||| io	count=3
return	write the ||| io	count=1
module	[module_1] datatype to ||| [module_1] [module_2]	count=2
function	available to read on ||| read	count=1
args	complex number ||| complex realfloat	count=1
module	of second components ||| data	count=1
return	a pair ||| $tuple_2$ b a	count=1
function	passed to the finalizer ||| ptr finalizer	count=2
args	list is ||| $list$	count=1
args	case ||| io a	count=1
module	a variant of foldr ||| data	count=2
function	written to a ||| write stm	count=3
function	ascii hexadecimal digits ||| is hex digit	count=1
args	or right by -i ||| int	count=1
return	a tuple ||| $list$ a $list$ a	count=1
args	with a ||| $f_2$	count=2
args	exception predicate to select ||| $f_2$ exception maybe b io a	count=1
module	x ||| data bits	count=2
args	with a pure ||| $f_2$ b	count=1
function_args	test whether [args_2] ||| [function_1] [args_2]	count=6
args	string str to the ||| string	count=1
function	a ||| pool	count=1
args	the given [args_2] ||| [args_1] [args_2]	count=2
return	tycon object representing ||| tycon	count=2
args	as argument a pointer ||| ptr storable	count=2
function	list ||| to list	count=2
function	[function_1] be written ||| [function_1] [function_2]	count=3
function	that file ||| file	count=2
args	the either type ||| b c either	count=1
args	argument and ||| string $list$ optdescr	count=1
module	this exception ||| control exception	count=4
return	buffer blocking ||| $tuple_2$ int buffer	count=1
args	non-empty lists ||| $list$	count=2
return	into the ||| io	count=2
args	equality predicate ||| $f_3$ a a bool	count=2
function	a prefix ||| prefix	count=1
module	of a key function ||| data	count=1
args	gets the number ||| int	count=1
return	a list ||| a	count=2
return	x setbit i is ||| bits	count=1
module	same as x ||| data bits	count=1
function	arrowchoice by defining left ||| left	count=1
module	first occurrence of x ||| data	count=1
return	the size of ||| io	count=1
module	marshal ||| marshal pool	count=1
return	a ||| a b c	count=3
args	of a structure but ||| foldable a	count=1
module	error indicating that an ||| error	count=1
function	stack trace ||| stack trace	count=1
args	copy the given number ||| storable ptr storable int	count=1
function_args	exception type [args_2] ||| [function_1] [args_2]	count=1
function	[function] given ||| [function]	count=1
function_args	suspends the current [function_1] [args_2] ||| [function_1] [args_2]	count=5
module	is an unsigned ||| ghc exts	count=1
return	argument as a ||| a	count=2
function	[function] the ||| [function] malloc	count=2
module	integral ||| exts	count=1
args	be returned ||| a $f_2$ a	count=1
args	value of the ||| a applicative b	count=1
return	buffered for output in ||| io	count=1
module	size ||| ghc	count=1
function	line from the ||| line	count=1
return	for the ||| io ptr storable	count=1
module	e [module] raised ||| [module]	count=1
function	in temporary storage with ||| with	count=1
args	of non-options a ||| argorder a $list$ optdescr a	count=1
args	with a pure ||| $f_2$ b c arrow c	count=1
args	a monad scanning ||| monad a3 monad a4 monad a5	count=1
return	the computation exitfailure ||| io	count=1
args	exception predicate to ||| $f_2$ exception maybe	count=1
module	internal function to ||| data typeable internal	count=1
module	memory location ||| foreign	count=1
args	stm ||| stm a stm a	count=2
module	types defined ||| types	count=1
function	an arbitrary ||| make stable	count=1
args	a c string ie ||| string $f_2$	count=1
function	of the module where ||| sp info module	count=1
return	a storable type ||| ptr storable	count=3
function	[function_1] file ||| [function_1] binary [function_2]	count=1
args	promote a function to ||| a3 a4 a5 r monad a1 monad	count=1
args	characters ||| char	count=3
return	of [return] ||| [return]	count=3
module	[module_1] [module_2] pairs ||| [module_2] [module_1]	count=2
args	arguments ||| $f_2$ a monad b monad	count=1
return	stm action that can ||| stm io	count=3
args	handle to ||| $f_2$ handle	count=1
module	[module_1] list argument ||| [module_1] [module_2] delete	count=2
args	resulting handle to ||| handle io r	count=1
function	zip5 function takes ||| zip5	count=1
function	whether the thread ||| thread	count=2
function	line from the file ||| line	count=1
function	the mapandunzipm function ||| map and unzip m	count=1
args	string as its ||| string string	count=1
return	cc other ||| generalcategory	count=1
args	like witharray but a ||| ptr storable io	count=1
module	the utf-32 unicode encoding ||| ghc io encoding	count=1
module	use in ||| io	count=1
return	a ||| a $list$ a	count=1
function	p separated [function] sep ||| sep [function]	count=1
module	set ||| ghc conc sync	count=1
args	of the codec ||| buffercodec from to	count=1
args	the given number ||| int $f_2$ ptr storable	count=1
args	promote a function ||| a1 monad a2	count=2
args	pointer to a temporarily ||| storable $f_2$ ptr	count=1
function_args	an index [args_2] ||| [function_1] [args_2]	count=1
function	only performs ||| on error	count=1
return	but returns a quadruple ||| $list$ string $list$ string $list$ string	count=1
args	an action ||| $f_2$ a applicative	count=1
args	makes a ||| iodevice/bufferedio/typeable filepath iomode maybe textencoding newlinemode	count=1
args	executed ||| mvar a $f_2$	count=1
module	allocate a ||| foreign marshal pool	count=1
return	pair in ||| $tuple_2$	count=1
args	the given number of ||| int $f_2$ ptr	count=1
function	limits ||| min bound	count=1
function	finalizer ||| finalizer env	count=4
function_return	[function_1] an intptr ||| [return_2] [function_1]	count=1
args	the static pointer as ||| staticptrinfo	count=1
return	number of ||| io $tuple_2$ int bool	count=2
args	a structure to an ||| applicative b foldable a	count=1
args	the pool to ||| pool ptr	count=2
args	pointer to a temporarily ||| ptr storable	count=2
module	of strings at newline ||| data	count=2
function	[function_1] pointer ||| [function_1] [function_2]	count=4
module	[module_1] the ||| [module_2] [module_1]	count=1
function	duplicate of the ||| duplicate	count=1
args	the pool to ||| pool ptr a	count=1
module	columns of its argument ||| data list	count=1
module	[module_1] for ||| [module_1] [module_2]	count=1
args	[args_1] resulting handle ||| [args_1] [args_2]	count=1
function	allocate a fresh ||| new pool	count=1
return	computation into ||| s	count=3
function	into a foreign object ||| foreign	count=1
module	a c string ||| c	count=2
args	and ||| string $list$ optdescr a	count=1
function	wide character ||| new cwstring	count=1
function	group ||| group	count=1
function	to that capability or ||| capability	count=1
args	takes an exception predicate ||| $f_2$ exception maybe b	count=1
return	argument arrow ||| arrow $tuple_3$ b d	count=1
return	a storable type in ||| ptr storable	count=2
function	for hdl ||| h	count=1
module	always ||| conc sync	count=1
function	computes the sum of ||| sum	count=1
function	to ||| to bool	count=2
function	gc ||| gc	count=3
return	atomically modifies [return] ||| [return]	count=1
args	a pointer ||| ptr storable io b	count=2
module	types [module_2] ||| [module_2] [module_1]	count=1
args	predicate instead ||| a a bool $list$ a	count=1
function	strict one ||| to strict st	count=1
function_return	[function_1] constructor application ||| [return_2] [function_1]	count=2
args	c string ie ||| string $f_2$	count=1
module	[module_1] an io ||| [module_1] [module_2]	count=2
module	is ||| system io	count=1
return	and its value ||| a	count=2
return	arrow and ||| arrow	count=1
module	and ||| data maybe	count=2
return	for a ||| a	count=1
return	staticptr by ||| io maybe staticptr	count=1
module	the upper and ||| prelude	count=1
args	as well as four ||| d	count=1
args	given type where ||| ioerrortype string maybe	count=1
function	the program s heap ||| heap	count=2
function_args	satisfying the [args_2] ||| [function_1] [args_2]	count=2
return	[return_1] true ||| [return_1] [return_2]	count=3
function	least element ||| minimum by	count=1
function	wait until data can ||| thread wait	count=3
return	[return_1] a string ||| [return_2] [return_1]	count=1
function	this function maps ||| map exception	count=1
args	character from the handle ||| handle	count=1
function	[function_1] a terminal ||| [function_2] [function_1]	count=1
function	the error ||| error	count=1
module	of that ||| data typeable internal	count=1
return	a haskell string ||| io string	count=4
module	of xs of length ||| data	count=1
function	is an unsigned ||| w#	count=1
args	the given ||| ptr a ptr	count=2
module	an object of ||| data dynamic	count=1
module	nul terminated c ||| foreign c	count=2
module	an io ||| control	count=1
module	a foreign function equivalent ||| foreign	count=1
function	channel managed ||| h	count=2
function	of megabytes allocated ||| megabytes allocated	count=2
function	haskell character to ||| cast char to	count=3
function	file ||| regular file	count=1
function	hdl to ||| h	count=5
args	with a pure ||| $f_2$ b c arrow	count=1
module	the position of hdl ||| ghc io handle	count=1
return	in the io monad ||| io string	count=2
function	query element or ||| elem	count=1
args	converts a rational ||| rational	count=1
return	handle is created with ||| io handle	count=1
module	an ||| ghc exts	count=2
return	by the io action ||| io	count=1
return	of the buffer ||| io buffer word8	count=1
module	the representation ||| system io	count=1
module	promotable proxy type for ||| data proxy	count=1
module	same size ||| ghc	count=1
function	a haskell character to ||| cast char to cschar	count=1
return	obtain the [return_2] ||| [return_2] [return_1]	count=1
args	of a handle ||| handle	count=2
module	of foldl ||| data list	count=1
function	extra element ||| array0	count=1
args	argument a pointer ||| $f_2$ ptr storable io	count=2
args	structure ||| foldable applicative	count=1
function	the file in ||| file	count=4
function	name the upper and ||| min bound	count=1
args	if there are no ||| bufferedio buffer	count=1
function	the ||| bound	count=2
args	like witharray but ||| storable $list$ storable $f_2$ ptr storable io	count=1
function	[function] textencoding ||| [function]	count=4
return	of the buffer to ||| io buffer	count=1
return	any [return] in ||| [return]	count=1
args	on stablename that ||| stablename a stablename	count=1
return	with just a ||| a	count=1
module	of xs after the ||| data	count=1
args	hsetbuffering hdl mode ||| buffermode	count=1
return	but allows the finalizer ||| io	count=2
module	in the [module_2] ||| [module_1] [module_2]	count=6
module	[module_1] including an ||| [module_2] [module_1]	count=4
module	allocate a fresh memory ||| marshal pool	count=1
function	tvar ||| read tvar	count=1
args	monad scanning the ||| monad a4 monad a5	count=1
module	of the correct ||| data	count=2
function	quantity ||| qsem	count=1
function	into a foreign ||| foreign	count=2
module	direct support for ||| ghc	count=1
module	a variant of ||| data list	count=1
args	list of non-options a ||| argorder	count=1
args	their point-wise combination analogous ||| d $list$ e	count=1
function	current thread for a ||| thread	count=1
function	unzip6 function ||| unzip6	count=1
module	of magnitude and ||| data complex	count=1
return	the device without ||| word8	count=1
args	pointer to a temporarily ||| storable $f_2$ ptr storable	count=1
return	but returns a quadruple ||| a $list$ string $list$ string $list$ string	count=1
function	in class ||| rat	count=1
return	returns a quadruple ||| a $list$ string $list$ string $list$ string	count=1
args	is ||| int	count=1
args	an exception predicate ||| $f_2$ exception maybe b io a	count=1
function	var or nothing if ||| lookup	count=1
module	subset of unicode ||| data char	count=1
function	wait until data ||| thread wait	count=3
module	only ||| conc io	count=3
function	between the stable ||| stable	count=1
args	storable values in ||| $f_2$ ptr storable io b	count=1
module	of its ||| data	count=1
function	stm transaction ||| stm	count=1
args	executed with ||| mvar a $f_2$ a	count=1
function	the current buffering mode ||| get buffering	count=2
args	the return value ||| io a io b	count=2
function	haskell character to ||| cast char to cschar	count=1
rep	slides [function_return_2] ||| [module_1] slide [function_return_2]	count=4
args	analysis for the either ||| c either a	count=1
return	addition to the ||| io	count=1
args	like witharray but a ||| storable io b	count=1
return	[return_1] haskell list ||| [return_2] [return_1]	count=2
return	block of memory ||| io ptr storable	count=1
module	the array ||| array	count=1
return	that traverse ||| traversable	count=1
args	for the either type ||| c $f_2$ b c either a b	count=1
args	elements of the list ||| a bool $list$ a	count=1
module	malloc ||| foreign marshal array	count=1
args	a precedence-insensitive readp to ||| readp	count=1
args	describes ||| argdescr	count=1
return	quadruples analogous to zip ||| $tuple_4$	count=1
module	standard output device same ||| system	count=1
module	of length n or ||| data	count=1
args	list ||| $list$ readprec a	count=2
args	[args_1] predicate to ||| [args_2] [args_1]	count=8
module	offset ||| ghc io device	count=1
function	stable pointer to an ||| cast stable ptr to ptr	count=1
args	either type ||| c $f_2$ b c either	count=1
return	a quadruple consisting ||| string	count=1
module	for ||| ghc	count=6
return	reads a non-empty string ||| reads string	count=1
function_return	[function_1] [return_2] ||| [function_1] floating [return_2]	count=9
args	a ||| a $list$	count=2
function	map which can ||| map	count=1
return	traverse with ||| applicative traversable	count=1
return	returns a ||| a $list$ a	count=1
function	to name the ||| bound	count=1
function	the int [function_2] ||| [function_1] [function_2]	count=1
args	a predicate ||| $f_2$ a	count=2
args	the pool ||| pool ptr	count=2
function	to the query element ||| elem	count=2
module	the ||| data bits	count=2
function	slides the contents of ||| slide contents	count=1
module	allocate ||| foreign marshal pool	count=2
args	user-supplied equality predicate ||| $f_3$ a a bool	count=2
function	elements of a ||| array	count=1
return	arrow notation ||| arrow	count=1
args	argument a pointer ||| ptr	count=2
module	c byte ||| foreign c	count=1
function	to run ||| run	count=1
function	similar to mallocarray0 ||| ptr array0	count=1
args	pool ||| pool	count=7
module	was an ||| control	count=1
return	that didn t ||| $tuple_3$ $list$ a $list$	count=1
module	the input to both ||| control	count=1
module	use control ||| control concurrent	count=1
args	resulting handle to ||| handle	count=1
args	of storable ||| ptr storable io	count=1
return	word is an unsigned ||| word	count=1
args	pointer to a temporarily ||| $f_2$ ptr storable io	count=2
args	for the either ||| b c either a b	count=1
return	rest through unchanged to ||| either c d	count=1
function	difference non-associative ||| (\\)	count=1
args	signed [args_2] ||| [args_2] [args_1]	count=8
args	a pointer to ||| storable $f_2$ ptr storable io	count=1
function	string [function_1] [function_2] length information ||| [function_2] [function_1]	count=2
return	of newtvar ||| tvar	count=1
args	second argument is executed ||| mvar a $f_2$ a io $tuple_2$	count=1
function	to full precision ||| float	count=1
return	the io action returns ||| io ptr	count=1
function	return args ||| with args	count=1
function	allocate a ||| pool	count=1
return	strict ||| st s	count=1
function	a ||| bound	count=1
args	promote a function ||| a4 r monad a1	count=1
return	unicode ||| textencoding	count=6
args	monad scanning the ||| a3 monad a4 monad	count=1
return	a computation and which ||| either ioerror a	count=1
function	[function_1] [function_2] comparison function ||| [function_1] [function_2]	count=6
return	but the io ||| io	count=1
return	next character from the ||| io	count=1
function	the default file permissions ||| file with default permissions	count=1
module	error indicating ||| error	count=1
function	wide string with ||| peek cwstring len	count=1
args	equality predicate instead ||| a a bool $list$	count=1
return	[return_1] a ||| [return_2] [return_1]	count=20
args	structure but with strict ||| b foldable	count=1
args	lists ||| $list$	count=3
module	current [module] until ||| [module]	count=1
function_return	[function_1] buffer to ||| [function_1] buffer word8 [return_2]	count=3
function_return	[function_1] [return_2] ||| [function_1] stableptr a [return_2]	count=4
function	file that may be ||| file	count=1
return	hdl returns true if ||| bool	count=1
function	mallocarray0 but yields ||| foreign ptr array0	count=1
args	user-supplied equality predicate instead ||| a a bool $list$	count=1
function	filled ||| calloc array	count=2
module	integral type ||| ghc exts	count=1
function	for an index ||| index constr	count=1
args	string using ||| textencoding string $f_2$	count=1
module	create ||| foreign stableptr	count=1
function	causes ||| finalize	count=2
module	available for ||| ghc	count=1
module	[module_1] scanl that ||| [module_1] [module_2]	count=8
module	is the same ||| data	count=1
function	until data [function_2] ||| [function_2] [function_1]	count=1
module	an ||| control	count=10
function	litte-endian ||| utf32le	count=2
module	the datatype ||| ghc generics	count=4
args	that takes an exception ||| exception maybe b io a	count=1
function	storage for the ||| pooled	count=2
function_args	[function_1] [args_2] ||| [function_1] readp [args_2]	count=3
module	the given parser ||| text parsercombinators readp	count=1
function	written ||| write	count=6
function	read an unsigned number ||| read dec	count=1
args	input [args] hdl ||| [args]	count=1
function	a foreign [function_2] ||| [function_1] [function_2] finalizerptr a	count=2
function	zip5 ||| zip5	count=1
function	version of putmvar ||| put	count=1
return	an intptr ||| intptr	count=1
module	[module_1] a ||| [module_2] [module_1]	count=2
function	size of an array ||| array	count=1
module	variant of scanl ||| data list	count=2
function	to the finalizer ||| add foreign ptr finalizer	count=2
args	pointer living inside a ||| $f_2$ ptr a	count=2
function	the transpose ||| transpose	count=1
function	same size ||| w#	count=1
module	which may be ||| ghc exts	count=1
function	insufficient ||| underflow	count=2
args	pool which ||| $f_2$ pool io b	count=1
function_return	to represent [return_2] ||| [function_1] [return_2]	count=6
return	rest through unchanged ||| d either c d	count=1
module	defines parser combinators ||| parsercombinators	count=1
function_return	split [return_2] ||| [function_1] typerep [return_2]	count=2
return	not pass [return] restore action ||| [return]	count=2
module	returns the list of ||| data list	count=1
module	may be ||| ghc	count=1
return	[return_1] number of ||| [return_2] [return_1]	count=6
args	storable values in memory ||| $f_2$ ptr storable	count=1
module	io library portions ||| io encoding	count=2
return	unicode encoding a ||| textencoding	count=1
function	marshal a c ||| peek cstring len	count=1
return	and a list ||| maybe a	count=1
args	the elemindex function returns ||| $list$	count=1
return	a parser ||| readp	count=1
return	and also may be ||| iodevicetype	count=1
return	of [return_2] ||| [return_2] [return_1]	count=4
function_return	[function_args_1] and a ||| [function_args_1] [return_2]	count=1
args	the resulting handle to ||| handle io	count=1
return	the original handle with ||| handle	count=1
function	program s heap ||| heap	count=2
module	corresponding to the ||| c	count=1
function	value of geterrno ||| errno	count=2
return	the required ||| io ptr storable	count=1
function	nub ||| nub	count=1
args	for the either type ||| a c $f_2$ b c either a	count=1
args	function ||| b $list$	count=1
return	memory and ||| io ptr storable	count=1
args	from the handle ||| handle	count=3
args	value typically the right-identity ||| a b b b $list$ a	count=1
function	disable allocation ||| disable allocation	count=4
function	of bytes copied each ||| bytes copied	count=1
function	[function_1] mvar ||| [function_2] [function_1]	count=2
function	same as hputchar stdout ||| put	count=1
function	allow ||| fix	count=3
return	used to continue ||| from buffer to	count=2
function	the float ||| mk float	count=1
return	stablename [return_2] ||| [return_2] [return_1]	count=4
function_return	class [return_2] ||| [function_1] rational [return_2]	count=1
args	type where the second ||| ioerrortype string	count=1
return	returns an either result ||| io either	count=1
function	[function_1] not ||| [function_1] [function_2]	count=2
module	because the user does ||| io	count=2
args	the number ||| int	count=2
function	constructor ||| con app	count=1
args	function takes a ||| $list$ a	count=1
return	into a circular ||| a	count=1
function	ascii digits ||| digit	count=1
args	a ||| a b	count=5
function	float type ||| mk float type	count=2
function	is [function_2] ||| [function_2] [function_1]	count=19
function	a stack trace to ||| with stack trace	count=1
return	the next character if ||| readp char	count=1
function_args	module where [args_2] ||| [args_2] [function_1]	count=3
module	for ||| ghc staticptr	count=2
module	the error ||| foreign c error	count=2
return	as a ||| a	count=4
module	from an mvar put ||| control	count=1
function	insert ||| insert	count=1
function	the same as ||| set bit	count=1
return	and returns a ||| io chan a	count=1
function	with a fresh memory ||| with pool	count=1
module	and lower limits ||| prelude	count=1
module	write ||| ghc conc	count=1
args	the file handle ||| handle maybe	count=1
function_return	changes the [return_2] ||| [return_2] [function_1]	count=1
args	the [args] hdl as ||| [args]	count=1
args	value produced by the ||| a $f_2$ a	count=1
return	[return_1] [return_2] ||| sync get num capabilities [return_1] [return_2]	count=8
return	way of showing ||| shows	count=1
args	chan ||| chan	count=1
function_return	[function_1] a ||| [function_1] int $list$ a [return_2]	count=1
function	[function_1] [function_2] the ||| [function_2] malloc [function_1]	count=4
return	a complex value ||| complex floating	count=1
return	a ||| io either b a	count=1
return	plain memory ||| foreignptr	count=2
return	number of ||| maybe int	count=1
args	pool ||| pool io b	count=1
module	value [module] list ||| [module]	count=1
return	next character if ||| char	count=1
function	lcm ||| lcm	count=1
args	the static pointer ||| staticptrinfo	count=2
args	argument is executed ||| mvar a $f_2$ a io $tuple_2$ a	count=1
args	lifetime lt ||| event lifetime	count=1
function	block the current [function_1] [function_2] ||| ghc conc [function_1] [function_2]	count=5
function	given path when appropriate ||| path if	count=1
module	is ||| data either	count=1
function_return	new instance [return_2] ||| [function_1] io [return_2]	count=1
function_args	lift a [args_2] ||| [args_2] [function_1]	count=2
module	application of the operator ||| data foldable	count=1
return	if an exception ||| exception	count=2
function	value lies between 0 ||| gfloat	count=1
return	returns a tuple ||| $list$ a $list$ a	count=1
module	integral ||| ghc	count=1
return	the number of haskell ||| io int	count=3
return	arrow ||| arrow	count=2
function	wrapper for modifying ||| modify mvar_	count=1
return	the threadid [return_2] ||| [return_2] [return_1]	count=4
return	hgetline hdl ||| string	count=1
module	the operation failed ||| io	count=5
module	tyconmodule and ||| data	count=2
function	sparks currently in the ||| sparks	count=2
args	structure ||| applicative b foldable	count=1
args	a memory ||| ptr a	count=1
module	a c ||| foreign c	count=7
return	function takes a ||| a $list$ b	count=3
module	functions from data ||| data	count=1
args	[args] respectively ||| [args]	count=3
return	fresh memory pool ||| pool	count=1
function	the transpose function transposes ||| transpose	count=1
function	scientific ||| read	count=1
return	convert a strict st [return_1] [return_2] ||| [return_1] [return_2]	count=2
args	x returns the integer ||| realfrac	count=1
module	that can only ||| ghc conc	count=1
module	a string representation of ||| data char	count=1
function	not ||| not	count=3
args	the ||| io b	count=4
module	valid memory location ||| foreign	count=1
function	duplicate ||| h duplicate to	count=1
args	value ||| a monad	count=2
args	non-options a list ||| argorder a $list$ optdescr	count=1
return	pairs ||| $tuple_2$	count=1
return	the buffer ||| buffer word8	count=2
args	monad scanning ||| monad a3 monad a4	count=1
return	parses the ||| readp	count=2
function	an arbitrary ||| make stable name	count=1
args	storable values ||| storable	count=1
return	a type constructor application ||| $tuple_2$ tycon $list$ typerep	count=1
function	is the ||| set	count=1
args	[args] maximum ||| [args]	count=1
args	size ||| word#	count=1
function	size as ||| w#	count=1
args	action ||| $f_2$ a applicative b	count=1
args	adds a ||| a	count=2
function	[function_1] already being ||| [function_2] [function_1]	count=4
function	accumulator together with ||| map accum	count=1
function	satisfying ||| munch	count=1
return	a list ||| maybe a	count=1
return	tvar to [return_2] ||| [return_2] [return_1]	count=1
args	type string- > string ||| string string	count=1
function	returns the current ||| get posn	count=2
return	a single string ||| string	count=1
return	staticptr ||| maybe staticptr	count=1
return	of ||| $list$ a	count=1
module	the traceio ||| debug	count=1
args	a structure to ||| applicative b foldable a	count=1
module	[module_1] of a ||| [module_2] [module_1]	count=1
return	and merging their ||| b' either c c'	count=1
args	a list is empty ||| $list$ a	count=1
args	handle to ||| filepath iomode $f_2$ handle	count=1
function_args	[function_1] using openfile ||| [args_2] [function_1]	count=4
function	the thread [function_2] ||| [function_1] [function_2]	count=2
module	the error code eagain ||| c error	count=1
function	by defining left ||| left app	count=1
return	returns the next character ||| readp char	count=1
function_args	duplicate [args_2] ||| [function_1] [args_2]	count=1
module	device type ||| io device	count=1
function	unzip4 function takes ||| unzip4	count=1
module	first element of ||| data	count=1
function_return	[function_1] io ||| [return_2] [function_1]	count=6
function	character to ||| cast char to	count=3
args	a c string ||| textencoding string	count=1
function	is ||| w#	count=1
args	an int in the ||| int	count=1
return	io errors which ||| io	count=1
args	to a monad scanning ||| a3 monad a4 monad a5	count=1
function	list [function] ||| cat [function]	count=1
args	constructor to ||| tycon $list$	count=1
args	promote a function ||| monad a1	count=2
return	asynchronous exceptions are ||| maskingstate	count=2
function	a v ||| v	count=1
function	error where ||| error	count=9
module	if so [module] ||| [module]	count=2
args	an action ||| $f_2$ a applicative b	count=1
args	copy the given number ||| ptr storable int	count=1
args	a curried [args_2] ||| [args_2] [args_1]	count=2
return	observe ||| typerep	count=2
function	separated [function] ||| [function]	count=1
function	the module where the ||| info module	count=1
return	list of ||| io $list$	count=1
function	realfloat ||| real float	count=1
args	of bits ||| finitebits	count=1
args	a [args_1] [args_2] ||| [args_1] [args_2]	count=2
return	[return_1] hgetbuffering hdl ||| [return_2] [return_1]	count=2
module	the right-to-left dual of ||| data	count=1
function	the current thread ||| thread	count=3
return	constructor ||| tycon	count=5
args	describes a single ||| string argdescr a string	count=1
module	of the correct ||| data dynamic	count=2
function	to atomically ||| atomically	count=1
module	extract [module] ||| [module]	count=1
return	parses and [return_2] ||| [return_2] [return_1]	count=1
function	a haskell character to ||| char to cschar	count=1
return	io monad and gives ||| io string	count=1
function	ie wide character array ||| cwstring len	count=1
return	but returns a quadruple ||| $list$ a $list$ string $list$ string $list$ string	count=1
function	an invalid or unrepresentable ||| invalid	count=1
args	living inside a ||| $f_2$ ptr a	count=2
function	user calls error ||| error call	count=2
args	on stablename that does ||| stablename a stablename b	count=1
args	a pointer ||| ptr	count=2
return	the non-overloaded version ||| a	count=2
function	ie character array ||| len	count=2
function_args	[function_1] string s ||| [function_1] put str [args_2]	count=1
return	contents after the ||| io	count=1
function	with a ||| with	count=1
args	handle and file ||| handle	count=1
args	openfile file mode ||| filepath iomode	count=2
function	p separated [function] sep ||| [function]	count=1
function	use traceevent ||| event	count=1
args	function takes ||| $f_2$ a bool $list$ a	count=1
function	error that is ||| error	count=1
args	the same size ||| word#	count=1
module	the current [module] until data ||| [module]	count=1
args	either ||| $f_2$ b c either a b	count=2
function	that the foreign object ||| foreign	count=2
function	marshal a ||| cstring len	count=1
module	c int type ||| foreign c	count=1
args	promote a function ||| a4 a5 r monad a1	count=1
module	c string into a ||| c string	count=1
function	that capability ||| capability	count=1
return	fingerprint ||| fingerprint	count=2
module	an ||| ghc	count=1
args	elemindex function returns the ||| eq $list$	count=1
module	be marshalled to ||| ghc	count=1
args	a maybe value ||| b maybe a	count=1
args	a ||| f g $list$ a	count=1
function	an error when an ||| error	count=1
function_args	a file [args_2] ||| [function_1] filepath iomode [args_2]	count=1
args	a binary ||| b c applicative a	count=1
args	promote a function ||| a1 a2 a3 a4 a5 r monad a1	count=1
function	version of takemvar ||| try take	count=1
function	channel managed by ||| h get	count=2
function	duplicate of the first ||| h duplicate to	count=1
return	value as the number ||| $list$ a	count=1
args	for the either type ||| b c either a b	count=1
module	latin-1 subset of unicode ||| data char	count=1
args	first argument and ||| string $list$ optdescr	count=1
module	of zero ||| data bits	count=2
module	a variant of foldl ||| data	count=1
args	the either ||| a c $f_2$ b c either a	count=1
module	argument arrows ||| control arrow	count=2
module	an io operation ||| system io	count=2
args	with a ||| $f_2$ c d arrow b c	count=1
args	non-options a ||| argorder	count=1
return	storage associated with the ||| io	count=1
return	the buffer blocking if ||| $tuple_2$ int buffer	count=1
module	an unsigned integral ||| exts	count=1
return	a final value ||| $tuple_2$ a traversable	count=1
args	the representation ||| rep generic x	count=1
module	a fresh ||| marshal pool	count=1
module	like mallocarray but add ||| array	count=1
args	witharray but a ||| storable $f_2$ ptr storable io b	count=1
return	[return] list ||| io $list$ [return]	count=2
module	is the ||| data bits	count=1
args	to a ||| $f_2$ a monad b traversable a	count=2
args	file handle and file ||| handle	count=1
return	into a nul terminated ||| io cstring	count=1
args	pointer to ||| $f_2$ ptr	count=2
return	using the ||| maybe	count=1
module	memory ||| foreign marshal pool	count=2
rep	[module_1] offset i ||| [module_1] [function_return_2]	count=2
return	a single string which ||| string	count=1
function_args	suspends the [function_1] [args_2] only ||| ghc conc [function_1] delay [args_2]	count=2
function	storage for a ||| pooled new	count=1
function_return	[function_1] buffer to ||| [return_2] [function_1]	count=3
function	like openfile [function_1] [function_2] ||| system io [function_1] [function_2] filepath iomode io handle	count=2
function	the first argument right ||| r	count=1
return	provided that traverse is ||| traversable	count=1
module	monoid under ||| data monoid	count=2
args	equality on stablename ||| a stablename b	count=1
function	as int ||| w#	count=1
args	on stablename ||| stablename b	count=1
return	didn t ||| $tuple_3$ $list$ a $list$	count=1
args	a pointer to ||| $f_2$ ptr	count=2
args	return value ||| io a io	count=2
module	is an ||| ghc exts	count=1
return	type ptr ||| ptr	count=1
function	behaves like delete ||| delete by	count=1
function	of throw that can ||| throw io	count=2
args	of a structure but ||| b b foldable a	count=1
return	elements ||| $list$	count=4
return	this variant [return_2] ||| [return_2] [return_1]	count=1
return	retagging and merging their ||| b b' either	count=1
module	options ||| system console	count=1
args	promote a function to ||| a5 r monad a1 monad a2 monad a3	count=1
function_return	until [function_1] [return_2] ||| [function_1] fd [return_2]	count=3
function	single-use resource which ||| in use	count=2
module	as the number of ||| data	count=2
function	stm transaction but there ||| on stm	count=1
module	object ||| mem	count=1
args	value produced ||| $f_2$ a monad	count=1
function	close a ||| close	count=1
function	the radix of the ||| float radix	count=1
return	is the non-overloaded version ||| a	count=2
module	the number of ||| data	count=2
module	of a character ||| data	count=1
function	event [function_2] ||| [function_2] [function_1]	count=1
function	arrowchoice by defining left ||| left app	count=1
function	throwerrnoifminus1retrymayblock ||| errno if minus1retry may block_	count=1
module	[module] handle ||| [module]	count=3
module	error ||| control exception base	count=1
args	a ||| a $f_2$ a	count=1
return	comp exposes io errors ||| io either	count=1
return	leftmost non-nothing ||| first	count=1
return	val [return_1] [return_2] ||| [return_1] [return_2]	count=8
module	that the machine has ||| ghc conc sync	count=1
return	stopped because there ||| codingprogress	count=1
module	variant of scanr ||| data list	count=2
args	either ||| either a b	count=2
function	the file in binary ||| binary file	count=2
args	actions discarding any value ||| monad a monad	count=1
args	the mapmaybe function is ||| maybe b	count=1
args	value ||| a $f_2$ either someexception a	count=1
return	a staticptr ||| maybe staticptr a	count=1
args	[args_1] number ||| [args_1] a [args_2]	count=5
module	allocate a ||| foreign	count=1
module	[module_1] command-line ||| [module_1] [module_2]	count=2
module	of bytes in ||| data	count=1
return	and the external file ||| newlinemode	count=1
module	of zero ||| data	count=2
return	the io action returns ||| io	count=2
args	quadruples ||| b c d	count=1
function	split a ||| split poly ty	count=1
args	a block of memory ||| a	count=1
module	if eventlog profiling ||| debug trace	count=1
args	either type ||| either a	count=1
return	[return_1] hgetline ||| [return_1] [return_2]	count=1
args	mapmaybe ||| a maybe	count=1
function	splits ||| split ty con	count=2
args	value produced ||| $f_2$ a	count=1
return	the buffer to ||| buffer word8	count=1
function	div ||| div'	count=1
module	a fresh memory ||| marshal	count=1
return	computation is ||| io c	count=2
function	number of bytes copied ||| bytes copied	count=1
return	to mkweakpair ||| v	count=1
args	a tvar ||| tvar a	count=2
args	where the second argument ||| ioerrortype string	count=1
return	the rest unchanged ||| c d	count=1
return	and returns [return_2] ||| [return_1] chan [return_2]	count=1
function	parameter from right to ||| r	count=1
function	sign of ||| sign plus	count=1
args	promote a function ||| a1 monad	count=2
args	an ||| word#	count=1
return	returns a quadruple consisting ||| $list$ string $list$ string	count=1
return	fixity of ||| fixity	count=1
return	a storable ||| io ptr storable	count=2
function	flush ||| flush	count=2
args	a monad scanning the ||| a2 monad a3 monad a4 monad	count=1
module	tyconname tyconmodule and ||| data	count=2
module	argument arrows and ||| control arrow	count=2
return	of io ||| io	count=2
function	throw that ||| throw io	count=2
function	foreign pointer and ||| foreign ptr	count=1
module	gc stats ||| stats	count=1
args	the ||| k v maybe io	count=1
return	tycon ||| tycon	count=4
function	be used to wait ||| wait	count=1
function	thread ||| thread	count=26
args	given number of ||| ptr storable ptr storable int	count=2
module	an [module_2] ||| [module_2] [module_1]	count=12
module	of elements that ||| data	count=1
function	device is full ||| is full	count=1
args	applied to non-empty ||| $f_3$	count=1
function	in ||| finite bit size	count=1
function	line from ||| line	count=1
return	not pass a ||| io a	count=2
return	[return_1] [return_2] ||| concurrent get num capabilities [return_1] [return_2]	count=8
args	a ||| $f_2$ a monad $tuple_2$ b c $list$ a	count=1
args	list of storable ||| $f_2$ ptr storable io	count=1
function	hwaitforinput hdl t waits ||| for	count=2
return	the ||| a	count=3
args	value produced ||| monad a	count=1
function	disjunction ||| or	count=2
return	string which ||| string	count=1
args	handle ||| iomode $f_2$ handle	count=1
function	sets the position of ||| set	count=2
function	allow the result ||| fix st	count=3
args	value typically the ||| b a b b $list$ a	count=1
function	get the ||| h get	count=1
return	of a storable ||| ptr storable	count=3
rep	[module_1] [function_args_2] ||| [module_1] alg [function_args_2]	count=2
module	block ||| alloc	count=1
args	structure ||| foldable a	count=4
function	actually a pair ||| mk weak pair	count=1
function	thread until data is ||| thread wait	count=1
module	unlines ||| data string	count=1
return	realfrac value ||| realfrac	count=1
module	unsigned integral type with ||| exts	count=1
args	value ||| $tuple_2$ a b	count=1
args	a ||| a $f_2$ a b	count=2
module	the array ends ||| marshal array	count=1
function	storage for a ||| pooled	count=1
args	where the second argument ||| ioerrortype string maybe	count=1
args	openfile and [args_2] ||| [args_1] $f_2$ [args_2]	count=1
args	elements of the list ||| bool $list$ a	count=1
module	of the ||| data foldable	count=1
return	[return_1] pairs ||| [return_1] [return_2]	count=1
args	for the either ||| $f_2$ b c either	count=1
function	terminal or ||| terminal	count=1
function	of the second ||| of	count=1
args	value typically the ||| b b $list$ a	count=1
function	query element in ||| elem	count=1
module	of the types ||| types	count=1
args	any value produced ||| monad a	count=1
args	non-options a list of ||| argorder a $list$ optdescr a $list$	count=1
function_return	bytes [return_2] ||| [function_1] int [return_2]	count=2
args	with the arguments ||| $f_2$	count=3
return	bytes into the buffer ||| $tuple_2$ int buffer	count=1
function	the mvar ||| mvar	count=2
args	be returned ||| $f_2$ a io $tuple_2$	count=1
function	megabytes [function_2] ||| [function_1] [function_2]	count=3
return	a stablename for an ||| io stablename a	count=1
args	the given number ||| ptr storable int	count=2
function	[function_1] written ||| [function_1] [function_2]	count=8
return	the length of the ||| io	count=1
return	a haskell list ||| $list$	count=1
rep	[module_1] representation of ||| [module_1] [function_args_2]	count=1
return	the pointer ||| io	count=2
function	duplicate of the ||| h duplicate to	count=1
args	equality predicate instead ||| $f_3$ a a bool $list$ a	count=1
module	and the like which ||| data	count=1
function	the thread is ||| thread	count=5
return	of a collection ||| a	count=1
function	is blocked [function_2] ||| [function_2] [function_1]	count=8
args	pointer to ||| ptr storable io	count=2
args	scanning ||| monad a4 monad	count=1
args	takes an exception predicate ||| $f_2$ exception maybe b io	count=1
return	returned tvar [return_2] ||| [return_1] [return_2]	count=1
return	the code for the ||| io	count=2
module	the results ||| control	count=1
return	the rest unchanged to ||| d	count=1
args	action ||| $f_2$ a applicative	count=1
return	into the buffer blocking ||| buffer word8	count=1
return	[return] encoding ||| [return]	count=1
function	the newly created ||| fork	count=2
function	duplicate channel begins empty ||| dup chan	count=1
function	printf except that ||| printf	count=1
function	thread has an allocation ||| allocation	count=1
function	100% accurately ||| full	count=1
function	a pair of ||| mk weak pair	count=1
function	group function takes ||| group	count=1
return	hgetline hdl reads a ||| string	count=1
return	feed marked inputs through ||| arrowchoice either b d	count=1
function_return	contents of [return_2] ||| [return_2] [function_1]	count=3
args	returned ||| a $f_2$ a io $tuple_2$	count=1
function	line from the file ||| h get line	count=1
args	function takes ||| a bool $list$	count=1
function	hdl t waits until ||| wait for	count=2
function	[function_1] newline ||| [function_2] [function_1]	count=1
return	for a given type ||| a	count=1
module	encode ||| encoding types	count=1
module	of elements which ||| data	count=1
args	the predicate ||| $f_2$ a	count=3
module	the suffix of xs ||| data	count=1
args	is a reverse application ||| a b	count=1
function	of throw that ||| throw	count=2
return	bool ||| bool	count=1
function_args	[function_1] [args_2] ||| [function_1] float [args_2]	count=8
args	type where the ||| ioerrortype	count=1
return	threadid of [return_2] ||| [return_2] [return_1]	count=4
function	data [function] on ||| thread wait [function]	count=1
args	describes a single ||| $list$ char $list$ string argdescr a string	count=1
function	is like catch but ||| catch	count=1
args	given type where the ||| ioerrortype string maybe	count=1
args	promote a function to ||| a1 a2 a3 a4 r monad a1 monad	count=1
function	begins ||| dup chan	count=2
module	error if ||| error	count=1
args	the same size as ||| word#	count=1
return	that a handle is ||| handle	count=1
function	float [function_2] ||| [function_2] [function_1]	count=1
module	element ||| list	count=2
function	[function_1] be written ||| [function_2] [function_1]	count=3
function	function maps ||| map	count=1
args	of non-options a list ||| argorder a	count=1
return	the eventlog if ||| io	count=1
function	[function_1] suffix of ||| [function_1] [function_2]	count=1
args	pointer ||| storable $f_2$ ptr storable io b	count=1
args	monad scanning ||| a3 monad a4 monad	count=1
args	value from the first ||| io a io	count=2
module	new ||| ghc conc sync	count=1
function	lower ||| bound	count=1
function	[function_1] error message ||| [function_2] stack [function_1]	count=1
args	arguments ||| $f_2$	count=3
function	to the corresponding haskell ||| cast cschar to	count=1
function	if ||| throw if	count=2
args	[args_1] handle ||| [args_1] $f_2$ [args_2]	count=1
module	mappend ||| monoid	count=1
module	returns an ||| control	count=1
args	function to a ||| a	count=1
function	size of the data ||| size	count=1
module	that the machine ||| ghc conc	count=2
module	the stack ||| ghc stack	count=2
args	value ||| $f_2$ a	count=1
return	lists such that ||| $list$ $list$ eq	count=1
function	to represent the ||| prefix	count=1
return	the precedence context ||| readprec a	count=4
return	a fresh memory ||| io	count=1
module	[module_1] including ||| [module_1] [module_2]	count=4
module	returns the suffix of ||| data	count=1
args	actions ||| applicative b	count=1
function	where ||| mk ioerror	count=1
module	maximum value [module] ||| [module]	count=1
return	those that didn t ||| $tuple_3$ $list$ a $list$	count=1
function	the largest ||| maximum by	count=1
module	instead [module] ||| [module]	count=1
module	a ||| marshal	count=1
args	into a nul terminated ||| cstring	count=1
function_args	[function_1] structure ||| [function_1] [args_2]	count=2
args	for the either type ||| b c either a	count=1
return	buffer blocking ||| io $tuple_2$ int buffer word8	count=1
module	if so [module] context n ||| [module]	count=1
return	the buffer blocking ||| $tuple_2$ int buffer word8	count=1
args	pointer to ||| storable $f_2$ ptr	count=1
return	the current value ||| ptr a	count=1
module	of ||| data bits	count=3
args	the return value ||| a	count=2
function	foldr1 is a variant ||| foldr1	count=1
module	a function and ||| data	count=1
return	returns a quadruple consisting ||| string $list$ string $list$ string	count=1
args	pool which ||| pool	count=1
module	promotable proxy ||| data proxy	count=1
module	convert a [module_2] ||| [module_2] [module_1]	count=6
return	their point-wise combination analogous ||| e	count=1
args	explicit length information ||| cstringlen io a	count=2
args	elements ||| bool $list$	count=1
return	and merging ||| b b' either	count=1
function	parses zero ||| many	count=1
args	predicate ||| $f_2$ char bool	count=2
args	monad scanning the ||| monad a4	count=1
return	elements satisfying the predicate ||| $list$	count=1
module	through the argument ||| control	count=1
function	performs the final action ||| on error	count=1
return	mapaccumr function behaves ||| $tuple_2$ acc $list$ y	count=1
function	storage for ||| pooled	count=3
return	parses the first ||| readp string	count=2
args	of storable values in ||| storable	count=1
return	end marker into a ||| storable/eq	count=1
args	living inside a ||| a io b	count=2
module	container of ||| data	count=1
function	[function] on both ||| [function]	count=2
args	an exception ||| exception	count=2
function	terminal or console ||| terminal	count=1
module	returns whether gc stats ||| stats	count=1
return	lists ||| $list$ $list$ eq	count=1
function	blocking mode ||| blocking	count=1
function	send the first ||| first	count=1
module	of types that ||| data	count=1
args	is executed ||| mvar a $f_2$ a io $tuple_2$ a	count=1
function	a third value ||| show id	count=1
args	elemindex function returns the ||| $list$	count=1
return	the someexception type ||| someexception	count=1
function_return	[function_1] [return_2] ||| [function_1] [return_2]	count=414
function	allocate storage ||| pooled malloc	count=2
function	buffering mode [function_2] ||| [function_2] [function_1]	count=1
function	the first argument ||| first	count=1
return	a complex number ||| complex	count=1
module	exception ||| exception base	count=1
module	of length ||| data	count=1
args	nul terminated c string ||| string $f_2$ cstring io a	count=1
return	[return] encoding ||| io [return]	count=1
args	value produced by the ||| a $f_2$ a monad	count=1
function	a ||| min bound	count=1
args	class typeable ||| typeable	count=1
return	[return] instead ||| [return]	count=2
module	element [module_2] ||| [module_1] [module_2]	count=2
args	a file descriptor ||| fd	count=4
args	either ||| b c either	count=1
return	into the buffer ||| int buffer	count=1
function	passed to the finalizer ||| foreign ptr finalizer env	count=2
function	[function_1] [function_2] ||| [function_2] already [function_1]	count=2
args	the given number of ||| a ptr a int	count=2
function	of elements of ||| array	count=1
return	is waiting to retry ||| blockedindefinitelyonstm	count=1
return	for versions in ||| version	count=1
return	buffer to the beginning ||| buffer	count=1
module	parses p in ||| text parsercombinators	count=1
args	the handle ||| handle ptr	count=2
module	to ||| data char	count=2
return	used to continue decoding ||| buffer from buffer to	count=2
return	returns a [ string ||| $list$ string	count=2
return	of the current ||| io	count=1
return	[return] usage of ||| [return]	count=1
function	to the finalizer ||| finalizer	count=2
function	class ||| rat	count=1
args	user-supplied equality predicate ||| bool $list$	count=1
module	corresponding ||| foreign c	count=3
args	scanning the ||| a2 monad a3 monad a4	count=1
module	failed because the ||| system io error	count=4
function	integral type ||| w#	count=1
function	split a type ||| split poly ty con app	count=1
args	value from the ||| io a io b io c	count=2
function	lower limits of ||| bound	count=1
return	exposes io ||| io either ioerror	count=1
function_args	suspends the [function_1] [args_2] ghc only ||| [function_1] [args_2]	count=2
return	original handle ||| handle	count=1
return	elements satisfying ||| $list$ int	count=1
module	allow ||| monad st lazy safe	count=1
return	hgetline ||| string	count=1
args	elements of the ||| $list$ a	count=1
args	signed realfloat value ||| realfloat	count=1
return	into the buffer blocking ||| int buffer	count=1
function	throwerrnoifminus1retrymayblock but discards the ||| errno if minus1retry may block_	count=1
return	of the required ||| io	count=1
function	[function_1] event manager ||| [function_2] [function_1]	count=3
args	monad scanning the ||| a4	count=1
function	flush data [function_2] ||| [function_1] [function_2]	count=1
args	inside a ||| ptr a	count=2
args	nul terminated c string ||| textencoding string $f_2$ cstring	count=1
function	until ||| wait	count=2
return	until a character is ||| io char	count=1
function	filled with ||| calloc	count=1
function	until [function_2] ||| [function_2] [function_1]	count=2
module	in the error ||| system io error	count=2
args	s writes the string ||| string	count=1
module	the ||| bits	count=1
return	except that a handle ||| handle	count=1
module	because the ||| io error	count=2
function	[function_1] limit ||| [function_1] [function_2]	count=5
function	flush all the data ||| flush	count=1
function	mallocarray0 but yields a ||| ptr array0	count=1
args	value ||| io a io	count=2
return	list of [return_2] ||| [return_2] [return_1]	count=1
args	value from the first ||| a io b io	count=2
args	storable values in memory ||| $f_2$ ptr storable io b	count=1
function	conjunction ||| and	count=2
args	executed ||| mvar a $f_2$ a io $tuple_2$	count=1
args	maybe ||| maybe	count=2
function_return	[function_args_1] [return_2] ||| [function_args_1] close readp a [return_2]	count=1
function	[function] the file ||| seek from [function]	count=2
function	the module where ||| info module	count=1
function	unzip6 ||| unzip6	count=1
module	of hdl is ||| ghc io handle	count=3
args	string ie character array ||| string $f_2$	count=1
args	a pointer to a ||| storable $f_2$ ptr storable	count=1
args	scanning the ||| monad a2 monad a3 monad a4 monad	count=1
args	a list of non-options ||| argorder	count=1
return	the io ||| io eq/num	count=1
args	static ||| staticptrinfo	count=2
function	given file ||| get file	count=1
return	merging ||| b' either c c'	count=1
return	[return_1] computation ||| [return_1] [return_2]	count=4
args	the structure is empty ||| foldable	count=2
function	thread for some reason ||| thread	count=1
args	scanning the ||| monad a3 monad a4 monad a5	count=1
function	latin-1 character to the ||| to	count=1
function_return	[function_1] [return_2] an ||| [function_1] mvar mvar a [return_2]	count=1
module	information available for ||| ghc staticptr	count=1
args	number of ||| a int	count=4
function	timeout to fire in ||| timeout	count=1
args	the file handle ||| string maybe handle	count=1
function	additionally if the ||| throw errno if	count=1
return	gets the constructor ||| constr	count=1
function	name ||| min	count=1
function	returning the radix ||| float radix	count=1
args	as ||| string io eq/num io b	count=2
function_args	[function_1] [args_2] in the type ||| [function_1] [args_2] bits	count=3
function	two independent buffers one ||| mk duplex	count=1
module	an io ||| system io error	count=1
args	into a nul terminated ||| $f_2$ cstring io a	count=1
args	passing any value ||| $f_2$ a	count=1
function	the file in ||| open file	count=1
function	get ||| get	count=2
function	radix of the representation ||| radix	count=1
args	a ||| a io	count=2
function	open the [function_2] ||| system io [function_1] [function_2]	count=2
args	is an ||| word#	count=1
args	handle ||| iomode $f_2$ handle io	count=1
args	> string as ||| $f_2$ string string	count=1
function_return	of elements [return_2] ||| [function_1] pool int io [return_2]	count=2
function	adjust the ||| realloc	count=1
function	is about ||| finally	count=1
return	five [return] ||| [return] $tuple_5$ a b	count=1
args	value produced by ||| a $f_2$ a	count=1
module	application of the operator ||| data	count=1
args	in a tvar ||| tvar	count=2
module	get ||| foreign c error	count=1
module	name the upper and ||| prelude	count=1
module	values ||| text show	count=2
module	list and returns the ||| list	count=1
args	the either ||| a c $f_2$ b c either a b	count=1
function	of a given file ||| get file	count=1
args	where the return value ||| io a io b io c	count=2
function	index of ||| constr index	count=1
args	be returned ||| a $f_2$ a io	count=1
return	throw out elements ||| $list$	count=1
return	a word is an ||| word	count=1
return	and ||| newlinemode	count=1
function	by defining left = ||| left app	count=1
function	of that file ||| file	count=2
args	a binary ||| a	count=1
function	the range 0 ||| int to digit	count=1
function	unmasked the normal state ||| unmasked	count=2
module	of the list ||| data list	count=4
module	allocate a fresh memory ||| marshal	count=1
args	equality on stablename that ||| stablename a stablename	count=1
return	f ||| b	count=1
args	function returns ||| $list$ eq	count=1
function	wide ||| peek cwstring len	count=2
module	of the ||| ghc	count=2
return	all elements ||| $list$ int	count=1
args	static pointer as ||| staticptrinfo	count=1
return	a given ||| a	count=1
args	memory pool which gets ||| pool	count=1
return	a user-supplied equality ||| a	count=1
return	all elements satisfying ||| $list$	count=1
return	feed marked inputs through ||| arrowchoice either b	count=1
return	exception ||| exception	count=2
module	ghc only ||| ghc conc io	count=6
function	role of return in ||| return a	count=1
module	and all ||| data bits	count=1
args	associated with a ||| a	count=2
args	like addforeignptrfinalizerenv ||| env foreignptr	count=2
return	arrow and ||| arrow $tuple_3$ b d c	count=1
return	is used to continue ||| from buffer to	count=2
args	a new invariant ||| a	count=2
function	alive at the given ||| ptr	count=2
module	marshal a c string ||| foreign c	count=1
function	a line from the ||| h get line	count=1
args	catch any ioerror ||| ioerror ioerror io a	count=1
return	; the copied areas ||| io	count=1
args	mapmaybe ||| maybe	count=1
function	strict one ||| strict	count=1
function	its arguments already exists ||| is already exists	count=1
function_return	[function_1] asynchronous exceptions ||| [return_2] [function_1]	count=2
module	the same ||| ghc exts	count=1
function_args	for modifying [args_2] ||| [args_2] [function_1]	count=1
args	[args_1] and ||| [args_2] [args_1]	count=4
return	the number ||| io $tuple_2$ int	count=2
module	same size as ||| ghc exts	count=1
module	to a pair of ||| data	count=1
module	unrecognized options and ||| system console	count=1
module	area with a ||| utils	count=1
function	computes the sum ||| sum	count=2
function	the radix ||| radix	count=1
return	the io monad and ||| io	count=1
function	supports seek operations ||| seekable	count=1
function	throw ||| throw	count=9
return	i from the ||| seekmode	count=2
args	a structure ||| b b foldable a	count=6
module	a c byte ||| c string	count=1
return	a type constructor ||| $tuple_3$ tycon	count=1
args	with a ||| $f_2$ b c arrow c	count=1
return	return the ||| io	count=1
module	eventlog profiling ||| debug trace	count=1
args	pool to the ||| pool	count=1
module	option ||| system console getopt	count=1
args	a ||| a $list$ a	count=1
return	exposes io ||| io	count=1
module	the traceio function outputs ||| debug	count=1
function	encoding of the ||| encoding	count=1
return	the argument arrow ||| arrow $tuple_3$ b	count=1
args	in the pool to ||| pool ptr a int	count=1
module	promotable proxy type ||| proxy	count=1
function	if the ||| errno if	count=1
function	div to ||| div'	count=1
module	of ||| data char	count=5
function	throwerrnoifminus1retrymayblock but discards ||| minus1retry may block_	count=1
return	the number of the ||| io $tuple_2$ int	count=2
function	the int ||| mk int	count=1
return	a string up into ||| string	count=2
return	list ||| io $list$	count=1
return	the first computation is ||| io c	count=2
module	device ||| ghc io device	count=1
module	promotable proxy type for ||| proxy	count=1
module	modified ||| concurrent mvar	count=1
function	the current locale ||| get locale	count=2
function	separator ||| separator	count=1
function	managed by hdl ||| h	count=2
function	as hputchar stdout ||| put	count=1
function	splits a ||| split ty	count=1
function	marshal a c string ||| peek cstring	count=1
args	promote a function to ||| a2 a3 a4 r monad a1 monad a2	count=1
function	between the stable pointer ||| stable ptr	count=1
function	to ||| to int	count=1
return	arbitrary monads ||| monad	count=1
module	in decimal notation ||| numeric	count=1
function	is blocked ||| blocked	count=2
args	for the either ||| either a b	count=1
module	as int ||| ghc exts	count=1
args	value typically the left-identity ||| a	count=1
args	type constructor to a ||| tycon $list$	count=1
function	other private ||| private	count=1
module	array ends ||| array	count=1
module	of xs of ||| data	count=2
args	returned ||| a $f_2$	count=1
return	the buffer ||| $tuple_2$ int buffer	count=1
function	extra position to ||| malloc array0	count=1
return	the size needed ||| io ptr storable	count=1
function	of sparks currently in ||| num sparks	count=2
module	it yields the error ||| c error	count=1
function	[function_1] blocked on ||| [function_2] [function_1]	count=4
function	retry execution of ||| retry	count=1
function	query element in ascending ||| elem	count=1
module	was ||| base	count=2
module	an unsigned ||| ghc	count=1
args	encapsulated in a ||| a	count=1
function	quot ||| quot	count=1
args	a ||| b c $list$ a	count=1
args	value from the first ||| a	count=2
args	a value ||| b traversable a	count=1
function_args	right [args_2] ||| bits rotate [function_1] [args_2] bits	count=1
args	an exception predicate to ||| $f_2$ exception maybe b io a	count=1
return	computation ||| io bool	count=3
return	weak pointer ||| io weak	count=1
args	describes a single ||| argdescr a string	count=1
args	of a conversion scheme ||| textencoder estate	count=1
module	list argument ||| list	count=1
args	a ||| $f_2$ ptr a	count=2
args	value of the first ||| a	count=1
function	privilege to perform that ||| permission	count=3
module	create ||| concurrent mvar	count=1
function	and lower limits ||| min bound	count=1
function	name the ||| bound	count=1
function	unmasked the ||| unmasked	count=2
return	character ||| io char	count=1
module	of strings at ||| data	count=2
module	standard ||| system	count=1
function	a list of ||| to list	count=1
args	file handle and file ||| string maybe handle maybe filepath	count=1
return	a circular ||| a	count=1
return	other bits clear ||| bits	count=1
function	and ended by ||| by	count=1
return	true iff the first ||| bool	count=2
return	buffer to ||| buffer word8	count=1
function_args	[function_1] predicate ||| [function_1] [args_2]	count=2
function	function extracts a list ||| to list	count=1
function	string ended early ||| short	count=1
return	a character ||| io char	count=1
function	conjugate ||| conjugate	count=1
module	show ||| text show	count=2
return	hgetline hdl reads ||| string	count=1
function	size of the data ||| set size	count=1
args	value from the first ||| io a	count=2
return	each optdescr ||| optdescr	count=1
function	items to ||| list2chan	count=1
module	in utf-16 ||| io	count=1
module	plus letters of ||| data char	count=1
args	their point-wise combination analogous ||| $list$ e	count=1
args	series of stm actions ||| stm	count=1
function	the radix of the ||| radix	count=1
function	a third value ||| trace show id	count=1
args	free [args] ||| [args]	count=3
return	a ||| a $list$ b	count=3
function	argument right ||| r	count=2
args	like witharray [args_2] ||| [args_1] [args_2]	count=4
module	overloaded ||| list	count=1
args	the given number of ||| timeoutkey int	count=1
args	of non-options a list ||| argorder a $list$ optdescr a $list$	count=1
args	list of non-options ||| argorder a $list$ optdescr a $list$	count=1
function	is a [function_2] ||| [function_1] [function_2]	count=12
args	a pointer ||| storable $f_2$ ptr storable io	count=1
args	argument a pointer ||| $f_2$ ptr storable	count=2
function	[function_1] wide character ||| [function_2] [function_1]	count=2
function	operation is [function_2] ||| [function_2] [function_1]	count=2
args	argument a pointer to ||| $f_2$ ptr storable	count=2
function	lift a precedence-insensitive ||| lift	count=1
args	value produced by the ||| $f_2$ a monad b	count=1
args	promote a function ||| r monad a1 monad a2 monad a3	count=2
args	second argument is executed ||| mvar a $f_2$ a io	count=1
module	hdl ||| handle	count=3
args	a monad scanning ||| a3 monad a4	count=1
return	[return_1] b ||| [return_2] [return_1]	count=1
module	the monoid of ||| data monoid	count=1
function	the file ||| file	count=4
return	the functor ||| functor	count=2
function_args	default [args_2] ||| [function_1] [args_2]	count=1
return	applicable to any monadplus ||| monadplus a	count=1
module	variant of scanr that ||| data list	count=1
function	from the [function_2] ||| [function_2] [function_1]	count=6
module	integral ||| ghc exts	count=2
args	action ||| a	count=2
module	marshal a c ||| c string	count=2
function	a ||| min	count=1
args	value produced by ||| monad a	count=1
module	same as getopt but ||| getopt	count=1
args	return value ||| io a	count=2
return	and merging their outputs ||| arrowchoice either b b'	count=1
return	into a haskell string ||| io string	count=7
args	explicit length ||| textencoding cstringlen	count=1
function	to ||| to	count=21
args	structure but with strict ||| b b foldable	count=1
return	finite list into a ||| a	count=1
function	split a ||| split poly ty con	count=1
function	[function_1] end ||| [function_1] [function_2]	count=2
args	witharray but a ||| ptr storable io	count=1
args	a monad scanning ||| monad a2 monad a3 monad a4 monad a5	count=1
return	or nothing if the ||| maybe	count=1
return	tvar to [return_2] ||| [return_1] [return_2]	count=1
args	of storable values in ||| storable $f_2$ ptr storable	count=1
function_return	[function_1] arrow ||| [function_1] [return_2]	count=1
function	until [function_2] ||| [function_1] for [function_2] handle	count=1
function	a file using ||| with binary file	count=1
module	the representation of ||| system io	count=1
function_return	[function_1] [return_2] ||| [function_1] leading zeros finitebits [return_2]	count=1
function	1 mfilter ||| mfilter	count=1
module	io ||| io encoding	count=2
function	a foreign call ||| foreign call	count=2
function	to offset ||| relative seek	count=2
return	is set to i ||| seekmode	count=3
module	[module] structure ||| [module]	count=2
args	number of ||| word8 int	count=1
return	[return_1] to true ||| [return_2] [return_1]	count=4
module	[module_1] the combination ||| [module_1] [module_2]	count=5
function	the recover function ||| recover	count=2
function	lower limits of a ||| min	count=1
return	a stablename [return_2] ||| [return_2] [return_1]	count=4
return	predicate and a ||| maybe a	count=1
return	after the action has ||| io	count=1
function	[function_1] sparks ||| [function_2] [function_1]	count=3
function	total number of bytes ||| bytes	count=1
module	position of hdl is ||| io handle	count=1
function	insert ||| insert by	count=2
args	x ||| int	count=1
function	haskell character to ||| to	count=3
args	handle connected to ||| handle	count=2
function	marshal a c ||| peek cstring	count=1
return	of io actions ||| io	count=2
function	pure instance of show ||| show	count=2
args	monad scanning ||| monad a2 monad a3 monad a4 monad	count=1
function	blocked in retry in ||| blocked on	count=2
return	but returns a ||| $list$ string	count=1
function	list [function] and ||| cat [function]	count=1
return	returns a tuple where ||| a	count=1
function	like bracket [function] ||| bracket [function]	count=2
module	copies ||| utils	count=1
function	satisfying ||| munch1	count=1
function	file ||| binary file	count=2
function_args	[function_1] x returns ||| [function_1] [args_2]	count=2
args	a list of ||| b res $list$ a $f_2$ $list$ b	count=1
return	string which is ||| string	count=1
args	catch any ioerror ||| ioerror ioerror	count=1
args	a binary function ||| c applicative a applicative	count=1
args	not satisfy the predicate ||| $f_2$ a bool $list$ a	count=1
args	with ||| $f_2$ b c arrow	count=1
function	throw ||| throw io	count=2
function_return	represent the [return_2] ||| [function_1] [return_2]	count=8
function	to the corresponding ||| cast cchar to	count=1
args	gets ||| constr	count=4
args	realfloat value to ||| realfloat	count=1
function	splits a type ||| split ty con	count=1
module	and and ||| data	count=1
args	character ch to ||| char	count=1
args	a c string ||| string $f_2$	count=1
args	list of storable values ||| storable io b	count=1
args	like witharray but ||| storable $list$ storable $f_2$ ptr storable io b	count=1
function	unset name removes the ||| unset	count=1
function	same ||| bit	count=1
return	the result value of ||| a	count=1
function_return	[function_1] associativity of ||| [function_1] [return_2]	count=2
return	the finalizers ||| io	count=2
args	given number ||| timeoutkey int	count=1
args	conversion scheme between sequences ||| dstate io textencoder estate	count=1
args	witharray but a terminator ||| ptr storable io	count=1
function	unicode general category ||| general category	count=2
function	passed to the finalizer ||| add foreign ptr finalizer	count=2
module	from an mvar ||| control concurrent	count=1
return	until a character ||| io char	count=1
function	the denominator ||| denominator	count=1
function_return	[function_1] a ptr ||| [return_2] [function_1]	count=1
function_return	[function_1] constructor ||| [function_1] typerep [return_2]	count=2
function	stack ||| stack	count=5
function	[function_1] bytes ||| [function_2] [function_1]	count=1
function	of a third value ||| id	count=1
return	haskell string ||| string	count=4
function	splitat n xs ||| split at	count=1
module	and columns ||| list	count=1
args	loop [args] interrupted ||| [args]	count=1
args	pointer to ||| ptr storable	count=2
function	wide ||| peek cwstring	count=2
return	computation to ||| io	count=1
args	given number of ||| timeoutkey int	count=1
args	a ||| b c d e f g $list$ a	count=1
return	whether the ||| io $tuple_2$	count=1
args	given [args_2] ||| marshal array copy array [args_1] [args_2]	count=4
function	the same size as ||| w#	count=1
module	for the capability ||| ghc event	count=1
return	[return_1] hgetline hdl ||| [return_1] [return_2]	count=1
function	char [function_2] ||| [function_1] [function_2]	count=1
function	the contents of the ||| contents	count=1
args	number ||| int timeoutcallback	count=2
module	lift ||| parsercombinators readprec	count=1
args	[args_1] the structure ||| [args_2] monad [args_1]	count=1
return	the original handle with ||| io handle	count=1
module	variable from the environment ||| system environment	count=1
function	the exception ||| exception	count=1
function	sort function ||| sort	count=1
args	value typically the left-identity ||| b $list$ a	count=1
function_return	in class [return_2] ||| [function_1] rational [return_2]	count=1
args	argument a pointer ||| ptr storable io b	count=2
module	list ||| data list	count=5
args	a signed realfloat value ||| int realfloat	count=3
return	the precedence context to ||| readprec a	count=1
function	duplicate of ||| h duplicate to	count=1
module	a list [module_2] ||| [module_2] [module_1]	count=5
module	indicates where the array ||| array	count=1
args	to non-empty ||| $f_3$ a a	count=1
module	point of the ||| data	count=1
module	two argument arrows ||| control arrow	count=2
return	weak pointer [return_2] ||| [return_1] [return_2]	count=1
return	magnitude phase pair in ||| $tuple_2$	count=1
args	is a reverse application ||| $f_2$ a	count=1
function	stable pointer ||| stable ptr	count=3
return	reads a single ||| reads string	count=2
module	error ||| exception base	count=1
args	that takes an exception ||| exception maybe b	count=1
return	monadic fold ||| monad b	count=2
module	version of !!, ||| data	count=1
args	six-tuples ||| a b c d e f	count=1
function	a file that may ||| regular file	count=1
function	finalizer cf foreignptr for ||| finalizer	count=1
return	[return_1] stablename for ||| [return_2] [return_1]	count=4
module	value [module] ||| [module]	count=4
function_return	[function_1] of value ||| [function_1] int [return_2]	count=1
function_args	of show [args_2] ||| [function_1] [args_2]	count=1
function	[function_1] supplied write ||| [function_2] [function_1]	count=1
function	float ||| float	count=1
args	list of storable ||| ptr storable io	count=1
args	same as x ||| bits	count=1
return	just a computation to ||| io a	count=1
function	is executed before retrying ||| retry may block	count=1
function_args	[function_1] the static ||| [function_1] [args_2]	count=1
function	monad join operator ||| join	count=1
function	is used to ||| min bound	count=1
args	where the return value ||| a	count=2
function_return	[function_1] [return_2] ||| [function_1] statickey [return_2]	count=3
args	predicate and two ||| bool $list$	count=1
function	by returning the indices ||| indices	count=1
module	[module_1] was ||| [module_1] [module_2]	count=8
args	monomorphic type constructor to ||| tycon $list$	count=1
module	occur in the ||| data	count=1
return	and combine their output ||| arrow b $tuple_2$ c c'	count=1
return	the action has finished ||| io	count=1
return	the number ||| int bool	count=3
function	[function_1] locale ||| [function_2] [function_1]	count=2
function	returns a duplicate of ||| duplicate	count=1
module	of elements ||| data	count=3
args	value from ||| a io b io c	count=2
function	looks up ||| unsafe lookup	count=1
return	finalizer [return] ||| [return] foreignptr	count=2
return	is a complex ||| complex floating	count=1
function	input is available on ||| input	count=2
module	an array ||| marshal array	count=1
return	a nul terminated c ||| cstring	count=1
function_args	the find [args_2] ||| [function_1] [args_2]	count=3
module	the representation of ||| io	count=1
args	pointer to a temporarily ||| $f_2$ ptr	count=2
return	mkweak where ||| weak k	count=2
return	reads an [return_2] ||| [return_2] [return_1]	count=2
function	natural [function] word ||| natural [function] word	count=1
args	specified number ||| int	count=4
module	of strings at ||| data string	count=1
args	string using temporary ||| textencoding string $f_2$	count=1
function_args	suspends the [function_1] [args_2] only ||| [function_1] [args_2]	count=2
return	merging their ||| b b' either c	count=1
module	the end of file ||| io error	count=1
args	witharray but a terminator ||| $list$ storable $f_2$ ptr storable io b	count=1
return	the handler is ||| io	count=2
args	a reverse application ||| $f_2$ a b	count=1
return	size of the ||| io ptr storable	count=1
function_args	[function_1] type hierarchy ||| [function_1] [args_2]	count=4
function	behaves like delete ||| delete	count=1
return	true iff the ||| bool	count=2
args	and passes the ||| filepath	count=1
args	nul terminated c string ||| string $f_2$ cstring io	count=1
args	a ||| b b foldable a	count=1
function	the sign of ||| sign plus	count=1
return	the rest through unchanged ||| either c d	count=1
module	and ||| prelude	count=1
args	alwayssucceeds adds a ||| a	count=2
return	a user-supplied equality ||| $list$ a	count=1
args	signed [args_2] ||| [args_1] [args_2]	count=8
function	the exception type ||| exception	count=1
function_return	[function_args_1] [return_2] act ||| [function_args_1] [return_2] r	count=8
args	openfile and [args_2] ||| [args_2] [args_1]	count=1
return	returning a final value ||| a	count=1
return	and non-options ||| argorder a	count=2
return	which occur within a ||| either ioerror a	count=1
args	user-supplied equality predicate instead ||| $f_3$ a a bool $list$ a	count=1
function	the end of ||| end	count=2
function	[function_1] on ||| [function_1] indefinitely [function_2]	count=6
args	convert from the representation ||| rep	count=1
function	into a foreign ||| new foreign	count=1
function	foreign ||| new foreign	count=1
return	a handle ||| io handle	count=1
function	pair ||| mk weak pair	count=2
return	tvar [return_2] ||| [return_2] [return_1]	count=1
return	that it ||| reads	count=1
function	its arguments does ||| does	count=1
module	value [module] list which ||| [module]	count=1
function	raw mode where ||| set raw	count=1
return	used to ||| io $tuple_2$ buffer from buffer to	count=2
function	bits preceding the most ||| leading	count=1
return	in the target ||| io	count=1
module	maximum value [module] list which ||| [module]	count=1
module	releases ||| foreignptr safe	count=1
return	buffer ||| io buffer word8	count=1
function	[function] on ||| thread wait [function]	count=3
function	to ||| to cschar	count=1
function	marshal ||| cstring len	count=2
return	merging ||| b'	count=1
function	the real [function_2] ||| [function_2] [function_1]	count=1
return	monadic ||| monad	count=4
return	parses and returns the ||| readp	count=1
function	action returns nullptr ||| null	count=1
module	monad ||| control exception base	count=1
function	file in ||| open file	count=1
function_args	[function_1] given number ||| [function_1] array pool [args_2]	count=1
function_args	[function_1] string s ||| [args_2] [function_1]	count=2
args	value to be returned ||| a $f_2$ a io	count=1
module	for the current ||| ghc io handle	count=1
function	to run afterward ||| finally	count=1
function	show for ||| h show	count=1
args	storable values ||| storable $f_2$ ptr storable io b	count=1
args	of non-options ||| argorder a $list$	count=1
args	pointer living inside a ||| a io b	count=2
function	sum of ||| sum	count=1
args	analysis for the either ||| b c either a b	count=1
function	a result of -1 ||| minus1	count=1
module	parses p ||| text parsercombinators	count=1
module	size ||| ghc exts	count=2
function	same as x ||| set	count=1
function	calls error ||| error	count=2
args	a signed realfloat ||| int realfloat	count=5
function	flush data from the ||| flush	count=1
args	scanning ||| monad a2 monad a3 monad a4	count=1
return	[return_1] monadic ||| [return_2] [return_1]	count=2
module	io ||| io error	count=3
return	lists ||| $tuple_2$ $list$ a $list$	count=1
function	unzip7 function takes ||| unzip7	count=1
return	to the ||| io ptr	count=1
return	the memory ||| storable	count=2
args	of storable values ||| ptr storable	count=1
args	monad scanning ||| a4	count=1
function_return	[function_1] handle with ||| [return_2] [function_1]	count=1
function_return	read [return_2] ||| [function_1] ioref ioref a [return_2]	count=1
return	build and returns ||| io	count=1
args	scanning ||| a3 monad a4 monad a5	count=1
module	remainder of the ||| data	count=2
function	the float type ||| mk float type	count=2
function	elements of ||| array	count=1
function_args	[function_1] pool which ||| [args_2] [function_1]	count=1
args	this function extracts the ||| foreignptr	count=1
args	mapmaybe function ||| maybe b	count=1
args	to be returned ||| $f_2$	count=1
function	[function_1] permissions ||| [function_1] default [function_2]	count=1
args	a ||| f g $list$ a $list$ b $list$	count=1
args	first argument and ||| $list$	count=1
function_return	signed [return_2] ||| [return_2] [function_1]	count=4
function	passed as ||| unbound thread	count=1
function	an action with a ||| with	count=1
args	as argument a pointer ||| ptr	count=2
function	handle ||| newline mode	count=1
return	stm action that can ||| stm	count=3
args	to a monad scanning ||| monad a3 monad a4 monad	count=1
args	pool which gets automatically ||| $f_2$ pool io b	count=1
module	the c int type ||| foreign c	count=1
function	hdl or for ||| h	count=1
args	exception predicate to select ||| $f_2$ exception maybe b io	count=1
function	separated [function] sep ||| sep [function]	count=1
function_return	the tolist [function_1] [return_2] from the structure l ||| [function_1] [return_2]	count=1
args	any integral ||| integral $list$ a	count=1
args	the given number of ||| ptr a ptr a int	count=2
function	like openfile but [function_1] [function_2] ||| [function_1] [function_2]	count=8
return	function is used to ||| io $tuple_2$ buffer from buffer to	count=2
args	string- > string as ||| $f_2$ string string	count=1
module	which may be ||| ghc	count=1
function_args	[function_1] integral ||| [function_1] index $list$ a [args_2]	count=3
function	throwerrnoifminus1retrymayblock but ||| minus1retry may block_	count=1
function	the unzip4 ||| unzip4	count=1
function	the tolist [function] ||| [function]	count=1
return	to continue decoding in ||| to	count=2
function	[function_1] that capability ||| [function_1] [function_2]	count=1
module	marshal these values ||| marshal pool	count=1
function	lex ||| lex	count=1
return	function takes a ||| $list$ a	count=2
module	a fresh memory ||| pool	count=1
module	an internal function ||| internal	count=1
function_args	[function_1] [args_2] ||| [function_1] gfloat [args_2]	count=10
module	parser into one that ||| text parsercombinators	count=1
module	operation failed because ||| system	count=2
function	[function_1] already being ||| [function_1] [function_2] in use	count=1
module	a ||| exts	count=1
function	truncate ||| truncate	count=1
function	in ordinary blocking ||| blocking	count=1
module	copies the ||| utils	count=1
function	current thread for ||| thread	count=1
args	[args_1] [args_2] swapped around see ||| [args_2] [args_1]	count=2
module	type with the same ||| ghc exts	count=1
args	accepts any integral ||| integral $list$	count=1
args	argument a pointer ||| storable $f_2$ ptr storable	count=1
function	be written to ||| write	count=3
function	turns ||| new	count=1
args	either type ||| c either a	count=1
function	the float [function_2] ||| [function_2] [function_1]	count=1
return	computation hgetbuffering hdl returns ||| io buffermode	count=2
return	a tuple where ||| $tuple_2$ $list$ a $list$ a	count=1
rep	[module_1] [function_args_2] ||| [module_1] register [function_args_2]	count=1
return	hgetbuffering hdl ||| buffermode	count=2
args	given [args] ghc only ||| [args]	count=1
function	name the upper ||| min bound	count=1
function	[function_1] the current ||| [function_2] locale [function_1]	count=1
return	the computation exitfailure ||| io a	count=1
function	an extra element ||| array0	count=1
function	between open ||| between	count=1
function	haskell character to ||| char to cschar	count=1
args	value from the ||| io a io b io	count=2
args	satisfy the predicate ||| $f_2$	count=2
args	data from the handle ||| handle ptr a	count=2
module	because the user ||| io	count=2
module	bytes ||| ghc stats	count=1
module	applied to ||| ghc oldlist	count=1
return	into the ||| io int	count=2
function_return	[function_1] [return_2] ||| system io [function_1] end [return_2]	count=1
function	transpose ||| transpose	count=1
function	be written to a ||| write	count=3
args	[args_1] arguments ||| just [args_2] [args_1]	count=2
return	that didn t ||| $tuple_3$	count=1
function	allocate a fresh memory ||| pool	count=1
args	catch any ioerror that ||| ioerror ioerror io	count=1
return	pair in ||| $tuple_2$ realfloat realfloat	count=1
args	nul terminated c string ||| textencoding string $f_2$ cstring io a	count=1
function	the range 0 ||| digit	count=1
module	values of ||| data	count=1
function_return	[function_1] [return_2] value ||| [function_1] [return_2]	count=4
return	next value ||| a	count=1
function	to ||| cast cchar to	count=1
module	and currency ||| data char	count=1
return	the bool ||| bool	count=1
return	newtvar ||| tvar	count=1
args	is true ||| bool	count=1
args	of bits in ||| bits	count=1
args	witharray but ||| storable $f_2$ ptr storable io	count=1
args	pool to the ||| pool ptr storable	count=1
args	number of values ||| int	count=1
module	exception is raised by ||| exception	count=2
function	s heap is ||| heap overflow	count=2
return	number of ||| int	count=14
return	not pass a ||| a	count=2
function	the sum of ||| sum	count=1
function	part ||| part	count=1
args	the structure ||| foldable applicative a	count=1
function	join operator ||| join	count=1
function	length ||| generic length	count=2
args	promote a function to ||| monad a1 monad a2 monad a3	count=2
function	string [function] ||| with castring [function]	count=3
return	either ||| either	count=2
function	a duplicate of ||| h duplicate	count=1
args	uncurried function to a ||| a b	count=1
function_args	exception type hierarchy ||| some exception e	count=2
args	which is an exception ||| exception maybe b io	count=1
args	pointer to a temporarily ||| ptr storable io	count=2
args	value produced by ||| $f_2$ a monad b	count=1
return	the next character ||| readp char	count=1
rep	array [function_return_2] ||| [module_1] [function_return_2]	count=2
return	true if ||| bool	count=4
module	command-line and return ||| console getopt	count=1
module	useful in situations ||| control exception	count=2
module	a c ||| c string	count=10
function_return	[function_1] fixity of ||| [function_1] [return_2]	count=2
return	bytes into the buffer ||| io $tuple_2$ int buffer	count=1
function	the radix ||| float radix	count=1
function	class method without a ||| method error	count=1
args	structure but with ||| b foldable	count=1
args	non-options ||| argorder a $list$ optdescr a $list$ string	count=2
function	with a fresh ||| with	count=1
module	of all ||| data list	count=2
args	pointer ||| ptr	count=2
args	pointer to a ||| ptr storable io b	count=2
args	elemindex function returns ||| $list$ eq	count=1
args	passing any value ||| $f_2$ a monad b	count=1
function	latin-1 character to ||| to	count=1
function_return	[function_1] real ||| [function_1] reads real reads [return_2]	count=1
args	argument a pointer to ||| ptr storable	count=2
return	returns ||| $tuple_4$ $list$ a $list$ string $list$ string $list$	count=1
module	same size as ||| exts	count=1
args	elements of the ||| bool $list$	count=1
module	of the types defined ||| types	count=1
return	actions from left ||| applicative	count=1
function	use traceevent or traceeventio ||| trace event	count=1
return	the contents of ||| io b	count=1
module	c ||| foreign c	count=28
function	list by the ||| by	count=1
return	number of ||| int bool	count=3
module	to name the ||| prelude	count=1
args	on stablename ||| stablename a stablename b	count=1
args	the representation ||| rep	count=1
module	x ||| bits	count=1
return	thrown when the user ||| errorcall	count=2
return	gets the constructor for ||| constr	count=1
args	of non-options a list ||| argorder a $list$ optdescr a	count=1
return	fixity of a ||| fixity	count=1
function	[function_1] hdl as ||| [function_2] [function_1]	count=2
args	is executed with ||| mvar a $f_2$ a	count=1
function	extra position to ||| array0	count=1
return	the end ||| io ptr	count=1
function	haskell ||| lex	count=1
return	stm action that ||| stm	count=3
function	form the numerator ||| numerator	count=1
module	environment ||| environment	count=1
args	the mapmaybe ||| $f_2$ a maybe	count=1
function	instance of show for ||| h show	count=1
module	is an unsigned ||| ghc	count=1
module	error code eintr ||| error	count=1
args	the ||| ptr storable	count=1
args	change ||| iodevice integer	count=2
module	that ||| sync	count=2
function	field labels ||| constr fields	count=1
module	marshal a c ||| foreign c string	count=2
return	of value ||| ptr a	count=1
return	and b ||| b	count=1
args	constructor to a sequence ||| tycon $list$	count=1
args	realfloat ||| realfloat	count=4
args	the given number ||| int $f_2$ ptr storable io b	count=1
return	argument as a finalizer ||| a	count=2
function	occurrence ||| delete	count=1
args	witharray but ||| storable $list$ storable $f_2$ ptr storable io	count=1
args	the file handle ||| string maybe handle maybe filepath	count=1
args	lifetime ||| lifetime	count=1
function	base specified by ||| int at base	count=1
module	system ||| system io	count=1
module	inject ||| monad instances	count=1
return	but returns [return_2] ||| [return_2] [return_1]	count=7
module	in ||| io	count=1
args	a reverse application ||| a	count=1
return	the unicode ||| textencoding	count=4
module	unsigned ||| ghc	count=1
module	releases ||| foreign foreignptr safe	count=1
args	the given number of ||| int $f_2$ ptr storable io b	count=1
function	current locale ||| get locale	count=1
function	until data is available ||| wait	count=1
function_return	[function_1] a storable ||| [function_1] pool int io [return_2]	count=2
return	[return_1] the ||| [return_2] [return_1] textencoding	count=4
return	the argument arrow and ||| arrow $tuple_3$ b d	count=1
module	appropriate instance was ||| control exception base	count=2
args	a binary ||| $f_3$ a b c applicative a applicative b	count=1
module	device type but a ||| io device	count=1
function	elements ||| array	count=1
return	value of returned tvar ||| tvar	count=1
function	flush data [function_2] ||| [function_2] [function_1]	count=1
return	any monadplus for example ||| monadplus a	count=1
return	the buffer ||| $tuple_2$ int buffer word8	count=1
function	float ||| mk float	count=1
module	was ||| exception base	count=4
function	the thread for ||| thread	count=1
return	a textencoding ||| textencoding	count=1
function	a fresh memory ||| pool	count=1
args	a complex number ||| complex	count=1
module	[module_1] of a ||| [module_1] [module_2]	count=1
module	and columns of its ||| data list	count=1
function	[function_1] until data ||| [function_1] [function_2]	count=4
function	upper ||| bound	count=1
args	over ||| $f_2$	count=2
module	functions from data ||| data ord	count=1
function	other not [function_2] ||| [function_1] [function_2]	count=1
args	the return value from ||| a io b io c	count=2
args	value ||| a $f_2$ a monad b	count=2
module	if eventlog profiling ||| debug	count=3
function	[function_1] bytes ||| [function_1] [function_2]	count=1
function_return	the [function_1] [return_2] l from the structure ||| [function_1] islist [return_2] islist	count=1
args	[args_1] handle ||| [args_2] [args_1]	count=3
module	the encoding may now ||| ghc io encoding	count=2
function	[function] requests ||| [function]	count=3
args	the either type ||| a c $f_2$ b c either	count=1
args	of non-options a ||| argorder a	count=1
function	and merge ||| (|||)	count=1
function	ended by ||| by	count=1
function	foreign ||| add foreign	count=1
function	name ||| bound	count=1
function_args	with [args_2] ||| [args_2] [function_1]	count=1
module	the ||| exts	count=1
function	performs the ||| on	count=1
module	for the ||| ghc event	count=1
args	number within epsilon of ||| realfrac realfrac	count=1
function	allocation [function_2] ||| [function_1] [function_2]	count=7
args	monad scanning the ||| monad a3 monad a4 monad a5	count=1
return	traverse is ||| traversable b	count=1
args	promote a function ||| a1 monad a2 monad	count=2
args	openfile ||| filepath iomode	count=2
function	hdl returns ||| h	count=1
function	unwords is an ||| unwords	count=1
function_args	[function_1] the string ||| [function_1] [args_2]	count=1
function	lift a ||| lift	count=1
args	a ||| d e f g $list$ a	count=1
function	a foreign [function_2] ||| [function_1] [function_2]	count=1
function	is used ||| bound	count=1
return	in the io monad ||| io	count=2
return	handle with its own ||| io handle	count=1
args	predicate and ||| bool $list$ a $list$	count=1
function	returns a duplicate of ||| h duplicate	count=1
args	computation ||| a io b	count=1
return	the io action when ||| io	count=1
function	to wait until data ||| thread wait	count=3
function	character to the corresponding ||| to	count=1
function	a [function] or similar ||| [function] bad	count=1
function	bytes of ||| bytes	count=2
module	for the [module_2] ||| [module_1] [module_2]	count=26
return	to its representation ||| rep generic	count=1
module	the operation failed because ||| system	count=2
function_args	test whether [args_2] ||| [args_2] [function_1]	count=6
function	recover function ||| recover	count=2
args	implementation for testbit ||| bits/num int	count=1
function	of throw that ||| throw io	count=2
function	like catch ||| catch	count=1
module	useful in situations ||| control exception base	count=1
module	the operation failed ||| io error	count=5
return	complex value ||| complex	count=1
module	allocate a ||| pool	count=1
args	the return value from ||| a io b io	count=2
return	the buffer ||| io $tuple_2$ int buffer	count=1
args	been obtained from a ||| a	count=1
return	any monadplus for ||| monadplus a	count=1
function	the ||| bit	count=1
args	a structure to ||| foldable a	count=1
args	with ||| $f_2$ b c	count=1
function	is the same as ||| bit	count=1
function	lower ||| min	count=1
function_return	[function_1] intptr ||| [function_1] ptr ptr a [return_2]	count=1
return	or more ||| alternative $list$	count=1
return	of the ||| io	count=9
function	a thread ||| thread	count=2
function	[function_1] allocation ||| [function_2] [function_1]	count=2
function	the group function ||| group	count=1
return	function returns an ||| $list$	count=1
module	applied to a predicate ||| oldlist	count=1
module	microseconds ghc [module_2] ||| [module_1] [module_2]	count=2
return	of a ||| a b	count=2
function	the group function takes ||| group	count=1
args	the either ||| $f_2$ a c $f_2$ b c either	count=1
function	product of the ||| product	count=1
module	map each element of ||| data	count=1
function	x ||| bit	count=1
args	predicate ||| a bool $list$ a	count=2
function_return	[function_1] i ||| [function_1] [return_2]	count=7
function	file that may be ||| regular file	count=1
args	exception [args_2] ||| [args_2] [args_1]	count=8
args	of storable ||| storable io	count=1
module	the array ||| marshal array	count=1
return	value of the second ||| applicative a	count=1
module	arrow passing ||| arrow	count=1
function	modified version ||| modify	count=1
function	the program attempts to ||| nested	count=1
return	of a ||| ptr a	count=1
args	bool parameter is true ||| bool shows	count=1
function	zip ||| zip	count=1
return	buffer blocking if ||| $tuple_2$ int buffer	count=1
module	alloca ||| foreign marshal array	count=1
args	the ||| $list$ storable	count=1
module	an ioerror corresponding ||| c error	count=3
args	this function ||| foreignptr a	count=1
return	subsequences function returns ||| $list$ $list$	count=1
function	maps ||| map	count=1
args	returned value ||| either someexception a	count=1
function_args	[function_1] number ||| [function_1] array pool [args_2]	count=1
return	the haskell value ||| io a	count=3
args	and ||| a	count=1
args	stablename that ||| a stablename	count=1
args	catch any ioerror that ||| $f_2$ ioerror ioerror	count=1
return	value ||| $tuple_2$ a traversable c	count=1
return	handle to manage ||| handle	count=2
args	a structure ||| b foldable a	count=7
return	gets the ||| constr	count=1
args	openfile and passes ||| filepath iomode	count=2
args	with the arguments ||| $f_2$ a monad b	count=1
module	an applicative functor ||| control applicative	count=1
function	scanr1 is a ||| scanr1	count=1
args	using openfile and ||| filepath iomode $f_2$	count=3
return	of the given ||| io ptr	count=2
args	a ||| a b c d applicative a applicative	count=1
function	in ||| fmt	count=1
args	using openfile ||| iomode $f_2$	count=2
args	like witharray but a ||| storable $list$ storable $f_2$ ptr storable io b	count=1
args	the either ||| $f_2$ b c either a	count=1
function	[function] handle ||| h wait for [function]	count=1
function	defining left ||| left	count=1
module	is the same ||| bits	count=1
module	[module_1] types ||| [module_1] [module_2]	count=16
function	marker to the ||| marker	count=1
args	[args] bits otherwise ||| bits [args]	count=3
function	as ||| set bit	count=2
function	error messages ||| get opt'	count=1
function_args	suspends the current [function_1] [args_2] only ||| ghc conc [function_1] delay [args_2]	count=2
args	a monad scanning the ||| a2 monad a3 monad a4	count=1
return	to actions ||| applicative b	count=1
return	or nothing if ||| maybe	count=3
return	that the ||| a	count=1
function	is a [function_2] ||| [function_2] [function_1]	count=12
function	combine the results ||| fold	count=1
function	char type ||| mk char type	count=2
function_return	a list [return_2] ||| [function_1] islist [return_2] islist	count=3
function	with a fresh memory ||| with	count=1
module	have direct support for ||| ghc	count=1
return	character is available ||| io char	count=1
return	value passed to mkweakpair ||| v	count=1
function	scanr1 ||| scanr1	count=1
module	a fresh ||| foreign marshal pool	count=1
return	the supplied ||| io	count=1
module	into a list ||| list	count=2
args	a list of ||| b res $list$ a $f_2$ $list$	count=1
args	structure ||| b foldable	count=9
args	a reverse application ||| a b	count=1
function	an stm transaction but ||| stm	count=1
function	to name ||| bound	count=1
args	equality predicate instead ||| bool	count=1
return	any monadplus ||| monadplus	count=1
args	discarding any value ||| monad a	count=1
module	upper and lower limits ||| prelude	count=1
return	[return_1] b ||| [return_1] [return_2]	count=1
function	begins empty but data ||| dup chan	count=1
return	rational ||| rational	count=1
module	element of a ||| data traversable	count=1
function	the stable pointer ||| free stable ptr	count=1
return	of lists ||| $list$ b $list$	count=1
args	value produced by ||| a $f_2$ a monad b	count=1
module	the two argument arrows ||| control arrow	count=1
function	of geterrno ||| errno	count=4
return	the rest through unchanged ||| c d	count=1
args	rational value into any ||| rational	count=1
return	[return_1] stm action ||| [return_2] [return_1]	count=3
return	used as a ||| a	count=1
args	arrow ||| arrow b c	count=1
module	the combination of ||| utils	count=1
module	[module_1] can only ||| [module_2] [module_1]	count=1
function	[function_1] and rem ||| [function_1] [function_2]	count=1
return	associativity of ||| associativity	count=1
args	analysis for the either ||| c either a b	count=1
function	filter applied ||| filter	count=1
function	throwerrnoifminus1retrymayblock ||| throw errno if minus1retry may block_	count=1
return	elements of a storable ||| io ptr storable	count=2
function_return	[function_1] unicode encoding ||| [return_2] [function_1]	count=1
return	a value ||| a	count=3
module	list which is equal ||| list	count=1
return	and [return] haskell value ||| [return]	count=1
return	[return_1] [return_2] ||| conc get num capabilities [return_1] [return_2]	count=8
function	of megabytes ||| megabytes	count=1
return	returns ||| io $list$	count=2
module	device if ||| device	count=1
return	elements satisfying the ||| $list$ int	count=1
function	to wait until data ||| wait	count=3
return	the buffer blocking ||| buffer word8	count=1
args	of storable values ||| storable $f_2$ ptr storable	count=1
return	perform a ||| io a	count=1
module	ghc ||| ghc	count=8
function	the current i/o position ||| get	count=2
module	non-overloaded version of ||| data list	count=1
function_return	[function_1] [return_2] ||| [function_1] int $list$ a [return_2]	count=7
args	using openfile and passes ||| filepath iomode $f_2$	count=1
return	to stderr and ||| a	count=1
function	from the end ||| from end	count=6
return	returns an [return_2] ||| [return_1] [return_2]	count=9
function	not fully handled ||| try ioerror	count=1
module	error ||| ghc stack	count=1
function	bytes copied each gc ||| bytes copied	count=1
args	list of non-options a ||| argorder a $list$ optdescr a $list$ string	count=1
module	between the two argument ||| control	count=1
args	a ||| a $list$ b $list$	count=2
return	feed marked inputs through ||| arrowchoice either b d either	count=1
function	open [function_2] ||| system io [function_1] binary [function_2] filepath iomode io handle	count=2
args	type where the ||| ioerrortype string maybe	count=1
module	ioerror corresponding ||| foreign c	count=3
args	the pool to ||| pool ptr storable	count=1
args	an abstract type ||| threadid#	count=2
function_return	a duplicate [return_2] ||| [return_2] [function_1]	count=1
args	any value produced ||| monad a monad	count=1
return	in the io ||| io a	count=3
args	explicit length information ||| $f_2$ cstringlen	count=2
args	convert an int in ||| int	count=1
function	the int ||| int	count=1
args	handle and file path ||| maybe handle	count=1
args	not satisfy the predicate ||| $f_2$	count=1
args	pointer to ||| ptr storable io b	count=2
function	format string ||| format	count=1
args	the resulting handle to ||| handle io r	count=1
function	mutator threads ||| mutator	count=1
function	storage for ||| pooled new	count=1
args	pool which gets ||| pool io	count=1
return	returns the number of ||| int	count=7
function	to mallocarray0 but ||| ptr array0	count=1
module	time ||| ghc	count=1
args	equality on stablename ||| stablename	count=1
return	traverse ||| applicative traversable	count=1
args	[args_1] a ||| [args_2] [args_1]	count=1
args	algebraic datatypes only ||| datatype conindex	count=1
args	[args] ghc only ||| [args]	count=4
args	of non-options a ||| argorder	count=1
return	function is used to ||| buffer from buffer to	count=2
args	in the pool to ||| pool ptr a	count=1
function_return	[function_1] [return_2] ||| wait [function_1] fd [return_2]	count=3
return	next character ||| char	count=1
args	out to ||| bufferedio	count=1
return	a stablename ||| stablename a	count=2
module	ex ||| control exception	count=1
function	a prefix [function_2] ||| [function_2] [function_1]	count=3
module	a nul terminated c ||| c	count=2
return	the datatype ||| datatype	count=1
function	items ||| list2chan	count=1
args	like witharray but ||| storable $f_2$ ptr storable io b	count=1
function	adjust the size of ||| realloc	count=1
return	staticptr ||| io maybe staticptr	count=1
args	monad scanning the ||| a4 monad	count=1
return	the number of ||| int	count=10
args	to a ||| a monad b traversable a	count=2
function	string [function] temporary storage ||| with cstring [function]	count=1
module	components of magnitude ||| data	count=1
return	type constructor application ||| $tuple_2$ tycon $list$ typerep	count=2
return	make a weak pointer ||| weak	count=1
module	allocate ||| foreign	count=1
function	format string ended early ||| short format	count=1
function	[function] associates a ||| [function]	count=2
module	and marshal [module_2] ||| [module_2] [module_1]	count=4
args	the either ||| either a	count=1
return	a string ||| $list$ string	count=2
function	memory is [function] ||| [function]	count=3
module	of magnitude and ||| data	count=1
module	of a type ||| prelude	count=1
function	block ||| block	count=1
function	slides the [function_2] ||| [function_2] [function_1]	count=3
args	witharray but a ||| $list$ storable $f_2$ ptr storable io	count=1
args	but ||| io b	count=2
module	with ||| foreign marshal pool	count=1
return	[return_1] supplied value ||| [return_1] mvar [return_2]	count=1
function	file in ordinary ||| file	count=1
module	arrows and ||| arrow	count=1
module	indicating that an io ||| io	count=2
function	type ||| type	count=14
return	character is ||| char	count=2
args	element in the pool ||| pool ptr a int	count=1
module	indicating that an io ||| system io	count=2
function	integral ||| w#	count=1
module	accents and the like ||| data char	count=1
args	the file handle ||| maybe handle maybe	count=1
args	a fresh memory pool ||| pool io b	count=1
args	a pointer to ||| ptr storable io b	count=2
function_args	show [args_2] ||| [function_1] ffloat alt maybe [args_2]	count=3
args	value typically the left-identity ||| b a b b $list$ a	count=1
module	the given parser ||| parsercombinators	count=1
function_return	[function_1] chan ||| [function_1] io [return_2]	count=1
return	of the ||| io maybe	count=1
function_return	the tolist [function_1] [return_2] the structure l ||| [function_1] [return_2]	count=1
function	[function_1] allocation limit ||| [function_1] [function_2]	count=2
return	the representational equality ||| maybe coercion	count=1
function	[function_1] call stack ||| [function_2] [function_1]	count=1
args	describes a single ||| $list$ string argdescr a string	count=1
function	merge ||| (|||)	count=1
function_args	temporary storage [function_1] [args_2] ||| [function_1] [args_2]	count=1
return	computation into a ||| s a	count=3
module	a foreign ||| foreign	count=1
module	a value into ||| foreign	count=1
function	as the index ||| index	count=1
return	[return_1] of the ||| [return_2] [return_1]	count=12
function	with asynchronous exceptions masked ||| masked	count=1
function	bytes [function_2] ||| [function_1] [function_2]	count=4
args	characters ||| char bool	count=2
args	discarding any value produced ||| a monad	count=1
module	allow ||| st lazy	count=1
return	written and also may ||| iodevicetype	count=1
module	for the specified ||| ghc io handle	count=1
args	any value ||| monad a	count=1
module	be marshalled to or ||| ghc exts	count=1
function	handle to a thread ||| thread	count=2
function	run sparks ||| run sparks	count=1
module	chainl ||| text parsercombinators readp	count=1
return	duplicate a [return_2] ||| [return_2] [return_1]	count=8
args	is executed with ||| mvar a $f_2$ a io $tuple_2$	count=1
args	maybe value ||| maybe	count=1
return	mkweak where the value ||| weak k	count=1
args	complex number and ||| complex	count=1
args	structure is ||| foldable	count=2
module	position of hdl ||| handle	count=1
module	open ||| data char	count=1
return	integer and ||| $tuple_2$ integer	count=2
function	is programmer-defined ||| user	count=1
function	numerator and denominator ||| numerator	count=1
module	there was an ||| control	count=1
module	of magnitude and phase ||| data complex	count=1
function	thread for some ||| thread	count=1
args	function takes ||| $f_2$ a bool $list$	count=1
function	this accumulator together with ||| accum l	count=2
args	of non-options a ||| argorder a $list$	count=1
module	has ||| ghc conc sync	count=1
return	words breaks a string ||| $list$ string	count=1
function	get the current value ||| get	count=1
function	already being used ||| already	count=3
args	accepts any integral ||| integral	count=1
return	to actions ||| applicative	count=3
function	similar to mallocarray0 but ||| ptr array0	count=1
args	a finite ||| a	count=1
args	file descriptor ghc ||| fd	count=2
args	a binary function to ||| b c applicative a applicative b	count=1
args	a ||| e f g $list$ a $list$ b	count=1
function	mallocarray0 ||| foreign ptr array0	count=2
return	tryioerror comp exposes io ||| io	count=1
module	parses ||| text parsercombinators	count=1
module	and all other ||| data bits	count=1
function	channel managed by hdl ||| h get char	count=2
args	witharray but a terminator ||| storable $list$ storable $f_2$ ptr storable io	count=1
return	returns a ||| a	count=1
return	traverse with its arguments ||| applicative traversable b	count=1
args	an exception ||| exception maybe b io a	count=1
function	polar ||| mk polar	count=2
module	a fresh ||| marshal	count=1
module	same size as int ||| ghc exts	count=1
args	to a monad scanning ||| monad a3 monad a4 monad a5	count=1
return	complex value with ||| complex floating	count=1
function	given foreign object ||| foreign ptr	count=1
function	ascii hexadecimal digits ||| hex digit	count=1
return	in the current ||| io	count=1
args	value ||| io $tuple_2$ a b	count=1
return	merging their outputs ||| arrowchoice either b b' either c	count=1
module	hdl is ||| handle	count=3
return	argument arrow and ||| arrow $tuple_3$ b d	count=1
function	stable ||| free stable	count=1
function	related functions ||| false	count=1
function	maximum number of bytes ||| bytes	count=1
function	use traceevent or ||| event	count=1
module	if so [module] context ||| [module]	count=1
args	storable values ||| storable io	count=1
function_args	suspends [function_1] [args_2] ghc only ||| ghc conc [function_1] delay [args_2]	count=2
args	a ||| f g $list$ a $list$ b	count=1
function	[function_1] given file ||| [function_2] [function_1]	count=2
function_args	[function_1] the string ||| [args_2] [function_1]	count=2
return	key value pairs ||| $tuple_2$ string	count=1
function	or channel managed by ||| h get char	count=2
function	which accepts any ||| generic	count=2
module	the c int type ||| c	count=1
args	promote a function to ||| r monad a1 monad a2 monad a3 monad	count=1
args	this is ||| foreignptr a $f_2$ ptr	count=2
return	a fresh memory pool ||| io pool	count=1
function	div to any instance ||| div'	count=1
function_return	bytes of [return_2] ||| [return_2] [function_1]	count=2
args	a ||| e $list$ a $list$ b	count=1
args	list ||| $list$	count=2
module	releases ||| foreign foreignptr	count=1
return	perform a series ||| a	count=1
module	nul terminated c ||| c	count=2
return	function reads a ||| reads string	count=2
args	number ||| word8 int	count=2
return	is traverse with ||| applicative traversable	count=1
args	given [args_2] ||| [args_2] [args_1]	count=14
args	a binary ||| c applicative a applicative b	count=1
return	elements of a ||| a	count=2
module	allocate ||| marshal pool	count=2
args	the ||| storable int	count=1
args	the structure is ||| foldable a	count=2
args	the number of ||| int	count=1
return	into the buffer ||| $tuple_2$ int buffer	count=1
args	with a pure function ||| $f_2$ c	count=1
module	the ||| system io error	count=7
module	sequence of types ||| data typeable	count=2
return	associativity ||| associativity	count=1
args	witharray ||| ptr storable	count=1
function	but [function] ||| [function] binary	count=1
module	xs of length n ||| data	count=1
args	for the either type ||| $f_2$ a c $f_2$ b c either a	count=1
args	scanning the ||| monad a4 monad	count=1
function	to an ||| to	count=2
function_return	[function_1] may ||| [function_1] [return_2]	count=3
return	retagging and merging their ||| b' either c c'	count=1
return	occur within a ||| a	count=1
function_args	a file [args_2] ||| [function_1] filepath [args_2]	count=1
return	[return_1] f ||| [return_2] [return_1]	count=4
function	of ||| bound	count=1
args	in the pool to ||| pool ptr	count=2
return	unicode encoding ||| textencoding	count=3
args	a structure but with ||| b b foldable a	count=1
args	structure to ||| monad b foldable	count=2
module	[module_1] of strings ||| [module_1] [module_2]	count=4
function	[function_1] the file ||| [function_2] [function_1]	count=1
args	action [args_2] ||| [args_2] monad [args_1]	count=1
return	the number of the ||| int bool	count=3
function	[function_1] call ||| [function_2] [function_1]	count=2
function	function drops the given ||| strip	count=1
args	given number of elements ||| storable ptr storable int	count=2
return	using ||| maybe	count=1
function	shift the ||| shift	count=5
function	[function_1] [function_2] ||| [function_2] [function_1] filepath iomode io handle	count=8
function_args	hputstr hdl [args_2] ||| [function_1] [args_2]	count=1
args	but ||| io	count=1
return	[return_1] to continue ||| [return_1] [return_2]	count=6
args	handle ||| $f_2$ handle	count=1
return	on [return] ||| [return]	count=1
return	tvar [return_2] ||| [return_1] [return_2]	count=1
function	connected to a terminal? ||| terminal device	count=2
function_return	the [function_1] [return_2] ||| system io [function_1] from end [return_2]	count=1
return	a computation and which ||| a	count=1
function_args	duplicate of [args_2] ||| [function_1] [args_2]	count=1
return	a parser for versions ||| readp version	count=1
args	storable values ||| $f_2$ ptr storable io b	count=1
return	buffer ||| int buffer word8	count=1
function	[function_1] of the ||| [function_2] [function_1]	count=3
return	number of the ||| $tuple_2$ int bool	count=3
return	reference into a ||| a	count=1
return	and [return_2] ||| [return_2] [return_1]	count=2
args	readparen [args] p ||| [args]	count=1
function	storage ||| pooled new	count=1
return	a container ||| a	count=1
return	the rest through unchanged ||| b d either c d	count=1
function	hdl as a value ||| h	count=1
function	blocked on a ||| blocked on	count=2
function	split ||| split poly ty	count=1
function_args	[function_1] the ||| [args_2] [function_1]	count=9
module	bit ||| data bits	count=1
function	extracts the real part ||| real part	count=1
function	the stable pointer ||| stable ptr	count=1
args	to non-empty ||| $f_3$	count=1
module	c int ||| c	count=1
function	all permutations ||| permutations	count=1
module	[module_1] io ||| [module_2] [module_1]	count=1
function	radix of ||| radix	count=1
function_args	[function_1] static pointer ||| [args_2] [function_1]	count=3
args	the return value ||| io a io	count=2
function	[function_1] exceptions ||| [function_1] [function_2]	count=1
args	type where the second ||| ioerrortype string maybe	count=1
function_return	the [function_1] [return_2] the structure l ||| [function_1] islist [return_2] islist	count=1
module	in ||| marshal	count=1
args	either type ||| c either	count=1
args	hsetbuffering ||| buffermode	count=1
args	in a ||| a monad b b foldable a	count=1
args	a ||| a b c d applicative a	count=1
module	a c wide ||| foreign c string	count=1
module	the operation failed ||| system io	count=5
args	the ||| ptr a	count=1
module	mode for ||| ghc	count=1
args	arguments ||| $f_2$ a monad b	count=1
module	of the ||| data dynamic	count=2
function	is ||| h is	count=2
return	a final value ||| a traversable	count=1
return	this variant ||| foreignptr	count=1
return	either result which is ||| either	count=2
module	the utf-32 ||| system io	count=4
args	catch with the arguments ||| $f_2$	count=2
module	used to name the ||| prelude	count=1
return	in the current thread ||| io	count=1
function	allocation ||| set allocation	count=1
return	fixity of a constructor ||| fixity	count=1
function	strict ||| strict	count=1
function	error where the operation ||| error	count=4
function	an index ||| index	count=1
return	original handle with ||| handle	count=1
return	[return_1] supplied value ||| [return_1] [return_2]	count=1
module	of strings ||| data string	count=1
return	threadid is ||| threadid	count=2
args	two ||| b	count=1
function_return	[function_args_1] the computation ||| [return_2] [function_args_1]	count=4
return	its representation ||| rep	count=1
function_args	[function_1] [args_2] ||| [function_1] [args_2]	count=677
args	or a returned value ||| someexception a	count=1
function	sets the position of ||| set posn	count=2
function	of the ||| of	count=1
args	file handle and ||| string maybe handle	count=1
function	not assigned ||| not assigned	count=1
function	actually a pair of ||| mk weak pair	count=1
module	text ||| encoding	count=1
args	with a pure ||| $f_2$ c d arrow b c	count=1
return	in arrow ||| arrow b b	count=1
args	witharray ||| storable	count=1
function	the module where the ||| sp info module	count=1
args	inside a ||| a	count=2
return	a series ||| a	count=1
args	the either type ||| c $f_2$ b c either a b	count=1
module	failed because the ||| io error	count=2
function	passed as the ||| unbound thread	count=1
args	list of storable values ||| storable $f_2$ ptr storable io b	count=1
return	as an integer ||| integer	count=1
function	size as int ||| w#	count=1
module	combination of malloc ||| utils	count=1
function	read an unsigned ||| read dec	count=1
args	but with the arguments ||| $f_2$	count=1
args	an action ||| $f_2$	count=1
function	[function] the ||| h [function]	count=1
return	staticptr by ||| maybe staticptr	count=1
module	parser combinators for precedence ||| parsercombinators readprec	count=1
function	[function_1] allocated | ||| [function_2] [function_1]	count=4
args	the either type ||| $f_2$ a c $f_2$ b c either a	count=1
module	error code eintr - ||| c error	count=1
return	but returns a quadruple ||| string $list$ string $list$ string	count=1
function	sort ||| sort by	count=1
return	a type constructor application ||| tycon $list$ kindrep $list$ typerep	count=1
args	stablename ||| a stablename b	count=2
function	used to name ||| min	count=1
function	limits ||| bound	count=1
args	the structure is empty ||| foldable a	count=2
return	the io action ||| io	count=5
function_return	[function_1] [return_2] an ||| [function_1] [return_2]	count=1
args	a binary ||| a b c applicative a applicative	count=1
return	within a computation ||| either ioerror a	count=1
args	passing any value produced ||| a monad	count=1
return	[return_1] [return_2] ||| [return_2] [return_1] textencoding	count=4
args	the given ||| ptr storable ptr storable	count=2
function	like catch but it ||| catch just	count=1
args	isprefixof ||| eq	count=1
args	either ||| either	count=1
args	exception predicate to ||| $f_2$ exception maybe b io a	count=1
function	disable [function_2] ||| [function_2] [function_1]	count=4
return	arrow and ||| arrow $tuple_3$ b	count=1
args	a list of non-options ||| argorder a $list$ optdescr	count=1
args	the given ||| ptr storable	count=2
args	for the given number ||| int $f_2$ ptr storable io b	count=1
function	run afterward ||| finally	count=1
return	the current value ||| io a	count=1
return	io monad and ||| io string	count=1
function	to ||| fd to	count=1
args	predicate ||| $f_2$ a bool	count=6
args	file handle and ||| string maybe handle maybe filepath	count=1
return	the end ||| io	count=1
function	[function_1] already ||| [function_1] [function_2]	count=1
function_args	[function_1] a signed ||| [args_2] [function_1]	count=3
return	buffer blocking ||| buffer	count=1
module	marshal ||| foreign marshal	count=1
function	duplicate channel begins empty ||| dup	count=1
function	throwerrnoifminus1retrymayblock but discards ||| if minus1retry may block_	count=1
args	case no result is ||| io a	count=1
return	the monadic arguments from ||| monad r	count=1
args	well as six ||| f	count=1
args	structure ||| foldable applicative a	count=2
module	utf-32 unicode encoding ||| io encoding	count=1
function	superclass for asynchronous exceptions ||| some async exception	count=1
args	bits ||| bits	count=2
return	io ||| io	count=5
args	either type ||| a c $f_2$ b c either a	count=1
args	file handle and ||| maybe handle	count=1
function	split a type ||| split poly	count=1
function	string ended early ||| error short	count=1
return	a plain memory reference ||| foreignptr a	count=1
return	size of the ||| io	count=2
function_args	read on [args_2] ||| [args_2] [function_1]	count=1
module	command-line and return the ||| console getopt	count=1
module	useful in situations ||| control	count=2
function_return	[function_1] the ||| [return_2] [function_1]	count=15
args	the given number ||| ptr storable ptr storable int	count=2
function	is a suffix of ||| is suffix of	count=1
function_args	show a [args_2] ||| [args_2] [function_1]	count=14
module	the argument arrow ||| control arrow	count=2
args	either ||| c either a	count=1
module	that an [module_2] ||| [module_1] [module_2]	count=16
module	as ||| exts	count=1
return	a weak pointer ||| io weak	count=1
return	complex number [return_2] ||| [return_1] [return_2]	count=1
args	number of values as ||| int ptr	count=1
return	to the computation ||| io	count=1
args	of the [args] hdl as ||| [args]	count=1
args	a ||| a $list$ b $list$ c $list$	count=1
args	user-supplied equality predicate ||| a a bool $list$	count=1
return	the current value ||| a	count=1
function	type with the same ||| w#	count=1
function	string [function] ||| with cstring [function]	count=3
args	monad scanning ||| monad a3 monad a4 monad a5	count=1
module	encoding ||| io encoding	count=1
args	predicate ||| a bool	count=2
module	hdl is ||| io handle	count=3
function	is already being used ||| is already	count=2
args	scanning ||| monad a2 monad a3 monad a4 monad	count=1
args	satisfy the predicate ||| $f_2$ a	count=2
function	t waits ||| for	count=2
args	given marker ||| ptr storable $list$ storable	count=1
args	value to be returned ||| $f_2$ a	count=1
function	hputstr hdl s ||| h put str	count=4
module	is the ||| data	count=1
return	non-options ||| argorder	count=1
return	an either ||| either	count=2
args	action in [args_2] ||| [args_2] monad [args_1]	count=1
function_args	show a [args_2] ||| [function_1] float [args_2]	count=3
return	[return] empty ||| [return]	count=2
args	scanning ||| monad a3 monad a4 monad a5	count=1
function	channel managed by ||| h get char	count=2
args	either ||| $f_2$ a c $f_2$ b c either a	count=1
function	a terminal or console ||| terminal	count=1
return	the thread is waiting ||| blockedindefinitelyonstm	count=1
return	block of memory ||| ptr storable	count=1
module	eventlog if eventlog profiling ||| debug	count=3
function	similar to mallocarray0 ||| array0	count=1
function_return	[function_1] of item ||| [return_2] [function_1]	count=6
return	rest unchanged ||| d	count=1
return	lists such ||| $list$ $list$	count=1
args	storable values in ||| $f_2$ ptr storable io	count=1
return	haskell list ||| $list$	count=1
return	lists such that the ||| $list$ $list$	count=1
function	additionally if ||| if	count=1
module	of an ||| data	count=2
module	to a list ||| list	count=1
return	arrow notation ||| arrow b b	count=1
function	sparks currently ||| sparks	count=2
return	returns an either ||| either	count=1
function	[function_1] representation ||| [function_1] [function_2]	count=6
args	monads ||| monad c $list$ a $list$ b	count=1
function	[function_1] binary mode ||| [function_2] [function_1] filepath iomode io handle	count=2
return	but the io action ||| io	count=1
return	constructor [return_2] ||| [return_2] [return_1]	count=3
function_return	[function_args_1] to actions ||| [return_2] [function_args_1]	count=1
args	static pointer is ||| staticptrinfo	count=1
module	parser ||| parsercombinators readp	count=3
args	> string as its ||| string string	count=1
args	of stm actions ||| stm a	count=1
args	the mapmaybe function ||| a maybe b	count=1
function	[function_1] [function_2] ||| [function_2] [function_1]	count=244
return	st [return_1] [return_2] ||| [return_1] [return_2]	count=1
return	of returned tvar to ||| tvar	count=1
module	types of a ||| data typeable	count=2
module	of microseconds ghc only ||| ghc conc io	count=1
return	reads [return_2] ||| [return_1] [return_2]	count=7
args	[args] value argument ||| [args] a a a	count=4
args	action in the ||| a	count=1
function	field labels ||| fields	count=1
function	upper ||| min bound	count=1
return	non-overloaded version ||| $list$ a	count=2
function	[function_1] hdl ||| [function_2] [function_1]	count=4
args	argument is executed with ||| mvar	count=1
return	returns a quadruple ||| $list$ string $list$ string	count=1
args	be applied to non-empty ||| $f_3$ a a a foldable a	count=1
return	destination ; [return] copied areas ||| [return]	count=1
function	trace scheduler ||| trace scheduler	count=1
function	[function_1] hdl ||| ghc io handle [function_2] [function_1]	count=4
module	same as x ||| data	count=1
function	endby ||| end by1	count=2
module	where the array ||| array	count=1
function	base specified ||| at base	count=1
args	equality predicate instead ||| $f_3$ a a bool	count=1
args	like witharray but ||| ptr storable io b	count=1
function_args	written [args_2] ||| [args_2] [function_1]	count=3
function	its arguments already exists ||| already exists	count=2
return	predicate and a list ||| maybe a	count=1
function	to wait for data ||| thread wait	count=1
return	the value ||| a	count=1
function	of a given file ||| file	count=1
args	fresh memory pool ||| pool io	count=1
module	[module_1] encoding ||| [module_1] [module_2]	count=4
function	open the [function_2] ||| system io [function_1] binary [function_2] filepath iomode io handle	count=2
module	block of memory of ||| marshal alloc	count=1
function	and lower limits ||| bound	count=1
function_return	[function_1] the contents ||| [return_2] [function_1]	count=1
function	character to ||| to	count=4
args	with ||| $f_2$ c d arrow b	count=1
module	may be marshalled to ||| ghc	count=1
args	monad scanning ||| monad a2 monad a3 monad a4	count=1
module	wait ||| control concurrent qsemn	count=1
module	can only ||| ghc conc	count=1
function	flush all the ||| flush	count=1
module	yields the error ||| error	count=2
function	mode ||| set	count=1
module	slides ||| ghc io buffer	count=1
args	only be used within ||| exception	count=2
module	defines parser combinators for ||| text parsercombinators	count=1
module	processing for the current ||| ghc conc	count=1
function	constructor ||| ty con app	count=1
module	int ||| ghc	count=1
function	to name ||| min	count=1
args	either ||| $f_2$ b c either a	count=1
function_args	action with [args_2] ||| [function_1] [args_2]	count=1
module	failed because the ||| system io	count=2
return	a storable type in ||| storable	count=2
function	an extra position ||| array0	count=1
module	a haskell ||| foreign	count=2
module	posix data types haskell ||| system posix	count=1
args	a binary ||| c applicative a applicative	count=1
return	buffer ||| buffer word8	count=2
function	var or nothing ||| lookup	count=1
module	the components of ||| data tuple	count=1
args	[args_1] function is ||| [args_1] [args_2]	count=2
function	mode for hdl ||| h	count=1
return	storable type in ||| ptr storable	count=2
function	set the ||| set	count=2
return	version ||| $list$ a	count=2
function_return	[function_args_1] into ||| [function_args_1] [return_2]	count=1
args	the arguments ||| $f_2$ a monad b	count=1
module	[module_1] io operation ||| [module_2] [module_1]	count=1
args	argument a pointer ||| $f_2$ ptr	count=2
function	of a type ||| min	count=1
function	given path when appropriate ||| path	count=3
args	file descriptor ghc only ||| fd	count=2
module	given ||| foreign	count=1
return	but returns ||| $list$ string $list$ string $list$	count=1
function	is a signed type ||| is signed	count=1
function	is ||| min bound	count=1
function	pointer to ||| ptr to ptr	count=1
return	to the ||| io	count=9
args	on stablename that ||| stablename	count=1
args	a ||| $f_2$ ptr a io b	count=2
return	fresh memory pool ||| io pool	count=1
module	with the ||| exts	count=1
return	[return_1] a string ||| [return_1] [return_2]	count=1
module	miscelaneous information available for ||| ghc	count=1
return	by the computation ||| io a	count=1
function	to ||| cast cschar to	count=1
args	stablename that ||| stablename b	count=1
function	takemvar ||| take	count=1
function	restore action to ||| mask_	count=2
return	number of the capability ||| int bool	count=3
function	to represent ||| left associative	count=1
return	arrows retagging and merging ||| b' either c	count=1
return	return true if ||| bool	count=2
args	to a monad scanning ||| monad a2 monad a3 monad a4	count=1
module	the given list which ||| list	count=1
module	types ||| typeable	count=2
return	the io action when ||| io a	count=1
args	string ie character ||| string $f_2$	count=1
return	mutate the ||| io	count=1
function	show for ||| show	count=1
module	integral type with the ||| exts	count=1
function	to the error message ||| error with	count=1
args	argument is executed with ||| mvar a	count=1
module	was made ||| control exception base	count=1
args	given file descriptor ||| fd	count=5
function_return	[function_args_1] monadic action ||| [return_2] [function_args_1]	count=1
args	signed realfloat value using ||| int realfloat	count=1
args	a conversion scheme between ||| dstate io textencoder estate	count=1
function	if the operation ||| errno if	count=1
args	computation ||| io b io c	count=2
module	where the operation failed ||| system io error	count=5
return	into a circular one ||| a	count=1
function	file in ordinary blocking ||| open file blocking	count=1
return	more occurrences [return] p ||| readp [return]	count=1
module	the ||| io	count=20
function	form when the resultant ||| evaluate	count=2
function_return	[function_1] complex value ||| [function_1] floating [return_2]	count=1
module	haskell representation ||| foreign c	count=1
return	nul terminated ||| cstring	count=1
function	no newline [function_2] ||| [function_2] [function_1]	count=1
return	number ||| int bool	count=3
function	query element ||| elem	count=2
module	pair of [module_2] ||| [module_1] [module_2]	count=2
return	[return] encoding of ||| [return]	count=1
return	a predicate and a ||| maybe a	count=1
module	error indicating [module_2] ||| [module_1] [module_2]	count=2
return	buffer ||| buffer	count=3
return	that ||| reads	count=1
module	a ||| string	count=6
function_args	resize a ||| realloc ptr a	count=1
return	elements to ||| $list$	count=1
args	contain the file handle ||| handle maybe filepath	count=1
args	the either type ||| c $f_2$ b c either a	count=1
args	argument a pointer ||| $f_2$ ptr storable io b	count=2
module	then right parser ||| text parsercombinators	count=1
function	least element of the ||| minimum	count=1
args	conversion scheme between sequences ||| textencoder estate	count=1
function	[function_1] part ||| [function_2] [function_1]	count=3
function	foreign object ||| with foreign ptr	count=2
args	predicate ||| bool $list$ a	count=3
args	user-supplied equality predicate ||| a bool $list$ a	count=1
args	character ||| char	count=4
function	[function_1] of bytes ||| [function_1] [function_2]	count=1
return	adds a finalizer that ||| a	count=1
function	wait for data to ||| wait	count=1
args	predicate to select which ||| $f_2$	count=1
return	read a string ||| reads string	count=2
args	by its statickey ||| statickey	count=1
args	casts a wordptr ||| wordptr	count=1
function	with its arguments flipped ||| for	count=3
function	the same as ||| bit	count=1
module	that an io ||| io	count=4
function	to terminate the thread ||| thread	count=1
module	into a c ||| foreign c string	count=1
return	allocate a fresh memory ||| io	count=1
function	to ||| ptr to ptr	count=2
function	symbol ||| symbol	count=6
return	a collection ||| a	count=1
return	real value given ||| real	count=1
args	from the handle ||| handle ptr	count=2
function	the upper and lower ||| min bound	count=1
function	category ||| category	count=1
function	[function_1] end of ||| [function_1] [function_2]	count=2
module	an ||| error	count=4
function	i/o position [function] equal ||| h [function]	count=1
function	throwerrnoifminus1retrymayblock but discards the ||| throw errno if minus1retry may block_	count=1
function	buffering mode [function_2] ||| [function_2] get [function_1]	count=1
module	allow ||| control monad st safe	count=1
function_return	[function_1] associativity ||| [return_2] [function_1]	count=2
args	with a ||| $f_2$ c d	count=1
module	list of ||| data list	count=20
return	raised and its value ||| a	count=1
module	iseof ||| io handle fd	count=1
args	to the type char ||| char	count=1
module	a list of ||| data list	count=4
function_args	suspends the current [function_1] [args_2] ||| ghc conc [function_1] delay [args_2]	count=5
function_return	[function_1] a string ||| [return_2] [function_1]	count=3
function	wide string ||| peek cwstring len	count=1
function	unset name removes ||| unset	count=1
function	shift the ||| i shift	count=1
args	not satisfy the predicate ||| $f_2$ a bool	count=1
args	a memory ||| a	count=1
function	resultant ||| evaluate	count=2
module	control ||| control	count=2
return	shows ||| shows	count=1
return	a handle is created ||| io handle	count=1
function	between the stable ||| free stable	count=1
function	is given ||| ptr	count=1
return	sum of a ||| alternative a	count=1
return	returns ||| string $list$ string $list$	count=1
function_return	is [return_2] ||| [function_1] terminal device handle [return_2]	count=2
module	area with a byte ||| utils	count=1
function	identical to hiseof except ||| eof	count=1
module	[module] this ||| [module]	count=3
return	[return_1] realfrac ||| [return_1] [return_2]	count=1
module	the same as ||| bits	count=1
return	rest unchanged to ||| c d	count=1
function	additionally if the ||| errno if	count=1
args	with the arguments ||| $f_2$ a monad b monad a	count=1
module	decimal ||| numeric	count=1
return	and merging their ||| b'	count=1
function	[function_1] if the ||| [function_2] [function_1]	count=4
function	value expressed ||| float	count=1
function_args	[function_1] [args_2] ||| [function_1] array pool [args_2]	count=7
args	curried [args_2] ||| [args_2] [args_1]	count=2
rep	of !!, [function_args_2] ||| [module_1] [function_args_2]	count=2
function	contents ||| contents	count=1
module	[module_1] a haskell ||| [module_2] [module_1]	count=1
function	and returns the conjunction ||| and	count=2
function	test whether the ||| null	count=2
function_return	[function_1] [return_2] ||| [function_1] trailing zeros finitebits [return_2]	count=1
rep	an array [function_return_2] ||| [module_1] [function_return_2]	count=2
module	c wide ||| c	count=1
args	[args_1] resulting handle ||| [args_1] iomode $f_2$ [args_2]	count=1
module	the value of an ||| data	count=1
args	number within ||| realfrac realfrac	count=1
args	is a version ||| a	count=1
return	the buffer to the ||| io buffer	count=1
return	the number of bytes ||| int	count=1
args	pointer ||| ptr storable io b	count=2
function	a usererror if the ||| throw if	count=1
return	a and b ||| a b	count=3
return	used [return_2] ||| [return_2] [return_1]	count=8
return	a complex ||| complex floating	count=1
function	bool ||| from bool	count=1
module	and the like ||| data	count=1
function	to be sent immediately ||| flush	count=2
args	an exception ||| exception maybe	count=2
args	handle ||| string maybe handle	count=2
args	for the either ||| a c $f_2$ b c either a b	count=1
args	promote a function to ||| a1 monad a2 monad a3	count=2
function	channel begins empty but ||| dup chan	count=1
module	because the end of ||| system io error	count=1
args	non-negative integral ||| integral	count=1
module	instance of ||| data fixed	count=1
module	marshal a c string ||| c	count=1
function	type error ||| error	count=1
args	[args_1] resulting handle ||| [args_2] [args_1]	count=3
function_return	parser [return_2] ||| [return_2] [function_1]	count=3
args	of non-options a list ||| argorder a $list$ optdescr	count=1
module	convert an array ||| array	count=1
function	upper and lower ||| min bound	count=1
function	read ||| read	count=12
module	for ||| ghc io handle	count=2
module	be marshalled ||| ghc	count=1
function	[function_1] prefix ||| [function_2] [function_1]	count=3
args	analysis for the either ||| $f_2$ b c either a b	count=1
args	is an unsigned integral ||| word#	count=1
function	name the upper ||| bound	count=1
function	[function] temporary ||| with cstring [function]	count=1
args	the static ||| staticptrinfo	count=2
function	about ||| finally	count=1
args	string str to ||| string	count=1
module	integral type ||| ghc	count=1
function	var ||| lookup	count=1
function	the char ||| char	count=1
function	a single-use resource which [function_1] [function_2] ||| [function_1] [function_2]	count=4
function	[function_1] that capability ||| [function_2] [function_1]	count=1
return	yield true if the ||| bool	count=1
function	exceptions ||| exception	count=1
return	a character is ||| char	count=2
args	witharray but ||| $list$ storable $f_2$ ptr storable io	count=1
return	a word ||| word	count=1
args	any value ||| a monad	count=2
args	to an action ||| $f_2$ a	count=1
return	value of [return_2] ||| [return_2] [return_1]	count=6
module	iseof ||| ghc io handle fd	count=1
function	[function_1] terminal ||| [function_1] [function_2]	count=1
args	file handle and file ||| maybe handle maybe	count=1
args	obtained from a ||| a	count=1
function	fork ||| fork	count=1
function	to mallocarray0 but ||| foreign ptr array0	count=1
module	operation failed because the ||| io error	count=2
return	function to actions ||| applicative	count=2
args	the file handle and ||| string maybe handle maybe	count=1
function	you wish [function] ||| [function]	count=6
function	accumulator together with the ||| accum	count=3
return	the value of the ||| io maybe string	count=1
function	the program attempts ||| nested	count=1
return	traverse with its arguments ||| applicative traversable	count=1
function	the current ||| h get	count=2
return	of the [return_2] ||| [return_2] [return_1]	count=4
return	subsequences function returns ||| $list$ $list$ a	count=1
args	[args_1] openfile and ||| [args_2] [args_1]	count=2
function	a haskell character to ||| cast char to	count=3
module	temporarily allocated ||| foreign marshal	count=1
args	return value from the ||| a	count=2
return	[return_1] given ||| [return_1] [return_2]	count=7
function_args	[function_1] [args_2] ||| [function_1] filepath iomode [args_2]	count=4
module	an ioerror corresponding to ||| c error	count=1
return	written and also ||| iodevicetype	count=1
args	hseek ||| seekmode	count=1
args	pool to the given ||| pool	count=1
function_args	[function_1] structure ||| [args_2] [function_1]	count=2
return	of lists ||| a $list$	count=1
return	occur within a computation ||| either ioerror a	count=1
args	same as ||| bits	count=1
args	to an action ||| $f_2$	count=1
module	an exception is raised ||| control exception	count=2
function	file using openbinaryfile and ||| binary file	count=1
function	given file ||| file	count=1
function	an smaller than the ||| r	count=1
module	this [module_2] ||| [module_1] [module_2]	count=16
module	the operation failed because ||| system io	count=5
function	[function_1] is ||| [function_2] [function_1]	count=2
function_return	[function_1] reads ||| [return_2] [function_1]	count=2
return	the monadic ||| monad	count=2
function	a stable ||| stable	count=2
args	like witharray but a ||| storable $f_2$ ptr storable io b	count=1
return	of memory of the ||| io	count=1
return	indicating whether the ||| io $tuple_2$	count=1
module	instance [module_2] ||| [module_1] [module_2]	count=2
function	returns ||| get	count=1
args	type constructor ||| tycon $list$	count=1
args	pool which ||| $f_2$ pool io	count=1
function	additionally if the ||| if	count=1
function	the system [function_2] ||| [function_1] [function_2]	count=2
args	true ||| bool shows	count=2
return	outputs ||| arrowchoice either b c	count=1
function_args	for modifying [args_2] ||| [function_1] mvar a [args_2]	count=1
function	generalisation of div ||| div'	count=1
function	write ||| write	count=8
function	additionally if the operation ||| throw errno if	count=1
args	with ||| word#	count=1
module	the same size as ||| ghc	count=1
return	the supplied value ||| io mvar a	count=2
args	string ||| textencoding string $f_2$	count=2
function	returns the current buffering ||| get buffering	count=2
return	the required type ||| io ptr storable	count=1
args	signed ||| int	count=3
return	function to actions ||| applicative c	count=1
args	a signed ||| int	count=3
function_args	suspends [function_1] [args_2] only ||| ghc conc [function_1] delay [args_2]	count=2
return	the haskell [return_2] ||| [return_2] [return_1]	count=1
args	analysis for the either ||| either	count=1
args	a binary function ||| b c applicative a applicative	count=1
function_args	show [args_2] ||| [function_1] float [args_2]	count=2
function	the rts to run ||| run	count=1
function	the file [function_2] ||| [function_2] [function_1] filepath iomode io handle	count=2
module	an mvar put ||| control	count=1
args	second argument is executed ||| mvar	count=1
args	a ||| a monad $tuple_2$ b c $list$ a	count=1
return	char ||| char	count=1
args	applied [args] ||| [args]	count=1
function_return	[function_args_1] value as ||| [function_args_1] [return_2]	count=3
args	non-options a ||| argorder a $list$ optdescr a	count=1
module	[module_1] an io ||| [module_2] [module_1]	count=2
return	[return_1] a threadid ||| [return_2] [return_1]	count=2
args	a reverse application ||| a $f_2$ a b	count=1
function	spark ||| sparks	count=2
function	passed to the finalizer ||| foreign ptr finalizer	count=2
function	s heap ||| heap	count=2
function_args	[function_1] elements ||| [function_1] $f_2$ [args_2]	count=4
function	until [function_2] ||| [function_1] for [function_2]	count=1
return	a handle is ||| handle	count=1
module	monoid returning the ||| monoid	count=1
args	function takes a ||| $f_2$ a bool $list$ a	count=1
module	be ||| ghc	count=1
function	standard ||| ffloat alt	count=1
args	exception predicate ||| $f_2$ exception	count=1
module	of x from ||| data	count=1
function	the default ||| with default	count=1
function	character to ||| cast cuchar to	count=1
args	type where ||| ioerrortype string	count=1
args	readfile function reads a ||| filepath	count=1
function	an allocation counter ||| set allocation counter	count=2
function	allocate ||| new pool	count=2
args	handle ||| handle io	count=2
return	returns the number ||| $tuple_2$ int bool	count=3
function	like delete ||| delete	count=1
module	useful in ||| control exception	count=2
return	version of mkweak where ||| $tuple_2$ weak k	count=1
args	handle ||| handle textencoding	count=1
args	mapmaybe function is ||| a maybe b $list$	count=1
args	function takes a ||| a bool $list$	count=1
args	memory pool ||| $f_2$ pool	count=1
args	function returns the ||| eq $list$	count=1
function_return	[function_1] real value ||| [function_1] reads real reads [return_2]	count=1
function	a foreign object ||| foreign	count=1
module	proxy type ||| data proxy	count=1
function	unlines is an ||| unlines	count=1
function	additionally if the operation ||| errno if	count=1
return	type constructor [return_2] ||| [return_2] [return_1]	count=3
function_args	truncate [args_2] ||| [function_1] [args_2]	count=3
function_args	a file [args_2] ||| [function_1] [args_2]	count=6
return	to continue decoding ||| to	count=2
function	open [function_2] ||| system io [function_1] [function_2]	count=2
function	thread [function_2] ||| ghc conc [function_1] [function_2]	count=5
function	traceeventio ||| event	count=1
function	handle the sign ||| sign plus	count=1
module	channel results in ||| ghc io	count=1
function	is not possible ||| illegal	count=1
function	current ||| current	count=2
function	a list of ||| list	count=1
module	convert a c ||| c string	count=3
function	represent ||| prefix	count=1
return	rest through unchanged ||| b d either c d	count=1
function	the given ||| ptr info	count=1
args	a returned value ||| either someexception a	count=1
args	to non-empty ||| $f_3$ a	count=1
module	[module_1] current ||| [module_1] [module_2]	count=2
return	elements satisfying the predicate ||| $list$ int	count=1
function	ceiling ||| ceiling	count=1
args	the handle ||| handle ptr a	count=2
module	an unsigned integral ||| ghc	count=1
module	that can only ||| conc sync	count=1
module	options ||| console getopt	count=1
function_return	[function_args_1] the io ||| [function_args_1] [return_2]	count=4
args	a reverse application operator ||| a	count=1
module	the position of hdl ||| handle	count=1
function	can be written ||| write	count=3
module	is ||| ghc	count=1
args	a reverse application operator ||| a b	count=1
function	of an array ||| array	count=1
module	parser ||| text parsercombinators	count=4
module	allow ||| monad st	count=1
module	strict version of ||| data	count=2
args	given ||| ptr storable/eq	count=1
args	passing any value ||| a $f_2$ a monad	count=1
args	is encapsulated in a ||| foldable a	count=1
function_return	duplicate [return_2] ||| [function_1] handle [return_2]	count=1
return	buffer blocking if ||| buffer word8	count=1
function_return	contents [return_2] ||| [return_2] [function_1]	count=2
return	a list ||| $list$	count=1
function	to ||| cast fun ptr to	count=1
args	either ||| b c either a b	count=2
function_return	[function_1] a ptr ||| [function_1] wordptr [return_2]	count=1
module	managed ||| system io	count=1
function	the current ||| get	count=8
function	to the corresponding haskell ||| cchar to char	count=1
module	io library portions ||| io	count=3
module	applicative functor based ||| applicative	count=1
module	only be used ||| conc	count=1
return	within a computation ||| ioerror a	count=1
module	unsigned integral type ||| ghc exts	count=1
args	conversion scheme ||| io textdecoder dstate io textencoder estate	count=1
return	precedence context to zero ||| readprec	count=1
function	[function_1] binary mode ||| [function_2] temp [function_1]	count=2
args	true ||| bool reads a	count=2
return	the number ||| io $tuple_2$ int bool	count=2
module	eventlog profiling ||| debug	count=3
return	rest unchanged to ||| d	count=1
args	a ||| d e f g $list$ a $list$ b	count=1
args	rational ||| rational	count=1
args	the return value from ||| io a io b io	count=2
function	current i/o [function_2] ||| [function_2] [function_1]	count=4
args	scanning the ||| monad a2 monad a3 monad a4	count=1
args	scanning the ||| a3 monad a4 monad	count=1
function	the same size ||| w#	count=1
return	the ||| io int	count=2
function	cn other not ||| not	count=1
return	the [return_2] ||| [return_1] mvar [return_2]	count=1
function	constructor for an index ||| index	count=1
args	one or more characters ||| char bool	count=1
module	area ||| utils	count=1
function	to the ||| cast cuchar to	count=1
args	structure but with ||| b b b foldable	count=1
function	returns the disjunction ||| or	count=2
module	read ||| control concurrent chan	count=1
function	the mapandunzipm function maps ||| and unzip m	count=1
function	a latin-1 character to ||| to	count=1
function	to the corresponding ||| cast cchar to char	count=1
function_return	offset [return_2] ||| [return_2] [function_1]	count=4
module	event that an ||| control	count=2
args	predicate instead ||| a bool $list$ a	count=1
args	string using temporary storage ||| textencoding string $f_2$	count=1
return	within a computation and ||| either ioerror a	count=1
return	of a ||| a	count=4
return	traverse is defined ||| traversable	count=1
module	a value ||| foreign	count=1
args	casts a ||| a	count=1
function	accumulator together with ||| accum	count=3
return	computation is ||| io	count=2
args	storable values in ||| $f_2$ ptr storable	count=1
args	nul terminated c ||| $f_2$ cstring io	count=1
args	method showlist is provided ||| show	count=1
module	as the number of ||| data list	count=2
return	to the io monad ||| io	count=1
args	either ||| c $f_2$ b c either	count=1
args	a curried ||| c a	count=1
args	a ||| d e f g $list$ a $list$	count=1
args	[args_1] number ||| [args_2] [args_1]	count=11
function	first argument right ||| r	count=1
module	of foldl that has ||| data	count=1
function_args	[function_1] complex number ||| [function_1] [args_2]	count=2
args	a ||| ptr a io	count=2
args	represents a pointer to ||| addr#	count=1
function_args	[function_1] [args_2] only ||| [function_1] [args_2]	count=18
module	utf-32 unicode encoding ||| encoding	count=1
function_args	ceiling [args_2] ||| [args_2] [function_1]	count=3
args	where the return value ||| a io b io c	count=2
module	is ||| data	count=1
return	is used [return_2] ||| [return_1] [return_2]	count=8
function_return	duplicate [return_2] ||| [return_2] [function_1]	count=1
function	of its arguments already ||| is already	count=1
function	foreign object ||| add foreign	count=1
module	concrete promotable proxy type ||| proxy	count=1
module	used ||| ghc	count=1
return	strict st [return] ||| st [return]	count=4
args	a curried function ||| b c a	count=1
return	for the end ||| io	count=1
function	a prefix of ||| prefix of	count=2
args	handle and file path ||| maybe handle maybe filepath	count=1
module	may be marshalled to ||| ghc exts	count=1
function	of bytes copied ||| bytes copied	count=2
function	name the upper and ||| min	count=1
function	marshal ||| peek cstring len	count=2
function_return	[function_1] in arrow ||| [function_1] [return_2]	count=2
module	c ||| foreign c string	count=10
return	actions ||| applicative c	count=1
function	used to name the ||| bound	count=1
module	[module_1] corresponding to ||| [module_2] [module_1]	count=2
args	version ||| $f_2$ a a	count=1
function	using temporary ||| with cstring	count=1
args	memory pool ||| pool io b	count=1
function	the end of the ||| end	count=1
function_return	of elements [return_2] ||| [return_2] [function_1]	count=2
args	a ||| e $list$ a $list$ b $list$ c	count=1
module	file involved in the ||| io	count=1
args	non-options a list ||| argorder	count=1
module	function and ||| data	count=1
args	be applied to non-empty ||| $f_3$ a	count=1
args	series of stm actions ||| stm a	count=1
args	finalized pointer ||| a ptr env ptr	count=1
function	is ||| set	count=1
args	via the specified handle ||| handle	count=1
module	and columns [module_2] ||| [module_2] [module_1]	count=3
module	the non-overloaded version of ||| data list	count=1
function	the same as ||| set	count=1
function	[function_1] [function_2] the ||| [function_1] [function_2]	count=2
args	a string ||| string	count=4
function	module where the ||| info module	count=1
args	where ||| ioerrortype string maybe	count=1
module	indicating that an io ||| system io error	count=1
args	the either ||| either a b	count=1
return	a ||| a b	count=4
function	heap ||| heap	count=2
return	argument arrow ||| arrow	count=1
args	[args_1] [args_2] swapped around see ||| just [args_2] [args_1]	count=2
return	[return_1] application ||| [return_2] [return_1]	count=8
return	a parser [return_2] ||| [return_2] [return_1]	count=3
args	equality predicate ||| $f_3$ a a bool $list$	count=1
args	storable values ||| ptr storable io b	count=1
return	[return] l from ||| [return]	count=1
args	promote a function ||| a4 a5 r monad a1 monad	count=1
function	[function] or similar ||| [function] bad	count=1
return	raised [return] ||| io either exception [return]	count=2
args	value ||| a monad b	count=4
return	used to continue decoding ||| from buffer to	count=2
function	terminated ||| peek array0	count=2
args	number ||| realfrac realfrac	count=1
return	computation [return_2] ||| [return_2] [return_1]	count=12
args	on stablename ||| a stablename b	count=1
function_args	[function_1] a signed ||| [function_1] ffloat maybe [args_2]	count=1
module	resets ||| parsercombinators readprec	count=1
args	six-tuples ||| d e f	count=1
function	current number ||| current	count=2
module	error ||| c error	count=4
function	computes the product ||| product	count=2
module	same ||| bits	count=1
function	file using ||| file	count=1
return	pair in canonical form ||| $tuple_2$ realfloat realfloat	count=1
module	[module_1] encoding may ||| [module_1] [module_2]	count=4
return	more occurrences [return] p separated ||| readp [return]	count=1
function	pool ||| new array	count=1
args	memory pool which gets ||| $f_2$ pool	count=1
return	makes a stablename for ||| io stablename a	count=1
function	current number of bytes ||| current bytes	count=1
args	handle and file ||| maybe handle maybe	count=1
module	[module] of ||| data [module]	count=2
args	mapmaybe function is ||| $f_2$ a maybe b $list$	count=1
args	string s ||| handle string	count=2
args	value produced ||| a $f_2$ a monad	count=1
return	newforeignptr adds a ||| a	count=1
module	no ||| console getopt	count=1
return	expressed as an integer ||| integer	count=1
function_args	show a [args_2] ||| [function_1] ffloat maybe [args_2]	count=3
function	a line from ||| line	count=1
return	storable type ||| io ptr storable	count=2
function	wait for ||| thread wait	count=1
return	the buffer to ||| buffer	count=1
args	as well as six ||| f	count=1
function	the phase ||| phase	count=1
args	witharray ||| storable $list$ storable $f_2$ ptr storable	count=1
function	the supplied write ||| write buffer0	count=1
function_args	a duplicate [args_2] ||| [args_2] [function_1]	count=1
args	in a ||| a	count=1
args	and always returns ||| a	count=1
module	rows and columns ||| list	count=1
function	[function_1] on ||| [function_2] [function_1]	count=6
module	[module] pairs ||| [module]	count=1
function	call [function_2] ||| [function_1] [function_2]	count=2
module	a foreign function ||| foreign	count=1
module	valid memory ||| foreign	count=1
function_args	[function_1] [args_2] evaluate these actions from ||| [function_1] [args_2] monad traversable b	count=1
function	a file that ||| file	count=1
function	slides the contents ||| slide contents	count=2
return	a given type ||| a	count=1
function	[function] so that ||| [function]	count=2
function	can t ever continue ||| blocked indefinitely	count=1
module	splits ||| data typeable internal	count=1
args	the return value from ||| io a io b io c	count=2
return	reference into a ||| io foreignptr a	count=1
module	tool of ||| data	count=1
module	a function and ||| data maybe	count=1
return	to offset i ||| seekmode	count=2
function	limits of ||| min	count=1
function	throwerrnoifretry but additionally if ||| throw errno if	count=1
function	[function_1] of storage ||| [function_2] malloc [function_1]	count=2
args	given type where the ||| ioerrortype string	count=1
module	[module_1] [module_2] ||| [module_1] [module_2]	count=418
function	[function_1] [function_2] handle ||| [function_1] for [function_2] handle	count=1
function	a stack trace ||| stack trace	count=1
module	[module_1] the ||| [module_1] [module_2]	count=19
module	a concrete promotable proxy ||| proxy	count=1
args	actions passing any value ||| $f_2$ a monad b	count=1
args	discarding any value ||| monad a monad	count=1
function	[function_1] for hdl ||| [function_2] [function_1]	count=9
function	given foreign object ||| add foreign ptr	count=2
args	value ||| b b $list$ a	count=2
module	for a ||| data	count=1
args	handle ||| string maybe handle maybe filepath	count=1
function	or channel managed ||| h get	count=2
function	group function ||| group	count=1
module	current ||| ghc io encoding	count=1
function	call ||| call	count=3
return	a user-supplied ||| a	count=1
module	allow ||| monad st safe	count=1
args	a nul terminated c ||| $f_2$ cstring io	count=1
function	strict ||| to strict st	count=2
module	within ||| ghc conc sync	count=1
args	pointer living inside a ||| $f_2$ ptr a io b	count=2
function_return	to offset i ||| relative seek seekmode	count=2
function_return	[function_1] [return_2] ||| [function_1] terminal device handle [return_2]	count=2
function	index an [function_2] ||| [function_2] [function_1]	count=2
function	[function_1] file in ||| [function_2] [function_1]	count=4
return	[return] file ||| [return]	count=3
module	exception is raised during ||| exception	count=2
args	this is ||| foreignptr a $f_2$	count=2
return	to the size needed ||| io	count=1
module	thread ghc [module_2] ||| [module_1] [module_2]	count=2
args	the [args] ||| [args]	count=3
args	binary mode [args] or text ||| handle [args]	count=2
function_args	default [args_2] ||| [args_2] [function_1]	count=1
args	number of ||| int	count=17
function	to the corresponding haskell ||| cast cchar to char	count=1
module	[module] type dynamic ||| [module]	count=3
module	a nul terminated c ||| foreign c	count=2
module	parser combinators ||| text parsercombinators	count=1
args	file handle and ||| maybe handle maybe filepath	count=1
function	be taken from hdl ||| h	count=1
module	attempt was made to ||| exception base	count=1
args	a binary function to ||| applicative a applicative b	count=1
module	of foldl that ||| data	count=1
module	where ||| system	count=1
return	allows io computation to ||| io a	count=1
function	the index of a ||| constr index	count=1
return	convert a boolean ||| bool	count=1
args	[args] ghc ||| [args]	count=4
args	but a ||| io	count=1
return	gets ||| constr	count=1
return	is traverse ||| applicative traversable	count=1
function_return	[function_args_1] the io ||| [return_2] [function_args_1]	count=4
args	the same as ||| bits	count=1
module	error indicating that ||| error	count=1
args	list of storable values ||| $f_2$ ptr storable io b	count=1
return	but allows the ||| io	count=2
return	used ||| io $tuple_2$ buffer from buffer	count=2
return	to the size ||| io ptr	count=1
args	witharray but ||| $list$ storable $f_2$ ptr storable io b	count=1
function	the error ||| error with	count=1
function	allocation counter that tracks ||| allocation counter	count=1
function	args ||| with args	count=2
module	the suffix of xs ||| data list	count=1
function	show ||| show	count=8
args	predicate ||| bool $list$ a $list$	count=1
function	position of hdl ||| seek	count=3
args	structure to ||| a applicative b foldable	count=1
args	list of storable values ||| storable	count=1
function_return	list of [return_2] ||| [function_1] islist [return_2] islist	count=1
return	not pass [return] restore ||| [return]	count=2
function	thread is ||| thread	count=6
function_args	argument right [args_2] ||| bits rotate [function_1] [args_2] bits	count=1
function	least element [function_2] ||| [function_1] [function_2]	count=1
args	argument and ||| $list$	count=1
module	get the stack ||| ghc stack	count=2
function	using ||| coerce with	count=1
module	of unrecognized options ||| system console	count=1
function_args	satisfying the predicate ||| munch $f_2$	count=1
module	type with the ||| ghc exts	count=1
args	analysis for the either ||| c either	count=1
args	a conversion scheme between ||| io textdecoder dstate io textencoder estate	count=1
args	a list of storable ||| $f_2$ ptr storable	count=1
args	from a ||| a	count=1
module	type with the ||| ghc	count=1
args	given [args] ||| [args]	count=2
module	a [module_2] ||| [module_2] [module_1]	count=9
module	parser combinators for ||| text parsercombinators	count=1
args	storable ||| $f_2$ ptr storable io	count=1
return	memory ||| ptr storable	count=1
module	atomically ||| ghc conc sync	count=1
function	wide string with explicit ||| peek cwstring	count=1
function	is used to name ||| min bound	count=1
module	same ||| exts	count=1
args	is executed ||| mvar a $f_2$ a io	count=1
return	feed marked inputs ||| arrowchoice either b	count=1
args	given ||| ptr storable	count=2
function	the sign of ||| sign	count=1
function	the thread is locked ||| thread	count=2
args	pointer living inside a ||| a $f_2$ ptr a io b	count=2
function	error ||| error with	count=1
function	a usererror if ||| throw if	count=1
module	new ||| conc sync	count=1
return	reads a ||| reads	count=1
args	to a monad scanning ||| a2 monad a3 monad a4	count=1
module	first list ||| data list	count=3
return	the action has ||| io b	count=1
args	the same as ||| bits int	count=1
module	is an ||| ghc	count=1
function	use traceevent ||| trace event	count=1
return	pass [return] restore ||| [return]	count=2
module	surrogate ||| data char	count=1
return	complex number ||| complex	count=1
args	a curried function ||| a b c a b	count=1
function_return	[function_args_1] and a ||| [return_2] [function_args_1]	count=1
function	of a third value ||| trace show id	count=1
function	map each ||| map m	count=2
module	reasoning tool of ||| data	count=1
function	base specified by ||| show int at base	count=1
module	attempt was made to ||| control exception base	count=1
return	a fresh ||| io	count=1
return	the buffer blocking ||| io $tuple_2$ int buffer word8	count=1
function	exception type ||| some exception	count=1
module	iff the first list ||| data list	count=2
args	describes a single ||| char $list$ string argdescr a string	count=1
module	is ||| c error	count=1
module	unsigned integral type ||| ghc	count=1
module	a pair of types ||| data typeable internal	count=1
args	handle to ||| ioerror string maybe handle	count=1
module	the user ||| io	count=2
return	their outputs ||| arrowchoice either b c d	count=1
args	handle to ||| filepath iomode $f_2$ handle io	count=1
return	blocking until a character ||| io char	count=1
return	the size needed ||| io ptr	count=1
function	[function] so ||| [function]	count=2
args	be returned ||| $f_2$	count=1
module	of bytes ||| data	count=1
module	[module_1] [module_2] described by the second ||| [module_1] [module_2]	count=1
return	[return_1] computation to ||| [return_2] [return_1]	count=12
return	computation into [return_2] ||| [return_2] [return_1]	count=3
args	either type ||| $f_2$ b c either	count=1
module	the ||| system	count=1
module	an array ||| foreign marshal array	count=1
function	second handle a duplicate ||| h duplicate to	count=1
function_args	[function_1] a memory ||| [args_2] [function_1]	count=1
module	user ||| rts flags	count=1
return	computes [return_2] ||| [return_2] [return_1]	count=2
return	arrow and ||| arrow $tuple_3$ b d	count=1
function_return	[function_1] intptr ||| [return_2] [function_1]	count=1
args	monad scanning the ||| a2 monad a3 monad a4	count=1
args	value ||| a applicative	count=1
return	utility function ||| shows	count=2
args	this is a ||| foreignptr a $f_2$ ptr	count=2
function	same size as int ||| w#	count=1
function_return	[function_1] for storable ||| [function_1] pool io ptr [return_2]	count=1
module	alias for ||| ghc	count=1
function	combine the ||| fold	count=1
module	is ||| prelude	count=1
args	of storable ||| storable	count=1
function_return	list of [return_2] ||| [return_2] [function_1]	count=1
module	marshal a c ||| c	count=2
args	numbers of a structure ||| foldable	count=2
module	catch ||| control exception	count=1
args	curried ||| c	count=1
function_return	[function_1] number ||| [return_2] [function_1]	count=2
function_args	[function_1] file descriptor ||| [args_2] [function_1]	count=22
return	retagging and merging ||| b' either c c'	count=1
return	the monadic arguments ||| monad	count=1
module	for a ||| ghc io	count=1
return	contents after the ||| io b	count=1
module	a ||| data typeable	count=1
function	a list ||| list	count=2
function	scanr is the right-to-left ||| scanr	count=1
args	argument is executed with ||| mvar a $f_2$ a	count=1
args	value typically the left-identity ||| a b b $list$ a	count=1
function	[function] sep ||| [function]	count=2
function	be sent immediately to ||| flush	count=2
function	size of ||| size	count=1
function	handle to a thread ||| thread id	count=2
function	allocate a new ||| new	count=1
function	mvar ||| mvar	count=4
function	mapandunzipm ||| and unzip m	count=2
args	witharray but a ||| $f_2$ ptr storable io b	count=1
args	pool to the given ||| pool ptr storable	count=1
function_return	the action hsetencoding [function_1] [return_2] ||| [function_1] [return_2]	count=3
module	to a temporarily allocated ||| marshal	count=1
function	coerce allows ||| coerce	count=1
return	type in the ||| io ptr	count=1
function_args	show for handle ||| h show handle	count=2
args	the number of values ||| int	count=1
function	the finalizer ||| foreign ptr finalizer	count=2
function_return	splits a [return_2] ||| [function_1] typerep [return_2]	count=2
function	wait for data ||| thread wait	count=1
function	is a [function] ||| [function] bad	count=1
function	geterrno if the ||| errno if	count=2
module	the end ||| io error	count=1
function	in the range 0 ||| digit	count=1
function	[function_1] allocated ||| [function_1] [function_2]	count=7
module	its numeric representation ||| utils	count=1
return	io monad and gives ||| io	count=1
return	of a container ||| $list$ a	count=1
return	tvar ||| io tvar	count=1
args	any value ||| $f_2$ a	count=1
function	for an index ||| index	count=1
module	allocate a fresh ||| foreign marshal pool	count=1
args	storable values ||| storable io b	count=1
function_return	hfilesize hdl [return_2] ||| [return_2] [function_1]	count=1
function	buffering [function_2] ||| [function_2] [function_1]	count=1
function	on [function_2] ||| [function_2] [function_1]	count=2
function	the concatenation of all ||| concat	count=2
function	is actually a pair ||| pair	count=1
module	first ||| control arrow	count=1
args	witharray [args_2] ||| [args_1] [args_2]	count=4
return	is used to continue ||| $tuple_2$ buffer from buffer to	count=2
return	form a complex number ||| complex	count=1
return	chan the duplicate channel ||| io chan	count=1
args	fresh memory pool ||| pool io b	count=1
module	an ioerror corresponding ||| foreign c error	count=3
function	[function_1] [function_2] handle ||| [function_1] [function_2]	count=4
args	where the second ||| ioerrortype string	count=1
function	fill ||| fill	count=1
function	copied each gc ||| copied	count=1
function	of a type ||| bound	count=1
module	the options ||| system console getopt	count=1
args	and ||| readp a	count=1
module	computation iseof ||| fd	count=1
module	posix data types ||| system posix	count=1
args	is a reverse ||| a $f_2$ a b	count=1
module	a parser into ||| text parsercombinators	count=1
return	a [return] ||| io [return]	count=3
args	is executed with ||| mvar a $f_2$ a io $tuple_2$ a	count=1
return	a container ||| $list$ a	count=1
module	write ||| ghc conc sync	count=1
args	an exception predicate to ||| $f_2$ exception maybe b	count=1
function_return	represent the associativity ||| left associative associativity	count=2
function	begins empty but ||| dup chan	count=1
module	an entire ||| control concurrent	count=1
module	two argument [module_2] ||| [module_1] [module_2]	count=4
function	not [function_2] ||| [function_1] [function_2]	count=1
function	file that ||| file	count=1
args	witharray [args_2] ||| [args_2] [args_1]	count=4
module	the same ||| bits	count=1
args	case no result ||| io a	count=1
return	; the ||| io	count=2
return	the buffer blocking ||| int buffer word8	count=1
return	mapaccumr function ||| acc $list$ y	count=1
args	stablename ||| a stablename	count=1
args	there are no ||| bufferedio buffer	count=1
args	for the either ||| c either a b	count=1
module	the upper and lower ||| prelude	count=1
return	bytes returning the number ||| int	count=1
return	mkweak where the key ||| weak k	count=1
function	retry an stm transaction ||| stm	count=1
return	magnitude phase pair ||| $tuple_2$ realfloat realfloat	count=1
args	there are no bytes ||| bufferedio	count=1
args	value ||| a	count=8
function	begins empty ||| dup chan	count=1
args	structure ||| b b foldable	count=6
function	[function] and ||| cat [function]	count=1
args	the class typeable ||| typeable	count=1
function	default ||| with default	count=1
function	of ||| of	count=1
args	this ||| foreignptr a $f_2$ ptr	count=2
return	of a ||| alternative a	count=1
function	create a stable ||| new stable	count=2
return	pass a ||| a	count=2
module	that the machine ||| conc sync	count=1
args	of a structure ||| a b b b foldable a	count=1
function	allocate ||| new	count=1
function_args	[function_1] complex number ||| [args_2] [function_1]	count=2
function	to read from ||| read	count=1
return	the io computation ||| io a	count=2
function	the encode ||| encode	count=2
return	used to continue ||| $tuple_2$ buffer from buffer to	count=2
module	element of a structure ||| data	count=1
args	either ||| a c $f_2$ b c either	count=1
return	provided that traverse is ||| traversable b	count=1
module	around [module] ||| [module]	count=6
args	a list of ||| $list$ a $f_2$ $list$ b	count=1
module	temporarily allocated ||| marshal	count=1
return	i from the current ||| seekmode	count=2
function_args	hdl s [args_2] ||| [args_2] [function_1]	count=2
return	a string up ||| $list$ string	count=2
args	as a value ||| a	count=1
function	void value discards ||| void	count=1
return	returns the next character ||| char	count=1
module	indicating that an io ||| io error	count=1
return	didn t ||| $tuple_3$ $list$ a $list$ string	count=1
return	parses and returns ||| readp	count=1
return	into a ||| foreignptr a	count=1
return	but returns ||| string $list$	count=1
module	the encoding may ||| ghc io encoding	count=4
function	catch but ||| catch just	count=1
args	a ||| c applicative a applicative	count=1
function	in class ||| from rat	count=1
args	stablename ||| stablename	count=1
args	file handle ||| maybe handle maybe	count=1
function_return	[function_1] asynchronous ||| [function_1] [return_2]	count=2
function	thread is locked ||| thread	count=3
args	promote a function to ||| monad a1 monad a2 monad	count=2
args	a structure but with ||| a b b b foldable a	count=1
args	from the handle ||| handle ptr a int	count=2
function	[function_1] exists ||| [function_1] [function_2]	count=4
args	an additional parameter ||| $f_3$	count=1
module	array ||| marshal array	count=4
args	a monad scanning ||| monad a2 monad a3 monad a4	count=1
return	obtain the ||| io	count=1
module	the appropriate instance ||| control	count=1
return	a tuple ||| a $list$ a	count=1
module	limits of a type ||| prelude	count=1
function	accumulator together with the ||| map accum	count=1
return	an integer [return_2] ||| [return_2] [return_1]	count=2
function_args	[function_1] function takes ||| [args_2] [function_1]	count=1
args	predicate ||| a bool $list$	count=1
module	for the io library ||| ghc io encoding	count=2
function	association between the stable ||| stable	count=1
args	promote a function ||| a3 a4 r monad a1 monad a2 monad	count=1
module	this exception is ||| control exception	count=4
function	defining left ||| left app	count=1
return	the pointer ||| io b	count=2
return	the mapaccumr function ||| acc $list$ y	count=1
function	[function] temporary storage ||| with cstring [function]	count=1
module	into an [module] by the ||| [module]	count=1
module	as int ||| ghc	count=1
return	and the ||| newlinemode	count=1
return	a predicate and a ||| a	count=1
args	for the either type ||| c $f_2$ b c either a	count=1
return	[return_1] adds a ||| [return_1] [return_2]	count=1
return	phase pair in ||| $tuple_2$	count=1
return	staticptr by its ||| maybe staticptr	count=1
args	in a ||| monad b b foldable a	count=1
args	try [args_1] [args_2] ||| [args_2] [args_1]	count=8
args	conditionally prove ||| a testcoercion	count=1
args	return value from ||| io a io b io c	count=2
function	indices ||| indices	count=1
module	remainder of the list ||| data list	count=2
args	is a reverse application ||| a $f_2$ a	count=1
module	area with ||| utils	count=1
function	[function_1] foreign object ||| [function_2] [function_1]	count=2
args	storable values in memory ||| storable io b	count=1
function	the user calls error ||| error call	count=2
module	allow ||| control monad st lazy safe	count=1
function	the int type ||| mk int type	count=2
args	for ||| $f_2$	count=1
return	the computation ||| io b	count=1
args	this ||| foreignptr a	count=2
args	actions ||| applicative c	count=1
function	usererror if ||| throw if	count=1
function	and merge their ||| (|||)	count=1
function	[function_1] if ||| [function_2] [function_1]	count=10
function	to an ||| to int	count=1
module	control ||| data char	count=1
args	the file handle and ||| maybe handle maybe filepath	count=1
function	same ||| set	count=1
args	the mapmaybe function ||| $f_2$ a maybe b	count=1
function	its arguments does not ||| is does not	count=1
return	raised [return] ||| [return]	count=1
args	memory pool ||| $f_2$ pool io	count=1
args	handle hdl ||| handle	count=2
function	number of megabytes allocated ||| megabytes allocated	count=1
return	the computation exitfailure is ||| io	count=1
args	equality on stablename that ||| a stablename	count=1
function	from the end of ||| from end	count=2
module	same object ||| system mem	count=1
function_args	[function_1] given number ||| [function_1] malloc array pool [args_2]	count=1
function	the upper and ||| min bound	count=1
return	number of haskell ||| int	count=3
function	representation of a type ||| type	count=1
args	pool ||| $f_2$ pool io b	count=1
args	for ||| $f_2$ a bool string io a	count=1
return	the computation ||| io a	count=2
args	given number of elements ||| ptr storable int	count=2
args	this function extracts the ||| foreignptr a	count=1
args	with a ||| $f_2$ b c arrow	count=1
