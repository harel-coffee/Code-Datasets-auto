<tt style='background-color:#E8E8E8;'> Unsafe.Coerce <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Unsafe-Coerce.html#v:unsafeCoerce'>unsafeCoerce </a>  a -> b </tt>	The highly unsafe primitive unsafeCoerce converts a value from any type to any other type
<tt style='background-color:#E8E8E8;'> Data.Tuple <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Tuple.html#v:fst'>fst </a>  (a, b) -> a </tt>	Extract the first component of a pair
<tt style='background-color:#E8E8E8;'> Data.Tuple <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Tuple.html#v:snd'>snd </a>  (a, b) -> b </tt>	Extract the second component of a pair
<tt style='background-color:#E8E8E8;'> Data.Tuple <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Tuple.html#v:curry'>curry </a>  ((a, b) -> c) -> a -> b -> c </tt>	curry converts an uncurried function to a curried function
<tt style='background-color:#E8E8E8;'> Data.Tuple <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Tuple.html#v:uncurry'>uncurry </a>  (a -> b -> c) -> ((a, b) -> c) </tt>	uncurry converts a curried function to a function on pairs
<tt style='background-color:#E8E8E8;'> Data.Tuple <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Tuple.html#v:swap'>swap </a>  (a, b) -> (b, a) </tt>	Swap the components of a pair
<tt style='background-color:#E8E8E8;'> Data.Maybe <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Maybe.html#v:Nothing'>Nothing </a>  Maybe a </tt>	The Maybe type encapsulates an optional value
<tt style='background-color:#E8E8E8;'> Data.Maybe <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Maybe.html#v:maybe'>maybe </a>  b -> (a -> b) -> Maybe a -> b </tt>	The maybe function takes a default value, a function, and a Maybe value
<tt style='background-color:#E8E8E8;'> Data.Maybe <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Maybe.html#v:isJust'>isJust </a>  Maybe a -> Bool </tt>	The isJust function returns True iff its argument is of the form Just _
<tt style='background-color:#E8E8E8;'> Data.Maybe <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Maybe.html#v:isNothing'>isNothing </a>  Maybe a -> Bool </tt>	The isNothing function returns True iff its argument is Nothing
<tt style='background-color:#E8E8E8;'> Data.Maybe <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Maybe.html#v:fromJust'>fromJust </a>  Maybe a -> a </tt>	The fromJust function extracts the element out of a Just and throws an error if its argument is Nothing
<tt style='background-color:#E8E8E8;'> Data.Maybe <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Maybe.html#v:fromMaybe'>fromMaybe </a>  a -> Maybe a -> a </tt>	The fromMaybe function takes a default value and and Maybe value
<tt style='background-color:#E8E8E8;'> Data.Maybe <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Maybe.html#v:listToMaybe'>listToMaybe </a>  [a] -> Maybe a </tt>	The listToMaybe function returns Nothing on an empty list or Just a where a is the first element of the list
<tt style='background-color:#E8E8E8;'> Data.Maybe <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Maybe.html#v:maybeToList'>maybeToList </a>  Maybe a -> [a] </tt>	The maybeToList function returns an empty list when given Nothing or a singleton list when not given Nothing
<tt style='background-color:#E8E8E8;'> Data.Maybe <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Maybe.html#v:catMaybes'>catMaybes </a>  [Maybe a] -> [a] </tt>	The catMaybes function takes a list of Maybes and returns a list of all the Just values
<tt style='background-color:#E8E8E8;'> Data.Maybe <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Maybe.html#v:mapMaybe'>mapMaybe </a>  (a -> Maybe b) -> [a] -> [b] </tt>	The mapMaybe function is a version of map which can throw out elements
<tt style='background-color:#E8E8E8;'> Text.Show <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Show.html#v:showsPrec'>showsPrec </a>  Show a => Int -> a -> ShowS </tt>	Convert a value to a readable String
<tt style='background-color:#E8E8E8;'> Text.Show <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Show.html#v:show'>show </a>  Show a => a -> String </tt>	A specialised variant of showsPrec, using precedence context zero, and returning an ordinary String
<tt style='background-color:#E8E8E8;'> Text.Show <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Show.html#v:showList'>showList </a>  Show a => [a] -> ShowS </tt>	The method showList is provided to allow the programmer to give a specialised way of showing lists of values
<tt style='background-color:#E8E8E8;'> Text.Show <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Show.html#v:shows'>shows </a>  (Show a) => a -> ShowS </tt>	equivalent to showsPrec with a precedence of 0
<tt style='background-color:#E8E8E8;'> Text.Show <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Show.html#v:showChar'>showChar </a>  Char -> ShowS </tt>	utility function converting a Char to a show function that simply prepends the character unchanged
<tt style='background-color:#E8E8E8;'> Text.Show <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Show.html#v:showString'>showString </a>  String -> ShowS </tt>	utility function converting a String to a show function that simply prepends the string unchanged
<tt style='background-color:#E8E8E8;'> Text.Show <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Show.html#v:showParen'>showParen </a>  Bool -> ShowS -> ShowS </tt>	utility function that surrounds the inner show function with parentheses when the Bool parameter is True
<tt style='background-color:#E8E8E8;'> Text.Show <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Show.html#v:showListWith'>showListWith </a>  (a -> ShowS) -> [a] -> ShowS </tt>	Show a list (using square brackets and commas), given a function for showing elements
<tt style='background-color:#E8E8E8;'> Data.Eq <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Eq.html#v:(==)'>(==) </a>  Eq a => a -> a -> Bool </tt>	The Eq class defines equality (==) and inequality (/=)
<tt style='background-color:#E8E8E8;'> Data.Functor <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Functor.html#v:fmap'>fmap </a>  Functor f => (a -> b) -> f a -> f b </tt>	The Functor class is used for types that can be mapped over
<tt style='background-color:#E8E8E8;'> Data.Functor <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Functor.html#v:(<$)'>(<$) </a>  Functor f => a -> f b -> f a </tt>	Replace all locations in the input with the same value
<tt style='background-color:#E8E8E8;'> Data.Functor <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Functor.html#v:($>)'>($>) </a>  Functor f => f a -> b -> f b </tt>	Flipped version of &lt;$
<tt style='background-color:#E8E8E8;'> Data.Functor <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Functor.html#v:(<$>)'>(<$>) </a>  Functor f => (a -> b) -> f a -> f b </tt>	An infix synonym for fmap
<tt style='background-color:#E8E8E8;'> Data.Functor <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Functor.html#v:void'>void </a>  Functor f => f a -> f () </tt>	void value discards or ignores the result of evaluation, such as the return value of an IO action
<tt style='background-color:#E8E8E8;'> Data.Function <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Function.html#v:id'>id </a>  a -> a </tt>	Identity function
<tt style='background-color:#E8E8E8;'> Data.Function <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Function.html#v:const'>const </a>  a -> b -> a </tt>	Constant function
<tt style='background-color:#E8E8E8;'> Data.Function <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Function.html#v:(DOT)'>(.) </a>  (b -> c) -> (a -> b) -> a -> c </tt>	Function composition
<tt style='background-color:#E8E8E8;'> Data.Function <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Function.html#v:flip'>flip </a>  (a -> b -> c) -> b -> a -> c </tt>	flip f takes its (first) two arguments in the reverse order of f
<tt style='background-color:#E8E8E8;'> Data.Function <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Function.html#v:($)'>($) </a>  (a -> b) -> a -> b </tt>	Application operator
<tt style='background-color:#E8E8E8;'> Data.Function <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Function.html#v:(&)'>(&) </a>  a -> (a -> b) -> b </tt>	&amp; is a reverse application operator
<tt style='background-color:#E8E8E8;'> Data.Function <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Function.html#v:fix'>fix </a>  (a -> a) -> a </tt>	fix f is the least fixed point of the function f
<tt style='background-color:#E8E8E8;'> Data.Function <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Function.html#v:on'>on </a>  (b -> b -> c) -> (a -> b) -> a -> a -> c </tt>	(*) `on` f = \x y -&gt; f x * f y
<tt style='background-color:#E8E8E8;'> Data.Bool <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Bool.html#v:False'>False </a>  Bool </tt>	The Bool type and related functions
<tt style='background-color:#E8E8E8;'> Data.Bool <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Bool.html#v:(&&)'>(&&) </a>  Bool -> Bool -> Bool </tt>	Boolean "and"
<tt style='background-color:#E8E8E8;'> Data.Bool <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Bool.html#v:(||)'>(||) </a>  Bool -> Bool -> Bool </tt>	Boolean "or"
<tt style='background-color:#E8E8E8;'> Data.Bool <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Bool.html#v:not'>not </a>  Bool -> Bool </tt>	Boolean "not"
<tt style='background-color:#E8E8E8;'> Data.Bool <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Bool.html#v:otherwise'>otherwise </a>  Bool </tt>	otherwise is defined as the value True
<tt style='background-color:#E8E8E8;'> Data.Bool <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Bool.html#v:bool'>bool </a>  a -> a -> Bool -> a </tt>	Case analysis for the Bool type
<tt style='background-color:#E8E8E8;'> GHC.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Char.html#v:chr'>chr </a>  Int -> Char </tt>	The toEnum method restricted to the type Char
<tt style='background-color:#E8E8E8;'> Data.Bits.(.& <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Bits-(-&.html#v:)'>(.&.) </a>  Bits a => a -> a -> a </tt>	Bitwise "and"
<tt style='background-color:#E8E8E8;'> Data.Bits.(.| <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Bits-(-|.html#v:)'>(.|.) </a>  Bits a => a -> a -> a </tt>	Bitwise "or"
<tt style='background-color:#E8E8E8;'> Data.Bits <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Bits.html#v:xor'>xor </a>  Bits a => a -> a -> a </tt>	Bitwise "xor"
<tt style='background-color:#E8E8E8;'> Data.Bits <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Bits.html#v:complement'>complement </a>  Bits a => a -> a </tt>	Reverse all the bits in the argument
<tt style='background-color:#E8E8E8;'> Data.Bits <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Bits.html#v:shift'>shift </a>  Bits a => a -> Int -> a </tt>	shift x i shifts x left by i bits if i is positive, or right by -i bits otherwise
<tt style='background-color:#E8E8E8;'> Data.Bits <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Bits.html#v:rotate'>rotate </a>  Bits a => a -> Int -> a </tt>	rotate x i rotates x left by i bits if i is positive, or right by -i bits otherwise
<tt style='background-color:#E8E8E8;'> Data.Bits <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Bits.html#v:zeroBits'>zeroBits </a>  Bits a => a </tt>	zeroBits is the value with all bits unset
<tt style='background-color:#E8E8E8;'> Data.Bits <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Bits.html#v:bit'>bit </a>  Bits a => Int -> a </tt>	bit i is a value with the ith bit set and all other bits clear
<tt style='background-color:#E8E8E8;'> Data.Bits <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Bits.html#v:setBit'>setBit </a>  Bits a => a -> Int -> a </tt>	x `setBit` i is the same as x
<tt style='background-color:#E8E8E8;'> Data.Bits <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Bits.html#v:clearBit'>clearBit </a>  Bits a => a -> Int -> a </tt>	x `clearBit` i is the same as x
<tt style='background-color:#E8E8E8;'> Data.Bits <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Bits.html#v:complementBit'>complementBit </a>  Bits a => a -> Int -> a </tt>	x `complementBit` i is the same as x `xor` bit i
<tt style='background-color:#E8E8E8;'> Data.Bits <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Bits.html#v:testBit'>testBit </a>  Bits a => a -> Int -> Bool </tt>	Return True if the nth bit of the argument is 1  Can be implemented using testBitDefault if a is also an instance of Num
<tt style='background-color:#E8E8E8;'> Data.Bits <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Bits.html#v:bitSizeMaybe'>bitSizeMaybe </a>  Bits a => a -> Maybe Int </tt>	Return the number of bits in the type of the argument
<tt style='background-color:#E8E8E8;'> Data.Bits <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Bits.html#v:isSigned'>isSigned </a>  Bits a => a -> Bool </tt>	Return True if the argument is a signed type
<tt style='background-color:#E8E8E8;'> Data.Bits <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Bits.html#v:shiftL'>shiftL </a>  Bits a => a -> Int -> a </tt>	Shift the argument left by the specified number of bits (which must be non-negative)
<tt style='background-color:#E8E8E8;'> Data.Bits <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Bits.html#v:unsafeShiftL'>unsafeShiftL </a>  Bits a => a -> Int -> a </tt>	Shift the argument left by the specified number of bits
<tt style='background-color:#E8E8E8;'> Data.Bits <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Bits.html#v:shiftR'>shiftR </a>  Bits a => a -> Int -> a </tt>	Shift the first argument right by the specified number of bits
<tt style='background-color:#E8E8E8;'> Data.Bits <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Bits.html#v:unsafeShiftR'>unsafeShiftR </a>  Bits a => a -> Int -> a </tt>	Shift the first argument right by the specified number of bits, which must be non-negative an smaller than the number of bits in the type
<tt style='background-color:#E8E8E8;'> Data.Bits <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Bits.html#v:rotateL'>rotateL </a>  Bits a => a -> Int -> a </tt>	Rotate the argument left by the specified number of bits (which must be non-negative)
<tt style='background-color:#E8E8E8;'> Data.Bits <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Bits.html#v:rotateR'>rotateR </a>  Bits a => a -> Int -> a </tt>	Rotate the argument right by the specified number of bits (which must be non-negative)
<tt style='background-color:#E8E8E8;'> Data.Bits <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Bits.html#v:popCount'>popCount </a>  Bits a => a -> Int </tt>	Return the number of set bits in the argument
<tt style='background-color:#E8E8E8;'> Data.Bits <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Bits.html#v:finiteBitSize'>finiteBitSize </a>  FiniteBits b => b -> Int </tt>	Return the number of bits in the type of the argument
<tt style='background-color:#E8E8E8;'> Data.Bits <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Bits.html#v:countLeadingZeros'>countLeadingZeros </a>  FiniteBits b => b -> Int </tt>	Count number of zero bits preceding the most significant set bit
<tt style='background-color:#E8E8E8;'> Data.Bits <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Bits.html#v:countTrailingZeros'>countTrailingZeros </a>  FiniteBits b => b -> Int </tt>	Count number of zero bits following the least significant set bit
<tt style='background-color:#E8E8E8;'> Data.Bits <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Bits.html#v:bitDefault'>bitDefault </a>  (Bits a, Num a) => Int -> a </tt>	Default implementation for bit
<tt style='background-color:#E8E8E8;'> Data.Bits <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Bits.html#v:testBitDefault'>testBitDefault </a>  (Bits a, Num a) => a -> Int -> Bool </tt>	Default implementation for testBit
<tt style='background-color:#E8E8E8;'> Data.Bits <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Bits.html#v:popCountDefault'>popCountDefault </a>  (Bits a, Num a) => a -> Int </tt>	Default implementation for popCount
<tt style='background-color:#E8E8E8;'> Data.Bits <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Bits.html#v:toIntegralSized'>toIntegralSized </a>  (Integral a, Integral b, Bits a, Bits b) => a -> Maybe b </tt>	Attempt to convert an Integral type a to an Integral type b using the size of the types as measured by Bits methods
<tt style='background-color:#E8E8E8;'> Data.Coerce <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Coerce.html#v:coerce'>coerce </a>  Coercible * a b => a -> b </tt>	The function coerce allows you to safely convert between values of types that have the same representation with no run-time overhead
<tt style='background-color:#E8E8E8;'> Text.ParserCombinators.ReadP <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-ParserCombinators-ReadP.html#v:get'>get </a>  ReadP Char </tt>	Consumes and returns the next character
<tt style='background-color:#E8E8E8;'> Text.ParserCombinators.ReadP <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-ParserCombinators-ReadP.html#v:look'>look </a>  ReadP String </tt>	Look-ahead: returns the part of the input that is left, without consuming it
<tt style='background-color:#E8E8E8;'> Text.ParserCombinators.ReadP <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-ParserCombinators-ReadP.html#v:(+++)'>(+++) </a>  ReadP a -> ReadP a -> ReadP a </tt>	Symmetric choice
<tt style='background-color:#E8E8E8;'> Text.ParserCombinators.ReadP <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-ParserCombinators-ReadP.html#v:(<++)'>(<++) </a>  ReadP a -> ReadP a -> ReadP a </tt>	Local, exclusive, left-biased choice: If left parser locally produces any result at all, then right parser is not used
<tt style='background-color:#E8E8E8;'> Text.ParserCombinators.ReadP <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-ParserCombinators-ReadP.html#v:gather'>gather </a>  ReadP a -> ReadP (String, a) </tt>	Transforms a parser into one that does the same, but in addition returns the exact characters read
<tt style='background-color:#E8E8E8;'> Text.ParserCombinators.ReadP <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-ParserCombinators-ReadP.html#v:pfail'>pfail </a>  ReadP a </tt>	Always fails
<tt style='background-color:#E8E8E8;'> Text.ParserCombinators.ReadP <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-ParserCombinators-ReadP.html#v:eof'>eof </a>  ReadP () </tt>	Succeeds iff we are at the end of input
<tt style='background-color:#E8E8E8;'> Text.ParserCombinators.ReadP <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-ParserCombinators-ReadP.html#v:satisfy'>satisfy </a>  (Char -> Bool) -> ReadP Char </tt>	Consumes and returns the next character, if it satisfies the specified predicate
<tt style='background-color:#E8E8E8;'> Text.ParserCombinators.ReadP <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-ParserCombinators-ReadP.html#v:char'>char </a>  Char -> ReadP Char </tt>	Parses and returns the specified character
<tt style='background-color:#E8E8E8;'> Text.ParserCombinators.ReadP <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-ParserCombinators-ReadP.html#v:string'>string </a>  String -> ReadP String </tt>	Parses and returns the specified string
<tt style='background-color:#E8E8E8;'> Text.ParserCombinators.ReadP <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-ParserCombinators-ReadP.html#v:munch'>munch </a>  (Char -> Bool) -> ReadP String </tt>	Parses the first zero or more characters satisfying the predicate
<tt style='background-color:#E8E8E8;'> Text.ParserCombinators.ReadP <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-ParserCombinators-ReadP.html#v:munch1'>munch1 </a>  (Char -> Bool) -> ReadP String </tt>	Parses the first one or more characters satisfying the predicate
<tt style='background-color:#E8E8E8;'> Text.ParserCombinators.ReadP <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-ParserCombinators-ReadP.html#v:skipSpaces'>skipSpaces </a>  ReadP () </tt>	Skips all whitespace
<tt style='background-color:#E8E8E8;'> Text.ParserCombinators.ReadP <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-ParserCombinators-ReadP.html#v:choice'>choice </a>  [ReadP a] -> ReadP a </tt>	Combines all parsers in the specified list
<tt style='background-color:#E8E8E8;'> Text.ParserCombinators.ReadP <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-ParserCombinators-ReadP.html#v:count'>count </a>  Int -> ReadP a -> ReadP [a] </tt>	count n p parses n occurrences of p in sequence
<tt style='background-color:#E8E8E8;'> Text.ParserCombinators.ReadP <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-ParserCombinators-ReadP.html#v:between'>between </a>  ReadP open -> ReadP close -> ReadP a -> ReadP a </tt>	between open close p parses open, followed by p and finally close
<tt style='background-color:#E8E8E8;'> Text.ParserCombinators.ReadP <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-ParserCombinators-ReadP.html#v:option'>option </a>  a -> ReadP a -> ReadP a </tt>	option x p will either parse p or return x without consuming any input
<tt style='background-color:#E8E8E8;'> Text.ParserCombinators.ReadP <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-ParserCombinators-ReadP.html#v:optional'>optional </a>  ReadP a -> ReadP () </tt>	optional p optionally parses p and always returns ()
<tt style='background-color:#E8E8E8;'> Text.ParserCombinators.ReadP <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-ParserCombinators-ReadP.html#v:many'>many </a>  ReadP a -> ReadP [a] </tt>	Parses zero or more occurrences of the given parser
<tt style='background-color:#E8E8E8;'> Text.ParserCombinators.ReadP <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-ParserCombinators-ReadP.html#v:many1'>many1 </a>  ReadP a -> ReadP [a] </tt>	Parses one or more occurrences of the given parser
<tt style='background-color:#E8E8E8;'> Text.ParserCombinators.ReadP <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-ParserCombinators-ReadP.html#v:skipMany'>skipMany </a>  ReadP a -> ReadP () </tt>	Like many, but discards the result
<tt style='background-color:#E8E8E8;'> Text.ParserCombinators.ReadP <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-ParserCombinators-ReadP.html#v:skipMany1'>skipMany1 </a>  ReadP a -> ReadP () </tt>	Like many1, but discards the result
<tt style='background-color:#E8E8E8;'> Text.ParserCombinators.ReadP <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-ParserCombinators-ReadP.html#v:sepBy'>sepBy </a>  ReadP a -> ReadP sep -> ReadP [a] </tt>	sepBy p sep parses zero or more occurrences of p, separated by sep
<tt style='background-color:#E8E8E8;'> Text.ParserCombinators.ReadP <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-ParserCombinators-ReadP.html#v:sepBy1'>sepBy1 </a>  ReadP a -> ReadP sep -> ReadP [a] </tt>	sepBy1 p sep parses one or more occurrences of p, separated by sep
<tt style='background-color:#E8E8E8;'> Text.ParserCombinators.ReadP <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-ParserCombinators-ReadP.html#v:endBy'>endBy </a>  ReadP a -> ReadP sep -> ReadP [a] </tt>	endBy p sep parses zero or more occurrences of p, separated and ended by sep
<tt style='background-color:#E8E8E8;'> Text.ParserCombinators.ReadP <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-ParserCombinators-ReadP.html#v:endBy1'>endBy1 </a>  ReadP a -> ReadP sep -> ReadP [a] </tt>	endBy p sep parses one or more occurrences of p, separated and ended by sep
<tt style='background-color:#E8E8E8;'> Text.ParserCombinators.ReadP <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-ParserCombinators-ReadP.html#v:chainr'>chainr </a>  ReadP a -> ReadP (a -> a -> a) -> a -> ReadP a </tt>	chainr p op x parses zero or more occurrences of p, separated by op
<tt style='background-color:#E8E8E8;'> Text.ParserCombinators.ReadP <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-ParserCombinators-ReadP.html#v:chainl'>chainl </a>  ReadP a -> ReadP (a -> a -> a) -> a -> ReadP a </tt>	chainl p op x parses zero or more occurrences of p, separated by op
<tt style='background-color:#E8E8E8;'> Text.ParserCombinators.ReadP <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-ParserCombinators-ReadP.html#v:chainl1'>chainl1 </a>  ReadP a -> ReadP (a -> a -> a) -> ReadP a </tt>	Like chainl, but parses one or more occurrences of p
<tt style='background-color:#E8E8E8;'> Text.ParserCombinators.ReadP <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-ParserCombinators-ReadP.html#v:chainr1'>chainr1 </a>  ReadP a -> ReadP (a -> a -> a) -> ReadP a </tt>	Like chainr, but parses one or more occurrences of p
<tt style='background-color:#E8E8E8;'> Text.ParserCombinators.ReadP <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-ParserCombinators-ReadP.html#v:manyTill'>manyTill </a>  ReadP a -> ReadP end -> ReadP [a] </tt>	manyTill p end parses zero or more occurrences of p, until end succeeds
<tt style='background-color:#E8E8E8;'> Text.ParserCombinators.ReadP <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-ParserCombinators-ReadP.html#v:readP_to_S'>readP_to_S </a>  ReadP a -> ReadS a </tt>	Converts a parser into a Haskell ReadS-style function
<tt style='background-color:#E8E8E8;'> Text.ParserCombinators.ReadP <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-ParserCombinators-ReadP.html#v:readS_to_P'>readS_to_P </a>  ReadS a -> ReadP a </tt>	Converts a Haskell ReadS-style function into a parser
<tt style='background-color:#E8E8E8;'> Text.ParserCombinators.ReadPrec <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-ParserCombinators-ReadPrec.html#v:minPrec'>minPrec </a>  Prec </tt>	This library defines parser combinators for precedence parsing
<tt style='background-color:#E8E8E8;'> Text.ParserCombinators.ReadPrec <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-ParserCombinators-ReadPrec.html#v:lift'>lift </a>  ReadP a -> ReadPrec a </tt>	Lift a precedence-insensitive ReadP to a ReadPrec
<tt style='background-color:#E8E8E8;'> Text.ParserCombinators.ReadPrec <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-ParserCombinators-ReadPrec.html#v:prec'>prec </a>  Prec -> ReadPrec a -> ReadPrec a </tt>	(prec n p) checks whether the precedence context is less than or equal to n, and   if not, fails if so, parses p in context n
<tt style='background-color:#E8E8E8;'> Text.ParserCombinators.ReadPrec <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-ParserCombinators-ReadPrec.html#v:step'>step </a>  ReadPrec a -> ReadPrec a </tt>	Increases the precedence context by one
<tt style='background-color:#E8E8E8;'> Text.ParserCombinators.ReadPrec <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-ParserCombinators-ReadPrec.html#v:reset'>reset </a>  ReadPrec a -> ReadPrec a </tt>	Resets the precedence context to zero
<tt style='background-color:#E8E8E8;'> Text.ParserCombinators.ReadPrec <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-ParserCombinators-ReadPrec.html#v:get'>get </a>  ReadPrec Char </tt>	Consumes and returns the next character
<tt style='background-color:#E8E8E8;'> Text.ParserCombinators.ReadPrec <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-ParserCombinators-ReadPrec.html#v:look'>look </a>  ReadPrec String </tt>	Look-ahead: returns the part of the input that is left, without consuming it
<tt style='background-color:#E8E8E8;'> Text.ParserCombinators.ReadPrec <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-ParserCombinators-ReadPrec.html#v:(+++)'>(+++) </a>  ReadPrec a -> ReadPrec a -> ReadPrec a </tt>	Symmetric choice
<tt style='background-color:#E8E8E8;'> Text.ParserCombinators.ReadPrec <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-ParserCombinators-ReadPrec.html#v:(<++)'>(<++) </a>  ReadPrec a -> ReadPrec a -> ReadPrec a </tt>	Local, exclusive, left-biased choice: If left parser locally produces any result at all, then right parser is not used
<tt style='background-color:#E8E8E8;'> Text.ParserCombinators.ReadPrec <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-ParserCombinators-ReadPrec.html#v:pfail'>pfail </a>  ReadPrec a </tt>	Always fails
<tt style='background-color:#E8E8E8;'> Text.ParserCombinators.ReadPrec <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-ParserCombinators-ReadPrec.html#v:choice'>choice </a>  [ReadPrec a] -> ReadPrec a </tt>	Combines all parsers in the specified list
<tt style='background-color:#E8E8E8;'> Text.Read.Lex <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Read-Lex.html#v:Char'>Char </a>  Char -> Lexeme </tt>	Character literal
<tt style='background-color:#E8E8E8;'> Text.Read.Lex <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Read-Lex.html#v:String'>String </a>  String -> Lexeme </tt>	String literal, with escapes interpreted
<tt style='background-color:#E8E8E8;'> Text.Read.Lex <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Read-Lex.html#v:Punc'>Punc </a>  String -> Lexeme </tt>	Punctuation or reserved symbol, e
<tt style='background-color:#E8E8E8;'> Text.Read.Lex <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Read-Lex.html#v:Ident'>Ident </a>  String -> Lexeme </tt>	Haskell identifier, e
<tt style='background-color:#E8E8E8;'> Text.Read.Lex <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Read-Lex.html#v:Symbol'>Symbol </a>  String -> Lexeme </tt>	Haskell symbol, e
<tt style='background-color:#E8E8E8;'> Text.Read.Lex <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Read-Lex.html#v:hsLex'>hsLex </a>  ReadP String </tt>	Haskell lexer: returns the lexed string, rather than the lexeme
<tt style='background-color:#E8E8E8;'> Data.Word <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Word.html#v:byteSwap16'>byteSwap16 </a>  Word16 -> Word16 </tt>	Swap bytes in Word16
<tt style='background-color:#E8E8E8;'> Data.Word <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Word.html#v:byteSwap32'>byteSwap32 </a>  Word32 -> Word32 </tt>	Reverse order of bytes in Word32
<tt style='background-color:#E8E8E8;'> Data.Word <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Word.html#v:byteSwap64'>byteSwap64 </a>  Word64 -> Word64 </tt>	Reverse order of bytes in Word64
<tt style='background-color:#E8E8E8;'> Data.Ord <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Ord.html#v:compare'>compare </a>  Ord a => a -> a -> Ordering </tt>	The Ord class is used for totally ordered datatypes
<tt style='background-color:#E8E8E8;'> Data.Ord <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Ord.html#v:Down'>Down </a>  a -> Down a </tt>	The Down type allows you to reverse sort order conveniently
<tt style='background-color:#E8E8E8;'> Data.Ord <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Ord.html#v:comparing'>comparing </a>  (Ord a) => (b -> a) -> b -> b -> Ordering </tt>	comparing p x y = compare (p x) (p y)   Useful combinator for use in conjunction with the xxxBy family of functions from Data
<tt style='background-color:#E8E8E8;'> Data.Type.Coercion <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Type-Coercion.html#v:Coercion'>Coercion </a>  Coercion a b </tt>	Representational equality
<tt style='background-color:#E8E8E8;'> Data.Type.Coercion <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Type-Coercion.html#v:coerceWith'>coerceWith </a>  Coercion a b -> a -> b </tt>	Type-safe cast, using representational equality
<tt style='background-color:#E8E8E8;'> Data.Type.Coercion <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Type-Coercion.html#v:sym'>sym </a>  Coercion a b -> Coercion b a </tt>	Symmetry of representational equality
<tt style='background-color:#E8E8E8;'> Data.Type.Coercion <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Type-Coercion.html#v:trans'>trans </a>  Coercion a b -> Coercion b c -> Coercion a c </tt>	Transitivity of representational equality
<tt style='background-color:#E8E8E8;'> Data.Type.Coercion <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Type-Coercion.html#v:testCoercion'>testCoercion </a>  TestCoercion f => f a -> f b -> Maybe (Coercion a b) </tt>	Conditionally prove the representational equality of a and b
<tt style='background-color:#E8E8E8;'> Control.Category <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Category.html#v:id'>id </a>  Category cat => cat a a </tt>	the identity morphism
<tt style='background-color:#E8E8E8;'> Control.Category <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Category.html#v:(DOT)'>(.) </a>  Category cat => cat b c -> cat a b -> cat a c </tt>	morphism composition
<tt style='background-color:#E8E8E8;'> Control.Category <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Category.html#v:(<<<)'>(<<<) </a>  Category cat => cat b c -> cat a b -> cat a c </tt>	Right-to-left composition
<tt style='background-color:#E8E8E8;'> Control.Category <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Category.html#v:(>>>)'>(>>>) </a>  Category cat => cat a b -> cat b c -> cat a c </tt>	Left-to-right composition
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:isControl'>isControl </a>  Char -> Bool </tt>	Selects control characters, which are the non-printing characters of the Latin-1 subset of Unicode
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:isSpace'>isSpace </a>  Char -> Bool </tt>	Returns True for any Unicode space character, and the control characters \t, \n, \r, \f, \v
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:isLower'>isLower </a>  Char -> Bool </tt>	Selects lower-case alphabetic Unicode characters (letters)
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:isUpper'>isUpper </a>  Char -> Bool </tt>	Selects upper-case or title-case alphabetic Unicode characters (letters)
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:isAlpha'>isAlpha </a>  Char -> Bool </tt>	Selects alphabetic Unicode characters (lower-case, upper-case and title-case letters, plus letters of caseless scripts and modifiers letters)
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:isAlphaNum'>isAlphaNum </a>  Char -> Bool </tt>	Selects alphabetic or numeric digit Unicode characters
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:isPrint'>isPrint </a>  Char -> Bool </tt>	Selects printable Unicode characters (letters, numbers, marks, punctuation, symbols and spaces)
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:isDigit'>isDigit </a>  Char -> Bool </tt>	Selects ASCII digits
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:isOctDigit'>isOctDigit </a>  Char -> Bool </tt>	Selects ASCII octal digits
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:isHexDigit'>isHexDigit </a>  Char -> Bool </tt>	Selects ASCII hexadecimal digits
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:isLetter'>isLetter </a>  Char -> Bool </tt>	Selects alphabetic Unicode characters (lower-case, upper-case and title-case letters, plus letters of caseless scripts and modifiers letters)
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:isMark'>isMark </a>  Char -> Bool </tt>	Selects Unicode mark characters, for example accents and the like, which combine with preceding characters
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:isNumber'>isNumber </a>  Char -> Bool </tt>	Selects Unicode numeric characters, including digits from various scripts, Roman numerals, et cetera
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:isPunctuation'>isPunctuation </a>  Char -> Bool </tt>	Selects Unicode punctuation characters, including various kinds of connectors, brackets and quotes
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:isSymbol'>isSymbol </a>  Char -> Bool </tt>	Selects Unicode symbol characters, including mathematical and currency symbols
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:isSeparator'>isSeparator </a>  Char -> Bool </tt>	Selects Unicode space and separator characters
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:isAscii'>isAscii </a>  Char -> Bool </tt>	Selects the first 128 characters of the Unicode character set, corresponding to the ASCII character set
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:isLatin1'>isLatin1 </a>  Char -> Bool </tt>	Selects the first 256 characters of the Unicode character set, corresponding to the ISO 8859-1 (Latin-1) character set
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:isAsciiUpper'>isAsciiUpper </a>  Char -> Bool </tt>	Selects ASCII upper-case letters
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:isAsciiLower'>isAsciiLower </a>  Char -> Bool </tt>	Selects ASCII lower-case letters
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:UppercaseLetter'>UppercaseLetter </a>  GeneralCategory </tt>	Lu: Letter, Uppercase
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:LowercaseLetter'>LowercaseLetter </a>  GeneralCategory </tt>	Ll: Letter, Lowercase
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:TitlecaseLetter'>TitlecaseLetter </a>  GeneralCategory </tt>	Lt: Letter, Titlecase
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:ModifierLetter'>ModifierLetter </a>  GeneralCategory </tt>	Lm: Letter, Modifier
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:OtherLetter'>OtherLetter </a>  GeneralCategory </tt>	Lo: Letter, Other
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:NonSpacingMark'>NonSpacingMark </a>  GeneralCategory </tt>	Mn: Mark, Non-Spacing
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:SpacingCombiningMark'>SpacingCombiningMark </a>  GeneralCategory </tt>	Mc: Mark, Spacing Combining
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:EnclosingMark'>EnclosingMark </a>  GeneralCategory </tt>	Me: Mark, Enclosing
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:DecimalNumber'>DecimalNumber </a>  GeneralCategory </tt>	Nd: Number, Decimal
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:LetterNumber'>LetterNumber </a>  GeneralCategory </tt>	Nl: Number, Letter
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:OtherNumber'>OtherNumber </a>  GeneralCategory </tt>	No: Number, Other
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:ConnectorPunctuation'>ConnectorPunctuation </a>  GeneralCategory </tt>	Pc: Punctuation, Connector
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:DashPunctuation'>DashPunctuation </a>  GeneralCategory </tt>	Pd: Punctuation, Dash
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:OpenPunctuation'>OpenPunctuation </a>  GeneralCategory </tt>	Ps: Punctuation, Open
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:ClosePunctuation'>ClosePunctuation </a>  GeneralCategory </tt>	Pe: Punctuation, Close
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:InitialQuote'>InitialQuote </a>  GeneralCategory </tt>	Pi: Punctuation, Initial quote
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:FinalQuote'>FinalQuote </a>  GeneralCategory </tt>	Pf: Punctuation, Final quote
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:OtherPunctuation'>OtherPunctuation </a>  GeneralCategory </tt>	Po: Punctuation, Other
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:MathSymbol'>MathSymbol </a>  GeneralCategory </tt>	Sm: Symbol, Math
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:CurrencySymbol'>CurrencySymbol </a>  GeneralCategory </tt>	Sc: Symbol, Currency
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:ModifierSymbol'>ModifierSymbol </a>  GeneralCategory </tt>	Sk: Symbol, Modifier
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:OtherSymbol'>OtherSymbol </a>  GeneralCategory </tt>	So: Symbol, Other
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:Space'>Space </a>  GeneralCategory </tt>	Zs: Separator, Space
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:LineSeparator'>LineSeparator </a>  GeneralCategory </tt>	Zl: Separator, Line
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:ParagraphSeparator'>ParagraphSeparator </a>  GeneralCategory </tt>	Zp: Separator, Paragraph
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:Control'>Control </a>  GeneralCategory </tt>	Cc: Other, Control
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:Format'>Format </a>  GeneralCategory </tt>	Cf: Other, Format
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:Surrogate'>Surrogate </a>  GeneralCategory </tt>	Cs: Other, Surrogate
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:PrivateUse'>PrivateUse </a>  GeneralCategory </tt>	Co: Other, Private Use
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:NotAssigned'>NotAssigned </a>  GeneralCategory </tt>	Cn: Other, Not Assigned
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:generalCategory'>generalCategory </a>  Char -> GeneralCategory </tt>	The Unicode general category of the character
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:toUpper'>toUpper </a>  Char -> Char </tt>	Convert a letter to the corresponding upper-case letter, if any
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:toLower'>toLower </a>  Char -> Char </tt>	Convert a letter to the corresponding lower-case letter, if any
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:toTitle'>toTitle </a>  Char -> Char </tt>	Convert a letter to the corresponding title-case or upper-case letter, if any
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:digitToInt'>digitToInt </a>  Char -> Int </tt>	Convert a single digit Char to the corresponding Int
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:intToDigit'>intToDigit </a>  Int -> Char </tt>	Convert an Int in the range 0
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:ord'>ord </a>  Char -> Int </tt>	The fromEnum method restricted to the type Char
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:chr'>chr </a>  Int -> Char </tt>	The toEnum method restricted to the type Char
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:showLitChar'>showLitChar </a>  Char -> ShowS </tt>	Convert a character to a string using only printable characters, using Haskell source-language escape conventions
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:lexLitChar'>lexLitChar </a>  ReadS String </tt>	Read a string representation of a character, using Haskell source-language escape conventions
<tt style='background-color:#E8E8E8;'> Data.Char <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Char.html#v:readLitChar'>readLitChar </a>  ReadS Char </tt>	Read a string representation of a character, using Haskell source-language escape conventions, and convert it to the character that it encodes
<tt style='background-color:#E8E8E8;'> GHC.OldList <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-OldList.html#v:null'>null </a>  [a] -> Bool </tt>	Test whether a list is empty
<tt style='background-color:#E8E8E8;'> GHC.OldList <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-OldList.html#v:length'>length </a>  [a] -> Int </tt>	length returns the length of a finite list as an Int
<tt style='background-color:#E8E8E8;'> GHC.OldList <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-OldList.html#v:foldl'>foldl </a>  (b -> a -> b) -> b -> [a] -> b </tt>	foldl, applied to a binary operator, a starting value (typically the left-identity of the operator), and a list, reduces the list using the binary operator, from left to right:   foldl f z [x1, x2,
<tt style='background-color:#E8E8E8;'> GHC.OldList <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-OldList.html#v:foldl''>foldl' </a>  (b -> a -> b) -> b -> [a] -> b </tt>	A strict version of foldl
<tt style='background-color:#E8E8E8;'> GHC.OldList <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-OldList.html#v:foldl1'>foldl1 </a>  (a -> a -> a) -> [a] -> a </tt>	foldl1 is a variant of foldl that has no starting value argument, and thus must be applied to non-empty lists
<tt style='background-color:#E8E8E8;'> GHC.OldList <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-OldList.html#v:foldr'>foldr </a>  (a -> b -> b) -> b -> [a] -> b </tt>	foldr, applied to a binary operator, a starting value (typically the right-identity of the operator), and a list, reduces the list using the binary operator, from right to left:   foldr f z [x1, x2,
<tt style='background-color:#E8E8E8;'> GHC.OldList <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-OldList.html#v:foldr1'>foldr1 </a>  (a -> a -> a) -> [a] -> a </tt>	foldr1 is a variant of foldr that has no starting value argument, and thus must be applied to non-empty lists
<tt style='background-color:#E8E8E8;'> GHC.OldList <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-OldList.html#v:concat'>concat </a>  [[a]] -> [a] </tt>	Concatenate a list of lists
<tt style='background-color:#E8E8E8;'> GHC.OldList <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-OldList.html#v:concatMap'>concatMap </a>  (a -> [b]) -> [a] -> [b] </tt>	Map a function over a list and concatenate the results
<tt style='background-color:#E8E8E8;'> GHC.OldList <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-OldList.html#v:and'>and </a>  [Bool] -> Bool </tt>	and returns the conjunction of a Boolean list
<tt style='background-color:#E8E8E8;'> GHC.OldList <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-OldList.html#v:or'>or </a>  [Bool] -> Bool </tt>	or returns the disjunction of a Boolean list
<tt style='background-color:#E8E8E8;'> GHC.OldList <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-OldList.html#v:any'>any </a>  (a -> Bool) -> [a] -> Bool </tt>	Applied to a predicate and a list, any determines if any element of the list satisfies the predicate
<tt style='background-color:#E8E8E8;'> GHC.OldList <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-OldList.html#v:all'>all </a>  (a -> Bool) -> [a] -> Bool </tt>	Applied to a predicate and a list, all determines if all elements of the list satisfy the predicate
<tt style='background-color:#E8E8E8;'> GHC.OldList <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-OldList.html#v:sum'>sum </a>  (Num a) => [a] -> a </tt>	The sum function computes the sum of a finite list of numbers
<tt style='background-color:#E8E8E8;'> GHC.OldList <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-OldList.html#v:product'>product </a>  (Num a) => [a] -> a </tt>	The product function computes the product of a finite list of numbers
<tt style='background-color:#E8E8E8;'> GHC.OldList <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-OldList.html#v:maximum'>maximum </a>  (Ord a) => [a] -> a </tt>	maximum returns the maximum value from a list, which must be non-empty, finite, and of an ordered type
<tt style='background-color:#E8E8E8;'> GHC.OldList <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-OldList.html#v:minimum'>minimum </a>  (Ord a) => [a] -> a </tt>	minimum returns the minimum value from a list, which must be non-empty, finite, and of an ordered type
<tt style='background-color:#E8E8E8;'> GHC.OldList <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-OldList.html#v:mapAccumL'>mapAccumL </a>  (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y]) </tt>	The mapAccumL function behaves like a combination of map and foldl; it applies a function to each element of a list, passing an accumulating parameter from left to right, and returning a final value of this accumulator together with the new list
<tt style='background-color:#E8E8E8;'> GHC.OldList <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-OldList.html#v:mapAccumR'>mapAccumR </a>  (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y]) </tt>	The mapAccumR function behaves like a combination of map and foldr; it applies a function to each element of a list, passing an accumulating parameter from right to left, and returning a final value of this accumulator together with the new list
<tt style='background-color:#E8E8E8;'> GHC.OldList <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-OldList.html#v:elem'>elem </a>  (Eq a) => a -> [a] -> Bool </tt>	elem is the list membership predicate, usually written in infix form, e
<tt style='background-color:#E8E8E8;'> GHC.OldList <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-OldList.html#v:find'>find </a>  (a -> Bool) -> [a] -> Maybe a </tt>	The find function takes a predicate and a list and returns the first element in the list matching the predicate, or Nothing if there is no such element
<tt style='background-color:#E8E8E8;'> GHC.OldList <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-OldList.html#v:maximumBy'>maximumBy </a>  (a -> a -> Ordering) -> [a] -> a </tt>	The maximumBy function takes a comparison function and a list and returns the greatest element of the list by the comparison function
<tt style='background-color:#E8E8E8;'> GHC.OldList <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-OldList.html#v:minimumBy'>minimumBy </a>  (a -> a -> Ordering) -> [a] -> a </tt>	The minimumBy function takes a comparison function and a list and returns the least element of the list by the comparison function
<tt style='background-color:#E8E8E8;'> Data.Proxy <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Proxy.html#v:Proxy'>Proxy </a>  Proxy t </tt>	A concrete, poly-kinded proxy type
<tt style='background-color:#E8E8E8;'> Data.Proxy <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Proxy.html#v:asProxyTypeOf'>asProxyTypeOf </a>  a -> Proxy a -> a </tt>	asProxyTypeOf is a type-restricted version of const
<tt style='background-color:#E8E8E8;'> Data.Proxy <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Proxy.html#v:KProxy'>KProxy </a>  KProxy </tt>	A concrete, promotable proxy type, for use at the kind level There are no instances for this because it is intended at the kind level only
<tt style='background-color:#E8E8E8;'> Numeric <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Numeric.html#v:showSigned'>showSigned </a>  (Real a) => (a -> ShowS) -> Int -> a -> ShowS </tt>	Converts a possibly-negative Real value to a string
<tt style='background-color:#E8E8E8;'> Numeric <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Numeric.html#v:showIntAtBase'>showIntAtBase </a>  (Integral a, Show a) => a -> (Int -> Char) -> a -> ShowS </tt>	Shows a non-negative Integral number using the base specified by the first argument, and the character representation specified by the second
<tt style='background-color:#E8E8E8;'> Numeric <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Numeric.html#v:showInt'>showInt </a>  Integral a => a -> ShowS </tt>	Show non-negative Integral numbers in base 10
<tt style='background-color:#E8E8E8;'> Numeric <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Numeric.html#v:showHex'>showHex </a>  (Integral a, Show a) => a -> ShowS </tt>	Show non-negative Integral numbers in base 16
<tt style='background-color:#E8E8E8;'> Numeric <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Numeric.html#v:showOct'>showOct </a>  (Integral a, Show a) => a -> ShowS </tt>	Show non-negative Integral numbers in base 8
<tt style='background-color:#E8E8E8;'> Numeric <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Numeric.html#v:showEFloat'>showEFloat </a>  (RealFloat a) => Maybe Int -> a -> ShowS </tt>	Show a signed RealFloat value using scientific (exponential) notation (e
<tt style='background-color:#E8E8E8;'> Numeric <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Numeric.html#v:showFFloat'>showFFloat </a>  (RealFloat a) => Maybe Int -> a -> ShowS </tt>	Show a signed RealFloat value using standard decimal notation (e
<tt style='background-color:#E8E8E8;'> Numeric <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Numeric.html#v:showGFloat'>showGFloat </a>  (RealFloat a) => Maybe Int -> a -> ShowS </tt>	Show a signed RealFloat value using standard decimal notation for arguments whose absolute value lies between 0
<tt style='background-color:#E8E8E8;'> Numeric <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Numeric.html#v:showFFloatAlt'>showFFloatAlt </a>  (RealFloat a) => Maybe Int -> a -> ShowS </tt>	Show a signed RealFloat value using standard decimal notation (e
<tt style='background-color:#E8E8E8;'> Numeric <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Numeric.html#v:showGFloatAlt'>showGFloatAlt </a>  (RealFloat a) => Maybe Int -> a -> ShowS </tt>	Show a signed RealFloat value using standard decimal notation for arguments whose absolute value lies between 0
<tt style='background-color:#E8E8E8;'> Numeric <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Numeric.html#v:showFloat'>showFloat </a>  (RealFloat a) => a -> ShowS </tt>	Show a signed RealFloat value to full precision using standard decimal notation for arguments whose absolute value lies between 0
<tt style='background-color:#E8E8E8;'> Numeric <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Numeric.html#v:floatToDigits'>floatToDigits </a>  (RealFloat a) => Integer -> a -> ([Int], Int) </tt>	floatToDigits takes a base and a non-negative RealFloat number, and returns a list of digits and an exponent
<tt style='background-color:#E8E8E8;'> Numeric <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Numeric.html#v:readSigned'>readSigned </a>  (Real a) => ReadS a -> ReadS a </tt>	Reads a signed Real value, given a reader for an unsigned value
<tt style='background-color:#E8E8E8;'> Numeric <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Numeric.html#v:readInt'>readInt </a>  Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a </tt>	Reads an unsigned Integral value in an arbitrary base
<tt style='background-color:#E8E8E8;'> Numeric <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Numeric.html#v:readDec'>readDec </a>  (Eq a, Num a) => ReadS a </tt>	Read an unsigned number in decimal notation
<tt style='background-color:#E8E8E8;'> Numeric <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Numeric.html#v:readOct'>readOct </a>  (Eq a, Num a) => ReadS a </tt>	Read an unsigned number in octal notation
<tt style='background-color:#E8E8E8;'> Numeric <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Numeric.html#v:readHex'>readHex </a>  (Eq a, Num a) => ReadS a </tt>	Read an unsigned number in hexadecimal notation
<tt style='background-color:#E8E8E8;'> Numeric <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Numeric.html#v:readFloat'>readFloat </a>  RealFrac a => ReadS a </tt>	Reads an unsigned RealFrac value, expressed in decimal scientific notation
<tt style='background-color:#E8E8E8;'> Numeric <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Numeric.html#v:lexDigits'>lexDigits </a>  ReadS String </tt>	Reads a non-empty string of decimal digits
<tt style='background-color:#E8E8E8;'> Numeric <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Numeric.html#v:fromRat'>fromRat </a>  (RealFloat a) => Rational -> a </tt>	Converts a Rational value into any type in class RealFloat
<tt style='background-color:#E8E8E8;'> Data.Typeable.Internal <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Typeable-Internal.html#v:Proxy'>Proxy </a>  Proxy t </tt>	A concrete, poly-kinded proxy type
<tt style='background-color:#E8E8E8;'> Data.Typeable.Internal <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Typeable-Internal.html#v:typeRep'>typeRep </a>  Typeable a => proxy a -> TypeRep </tt>	Takes a value of type a and returns a concrete representation of that type
<tt style='background-color:#E8E8E8;'> Data.Typeable.Internal <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Typeable-Internal.html#v:mkTyCon3'>mkTyCon3 </a>  String -> String -> String -> TyCon </tt>	Builds a TyCon object representing a type constructor
<tt style='background-color:#E8E8E8;'> Data.Typeable.Internal <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Typeable-Internal.html#v:mkTyConApp'>mkTyConApp </a>  TyCon -> [TypeRep] -> TypeRep </tt>	Applies a monomorphic type constructor to a sequence of types
<tt style='background-color:#E8E8E8;'> Data.Typeable.Internal <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Typeable-Internal.html#v:mkPolyTyConApp'>mkPolyTyConApp </a>  TyCon -> [KindRep] -> [TypeRep] -> TypeRep </tt>	Applies a polymorhic type constructor to a sequence of kinds and types
<tt style='background-color:#E8E8E8;'> Data.Typeable.Internal <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Typeable-Internal.html#v:mkAppTy'>mkAppTy </a>  TypeRep -> TypeRep -> TypeRep </tt>	Adds a TypeRep argument to a TypeRep
<tt style='background-color:#E8E8E8;'> Data.Typeable.Internal <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Typeable-Internal.html#v:typeRepTyCon'>typeRepTyCon </a>  TypeRep -> TyCon </tt>	Observe the type constructor of a type representation
<tt style='background-color:#E8E8E8;'> Data.Typeable.Internal <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Typeable-Internal.html#v:typeRep#'>typeRep# </a>  Typeable a => Proxy# a -> TypeRep </tt>	The class Typeable allows a concrete representation of a type to be calculated
<tt style='background-color:#E8E8E8;'> Data.Typeable.Internal <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Typeable-Internal.html#v:mkFunTy'>mkFunTy </a>  TypeRep -> TypeRep -> TypeRep </tt>	A special case of mkTyConApp, which applies the function type constructor to a pair of types
<tt style='background-color:#E8E8E8;'> Data.Typeable.Internal <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Typeable-Internal.html#v:splitTyConApp'>splitTyConApp </a>  TypeRep -> (TyCon, [TypeRep]) </tt>	Splits a type constructor application
<tt style='background-color:#E8E8E8;'> Data.Typeable.Internal <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Typeable-Internal.html#v:splitPolyTyConApp'>splitPolyTyConApp </a>  TypeRep -> (TyCon, [KindRep], [TypeRep]) </tt>	Split a type constructor application
<tt style='background-color:#E8E8E8;'> Data.Typeable.Internal <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Typeable-Internal.html#v:funResultTy'>funResultTy </a>  TypeRep -> TypeRep -> Maybe TypeRep </tt>	Applies a type to a function type
<tt style='background-color:#E8E8E8;'> Data.Typeable.Internal <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Typeable-Internal.html#v:typeRepArgs'>typeRepArgs </a>  TypeRep -> [TypeRep] </tt>	Observe the argument types of a type representation
<tt style='background-color:#E8E8E8;'> Data.Typeable.Internal <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Typeable-Internal.html#v:typeRepFingerprint'>typeRepFingerprint </a>  TypeRep -> Fingerprint </tt>	Observe the Fingerprint of a type representation
<tt style='background-color:#E8E8E8;'> Data.Typeable.Internal <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Typeable-Internal.html#v:rnfTypeRep'>rnfTypeRep </a>  TypeRep -> () </tt>	Helper to fully evaluate TypeRep for use as NFData(rnf) implementation
<tt style='background-color:#E8E8E8;'> Data.Typeable.Internal <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Typeable-Internal.html#v:tyConString'>tyConString </a>  TyCon -> String </tt>	Deprecated: renamed to tyConName; tyConModule and tyConPackage are also available
<tt style='background-color:#E8E8E8;'> Data.Typeable.Internal <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Typeable-Internal.html#v:rnfTyCon'>rnfTyCon </a>  TyCon -> () </tt>	Helper to fully evaluate TyCon for use as NFData(rnf) implementation
<tt style='background-color:#E8E8E8;'> Data.Typeable.Internal <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Typeable-Internal.html#v:typeRepKinds'>typeRepKinds </a>  TypeRep -> [KindRep] </tt>	Observe the argument kinds of a type representation
<tt style='background-color:#E8E8E8;'> Data.Typeable.Internal <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Typeable-Internal.html#v:typeLitTypeRep'>typeLitTypeRep </a>  String -> TypeRep </tt>	An internal function, to make representations for type literals
<tt style='background-color:#E8E8E8;'> Foreign.StablePtr <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-StablePtr.html#v:newStablePtr'>newStablePtr </a>  a -> IO (StablePtr a) </tt>	Create a stable pointer referring to the given Haskell value
<tt style='background-color:#E8E8E8;'> Foreign.StablePtr <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-StablePtr.html#v:deRefStablePtr'>deRefStablePtr </a>  StablePtr a -> IO a </tt>	Obtain the Haskell value referenced by a stable pointer
<tt style='background-color:#E8E8E8;'> Foreign.StablePtr <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-StablePtr.html#v:freeStablePtr'>freeStablePtr </a>  StablePtr a -> IO () </tt>	Dissolve the association between the stable pointer and the Haskell value
<tt style='background-color:#E8E8E8;'> Foreign.StablePtr <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-StablePtr.html#v:castStablePtrToPtr'>castStablePtrToPtr </a>  StablePtr a -> Ptr () </tt>	Coerce a stable pointer to an address
<tt style='background-color:#E8E8E8;'> Foreign.StablePtr <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-StablePtr.html#v:castPtrToStablePtr'>castPtrToStablePtr </a>  Ptr () -> StablePtr a </tt>	The inverse of castStablePtrToPtr
<tt style='background-color:#E8E8E8;'> Data.Typeable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Typeable.html#v:typeRep'>typeRep </a>  Typeable a => proxy a -> TypeRep </tt>	Takes a value of type a and returns a concrete representation of that type
<tt style='background-color:#E8E8E8;'> Data.Typeable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Typeable.html#v:cast'>cast </a>  (Typeable a, Typeable b) => a -> Maybe b </tt>	The type-safe cast operation
<tt style='background-color:#E8E8E8;'> Data.Typeable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Typeable.html#v:gcast'>gcast </a>  (Typeable a, Typeable b) => c a -> Maybe (c b) </tt>	A flexible variation parameterised in a type constructor
<tt style='background-color:#E8E8E8;'> Data.Typeable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Typeable.html#v:gcast1'>gcast1 </a>  (Typeable t, Typeable t') => c (t a) -> Maybe (c (t' a)) </tt>	Cast over k1 -&gt; k2
<tt style='background-color:#E8E8E8;'> Data.Typeable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Typeable.html#v:gcast2'>gcast2 </a>  (Typeable t, Typeable t') => c (t a b) -> Maybe (c (t' a b)) </tt>	Cast over k1 -&gt; k2 -&gt; k3
<tt style='background-color:#E8E8E8;'> Data.Typeable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Typeable.html#v:Proxy'>Proxy </a>  Proxy t </tt>	A concrete, poly-kinded proxy type
<tt style='background-color:#E8E8E8;'> Data.Typeable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Typeable.html#v:typeRepFingerprint'>typeRepFingerprint </a>  TypeRep -> Fingerprint </tt>	Observe the Fingerprint of a type representation
<tt style='background-color:#E8E8E8;'> Data.Typeable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Typeable.html#v:rnfTypeRep'>rnfTypeRep </a>  TypeRep -> () </tt>	Helper to fully evaluate TypeRep for use as NFData(rnf) implementation
<tt style='background-color:#E8E8E8;'> Data.Typeable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Typeable.html#v:tyConString'>tyConString </a>  TyCon -> String </tt>	Deprecated: renamed to tyConName; tyConModule and tyConPackage are also available
<tt style='background-color:#E8E8E8;'> Data.Typeable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Typeable.html#v:rnfTyCon'>rnfTyCon </a>  TyCon -> () </tt>	Helper to fully evaluate TyCon for use as NFData(rnf) implementation
<tt style='background-color:#E8E8E8;'> Data.Typeable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Typeable.html#v:mkTyCon3'>mkTyCon3 </a>  String -> String -> String -> TyCon </tt>	Builds a TyCon object representing a type constructor
<tt style='background-color:#E8E8E8;'> Data.Typeable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Typeable.html#v:mkTyConApp'>mkTyConApp </a>  TyCon -> [TypeRep] -> TypeRep </tt>	Applies a monomorphic type constructor to a sequence of types
<tt style='background-color:#E8E8E8;'> Data.Typeable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Typeable.html#v:mkAppTy'>mkAppTy </a>  TypeRep -> TypeRep -> TypeRep </tt>	Adds a TypeRep argument to a TypeRep
<tt style='background-color:#E8E8E8;'> Data.Typeable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Typeable.html#v:mkFunTy'>mkFunTy </a>  TypeRep -> TypeRep -> TypeRep </tt>	A special case of mkTyConApp, which applies the function type constructor to a pair of types
<tt style='background-color:#E8E8E8;'> Data.Typeable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Typeable.html#v:splitTyConApp'>splitTyConApp </a>  TypeRep -> (TyCon, [TypeRep]) </tt>	Splits a type constructor application
<tt style='background-color:#E8E8E8;'> Data.Typeable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Typeable.html#v:funResultTy'>funResultTy </a>  TypeRep -> TypeRep -> Maybe TypeRep </tt>	Applies a type to a function type
<tt style='background-color:#E8E8E8;'> Data.Typeable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Typeable.html#v:typeRepTyCon'>typeRepTyCon </a>  TypeRep -> TyCon </tt>	Observe the type constructor of a type representation
<tt style='background-color:#E8E8E8;'> Data.Typeable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Typeable.html#v:typeRepArgs'>typeRepArgs </a>  TypeRep -> [TypeRep] </tt>	Observe the argument types of a type representation
<tt style='background-color:#E8E8E8;'> Data.Either <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Either.html#v:Left'>Left </a>  a -> Either a b </tt>	The Either type represents values with two possibilities: a value of type Either a b is either Left a or Right b
<tt style='background-color:#E8E8E8;'> Data.Either <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Either.html#v:either'>either </a>  (a -> c) -> (b -> c) -> Either a b -> c </tt>	Case analysis for the Either type
<tt style='background-color:#E8E8E8;'> Data.Either <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Either.html#v:lefts'>lefts </a>  [Either a b] -> [a] </tt>	Extracts from a list of Either all the Left elements
<tt style='background-color:#E8E8E8;'> Data.Either <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Either.html#v:rights'>rights </a>  [Either a b] -> [b] </tt>	Extracts from a list of Either all the Right elements
<tt style='background-color:#E8E8E8;'> Data.Either <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Either.html#v:isLeft'>isLeft </a>  Either a b -> Bool </tt>	Return True if the given value is a Left-value, False otherwise
<tt style='background-color:#E8E8E8;'> Data.Either <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Either.html#v:isRight'>isRight </a>  Either a b -> Bool </tt>	Return True if the given value is a Right-value, False otherwise
<tt style='background-color:#E8E8E8;'> Data.Either <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Either.html#v:partitionEithers'>partitionEithers </a>  [Either a b] -> ([a], [b]) </tt>	Partitions a list of Either into two lists
<tt style='background-color:#E8E8E8;'> GHC.Generics <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Generics.html#v:U1'>U1 </a>  U1 p </tt>	Unit: used for constructors without arguments
<tt style='background-color:#E8E8E8;'> GHC.Generics <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Generics.html#v:Par1'>Par1 </a>  p -> Par1 p </tt>	Used for marking occurrences of the parameter
<tt style='background-color:#E8E8E8;'> GHC.Generics <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Generics.html#v:Rec1'>Rec1 </a>  f p -> Rec1 f p </tt>	Recursive calls of kind * -&gt; *
<tt style='background-color:#E8E8E8;'> GHC.Generics <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Generics.html#v:K1'>K1 </a>  c -> K1 i c p </tt>	Constants, additional parameters and recursion of kind *
<tt style='background-color:#E8E8E8;'> GHC.Generics <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Generics.html#v:M1'>M1 </a>  f p -> M1 i c f p </tt>	Meta-information (constructor names, etc
<tt style='background-color:#E8E8E8;'> GHC.Generics <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Generics.html#v:L1'>L1 </a>  (f p) -> (:+:) f g p </tt>	Sums: encode choice between constructors
<tt style='background-color:#E8E8E8;'> GHC.Generics <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Generics.html#v:(:*:)'>(:*:) </a>  f p -> g p -> (:*:) f g p </tt>	Products: encode multiple arguments to constructors
<tt style='background-color:#E8E8E8;'> GHC.Generics <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Generics.html#v:Comp1'>Comp1 </a>  f (g p) -> (:.:) f g p </tt>	Composition of functors
<tt style='background-color:#E8E8E8;'> GHC.Generics <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Generics.html#v:Prefix'>Prefix </a>  Fixity </tt>	Datatype to represent the fixity of a constructor
<tt style='background-color:#E8E8E8;'> GHC.Generics <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Generics.html#v:LeftAssociative'>LeftAssociative </a>  Associativity </tt>	Datatype to represent the associativity of a constructor
<tt style='background-color:#E8E8E8;'> GHC.Generics <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Generics.html#v:NoArity'>NoArity </a>  Arity </tt>	Datatype to represent the arity of a tuple
<tt style='background-color:#E8E8E8;'> GHC.Generics <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Generics.html#v:prec'>prec </a>  Fixity -> Int </tt>	Get the precedence of a fixity value
<tt style='background-color:#E8E8E8;'> GHC.Generics <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Generics.html#v:from'>from </a>  Generic a => a -> (Rep a) x </tt>	Convert from the datatype to its representation
<tt style='background-color:#E8E8E8;'> GHC.Generics <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Generics.html#v:to'>to </a>  Generic a => (Rep a) x -> a </tt>	Convert from the representation to the datatype
<tt style='background-color:#E8E8E8;'> GHC.Generics <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Generics.html#v:from1'>from1 </a>  Generic1 f => f a -> (Rep1 f) a </tt>	Convert from the datatype to its representation
<tt style='background-color:#E8E8E8;'> GHC.Generics <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Generics.html#v:to1'>to1 </a>  Generic1 f => (Rep1 f) a -> f a </tt>	Convert from the representation to the datatype
<tt style='background-color:#E8E8E8;'> Data.Monoid <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Monoid.html#v:mempty'>mempty </a>  Monoid a => a </tt>	Identity of mappend
<tt style='background-color:#E8E8E8;'> Data.Monoid <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Monoid.html#v:mappend'>mappend </a>  Monoid a => a -> a -> a </tt>	An associative operation
<tt style='background-color:#E8E8E8;'> Data.Monoid <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Monoid.html#v:mconcat'>mconcat </a>  Monoid a => [a] -> a </tt>	Fold a list using the monoid
<tt style='background-color:#E8E8E8;'> Data.Monoid <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Monoid.html#v:(<>)'>(<>) </a>  Monoid m => m -> m -> m </tt>	An infix synonym for mappend
<tt style='background-color:#E8E8E8;'> Data.Monoid <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Monoid.html#v:Dual'>Dual </a>  a -> Dual a </tt>	The dual of a Monoid, obtained by swapping the arguments of mappend
<tt style='background-color:#E8E8E8;'> Data.Monoid <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Monoid.html#v:Endo'>Endo </a>  (a -> a) -> Endo a </tt>	The monoid of endomorphisms under composition
<tt style='background-color:#E8E8E8;'> Data.Monoid <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Monoid.html#v:All'>All </a>  Bool -> All </tt>	Boolean monoid under conjunction (&amp;&amp;)
<tt style='background-color:#E8E8E8;'> Data.Monoid <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Monoid.html#v:Any'>Any </a>  Bool -> Any </tt>	Boolean monoid under disjunction (||)
<tt style='background-color:#E8E8E8;'> Data.Monoid <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Monoid.html#v:Sum'>Sum </a>  a -> Sum a </tt>	Monoid under addition
<tt style='background-color:#E8E8E8;'> Data.Monoid <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Monoid.html#v:Product'>Product </a>  a -> Product a </tt>	Monoid under multiplication
<tt style='background-color:#E8E8E8;'> Data.Monoid <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Monoid.html#v:First'>First </a>  Maybe a -> First a </tt>	Maybe monoid returning the leftmost non-Nothing value
<tt style='background-color:#E8E8E8;'> Data.Monoid <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Monoid.html#v:Last'>Last </a>  Maybe a -> Last a </tt>	Maybe monoid returning the rightmost non-Nothing value
<tt style='background-color:#E8E8E8;'> Data.Monoid <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Monoid.html#v:Alt'>Alt </a>  f a -> Alt f a </tt>	Monoid under &lt;|&gt;
<tt style='background-color:#E8E8E8;'> Data.Foldable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Foldable.html#v:fold'>fold </a>  (Foldable t, Monoid m) => t m -> m </tt>	Combine the elements of a structure using a monoid
<tt style='background-color:#E8E8E8;'> Data.Foldable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Foldable.html#v:foldMap'>foldMap </a>  (Foldable t, Monoid m) => (a -> m) -> t a -> m </tt>	Map each element of the structure to a monoid, and combine the results
<tt style='background-color:#E8E8E8;'> Data.Foldable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Foldable.html#v:foldr'>foldr </a>  Foldable t => (a -> b -> b) -> b -> t a -> b </tt>	Right-associative fold of a structure
<tt style='background-color:#E8E8E8;'> Data.Foldable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Foldable.html#v:foldr''>foldr' </a>  Foldable t => (a -> b -> b) -> b -> t a -> b </tt>	Right-associative fold of a structure, but with strict application of the operator
<tt style='background-color:#E8E8E8;'> Data.Foldable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Foldable.html#v:foldl'>foldl </a>  Foldable t => (b -> a -> b) -> b -> t a -> b </tt>	Left-associative fold of a structure
<tt style='background-color:#E8E8E8;'> Data.Foldable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Foldable.html#v:foldl''>foldl' </a>  Foldable t => (b -> a -> b) -> b -> t a -> b </tt>	Left-associative fold of a structure
<tt style='background-color:#E8E8E8;'> Data.Foldable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Foldable.html#v:foldr1'>foldr1 </a>  Foldable t => (a -> a -> a) -> t a -> a </tt>	A variant of foldr that has no base case, and thus may only be applied to non-empty structures
<tt style='background-color:#E8E8E8;'> Data.Foldable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Foldable.html#v:foldl1'>foldl1 </a>  Foldable t => (a -> a -> a) -> t a -> a </tt>	A variant of foldl that has no base case, and thus may only be applied to non-empty structures
<tt style='background-color:#E8E8E8;'> Data.Foldable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Foldable.html#v:toList'>toList </a>  Foldable t => t a -> [a] </tt>	List of elements of a structure, from left to right
<tt style='background-color:#E8E8E8;'> Data.Foldable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Foldable.html#v:null'>null </a>  Foldable t => t a -> Bool </tt>	Test whether the structure is empty
<tt style='background-color:#E8E8E8;'> Data.Foldable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Foldable.html#v:length'>length </a>  Foldable t => t a -> Int </tt>	Returns the size/length of a finite structure as an Int
<tt style='background-color:#E8E8E8;'> Data.Foldable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Foldable.html#v:elem'>elem </a>  (Foldable t, Eq a) => a -> t a -> Bool </tt>	Does the element occur in the structure?
<tt style='background-color:#E8E8E8;'> Data.Foldable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Foldable.html#v:maximum'>maximum </a>  (Foldable t, Ord a) => t a -> a </tt>	The largest element of a non-empty structure
<tt style='background-color:#E8E8E8;'> Data.Foldable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Foldable.html#v:minimum'>minimum </a>  (Foldable t, Ord a) => t a -> a </tt>	The least element of a non-empty structure
<tt style='background-color:#E8E8E8;'> Data.Foldable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Foldable.html#v:sum'>sum </a>  (Foldable t, Num a) => t a -> a </tt>	The sum function computes the sum of the numbers of a structure
<tt style='background-color:#E8E8E8;'> Data.Foldable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Foldable.html#v:product'>product </a>  (Foldable t, Num a) => t a -> a </tt>	The product function computes the product of the numbers of a structure
<tt style='background-color:#E8E8E8;'> Data.Foldable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Foldable.html#v:foldrM'>foldrM </a>  (Foldable t, Monad m) => (a -> b -> m b) -> b -> t a -> m b </tt>	Monadic fold over the elements of a structure, associating to the right
<tt style='background-color:#E8E8E8;'> Data.Foldable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Foldable.html#v:foldlM'>foldlM </a>  (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b </tt>	Monadic fold over the elements of a structure, associating to the left
<tt style='background-color:#E8E8E8;'> Data.Foldable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Foldable.html#v:traverse_'>traverse_ </a>  (Foldable t, Applicative f) => (a -> f b) -> t a -> f () </tt>	Map each element of a structure to an action, evaluate these actions from left to right, and ignore the results
<tt style='background-color:#E8E8E8;'> Data.Foldable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Foldable.html#v:for_'>for_ </a>  (Foldable t, Applicative f) => t a -> (a -> f b) -> f () </tt>	for_ is traverse_ with its arguments flipped
<tt style='background-color:#E8E8E8;'> Data.Foldable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Foldable.html#v:sequenceA_'>sequenceA_ </a>  (Foldable t, Applicative f) => t (f a) -> f () </tt>	Evaluate each action in the structure from left to right, and ignore the results
<tt style='background-color:#E8E8E8;'> Data.Foldable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Foldable.html#v:asum'>asum </a>  (Foldable t, Alternative f) => t (f a) -> f a </tt>	The sum of a collection of actions, generalizing concat
<tt style='background-color:#E8E8E8;'> Data.Foldable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Foldable.html#v:mapM_'>mapM_ </a>  (Foldable t, Monad m) => (a -> m b) -> t a -> m () </tt>	Map each element of a structure to a monadic action, evaluate these actions from left to right, and ignore the results
<tt style='background-color:#E8E8E8;'> Data.Foldable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Foldable.html#v:forM_'>forM_ </a>  (Foldable t, Monad m) => t a -> (a -> m b) -> m () </tt>	forM_ is mapM_ with its arguments flipped
<tt style='background-color:#E8E8E8;'> Data.Foldable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Foldable.html#v:sequence_'>sequence_ </a>  (Foldable t, Monad m) => t (m a) -> m () </tt>	Evaluate each monadic action in the structure from left to right, and ignore the results
<tt style='background-color:#E8E8E8;'> Data.Foldable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Foldable.html#v:msum'>msum </a>  (Foldable t, MonadPlus m) => t (m a) -> m a </tt>	The sum of a collection of actions, generalizing concat
<tt style='background-color:#E8E8E8;'> Data.Foldable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Foldable.html#v:concat'>concat </a>  Foldable t => t [a] -> [a] </tt>	The concatenation of all the elements of a container of lists
<tt style='background-color:#E8E8E8;'> Data.Foldable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Foldable.html#v:concatMap'>concatMap </a>  Foldable t => (a -> [b]) -> t a -> [b] </tt>	Map a function over all the elements of a container and concatenate the resulting lists
<tt style='background-color:#E8E8E8;'> Data.Foldable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Foldable.html#v:and'>and </a>  Foldable t => t Bool -> Bool </tt>	and returns the conjunction of a container of Bools
<tt style='background-color:#E8E8E8;'> Data.Foldable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Foldable.html#v:or'>or </a>  Foldable t => t Bool -> Bool </tt>	or returns the disjunction of a container of Bools
<tt style='background-color:#E8E8E8;'> Data.Foldable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Foldable.html#v:any'>any </a>  Foldable t => (a -> Bool) -> t a -> Bool </tt>	Determines whether any element of the structure satisfies the predicate
<tt style='background-color:#E8E8E8;'> Data.Foldable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Foldable.html#v:all'>all </a>  Foldable t => (a -> Bool) -> t a -> Bool </tt>	Determines whether all elements of the structure satisfy the predicate
<tt style='background-color:#E8E8E8;'> Data.Foldable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Foldable.html#v:maximumBy'>maximumBy </a>  Foldable t => (a -> a -> Ordering) -> t a -> a </tt>	The largest element of a non-empty structure with respect to the given comparison function
<tt style='background-color:#E8E8E8;'> Data.Foldable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Foldable.html#v:minimumBy'>minimumBy </a>  Foldable t => (a -> a -> Ordering) -> t a -> a </tt>	The least element of a non-empty structure with respect to the given comparison function
<tt style='background-color:#E8E8E8;'> Data.Foldable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Foldable.html#v:notElem'>notElem </a>  (Foldable t, Eq a) => a -> t a -> Bool </tt>	notElem is the negation of elem
<tt style='background-color:#E8E8E8;'> Data.Foldable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Foldable.html#v:find'>find </a>  Foldable t => (a -> Bool) -> t a -> Maybe a </tt>	The find function takes a predicate and a structure and returns the leftmost element of the structure matching the predicate, or Nothing if there is no such element
<tt style='background-color:#E8E8E8;'> Text.Read <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Read.html#v:readsPrec'>readsPrec </a>  Read a => Int -> ReadS a </tt>	attempts to parse a value from the front of the string, returning a list of (parsed value, remaining string) pairs
<tt style='background-color:#E8E8E8;'> Text.Read <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Read.html#v:readList'>readList </a>  Read a => ReadS [a] </tt>	The method readList is provided to allow the programmer to give a specialised way of parsing lists of values
<tt style='background-color:#E8E8E8;'> Text.Read <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Read.html#v:readPrec'>readPrec </a>  Read a => ReadPrec a </tt>	Proposed replacement for readsPrec using new-style parsers (GHC only)
<tt style='background-color:#E8E8E8;'> Text.Read <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Read.html#v:readListPrec'>readListPrec </a>  Read a => ReadPrec [a] </tt>	Proposed replacement for readList using new-style parsers (GHC only)
<tt style='background-color:#E8E8E8;'> Text.Read <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Read.html#v:reads'>reads </a>  Read a => ReadS a </tt>	equivalent to readsPrec with a precedence of 0
<tt style='background-color:#E8E8E8;'> Text.Read <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Read.html#v:read'>read </a>  Read a => String -> a </tt>	The read function reads input from a string, which must be completely consumed by the input process
<tt style='background-color:#E8E8E8;'> Text.Read <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Read.html#v:readParen'>readParen </a>  Bool -> ReadS a -> ReadS a </tt>	readParen True p parses what p parses, but surrounded with parentheses
<tt style='background-color:#E8E8E8;'> Text.Read <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Read.html#v:lex'>lex </a>  ReadS String </tt>	The lex function reads a single lexeme from the input, discarding initial white space, and returning the characters that constitute the lexeme
<tt style='background-color:#E8E8E8;'> Text.Read <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Read.html#v:Char'>Char </a>  Char -> Lexeme </tt>	Character literal
<tt style='background-color:#E8E8E8;'> Text.Read <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Read.html#v:String'>String </a>  String -> Lexeme </tt>	String literal, with escapes interpreted
<tt style='background-color:#E8E8E8;'> Text.Read <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Read.html#v:Punc'>Punc </a>  String -> Lexeme </tt>	Punctuation or reserved symbol, e
<tt style='background-color:#E8E8E8;'> Text.Read <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Read.html#v:Ident'>Ident </a>  String -> Lexeme </tt>	Haskell identifier, e
<tt style='background-color:#E8E8E8;'> Text.Read <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Read.html#v:Symbol'>Symbol </a>  String -> Lexeme </tt>	Haskell symbol, e
<tt style='background-color:#E8E8E8;'> Text.Read <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Read.html#v:lexP'>lexP </a>  ReadPrec Lexeme </tt>	Parse a single lexeme
<tt style='background-color:#E8E8E8;'> Text.Read <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Read.html#v:parens'>parens </a>  ReadPrec a -> ReadPrec a </tt>	(parens p) parses "P", "(P0)", "((P0))", etc, where p parses "P" in the current precedence context and parses "P0" in precedence context zero
<tt style='background-color:#E8E8E8;'> Text.Read <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Read.html#v:readListDefault'>readListDefault </a>  Read a => ReadS [a] </tt>	A possible replacement definition for the readList method (GHC only)
<tt style='background-color:#E8E8E8;'> Text.Read <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Read.html#v:readListPrecDefault'>readListPrecDefault </a>  Read a => ReadPrec [a] </tt>	A possible replacement definition for the readListPrec method, defined using readPrec (GHC only)
<tt style='background-color:#E8E8E8;'> Text.Read <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Read.html#v:readEither'>readEither </a>  Read a => String -> Either String a </tt>	Parse a string using the Read instance
<tt style='background-color:#E8E8E8;'> Text.Read <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Read.html#v:readMaybe'>readMaybe </a>  Read a => String -> Maybe a </tt>	Parse a string using the Read instance
<tt style='background-color:#E8E8E8;'> Data.IORef <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-IORef.html#v:newIORef'>newIORef </a>  a -> IO (IORef a) </tt>	Build a new IORef
<tt style='background-color:#E8E8E8;'> Data.IORef <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-IORef.html#v:readIORef'>readIORef </a>  IORef a -> IO a </tt>	Read the value of an IORef
<tt style='background-color:#E8E8E8;'> Data.IORef <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-IORef.html#v:writeIORef'>writeIORef </a>  IORef a -> a -> IO () </tt>	Write a new value into an IORef
<tt style='background-color:#E8E8E8;'> Data.IORef <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-IORef.html#v:modifyIORef'>modifyIORef </a>  IORef a -> (a -> a) -> IO () </tt>	Mutate the contents of an IORef
<tt style='background-color:#E8E8E8;'> Data.IORef <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-IORef.html#v:modifyIORef''>modifyIORef' </a>  IORef a -> (a -> a) -> IO () </tt>	Strict version of modifyIORef
<tt style='background-color:#E8E8E8;'> Data.IORef <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-IORef.html#v:atomicModifyIORef'>atomicModifyIORef </a>  IORef a -> (a -> (a, b)) -> IO b </tt>	Atomically modifies the contents of an IORef
<tt style='background-color:#E8E8E8;'> Data.IORef <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-IORef.html#v:atomicModifyIORef''>atomicModifyIORef' </a>  IORef a -> (a -> (a, b)) -> IO b </tt>	Strict version of atomicModifyIORef
<tt style='background-color:#E8E8E8;'> Data.IORef <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-IORef.html#v:atomicWriteIORef'>atomicWriteIORef </a>  IORef a -> a -> IO () </tt>	Variant of writeIORef with the "barrier to reordering" property that atomicModifyIORef has
<tt style='background-color:#E8E8E8;'> Data.IORef <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-IORef.html#v:mkWeakIORef'>mkWeakIORef </a>  IORef a -> IO () -> IO (Weak (IORef a)) </tt>	Make a Weak pointer to an IORef, using the second argument as a finalizer to run when IORef is garbage-collected
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Unsafe <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Unsafe.html#v:unsafeLocalState'>unsafeLocalState </a>  IO a -> a </tt>	Sometimes an external entity is a pure function, except that it passes arguments and/or results via pointers
<tt style='background-color:#E8E8E8;'> Data.Dynamic <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Dynamic.html#v:toDyn'>toDyn </a>  Typeable a => a -> Dynamic </tt>	Converts an arbitrary value into an object of type Dynamic
<tt style='background-color:#E8E8E8;'> Data.Dynamic <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Dynamic.html#v:fromDyn'>fromDyn </a>  Typeable a => Dynamic -> a -> a </tt>	Converts a Dynamic object back into an ordinary Haskell value of the correct type
<tt style='background-color:#E8E8E8;'> Data.Dynamic <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Dynamic.html#v:fromDynamic'>fromDynamic </a>  Typeable a => Dynamic -> Maybe a </tt>	Converts a Dynamic object back into an ordinary Haskell value of the correct type
<tt style='background-color:#E8E8E8;'> Foreign.Storable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Storable.html#v:sizeOf'>sizeOf </a>  Storable a => a -> Int </tt>	Computes the storage requirements (in bytes) of the argument
<tt style='background-color:#E8E8E8;'> Foreign.Storable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Storable.html#v:alignment'>alignment </a>  Storable a => a -> Int </tt>	Computes the alignment constraint of the argument
<tt style='background-color:#E8E8E8;'> Foreign.Storable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Storable.html#v:peekElemOff'>peekElemOff </a>  Storable a => Ptr a -> Int -> IO a </tt>	Read a value from a memory area regarded as an array of values of the same kind
<tt style='background-color:#E8E8E8;'> Foreign.Storable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Storable.html#v:pokeElemOff'>pokeElemOff </a>  Storable a => Ptr a -> Int -> a -> IO () </tt>	Write a value to a memory area regarded as an array of values of the same kind
<tt style='background-color:#E8E8E8;'> Foreign.Storable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Storable.html#v:peekByteOff'>peekByteOff </a>  Storable a => Ptr b -> Int -> IO a </tt>	Read a value from a memory location given by a base address and offset
<tt style='background-color:#E8E8E8;'> Foreign.Storable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Storable.html#v:pokeByteOff'>pokeByteOff </a>  Storable a => Ptr b -> Int -> a -> IO () </tt>	Write a value to a memory location given by a base address and offset
<tt style='background-color:#E8E8E8;'> Foreign.Storable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Storable.html#v:peek'>peek </a>  Storable a => Ptr a -> IO a </tt>	Read a value from the given memory location
<tt style='background-color:#E8E8E8;'> Foreign.Storable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Storable.html#v:poke'>poke </a>  Storable a => Ptr a -> a -> IO () </tt>	Write the given value to the given memory location
<tt style='background-color:#E8E8E8;'> Foreign.C.Types <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-Types.html#v:CChar'>CChar </a>  Int8 -> CChar </tt>	Haskell type representing the C char type
<tt style='background-color:#E8E8E8;'> Foreign.C.Types <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-Types.html#v:CSChar'>CSChar </a>  Int8 -> CSChar </tt>	Haskell type representing the C signed char type
<tt style='background-color:#E8E8E8;'> Foreign.C.Types <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-Types.html#v:CUChar'>CUChar </a>  Word8 -> CUChar </tt>	Haskell type representing the C unsigned char type
<tt style='background-color:#E8E8E8;'> Foreign.C.Types <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-Types.html#v:CShort'>CShort </a>  Int16 -> CShort </tt>	Haskell type representing the C short type
<tt style='background-color:#E8E8E8;'> Foreign.C.Types <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-Types.html#v:CUShort'>CUShort </a>  Word16 -> CUShort </tt>	Haskell type representing the C unsigned short type
<tt style='background-color:#E8E8E8;'> Foreign.C.Types <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-Types.html#v:CInt'>CInt </a>  Int32 -> CInt </tt>	Haskell type representing the C int type
<tt style='background-color:#E8E8E8;'> Foreign.C.Types <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-Types.html#v:CUInt'>CUInt </a>  Word32 -> CUInt </tt>	Haskell type representing the C unsigned int type
<tt style='background-color:#E8E8E8;'> Foreign.C.Types <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-Types.html#v:CLong'>CLong </a>  Int64 -> CLong </tt>	Haskell type representing the C long type
<tt style='background-color:#E8E8E8;'> Foreign.C.Types <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-Types.html#v:CULong'>CULong </a>  Word64 -> CULong </tt>	Haskell type representing the C unsigned long type
<tt style='background-color:#E8E8E8;'> Foreign.C.Types <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-Types.html#v:CPtrdiff'>CPtrdiff </a>  Int64 -> CPtrdiff </tt>	Haskell type representing the C ptrdiff_t type
<tt style='background-color:#E8E8E8;'> Foreign.C.Types <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-Types.html#v:CSize'>CSize </a>  Word64 -> CSize </tt>	Haskell type representing the C size_t type
<tt style='background-color:#E8E8E8;'> Foreign.C.Types <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-Types.html#v:CWchar'>CWchar </a>  Int32 -> CWchar </tt>	Haskell type representing the C wchar_t type
<tt style='background-color:#E8E8E8;'> Foreign.C.Types <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-Types.html#v:CSigAtomic'>CSigAtomic </a>  Int32 -> CSigAtomic </tt>	Haskell type representing the C sig_atomic_t type
<tt style='background-color:#E8E8E8;'> Foreign.C.Types <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-Types.html#v:CLLong'>CLLong </a>  Int64 -> CLLong </tt>	Haskell type representing the C long long type
<tt style='background-color:#E8E8E8;'> Foreign.C.Types <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-Types.html#v:CULLong'>CULLong </a>  Word64 -> CULLong </tt>	Haskell type representing the C unsigned long long type
<tt style='background-color:#E8E8E8;'> Foreign.C.Types <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-Types.html#v:CClock'>CClock </a>  Int64 -> CClock </tt>	Haskell type representing the C clock_t type
<tt style='background-color:#E8E8E8;'> Foreign.C.Types <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-Types.html#v:CTime'>CTime </a>  Int64 -> CTime </tt>	Haskell type representing the C time_t type
<tt style='background-color:#E8E8E8;'> Foreign.C.Types <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-Types.html#v:CUSeconds'>CUSeconds </a>  Word32 -> CUSeconds </tt>	Haskell type representing the C useconds_t type
<tt style='background-color:#E8E8E8;'> Foreign.C.Types <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-Types.html#v:CSUSeconds'>CSUSeconds </a>  Int64 -> CSUSeconds </tt>	Haskell type representing the C suseconds_t type
<tt style='background-color:#E8E8E8;'> Foreign.C.Types <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-Types.html#v:CFloat'>CFloat </a>  Float -> CFloat </tt>	Haskell type representing the C float type
<tt style='background-color:#E8E8E8;'> Foreign.C.Types <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-Types.html#v:CDouble'>CDouble </a>  Double -> CDouble </tt>	Haskell type representing the C double type
<tt style='background-color:#E8E8E8;'> Foreign.Concurrent <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Concurrent.html#v:newForeignPtr'>newForeignPtr </a>  Ptr a -> IO () -> IO (ForeignPtr a) </tt>	Turns a plain memory reference into a foreign object by associating a finalizer - given by the monadic operation - with the reference
<tt style='background-color:#E8E8E8;'> Foreign.Concurrent <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Concurrent.html#v:addForeignPtrFinalizer'>addForeignPtrFinalizer </a>  ForeignPtr a -> IO () -> IO () </tt>	This function adds a finalizer to the given ForeignPtr
<tt style='background-color:#E8E8E8;'> Foreign.Ptr <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Ptr.html#v:nullPtr'>nullPtr </a>  Ptr a </tt>	The constant nullPtr contains a distinguished value of Ptr that is not associated with a valid memory location
<tt style='background-color:#E8E8E8;'> Foreign.Ptr <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Ptr.html#v:castPtr'>castPtr </a>  Ptr a -> Ptr b </tt>	The castPtr function casts a pointer from one type to another
<tt style='background-color:#E8E8E8;'> Foreign.Ptr <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Ptr.html#v:plusPtr'>plusPtr </a>  Ptr a -> Int -> Ptr b </tt>	Advances the given address by the given offset in bytes
<tt style='background-color:#E8E8E8;'> Foreign.Ptr <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Ptr.html#v:alignPtr'>alignPtr </a>  Ptr a -> Int -> Ptr a </tt>	Given an arbitrary address and an alignment constraint, alignPtr yields the next higher address that fulfills the alignment constraint
<tt style='background-color:#E8E8E8;'> Foreign.Ptr <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Ptr.html#v:minusPtr'>minusPtr </a>  Ptr a -> Ptr b -> Int </tt>	Computes the offset required to get from the second to the first argument
<tt style='background-color:#E8E8E8;'> Foreign.Ptr <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Ptr.html#v:nullFunPtr'>nullFunPtr </a>  FunPtr a </tt>	The constant nullFunPtr contains a distinguished value of FunPtr that is not associated with a valid memory location
<tt style='background-color:#E8E8E8;'> Foreign.Ptr <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Ptr.html#v:castFunPtr'>castFunPtr </a>  FunPtr a -> FunPtr b </tt>	Casts a FunPtr to a FunPtr of a different type
<tt style='background-color:#E8E8E8;'> Foreign.Ptr <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Ptr.html#v:castFunPtrToPtr'>castFunPtrToPtr </a>  FunPtr a -> Ptr b </tt>	Casts a FunPtr to a Ptr
<tt style='background-color:#E8E8E8;'> Foreign.Ptr <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Ptr.html#v:castPtrToFunPtr'>castPtrToFunPtr </a>  Ptr a -> FunPtr b </tt>	Casts a Ptr to a FunPtr
<tt style='background-color:#E8E8E8;'> Foreign.Ptr <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Ptr.html#v:freeHaskellFunPtr'>freeHaskellFunPtr </a>  FunPtr a -> IO () </tt>	Release the storage associated with the given FunPtr, which must have been obtained from a wrapper stub
<tt style='background-color:#E8E8E8;'> Foreign.Ptr <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Ptr.html#v:ptrToIntPtr'>ptrToIntPtr </a>  Ptr a -> IntPtr </tt>	casts a Ptr to an IntPtr
<tt style='background-color:#E8E8E8;'> Foreign.Ptr <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Ptr.html#v:intPtrToPtr'>intPtrToPtr </a>  IntPtr -> Ptr a </tt>	casts an IntPtr to a Ptr
<tt style='background-color:#E8E8E8;'> Foreign.Ptr <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Ptr.html#v:ptrToWordPtr'>ptrToWordPtr </a>  Ptr a -> WordPtr </tt>	casts a Ptr to a WordPtr
<tt style='background-color:#E8E8E8;'> Foreign.Ptr <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Ptr.html#v:wordPtrToPtr'>wordPtrToPtr </a>  WordPtr -> Ptr a </tt>	casts a WordPtr to a Ptr
<tt style='background-color:#E8E8E8;'> Foreign.ForeignPtr <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-ForeignPtr.html#v:newForeignPtr'>newForeignPtr </a>  FinalizerPtr a -> Ptr a -> IO (ForeignPtr a) </tt>	Turns a plain memory reference into a foreign pointer, and associates a finalizer with the reference
<tt style='background-color:#E8E8E8;'> Foreign.ForeignPtr <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-ForeignPtr.html#v:newForeignPtr_'>newForeignPtr_ </a>  Ptr a -> IO (ForeignPtr a) </tt>	Turns a plain memory reference into a foreign pointer that may be associated with finalizers by using addForeignPtrFinalizer
<tt style='background-color:#E8E8E8;'> Foreign.ForeignPtr <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-ForeignPtr.html#v:addForeignPtrFinalizer'>addForeignPtrFinalizer </a>  FinalizerPtr a -> ForeignPtr a -> IO () </tt>	This function adds a finalizer to the given foreign object
<tt style='background-color:#E8E8E8;'> Foreign.ForeignPtr <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-ForeignPtr.html#v:newForeignPtrEnv'>newForeignPtrEnv </a>  FinalizerEnvPtr env a -> Ptr env -> Ptr a -> IO (ForeignPtr a) </tt>	This variant of newForeignPtr adds a finalizer that expects an environment in addition to the finalized pointer
<tt style='background-color:#E8E8E8;'> Foreign.ForeignPtr <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-ForeignPtr.html#v:addForeignPtrFinalizerEnv'>addForeignPtrFinalizerEnv </a>  FinalizerEnvPtr env a -> Ptr env -> ForeignPtr a -> IO () </tt>	Like addForeignPtrFinalizerEnv but allows the finalizer to be passed an additional environment parameter to be passed to the finalizer
<tt style='background-color:#E8E8E8;'> Foreign.ForeignPtr <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-ForeignPtr.html#v:withForeignPtr'>withForeignPtr </a>  ForeignPtr a -> (Ptr a -> IO b) -> IO b </tt>	This is a way to look at the pointer living inside a foreign object
<tt style='background-color:#E8E8E8;'> Foreign.ForeignPtr <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-ForeignPtr.html#v:finalizeForeignPtr'>finalizeForeignPtr </a>  ForeignPtr a -> IO () </tt>	Causes the finalizers associated with a foreign pointer to be run immediately
<tt style='background-color:#E8E8E8;'> Foreign.ForeignPtr <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-ForeignPtr.html#v:touchForeignPtr'>touchForeignPtr </a>  ForeignPtr a -> IO () </tt>	This function ensures that the foreign object in question is alive at the given place in the sequence of IO actions
<tt style='background-color:#E8E8E8;'> Foreign.ForeignPtr <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-ForeignPtr.html#v:castForeignPtr'>castForeignPtr </a>  ForeignPtr a -> ForeignPtr b </tt>	This function casts a ForeignPtr parameterised by one type into another type
<tt style='background-color:#E8E8E8;'> Foreign.ForeignPtr <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-ForeignPtr.html#v:mallocForeignPtr'>mallocForeignPtr </a>  Storable a => IO (ForeignPtr a) </tt>	Allocate some memory and return a ForeignPtr to it
<tt style='background-color:#E8E8E8;'> Foreign.ForeignPtr <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-ForeignPtr.html#v:mallocForeignPtrBytes'>mallocForeignPtrBytes </a>  Int -> IO (ForeignPtr a) </tt>	This function is similar to mallocForeignPtr, except that the size of the memory required is given explicitly as a number of bytes
<tt style='background-color:#E8E8E8;'> Foreign.ForeignPtr <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-ForeignPtr.html#v:mallocForeignPtrArray'>mallocForeignPtrArray </a>  Storable a => Int -> IO (ForeignPtr a) </tt>	This function is similar to mallocArray, but yields a memory area that has a finalizer attached that releases the memory area
<tt style='background-color:#E8E8E8;'> Foreign.ForeignPtr <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-ForeignPtr.html#v:mallocForeignPtrArray0'>mallocForeignPtrArray0 </a>  Storable a => Int -> IO (ForeignPtr a) </tt>	This function is similar to mallocArray0, but yields a memory area that has a finalizer attached that releases the memory area
<tt style='background-color:#E8E8E8;'> Foreign.ForeignPtr.Safe <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-ForeignPtr-Safe.html#v:newForeignPtr'>newForeignPtr </a>  FinalizerPtr a -> Ptr a -> IO (ForeignPtr a) </tt>	Turns a plain memory reference into a foreign pointer, and associates a finalizer with the reference
<tt style='background-color:#E8E8E8;'> Foreign.ForeignPtr.Safe <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-ForeignPtr-Safe.html#v:newForeignPtr_'>newForeignPtr_ </a>  Ptr a -> IO (ForeignPtr a) </tt>	Turns a plain memory reference into a foreign pointer that may be associated with finalizers by using addForeignPtrFinalizer
<tt style='background-color:#E8E8E8;'> Foreign.ForeignPtr.Safe <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-ForeignPtr-Safe.html#v:addForeignPtrFinalizer'>addForeignPtrFinalizer </a>  FinalizerPtr a -> ForeignPtr a -> IO () </tt>	This function adds a finalizer to the given foreign object
<tt style='background-color:#E8E8E8;'> Foreign.ForeignPtr.Safe <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-ForeignPtr-Safe.html#v:newForeignPtrEnv'>newForeignPtrEnv </a>  FinalizerEnvPtr env a -> Ptr env -> Ptr a -> IO (ForeignPtr a) </tt>	This variant of newForeignPtr adds a finalizer that expects an environment in addition to the finalized pointer
<tt style='background-color:#E8E8E8;'> Foreign.ForeignPtr.Safe <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-ForeignPtr-Safe.html#v:addForeignPtrFinalizerEnv'>addForeignPtrFinalizerEnv </a>  FinalizerEnvPtr env a -> Ptr env -> ForeignPtr a -> IO () </tt>	Like addForeignPtrFinalizerEnv but allows the finalizer to be passed an additional environment parameter to be passed to the finalizer
<tt style='background-color:#E8E8E8;'> Foreign.ForeignPtr.Safe <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-ForeignPtr-Safe.html#v:withForeignPtr'>withForeignPtr </a>  ForeignPtr a -> (Ptr a -> IO b) -> IO b </tt>	This is a way to look at the pointer living inside a foreign object
<tt style='background-color:#E8E8E8;'> Foreign.ForeignPtr.Safe <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-ForeignPtr-Safe.html#v:finalizeForeignPtr'>finalizeForeignPtr </a>  ForeignPtr a -> IO () </tt>	Causes the finalizers associated with a foreign pointer to be run immediately
<tt style='background-color:#E8E8E8;'> Foreign.ForeignPtr.Safe <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-ForeignPtr-Safe.html#v:touchForeignPtr'>touchForeignPtr </a>  ForeignPtr a -> IO () </tt>	This function ensures that the foreign object in question is alive at the given place in the sequence of IO actions
<tt style='background-color:#E8E8E8;'> Foreign.ForeignPtr.Safe <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-ForeignPtr-Safe.html#v:castForeignPtr'>castForeignPtr </a>  ForeignPtr a -> ForeignPtr b </tt>	This function casts a ForeignPtr parameterised by one type into another type
<tt style='background-color:#E8E8E8;'> Foreign.ForeignPtr.Safe <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-ForeignPtr-Safe.html#v:mallocForeignPtr'>mallocForeignPtr </a>  Storable a => IO (ForeignPtr a) </tt>	Allocate some memory and return a ForeignPtr to it
<tt style='background-color:#E8E8E8;'> Foreign.ForeignPtr.Safe <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-ForeignPtr-Safe.html#v:mallocForeignPtrBytes'>mallocForeignPtrBytes </a>  Int -> IO (ForeignPtr a) </tt>	This function is similar to mallocForeignPtr, except that the size of the memory required is given explicitly as a number of bytes
<tt style='background-color:#E8E8E8;'> Foreign.ForeignPtr.Safe <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-ForeignPtr-Safe.html#v:mallocForeignPtrArray'>mallocForeignPtrArray </a>  Storable a => Int -> IO (ForeignPtr a) </tt>	This function is similar to mallocArray, but yields a memory area that has a finalizer attached that releases the memory area
<tt style='background-color:#E8E8E8;'> Foreign.ForeignPtr.Safe <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-ForeignPtr-Safe.html#v:mallocForeignPtrArray0'>mallocForeignPtrArray0 </a>  Storable a => Int -> IO (ForeignPtr a) </tt>	This function is similar to mallocArray0, but yields a memory area that has a finalizer attached that releases the memory area
<tt style='background-color:#E8E8E8;'> Foreign.ForeignPtr.Unsafe <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-ForeignPtr-Unsafe.html#v:unsafeForeignPtrToPtr'>unsafeForeignPtrToPtr </a>  ForeignPtr a -> Ptr a </tt>	This function extracts the pointer component of a foreign pointer
<tt style='background-color:#E8E8E8;'> GHC.IO.Buffer <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Buffer.html#v:Buffer'>Buffer </a>  !(RawBuffer e) -> BufferState -> !Int -> !Int -> !Int -> Buffer e </tt>	A mutable array of bytes that can be passed to foreign functions
<tt style='background-color:#E8E8E8;'> GHC.IO.Buffer <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Buffer.html#v:slideContents'>slideContents </a>  Buffer Word8 -> IO (Buffer Word8) </tt>	slides the contents of the buffer to the beginning
<tt style='background-color:#E8E8E8;'> GHC.IO.Encoding.Types <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Encoding-Types.html#v:BufferCodec'>BufferCodec </a>  CodeBuffer from to -> (Buffer from -> Buffer to -> IO (Buffer from, Buffer to)) -> IO () -> IO state -> (state -> IO ()) -> BufferCodec from to state </tt>	Types for text encoding/decoding
<tt style='background-color:#E8E8E8;'> GHC.IO.Encoding.Types <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Encoding-Types.html#v:[encode]'>[encode] </a>  BufferCodec from to state -> CodeBuffer from to </tt>	The encode function translates elements of the buffer from to the buffer to
<tt style='background-color:#E8E8E8;'> GHC.IO.Encoding.Types <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Encoding-Types.html#v:[recover]'>[recover] </a>  BufferCodec from to state -> Buffer from -> Buffer to -> IO (Buffer from, Buffer to) </tt>	The recover function is used to continue decoding in the presence of invalid or unrepresentable sequences
<tt style='background-color:#E8E8E8;'> GHC.IO.Encoding.Types <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Encoding-Types.html#v:[close]'>[close] </a>  BufferCodec from to state -> IO () </tt>	Resources associated with the encoding may now be released
<tt style='background-color:#E8E8E8;'> GHC.IO.Encoding.Types <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Encoding-Types.html#v:[getState]'>[getState] </a>  BufferCodec from to state -> IO state </tt>	Return the current state of the codec
<tt style='background-color:#E8E8E8;'> GHC.IO.Encoding.Types <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Encoding-Types.html#v:TextEncoding'>TextEncoding </a>  String -> IO (TextDecoder dstate) -> IO (TextEncoder estate) -> TextEncoding </tt>	A TextEncoding is a specification of a conversion scheme between sequences of bytes and sequences of Unicode characters
<tt style='background-color:#E8E8E8;'> GHC.IO.Encoding.Types <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Encoding-Types.html#v:[textEncodingName]'>[textEncodingName] </a>  TextEncoding -> String </tt>	a string that can be passed to mkTextEncoding to create an equivalent TextEncoding
<tt style='background-color:#E8E8E8;'> GHC.IO.Encoding.Types <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Encoding-Types.html#v:[mkTextDecoder]'>[mkTextDecoder] </a>  TextEncoding -> IO (TextDecoder dstate) </tt>	Creates a means of decoding bytes into characters: the result must not be shared between several byte sequences or simultaneously across threads
<tt style='background-color:#E8E8E8;'> GHC.IO.Encoding.Types <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Encoding-Types.html#v:[mkTextEncoder]'>[mkTextEncoder] </a>  TextEncoding -> IO (TextEncoder estate) </tt>	Creates a means of encode characters into bytes: the result must not be shared between several character sequences or simultaneously across threads
<tt style='background-color:#E8E8E8;'> GHC.IO.Encoding.Types <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Encoding-Types.html#v:InputUnderflow'>InputUnderflow </a>  CodingProgress </tt>	Stopped because the input contains insufficient available elements, or all of the input sequence has been sucessfully translated
<tt style='background-color:#E8E8E8;'> GHC.IO.Encoding.Types <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Encoding-Types.html#v:OutputUnderflow'>OutputUnderflow </a>  CodingProgress </tt>	Stopped because the output contains insufficient free elements
<tt style='background-color:#E8E8E8;'> GHC.IO.Encoding.Types <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Encoding-Types.html#v:InvalidSequence'>InvalidSequence </a>  CodingProgress </tt>	Stopped because there are sufficient free elements in the output to output at least one encoded ASCII character, but the input contains an invalid or unrepresentable sequence
<tt style='background-color:#E8E8E8;'> GHC.IO.Device <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Device.html#v:read'>read </a>  RawIO a => a -> Ptr Word8 -> Int -> IO Int </tt>	Read up to the specified number of bytes, returning the number of bytes actually read
<tt style='background-color:#E8E8E8;'> GHC.IO.Device <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Device.html#v:readNonBlocking'>readNonBlocking </a>  RawIO a => a -> Ptr Word8 -> Int -> IO (Maybe Int) </tt>	Read up to the specified number of bytes, returning the number of bytes actually read, or Nothing if the end of the stream has been reached
<tt style='background-color:#E8E8E8;'> GHC.IO.Device <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Device.html#v:write'>write </a>  RawIO a => a -> Ptr Word8 -> Int -> IO () </tt>	Write the specified number of bytes
<tt style='background-color:#E8E8E8;'> GHC.IO.Device <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Device.html#v:writeNonBlocking'>writeNonBlocking </a>  RawIO a => a -> Ptr Word8 -> Int -> IO Int </tt>	Write up to the specified number of bytes without blocking
<tt style='background-color:#E8E8E8;'> GHC.IO.Device <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Device.html#v:ready'>ready </a>  IODevice a => a -> Bool -> Int -> IO Bool </tt>	ready dev write msecs returns True if the device has data to read (if write is False) or space to write new data (if write is True)
<tt style='background-color:#E8E8E8;'> GHC.IO.Device <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Device.html#v:close'>close </a>  IODevice a => a -> IO () </tt>	closes the device
<tt style='background-color:#E8E8E8;'> GHC.IO.Device <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Device.html#v:isTerminal'>isTerminal </a>  IODevice a => a -> IO Bool </tt>	returns True if the device is a terminal or console
<tt style='background-color:#E8E8E8;'> GHC.IO.Device <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Device.html#v:isSeekable'>isSeekable </a>  IODevice a => a -> IO Bool </tt>	returns True if the device supports seek operations
<tt style='background-color:#E8E8E8;'> GHC.IO.Device <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Device.html#v:seek'>seek </a>  IODevice a => a -> SeekMode -> Integer -> IO () </tt>	seek to the specified position in the data
<tt style='background-color:#E8E8E8;'> GHC.IO.Device <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Device.html#v:tell'>tell </a>  IODevice a => a -> IO Integer </tt>	return the current position in the data
<tt style='background-color:#E8E8E8;'> GHC.IO.Device <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Device.html#v:getSize'>getSize </a>  IODevice a => a -> IO Integer </tt>	return the size of the data
<tt style='background-color:#E8E8E8;'> GHC.IO.Device <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Device.html#v:setSize'>setSize </a>  IODevice a => a -> Integer -> IO () </tt>	change the size of the data
<tt style='background-color:#E8E8E8;'> GHC.IO.Device <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Device.html#v:setEcho'>setEcho </a>  IODevice a => a -> Bool -> IO () </tt>	for terminal devices, changes whether characters are echoed on the device
<tt style='background-color:#E8E8E8;'> GHC.IO.Device <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Device.html#v:getEcho'>getEcho </a>  IODevice a => a -> IO Bool </tt>	returns the current echoing status
<tt style='background-color:#E8E8E8;'> GHC.IO.Device <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Device.html#v:setRaw'>setRaw </a>  IODevice a => a -> Bool -> IO () </tt>	some devices (eg terminals) support a "raw" mode where characters entered are immediately made available to the program
<tt style='background-color:#E8E8E8;'> GHC.IO.Device <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Device.html#v:devType'>devType </a>  IODevice a => a -> IO IODeviceType </tt>	returns the IODeviceType corresponding to this device
<tt style='background-color:#E8E8E8;'> GHC.IO.Device <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Device.html#v:dup'>dup </a>  IODevice a => a -> IO a </tt>	duplicates the device, if possible
<tt style='background-color:#E8E8E8;'> GHC.IO.Device <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Device.html#v:dup2'>dup2 </a>  IODevice a => a -> a -> IO a </tt>	dup2 source target replaces the target device with the source device
<tt style='background-color:#E8E8E8;'> GHC.IO.Device <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Device.html#v:Directory'>Directory </a>  IODeviceType </tt>	The standard libraries do not have direct support for this device type, but a user implementation is expected to provide a list of file names in the directory, in any order, separated by '\0' characters, excluding the "
<tt style='background-color:#E8E8E8;'> GHC.IO.Device <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Device.html#v:Stream'>Stream </a>  IODeviceType </tt>	A duplex communications channel (results in creation of a duplex Handle)
<tt style='background-color:#E8E8E8;'> GHC.IO.Device <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Device.html#v:RegularFile'>RegularFile </a>  IODeviceType </tt>	A file that may be read or written, and also may be seekable
<tt style='background-color:#E8E8E8;'> GHC.IO.Device <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Device.html#v:RawDevice'>RawDevice </a>  IODeviceType </tt>	A "raw" (disk) device which supports block binary read and write operations and may be seekable only to positions of certain granularity (block- aligned)
<tt style='background-color:#E8E8E8;'> GHC.IO.Device <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Device.html#v:AbsoluteSeek'>AbsoluteSeek </a>  SeekMode </tt>	the position of hdl is set to i
<tt style='background-color:#E8E8E8;'> GHC.IO.Device <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Device.html#v:RelativeSeek'>RelativeSeek </a>  SeekMode </tt>	the position of hdl is set to offset i from the current position
<tt style='background-color:#E8E8E8;'> GHC.IO.Device <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Device.html#v:SeekFromEnd'>SeekFromEnd </a>  SeekMode </tt>	the position of hdl is set to offset i from the end of the file
<tt style='background-color:#E8E8E8;'> GHC.IO.BufferedIO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-BufferedIO.html#v:newBuffer'>newBuffer </a>  BufferedIO dev => dev -> BufferState -> IO (Buffer Word8) </tt>	allocate a new buffer
<tt style='background-color:#E8E8E8;'> GHC.IO.BufferedIO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-BufferedIO.html#v:fillReadBuffer'>fillReadBuffer </a>  BufferedIO dev => dev -> Buffer Word8 -> IO (Int, Buffer Word8) </tt>	reads bytes into the buffer, blocking if there are no bytes available
<tt style='background-color:#E8E8E8;'> GHC.IO.BufferedIO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-BufferedIO.html#v:fillReadBuffer0'>fillReadBuffer0 </a>  BufferedIO dev => dev -> Buffer Word8 -> IO (Maybe Int, Buffer Word8) </tt>	reads bytes into the buffer without blocking
<tt style='background-color:#E8E8E8;'> GHC.IO.BufferedIO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-BufferedIO.html#v:emptyWriteBuffer'>emptyWriteBuffer </a>  BufferedIO dev => dev -> Buffer Word8 -> IO (Buffer Word8) </tt>	Prepares an empty write buffer
<tt style='background-color:#E8E8E8;'> GHC.IO.BufferedIO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-BufferedIO.html#v:flushWriteBuffer'>flushWriteBuffer </a>  BufferedIO dev => dev -> Buffer Word8 -> IO (Buffer Word8) </tt>	Flush all the data from the supplied write buffer out to the device
<tt style='background-color:#E8E8E8;'> GHC.IO.BufferedIO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-BufferedIO.html#v:flushWriteBuffer0'>flushWriteBuffer0 </a>  BufferedIO dev => dev -> Buffer Word8 -> IO (Int, Buffer Word8) </tt>	Flush data from the supplied write buffer out to the device without blocking
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Alloc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Alloc.html#v:alloca'>alloca </a>  Storable a => (Ptr a -> IO b) -> IO b </tt>	alloca f executes the computation f, passing as argument a pointer to a temporarily allocated block of memory sufficient to hold values of type a
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Alloc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Alloc.html#v:allocaBytes'>allocaBytes </a>  Int -> (Ptr a -> IO b) -> IO b </tt>	allocaBytes n f executes the computation f, passing as argument a pointer to a temporarily allocated block of memory of n bytes
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Alloc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Alloc.html#v:malloc'>malloc </a>  Storable a => IO (Ptr a) </tt>	Allocate a block of memory that is sufficient to hold values of type a
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Alloc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Alloc.html#v:mallocBytes'>mallocBytes </a>  Int -> IO (Ptr a) </tt>	Allocate a block of memory of the given number of bytes
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Alloc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Alloc.html#v:calloc'>calloc </a>  Storable a => IO (Ptr a) </tt>	Like malloc but memory is filled with bytes of value zero
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Alloc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Alloc.html#v:callocBytes'>callocBytes </a>  Int -> IO (Ptr a) </tt>	Llike mallocBytes but memory is filled with bytes of value zero
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Alloc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Alloc.html#v:realloc'>realloc </a>  Storable b => Ptr a -> IO (Ptr b) </tt>	Resize a memory area that was allocated with malloc or mallocBytes to the size needed to store values of type b
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Alloc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Alloc.html#v:reallocBytes'>reallocBytes </a>  Ptr a -> Int -> IO (Ptr a) </tt>	Resize a memory area that was allocated with malloc or mallocBytes to the given size
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Alloc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Alloc.html#v:free'>free </a>  Ptr a -> IO () </tt>	Free a block of memory that was allocated with malloc, mallocBytes, realloc, reallocBytes, new or any of the newX functions in Foreign
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Alloc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Alloc.html#v:finalizerFree'>finalizerFree </a>  FinalizerPtr a </tt>	A pointer to a foreign function equivalent to free, which may be used as a finalizer (cf ForeignPtr) for storage allocated with malloc, mallocBytes, realloc or reallocBytes
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Utils <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Utils.html#v:with'>with </a>  Storable a => a -> (Ptr a -> IO b) -> IO b </tt>	with val f executes the computation f, passing as argument a pointer to a temporarily allocated block of memory into which val has been marshalled (the combination of alloca and poke)
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Utils <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Utils.html#v:new'>new </a>  Storable a => a -> IO (Ptr a) </tt>	Allocate a block of memory and marshal a value into it (the combination of malloc and poke)
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Utils <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Utils.html#v:fromBool'>fromBool </a>  Num a => Bool -> a </tt>	Convert a Haskell Bool to its numeric representation
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Utils <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Utils.html#v:toBool'>toBool </a>  (Eq a, Num a) => a -> Bool </tt>	Convert a Boolean in numeric representation to a Haskell value
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Utils <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Utils.html#v:maybePeek'>maybePeek </a>  (Ptr a -> IO b) -> Ptr a -> IO (Maybe b) </tt>	Convert a peek combinator into a one returning Nothing if applied to a nullPtr
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Utils <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Utils.html#v:withMany'>withMany </a>  (a -> (b -> res) -> res) -> [a] -> ([b] -> res) -> res </tt>	Replicates a withXXX combinator over a list of objects, yielding a list of marshalled objects
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Utils <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Utils.html#v:copyBytes'>copyBytes </a>  Ptr a -> Ptr a -> Int -> IO () </tt>	Copies the given number of bytes from the second area (source) into the first (destination); the copied areas may not overlap
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Utils <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Utils.html#v:moveBytes'>moveBytes </a>  Ptr a -> Ptr a -> Int -> IO () </tt>	Copies the given number of bytes from the second area (source) into the first (destination); the copied areas may overlap
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Utils <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Utils.html#v:fillBytes'>fillBytes </a>  Ptr a -> Word8 -> Int -> IO () </tt>	Fill a given number of bytes in memory area with a byte value
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Array <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Array.html#v:mallocArray'>mallocArray </a>  Storable a => Int -> IO (Ptr a) </tt>	Allocate storage for the given number of elements of a storable type (like malloc, but for multiple elements)
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Array <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Array.html#v:mallocArray0'>mallocArray0 </a>  Storable a => Int -> IO (Ptr a) </tt>	Like mallocArray, but add an extra position to hold a special termination element
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Array <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Array.html#v:allocaArray'>allocaArray </a>  Storable a => Int -> (Ptr a -> IO b) -> IO b </tt>	Temporarily allocate space for the given number of elements (like alloca, but for multiple elements)
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Array <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Array.html#v:allocaArray0'>allocaArray0 </a>  Storable a => Int -> (Ptr a -> IO b) -> IO b </tt>	Like allocaArray, but add an extra position to hold a special termination element
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Array <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Array.html#v:reallocArray'>reallocArray </a>  Storable a => Ptr a -> Int -> IO (Ptr a) </tt>	Adjust the size of an array
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Array <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Array.html#v:reallocArray0'>reallocArray0 </a>  Storable a => Ptr a -> Int -> IO (Ptr a) </tt>	Adjust the size of an array including an extra position for the end marker
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Array <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Array.html#v:callocArray'>callocArray </a>  Storable a => Int -> IO (Ptr a) </tt>	Like mallocArray, but allocated memory is filled with bytes of value zero
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Array <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Array.html#v:callocArray0'>callocArray0 </a>  Storable a => Int -> IO (Ptr a) </tt>	Like callocArray0, but allocated memory is filled with bytes of value zero
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Array <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Array.html#v:peekArray'>peekArray </a>  Storable a => Int -> Ptr a -> IO [a] </tt>	Convert an array of given length into a Haskell list
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Array <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Array.html#v:peekArray0'>peekArray0 </a>  (Storable a, Eq a) => a -> Ptr a -> IO [a] </tt>	Convert an array terminated by the given end marker into a Haskell list
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Array <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Array.html#v:pokeArray'>pokeArray </a>  Storable a => Ptr a -> [a] -> IO () </tt>	Write the list elements consecutive into memory
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Array <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Array.html#v:pokeArray0'>pokeArray0 </a>  Storable a => a -> Ptr a -> [a] -> IO () </tt>	Write the list elements consecutive into memory and terminate them with the given marker element
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Array <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Array.html#v:newArray'>newArray </a>  Storable a => [a] -> IO (Ptr a) </tt>	Write a list of storable elements into a newly allocated, consecutive sequence of storable values (like new, but for multiple elements)
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Array <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Array.html#v:newArray0'>newArray0 </a>  Storable a => a -> [a] -> IO (Ptr a) </tt>	Write a list of storable elements into a newly allocated, consecutive sequence of storable values, where the end is fixed by the given end marker
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Array <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Array.html#v:withArray'>withArray </a>  Storable a => [a] -> (Ptr a -> IO b) -> IO b </tt>	Temporarily store a list of storable values in memory (like with, but for multiple elements)
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Array <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Array.html#v:withArray0'>withArray0 </a>  Storable a => a -> [a] -> (Ptr a -> IO b) -> IO b </tt>	Like withArray, but a terminator indicates where the array ends
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Array <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Array.html#v:withArrayLen'>withArrayLen </a>  Storable a => [a] -> (Int -> Ptr a -> IO b) -> IO b </tt>	Like withArray, but the action gets the number of values as an additional parameter
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Array <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Array.html#v:withArrayLen0'>withArrayLen0 </a>  Storable a => a -> [a] -> (Int -> Ptr a -> IO b) -> IO b </tt>	Like withArrayLen, but a terminator indicates where the array ends
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Array <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Array.html#v:copyArray'>copyArray </a>  Storable a => Ptr a -> Ptr a -> Int -> IO () </tt>	Copy the given number of elements from the second array (source) into the first array (destination); the copied areas may not overlap
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Array <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Array.html#v:moveArray'>moveArray </a>  Storable a => Ptr a -> Ptr a -> Int -> IO () </tt>	Copy the given number of elements from the second array (source) into the first array (destination); the copied areas may overlap
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Array <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Array.html#v:lengthArray0'>lengthArray0 </a>  (Storable a, Eq a) => a -> Ptr a -> IO Int </tt>	Return the number of elements in an array, excluding the terminator
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Array <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Array.html#v:advancePtr'>advancePtr </a>  Storable a => Ptr a -> Int -> Ptr a </tt>	Advance a pointer into an array by the given number of elements
<tt style='background-color:#E8E8E8;'> GHC.Foreign <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Foreign.html#v:peekCString'>peekCString </a>  TextEncoding -> CString -> IO String </tt>	Marshal a NUL terminated C string into a Haskell string
<tt style='background-color:#E8E8E8;'> GHC.Foreign <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Foreign.html#v:peekCStringLen'>peekCStringLen </a>  TextEncoding -> CStringLen -> IO String </tt>	Marshal a C string with explicit length into a Haskell string
<tt style='background-color:#E8E8E8;'> GHC.Foreign <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Foreign.html#v:newCString'>newCString </a>  TextEncoding -> String -> IO CString </tt>	Marshal a Haskell string into a NUL terminated C string
<tt style='background-color:#E8E8E8;'> GHC.Foreign <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Foreign.html#v:newCStringLen'>newCStringLen </a>  TextEncoding -> String -> IO CStringLen </tt>	Marshal a Haskell string into a C string (ie, character array) with explicit length information
<tt style='background-color:#E8E8E8;'> GHC.Foreign <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Foreign.html#v:withCString'>withCString </a>  TextEncoding -> String -> (CString -> IO a) -> IO a </tt>	Marshal a Haskell string into a NUL terminated C string using temporary storage
<tt style='background-color:#E8E8E8;'> GHC.Foreign <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Foreign.html#v:withCStringLen'>withCStringLen </a>  TextEncoding -> String -> (CStringLen -> IO a) -> IO a </tt>	Marshal a Haskell string into a C string (ie, character array) in temporary storage, with explicit length information
<tt style='background-color:#E8E8E8;'> GHC.Foreign <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Foreign.html#v:charIsRepresentable'>charIsRepresentable </a>  TextEncoding -> Char -> IO Bool </tt>	Determines whether a character can be accurately encoded in a CString
<tt style='background-color:#E8E8E8;'> Foreign.C.String <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-String.html#v:peekCString'>peekCString </a>  CString -> IO String </tt>	Marshal a NUL terminated C string into a Haskell string
<tt style='background-color:#E8E8E8;'> Foreign.C.String <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-String.html#v:peekCStringLen'>peekCStringLen </a>  CStringLen -> IO String </tt>	Marshal a C string with explicit length into a Haskell string
<tt style='background-color:#E8E8E8;'> Foreign.C.String <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-String.html#v:newCString'>newCString </a>  String -> IO CString </tt>	Marshal a Haskell string into a NUL terminated C string
<tt style='background-color:#E8E8E8;'> Foreign.C.String <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-String.html#v:newCStringLen'>newCStringLen </a>  String -> IO CStringLen </tt>	Marshal a Haskell string into a C string (ie, character array) with explicit length information
<tt style='background-color:#E8E8E8;'> Foreign.C.String <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-String.html#v:withCString'>withCString </a>  String -> (CString -> IO a) -> IO a </tt>	Marshal a Haskell string into a NUL terminated C string using temporary storage
<tt style='background-color:#E8E8E8;'> Foreign.C.String <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-String.html#v:withCStringLen'>withCStringLen </a>  String -> (CStringLen -> IO a) -> IO a </tt>	Marshal a Haskell string into a C string (ie, character array) in temporary storage, with explicit length information
<tt style='background-color:#E8E8E8;'> Foreign.C.String <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-String.html#v:castCharToCChar'>castCharToCChar </a>  Char -> CChar </tt>	Convert a Haskell character to a C character
<tt style='background-color:#E8E8E8;'> Foreign.C.String <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-String.html#v:castCCharToChar'>castCCharToChar </a>  CChar -> Char </tt>	Convert a C byte, representing a Latin-1 character, to the corresponding Haskell character
<tt style='background-color:#E8E8E8;'> Foreign.C.String <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-String.html#v:castCharToCUChar'>castCharToCUChar </a>  Char -> CUChar </tt>	Convert a Haskell character to a C unsigned char
<tt style='background-color:#E8E8E8;'> Foreign.C.String <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-String.html#v:castCUCharToChar'>castCUCharToChar </a>  CUChar -> Char </tt>	Convert a C unsigned char, representing a Latin-1 character, to the corresponding Haskell character
<tt style='background-color:#E8E8E8;'> Foreign.C.String <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-String.html#v:castCharToCSChar'>castCharToCSChar </a>  Char -> CSChar </tt>	Convert a Haskell character to a C signed char
<tt style='background-color:#E8E8E8;'> Foreign.C.String <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-String.html#v:castCSCharToChar'>castCSCharToChar </a>  CSChar -> Char </tt>	Convert a C signed char, representing a Latin-1 character, to the corresponding Haskell character
<tt style='background-color:#E8E8E8;'> Foreign.C.String <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-String.html#v:peekCAString'>peekCAString </a>  CString -> IO String </tt>	Marshal a NUL terminated C string into a Haskell string
<tt style='background-color:#E8E8E8;'> Foreign.C.String <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-String.html#v:peekCAStringLen'>peekCAStringLen </a>  CStringLen -> IO String </tt>	Marshal a C string with explicit length into a Haskell string
<tt style='background-color:#E8E8E8;'> Foreign.C.String <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-String.html#v:newCAString'>newCAString </a>  String -> IO CString </tt>	Marshal a Haskell string into a NUL terminated C string
<tt style='background-color:#E8E8E8;'> Foreign.C.String <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-String.html#v:newCAStringLen'>newCAStringLen </a>  String -> IO CStringLen </tt>	Marshal a Haskell string into a C string (ie, character array) with explicit length information
<tt style='background-color:#E8E8E8;'> Foreign.C.String <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-String.html#v:withCAString'>withCAString </a>  String -> (CString -> IO a) -> IO a </tt>	Marshal a Haskell string into a NUL terminated C string using temporary storage
<tt style='background-color:#E8E8E8;'> Foreign.C.String <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-String.html#v:withCAStringLen'>withCAStringLen </a>  String -> (CStringLen -> IO a) -> IO a </tt>	Marshal a Haskell string into a C string (ie, character array) in temporary storage, with explicit length information
<tt style='background-color:#E8E8E8;'> Foreign.C.String <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-String.html#v:peekCWString'>peekCWString </a>  CWString -> IO String </tt>	Marshal a NUL terminated C wide string into a Haskell string
<tt style='background-color:#E8E8E8;'> Foreign.C.String <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-String.html#v:peekCWStringLen'>peekCWStringLen </a>  CWStringLen -> IO String </tt>	Marshal a C wide string with explicit length into a Haskell string
<tt style='background-color:#E8E8E8;'> Foreign.C.String <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-String.html#v:newCWString'>newCWString </a>  String -> IO CWString </tt>	Marshal a Haskell string into a NUL terminated C wide string
<tt style='background-color:#E8E8E8;'> Foreign.C.String <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-String.html#v:newCWStringLen'>newCWStringLen </a>  String -> IO CWStringLen </tt>	Marshal a Haskell string into a C wide string (ie, wide character array) with explicit length information
<tt style='background-color:#E8E8E8;'> Foreign.C.String <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-String.html#v:withCWString'>withCWString </a>  String -> (CWString -> IO a) -> IO a </tt>	Marshal a Haskell string into a NUL terminated C wide string using temporary storage
<tt style='background-color:#E8E8E8;'> Foreign.C.String <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-String.html#v:withCWStringLen'>withCWStringLen </a>  String -> (CWStringLen -> IO a) -> IO a </tt>	Marshal a Haskell string into a C wide string (i
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Error.html#v:throwIf'>throwIf </a>  (a -> Bool) -> (a -> String) -> IO a -> IO a </tt>	Execute an IO action, throwing a userError if the predicate yields True when applied to the result returned by the IO action
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Error.html#v:throwIf_'>throwIf_ </a>  (a -> Bool) -> (a -> String) -> IO a -> IO () </tt>	Like throwIf, but discarding the result
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Error.html#v:throwIfNeg'>throwIfNeg </a>  (Ord a, Num a) => (a -> String) -> IO a -> IO a </tt>	Guards against negative result values
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Error.html#v:throwIfNeg_'>throwIfNeg_ </a>  (Ord a, Num a) => (a -> String) -> IO a -> IO () </tt>	Like throwIfNeg, but discarding the result
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Error.html#v:throwIfNull'>throwIfNull </a>  String -> IO (Ptr a) -> IO (Ptr a) </tt>	Guards against null pointers
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Error.html#v:void'>void </a>  IO a -> IO () </tt>	Deprecated: use void instead
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Pool <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Pool.html#v:newPool'>newPool </a>  IO Pool </tt>	Allocate a fresh memory pool
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Pool <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Pool.html#v:freePool'>freePool </a>  Pool -> IO () </tt>	Deallocate a memory pool and everything which has been allocated in the pool itself
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Pool <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Pool.html#v:withPool'>withPool </a>  (Pool -> IO b) -> IO b </tt>	Execute an action with a fresh memory pool, which gets automatically deallocated (including its contents) after the action has finished
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Pool <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Pool.html#v:pooledMalloc'>pooledMalloc </a>  Storable a => Pool -> IO (Ptr a) </tt>	Allocate space for storable type in the given pool
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Pool <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Pool.html#v:pooledMallocBytes'>pooledMallocBytes </a>  Pool -> Int -> IO (Ptr a) </tt>	Allocate the given number of bytes of storage in the pool
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Pool <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Pool.html#v:pooledRealloc'>pooledRealloc </a>  Storable a => Pool -> Ptr a -> IO (Ptr a) </tt>	Adjust the storage area for an element in the pool to the given size of the required type
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Pool <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Pool.html#v:pooledReallocBytes'>pooledReallocBytes </a>  Pool -> Ptr a -> Int -> IO (Ptr a) </tt>	Adjust the storage area for an element in the pool to the given size
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Pool <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Pool.html#v:pooledMallocArray'>pooledMallocArray </a>  Storable a => Pool -> Int -> IO (Ptr a) </tt>	Allocate storage for the given number of elements of a storable type in the pool
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Pool <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Pool.html#v:pooledMallocArray0'>pooledMallocArray0 </a>  Storable a => Pool -> Int -> IO (Ptr a) </tt>	Allocate storage for the given number of elements of a storable type in the pool, but leave room for an extra element to signal the end of the array
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Pool <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Pool.html#v:pooledReallocArray'>pooledReallocArray </a>  Storable a => Pool -> Ptr a -> Int -> IO (Ptr a) </tt>	Adjust the size of an array in the given pool
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Pool <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Pool.html#v:pooledReallocArray0'>pooledReallocArray0 </a>  Storable a => Pool -> Ptr a -> Int -> IO (Ptr a) </tt>	Adjust the size of an array with an end marker in the given pool
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Pool <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Pool.html#v:pooledNew'>pooledNew </a>  Storable a => Pool -> a -> IO (Ptr a) </tt>	Allocate storage for a value in the given pool and marshal the value into this storage
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Pool <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Pool.html#v:pooledNewArray'>pooledNewArray </a>  Storable a => Pool -> [a] -> IO (Ptr a) </tt>	Allocate consecutive storage for a list of values in the given pool and marshal these values into it
<tt style='background-color:#E8E8E8;'> Foreign.Marshal.Pool <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Pool.html#v:pooledNewArray0'>pooledNewArray0 </a>  Storable a => Pool -> a -> [a] -> IO (Ptr a) </tt>	Allocate consecutive storage for a list of values in the given pool and marshal these values into it, terminating the end with the given marker
<tt style='background-color:#E8E8E8;'> Foreign.C.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-Error.html#v:Errno'>Errno </a>  CInt -> Errno </tt>	Haskell representation for errno values
<tt style='background-color:#E8E8E8;'> Foreign.C.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-Error.html#v:isValidErrno'>isValidErrno </a>  Errno -> Bool </tt>	Yield True if the given Errno value is valid on the system
<tt style='background-color:#E8E8E8;'> Foreign.C.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-Error.html#v:getErrno'>getErrno </a>  IO Errno </tt>	Get the current value of errno in the current thread
<tt style='background-color:#E8E8E8;'> Foreign.C.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-Error.html#v:resetErrno'>resetErrno </a>  IO () </tt>	Reset the current thread's errno value to eOK
<tt style='background-color:#E8E8E8;'> Foreign.C.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-Error.html#v:errnoToIOError'>errnoToIOError </a>  String -> Errno -> Maybe Handle -> Maybe String -> IOError </tt>	Construct an IOError based on the given Errno value
<tt style='background-color:#E8E8E8;'> Foreign.C.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-Error.html#v:throwErrno'>throwErrno </a>  String -> IO a </tt>	Throw an IOError corresponding to the current value of getErrno
<tt style='background-color:#E8E8E8;'> Foreign.C.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-Error.html#v:throwErrnoIf'>throwErrnoIf </a>  (a -> Bool) -> String -> IO a -> IO a </tt>	Throw an IOError corresponding to the current value of getErrno if the result value of the IO action meets the given predicate
<tt style='background-color:#E8E8E8;'> Foreign.C.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-Error.html#v:throwErrnoIf_'>throwErrnoIf_ </a>  (a -> Bool) -> String -> IO a -> IO () </tt>	as throwErrnoIf, but discards the result of the IO action after error handling
<tt style='background-color:#E8E8E8;'> Foreign.C.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-Error.html#v:throwErrnoIfRetry'>throwErrnoIfRetry </a>  (a -> Bool) -> String -> IO a -> IO a </tt>	as throwErrnoIf, but retry the IO action when it yields the error code eINTR - this amounts to the standard retry loop for interrupted POSIX system calls
<tt style='background-color:#E8E8E8;'> Foreign.C.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-Error.html#v:throwErrnoIfRetry_'>throwErrnoIfRetry_ </a>  (a -> Bool) -> String -> IO a -> IO () </tt>	as throwErrnoIfRetry, but discards the result
<tt style='background-color:#E8E8E8;'> Foreign.C.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-Error.html#v:throwErrnoIfMinus1'>throwErrnoIfMinus1 </a>  (Eq a, Num a) => String -> IO a -> IO a </tt>	Throw an IOError corresponding to the current value of getErrno if the IO action returns a result of -1
<tt style='background-color:#E8E8E8;'> Foreign.C.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-Error.html#v:throwErrnoIfMinus1_'>throwErrnoIfMinus1_ </a>  (Eq a, Num a) => String -> IO a -> IO () </tt>	as throwErrnoIfMinus1, but discards the result
<tt style='background-color:#E8E8E8;'> Foreign.C.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-Error.html#v:throwErrnoIfMinus1Retry'>throwErrnoIfMinus1Retry </a>  (Eq a, Num a) => String -> IO a -> IO a </tt>	Throw an IOError corresponding to the current value of getErrno if the IO action returns a result of -1, but retries in case of an interrupted operation
<tt style='background-color:#E8E8E8;'> Foreign.C.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-Error.html#v:throwErrnoIfMinus1Retry_'>throwErrnoIfMinus1Retry_ </a>  (Eq a, Num a) => String -> IO a -> IO () </tt>	as throwErrnoIfMinus1, but discards the result
<tt style='background-color:#E8E8E8;'> Foreign.C.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-Error.html#v:throwErrnoIfNull'>throwErrnoIfNull </a>  String -> IO (Ptr a) -> IO (Ptr a) </tt>	Throw an IOError corresponding to the current value of getErrno if the IO action returns nullPtr
<tt style='background-color:#E8E8E8;'> Foreign.C.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-Error.html#v:throwErrnoIfNullRetry'>throwErrnoIfNullRetry </a>  String -> IO (Ptr a) -> IO (Ptr a) </tt>	Throw an IOError corresponding to the current value of getErrno if the IO action returns nullPtr, but retry in case of an interrupted operation
<tt style='background-color:#E8E8E8;'> Foreign.C.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-Error.html#v:throwErrnoIfRetryMayBlock'>throwErrnoIfRetryMayBlock </a>  (a -> Bool) -> String -> IO a -> IO b -> IO a </tt>	as throwErrnoIfRetry, but additionally if the operation yields the error code eAGAIN or eWOULDBLOCK, an alternative action is executed before retrying
<tt style='background-color:#E8E8E8;'> Foreign.C.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-Error.html#v:throwErrnoIfRetryMayBlock_'>throwErrnoIfRetryMayBlock_ </a>  (a -> Bool) -> String -> IO a -> IO b -> IO () </tt>	as throwErrnoIfRetryMayBlock, but discards the result
<tt style='background-color:#E8E8E8;'> Foreign.C.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-Error.html#v:throwErrnoIfMinus1RetryMayBlock'>throwErrnoIfMinus1RetryMayBlock </a>  (Eq a, Num a) => String -> IO a -> IO b -> IO a </tt>	as throwErrnoIfMinus1Retry, but checks for operations that would block
<tt style='background-color:#E8E8E8;'> Foreign.C.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-Error.html#v:throwErrnoIfMinus1RetryMayBlock_'>throwErrnoIfMinus1RetryMayBlock_ </a>  (Eq a, Num a) => String -> IO a -> IO b -> IO () </tt>	as throwErrnoIfMinus1RetryMayBlock, but discards the result
<tt style='background-color:#E8E8E8;'> Foreign.C.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-Error.html#v:throwErrnoIfNullRetryMayBlock'>throwErrnoIfNullRetryMayBlock </a>  String -> IO (Ptr a) -> IO b -> IO (Ptr a) </tt>	as throwErrnoIfNullRetry, but checks for operations that would block
<tt style='background-color:#E8E8E8;'> Foreign.C.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-Error.html#v:throwErrnoPath'>throwErrnoPath </a>  String -> FilePath -> IO a </tt>	as throwErrno, but exceptions include the given path when appropriate
<tt style='background-color:#E8E8E8;'> Foreign.C.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-Error.html#v:throwErrnoPathIf'>throwErrnoPathIf </a>  (a -> Bool) -> String -> FilePath -> IO a -> IO a </tt>	as throwErrnoIf, but exceptions include the given path when appropriate
<tt style='background-color:#E8E8E8;'> Foreign.C.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-Error.html#v:throwErrnoPathIf_'>throwErrnoPathIf_ </a>  (a -> Bool) -> String -> FilePath -> IO a -> IO () </tt>	as throwErrnoIf_, but exceptions include the given path when appropriate
<tt style='background-color:#E8E8E8;'> Foreign.C.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-Error.html#v:throwErrnoPathIfNull'>throwErrnoPathIfNull </a>  String -> FilePath -> IO (Ptr a) -> IO (Ptr a) </tt>	as throwErrnoIfNull, but exceptions include the given path when appropriate
<tt style='background-color:#E8E8E8;'> Foreign.C.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-Error.html#v:throwErrnoPathIfMinus1'>throwErrnoPathIfMinus1 </a>  (Eq a, Num a) => String -> FilePath -> IO a -> IO a </tt>	as throwErrnoIfMinus1, but exceptions include the given path when appropriate
<tt style='background-color:#E8E8E8;'> Foreign.C.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-C-Error.html#v:throwErrnoPathIfMinus1_'>throwErrnoPathIfMinus1_ </a>  (Eq a, Num a) => String -> FilePath -> IO a -> IO () </tt>	as throwErrnoIfMinus1_, but exceptions include the given path when appropriate
<tt style='background-color:#E8E8E8;'> System.Posix.Types <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-Posix-Types.html#v:CDev'>CDev </a>  Word64 -> CDev </tt>	POSIX data types: Haskell equivalents of the types defined by the &lt;sys/types
<tt style='background-color:#E8E8E8;'> GHC.IO.Encoding.Failure <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Encoding-Failure.html#v:ErrorOnCodingFailure'>ErrorOnCodingFailure </a>  CodingFailureMode </tt>	Throw an error when an illegal sequence is encountered
<tt style='background-color:#E8E8E8;'> GHC.IO.Encoding.Failure <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Encoding-Failure.html#v:IgnoreCodingFailure'>IgnoreCodingFailure </a>  CodingFailureMode </tt>	Attempt to ignore and recover if an illegal sequence is encountered
<tt style='background-color:#E8E8E8;'> GHC.IO.Encoding.Failure <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Encoding-Failure.html#v:TransliterateCodingFailure'>TransliterateCodingFailure </a>  CodingFailureMode </tt>	Replace with the closest visual match upon an illegal sequence
<tt style='background-color:#E8E8E8;'> GHC.IO.Encoding.Failure <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Encoding-Failure.html#v:RoundtripFailure'>RoundtripFailure </a>  CodingFailureMode </tt>	Use the private-use escape mechanism to attempt to allow illegal sequences to be roundtripped
<tt style='background-color:#E8E8E8;'> GHC.IO.Encoding.Failure <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Encoding-Failure.html#v:isSurrogate'>isSurrogate </a>  Char -> Bool </tt>	Some characters are actually "surrogate" codepoints defined for use in UTF-16
<tt style='background-color:#E8E8E8;'> GHC.IO.Encoding.UTF8 <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Encoding-UTF8.html#v:utf8'>utf8 </a>  TextEncoding </tt>	UTF-8 Codec for the IO library  Portions Copyright : (c) Tom Harper 2008-2009, (c) Bryan O'Sullivan 2009, (c) Duncan Coutts 2009
<tt style='background-color:#E8E8E8;'> GHC.Conc.Sync <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc-Sync.html#v:ThreadId'>ThreadId </a>  ThreadId# -> ThreadId </tt>	A ThreadId is an abstract type representing a handle to a thread
<tt style='background-color:#E8E8E8;'> GHC.Conc.Sync <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc-Sync.html#v:forkIO'>forkIO </a>  IO () -> IO ThreadId </tt>	Creates a new thread to run the IO computation passed as the first argument, and returns the ThreadId of the newly created thread
<tt style='background-color:#E8E8E8;'> GHC.Conc.Sync <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc-Sync.html#v:forkOn'>forkOn </a>  Int -> IO () -> IO ThreadId </tt>	Like forkIO, but lets you specify on which capability the thread should run
<tt style='background-color:#E8E8E8;'> GHC.Conc.Sync <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc-Sync.html#v:numCapabilities'>numCapabilities </a>  Int </tt>	the value passed to the +RTS -N flag
<tt style='background-color:#E8E8E8;'> GHC.Conc.Sync <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc-Sync.html#v:getNumCapabilities'>getNumCapabilities </a>  IO Int </tt>	Returns the number of Haskell threads that can run truly simultaneously (on separate physical processors) at any given time
<tt style='background-color:#E8E8E8;'> GHC.Conc.Sync <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc-Sync.html#v:setNumCapabilities'>setNumCapabilities </a>  Int -> IO () </tt>	Set the number of Haskell threads that can run truly simultaneously (on separate physical processors) at any given time
<tt style='background-color:#E8E8E8;'> GHC.Conc.Sync <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc-Sync.html#v:getNumProcessors'>getNumProcessors </a>  IO Int </tt>	Returns the number of CPUs that the machine has
<tt style='background-color:#E8E8E8;'> GHC.Conc.Sync <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc-Sync.html#v:numSparks'>numSparks </a>  IO Int </tt>	Returns the number of sparks currently in the local spark pool
<tt style='background-color:#E8E8E8;'> GHC.Conc.Sync <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc-Sync.html#v:myThreadId'>myThreadId </a>  IO ThreadId </tt>	Returns the ThreadId of the calling thread (GHC only)
<tt style='background-color:#E8E8E8;'> GHC.Conc.Sync <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc-Sync.html#v:killThread'>killThread </a>  ThreadId -> IO () </tt>	killThread raises the ThreadKilled exception in the given thread (GHC only)
<tt style='background-color:#E8E8E8;'> GHC.Conc.Sync <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc-Sync.html#v:throwTo'>throwTo </a>  Exception e => ThreadId -> e -> IO () </tt>	throwTo raises an arbitrary exception in the target thread (GHC only)
<tt style='background-color:#E8E8E8;'> GHC.Conc.Sync <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc-Sync.html#v:runSparks'>runSparks </a>  IO () </tt>	Internal function used by the RTS to run sparks
<tt style='background-color:#E8E8E8;'> GHC.Conc.Sync <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc-Sync.html#v:yield'>yield </a>  IO () </tt>	The yield action allows (forces, in a co-operative multitasking implementation) a context-switch to any other currently runnable threads (if any), and is occasionally useful when implementing concurrency abstractions
<tt style='background-color:#E8E8E8;'> GHC.Conc.Sync <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc-Sync.html#v:labelThread'>labelThread </a>  ThreadId -> String -> IO () </tt>	labelThread stores a string as identifier for this thread if you built a RTS with debugging support
<tt style='background-color:#E8E8E8;'> GHC.Conc.Sync <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc-Sync.html#v:mkWeakThreadId'>mkWeakThreadId </a>  ThreadId -> IO (Weak ThreadId) </tt>	make a weak pointer to a ThreadId
<tt style='background-color:#E8E8E8;'> GHC.Conc.Sync <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc-Sync.html#v:ThreadRunning'>ThreadRunning </a>  ThreadStatus </tt>	the thread is currently runnable or running
<tt style='background-color:#E8E8E8;'> GHC.Conc.Sync <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc-Sync.html#v:ThreadFinished'>ThreadFinished </a>  ThreadStatus </tt>	the thread has finished
<tt style='background-color:#E8E8E8;'> GHC.Conc.Sync <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc-Sync.html#v:ThreadBlocked'>ThreadBlocked </a>  BlockReason -> ThreadStatus </tt>	the thread is blocked on some resource
<tt style='background-color:#E8E8E8;'> GHC.Conc.Sync <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc-Sync.html#v:ThreadDied'>ThreadDied </a>  ThreadStatus </tt>	the thread received an uncaught exception
<tt style='background-color:#E8E8E8;'> GHC.Conc.Sync <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc-Sync.html#v:BlockedOnMVar'>BlockedOnMVar </a>  BlockReason </tt>	blocked on MVar
<tt style='background-color:#E8E8E8;'> GHC.Conc.Sync <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc-Sync.html#v:BlockedOnBlackHole'>BlockedOnBlackHole </a>  BlockReason </tt>	blocked on a computation in progress by another thread
<tt style='background-color:#E8E8E8;'> GHC.Conc.Sync <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc-Sync.html#v:BlockedOnException'>BlockedOnException </a>  BlockReason </tt>	blocked in throwTo
<tt style='background-color:#E8E8E8;'> GHC.Conc.Sync <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc-Sync.html#v:BlockedOnSTM'>BlockedOnSTM </a>  BlockReason </tt>	blocked in retry in an STM transaction
<tt style='background-color:#E8E8E8;'> GHC.Conc.Sync <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc-Sync.html#v:BlockedOnForeignCall'>BlockedOnForeignCall </a>  BlockReason </tt>	currently in a foreign call
<tt style='background-color:#E8E8E8;'> GHC.Conc.Sync <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc-Sync.html#v:BlockedOnOther'>BlockedOnOther </a>  BlockReason </tt>	blocked on some other resource
<tt style='background-color:#E8E8E8;'> GHC.Conc.Sync <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc-Sync.html#v:threadCapability'>threadCapability </a>  ThreadId -> IO (Int, Bool) </tt>	returns the number of the capability on which the thread is currently running, and a boolean indicating whether the thread is locked to that capability or not
<tt style='background-color:#E8E8E8;'> GHC.Conc.Sync <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc-Sync.html#v:setAllocationCounter'>setAllocationCounter </a>  Int64 -> IO () </tt>	Every thread has an allocation counter that tracks how much memory has been allocated by the thread
<tt style='background-color:#E8E8E8;'> GHC.Conc.Sync <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc-Sync.html#v:getAllocationCounter'>getAllocationCounter </a>  IO Int64 </tt>	Return the current value of the allocation counter for the current thread
<tt style='background-color:#E8E8E8;'> GHC.Conc.Sync <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc-Sync.html#v:enableAllocationLimit'>enableAllocationLimit </a>  IO () </tt>	Enables the allocation counter to be treated as a limit for the current thread
<tt style='background-color:#E8E8E8;'> GHC.Conc.Sync <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc-Sync.html#v:disableAllocationLimit'>disableAllocationLimit </a>  IO () </tt>	Disable allocation limit processing for the current thread
<tt style='background-color:#E8E8E8;'> GHC.Conc.Sync <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc-Sync.html#v:STM'>STM </a>  (State# RealWorld -> (# State# RealWorld, a #)) -> STM a </tt>	A monad supporting atomic memory transactions
<tt style='background-color:#E8E8E8;'> GHC.Conc.Sync <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc-Sync.html#v:atomically'>atomically </a>  STM a -> IO a </tt>	Perform a series of STM actions atomically
<tt style='background-color:#E8E8E8;'> GHC.Conc.Sync <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc-Sync.html#v:retry'>retry </a>  STM a </tt>	Retry execution of the current memory transaction because it has seen values in TVars which mean that it should not continue (e
<tt style='background-color:#E8E8E8;'> GHC.Conc.Sync <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc-Sync.html#v:orElse'>orElse </a>  STM a -> STM a -> STM a </tt>	Compose two alternative STM actions (GHC only)
<tt style='background-color:#E8E8E8;'> GHC.Conc.Sync <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc-Sync.html#v:throwSTM'>throwSTM </a>  Exception e => e -> STM a </tt>	A variant of throw that can only be used within the STM monad
<tt style='background-color:#E8E8E8;'> GHC.Conc.Sync <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc-Sync.html#v:catchSTM'>catchSTM </a>  Exception e => STM a -> (e -> STM a) -> STM a </tt>	Exception handling within STM actions
<tt style='background-color:#E8E8E8;'> GHC.Conc.Sync <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc-Sync.html#v:alwaysSucceeds'>alwaysSucceeds </a>  STM a -> STM () </tt>	alwaysSucceeds adds a new invariant that must be true when passed to alwaysSucceeds, at the end of the current transaction, and at the end of every subsequent transaction
<tt style='background-color:#E8E8E8;'> GHC.Conc.Sync <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc-Sync.html#v:always'>always </a>  STM Bool -> STM () </tt>	always is a variant of alwaysSucceeds in which the invariant is expressed as an STM Bool action that must return True
<tt style='background-color:#E8E8E8;'> GHC.Conc.Sync <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc-Sync.html#v:TVar'>TVar </a>  (TVar# RealWorld a) -> TVar a </tt>	Shared memory locations that support atomic memory transactions
<tt style='background-color:#E8E8E8;'> GHC.Conc.Sync <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc-Sync.html#v:newTVar'>newTVar </a>  a -> STM (TVar a) </tt>	Create a new TVar holding a value supplied
<tt style='background-color:#E8E8E8;'> GHC.Conc.Sync <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc-Sync.html#v:newTVarIO'>newTVarIO </a>  a -> IO (TVar a) </tt>	IO version of newTVar
<tt style='background-color:#E8E8E8;'> GHC.Conc.Sync <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc-Sync.html#v:readTVar'>readTVar </a>  TVar a -> STM a </tt>	Return the current value stored in a TVar
<tt style='background-color:#E8E8E8;'> GHC.Conc.Sync <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc-Sync.html#v:readTVarIO'>readTVarIO </a>  TVar a -> IO a </tt>	Return the current value stored in a TVar
<tt style='background-color:#E8E8E8;'> GHC.Conc.Sync <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc-Sync.html#v:writeTVar'>writeTVar </a>  TVar a -> a -> STM () </tt>	Write the supplied value into a TVar
<tt style='background-color:#E8E8E8;'> GHC.Conc.Sync <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc-Sync.html#v:unsafeIOToSTM'>unsafeIOToSTM </a>  IO a -> STM a </tt>	Unsafely performs IO in the STM monad
<tt style='background-color:#E8E8E8;'> Control.Exception.Base <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception-Base.html#v:SomeException'>SomeException </a>  e -> SomeException </tt>	The SomeException type is the root of the exception type hierarchy
<tt style='background-color:#E8E8E8;'> Control.Exception.Base <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception-Base.html#v:toException'>toException </a>  Exception e => e -> SomeException </tt>	Any type that you wish to throw or catch as an exception must be an instance of the Exception class
<tt style='background-color:#E8E8E8;'> Control.Exception.Base <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception-Base.html#v:displayException'>displayException </a>  Exception e => e -> String </tt>	Render this exception value in a human-friendly manner
<tt style='background-color:#E8E8E8;'> Control.Exception.Base <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception-Base.html#v:Overflow'>Overflow </a>  ArithException </tt>	Arithmetic exceptions
<tt style='background-color:#E8E8E8;'> Control.Exception.Base <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception-Base.html#v:IndexOutOfBounds'>IndexOutOfBounds </a>  String -> ArrayException </tt>	An attempt was made to index an array outside its declared bounds
<tt style='background-color:#E8E8E8;'> Control.Exception.Base <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception-Base.html#v:UndefinedElement'>UndefinedElement </a>  String -> ArrayException </tt>	An attempt was made to evaluate an element of an array that had not been initialized
<tt style='background-color:#E8E8E8;'> Control.Exception.Base <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception-Base.html#v:AssertionFailed'>AssertionFailed </a>  String -> AssertionFailed </tt>	assert was applied to False
<tt style='background-color:#E8E8E8;'> Control.Exception.Base <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception-Base.html#v:SomeAsyncException'>SomeAsyncException </a>  e -> SomeAsyncException </tt>	Superclass for asynchronous exceptions
<tt style='background-color:#E8E8E8;'> Control.Exception.Base <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception-Base.html#v:StackOverflow'>StackOverflow </a>  AsyncException </tt>	The current thread's stack exceeded its limit
<tt style='background-color:#E8E8E8;'> Control.Exception.Base <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception-Base.html#v:HeapOverflow'>HeapOverflow </a>  AsyncException </tt>	The program's heap is reaching its limit, and the program should take action to reduce the amount of live data it has
<tt style='background-color:#E8E8E8;'> Control.Exception.Base <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception-Base.html#v:ThreadKilled'>ThreadKilled </a>  AsyncException </tt>	This exception is raised by another thread calling killThread, or by the system if it needs to terminate the thread for some reason
<tt style='background-color:#E8E8E8;'> Control.Exception.Base <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception-Base.html#v:UserInterrupt'>UserInterrupt </a>  AsyncException </tt>	This exception is raised by default in the main thread of the program when the user requests to terminate the program via the usual mechanism(s) (e
<tt style='background-color:#E8E8E8;'> Control.Exception.Base <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception-Base.html#v:NonTermination'>NonTermination </a>  NonTermination </tt>	Thrown when the runtime system detects that the computation is guaranteed not to terminate
<tt style='background-color:#E8E8E8;'> Control.Exception.Base <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception-Base.html#v:NestedAtomically'>NestedAtomically </a>  NestedAtomically </tt>	Thrown when the program attempts to call atomically, from the stm package, inside another call to atomically
<tt style='background-color:#E8E8E8;'> Control.Exception.Base <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception-Base.html#v:BlockedIndefinitelyOnMVar'>BlockedIndefinitelyOnMVar </a>  BlockedIndefinitelyOnMVar </tt>	The thread is blocked on an MVar, but there are no other references to the MVar so it can't ever continue
<tt style='background-color:#E8E8E8;'> Control.Exception.Base <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception-Base.html#v:BlockedIndefinitelyOnSTM'>BlockedIndefinitelyOnSTM </a>  BlockedIndefinitelyOnSTM </tt>	The thread is waiting to retry an STM transaction, but there are no other references to any TVars involved, so it can't ever continue
<tt style='background-color:#E8E8E8;'> Control.Exception.Base <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception-Base.html#v:AllocationLimitExceeded'>AllocationLimitExceeded </a>  AllocationLimitExceeded </tt>	This thread has exceeded its allocation limit
<tt style='background-color:#E8E8E8;'> Control.Exception.Base <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception-Base.html#v:Deadlock'>Deadlock </a>  Deadlock </tt>	There are no runnable threads, so the program is deadlocked
<tt style='background-color:#E8E8E8;'> Control.Exception.Base <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception-Base.html#v:NoMethodError'>NoMethodError </a>  String -> NoMethodError </tt>	A class method without a definition (neither a default definition, nor a definition in the appropriate instance) was called
<tt style='background-color:#E8E8E8;'> Control.Exception.Base <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception-Base.html#v:PatternMatchFail'>PatternMatchFail </a>  String -> PatternMatchFail </tt>	A pattern match failed
<tt style='background-color:#E8E8E8;'> Control.Exception.Base <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception-Base.html#v:RecConError'>RecConError </a>  String -> RecConError </tt>	An uninitialised record field was used
<tt style='background-color:#E8E8E8;'> Control.Exception.Base <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception-Base.html#v:RecSelError'>RecSelError </a>  String -> RecSelError </tt>	A record selector was applied to a constructor without the appropriate field
<tt style='background-color:#E8E8E8;'> Control.Exception.Base <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception-Base.html#v:RecUpdError'>RecUpdError </a>  String -> RecUpdError </tt>	A record update was performed on a constructor without the appropriate field
<tt style='background-color:#E8E8E8;'> Control.Exception.Base <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception-Base.html#v:ErrorCall'>ErrorCall </a>  String -> ErrorCall </tt>	This is thrown when the user calls error
<tt style='background-color:#E8E8E8;'> Control.Exception.Base <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception-Base.html#v:throwIO'>throwIO </a>  Exception e => e -> IO a </tt>	A variant of throw that can only be used within the IO monad
<tt style='background-color:#E8E8E8;'> Control.Exception.Base <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception-Base.html#v:throw'>throw </a>  Exception e => e -> a </tt>	Throw an exception
<tt style='background-color:#E8E8E8;'> Control.Exception.Base <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception-Base.html#v:ioError'>ioError </a>  IOError -> IO a </tt>	Raise an IOError in the IO monad
<tt style='background-color:#E8E8E8;'> Control.Exception.Base <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception-Base.html#v:throwTo'>throwTo </a>  Exception e => ThreadId -> e -> IO () </tt>	throwTo raises an arbitrary exception in the target thread (GHC only)
<tt style='background-color:#E8E8E8;'> Control.Exception.Base <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception-Base.html#v:catch'>catch </a>  Exception e => IO a -> (e -> IO a) -> IO a </tt>	This is the simplest of the exception-catching functions
<tt style='background-color:#E8E8E8;'> Control.Exception.Base <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception-Base.html#v:catchJust'>catchJust </a>  Exception e => (e -> Maybe b) -> IO a -> (b -> IO a) -> IO a </tt>	The function catchJust is like catch, but it takes an extra argument which is an exception predicate, a function which selects which type of exceptions we're interested in
<tt style='background-color:#E8E8E8;'> Control.Exception.Base <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception-Base.html#v:handle'>handle </a>  Exception e => (e -> IO a) -> IO a -> IO a </tt>	A version of catch with the arguments swapped around; useful in situations where the code for the handler is shorter
<tt style='background-color:#E8E8E8;'> Control.Exception.Base <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception-Base.html#v:handleJust'>handleJust </a>  Exception e => (e -> Maybe b) -> (b -> IO a) -> IO a -> IO a </tt>	A version of catchJust with the arguments swapped around (see handle)
<tt style='background-color:#E8E8E8;'> Control.Exception.Base <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception-Base.html#v:try'>try </a>  Exception e => IO a -> IO (Either e a) </tt>	Similar to catch, but returns an Either result which is (Right a) if no exception of type e was raised, or (Left ex) if an exception of type e was raised and its value is ex
<tt style='background-color:#E8E8E8;'> Control.Exception.Base <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception-Base.html#v:tryJust'>tryJust </a>  Exception e => (e -> Maybe b) -> IO a -> IO (Either b a) </tt>	A variant of try that takes an exception predicate to select which exceptions are caught (c
<tt style='background-color:#E8E8E8;'> Control.Exception.Base <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception-Base.html#v:onException'>onException </a>  IO a -> IO b -> IO a </tt>	Like finally, but only performs the final action if there was an exception raised by the computation
<tt style='background-color:#E8E8E8;'> Control.Exception.Base <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception-Base.html#v:evaluate'>evaluate </a>  a -> IO a </tt>	Forces its argument to be evaluated to weak head normal form when the resultant IO action is executed
<tt style='background-color:#E8E8E8;'> Control.Exception.Base <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception-Base.html#v:mapException'>mapException </a>  (Exception e1, Exception e2) => (e1 -> e2) -> a -> a </tt>	This function maps one exception into another as proposed in the paper "A semantics for imprecise exceptions"
<tt style='background-color:#E8E8E8;'> Control.Exception.Base <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception-Base.html#v:mask_'>mask_ </a>  IO a -> IO a </tt>	Like mask, but does not pass a restore action to the argument
<tt style='background-color:#E8E8E8;'> Control.Exception.Base <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception-Base.html#v:uninterruptibleMask_'>uninterruptibleMask_ </a>  IO a -> IO a </tt>	Like uninterruptibleMask, but does not pass a restore action to the argument
<tt style='background-color:#E8E8E8;'> Control.Exception.Base <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception-Base.html#v:Unmasked'>Unmasked </a>  MaskingState </tt>	asynchronous exceptions are unmasked (the normal state)
<tt style='background-color:#E8E8E8;'> Control.Exception.Base <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception-Base.html#v:MaskedInterruptible'>MaskedInterruptible </a>  MaskingState </tt>	the state during mask: asynchronous exceptions are masked, but blocking operations may still be interrupted
<tt style='background-color:#E8E8E8;'> Control.Exception.Base <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception-Base.html#v:MaskedUninterruptible'>MaskedUninterruptible </a>  MaskingState </tt>	the state during uninterruptibleMask: asynchronous exceptions are masked, and blocking operations may not be interrupted
<tt style='background-color:#E8E8E8;'> Control.Exception.Base <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception-Base.html#v:getMaskingState'>getMaskingState </a>  IO MaskingState </tt>	Returns the MaskingState for the current thread
<tt style='background-color:#E8E8E8;'> Control.Exception.Base <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception-Base.html#v:assert'>assert </a>  Bool -> a -> a </tt>	If the first argument evaluates to True, then the result is the second argument
<tt style='background-color:#E8E8E8;'> Control.Exception.Base <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception-Base.html#v:bracket'>bracket </a>  IO a -> (a -> IO b) -> (a -> IO c) -> IO c </tt>	When you want to acquire a resource, do some work with it, and then release the resource, it is a good idea to use bracket, because bracket will install the necessary exception handler to release the resource in the event that an exception is raised during the computation
<tt style='background-color:#E8E8E8;'> Control.Exception.Base <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception-Base.html#v:bracket_'>bracket_ </a>  IO a -> IO b -> IO c -> IO c </tt>	A variant of bracket where the return value from the first computation is not required
<tt style='background-color:#E8E8E8;'> Control.Exception.Base <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception-Base.html#v:bracketOnError'>bracketOnError </a>  IO a -> (a -> IO b) -> (a -> IO c) -> IO c </tt>	Like bracket, but only performs the final action if there was an exception raised by the in-between computation
<tt style='background-color:#E8E8E8;'> Control.Exception.Base <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception-Base.html#v:finally'>finally </a>  IO a -> IO b -> IO a </tt>	A specialised variant of bracket with just a computation to run afterward
<tt style='background-color:#E8E8E8;'> Control.Concurrent.MVar <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent-MVar.html#v:newEmptyMVar'>newEmptyMVar </a>  IO (MVar a) </tt>	Create an MVar which is initially empty
<tt style='background-color:#E8E8E8;'> Control.Concurrent.MVar <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent-MVar.html#v:newMVar'>newMVar </a>  a -> IO (MVar a) </tt>	Create an MVar which contains the supplied value
<tt style='background-color:#E8E8E8;'> Control.Concurrent.MVar <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent-MVar.html#v:takeMVar'>takeMVar </a>  MVar a -> IO a </tt>	Return the contents of the MVar
<tt style='background-color:#E8E8E8;'> Control.Concurrent.MVar <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent-MVar.html#v:putMVar'>putMVar </a>  MVar a -> a -> IO () </tt>	Put a value into an MVar
<tt style='background-color:#E8E8E8;'> Control.Concurrent.MVar <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent-MVar.html#v:readMVar'>readMVar </a>  MVar a -> IO a </tt>	Atomically read the contents of an MVar
<tt style='background-color:#E8E8E8;'> Control.Concurrent.MVar <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent-MVar.html#v:swapMVar'>swapMVar </a>  MVar a -> a -> IO a </tt>	Take a value from an MVar, put a new value into the MVar and return the value taken
<tt style='background-color:#E8E8E8;'> Control.Concurrent.MVar <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent-MVar.html#v:tryTakeMVar'>tryTakeMVar </a>  MVar a -> IO (Maybe a) </tt>	A non-blocking version of takeMVar
<tt style='background-color:#E8E8E8;'> Control.Concurrent.MVar <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent-MVar.html#v:tryPutMVar'>tryPutMVar </a>  MVar a -> a -> IO Bool </tt>	A non-blocking version of putMVar
<tt style='background-color:#E8E8E8;'> Control.Concurrent.MVar <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent-MVar.html#v:isEmptyMVar'>isEmptyMVar </a>  MVar a -> IO Bool </tt>	Check whether a given MVar is empty
<tt style='background-color:#E8E8E8;'> Control.Concurrent.MVar <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent-MVar.html#v:withMVar'>withMVar </a>  MVar a -> (a -> IO b) -> IO b </tt>	withMVar is an exception-safe wrapper for operating on the contents of an MVar
<tt style='background-color:#E8E8E8;'> Control.Concurrent.MVar <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent-MVar.html#v:withMVarMasked'>withMVarMasked </a>  MVar a -> (a -> IO b) -> IO b </tt>	Like withMVar, but the IO action in the second argument is executed with asynchronous exceptions masked
<tt style='background-color:#E8E8E8;'> Control.Concurrent.MVar <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent-MVar.html#v:modifyMVar_'>modifyMVar_ </a>  MVar a -> (a -> IO a) -> IO () </tt>	An exception-safe wrapper for modifying the contents of an MVar
<tt style='background-color:#E8E8E8;'> Control.Concurrent.MVar <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent-MVar.html#v:modifyMVar'>modifyMVar </a>  MVar a -> (a -> IO (a, b)) -> IO b </tt>	A slight variation on modifyMVar_ that allows a value to be returned (b) in addition to the modified value of the MVar
<tt style='background-color:#E8E8E8;'> Control.Concurrent.MVar <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent-MVar.html#v:modifyMVarMasked_'>modifyMVarMasked_ </a>  MVar a -> (a -> IO a) -> IO () </tt>	Like modifyMVar_, but the IO action in the second argument is executed with asynchronous exceptions masked
<tt style='background-color:#E8E8E8;'> Control.Concurrent.MVar <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent-MVar.html#v:modifyMVarMasked'>modifyMVarMasked </a>  MVar a -> (a -> IO (a, b)) -> IO b </tt>	Like modifyMVar, but the IO action in the second argument is executed with asynchronous exceptions masked
<tt style='background-color:#E8E8E8;'> Control.Concurrent.MVar <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent-MVar.html#v:tryReadMVar'>tryReadMVar </a>  MVar a -> IO (Maybe a) </tt>	A non-blocking version of readMVar
<tt style='background-color:#E8E8E8;'> Control.Concurrent.MVar <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent-MVar.html#v:mkWeakMVar'>mkWeakMVar </a>  MVar a -> IO () -> IO (Weak (MVar a)) </tt>	Make a Weak pointer to an MVar, using the second argument as a finalizer to run when MVar is garbage-collected
<tt style='background-color:#E8E8E8;'> Control.Concurrent.MVar <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent-MVar.html#v:addMVarFinalizer'>addMVarFinalizer </a>  MVar a -> IO () -> IO () </tt>	Deprecated: use mkWeakMVar instead
<tt style='background-color:#E8E8E8;'> Control.Exception <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:SomeException'>SomeException </a>  e -> SomeException </tt>	The SomeException type is the root of the exception type hierarchy
<tt style='background-color:#E8E8E8;'> Control.Exception <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:toException'>toException </a>  Exception e => e -> SomeException </tt>	Any type that you wish to throw or catch as an exception must be an instance of the Exception class
<tt style='background-color:#E8E8E8;'> Control.Exception <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:displayException'>displayException </a>  Exception e => e -> String </tt>	Render this exception value in a human-friendly manner
<tt style='background-color:#E8E8E8;'> Control.Exception <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:Overflow'>Overflow </a>  ArithException </tt>	Arithmetic exceptions
<tt style='background-color:#E8E8E8;'> Control.Exception <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:IndexOutOfBounds'>IndexOutOfBounds </a>  String -> ArrayException </tt>	An attempt was made to index an array outside its declared bounds
<tt style='background-color:#E8E8E8;'> Control.Exception <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:UndefinedElement'>UndefinedElement </a>  String -> ArrayException </tt>	An attempt was made to evaluate an element of an array that had not been initialized
<tt style='background-color:#E8E8E8;'> Control.Exception <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:AssertionFailed'>AssertionFailed </a>  String -> AssertionFailed </tt>	assert was applied to False
<tt style='background-color:#E8E8E8;'> Control.Exception <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:SomeAsyncException'>SomeAsyncException </a>  e -> SomeAsyncException </tt>	Superclass for asynchronous exceptions
<tt style='background-color:#E8E8E8;'> Control.Exception <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:StackOverflow'>StackOverflow </a>  AsyncException </tt>	The current thread's stack exceeded its limit
<tt style='background-color:#E8E8E8;'> Control.Exception <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:HeapOverflow'>HeapOverflow </a>  AsyncException </tt>	The program's heap is reaching its limit, and the program should take action to reduce the amount of live data it has
<tt style='background-color:#E8E8E8;'> Control.Exception <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:ThreadKilled'>ThreadKilled </a>  AsyncException </tt>	This exception is raised by another thread calling killThread, or by the system if it needs to terminate the thread for some reason
<tt style='background-color:#E8E8E8;'> Control.Exception <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:UserInterrupt'>UserInterrupt </a>  AsyncException </tt>	This exception is raised by default in the main thread of the program when the user requests to terminate the program via the usual mechanism(s) (e
<tt style='background-color:#E8E8E8;'> Control.Exception <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:NonTermination'>NonTermination </a>  NonTermination </tt>	Thrown when the runtime system detects that the computation is guaranteed not to terminate
<tt style='background-color:#E8E8E8;'> Control.Exception <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:NestedAtomically'>NestedAtomically </a>  NestedAtomically </tt>	Thrown when the program attempts to call atomically, from the stm package, inside another call to atomically
<tt style='background-color:#E8E8E8;'> Control.Exception <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:BlockedIndefinitelyOnMVar'>BlockedIndefinitelyOnMVar </a>  BlockedIndefinitelyOnMVar </tt>	The thread is blocked on an MVar, but there are no other references to the MVar so it can't ever continue
<tt style='background-color:#E8E8E8;'> Control.Exception <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:BlockedIndefinitelyOnSTM'>BlockedIndefinitelyOnSTM </a>  BlockedIndefinitelyOnSTM </tt>	The thread is waiting to retry an STM transaction, but there are no other references to any TVars involved, so it can't ever continue
<tt style='background-color:#E8E8E8;'> Control.Exception <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:AllocationLimitExceeded'>AllocationLimitExceeded </a>  AllocationLimitExceeded </tt>	This thread has exceeded its allocation limit
<tt style='background-color:#E8E8E8;'> Control.Exception <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:Deadlock'>Deadlock </a>  Deadlock </tt>	There are no runnable threads, so the program is deadlocked
<tt style='background-color:#E8E8E8;'> Control.Exception <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:NoMethodError'>NoMethodError </a>  String -> NoMethodError </tt>	A class method without a definition (neither a default definition, nor a definition in the appropriate instance) was called
<tt style='background-color:#E8E8E8;'> Control.Exception <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:PatternMatchFail'>PatternMatchFail </a>  String -> PatternMatchFail </tt>	A pattern match failed
<tt style='background-color:#E8E8E8;'> Control.Exception <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:RecConError'>RecConError </a>  String -> RecConError </tt>	An uninitialised record field was used
<tt style='background-color:#E8E8E8;'> Control.Exception <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:RecSelError'>RecSelError </a>  String -> RecSelError </tt>	A record selector was applied to a constructor without the appropriate field
<tt style='background-color:#E8E8E8;'> Control.Exception <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:RecUpdError'>RecUpdError </a>  String -> RecUpdError </tt>	A record update was performed on a constructor without the appropriate field
<tt style='background-color:#E8E8E8;'> Control.Exception <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:ErrorCall'>ErrorCall </a>  String -> ErrorCall </tt>	This is thrown when the user calls error
<tt style='background-color:#E8E8E8;'> Control.Exception <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:throw'>throw </a>  Exception e => e -> a </tt>	Throw an exception
<tt style='background-color:#E8E8E8;'> Control.Exception <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:throwIO'>throwIO </a>  Exception e => e -> IO a </tt>	A variant of throw that can only be used within the IO monad
<tt style='background-color:#E8E8E8;'> Control.Exception <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:ioError'>ioError </a>  IOError -> IO a </tt>	Raise an IOError in the IO monad
<tt style='background-color:#E8E8E8;'> Control.Exception <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:throwTo'>throwTo </a>  Exception e => ThreadId -> e -> IO () </tt>	throwTo raises an arbitrary exception in the target thread (GHC only)
<tt style='background-color:#E8E8E8;'> Control.Exception <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:catch'>catch </a>  Exception e => IO a -> (e -> IO a) -> IO a </tt>	This is the simplest of the exception-catching functions
<tt style='background-color:#E8E8E8;'> Control.Exception <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:catches'>catches </a>  IO a -> [Handler a] -> IO a </tt>	Sometimes you want to catch two different sorts of exception
<tt style='background-color:#E8E8E8;'> Control.Exception <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:Handler'>Handler </a>  (e -> IO a) -> Handler a </tt>	You need this when using catches
<tt style='background-color:#E8E8E8;'> Control.Exception <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:catchJust'>catchJust </a>  Exception e => (e -> Maybe b) -> IO a -> (b -> IO a) -> IO a </tt>	The function catchJust is like catch, but it takes an extra argument which is an exception predicate, a function which selects which type of exceptions we're interested in
<tt style='background-color:#E8E8E8;'> Control.Exception <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:handle'>handle </a>  Exception e => (e -> IO a) -> IO a -> IO a </tt>	A version of catch with the arguments swapped around; useful in situations where the code for the handler is shorter
<tt style='background-color:#E8E8E8;'> Control.Exception <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:handleJust'>handleJust </a>  Exception e => (e -> Maybe b) -> (b -> IO a) -> IO a -> IO a </tt>	A version of catchJust with the arguments swapped around (see handle)
<tt style='background-color:#E8E8E8;'> Control.Exception <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:try'>try </a>  Exception e => IO a -> IO (Either e a) </tt>	Similar to catch, but returns an Either result which is (Right a) if no exception of type e was raised, or (Left ex) if an exception of type e was raised and its value is ex
<tt style='background-color:#E8E8E8;'> Control.Exception <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:tryJust'>tryJust </a>  Exception e => (e -> Maybe b) -> IO a -> IO (Either b a) </tt>	A variant of try that takes an exception predicate to select which exceptions are caught (c
<tt style='background-color:#E8E8E8;'> Control.Exception <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:evaluate'>evaluate </a>  a -> IO a </tt>	Forces its argument to be evaluated to weak head normal form when the resultant IO action is executed
<tt style='background-color:#E8E8E8;'> Control.Exception <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:mapException'>mapException </a>  (Exception e1, Exception e2) => (e1 -> e2) -> a -> a </tt>	This function maps one exception into another as proposed in the paper "A semantics for imprecise exceptions"
<tt style='background-color:#E8E8E8;'> Control.Exception <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:mask_'>mask_ </a>  IO a -> IO a </tt>	Like mask, but does not pass a restore action to the argument
<tt style='background-color:#E8E8E8;'> Control.Exception <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:uninterruptibleMask_'>uninterruptibleMask_ </a>  IO a -> IO a </tt>	Like uninterruptibleMask, but does not pass a restore action to the argument
<tt style='background-color:#E8E8E8;'> Control.Exception <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:Unmasked'>Unmasked </a>  MaskingState </tt>	asynchronous exceptions are unmasked (the normal state)
<tt style='background-color:#E8E8E8;'> Control.Exception <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:MaskedInterruptible'>MaskedInterruptible </a>  MaskingState </tt>	the state during mask: asynchronous exceptions are masked, but blocking operations may still be interrupted
<tt style='background-color:#E8E8E8;'> Control.Exception <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:MaskedUninterruptible'>MaskedUninterruptible </a>  MaskingState </tt>	the state during uninterruptibleMask: asynchronous exceptions are masked, and blocking operations may not be interrupted
<tt style='background-color:#E8E8E8;'> Control.Exception <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:getMaskingState'>getMaskingState </a>  IO MaskingState </tt>	Returns the MaskingState for the current thread
<tt style='background-color:#E8E8E8;'> Control.Exception <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:allowInterrupt'>allowInterrupt </a>  IO () </tt>	When invoked inside mask, this function allows a masked asynchronous exception to be raised, if one exists
<tt style='background-color:#E8E8E8;'> Control.Exception <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:assert'>assert </a>  Bool -> a -> a </tt>	If the first argument evaluates to True, then the result is the second argument
<tt style='background-color:#E8E8E8;'> Control.Exception <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:bracket'>bracket </a>  IO a -> (a -> IO b) -> (a -> IO c) -> IO c </tt>	When you want to acquire a resource, do some work with it, and then release the resource, it is a good idea to use bracket, because bracket will install the necessary exception handler to release the resource in the event that an exception is raised during the computation
<tt style='background-color:#E8E8E8;'> Control.Exception <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:bracket_'>bracket_ </a>  IO a -> IO b -> IO c -> IO c </tt>	A variant of bracket where the return value from the first computation is not required
<tt style='background-color:#E8E8E8;'> Control.Exception <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:bracketOnError'>bracketOnError </a>  IO a -> (a -> IO b) -> (a -> IO c) -> IO c </tt>	Like bracket, but only performs the final action if there was an exception raised by the in-between computation
<tt style='background-color:#E8E8E8;'> Control.Exception <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:finally'>finally </a>  IO a -> IO b -> IO a </tt>	A specialised variant of bracket with just a computation to run afterward
<tt style='background-color:#E8E8E8;'> Control.Exception <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html#v:onException'>onException </a>  IO a -> IO b -> IO a </tt>	Like finally, but only performs the final action if there was an exception raised by the computation
<tt style='background-color:#E8E8E8;'> System.IO.Unsafe <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO-Unsafe.html#v:unsafePerformIO'>unsafePerformIO </a>  IO a -> a </tt>	This is the "back door" into the IO monad, allowing IO computation to be performed at any time
<tt style='background-color:#E8E8E8;'> System.IO.Unsafe <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO-Unsafe.html#v:unsafeDupablePerformIO'>unsafeDupablePerformIO </a>  IO a -> a </tt>	This version of unsafePerformIO is more efficient because it omits the check that the IO is only being performed by a single thread
<tt style='background-color:#E8E8E8;'> System.IO.Unsafe <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO-Unsafe.html#v:unsafeInterleaveIO'>unsafeInterleaveIO </a>  IO a -> IO a </tt>	unsafeInterleaveIO allows IO computation to be deferred lazily
<tt style='background-color:#E8E8E8;'> System.IO.Unsafe <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO-Unsafe.html#v:unsafeFixIO'>unsafeFixIO </a>  (a -> IO a) -> IO a </tt>	A slightly faster version of fixIO that may not be safe to use with multiple threads
<tt style='background-color:#E8E8E8;'> GHC.IO.Encoding.Latin1 <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Encoding-Latin1.html#v:latin1'>latin1 </a>  TextEncoding </tt>	Single-byte encodings that map directly to Unicode code points
<tt style='background-color:#E8E8E8;'> GHC.IO.Encoding.UTF16 <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Encoding-UTF16.html#v:utf16'>utf16 </a>  TextEncoding </tt>	UTF-16 Codecs for the IO library  Portions Copyright : (c) Tom Harper 2008-2009, (c) Bryan O'Sullivan 2009, (c) Duncan Coutts 2009
<tt style='background-color:#E8E8E8;'> GHC.IO.Encoding.UTF32 <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Encoding-UTF32.html#v:utf32'>utf32 </a>  TextEncoding </tt>	UTF-32 Codecs for the IO library  Portions Copyright : (c) Tom Harper 2008-2009, (c) Bryan O'Sullivan 2009, (c) Duncan Coutts 2009
<tt style='background-color:#E8E8E8;'> GHC.IO.Encoding <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Encoding.html#v:BufferCodec'>BufferCodec </a>  CodeBuffer from to -> (Buffer from -> Buffer to -> IO (Buffer from, Buffer to)) -> IO () -> IO state -> (state -> IO ()) -> BufferCodec from to state </tt>	Text codecs for I/O
<tt style='background-color:#E8E8E8;'> GHC.IO.Encoding <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Encoding.html#v:[encode]'>[encode] </a>  BufferCodec from to state -> CodeBuffer from to </tt>	The encode function translates elements of the buffer from to the buffer to
<tt style='background-color:#E8E8E8;'> GHC.IO.Encoding <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Encoding.html#v:[recover]'>[recover] </a>  BufferCodec from to state -> Buffer from -> Buffer to -> IO (Buffer from, Buffer to) </tt>	The recover function is used to continue decoding in the presence of invalid or unrepresentable sequences
<tt style='background-color:#E8E8E8;'> GHC.IO.Encoding <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Encoding.html#v:[close]'>[close] </a>  BufferCodec from to state -> IO () </tt>	Resources associated with the encoding may now be released
<tt style='background-color:#E8E8E8;'> GHC.IO.Encoding <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Encoding.html#v:[getState]'>[getState] </a>  BufferCodec from to state -> IO state </tt>	Return the current state of the codec
<tt style='background-color:#E8E8E8;'> GHC.IO.Encoding <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Encoding.html#v:TextEncoding'>TextEncoding </a>  String -> IO (TextDecoder dstate) -> IO (TextEncoder estate) -> TextEncoding </tt>	A TextEncoding is a specification of a conversion scheme between sequences of bytes and sequences of Unicode characters
<tt style='background-color:#E8E8E8;'> GHC.IO.Encoding <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Encoding.html#v:[textEncodingName]'>[textEncodingName] </a>  TextEncoding -> String </tt>	a string that can be passed to mkTextEncoding to create an equivalent TextEncoding
<tt style='background-color:#E8E8E8;'> GHC.IO.Encoding <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Encoding.html#v:[mkTextDecoder]'>[mkTextDecoder] </a>  TextEncoding -> IO (TextDecoder dstate) </tt>	Creates a means of decoding bytes into characters: the result must not be shared between several byte sequences or simultaneously across threads
<tt style='background-color:#E8E8E8;'> GHC.IO.Encoding <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Encoding.html#v:[mkTextEncoder]'>[mkTextEncoder] </a>  TextEncoding -> IO (TextEncoder estate) </tt>	Creates a means of encode characters into bytes: the result must not be shared between several character sequences or simultaneously across threads
<tt style='background-color:#E8E8E8;'> GHC.IO.Encoding <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Encoding.html#v:InputUnderflow'>InputUnderflow </a>  CodingProgress </tt>	Stopped because the input contains insufficient available elements, or all of the input sequence has been sucessfully translated
<tt style='background-color:#E8E8E8;'> GHC.IO.Encoding <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Encoding.html#v:OutputUnderflow'>OutputUnderflow </a>  CodingProgress </tt>	Stopped because the output contains insufficient free elements
<tt style='background-color:#E8E8E8;'> GHC.IO.Encoding <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Encoding.html#v:InvalidSequence'>InvalidSequence </a>  CodingProgress </tt>	Stopped because there are sufficient free elements in the output to output at least one encoded ASCII character, but the input contains an invalid or unrepresentable sequence
<tt style='background-color:#E8E8E8;'> GHC.IO.Encoding <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Encoding.html#v:latin1'>latin1 </a>  TextEncoding </tt>	The Latin1 (ISO8859-1) encoding
<tt style='background-color:#E8E8E8;'> GHC.IO.Encoding <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Encoding.html#v:utf8'>utf8 </a>  TextEncoding </tt>	The UTF-8 Unicode encoding
<tt style='background-color:#E8E8E8;'> GHC.IO.Encoding <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Encoding.html#v:utf8_bom'>utf8_bom </a>  TextEncoding </tt>	The UTF-8 Unicode encoding, with a byte-order-mark (BOM; the byte sequence 0xEF 0xBB 0xBF)
<tt style='background-color:#E8E8E8;'> GHC.IO.Encoding <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Encoding.html#v:utf16'>utf16 </a>  TextEncoding </tt>	The UTF-16 Unicode encoding (a byte-order-mark should be used to indicate endianness)
<tt style='background-color:#E8E8E8;'> GHC.IO.Encoding <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Encoding.html#v:utf16le'>utf16le </a>  TextEncoding </tt>	The UTF-16 Unicode encoding (litte-endian)
<tt style='background-color:#E8E8E8;'> GHC.IO.Encoding <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Encoding.html#v:utf16be'>utf16be </a>  TextEncoding </tt>	The UTF-16 Unicode encoding (big-endian)
<tt style='background-color:#E8E8E8;'> GHC.IO.Encoding <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Encoding.html#v:utf32'>utf32 </a>  TextEncoding </tt>	The UTF-32 Unicode encoding (a byte-order-mark should be used to indicate endianness)
<tt style='background-color:#E8E8E8;'> GHC.IO.Encoding <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Encoding.html#v:utf32le'>utf32le </a>  TextEncoding </tt>	The UTF-32 Unicode encoding (litte-endian)
<tt style='background-color:#E8E8E8;'> GHC.IO.Encoding <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Encoding.html#v:utf32be'>utf32be </a>  TextEncoding </tt>	The UTF-32 Unicode encoding (big-endian)
<tt style='background-color:#E8E8E8;'> GHC.IO.Encoding <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Encoding.html#v:getLocaleEncoding'>getLocaleEncoding </a>  IO TextEncoding </tt>	The Unicode encoding of the current locale
<tt style='background-color:#E8E8E8;'> GHC.IO.Encoding <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Encoding.html#v:getFileSystemEncoding'>getFileSystemEncoding </a>  IO TextEncoding </tt>	The Unicode encoding of the current locale, but allowing arbitrary undecodable bytes to be round-tripped through it
<tt style='background-color:#E8E8E8;'> GHC.IO.Encoding <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Encoding.html#v:getForeignEncoding'>getForeignEncoding </a>  IO TextEncoding </tt>	The Unicode encoding of the current locale, but where undecodable bytes are replaced with their closest visual match
<tt style='background-color:#E8E8E8;'> GHC.IO.Encoding <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Encoding.html#v:char8'>char8 </a>  TextEncoding </tt>	An encoding in which Unicode code points are translated to bytes by taking the code point modulo 256
<tt style='background-color:#E8E8E8;'> GHC.IO.Encoding <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Encoding.html#v:mkTextEncoding'>mkTextEncoding </a>  String -> IO TextEncoding </tt>	Look up the named Unicode encoding
<tt style='background-color:#E8E8E8;'> System.IO.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO-Error.html#v:userError'>userError </a>  String -> IOError </tt>	Construct an IOError value with a string describing the error
<tt style='background-color:#E8E8E8;'> System.IO.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO-Error.html#v:mkIOError'>mkIOError </a>  IOErrorType -> String -> Maybe Handle -> Maybe FilePath -> IOError </tt>	Construct an IOError of the given type where the second argument describes the error location and the third and fourth argument contain the file handle and file path of the file involved in the error if applicable
<tt style='background-color:#E8E8E8;'> System.IO.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO-Error.html#v:annotateIOError'>annotateIOError </a>  IOError -> String -> Maybe Handle -> Maybe FilePath -> IOError </tt>	Adds a location description and maybe a file path and file handle to an IOError
<tt style='background-color:#E8E8E8;'> System.IO.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO-Error.html#v:isAlreadyExistsError'>isAlreadyExistsError </a>  IOError -> Bool </tt>	An error indicating that an IO operation failed because one of its arguments already exists
<tt style='background-color:#E8E8E8;'> System.IO.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO-Error.html#v:isDoesNotExistError'>isDoesNotExistError </a>  IOError -> Bool </tt>	An error indicating that an IO operation failed because one of its arguments does not exist
<tt style='background-color:#E8E8E8;'> System.IO.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO-Error.html#v:isAlreadyInUseError'>isAlreadyInUseError </a>  IOError -> Bool </tt>	An error indicating that an IO operation failed because one of its arguments is a single-use resource, which is already being used (for example, opening the same file twice for writing might give this error)
<tt style='background-color:#E8E8E8;'> System.IO.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO-Error.html#v:isFullError'>isFullError </a>  IOError -> Bool </tt>	An error indicating that an IO operation failed because the device is full
<tt style='background-color:#E8E8E8;'> System.IO.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO-Error.html#v:isEOFError'>isEOFError </a>  IOError -> Bool </tt>	An error indicating that an IO operation failed because the end of file has been reached
<tt style='background-color:#E8E8E8;'> System.IO.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO-Error.html#v:isIllegalOperation'>isIllegalOperation </a>  IOError -> Bool </tt>	An error indicating that an IO operation failed because the operation was not possible
<tt style='background-color:#E8E8E8;'> System.IO.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO-Error.html#v:isPermissionError'>isPermissionError </a>  IOError -> Bool </tt>	An error indicating that an IO operation failed because the user does not have sufficient operating system privilege to perform that operation
<tt style='background-color:#E8E8E8;'> System.IO.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO-Error.html#v:isUserError'>isUserError </a>  IOError -> Bool </tt>	A programmer-defined error value constructed using userError
<tt style='background-color:#E8E8E8;'> System.IO.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO-Error.html#v:alreadyExistsErrorType'>alreadyExistsErrorType </a>  IOErrorType </tt>	I/O error where the operation failed because one of its arguments already exists
<tt style='background-color:#E8E8E8;'> System.IO.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO-Error.html#v:doesNotExistErrorType'>doesNotExistErrorType </a>  IOErrorType </tt>	I/O error where the operation failed because one of its arguments does not exist
<tt style='background-color:#E8E8E8;'> System.IO.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO-Error.html#v:alreadyInUseErrorType'>alreadyInUseErrorType </a>  IOErrorType </tt>	I/O error where the operation failed because one of its arguments is a single-use resource, which is already being used
<tt style='background-color:#E8E8E8;'> System.IO.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO-Error.html#v:fullErrorType'>fullErrorType </a>  IOErrorType </tt>	I/O error where the operation failed because the device is full
<tt style='background-color:#E8E8E8;'> System.IO.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO-Error.html#v:eofErrorType'>eofErrorType </a>  IOErrorType </tt>	I/O error where the operation failed because the end of file has been reached
<tt style='background-color:#E8E8E8;'> System.IO.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO-Error.html#v:illegalOperationErrorType'>illegalOperationErrorType </a>  IOErrorType </tt>	I/O error where the operation is not possible
<tt style='background-color:#E8E8E8;'> System.IO.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO-Error.html#v:permissionErrorType'>permissionErrorType </a>  IOErrorType </tt>	I/O error where the operation failed because the user does not have sufficient operating system privilege to perform that operation
<tt style='background-color:#E8E8E8;'> System.IO.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO-Error.html#v:userErrorType'>userErrorType </a>  IOErrorType </tt>	I/O error that is programmer-defined
<tt style='background-color:#E8E8E8;'> System.IO.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO-Error.html#v:isAlreadyExistsErrorType'>isAlreadyExistsErrorType </a>  IOErrorType -> Bool </tt>	I/O error where the operation failed because one of its arguments already exists
<tt style='background-color:#E8E8E8;'> System.IO.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO-Error.html#v:isDoesNotExistErrorType'>isDoesNotExistErrorType </a>  IOErrorType -> Bool </tt>	I/O error where the operation failed because one of its arguments does not exist
<tt style='background-color:#E8E8E8;'> System.IO.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO-Error.html#v:isAlreadyInUseErrorType'>isAlreadyInUseErrorType </a>  IOErrorType -> Bool </tt>	I/O error where the operation failed because one of its arguments is a single-use resource, which is already being used
<tt style='background-color:#E8E8E8;'> System.IO.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO-Error.html#v:isFullErrorType'>isFullErrorType </a>  IOErrorType -> Bool </tt>	I/O error where the operation failed because the device is full
<tt style='background-color:#E8E8E8;'> System.IO.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO-Error.html#v:isEOFErrorType'>isEOFErrorType </a>  IOErrorType -> Bool </tt>	I/O error where the operation failed because the end of file has been reached
<tt style='background-color:#E8E8E8;'> System.IO.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO-Error.html#v:isIllegalOperationErrorType'>isIllegalOperationErrorType </a>  IOErrorType -> Bool </tt>	I/O error where the operation is not possible
<tt style='background-color:#E8E8E8;'> System.IO.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO-Error.html#v:isPermissionErrorType'>isPermissionErrorType </a>  IOErrorType -> Bool </tt>	I/O error where the operation failed because the user does not have sufficient operating system privilege to perform that operation
<tt style='background-color:#E8E8E8;'> System.IO.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO-Error.html#v:isUserErrorType'>isUserErrorType </a>  IOErrorType -> Bool </tt>	I/O error that is programmer-defined
<tt style='background-color:#E8E8E8;'> System.IO.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO-Error.html#v:ioError'>ioError </a>  IOError -> IO a </tt>	Raise an IOError in the IO monad
<tt style='background-color:#E8E8E8;'> System.IO.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO-Error.html#v:catchIOError'>catchIOError </a>  IO a -> (IOError -> IO a) -> IO a </tt>	The catchIOError function establishes a handler that receives any IOError raised in the action protected by catchIOError
<tt style='background-color:#E8E8E8;'> System.IO.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO-Error.html#v:tryIOError'>tryIOError </a>  IO a -> IO (Either IOError a) </tt>	The construct tryIOError comp exposes IO errors which occur within a computation, and which are not fully handled
<tt style='background-color:#E8E8E8;'> System.IO.Error <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO-Error.html#v:modifyIOError'>modifyIOError </a>  (IOError -> IOError) -> IO a -> IO a </tt>	Catch any IOError that occurs in the computation and throw a modified version
<tt style='background-color:#E8E8E8;'> GHC.Conc.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc-IO.html#v:ensureIOManagerIsRunning'>ensureIOManagerIsRunning </a>  IO () </tt>	Basic concurrency stuff
<tt style='background-color:#E8E8E8;'> GHC.Conc.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc-IO.html#v:threadDelay'>threadDelay </a>  Int -> IO () </tt>	Suspends the current thread for a given number of microseconds (GHC only)
<tt style='background-color:#E8E8E8;'> GHC.Conc.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc-IO.html#v:registerDelay'>registerDelay </a>  Int -> IO (TVar Bool) </tt>	Set the value of returned TVar to True after a given number of microseconds
<tt style='background-color:#E8E8E8;'> GHC.Conc.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc-IO.html#v:threadWaitRead'>threadWaitRead </a>  Fd -> IO () </tt>	Block the current thread until data is available to read on the given file descriptor (GHC only)
<tt style='background-color:#E8E8E8;'> GHC.Conc.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc-IO.html#v:threadWaitWrite'>threadWaitWrite </a>  Fd -> IO () </tt>	Block the current thread until data can be written to the given file descriptor (GHC only)
<tt style='background-color:#E8E8E8;'> GHC.Conc.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc-IO.html#v:threadWaitReadSTM'>threadWaitReadSTM </a>  Fd -> IO (STM (), IO ()) </tt>	Returns an STM action that can be used to wait for data to read from a file descriptor
<tt style='background-color:#E8E8E8;'> GHC.Conc.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc-IO.html#v:threadWaitWriteSTM'>threadWaitWriteSTM </a>  Fd -> IO (STM (), IO ()) </tt>	Returns an STM action that can be used to wait until data can be written to a file descriptor
<tt style='background-color:#E8E8E8;'> GHC.Conc.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc-IO.html#v:closeFdWith'>closeFdWith </a>  (Fd -> IO ()) -> Fd -> IO () </tt>	Close a file descriptor in a concurrency-safe way (GHC only)
<tt style='background-color:#E8E8E8;'> GHC.Conc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc.html#v:ThreadId'>ThreadId </a>  ThreadId# -> ThreadId </tt>	A ThreadId is an abstract type representing a handle to a thread
<tt style='background-color:#E8E8E8;'> GHC.Conc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc.html#v:forkIO'>forkIO </a>  IO () -> IO ThreadId </tt>	Creates a new thread to run the IO computation passed as the first argument, and returns the ThreadId of the newly created thread
<tt style='background-color:#E8E8E8;'> GHC.Conc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc.html#v:forkOn'>forkOn </a>  Int -> IO () -> IO ThreadId </tt>	Like forkIO, but lets you specify on which capability the thread should run
<tt style='background-color:#E8E8E8;'> GHC.Conc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc.html#v:numCapabilities'>numCapabilities </a>  Int </tt>	the value passed to the +RTS -N flag
<tt style='background-color:#E8E8E8;'> GHC.Conc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc.html#v:getNumCapabilities'>getNumCapabilities </a>  IO Int </tt>	Returns the number of Haskell threads that can run truly simultaneously (on separate physical processors) at any given time
<tt style='background-color:#E8E8E8;'> GHC.Conc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc.html#v:setNumCapabilities'>setNumCapabilities </a>  Int -> IO () </tt>	Set the number of Haskell threads that can run truly simultaneously (on separate physical processors) at any given time
<tt style='background-color:#E8E8E8;'> GHC.Conc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc.html#v:getNumProcessors'>getNumProcessors </a>  IO Int </tt>	Returns the number of CPUs that the machine has
<tt style='background-color:#E8E8E8;'> GHC.Conc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc.html#v:numSparks'>numSparks </a>  IO Int </tt>	Returns the number of sparks currently in the local spark pool
<tt style='background-color:#E8E8E8;'> GHC.Conc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc.html#v:myThreadId'>myThreadId </a>  IO ThreadId </tt>	Returns the ThreadId of the calling thread (GHC only)
<tt style='background-color:#E8E8E8;'> GHC.Conc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc.html#v:killThread'>killThread </a>  ThreadId -> IO () </tt>	killThread raises the ThreadKilled exception in the given thread (GHC only)
<tt style='background-color:#E8E8E8;'> GHC.Conc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc.html#v:throwTo'>throwTo </a>  Exception e => ThreadId -> e -> IO () </tt>	throwTo raises an arbitrary exception in the target thread (GHC only)
<tt style='background-color:#E8E8E8;'> GHC.Conc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc.html#v:runSparks'>runSparks </a>  IO () </tt>	Internal function used by the RTS to run sparks
<tt style='background-color:#E8E8E8;'> GHC.Conc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc.html#v:yield'>yield </a>  IO () </tt>	The yield action allows (forces, in a co-operative multitasking implementation) a context-switch to any other currently runnable threads (if any), and is occasionally useful when implementing concurrency abstractions
<tt style='background-color:#E8E8E8;'> GHC.Conc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc.html#v:labelThread'>labelThread </a>  ThreadId -> String -> IO () </tt>	labelThread stores a string as identifier for this thread if you built a RTS with debugging support
<tt style='background-color:#E8E8E8;'> GHC.Conc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc.html#v:mkWeakThreadId'>mkWeakThreadId </a>  ThreadId -> IO (Weak ThreadId) </tt>	make a weak pointer to a ThreadId
<tt style='background-color:#E8E8E8;'> GHC.Conc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc.html#v:ThreadRunning'>ThreadRunning </a>  ThreadStatus </tt>	the thread is currently runnable or running
<tt style='background-color:#E8E8E8;'> GHC.Conc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc.html#v:ThreadFinished'>ThreadFinished </a>  ThreadStatus </tt>	the thread has finished
<tt style='background-color:#E8E8E8;'> GHC.Conc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc.html#v:ThreadBlocked'>ThreadBlocked </a>  BlockReason -> ThreadStatus </tt>	the thread is blocked on some resource
<tt style='background-color:#E8E8E8;'> GHC.Conc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc.html#v:ThreadDied'>ThreadDied </a>  ThreadStatus </tt>	the thread received an uncaught exception
<tt style='background-color:#E8E8E8;'> GHC.Conc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc.html#v:BlockedOnMVar'>BlockedOnMVar </a>  BlockReason </tt>	blocked on MVar
<tt style='background-color:#E8E8E8;'> GHC.Conc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc.html#v:BlockedOnBlackHole'>BlockedOnBlackHole </a>  BlockReason </tt>	blocked on a computation in progress by another thread
<tt style='background-color:#E8E8E8;'> GHC.Conc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc.html#v:BlockedOnException'>BlockedOnException </a>  BlockReason </tt>	blocked in throwTo
<tt style='background-color:#E8E8E8;'> GHC.Conc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc.html#v:BlockedOnSTM'>BlockedOnSTM </a>  BlockReason </tt>	blocked in retry in an STM transaction
<tt style='background-color:#E8E8E8;'> GHC.Conc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc.html#v:BlockedOnForeignCall'>BlockedOnForeignCall </a>  BlockReason </tt>	currently in a foreign call
<tt style='background-color:#E8E8E8;'> GHC.Conc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc.html#v:BlockedOnOther'>BlockedOnOther </a>  BlockReason </tt>	blocked on some other resource
<tt style='background-color:#E8E8E8;'> GHC.Conc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc.html#v:threadCapability'>threadCapability </a>  ThreadId -> IO (Int, Bool) </tt>	returns the number of the capability on which the thread is currently running, and a boolean indicating whether the thread is locked to that capability or not
<tt style='background-color:#E8E8E8;'> GHC.Conc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc.html#v:threadDelay'>threadDelay </a>  Int -> IO () </tt>	Suspends the current thread for a given number of microseconds (GHC only)
<tt style='background-color:#E8E8E8;'> GHC.Conc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc.html#v:registerDelay'>registerDelay </a>  Int -> IO (TVar Bool) </tt>	Set the value of returned TVar to True after a given number of microseconds
<tt style='background-color:#E8E8E8;'> GHC.Conc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc.html#v:threadWaitRead'>threadWaitRead </a>  Fd -> IO () </tt>	Block the current thread until data is available to read on the given file descriptor (GHC only)
<tt style='background-color:#E8E8E8;'> GHC.Conc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc.html#v:threadWaitWrite'>threadWaitWrite </a>  Fd -> IO () </tt>	Block the current thread until data can be written to the given file descriptor (GHC only)
<tt style='background-color:#E8E8E8;'> GHC.Conc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc.html#v:threadWaitReadSTM'>threadWaitReadSTM </a>  Fd -> IO (STM (), IO ()) </tt>	Returns an STM action that can be used to wait for data to read from a file descriptor
<tt style='background-color:#E8E8E8;'> GHC.Conc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc.html#v:threadWaitWriteSTM'>threadWaitWriteSTM </a>  Fd -> IO (STM (), IO ()) </tt>	Returns an STM action that can be used to wait until data can be written to a file descriptor
<tt style='background-color:#E8E8E8;'> GHC.Conc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc.html#v:closeFdWith'>closeFdWith </a>  (Fd -> IO ()) -> Fd -> IO () </tt>	Close a file descriptor in a concurrency-safe way (GHC only)
<tt style='background-color:#E8E8E8;'> GHC.Conc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc.html#v:setAllocationCounter'>setAllocationCounter </a>  Int64 -> IO () </tt>	Every thread has an allocation counter that tracks how much memory has been allocated by the thread
<tt style='background-color:#E8E8E8;'> GHC.Conc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc.html#v:getAllocationCounter'>getAllocationCounter </a>  IO Int64 </tt>	Return the current value of the allocation counter for the current thread
<tt style='background-color:#E8E8E8;'> GHC.Conc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc.html#v:enableAllocationLimit'>enableAllocationLimit </a>  IO () </tt>	Enables the allocation counter to be treated as a limit for the current thread
<tt style='background-color:#E8E8E8;'> GHC.Conc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc.html#v:disableAllocationLimit'>disableAllocationLimit </a>  IO () </tt>	Disable allocation limit processing for the current thread
<tt style='background-color:#E8E8E8;'> GHC.Conc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc.html#v:STM'>STM </a>  (State# RealWorld -> (# State# RealWorld, a #)) -> STM a </tt>	A monad supporting atomic memory transactions
<tt style='background-color:#E8E8E8;'> GHC.Conc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc.html#v:atomically'>atomically </a>  STM a -> IO a </tt>	Perform a series of STM actions atomically
<tt style='background-color:#E8E8E8;'> GHC.Conc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc.html#v:retry'>retry </a>  STM a </tt>	Retry execution of the current memory transaction because it has seen values in TVars which mean that it should not continue (e
<tt style='background-color:#E8E8E8;'> GHC.Conc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc.html#v:orElse'>orElse </a>  STM a -> STM a -> STM a </tt>	Compose two alternative STM actions (GHC only)
<tt style='background-color:#E8E8E8;'> GHC.Conc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc.html#v:throwSTM'>throwSTM </a>  Exception e => e -> STM a </tt>	A variant of throw that can only be used within the STM monad
<tt style='background-color:#E8E8E8;'> GHC.Conc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc.html#v:catchSTM'>catchSTM </a>  Exception e => STM a -> (e -> STM a) -> STM a </tt>	Exception handling within STM actions
<tt style='background-color:#E8E8E8;'> GHC.Conc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc.html#v:alwaysSucceeds'>alwaysSucceeds </a>  STM a -> STM () </tt>	alwaysSucceeds adds a new invariant that must be true when passed to alwaysSucceeds, at the end of the current transaction, and at the end of every subsequent transaction
<tt style='background-color:#E8E8E8;'> GHC.Conc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc.html#v:always'>always </a>  STM Bool -> STM () </tt>	always is a variant of alwaysSucceeds in which the invariant is expressed as an STM Bool action that must return True
<tt style='background-color:#E8E8E8;'> GHC.Conc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc.html#v:TVar'>TVar </a>  (TVar# RealWorld a) -> TVar a </tt>	Shared memory locations that support atomic memory transactions
<tt style='background-color:#E8E8E8;'> GHC.Conc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc.html#v:newTVar'>newTVar </a>  a -> STM (TVar a) </tt>	Create a new TVar holding a value supplied
<tt style='background-color:#E8E8E8;'> GHC.Conc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc.html#v:newTVarIO'>newTVarIO </a>  a -> IO (TVar a) </tt>	IO version of newTVar
<tt style='background-color:#E8E8E8;'> GHC.Conc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc.html#v:readTVar'>readTVar </a>  TVar a -> STM a </tt>	Return the current value stored in a TVar
<tt style='background-color:#E8E8E8;'> GHC.Conc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc.html#v:readTVarIO'>readTVarIO </a>  TVar a -> IO a </tt>	Return the current value stored in a TVar
<tt style='background-color:#E8E8E8;'> GHC.Conc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc.html#v:writeTVar'>writeTVar </a>  TVar a -> a -> STM () </tt>	Write the supplied value into a TVar
<tt style='background-color:#E8E8E8;'> GHC.Conc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc.html#v:unsafeIOToSTM'>unsafeIOToSTM </a>  IO a -> STM a </tt>	Unsafely performs IO in the STM monad
<tt style='background-color:#E8E8E8;'> GHC.IO.Handle <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle.html#v:NoBuffering'>NoBuffering </a>  BufferMode </tt>	buffering is disabled if possible
<tt style='background-color:#E8E8E8;'> GHC.IO.Handle <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle.html#v:LineBuffering'>LineBuffering </a>  BufferMode </tt>	line-buffering should be enabled if possible
<tt style='background-color:#E8E8E8;'> GHC.IO.Handle <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle.html#v:BlockBuffering'>BlockBuffering </a>  (Maybe Int) -> BufferMode </tt>	block-buffering should be enabled if possible
<tt style='background-color:#E8E8E8;'> GHC.IO.Handle <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle.html#v:mkFileHandle'>mkFileHandle </a>  (IODevice dev, BufferedIO dev, Typeable dev) => dev -> FilePath -> IOMode -> Maybe TextEncoding -> NewlineMode -> IO Handle </tt>	makes a new Handle
<tt style='background-color:#E8E8E8;'> GHC.IO.Handle <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle.html#v:mkDuplexHandle'>mkDuplexHandle </a>  (IODevice dev, BufferedIO dev, Typeable dev) => dev -> FilePath -> Maybe TextEncoding -> NewlineMode -> IO Handle </tt>	like mkFileHandle, except that a Handle is created with two independent buffers, one for reading and one for writing
<tt style='background-color:#E8E8E8;'> GHC.IO.Handle <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle.html#v:hFileSize'>hFileSize </a>  Handle -> IO Integer </tt>	For a handle hdl which attached to a physical file, hFileSize hdl returns the size of that file in 8-bit bytes
<tt style='background-color:#E8E8E8;'> GHC.IO.Handle <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle.html#v:hSetFileSize'>hSetFileSize </a>  Handle -> Integer -> IO () </tt>	hSetFileSize hdl size truncates the physical file with handle hdl to size bytes
<tt style='background-color:#E8E8E8;'> GHC.IO.Handle <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle.html#v:hIsEOF'>hIsEOF </a>  Handle -> IO Bool </tt>	For a readable handle hdl, hIsEOF hdl returns True if no further input can be taken from hdl or for a physical file, if the current I/O position is equal to the length of the file
<tt style='background-color:#E8E8E8;'> GHC.IO.Handle <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle.html#v:hLookAhead'>hLookAhead </a>  Handle -> IO Char </tt>	Computation hLookAhead returns the next character from the handle without removing it from the input buffer, blocking until a character is available
<tt style='background-color:#E8E8E8;'> GHC.IO.Handle <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle.html#v:hSetBuffering'>hSetBuffering </a>  Handle -> BufferMode -> IO () </tt>	Computation hSetBuffering hdl mode sets the mode of buffering for handle hdl on subsequent reads and writes
<tt style='background-color:#E8E8E8;'> GHC.IO.Handle <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle.html#v:hSetBinaryMode'>hSetBinaryMode </a>  Handle -> Bool -> IO () </tt>	Select binary mode (True) or text mode (False) on a open handle
<tt style='background-color:#E8E8E8;'> GHC.IO.Handle <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle.html#v:hSetEncoding'>hSetEncoding </a>  Handle -> TextEncoding -> IO () </tt>	The action hSetEncoding hdl encoding changes the text encoding for the handle hdl to encoding
<tt style='background-color:#E8E8E8;'> GHC.IO.Handle <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle.html#v:hGetEncoding'>hGetEncoding </a>  Handle -> IO (Maybe TextEncoding) </tt>	Return the current TextEncoding for the specified Handle, or Nothing if the Handle is in binary mode
<tt style='background-color:#E8E8E8;'> GHC.IO.Handle <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle.html#v:hFlush'>hFlush </a>  Handle -> IO () </tt>	The action hFlush hdl causes any items buffered for output in handle hdl to be sent immediately to the operating system
<tt style='background-color:#E8E8E8;'> GHC.IO.Handle <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle.html#v:hFlushAll'>hFlushAll </a>  Handle -> IO () </tt>	The action hFlushAll hdl flushes all buffered data in hdl, including any buffered read data
<tt style='background-color:#E8E8E8;'> GHC.IO.Handle <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle.html#v:hDuplicate'>hDuplicate </a>  Handle -> IO Handle </tt>	Returns a duplicate of the original handle, with its own buffer
<tt style='background-color:#E8E8E8;'> GHC.IO.Handle <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle.html#v:hDuplicateTo'>hDuplicateTo </a>  Handle -> Handle -> IO () </tt>	Makes the second handle a duplicate of the first handle
<tt style='background-color:#E8E8E8;'> GHC.IO.Handle <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle.html#v:hClose'>hClose </a>  Handle -> IO () </tt>	Computation hClose hdl makes handle hdl closed
<tt style='background-color:#E8E8E8;'> GHC.IO.Handle <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle.html#v:hGetPosn'>hGetPosn </a>  Handle -> IO HandlePosn </tt>	Computation hGetPosn hdl returns the current I/O position of hdl as a value of the abstract type HandlePosn
<tt style='background-color:#E8E8E8;'> GHC.IO.Handle <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle.html#v:hSetPosn'>hSetPosn </a>  HandlePosn -> IO () </tt>	If a call to hGetPosn hdl returns a position p, then computation hSetPosn p sets the position of hdl to the position it held at the time of the call to hGetPosn
<tt style='background-color:#E8E8E8;'> GHC.IO.Handle <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle.html#v:AbsoluteSeek'>AbsoluteSeek </a>  SeekMode </tt>	the position of hdl is set to i
<tt style='background-color:#E8E8E8;'> GHC.IO.Handle <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle.html#v:RelativeSeek'>RelativeSeek </a>  SeekMode </tt>	the position of hdl is set to offset i from the current position
<tt style='background-color:#E8E8E8;'> GHC.IO.Handle <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle.html#v:SeekFromEnd'>SeekFromEnd </a>  SeekMode </tt>	the position of hdl is set to offset i from the end of the file
<tt style='background-color:#E8E8E8;'> GHC.IO.Handle <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle.html#v:hSeek'>hSeek </a>  Handle -> SeekMode -> Integer -> IO () </tt>	Computation hSeek hdl mode i sets the position of handle hdl depending on mode
<tt style='background-color:#E8E8E8;'> GHC.IO.Handle <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle.html#v:hTell'>hTell </a>  Handle -> IO Integer </tt>	Computation hTell hdl returns the current position of the handle hdl, as the number of bytes from the beginning of the file
<tt style='background-color:#E8E8E8;'> GHC.IO.Handle <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle.html#v:hGetBuffering'>hGetBuffering </a>  Handle -> IO BufferMode </tt>	Computation hGetBuffering hdl returns the current buffering mode for hdl
<tt style='background-color:#E8E8E8;'> GHC.IO.Handle <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle.html#v:hSetEcho'>hSetEcho </a>  Handle -> Bool -> IO () </tt>	Set the echoing status of a handle connected to a terminal
<tt style='background-color:#E8E8E8;'> GHC.IO.Handle <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle.html#v:hGetEcho'>hGetEcho </a>  Handle -> IO Bool </tt>	Get the echoing status of a handle connected to a terminal
<tt style='background-color:#E8E8E8;'> GHC.IO.Handle <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle.html#v:hIsTerminalDevice'>hIsTerminalDevice </a>  Handle -> IO Bool </tt>	Is the handle connected to a terminal?
<tt style='background-color:#E8E8E8;'> GHC.IO.Handle <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle.html#v:hSetNewlineMode'>hSetNewlineMode </a>  Handle -> NewlineMode -> IO () </tt>	Set the NewlineMode on the specified Handle
<tt style='background-color:#E8E8E8;'> GHC.IO.Handle <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle.html#v:NewlineMode'>NewlineMode </a>  Newline -> Newline -> NewlineMode </tt>	Specifies the translation, if any, of newline characters between internal Strings and the external file or stream
<tt style='background-color:#E8E8E8;'> GHC.IO.Handle <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle.html#v:[inputNL]'>[inputNL] </a>  NewlineMode -> Newline </tt>	the representation of newlines on input
<tt style='background-color:#E8E8E8;'> GHC.IO.Handle <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle.html#v:[outputNL]'>[outputNL] </a>  NewlineMode -> Newline </tt>	the representation of newlines on output
<tt style='background-color:#E8E8E8;'> GHC.IO.Handle <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle.html#v:nativeNewline'>nativeNewline </a>  Newline </tt>	The native newline representation for the current platform: LF on Unix systems, CRLF on Windows
<tt style='background-color:#E8E8E8;'> GHC.IO.Handle <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle.html#v:noNewlineTranslation'>noNewlineTranslation </a>  NewlineMode </tt>	Do no newline translation at all
<tt style='background-color:#E8E8E8;'> GHC.IO.Handle <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle.html#v:universalNewlineMode'>universalNewlineMode </a>  NewlineMode </tt>	Map '\r\n' into '\n' on input, and '\n' to the native newline represetnation on output
<tt style='background-color:#E8E8E8;'> GHC.IO.Handle <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle.html#v:nativeNewlineMode'>nativeNewlineMode </a>  NewlineMode </tt>	Use the native newline representation on both input and output   nativeNewlineMode  = NewlineMode { inputNL  = nativeNewline outputNL = nativeNewline }
<tt style='background-color:#E8E8E8;'> GHC.IO.Handle <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle.html#v:hShow'>hShow </a>  Handle -> IO String </tt>	hShow is in the IO monad, and gives more comprehensive output than the (pure) instance of Show for Handle
<tt style='background-color:#E8E8E8;'> GHC.IO.Handle <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle.html#v:hWaitForInput'>hWaitForInput </a>  Handle -> Int -> IO Bool </tt>	Computation hWaitForInput hdl t waits until input is available on handle hdl
<tt style='background-color:#E8E8E8;'> GHC.IO.Handle <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle.html#v:hGetChar'>hGetChar </a>  Handle -> IO Char </tt>	Computation hGetChar hdl reads a character from the file or channel managed by hdl, blocking until a character is available
<tt style='background-color:#E8E8E8;'> GHC.IO.Handle <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle.html#v:hGetLine'>hGetLine </a>  Handle -> IO String </tt>	Computation hGetLine hdl reads a line from the file or channel managed by hdl
<tt style='background-color:#E8E8E8;'> GHC.IO.Handle <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle.html#v:hGetContents'>hGetContents </a>  Handle -> IO String </tt>	Computation hGetContents hdl returns the list of characters corresponding to the unread portion of the channel or file managed by hdl, which is put into an intermediate state, semi-closed
<tt style='background-color:#E8E8E8;'> GHC.IO.Handle <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle.html#v:hPutChar'>hPutChar </a>  Handle -> Char -> IO () </tt>	Computation hPutChar hdl ch writes the character ch to the file or channel managed by hdl
<tt style='background-color:#E8E8E8;'> GHC.IO.Handle <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle.html#v:hPutStr'>hPutStr </a>  Handle -> String -> IO () </tt>	Computation hPutStr hdl s writes the string s to the file or channel managed by hdl
<tt style='background-color:#E8E8E8;'> GHC.IO.Handle <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle.html#v:hGetBuf'>hGetBuf </a>  Handle -> Ptr a -> Int -> IO Int </tt>	hGetBuf hdl buf count reads data from the handle hdl into the buffer buf until either EOF is reached or count 8-bit bytes have been read
<tt style='background-color:#E8E8E8;'> GHC.IO.Handle <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle.html#v:hGetBufNonBlocking'>hGetBufNonBlocking </a>  Handle -> Ptr a -> Int -> IO Int </tt>	hGetBufNonBlocking hdl buf count reads data from the handle hdl into the buffer buf until either EOF is reached, or count 8-bit bytes have been read, or there is no more data available to read immediately
<tt style='background-color:#E8E8E8;'> GHC.IO.Handle <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle.html#v:hPutBuf'>hPutBuf </a>  Handle -> Ptr a -> Int -> IO () </tt>	hPutBuf hdl buf count writes count 8-bit bytes from the buffer buf to the handle hdl
<tt style='background-color:#E8E8E8;'> GHC.IO.Handle.FD <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle-FD.html#v:stdin'>stdin </a>  Handle </tt>	A handle managing input from the Haskell program's standard input channel
<tt style='background-color:#E8E8E8;'> GHC.IO.Handle.FD <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle-FD.html#v:stdout'>stdout </a>  Handle </tt>	A handle managing output to the Haskell program's standard output channel
<tt style='background-color:#E8E8E8;'> GHC.IO.Handle.FD <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle-FD.html#v:stderr'>stderr </a>  Handle </tt>	A handle managing output to the Haskell program's standard error channel
<tt style='background-color:#E8E8E8;'> GHC.IO.Handle.FD <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle-FD.html#v:openFile'>openFile </a>  FilePath -> IOMode -> IO Handle </tt>	Computation openFile file mode allocates and returns a new, open handle to manage the file file
<tt style='background-color:#E8E8E8;'> GHC.IO.Handle.FD <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle-FD.html#v:openBinaryFile'>openBinaryFile </a>  FilePath -> IOMode -> IO Handle </tt>	Like openFile, but open the file in binary mode
<tt style='background-color:#E8E8E8;'> GHC.IO.Handle.FD <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle-FD.html#v:openFileBlocking'>openFileBlocking </a>  FilePath -> IOMode -> IO Handle </tt>	Like openFile, but opens the file in ordinary blocking mode
<tt style='background-color:#E8E8E8;'> GHC.IO.Handle.FD <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle-FD.html#v:fdToHandle'>fdToHandle </a>  FD -> IO Handle </tt>	Turn an existing file descriptor into a Handle
<tt style='background-color:#E8E8E8;'> GHC.IO.Handle.FD <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle-FD.html#v:fdToHandle''>fdToHandle' </a>  CInt -> Maybe IODeviceType -> Bool -> FilePath -> IOMode -> Bool -> IO Handle </tt>	Old API kept to avoid breaking clients
<tt style='background-color:#E8E8E8;'> GHC.IO.Handle.FD <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IO-Handle-FD.html#v:isEOF'>isEOF </a>  IO Bool </tt>	The computation isEOF is identical to hIsEOF, except that it works only on stdin
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:fixIO'>fixIO </a>  (a -> IO a) -> IO a </tt>	A value of type IO a is a computation which, when performed, does some I/O before returning a value of type a
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:stdin'>stdin </a>  Handle </tt>	A handle managing input from the Haskell program's standard input channel
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:stdout'>stdout </a>  Handle </tt>	A handle managing output to the Haskell program's standard output channel
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:stderr'>stderr </a>  Handle </tt>	A handle managing output to the Haskell program's standard error channel
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:withFile'>withFile </a>  FilePath -> IOMode -> (Handle -> IO r) -> IO r </tt>	withFile name mode act opens a file using openFile and passes the resulting handle to the computation act
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:openFile'>openFile </a>  FilePath -> IOMode -> IO Handle </tt>	Computation openFile file mode allocates and returns a new, open handle to manage the file file
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:ReadMode'>ReadMode </a>  IOMode </tt>	See openFile
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:hClose'>hClose </a>  Handle -> IO () </tt>	Computation hClose hdl makes handle hdl closed
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:readFile'>readFile </a>  FilePath -> IO String </tt>	The readFile function reads a file and returns the contents of the file as a string
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:writeFile'>writeFile </a>  FilePath -> String -> IO () </tt>	The computation writeFile file str function writes the string str, to the file file
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:appendFile'>appendFile </a>  FilePath -> String -> IO () </tt>	The computation appendFile file str function appends the string str, to the file file
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:hFileSize'>hFileSize </a>  Handle -> IO Integer </tt>	For a handle hdl which attached to a physical file, hFileSize hdl returns the size of that file in 8-bit bytes
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:hSetFileSize'>hSetFileSize </a>  Handle -> Integer -> IO () </tt>	hSetFileSize hdl size truncates the physical file with handle hdl to size bytes
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:hIsEOF'>hIsEOF </a>  Handle -> IO Bool </tt>	For a readable handle hdl, hIsEOF hdl returns True if no further input can be taken from hdl or for a physical file, if the current I/O position is equal to the length of the file
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:isEOF'>isEOF </a>  IO Bool </tt>	The computation isEOF is identical to hIsEOF, except that it works only on stdin
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:NoBuffering'>NoBuffering </a>  BufferMode </tt>	buffering is disabled if possible
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:LineBuffering'>LineBuffering </a>  BufferMode </tt>	line-buffering should be enabled if possible
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:BlockBuffering'>BlockBuffering </a>  (Maybe Int) -> BufferMode </tt>	block-buffering should be enabled if possible
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:hSetBuffering'>hSetBuffering </a>  Handle -> BufferMode -> IO () </tt>	Computation hSetBuffering hdl mode sets the mode of buffering for handle hdl on subsequent reads and writes
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:hGetBuffering'>hGetBuffering </a>  Handle -> IO BufferMode </tt>	Computation hGetBuffering hdl returns the current buffering mode for hdl
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:hFlush'>hFlush </a>  Handle -> IO () </tt>	The action hFlush hdl causes any items buffered for output in handle hdl to be sent immediately to the operating system
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:hGetPosn'>hGetPosn </a>  Handle -> IO HandlePosn </tt>	Computation hGetPosn hdl returns the current I/O position of hdl as a value of the abstract type HandlePosn
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:hSetPosn'>hSetPosn </a>  HandlePosn -> IO () </tt>	If a call to hGetPosn hdl returns a position p, then computation hSetPosn p sets the position of hdl to the position it held at the time of the call to hGetPosn
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:hSeek'>hSeek </a>  Handle -> SeekMode -> Integer -> IO () </tt>	Computation hSeek hdl mode i sets the position of handle hdl depending on mode
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:AbsoluteSeek'>AbsoluteSeek </a>  SeekMode </tt>	the position of hdl is set to i
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:RelativeSeek'>RelativeSeek </a>  SeekMode </tt>	the position of hdl is set to offset i from the current position
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:SeekFromEnd'>SeekFromEnd </a>  SeekMode </tt>	the position of hdl is set to offset i from the end of the file
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:hTell'>hTell </a>  Handle -> IO Integer </tt>	Computation hTell hdl returns the current position of the handle hdl, as the number of bytes from the beginning of the file
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:hIsTerminalDevice'>hIsTerminalDevice </a>  Handle -> IO Bool </tt>	Is the handle connected to a terminal?
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:hSetEcho'>hSetEcho </a>  Handle -> Bool -> IO () </tt>	Set the echoing status of a handle connected to a terminal
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:hGetEcho'>hGetEcho </a>  Handle -> IO Bool </tt>	Get the echoing status of a handle connected to a terminal
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:hShow'>hShow </a>  Handle -> IO String </tt>	hShow is in the IO monad, and gives more comprehensive output than the (pure) instance of Show for Handle
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:hWaitForInput'>hWaitForInput </a>  Handle -> Int -> IO Bool </tt>	Computation hWaitForInput hdl t waits until input is available on handle hdl
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:hReady'>hReady </a>  Handle -> IO Bool </tt>	Computation hReady hdl indicates whether at least one item is available for input from handle hdl
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:hGetChar'>hGetChar </a>  Handle -> IO Char </tt>	Computation hGetChar hdl reads a character from the file or channel managed by hdl, blocking until a character is available
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:hGetLine'>hGetLine </a>  Handle -> IO String </tt>	Computation hGetLine hdl reads a line from the file or channel managed by hdl
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:hLookAhead'>hLookAhead </a>  Handle -> IO Char </tt>	Computation hLookAhead returns the next character from the handle without removing it from the input buffer, blocking until a character is available
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:hGetContents'>hGetContents </a>  Handle -> IO String </tt>	Computation hGetContents hdl returns the list of characters corresponding to the unread portion of the channel or file managed by hdl, which is put into an intermediate state, semi-closed
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:hPutChar'>hPutChar </a>  Handle -> Char -> IO () </tt>	Computation hPutChar hdl ch writes the character ch to the file or channel managed by hdl
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:hPutStr'>hPutStr </a>  Handle -> String -> IO () </tt>	Computation hPutStr hdl s writes the string s to the file or channel managed by hdl
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:hPutStrLn'>hPutStrLn </a>  Handle -> String -> IO () </tt>	The same as hPutStr, but adds a newline character
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:hPrint'>hPrint </a>  Show a => Handle -> a -> IO () </tt>	Computation hPrint hdl t writes the string representation of t given by the shows function to the file or channel managed by hdl and appends a newline
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:interact'>interact </a>  (String -> String) -> IO () </tt>	The interact function takes a function of type String-&gt;String as its argument
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:putChar'>putChar </a>  Char -> IO () </tt>	Write a character to the standard output device (same as hPutChar stdout)
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:putStr'>putStr </a>  String -> IO () </tt>	Write a string to the standard output device (same as hPutStr stdout)
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:putStrLn'>putStrLn </a>  String -> IO () </tt>	The same as putStr, but adds a newline character
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:print'>print </a>  Show a => a -> IO () </tt>	The print function outputs a value of any printable type to the standard output device
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:getChar'>getChar </a>  IO Char </tt>	Read a character from the standard input device (same as hGetChar stdin)
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:getLine'>getLine </a>  IO String </tt>	Read a line from the standard input device (same as hGetLine stdin)
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:getContents'>getContents </a>  IO String </tt>	The getContents operation returns all user input as a single string, which is read lazily as it is needed (same as hGetContents stdin)
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:readIO'>readIO </a>  Read a => String -> IO a </tt>	The readIO function is similar to read except that it signals parse failure to the IO monad instead of terminating the program
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:readLn'>readLn </a>  Read a => IO a </tt>	The readLn function combines getLine and readIO
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:withBinaryFile'>withBinaryFile </a>  FilePath -> IOMode -> (Handle -> IO r) -> IO r </tt>	withBinaryFile name mode act opens a file using openBinaryFile and passes the resulting handle to the computation act
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:openBinaryFile'>openBinaryFile </a>  FilePath -> IOMode -> IO Handle </tt>	Like openFile, but open the file in binary mode
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:hSetBinaryMode'>hSetBinaryMode </a>  Handle -> Bool -> IO () </tt>	Select binary mode (True) or text mode (False) on a open handle
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:hPutBuf'>hPutBuf </a>  Handle -> Ptr a -> Int -> IO () </tt>	hPutBuf hdl buf count writes count 8-bit bytes from the buffer buf to the handle hdl
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:hGetBuf'>hGetBuf </a>  Handle -> Ptr a -> Int -> IO Int </tt>	hGetBuf hdl buf count reads data from the handle hdl into the buffer buf until either EOF is reached or count 8-bit bytes have been read
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:hGetBufSome'>hGetBufSome </a>  Handle -> Ptr a -> Int -> IO Int </tt>	hGetBufSome hdl buf count reads data from the handle hdl into the buffer buf
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:hGetBufNonBlocking'>hGetBufNonBlocking </a>  Handle -> Ptr a -> Int -> IO Int </tt>	hGetBufNonBlocking hdl buf count reads data from the handle hdl into the buffer buf until either EOF is reached, or count 8-bit bytes have been read, or there is no more data available to read immediately
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:openTempFile'>openTempFile </a>  FilePath -> String -> IO (FilePath, Handle) </tt>	The function creates a temporary file in ReadWrite mode
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:openBinaryTempFile'>openBinaryTempFile </a>  FilePath -> String -> IO (FilePath, Handle) </tt>	Like openTempFile, but opens the file in binary mode
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:openTempFileWithDefaultPermissions'>openTempFileWithDefaultPermissions </a>  FilePath -> String -> IO (FilePath, Handle) </tt>	Like openTempFile, but uses the default file permissions
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:openBinaryTempFileWithDefaultPermissions'>openBinaryTempFileWithDefaultPermissions </a>  FilePath -> String -> IO (FilePath, Handle) </tt>	Like openBinaryTempFile, but uses the default file permissions
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:hSetEncoding'>hSetEncoding </a>  Handle -> TextEncoding -> IO () </tt>	The action hSetEncoding hdl encoding changes the text encoding for the handle hdl to encoding
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:hGetEncoding'>hGetEncoding </a>  Handle -> IO (Maybe TextEncoding) </tt>	Return the current TextEncoding for the specified Handle, or Nothing if the Handle is in binary mode
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:latin1'>latin1 </a>  TextEncoding </tt>	The Latin1 (ISO8859-1) encoding
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:utf8'>utf8 </a>  TextEncoding </tt>	The UTF-8 Unicode encoding
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:utf8_bom'>utf8_bom </a>  TextEncoding </tt>	The UTF-8 Unicode encoding, with a byte-order-mark (BOM; the byte sequence 0xEF 0xBB 0xBF)
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:utf16'>utf16 </a>  TextEncoding </tt>	The UTF-16 Unicode encoding (a byte-order-mark should be used to indicate endianness)
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:utf16le'>utf16le </a>  TextEncoding </tt>	The UTF-16 Unicode encoding (litte-endian)
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:utf16be'>utf16be </a>  TextEncoding </tt>	The UTF-16 Unicode encoding (big-endian)
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:utf32'>utf32 </a>  TextEncoding </tt>	The UTF-32 Unicode encoding (a byte-order-mark should be used to indicate endianness)
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:utf32le'>utf32le </a>  TextEncoding </tt>	The UTF-32 Unicode encoding (litte-endian)
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:utf32be'>utf32be </a>  TextEncoding </tt>	The UTF-32 Unicode encoding (big-endian)
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:localeEncoding'>localeEncoding </a>  TextEncoding </tt>	The Unicode encoding of the current locale  This is the initial locale encoding: if it has been subsequently changed by setLocaleEncoding this value will not reflect that change
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:char8'>char8 </a>  TextEncoding </tt>	An encoding in which Unicode code points are translated to bytes by taking the code point modulo 256
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:mkTextEncoding'>mkTextEncoding </a>  String -> IO TextEncoding </tt>	Look up the named Unicode encoding
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:hSetNewlineMode'>hSetNewlineMode </a>  Handle -> NewlineMode -> IO () </tt>	Set the NewlineMode on the specified Handle
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:nativeNewline'>nativeNewline </a>  Newline </tt>	The native newline representation for the current platform: LF on Unix systems, CRLF on Windows
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:NewlineMode'>NewlineMode </a>  Newline -> Newline -> NewlineMode </tt>	Specifies the translation, if any, of newline characters between internal Strings and the external file or stream
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:[inputNL]'>[inputNL] </a>  NewlineMode -> Newline </tt>	the representation of newlines on input
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:[outputNL]'>[outputNL] </a>  NewlineMode -> Newline </tt>	the representation of newlines on output
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:noNewlineTranslation'>noNewlineTranslation </a>  NewlineMode </tt>	Do no newline translation at all
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:universalNewlineMode'>universalNewlineMode </a>  NewlineMode </tt>	Map '\r\n' into '\n' on input, and '\n' to the native newline represetnation on output
<tt style='background-color:#E8E8E8;'> System.IO <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#v:nativeNewlineMode'>nativeNewlineMode </a>  NewlineMode </tt>	Use the native newline representation on both input and output   nativeNewlineMode  = NewlineMode { inputNL  = nativeNewline outputNL = nativeNewline }
<tt style='background-color:#E8E8E8;'> Control.Monad.Fix <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad-Fix.html#v:mfix'>mfix </a>  MonadFix m => (a -> m a) -> m a </tt>	The fixed point of a monadic computation
<tt style='background-color:#E8E8E8;'> Control.Monad.Fix <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad-Fix.html#v:fix'>fix </a>  (a -> a) -> a </tt>	fix f is the least fixed point of the function f
<tt style='background-color:#E8E8E8;'> Control.Arrow <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Arrow.html#v:arr'>arr </a>  Arrow a => (b -> c) -> a b c </tt>	Lift a function to an arrow
<tt style='background-color:#E8E8E8;'> Control.Arrow <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Arrow.html#v:first'>first </a>  Arrow a => a b c -> a (b, d) (c, d) </tt>	Send the first component of the input through the argument arrow, and copy the rest unchanged to the output
<tt style='background-color:#E8E8E8;'> Control.Arrow <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Arrow.html#v:second'>second </a>  Arrow a => a b c -> a (d, b) (d, c) </tt>	A mirror image of first
<tt style='background-color:#E8E8E8;'> Control.Arrow <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Arrow.html#v:(***)'>(***) </a>  Arrow a => a b c -> a b' c' -> a (b, b') (c, c') </tt>	Split the input between the two argument arrows and combine their output
<tt style='background-color:#E8E8E8;'> Control.Arrow <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Arrow.html#v:(&&&)'>(&&&) </a>  Arrow a => a b c -> a b c' -> a b (c, c') </tt>	Fanout: send the input to both argument arrows and combine their output
<tt style='background-color:#E8E8E8;'> Control.Arrow <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Arrow.html#v:Kleisli'>Kleisli </a>  (a -> m b) -> Kleisli m a b </tt>	Kleisli arrows of a monad
<tt style='background-color:#E8E8E8;'> Control.Arrow <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Arrow.html#v:returnA'>returnA </a>  Arrow a => a b b </tt>	The identity arrow, which plays the role of return in arrow notation
<tt style='background-color:#E8E8E8;'> Control.Arrow <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Arrow.html#v:(^>>)'>(^>>) </a>  Arrow a => (b -> c) -> a c d -> a b d </tt>	Precomposition with a pure function
<tt style='background-color:#E8E8E8;'> Control.Arrow <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Arrow.html#v:(>>^)'>(>>^) </a>  Arrow a => a b c -> (c -> d) -> a b d </tt>	Postcomposition with a pure function
<tt style='background-color:#E8E8E8;'> Control.Arrow <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Arrow.html#v:(>>>)'>(>>>) </a>  Category cat => cat a b -> cat b c -> cat a c </tt>	Left-to-right composition
<tt style='background-color:#E8E8E8;'> Control.Arrow <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Arrow.html#v:(<<<)'>(<<<) </a>  Category cat => cat b c -> cat a b -> cat a c </tt>	Right-to-left composition
<tt style='background-color:#E8E8E8;'> Control.Arrow <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Arrow.html#v:(<<^)'>(<<^) </a>  Arrow a => a c d -> (b -> c) -> a b d </tt>	Precomposition with a pure function (right-to-left variant)
<tt style='background-color:#E8E8E8;'> Control.Arrow <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Arrow.html#v:(^<<)'>(^<<) </a>  Arrow a => (c -> d) -> a b c -> a b d </tt>	Postcomposition with a pure function (right-to-left variant)
<tt style='background-color:#E8E8E8;'> Control.Arrow <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Arrow.html#v:(<+>)'>(<+>) </a>  ArrowPlus a => a b c -> a b c -> a b c </tt>	An associative operation with identity zeroArrow
<tt style='background-color:#E8E8E8;'> Control.Arrow <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Arrow.html#v:left'>left </a>  ArrowChoice a => a b c -> a (Either b d) (Either c d) </tt>	Feed marked inputs through the argument arrow, passing the rest through unchanged to the output
<tt style='background-color:#E8E8E8;'> Control.Arrow <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Arrow.html#v:right'>right </a>  ArrowChoice a => a b c -> a (Either d b) (Either d c) </tt>	A mirror image of left
<tt style='background-color:#E8E8E8;'> Control.Arrow <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Arrow.html#v:(+++)'>(+++) </a>  ArrowChoice a => a b c -> a b' c' -> a (Either b b') (Either c c') </tt>	Split the input between the two argument arrows, retagging and merging their outputs
<tt style='background-color:#E8E8E8;'> Control.Arrow <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Arrow.html#v:(|||)'>(|||) </a>  ArrowChoice a => a b d -> a c d -> a (Either b c) d </tt>	Fanin: Split the input between the two argument arrows and merge their outputs
<tt style='background-color:#E8E8E8;'> Control.Arrow <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Arrow.html#v:ArrowMonad'>ArrowMonad </a>  (a () b) -> ArrowMonad a b </tt>	The ArrowApply class is equivalent to Monad: any monad gives rise to a Kleisli arrow, and any instance of ArrowApply defines a monad
<tt style='background-color:#E8E8E8;'> Control.Arrow <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Arrow.html#v:leftApp'>leftApp </a>  ArrowApply a => a b c -> a (Either b d) (Either c d) </tt>	Any instance of ArrowApply can be made into an instance of ArrowChoice by defining left = leftApp
<tt style='background-color:#E8E8E8;'> Control.Arrow <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Arrow.html#v:loop'>loop </a>  ArrowLoop a => a (b, d) (c, d) -> a b c </tt>	The loop operator expresses computations in which an output value is fed back as input, although the computation occurs only once
<tt style='background-color:#E8E8E8;'> Control.Applicative <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Applicative.html#v:pure'>pure </a>  Applicative f => a -> f a </tt>	Lift a value
<tt style='background-color:#E8E8E8;'> Control.Applicative <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Applicative.html#v:(<*>)'>(<*>) </a>  Applicative f => f (a -> b) -> f a -> f b </tt>	Sequential application
<tt style='background-color:#E8E8E8;'> Control.Applicative <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Applicative.html#v:(*>)'>(*>) </a>  Applicative f => f a -> f b -> f b </tt>	Sequence actions, discarding the value of the first argument
<tt style='background-color:#E8E8E8;'> Control.Applicative <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Applicative.html#v:(<*)'>(<*) </a>  Applicative f => f a -> f b -> f a </tt>	Sequence actions, discarding the value of the second argument
<tt style='background-color:#E8E8E8;'> Control.Applicative <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Applicative.html#v:empty'>empty </a>  Alternative f => f a </tt>	The identity of &lt;|&gt;
<tt style='background-color:#E8E8E8;'> Control.Applicative <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Applicative.html#v:(<|>)'>(<|>) </a>  Alternative f => f a -> f a -> f a </tt>	An associative binary operation
<tt style='background-color:#E8E8E8;'> Control.Applicative <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Applicative.html#v:some'>some </a>  Alternative f => f a -> f [a] </tt>	One or more
<tt style='background-color:#E8E8E8;'> Control.Applicative <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Applicative.html#v:many'>many </a>  Alternative f => f a -> f [a] </tt>	Zero or more
<tt style='background-color:#E8E8E8;'> Control.Applicative <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Applicative.html#v:ZipList'>ZipList </a>  [a] -> ZipList a </tt>	Lists, but with an Applicative functor based on zipping, so that   f &lt;$&gt; ZipList xs1 &lt;*&gt;
<tt style='background-color:#E8E8E8;'> Control.Applicative <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Applicative.html#v:(<$>)'>(<$>) </a>  Functor f => (a -> b) -> f a -> f b </tt>	An infix synonym for fmap
<tt style='background-color:#E8E8E8;'> Control.Applicative <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Applicative.html#v:(<$)'>(<$) </a>  Functor f => a -> f b -> f a </tt>	Replace all locations in the input with the same value
<tt style='background-color:#E8E8E8;'> Control.Applicative <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Applicative.html#v:(<**>)'>(<**>) </a>  Applicative f => f a -> f (a -> b) -> f b </tt>	A variant of &lt;*&gt; with the arguments reversed
<tt style='background-color:#E8E8E8;'> Control.Applicative <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Applicative.html#v:liftA'>liftA </a>  Applicative f => (a -> b) -> f a -> f b </tt>	Lift a function to actions
<tt style='background-color:#E8E8E8;'> Control.Applicative <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Applicative.html#v:liftA2'>liftA2 </a>  Applicative f => (a -> b -> c) -> f a -> f b -> f c </tt>	Lift a binary function to actions
<tt style='background-color:#E8E8E8;'> Control.Applicative <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Applicative.html#v:liftA3'>liftA3 </a>  Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d </tt>	Lift a ternary function to actions
<tt style='background-color:#E8E8E8;'> Control.Applicative <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Applicative.html#v:optional'>optional </a>  Alternative f => f a -> f (Maybe a) </tt>	One or none
<tt style='background-color:#E8E8E8;'> Data.Traversable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Traversable.html#v:traverse'>traverse </a>  (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b) </tt>	Map each element of a structure to an action, evaluate these actions from left to right, and collect the results
<tt style='background-color:#E8E8E8;'> Data.Traversable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Traversable.html#v:sequenceA'>sequenceA </a>  (Traversable t, Applicative f) => t (f a) -> f (t a) </tt>	Evaluate each action in the structure from left to right, and and collect the results
<tt style='background-color:#E8E8E8;'> Data.Traversable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Traversable.html#v:mapM'>mapM </a>  (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b) </tt>	Map each element of a structure to a monadic action, evaluate these actions from left to right, and collect the results
<tt style='background-color:#E8E8E8;'> Data.Traversable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Traversable.html#v:sequence'>sequence </a>  (Traversable t, Monad m) => t (m a) -> m (t a) </tt>	Evaluate each monadic action in the structure from left to right, and collect the results
<tt style='background-color:#E8E8E8;'> Data.Traversable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Traversable.html#v:for'>for </a>  (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b) </tt>	for is traverse with its arguments flipped
<tt style='background-color:#E8E8E8;'> Data.Traversable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Traversable.html#v:forM'>forM </a>  (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b) </tt>	forM is mapM with its arguments flipped
<tt style='background-color:#E8E8E8;'> Data.Traversable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Traversable.html#v:mapAccumL'>mapAccumL </a>  Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c) </tt>	The mapAccumL function behaves like a combination of fmap and foldl; it applies a function to each element of a structure, passing an accumulating parameter from left to right, and returning a final value of this accumulator together with the new structure
<tt style='background-color:#E8E8E8;'> Data.Traversable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Traversable.html#v:mapAccumR'>mapAccumR </a>  Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c) </tt>	The mapAccumR function behaves like a combination of fmap and foldr; it applies a function to each element of a structure, passing an accumulating parameter from right to left, and returning a final value of this accumulator together with the new structure
<tt style='background-color:#E8E8E8;'> Data.Traversable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Traversable.html#v:fmapDefault'>fmapDefault </a>  Traversable t => (a -> b) -> t a -> t b </tt>	This function may be used as a value for fmap in a Functor instance, provided that traverse is defined
<tt style='background-color:#E8E8E8;'> Data.Traversable <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Traversable.html#v:foldMapDefault'>foldMapDefault </a>  (Traversable t, Monoid m) => (a -> m) -> t a -> m </tt>	This function may be used as a value for foldMap in a Foldable instance
<tt style='background-color:#E8E8E8;'> Control.Monad <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad.html#v:fmap'>fmap </a>  Functor f => (a -> b) -> f a -> f b </tt>	The Functor class is used for types that can be mapped over
<tt style='background-color:#E8E8E8;'> Control.Monad <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad.html#v:(>>=)'>(>>=) </a>  Monad m => m a -> (a -> m b) -> m b </tt>	Sequentially compose two actions, passing any value produced by the first as an argument to the second
<tt style='background-color:#E8E8E8;'> Control.Monad <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad.html#v:(>>)'>(>>) </a>  Monad m => m a -> m b -> m b </tt>	Sequentially compose two actions, discarding any value produced by the first, like sequencing operators (such as the semicolon) in imperative languages
<tt style='background-color:#E8E8E8;'> Control.Monad <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad.html#v:return'>return </a>  Monad m => a -> m a </tt>	Inject a value into the monadic type
<tt style='background-color:#E8E8E8;'> Control.Monad <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad.html#v:fail'>fail </a>  Monad m => String -> m a </tt>	Fail with a message
<tt style='background-color:#E8E8E8;'> Control.Monad <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad.html#v:mzero'>mzero </a>  MonadPlus m => m a </tt>	the identity of mplus
<tt style='background-color:#E8E8E8;'> Control.Monad <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad.html#v:mplus'>mplus </a>  MonadPlus m => m a -> m a -> m a </tt>	an associative operation
<tt style='background-color:#E8E8E8;'> Control.Monad <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad.html#v:mapM'>mapM </a>  (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b) </tt>	Map each element of a structure to a monadic action, evaluate these actions from left to right, and collect the results
<tt style='background-color:#E8E8E8;'> Control.Monad <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad.html#v:mapM_'>mapM_ </a>  (Foldable t, Monad m) => (a -> m b) -> t a -> m () </tt>	Map each element of a structure to a monadic action, evaluate these actions from left to right, and ignore the results
<tt style='background-color:#E8E8E8;'> Control.Monad <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad.html#v:forM'>forM </a>  (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b) </tt>	forM is mapM with its arguments flipped
<tt style='background-color:#E8E8E8;'> Control.Monad <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad.html#v:forM_'>forM_ </a>  (Foldable t, Monad m) => t a -> (a -> m b) -> m () </tt>	forM_ is mapM_ with its arguments flipped
<tt style='background-color:#E8E8E8;'> Control.Monad <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad.html#v:sequence'>sequence </a>  (Traversable t, Monad m) => t (m a) -> m (t a) </tt>	Evaluate each monadic action in the structure from left to right, and collect the results
<tt style='background-color:#E8E8E8;'> Control.Monad <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad.html#v:sequence_'>sequence_ </a>  (Foldable t, Monad m) => t (m a) -> m () </tt>	Evaluate each monadic action in the structure from left to right, and ignore the results
<tt style='background-color:#E8E8E8;'> Control.Monad <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad.html#v:(=<<)'>(=<<) </a>  Monad m => (a -> m b) -> m a -> m b </tt>	Same as &gt;&gt;=, but with the arguments interchanged
<tt style='background-color:#E8E8E8;'> Control.Monad <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad.html#v:(>=>)'>(>=>) </a>  Monad m => (a -> m b) -> (b -> m c) -> (a -> m c) </tt>	Left-to-right Kleisli composition of monads
<tt style='background-color:#E8E8E8;'> Control.Monad <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad.html#v:(<=<)'>(<=<) </a>  Monad m => (b -> m c) -> (a -> m b) -> (a -> m c) </tt>	Right-to-left Kleisli composition of monads
<tt style='background-color:#E8E8E8;'> Control.Monad <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad.html#v:forever'>forever </a>  (Monad m) => m a -> m b </tt>	forever act repeats the action infinitely
<tt style='background-color:#E8E8E8;'> Control.Monad <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad.html#v:void'>void </a>  Functor f => f a -> f () </tt>	void value discards or ignores the result of evaluation, such as the return value of an IO action
<tt style='background-color:#E8E8E8;'> Control.Monad <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad.html#v:join'>join </a>  (Monad m) => m (m a) -> m a </tt>	The join function is the conventional monad join operator
<tt style='background-color:#E8E8E8;'> Control.Monad <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad.html#v:msum'>msum </a>  (Foldable t, MonadPlus m) => t (m a) -> m a </tt>	The sum of a collection of actions, generalizing concat
<tt style='background-color:#E8E8E8;'> Control.Monad <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad.html#v:mfilter'>mfilter </a>  (MonadPlus m) => (a -> Bool) -> m a -> m a </tt>	Direct MonadPlus equivalent of filter filter = (mfilter:: (a -&gt; Bool) -&gt; [a] -&gt; [a] applicable to any MonadPlus, for example mfilter odd (Just 1) == Just 1 mfilter odd (Just 2) == Nothing
<tt style='background-color:#E8E8E8;'> Control.Monad <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad.html#v:filterM'>filterM </a>  (Monad m) => (a -> m Bool) -> [a] -> m [a] </tt>	This generalizes the list-based filter function
<tt style='background-color:#E8E8E8;'> Control.Monad <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad.html#v:mapAndUnzipM'>mapAndUnzipM </a>  (Monad m) => (a -> m (b, c)) -> [a] -> m ([b], [c]) </tt>	The mapAndUnzipM function maps its first argument over a list, returning the result as a pair of lists
<tt style='background-color:#E8E8E8;'> Control.Monad <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad.html#v:zipWithM'>zipWithM </a>  (Monad m) => (a -> b -> m c) -> [a] -> [b] -> m [c] </tt>	The zipWithM function generalizes zipWith to arbitrary monads
<tt style='background-color:#E8E8E8;'> Control.Monad <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad.html#v:zipWithM_'>zipWithM_ </a>  (Monad m) => (a -> b -> m c) -> [a] -> [b] -> m () </tt>	zipWithM_ is the extension of zipWithM which ignores the final result
<tt style='background-color:#E8E8E8;'> Control.Monad <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad.html#v:foldM'>foldM </a>  (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b </tt>	The foldM function is analogous to foldl, except that its result is encapsulated in a monad
<tt style='background-color:#E8E8E8;'> Control.Monad <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad.html#v:foldM_'>foldM_ </a>  (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m () </tt>	Like foldM, but discards the result
<tt style='background-color:#E8E8E8;'> Control.Monad <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad.html#v:replicateM'>replicateM </a>  (Monad m) => Int -> m a -> m [a] </tt>	replicateM n act performs the action n times, gathering the results
<tt style='background-color:#E8E8E8;'> Control.Monad <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad.html#v:replicateM_'>replicateM_ </a>  (Monad m) => Int -> m a -> m () </tt>	Like replicateM, but discards the result
<tt style='background-color:#E8E8E8;'> Control.Monad <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad.html#v:guard'>guard </a>  (Alternative f) => Bool -> f () </tt>	guard b is pure () if b is True, and empty if b is False
<tt style='background-color:#E8E8E8;'> Control.Monad <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad.html#v:when'>when </a>  (Applicative f) => Bool -> f () -> f () </tt>	Conditional execution of Applicative expressions
<tt style='background-color:#E8E8E8;'> Control.Monad <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad.html#v:unless'>unless </a>  (Applicative f) => Bool -> f () -> f () </tt>	The reverse of when
<tt style='background-color:#E8E8E8;'> Control.Monad <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad.html#v:liftM'>liftM </a>  (Monad m) => (a1 -> r) -> m a1 -> m r </tt>	Promote a function to a monad
<tt style='background-color:#E8E8E8;'> Control.Monad <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad.html#v:liftM2'>liftM2 </a>  (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r </tt>	Promote a function to a monad, scanning the monadic arguments from left to right
<tt style='background-color:#E8E8E8;'> Control.Monad <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad.html#v:liftM3'>liftM3 </a>  (Monad m) => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r </tt>	Promote a function to a monad, scanning the monadic arguments from left to right (cf
<tt style='background-color:#E8E8E8;'> Control.Monad <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad.html#v:liftM4'>liftM4 </a>  (Monad m) => (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r </tt>	Promote a function to a monad, scanning the monadic arguments from left to right (cf
<tt style='background-color:#E8E8E8;'> Control.Monad <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad.html#v:liftM5'>liftM5 </a>  (Monad m) => (a1 -> a2 -> a3 -> a4 -> a5 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r </tt>	Promote a function to a monad, scanning the monadic arguments from left to right (cf
<tt style='background-color:#E8E8E8;'> Control.Monad <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad.html#v:ap'>ap </a>  (Monad m) => m (a -> b) -> m a -> m b </tt>	In many situations, the liftM operations can be replaced by uses of ap, which promotes function application
<tt style='background-color:#E8E8E8;'> Control.Monad <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad.html#v:(<$!>)'>(<$!>) </a>  Monad m => (a -> b) -> m a -> m b </tt>	Strict version of &lt;$&gt;
<tt style='background-color:#E8E8E8;'> GHC.Stats <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Stats.html#v:[bytesAllocated]'>[bytesAllocated] </a>  GCStats -> !Int64 </tt>	Total number of bytes allocated
<tt style='background-color:#E8E8E8;'> GHC.Stats <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Stats.html#v:[numGcs]'>[numGcs] </a>  GCStats -> !Int64 </tt>	Number of garbage collections performed
<tt style='background-color:#E8E8E8;'> GHC.Stats <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Stats.html#v:[maxBytesUsed]'>[maxBytesUsed] </a>  GCStats -> !Int64 </tt>	Maximum number of live bytes seen so far
<tt style='background-color:#E8E8E8;'> GHC.Stats <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Stats.html#v:[numByteUsageSamples]'>[numByteUsageSamples] </a>  GCStats -> !Int64 </tt>	Number of byte usage samples taken | Sum of all byte usage samples, can be used with numByteUsageSamples to calculate averages with arbitrary weighting (if you are sampling this record multiple times)
<tt style='background-color:#E8E8E8;'> GHC.Stats <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Stats.html#v:[bytesCopied]'>[bytesCopied] </a>  GCStats -> !Int64 </tt>	Number of bytes copied during GC
<tt style='background-color:#E8E8E8;'> GHC.Stats <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Stats.html#v:[currentBytesUsed]'>[currentBytesUsed] </a>  GCStats -> !Int64 </tt>	Current number of live bytes
<tt style='background-color:#E8E8E8;'> GHC.Stats <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Stats.html#v:[currentBytesSlop]'>[currentBytesSlop] </a>  GCStats -> !Int64 </tt>	Current number of bytes lost to slop
<tt style='background-color:#E8E8E8;'> GHC.Stats <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Stats.html#v:[maxBytesSlop]'>[maxBytesSlop] </a>  GCStats -> !Int64 </tt>	Maximum number of bytes lost to slop at any one time so far
<tt style='background-color:#E8E8E8;'> GHC.Stats <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Stats.html#v:[peakMegabytesAllocated]'>[peakMegabytesAllocated] </a>  GCStats -> !Int64 </tt>	Maximum number of megabytes allocated | CPU time spent running mutator threads
<tt style='background-color:#E8E8E8;'> GHC.Stats <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Stats.html#v:[mutatorWallSeconds]'>[mutatorWallSeconds] </a>  GCStats -> !Double </tt>	Wall clock time spent running mutator threads
<tt style='background-color:#E8E8E8;'> GHC.Stats <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Stats.html#v:[gcCpuSeconds]'>[gcCpuSeconds] </a>  GCStats -> !Double </tt>	CPU time spent running GC
<tt style='background-color:#E8E8E8;'> GHC.Stats <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Stats.html#v:[gcWallSeconds]'>[gcWallSeconds] </a>  GCStats -> !Double </tt>	Wall clock time spent running GC
<tt style='background-color:#E8E8E8;'> GHC.Stats <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Stats.html#v:[cpuSeconds]'>[cpuSeconds] </a>  GCStats -> !Double </tt>	Total CPU time elapsed since program start
<tt style='background-color:#E8E8E8;'> GHC.Stats <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Stats.html#v:[wallSeconds]'>[wallSeconds] </a>  GCStats -> !Double </tt>	Total wall clock time elapsed since start | Number of bytes copied during GC, minus space held by mutable lists held by the capabilities
<tt style='background-color:#E8E8E8;'> GHC.Stats <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Stats.html#v:[parMaxBytesCopied]'>[parMaxBytesCopied] </a>  GCStats -> !Int64 </tt>	Sum of number of bytes copied each GC by the most active GC thread each GC
<tt style='background-color:#E8E8E8;'> GHC.Stats <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Stats.html#v:getGCStats'>getGCStats </a>  IO GCStats </tt>	Retrieves garbage collection and memory statistics as of the last garbage collection
<tt style='background-color:#E8E8E8;'> GHC.Stats <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Stats.html#v:getGCStatsEnabled'>getGCStatsEnabled </a>  IO Bool </tt>	Returns whether GC stats have been enabled (with +RTS -T, for example)
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:(++)'>(++) </a>  [a] -> [a] -> [a] </tt>	Append two lists
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:head'>head </a>  [a] -> a </tt>	Extract the first element of a list, which must be non-empty
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:last'>last </a>  [a] -> a </tt>	Extract the last element of a list, which must be finite and non-empty
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:tail'>tail </a>  [a] -> [a] </tt>	Extract the elements after the head of a list, which must be non-empty
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:init'>init </a>  [a] -> [a] </tt>	Return all the elements of a list except the last one
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:uncons'>uncons </a>  [a] -> Maybe (a, [a]) </tt>	Decompose a list into its head and tail
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:null'>null </a>  Foldable t => t a -> Bool </tt>	Test whether the structure is empty
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:length'>length </a>  Foldable t => t a -> Int </tt>	Returns the size/length of a finite structure as an Int
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:map'>map </a>  (a -> b) -> [a] -> [b] </tt>	map f xs is the list obtained by applying f to each element of xs
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:reverse'>reverse </a>  [a] -> [a] </tt>	reverse xs returns the elements of xs in reverse order
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:intersperse'>intersperse </a>  a -> [a] -> [a] </tt>	The intersperse function takes an element and a list and `intersperses' that element between the elements of the list
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:intercalate'>intercalate </a>  [a] -> [[a]] -> [a] </tt>	intercalate xs xss is equivalent to (concat (intersperse xs xss))
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:transpose'>transpose </a>  [[a]] -> [[a]] </tt>	The transpose function transposes the rows and columns of its argument
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:subsequences'>subsequences </a>  [a] -> [[a]] </tt>	The subsequences function returns the list of all subsequences of the argument
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:permutations'>permutations </a>  [a] -> [[a]] </tt>	The permutations function returns the list of all permutations of the argument
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:foldl'>foldl </a>  Foldable t => (b -> a -> b) -> b -> t a -> b </tt>	Left-associative fold of a structure
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:foldl''>foldl' </a>  Foldable t => (b -> a -> b) -> b -> t a -> b </tt>	Left-associative fold of a structure
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:foldl1'>foldl1 </a>  Foldable t => (a -> a -> a) -> t a -> a </tt>	A variant of foldl that has no base case, and thus may only be applied to non-empty structures
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:foldl1''>foldl1' </a>  (a -> a -> a) -> [a] -> a </tt>	A strict version of foldl1
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:foldr'>foldr </a>  Foldable t => (a -> b -> b) -> b -> t a -> b </tt>	Right-associative fold of a structure
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:foldr1'>foldr1 </a>  Foldable t => (a -> a -> a) -> t a -> a </tt>	A variant of foldr that has no base case, and thus may only be applied to non-empty structures
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:concat'>concat </a>  Foldable t => t [a] -> [a] </tt>	The concatenation of all the elements of a container of lists
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:concatMap'>concatMap </a>  Foldable t => (a -> [b]) -> t a -> [b] </tt>	Map a function over all the elements of a container and concatenate the resulting lists
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:and'>and </a>  Foldable t => t Bool -> Bool </tt>	and returns the conjunction of a container of Bools
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:or'>or </a>  Foldable t => t Bool -> Bool </tt>	or returns the disjunction of a container of Bools
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:any'>any </a>  Foldable t => (a -> Bool) -> t a -> Bool </tt>	Determines whether any element of the structure satisfies the predicate
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:all'>all </a>  Foldable t => (a -> Bool) -> t a -> Bool </tt>	Determines whether all elements of the structure satisfy the predicate
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:sum'>sum </a>  (Foldable t, Num a) => t a -> a </tt>	The sum function computes the sum of the numbers of a structure
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:product'>product </a>  (Foldable t, Num a) => t a -> a </tt>	The product function computes the product of the numbers of a structure
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:maximum'>maximum </a>  (Foldable t, Ord a) => t a -> a </tt>	The largest element of a non-empty structure
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:minimum'>minimum </a>  (Foldable t, Ord a) => t a -> a </tt>	The least element of a non-empty structure
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:scanl'>scanl </a>  (b -> a -> b) -> b -> [a] -> [b] </tt>	scanl is similar to foldl, but returns a list of successive reduced values from the left:   scanl f z [x1, x2,
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:scanl''>scanl' </a>  (b -> a -> b) -> b -> [a] -> [b] </tt>	A strictly accumulating version of scanl
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:scanl1'>scanl1 </a>  (a -> a -> a) -> [a] -> [a] </tt>	scanl1 is a variant of scanl that has no starting value argument:   scanl1 f [x1, x2,
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:scanr'>scanr </a>  (a -> b -> b) -> b -> [a] -> [b] </tt>	scanr is the right-to-left dual of scanl
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:scanr1'>scanr1 </a>  (a -> a -> a) -> [a] -> [a] </tt>	scanr1 is a variant of scanr that has no starting value argument
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:mapAccumL'>mapAccumL </a>  Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c) </tt>	The mapAccumL function behaves like a combination of fmap and foldl; it applies a function to each element of a structure, passing an accumulating parameter from left to right, and returning a final value of this accumulator together with the new structure
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:mapAccumR'>mapAccumR </a>  Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c) </tt>	The mapAccumR function behaves like a combination of fmap and foldr; it applies a function to each element of a structure, passing an accumulating parameter from right to left, and returning a final value of this accumulator together with the new structure
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:iterate'>iterate </a>  (a -> a) -> a -> [a] </tt>	iterate f x returns an infinite list of repeated applications of f to x:   iterate f x == [x, f x, f (f x),
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:repeat'>repeat </a>  a -> [a] </tt>	repeat x is an infinite list, with x the value of every element
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:replicate'>replicate </a>  Int -> a -> [a] </tt>	replicate n x is a list of length n with x the value of every element
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:cycle'>cycle </a>  [a] -> [a] </tt>	cycle ties a finite list into a circular one, or equivalently, the infinite repetition of the original list
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:unfoldr'>unfoldr </a>  (b -> Maybe (a, b)) -> b -> [a] </tt>	The unfoldr function is a `dual' to foldr: while foldr reduces a list to a summary value, unfoldr builds a list from a seed value
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:take'>take </a>  Int -> [a] -> [a] </tt>	take n, applied to a list xs, returns the prefix of xs of length n, or xs itself if n &gt; length xs:   take 5 "Hello World!" == "Hello" take 3 [1,2,3,4,5] == [1,2,3] take 3 [1,2] == [1,2] take 3 [] == [] take (-1) [1,2] == [] take 0 [1,2] == []   It is an instance of the more general genericTake, in which n may be of any integral type
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:drop'>drop </a>  Int -> [a] -> [a] </tt>	drop n xs returns the suffix of xs after the first n elements, or [] if n &gt; length xs:   drop 6 "Hello World!" == "World!" drop 3 [1,2,3,4,5] == [4,5] drop 3 [1,2] == [] drop 3 [] == [] drop (-1) [1,2] == [1,2] drop 0 [1,2] == [1,2]   It is an instance of the more general genericDrop, in which n may be of any integral type
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:splitAt'>splitAt </a>  Int -> [a] -> ([a], [a]) </tt>	splitAt n xs returns a tuple where first element is xs prefix of length n and second element is the remainder of the list:   splitAt 6 "Hello World!" == ("Hello ","World!") splitAt 3 [1,2,3,4,5] == ([1,2,3],[4,5]) splitAt 1 [1,2,3] == ([1],[2,3]) splitAt 3 [1,2,3] == ([1,2,3],[]) splitAt 4 [1,2,3] == ([1,2,3],[]) splitAt 0 [1,2,3] == ([],[1,2,3]) splitAt (-1) [1,2,3] == ([],[1,2,3])   It is equivalent to (take n xs, drop n xs) when n is not _|_ (splitAt _|_ xs = _|_)
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:takeWhile'>takeWhile </a>  (a -> Bool) -> [a] -> [a] </tt>	takeWhile, applied to a predicate p and a list xs, returns the longest prefix (possibly empty) of xs of elements that satisfy p:   takeWhile (&lt; 3) [1,2,3,4,1,2,3,4] == [1,2] takeWhile (&lt; 9) [1,2,3] == [1,2,3] takeWhile (&lt; 0) [1,2,3] == []
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:dropWhile'>dropWhile </a>  (a -> Bool) -> [a] -> [a] </tt>	dropWhile p xs returns the suffix remaining after takeWhile p xs:   dropWhile (&lt; 3) [1,2,3,4,5,1,2,3] == [3,4,5,1,2,3] dropWhile (&lt; 9) [1,2,3] == [] dropWhile (&lt; 0) [1,2,3] == [1,2,3]
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:dropWhileEnd'>dropWhileEnd </a>  (a -> Bool) -> [a] -> [a] </tt>	The dropWhileEnd function drops the largest suffix of a list in which the given predicate holds for all elements
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:span'>span </a>  (a -> Bool) -> [a] -> ([a], [a]) </tt>	span, applied to a predicate p and a list xs, returns a tuple where first element is longest prefix (possibly empty) of xs of elements that satisfy p and second element is the remainder of the list:   span (&lt; 3) [1,2,3,4,1,2,3,4] == ([1,2],[3,4,1,2,3,4]) span (&lt; 9) [1,2,3] == ([1,2,3],[]) span (&lt; 0) [1,2,3] == ([],[1,2,3])   span p xs is equivalent to (takeWhile p xs, dropWhile p xs)
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:break'>break </a>  (a -> Bool) -> [a] -> ([a], [a]) </tt>	break, applied to a predicate p and a list xs, returns a tuple where first element is longest prefix (possibly empty) of xs of elements that do not satisfy p and second element is the remainder of the list:   break (&gt; 3) [1,2,3,4,1,2,3,4] == ([1,2,3],[4,1,2,3,4]) break (&lt; 9) [1,2,3] == ([],[1,2,3]) break (&gt; 9) [1,2,3] == ([1,2,3],[])   break p is equivalent to span (not
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:stripPrefix'>stripPrefix </a>  Eq a => [a] -> [a] -> Maybe [a] </tt>	The stripPrefix function drops the given prefix from a list
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:group'>group </a>  Eq a => [a] -> [[a]] </tt>	The group function takes a list and returns a list of lists such that the concatenation of the result is equal to the argument
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:inits'>inits </a>  [a] -> [[a]] </tt>	The inits function returns all initial segments of the argument, shortest first
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:tails'>tails </a>  [a] -> [[a]] </tt>	The tails function returns all final segments of the argument, longest first
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:isPrefixOf'>isPrefixOf </a>  (Eq a) => [a] -> [a] -> Bool </tt>	The isPrefixOf function takes two lists and returns True iff the first list is a prefix of the second
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:isSuffixOf'>isSuffixOf </a>  (Eq a) => [a] -> [a] -> Bool </tt>	The isSuffixOf function takes two lists and returns True iff the first list is a suffix of the second
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:isInfixOf'>isInfixOf </a>  (Eq a) => [a] -> [a] -> Bool </tt>	The isInfixOf function takes two lists and returns True iff the first list is contained, wholly and intact, anywhere within the second
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:isSubsequenceOf'>isSubsequenceOf </a>  (Eq a) => [a] -> [a] -> Bool </tt>	The isSubsequenceOf function takes two lists and returns True if the first list is a subsequence of the second list
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:elem'>elem </a>  (Foldable t, Eq a) => a -> t a -> Bool </tt>	Does the element occur in the structure?
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:notElem'>notElem </a>  (Foldable t, Eq a) => a -> t a -> Bool </tt>	notElem is the negation of elem
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:lookup'>lookup </a>  (Eq a) => a -> [(a, b)] -> Maybe b </tt>	lookup key assocs looks up a key in an association list
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:find'>find </a>  Foldable t => (a -> Bool) -> t a -> Maybe a </tt>	The find function takes a predicate and a structure and returns the leftmost element of the structure matching the predicate, or Nothing if there is no such element
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:filter'>filter </a>  (a -> Bool) -> [a] -> [a] </tt>	filter, applied to a predicate and a list, returns the list of those elements that satisfy the predicate; i
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:partition'>partition </a>  (a -> Bool) -> [a] -> ([a], [a]) </tt>	The partition function takes a predicate a list and returns the pair of lists of elements which do and do not satisfy the predicate, respectively; i
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:(!!)'>(!!) </a>  [a] -> Int -> a </tt>	List index (subscript) operator, starting from 0
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:elemIndex'>elemIndex </a>  Eq a => a -> [a] -> Maybe Int </tt>	The elemIndex function returns the index of the first element in the given list which is equal (by ==) to the query element, or Nothing if there is no such element
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:elemIndices'>elemIndices </a>  Eq a => a -> [a] -> [Int] </tt>	The elemIndices function extends elemIndex, by returning the indices of all elements equal to the query element, in ascending order
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:findIndex'>findIndex </a>  (a -> Bool) -> [a] -> Maybe Int </tt>	The findIndex function takes a predicate and a list and returns the index of the first element in the list satisfying the predicate, or Nothing if there is no such element
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:findIndices'>findIndices </a>  (a -> Bool) -> [a] -> [Int] </tt>	The findIndices function extends findIndex, by returning the indices of all elements satisfying the predicate, in ascending order
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:zip'>zip </a>  [a] -> [b] -> [(a, b)] </tt>	zip takes two lists and returns a list of corresponding pairs
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:zip3'>zip3 </a>  [a] -> [b] -> [c] -> [(a, b, c)] </tt>	zip3 takes three lists and returns a list of triples, analogous to zip
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:zip4'>zip4 </a>  [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)] </tt>	The zip4 function takes four lists and returns a list of quadruples, analogous to zip
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:zip5'>zip5 </a>  [a] -> [b] -> [c] -> [d] -> [e] -> [(a, b, c, d, e)] </tt>	The zip5 function takes five lists and returns a list of five-tuples, analogous to zip
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:zip6'>zip6 </a>  [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [(a, b, c, d, e, f)] </tt>	The zip6 function takes six lists and returns a list of six-tuples, analogous to zip
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:zip7'>zip7 </a>  [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [(a, b, c, d, e, f, g)] </tt>	The zip7 function takes seven lists and returns a list of seven-tuples, analogous to zip
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:zipWith'>zipWith </a>  (a -> b -> c) -> [a] -> [b] -> [c] </tt>	zipWith generalises zip by zipping with the function given as the first argument, instead of a tupling function
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:zipWith3'>zipWith3 </a>  (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d] </tt>	The zipWith3 function takes a function which combines three elements, as well as three lists and returns a list of their point-wise combination, analogous to zipWith
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:zipWith4'>zipWith4 </a>  (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e] </tt>	The zipWith4 function takes a function which combines four elements, as well as four lists and returns a list of their point-wise combination, analogous to zipWith
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:zipWith5'>zipWith5 </a>  (a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] </tt>	The zipWith5 function takes a function which combines five elements, as well as five lists and returns a list of their point-wise combination, analogous to zipWith
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:zipWith6'>zipWith6 </a>  (a -> b -> c -> d -> e -> f -> g) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] </tt>	The zipWith6 function takes a function which combines six elements, as well as six lists and returns a list of their point-wise combination, analogous to zipWith
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:zipWith7'>zipWith7 </a>  (a -> b -> c -> d -> e -> f -> g -> h) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [h] </tt>	The zipWith7 function takes a function which combines seven elements, as well as seven lists and returns a list of their point-wise combination, analogous to zipWith
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:unzip'>unzip </a>  [(a, b)] -> ([a], [b]) </tt>	unzip transforms a list of pairs into a list of first components and a list of second components
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:unzip3'>unzip3 </a>  [(a, b, c)] -> ([a], [b], [c]) </tt>	The unzip3 function takes a list of triples and returns three lists, analogous to unzip
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:unzip4'>unzip4 </a>  [(a, b, c, d)] -> ([a], [b], [c], [d]) </tt>	The unzip4 function takes a list of quadruples and returns four lists, analogous to unzip
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:unzip5'>unzip5 </a>  [(a, b, c, d, e)] -> ([a], [b], [c], [d], [e]) </tt>	The unzip5 function takes a list of five-tuples and returns five lists, analogous to unzip
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:unzip6'>unzip6 </a>  [(a, b, c, d, e, f)] -> ([a], [b], [c], [d], [e], [f]) </tt>	The unzip6 function takes a list of six-tuples and returns six lists, analogous to unzip
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:unzip7'>unzip7 </a>  [(a, b, c, d, e, f, g)] -> ([a], [b], [c], [d], [e], [f], [g]) </tt>	The unzip7 function takes a list of seven-tuples and returns seven lists, analogous to unzip
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:lines'>lines </a>  String -> [String] </tt>	lines breaks a string up into a list of strings at newline characters
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:words'>words </a>  String -> [String] </tt>	words breaks a string up into a list of words, which were delimited by white space
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:unlines'>unlines </a>  [String] -> String </tt>	unlines is an inverse operation to lines
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:unwords'>unwords </a>  [String] -> String </tt>	unwords is an inverse operation to words
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:nub'>nub </a>  (Eq a) => [a] -> [a] </tt>	The nub function removes duplicate elements from a list
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:delete'>delete </a>  (Eq a) => a -> [a] -> [a] </tt>	delete x removes the first occurrence of x from its list argument
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:(\\)'>(\\) </a>  (Eq a) => [a] -> [a] -> [a] </tt>	The \\ function is list difference (non-associative)
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:union'>union </a>  (Eq a) => [a] -> [a] -> [a] </tt>	The union function returns the list union of the two lists
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:intersect'>intersect </a>  (Eq a) => [a] -> [a] -> [a] </tt>	The intersect function takes the list intersection of two lists
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:sort'>sort </a>  (Ord a) => [a] -> [a] </tt>	The sort function implements a stable sorting algorithm
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:sortOn'>sortOn </a>  Ord b => (a -> b) -> [a] -> [a] </tt>	Sort a list by comparing the results of a key function applied to each element
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:insert'>insert </a>  Ord a => a -> [a] -> [a] </tt>	The insert function takes an element and a list and inserts the element into the list at the first position where it is less than or equal to the next element
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:nubBy'>nubBy </a>  (a -> a -> Bool) -> [a] -> [a] </tt>	The nubBy function behaves just like nub, except it uses a user-supplied equality predicate instead of the overloaded == function
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:deleteBy'>deleteBy </a>  (a -> a -> Bool) -> a -> [a] -> [a] </tt>	The deleteBy function behaves like delete, but takes a user-supplied equality predicate
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:deleteFirstsBy'>deleteFirstsBy </a>  (a -> a -> Bool) -> [a] -> [a] -> [a] </tt>	The deleteFirstsBy function takes a predicate and two lists and returns the first list with the first occurrence of each element of the second list removed
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:unionBy'>unionBy </a>  (a -> a -> Bool) -> [a] -> [a] -> [a] </tt>	The unionBy function is the non-overloaded version of union
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:intersectBy'>intersectBy </a>  (a -> a -> Bool) -> [a] -> [a] -> [a] </tt>	The intersectBy function is the non-overloaded version of intersect
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:groupBy'>groupBy </a>  (a -> a -> Bool) -> [a] -> [[a]] </tt>	The groupBy function is the non-overloaded version of group
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:sortBy'>sortBy </a>  (a -> a -> Ordering) -> [a] -> [a] </tt>	The sortBy function is the non-overloaded version of sort
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:insertBy'>insertBy </a>  (a -> a -> Ordering) -> a -> [a] -> [a] </tt>	The non-overloaded version of insert
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:maximumBy'>maximumBy </a>  Foldable t => (a -> a -> Ordering) -> t a -> a </tt>	The largest element of a non-empty structure with respect to the given comparison function
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:minimumBy'>minimumBy </a>  Foldable t => (a -> a -> Ordering) -> t a -> a </tt>	The least element of a non-empty structure with respect to the given comparison function
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:genericLength'>genericLength </a>  (Num i) => [a] -> i </tt>	The genericLength function is an overloaded version of length
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:genericTake'>genericTake </a>  (Integral i) => i -> [a] -> [a] </tt>	The genericTake function is an overloaded version of take, which accepts any Integral value as the number of elements to take
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:genericDrop'>genericDrop </a>  (Integral i) => i -> [a] -> [a] </tt>	The genericDrop function is an overloaded version of drop, which accepts any Integral value as the number of elements to drop
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:genericSplitAt'>genericSplitAt </a>  (Integral i) => i -> [a] -> ([a], [a]) </tt>	The genericSplitAt function is an overloaded version of splitAt, which accepts any Integral value as the position at which to split
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:genericIndex'>genericIndex </a>  (Integral i) => [a] -> i -> a </tt>	The genericIndex function is an overloaded version of !!, which accepts any Integral value as the index
<tt style='background-color:#E8E8E8;'> Data.List <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-List.html#v:genericReplicate'>genericReplicate </a>  (Integral i) => i -> a -> [a] </tt>	The genericReplicate function is an overloaded version of replicate, which accepts any Integral value as the number of repetitions to make
<tt style='background-color:#E8E8E8;'> Data.String <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-String.html#v:fromString'>fromString </a>  IsString a => String -> a </tt>	Class for string-like datastructures; used by the overloaded string extension (-XOverloadedStrings in GHC)
<tt style='background-color:#E8E8E8;'> Data.String <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-String.html#v:lines'>lines </a>  String -> [String] </tt>	lines breaks a string up into a list of strings at newline characters
<tt style='background-color:#E8E8E8;'> Data.String <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-String.html#v:words'>words </a>  String -> [String] </tt>	words breaks a string up into a list of words, which were delimited by white space
<tt style='background-color:#E8E8E8;'> Data.String <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-String.html#v:unlines'>unlines </a>  [String] -> String </tt>	unlines is an inverse operation to lines
<tt style='background-color:#E8E8E8;'> Data.String <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-String.html#v:unwords'>unwords </a>  [String] -> String </tt>	unwords is an inverse operation to words
<tt style='background-color:#E8E8E8;'> Data.Version <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Version.html#v:Version'>Version </a>  [Int] -> [String] -> Version </tt>	A Version represents the version of a software entity
<tt style='background-color:#E8E8E8;'> Data.Version <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Version.html#v:[versionBranch]'>[versionBranch] </a>  Version -> [Int] </tt>	The numeric branch for this version
<tt style='background-color:#E8E8E8;'> Data.Version <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Version.html#v:[versionTags]'>[versionTags] </a>  Version -> [String] </tt>	Deprecated: See GHC ticket #2496
<tt style='background-color:#E8E8E8;'> Data.Version <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Version.html#v:showVersion'>showVersion </a>  Version -> String </tt>	Provides one possible concrete representation for Version
<tt style='background-color:#E8E8E8;'> Data.Version <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Version.html#v:parseVersion'>parseVersion </a>  ReadP Version </tt>	A parser for versions in the format produced by showVersion
<tt style='background-color:#E8E8E8;'> Data.Version <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Version.html#v:makeVersion'>makeVersion </a>  [Int] -> Version </tt>	Construct tag-less Version
<tt style='background-color:#E8E8E8;'> Data.Data <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Data.html#v:toConstr'>toConstr </a>  Data a => a -> Constr </tt>	Obtaining the constructor from a given datum
<tt style='background-color:#E8E8E8;'> Data.Data <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Data.html#v:mkDataType'>mkDataType </a>  String -> [Constr] -> DataType </tt>	Constructs an algebraic datatype
<tt style='background-color:#E8E8E8;'> Data.Data <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Data.html#v:mkIntType'>mkIntType </a>  String -> DataType </tt>	Constructs the Int type
<tt style='background-color:#E8E8E8;'> Data.Data <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Data.html#v:mkFloatType'>mkFloatType </a>  String -> DataType </tt>	Constructs the Float type
<tt style='background-color:#E8E8E8;'> Data.Data <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Data.html#v:mkCharType'>mkCharType </a>  String -> DataType </tt>	Constructs the Char type
<tt style='background-color:#E8E8E8;'> Data.Data <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Data.html#v:mkNoRepType'>mkNoRepType </a>  String -> DataType </tt>	Constructs a non-representation for a non-representable type
<tt style='background-color:#E8E8E8;'> Data.Data <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Data.html#v:AlgRep'>AlgRep </a>  [Constr] -> DataRep </tt>	Public representation of datatypes
<tt style='background-color:#E8E8E8;'> Data.Data <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Data.html#v:repConstr'>repConstr </a>  DataType -> ConstrRep -> Constr </tt>	Look up a constructor by its representation
<tt style='background-color:#E8E8E8;'> Data.Data <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Data.html#v:isAlgType'>isAlgType </a>  DataType -> Bool </tt>	Test for an algebraic type
<tt style='background-color:#E8E8E8;'> Data.Data <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Data.html#v:indexConstr'>indexConstr </a>  DataType -> ConIndex -> Constr </tt>	Gets the constructor for an index (algebraic datatypes only)
<tt style='background-color:#E8E8E8;'> Data.Data <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Data.html#v:maxConstrIndex'>maxConstrIndex </a>  DataType -> ConIndex </tt>	Gets the maximum constructor index of an algebraic datatype
<tt style='background-color:#E8E8E8;'> Data.Data <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Data.html#v:isNorepType'>isNorepType </a>  DataType -> Bool </tt>	Test for a non-representable type
<tt style='background-color:#E8E8E8;'> Data.Data <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Data.html#v:Prefix'>Prefix </a>  Fixity </tt>	Fixity of constructors
<tt style='background-color:#E8E8E8;'> Data.Data <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Data.html#v:mkConstr'>mkConstr </a>  DataType -> String -> [String] -> Fixity -> Constr </tt>	Constructs a constructor
<tt style='background-color:#E8E8E8;'> Data.Data <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Data.html#v:mkCharConstr'>mkCharConstr </a>  DataType -> Char -> Constr </tt>	Makes a constructor for Char
<tt style='background-color:#E8E8E8;'> Data.Data <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Data.html#v:constrType'>constrType </a>  Constr -> DataType </tt>	Gets the datatype of a constructor
<tt style='background-color:#E8E8E8;'> Data.Data <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Data.html#v:AlgConstr'>AlgConstr </a>  ConIndex -> ConstrRep </tt>	Public representation of constructors
<tt style='background-color:#E8E8E8;'> Data.Data <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Data.html#v:constrRep'>constrRep </a>  Constr -> ConstrRep </tt>	Gets the public presentation of constructors
<tt style='background-color:#E8E8E8;'> Data.Data <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Data.html#v:constrFields'>constrFields </a>  Constr -> [String] </tt>	Gets the field labels of a constructor
<tt style='background-color:#E8E8E8;'> Data.Data <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Data.html#v:constrFixity'>constrFixity </a>  Constr -> Fixity </tt>	Gets the fixity of a constructor
<tt style='background-color:#E8E8E8;'> Data.Data <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Data.html#v:constrIndex'>constrIndex </a>  Constr -> ConIndex </tt>	Gets the index of a constructor (algebraic datatypes only)
<tt style='background-color:#E8E8E8;'> Data.Data <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Data.html#v:showConstr'>showConstr </a>  Constr -> String </tt>	Gets the string for a constructor
<tt style='background-color:#E8E8E8;'> Data.Data <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Data.html#v:readConstr'>readConstr </a>  DataType -> String -> Maybe Constr </tt>	Lookup a constructor via a string
<tt style='background-color:#E8E8E8;'> Data.Data <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Data.html#v:tyconUQname'>tyconUQname </a>  String -> String </tt>	Gets the unqualified type constructor: drop *
<tt style='background-color:#E8E8E8;'> Data.Data <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Data.html#v:tyconModule'>tyconModule </a>  String -> String </tt>	Gets the module of a type constructor: take *
<tt style='background-color:#E8E8E8;'> Data.Data <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Data.html#v:fromConstr'>fromConstr </a>  Data a => Constr -> a </tt>	Build a term skeleton
<tt style='background-color:#E8E8E8;'> GHC.Natural <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Natural.html#v:NatS#'>NatS# </a>  GmpLimb# -> Natural </tt>	in [0, maxBound::Word]
<tt style='background-color:#E8E8E8;'> GHC.Natural <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Natural.html#v:isValidNatural'>isValidNatural </a>  Natural -> Bool </tt>	Test whether all internal invariants are satisfied by Natural value  This operation is mostly useful for test-suites and/or code which constructs Integer values directly
<tt style='background-color:#E8E8E8;'> GHC.Natural <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Natural.html#v:wordToNatural'>wordToNatural </a>  Word -> Natural </tt>	Construct Natural from Word value
<tt style='background-color:#E8E8E8;'> GHC.Natural <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Natural.html#v:naturalToWordMaybe'>naturalToWordMaybe </a>  Natural -> Maybe Word </tt>	Try downcasting Natural to Word value
<tt style='background-color:#E8E8E8;'> GHC.Natural <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Natural.html#v:minusNaturalMaybe'>minusNaturalMaybe </a>  Natural -> Natural -> Maybe Natural </tt>	Natural subtraction
<tt style='background-color:#E8E8E8;'> GHC.Natural <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Natural.html#v:powModNatural'>powModNatural </a>  Natural -> Natural -> Natural -> Natural </tt>	"powModNatural b e m" computes base b raised to exponent e modulo m
<tt style='background-color:#E8E8E8;'> GHC.RTS.Flags <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-RTS-Flags.html#v:RTSFlags'>RTSFlags </a>  GCFlags -> ConcFlags -> MiscFlags -> DebugFlags -> CCFlags -> ProfFlags -> TraceFlags -> TickyFlags -> RTSFlags </tt>	Accessors to GHC RTS flags
<tt style='background-color:#E8E8E8;'> GHC.RTS.Flags <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-RTS-Flags.html#v:[compact]'>[compact] </a>  GCFlags -> Bool </tt>	True = "compact all the time"
<tt style='background-color:#E8E8E8;'> GHC.RTS.Flags <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-RTS-Flags.html#v:[sweep]'>[sweep] </a>  GCFlags -> Bool </tt>	use "mostly mark-sweep" instead of copying for the oldest generation
<tt style='background-color:#E8E8E8;'> GHC.RTS.Flags <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-RTS-Flags.html#v:[heapBase]'>[heapBase] </a>  GCFlags -> Word </tt>	address to ask the OS for memory
<tt style='background-color:#E8E8E8;'> GHC.RTS.Flags <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-RTS-Flags.html#v:[linkerMemBase]'>[linkerMemBase] </a>  MiscFlags -> Word </tt>	address to ask the OS for memory for the linker, 0 ==&gt; off
<tt style='background-color:#E8E8E8;'> GHC.RTS.Flags <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-RTS-Flags.html#v:[linker]'>[linker] </a>  DebugFlags -> Bool </tt>	l the object linker
<tt style='background-color:#E8E8E8;'> GHC.RTS.Flags <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-RTS-Flags.html#v:[squeeze]'>[squeeze] </a>  DebugFlags -> Bool </tt>	z stack squeezing &amp; lazy blackholing
<tt style='background-color:#E8E8E8;'> GHC.RTS.Flags <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-RTS-Flags.html#v:[hpc]'>[hpc] </a>  DebugFlags -> Bool </tt>	c coverage
<tt style='background-color:#E8E8E8;'> GHC.RTS.Flags <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-RTS-Flags.html#v:[heapProfileInterval]'>[heapProfileInterval] </a>  ProfFlags -> Time </tt>	time between samples
<tt style='background-color:#E8E8E8;'> GHC.RTS.Flags <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-RTS-Flags.html#v:[heapProfileIntervalTicks]'>[heapProfileIntervalTicks] </a>  ProfFlags -> Word </tt>	ticks between samples (derived)
<tt style='background-color:#E8E8E8;'> GHC.RTS.Flags <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-RTS-Flags.html#v:[timestamp]'>[timestamp] </a>  TraceFlags -> Bool </tt>	show timestamp in stderr output
<tt style='background-color:#E8E8E8;'> GHC.RTS.Flags <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-RTS-Flags.html#v:[traceScheduler]'>[traceScheduler] </a>  TraceFlags -> Bool </tt>	trace scheduler events
<tt style='background-color:#E8E8E8;'> GHC.RTS.Flags <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-RTS-Flags.html#v:[traceGc]'>[traceGc] </a>  TraceFlags -> Bool </tt>	trace GC events
<tt style='background-color:#E8E8E8;'> GHC.RTS.Flags <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-RTS-Flags.html#v:[sparksSampled]'>[sparksSampled] </a>  TraceFlags -> Bool </tt>	trace spark events by a sampled method
<tt style='background-color:#E8E8E8;'> GHC.RTS.Flags <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-RTS-Flags.html#v:[sparksFull]'>[sparksFull] </a>  TraceFlags -> Bool </tt>	trace spark events 100% accurately
<tt style='background-color:#E8E8E8;'> GHC.RTS.Flags <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-RTS-Flags.html#v:[user]'>[user] </a>  TraceFlags -> Bool </tt>	trace user events (emitted from Haskell code)
<tt style='background-color:#E8E8E8;'> GHC.Fingerprint <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Fingerprint.html#v:getFileHash'>getFileHash </a>  FilePath -> IO Fingerprint </tt>	Computes the hash of a given file
<tt style='background-color:#E8E8E8;'> GHC.Event <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Event.html#v:getSystemEventManager'>getSystemEventManager </a>  IO (Maybe EventManager) </tt>	Retrieve the system event manager for the capability on which the calling thread is running
<tt style='background-color:#E8E8E8;'> GHC.Event <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Event.html#v:new'>new </a>  IO EventManager </tt>	Create a new event manager
<tt style='background-color:#E8E8E8;'> GHC.Event <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Event.html#v:evtRead'>evtRead </a>  Event </tt>	Data is available to be read
<tt style='background-color:#E8E8E8;'> GHC.Event <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Event.html#v:evtWrite'>evtWrite </a>  Event </tt>	The file descriptor is ready to accept a write
<tt style='background-color:#E8E8E8;'> GHC.Event <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Event.html#v:OneShot'>OneShot </a>  Lifetime </tt>	the registration will be active for only one event
<tt style='background-color:#E8E8E8;'> GHC.Event <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Event.html#v:MultiShot'>MultiShot </a>  Lifetime </tt>	the registration will trigger multiple times
<tt style='background-color:#E8E8E8;'> GHC.Event <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Event.html#v:registerFd'>registerFd </a>  EventManager -> IOCallback -> Fd -> Event -> Lifetime -> IO FdKey </tt>	registerFd mgr cb fd evs lt registers interest in the events evs on the file descriptor fd for lifetime lt
<tt style='background-color:#E8E8E8;'> GHC.Event <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Event.html#v:unregisterFd'>unregisterFd </a>  EventManager -> FdKey -> IO () </tt>	Drop a previous file descriptor registration
<tt style='background-color:#E8E8E8;'> GHC.Event <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Event.html#v:unregisterFd_'>unregisterFd_ </a>  EventManager -> FdKey -> IO Bool </tt>	Drop a previous file descriptor registration, without waking the event manager thread
<tt style='background-color:#E8E8E8;'> GHC.Event <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Event.html#v:closeFd'>closeFd </a>  EventManager -> (Fd -> IO ()) -> Fd -> IO () </tt>	Close a file descriptor in a race-safe way
<tt style='background-color:#E8E8E8;'> GHC.Event <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Event.html#v:registerTimeout'>registerTimeout </a>  TimerManager -> Int -> TimeoutCallback -> IO TimeoutKey </tt>	Register a timeout in the given number of microseconds
<tt style='background-color:#E8E8E8;'> GHC.Event <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Event.html#v:updateTimeout'>updateTimeout </a>  TimerManager -> TimeoutKey -> Int -> IO () </tt>	Update an active timeout to fire in the given number of microseconds
<tt style='background-color:#E8E8E8;'> GHC.Event <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Event.html#v:unregisterTimeout'>unregisterTimeout </a>  TimerManager -> TimeoutKey -> IO () </tt>	Unregister an active timeout
<tt style='background-color:#E8E8E8;'> GHC.TypeLits <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-TypeLits.html#v:someNatVal'>someNatVal </a>  Integer -> Maybe SomeNat </tt>	Convert an integer into an unknown type-level natural
<tt style='background-color:#E8E8E8;'> GHC.TypeLits <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-TypeLits.html#v:someSymbolVal'>someSymbolVal </a>  String -> SomeSymbol </tt>	Convert a string into an unknown type-level symbol
<tt style='background-color:#E8E8E8;'> GHC.IP <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-IP.html#v:ip'>ip </a>  IP x a => a </tt>	The syntax ?x :: a is desugared into IP "x" a
<tt style='background-color:#E8E8E8;'> Prelude <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:False'>False </a>  Bool </tt>	The Prelude: a standard module
<tt style='background-color:#E8E8E8;'> Prelude <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:succ'>succ </a>  Enum a => a -> a </tt>	the successor of a value
<tt style='background-color:#E8E8E8;'> Prelude <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:pred'>pred </a>  Enum a => a -> a </tt>	the predecessor of a value
<tt style='background-color:#E8E8E8;'> Prelude <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:toEnum'>toEnum </a>  Enum a => Int -> a </tt>	Convert from an Int
<tt style='background-color:#E8E8E8;'> Prelude <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:fromEnum'>fromEnum </a>  Enum a => a -> Int </tt>	Convert to an Int
<tt style='background-color:#E8E8E8;'> Prelude <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:enumFrom'>enumFrom </a>  Enum a => a -> [a] </tt>	Used in Haskell's translation of [ n
<tt style='background-color:#E8E8E8;'> Prelude <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:enumFromTo'>enumFromTo </a>  Enum a => a -> a -> [a] </tt>	Used in Haskell's translation of [n
<tt style='background-color:#E8E8E8;'> Prelude <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:minBound'>minBound </a>  Bounded a => a </tt>	The Bounded class is used to name the upper and lower limits of a type
<tt style='background-color:#E8E8E8;'> Prelude <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:(+)'>(+) </a>  Num a => a -> a -> a </tt>	Basic numeric class
<tt style='background-color:#E8E8E8;'> Prelude <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:negate'>negate </a>  Num a => a -> a </tt>	Unary negation
<tt style='background-color:#E8E8E8;'> Prelude <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:abs'>abs </a>  Num a => a -> a </tt>	Absolute value
<tt style='background-color:#E8E8E8;'> Prelude <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:signum'>signum </a>  Num a => a -> a </tt>	Sign of a number
<tt style='background-color:#E8E8E8;'> Prelude <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:fromInteger'>fromInteger </a>  Num a => Integer -> a </tt>	Conversion from an Integer
<tt style='background-color:#E8E8E8;'> Prelude <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:toRational'>toRational </a>  Real a => a -> Rational </tt>	the rational equivalent of its real argument with full precision
<tt style='background-color:#E8E8E8;'> Prelude <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:quot'>quot </a>  Integral a => a -> a -> a </tt>	integer division truncated toward zero
<tt style='background-color:#E8E8E8;'> Prelude <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:rem'>rem </a>  Integral a => a -> a -> a </tt>	integer remainder, satisfying   (x `quot` y)*y + (x `rem` y) == x
<tt style='background-color:#E8E8E8;'> Prelude <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:div'>div </a>  Integral a => a -> a -> a </tt>	integer division truncated toward negative infinity
<tt style='background-color:#E8E8E8;'> Prelude <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:mod'>mod </a>  Integral a => a -> a -> a </tt>	integer modulus, satisfying   (x `div` y)*y + (x `mod` y) == x
<tt style='background-color:#E8E8E8;'> Prelude <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:quotRem'>quotRem </a>  Integral a => a -> a -> (a, a) </tt>	simultaneous quot and rem
<tt style='background-color:#E8E8E8;'> Prelude <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:divMod'>divMod </a>  Integral a => a -> a -> (a, a) </tt>	simultaneous div and mod
<tt style='background-color:#E8E8E8;'> Prelude <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:toInteger'>toInteger </a>  Integral a => a -> Integer </tt>	conversion to Integer
<tt style='background-color:#E8E8E8;'> Prelude <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:(/)'>(/) </a>  Fractional a => a -> a -> a </tt>	fractional division
<tt style='background-color:#E8E8E8;'> Prelude <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:recip'>recip </a>  Fractional a => a -> a </tt>	reciprocal fraction
<tt style='background-color:#E8E8E8;'> Prelude <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:fromRational'>fromRational </a>  Fractional a => Rational -> a </tt>	Conversion from a Rational (that is Ratio Integer)
<tt style='background-color:#E8E8E8;'> Prelude <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:pi'>pi </a>  Floating a => a </tt>	Trigonometric and hyperbolic functions and related functions
<tt style='background-color:#E8E8E8;'> Prelude <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:properFraction'>properFraction </a>  (RealFrac a, Integral b) => a -> (b, a) </tt>	The function properFraction takes a real fractional number x and returns a pair (n,f) such that x = n+f, and:   n is an integral number with the same sign as x; and f is a fraction with the same type and sign as x, and with absolute value less than 1
<tt style='background-color:#E8E8E8;'> Prelude <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:truncate'>truncate </a>  (RealFrac a, Integral b) => a -> b </tt>	truncate x returns the integer nearest x between zero and x
<tt style='background-color:#E8E8E8;'> Prelude <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:round'>round </a>  (RealFrac a, Integral b) => a -> b </tt>	round x returns the nearest integer to x; the even integer if x is equidistant between two integers
<tt style='background-color:#E8E8E8;'> Prelude <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:ceiling'>ceiling </a>  (RealFrac a, Integral b) => a -> b </tt>	ceiling x returns the least integer not less than x
<tt style='background-color:#E8E8E8;'> Prelude <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:floor'>floor </a>  (RealFrac a, Integral b) => a -> b </tt>	floor x returns the greatest integer not greater than x
<tt style='background-color:#E8E8E8;'> Prelude <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:floatRadix'>floatRadix </a>  RealFloat a => a -> Integer </tt>	a constant function, returning the radix of the representation (often 2)
<tt style='background-color:#E8E8E8;'> Prelude <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:floatDigits'>floatDigits </a>  RealFloat a => a -> Int </tt>	a constant function, returning the number of digits of floatRadix in the significand
<tt style='background-color:#E8E8E8;'> Prelude <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:floatRange'>floatRange </a>  RealFloat a => a -> (Int, Int) </tt>	a constant function, returning the lowest and highest values the exponent may assume
<tt style='background-color:#E8E8E8;'> Prelude <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:decodeFloat'>decodeFloat </a>  RealFloat a => a -> (Integer, Int) </tt>	The function decodeFloat applied to a real floating-point number returns the significand expressed as an Integer and an appropriately scaled exponent (an Int)
<tt style='background-color:#E8E8E8;'> Prelude <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:encodeFloat'>encodeFloat </a>  RealFloat a => Integer -> Int -> a </tt>	encodeFloat performs the inverse of decodeFloat in the sense that for finite x with the exception of -0
<tt style='background-color:#E8E8E8;'> Prelude <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:exponent'>exponent </a>  RealFloat a => a -> Int </tt>	exponent corresponds to the second component of decodeFloat
<tt style='background-color:#E8E8E8;'> Prelude <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:significand'>significand </a>  RealFloat a => a -> a </tt>	The first component of decodeFloat, scaled to lie in the open interval (-1,1), either 0
<tt style='background-color:#E8E8E8;'> Prelude <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:scaleFloat'>scaleFloat </a>  RealFloat a => Int -> a -> a </tt>	multiplies a floating-point number by an integer power of the radix
<tt style='background-color:#E8E8E8;'> Prelude <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:isNaN'>isNaN </a>  RealFloat a => a -> Bool </tt>	True if the argument is an IEEE "not-a-number" (NaN) value
<tt style='background-color:#E8E8E8;'> Prelude <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:isInfinite'>isInfinite </a>  RealFloat a => a -> Bool </tt>	True if the argument is an IEEE infinity or negative infinity
<tt style='background-color:#E8E8E8;'> Prelude <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:isDenormalized'>isDenormalized </a>  RealFloat a => a -> Bool </tt>	True if the argument is too small to be represented in normalized format
<tt style='background-color:#E8E8E8;'> Prelude <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:isNegativeZero'>isNegativeZero </a>  RealFloat a => a -> Bool </tt>	True if the argument is an IEEE negative zero
<tt style='background-color:#E8E8E8;'> Prelude <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:isIEEE'>isIEEE </a>  RealFloat a => a -> Bool </tt>	True if the argument is an IEEE floating point number
<tt style='background-color:#E8E8E8;'> Prelude <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:atan2'>atan2 </a>  RealFloat a => a -> a -> a </tt>	a version of arctangent taking two real floating-point arguments
<tt style='background-color:#E8E8E8;'> Prelude <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:subtract'>subtract </a>  (Num a) => a -> a -> a </tt>	the same as flip (-)
<tt style='background-color:#E8E8E8;'> Prelude <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:gcd'>gcd </a>  (Integral a) => a -> a -> a </tt>	gcd x y is the non-negative factor of both x and y of which every common factor of x and y is also a factor; for example gcd 4 2 = 2, gcd (-4) 6 = 2, gcd 0 4 = 4
<tt style='background-color:#E8E8E8;'> Prelude <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:lcm'>lcm </a>  (Integral a) => a -> a -> a </tt>	lcm x y is the smallest positive integer that both x and y divide
<tt style='background-color:#E8E8E8;'> Prelude <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:(^)'>(^) </a>  (Num a, Integral b) => a -> b -> a </tt>	raise a number to a non-negative integral power
<tt style='background-color:#E8E8E8;'> Prelude <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:(^^)'>(^^) </a>  (Fractional a, Integral b) => a -> b -> a </tt>	raise a number to an integral power
<tt style='background-color:#E8E8E8;'> Prelude <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:fromIntegral'>fromIntegral </a>  (Integral a, Num b) => a -> b </tt>	general coercion from integral types
<tt style='background-color:#E8E8E8;'> Prelude <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:realToFrac'>realToFrac </a>  (Real a, Fractional b) => a -> b </tt>	general coercion to fractional types
<tt style='background-color:#E8E8E8;'> Prelude <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:until'>until </a>  (a -> Bool) -> (a -> a) -> a -> a </tt>	until p f yields the result of applying f until p holds
<tt style='background-color:#E8E8E8;'> Prelude <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:asTypeOf'>asTypeOf </a>  a -> a -> a </tt>	asTypeOf is a type-restricted version of const
<tt style='background-color:#E8E8E8;'> Prelude <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:error'>error </a>  [Char] -> a </tt>	error stops execution and displays an error message
<tt style='background-color:#E8E8E8;'> Prelude <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:undefined'>undefined </a>  a </tt>	A special case of error
<tt style='background-color:#E8E8E8;'> Prelude <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:seq'>seq </a>  a -> b -> b </tt>	The value of seq a b is bottom if a is bottom, and otherwise equal to b
<tt style='background-color:#E8E8E8;'> Prelude <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:($!)'>($!) </a>  (a -> b) -> a -> b </tt>	Strict (call-by-value) application operator
<tt style='background-color:#E8E8E8;'> GHC.SrcLoc <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-SrcLoc.html#v:srcLocPackage'>srcLocPackage </a>  SrcLoc -> String </tt>	A single location in the source code
<tt style='background-color:#E8E8E8;'> GHC.Stack <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Stack.html#v:currentCallStack'>currentCallStack </a>  IO [String] </tt>	returns a '[String]' representing the current call stack
<tt style='background-color:#E8E8E8;'> GHC.Stack <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Stack.html#v:whoCreated'>whoCreated </a>  a -> IO [String] </tt>	Get the stack trace attached to an object
<tt style='background-color:#E8E8E8;'> GHC.Stack <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Stack.html#v:errorWithStackTrace'>errorWithStackTrace </a>  String -> a </tt>	Like the function error, but appends a stack trace to the error message if one is available
<tt style='background-color:#E8E8E8;'> GHC.Stack <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Stack.html#v:getCallStack'>getCallStack </a>  CallStack -> [(String, SrcLoc)] </tt>	CallStacks are an alternate method of obtaining the call stack at a given point in the program
<tt style='background-color:#E8E8E8;'> Debug.Trace <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Debug-Trace.html#v:trace'>trace </a>  String -> a -> a </tt>	The trace function outputs the trace message given as its first argument, before returning the second argument as its result
<tt style='background-color:#E8E8E8;'> Debug.Trace <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Debug-Trace.html#v:traceId'>traceId </a>  String -> String </tt>	Like trace but returns the message instead of a third value
<tt style='background-color:#E8E8E8;'> Debug.Trace <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Debug-Trace.html#v:traceShow'>traceShow </a>  (Show a) => a -> b -> b </tt>	Like trace, but uses show on the argument to convert it to a String
<tt style='background-color:#E8E8E8;'> Debug.Trace <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Debug-Trace.html#v:traceShowId'>traceShowId </a>  (Show a) => a -> a </tt>	Like traceShow but returns the shown value instead of a third value
<tt style='background-color:#E8E8E8;'> Debug.Trace <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Debug-Trace.html#v:traceStack'>traceStack </a>  String -> a -> a </tt>	like trace, but additionally prints a call stack if one is available
<tt style='background-color:#E8E8E8;'> Debug.Trace <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Debug-Trace.html#v:traceIO'>traceIO </a>  String -> IO () </tt>	The traceIO function outputs the trace message from the IO monad
<tt style='background-color:#E8E8E8;'> Debug.Trace <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Debug-Trace.html#v:traceM'>traceM </a>  (Monad m) => String -> m () </tt>	Like trace but returning unit in an arbitrary monad
<tt style='background-color:#E8E8E8;'> Debug.Trace <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Debug-Trace.html#v:traceShowM'>traceShowM </a>  (Show a, Monad m) => a -> m () </tt>	Like traceM, but uses show on the argument to convert it to a String
<tt style='background-color:#E8E8E8;'> Debug.Trace <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Debug-Trace.html#v:putTraceMsg'>putTraceMsg </a>  String -> IO () </tt>	Deprecated: Use traceIO
<tt style='background-color:#E8E8E8;'> Debug.Trace <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Debug-Trace.html#v:traceEvent'>traceEvent </a>  String -> a -> a </tt>	The traceEvent function behaves like trace with the difference that the message is emitted to the eventlog, if eventlog profiling is available and enabled at runtime
<tt style='background-color:#E8E8E8;'> Debug.Trace <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Debug-Trace.html#v:traceEventIO'>traceEventIO </a>  String -> IO () </tt>	The traceEventIO function emits a message to the eventlog, if eventlog profiling is available and enabled at runtime
<tt style='background-color:#E8E8E8;'> Debug.Trace <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Debug-Trace.html#v:traceMarker'>traceMarker </a>  String -> a -> a </tt>	The traceMarker function emits a marker to the eventlog, if eventlog profiling is available and enabled at runtime
<tt style='background-color:#E8E8E8;'> Debug.Trace <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Debug-Trace.html#v:traceMarkerIO'>traceMarkerIO </a>  String -> IO () </tt>	The traceMarkerIO function emits a marker to the eventlog, if eventlog profiling is available and enabled at runtime
<tt style='background-color:#E8E8E8;'> GHC.Exts <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Exts.html#v:I#'>I# </a>  Int# -> Int </tt>	A fixed-precision integer type with at least the range [-2^29
<tt style='background-color:#E8E8E8;'> GHC.Exts <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Exts.html#v:W#'>W# </a>  Word# -> Word </tt>	A Word is an unsigned integral type, with the same size as Int
<tt style='background-color:#E8E8E8;'> GHC.Exts <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Exts.html#v:F#'>F# </a>  Float# -> Float </tt>	Single-precision floating point numbers
<tt style='background-color:#E8E8E8;'> GHC.Exts <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Exts.html#v:D#'>D# </a>  Double# -> Double </tt>	Double-precision floating point numbers
<tt style='background-color:#E8E8E8;'> GHC.Exts <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Exts.html#v:C#'>C# </a>  Char# -> Char </tt>	The character type Char is an enumeration whose values represent Unicode (or equivalently ISO/IEC 10646) characters (see http://www
<tt style='background-color:#E8E8E8;'> GHC.Exts <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Exts.html#v:Ptr'>Ptr </a>  Addr# -> Ptr a </tt>	A value of type Ptr a represents a pointer to an object, or an array of objects, which may be marshalled to or from Haskell values of type a
<tt style='background-color:#E8E8E8;'> GHC.Exts <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Exts.html#v:FunPtr'>FunPtr </a>  Addr# -> FunPtr a </tt>	A value of type FunPtr a is a pointer to a function callable from foreign code
<tt style='background-color:#E8E8E8;'> GHC.Exts <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Exts.html#v:shiftL#'>shiftL# </a>  Word# -> Int# -> Word# </tt>	Shift the argument left by the specified number of bits (which must be non-negative)
<tt style='background-color:#E8E8E8;'> GHC.Exts <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Exts.html#v:shiftRL#'>shiftRL# </a>  Word# -> Int# -> Word# </tt>	Shift the argument right by the specified number of bits (which must be non-negative)
<tt style='background-color:#E8E8E8;'> GHC.Exts <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Exts.html#v:iShiftL#'>iShiftL# </a>  Int# -> Int# -> Int# </tt>	Shift the argument left by the specified number of bits (which must be non-negative)
<tt style='background-color:#E8E8E8;'> GHC.Exts <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Exts.html#v:iShiftRA#'>iShiftRA# </a>  Int# -> Int# -> Int# </tt>	Shift the argument right (signed) by the specified number of bits (which must be non-negative)
<tt style='background-color:#E8E8E8;'> GHC.Exts <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Exts.html#v:iShiftRL#'>iShiftRL# </a>  Int# -> Int# -> Int# </tt>	Shift the argument right (unsigned) by the specified number of bits (which must be non-negative)
<tt style='background-color:#E8E8E8;'> GHC.Exts <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Exts.html#v:isTrue#'>isTrue# </a>  Int# -> Bool </tt>	Alias for tagToEnum#
<tt style='background-color:#E8E8E8;'> GHC.Exts <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Exts.html#v:fromString'>fromString </a>  IsString a => String -> a </tt>	Class for string-like datastructures; used by the overloaded string extension (-XOverloadedStrings in GHC)
<tt style='background-color:#E8E8E8;'> GHC.Exts <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Exts.html#v:lazy'>lazy </a>  a -> a </tt>	The lazy function restrains strictness analysis a little
<tt style='background-color:#E8E8E8;'> GHC.Exts <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Exts.html#v:inline'>inline </a>  a -> a </tt>	The call inline f arranges that f is inlined, regardless of its size
<tt style='background-color:#E8E8E8;'> GHC.Exts <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Exts.html#v:coerce'>coerce </a>  Coercible * a b => a -> b </tt>	The function coerce allows you to safely convert between values of types that have the same representation with no run-time overhead
<tt style='background-color:#E8E8E8;'> GHC.Exts <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Exts.html#v:Down'>Down </a>  a -> Down a </tt>	The Down type allows you to reverse sort order conveniently
<tt style='background-color:#E8E8E8;'> GHC.Exts <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Exts.html#v:groupWith'>groupWith </a>  Ord b => (a -> b) -> [a] -> [[a]] </tt>	The groupWith function uses the user supplied function which projects an element out of every list element in order to first sort the input list and then to form groups by equality on these projected elements
<tt style='background-color:#E8E8E8;'> GHC.Exts <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Exts.html#v:sortWith'>sortWith </a>  Ord b => (a -> b) -> [a] -> [a] </tt>	The sortWith function sorts a list of elements using the user supplied function to project something out of each element
<tt style='background-color:#E8E8E8;'> GHC.Exts <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Exts.html#v:the'>the </a>  Eq a => [a] -> a </tt>	the ensures that all the elements of the list are identical and then returns that unique element
<tt style='background-color:#E8E8E8;'> GHC.Exts <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Exts.html#v:traceEvent'>traceEvent </a>  String -> IO () </tt>	Deprecated: Use traceEvent or traceEventIO
<tt style='background-color:#E8E8E8;'> GHC.Exts <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Exts.html#v:currentCallStack'>currentCallStack </a>  IO [String] </tt>	returns a '[String]' representing the current call stack
<tt style='background-color:#E8E8E8;'> GHC.Exts <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Exts.html#v:fromList'>fromList </a>  IsList l => [Item l] -> l </tt>	The fromList function constructs the structure l from the given list of Item l
<tt style='background-color:#E8E8E8;'> GHC.Exts <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Exts.html#v:fromListN'>fromListN </a>  IsList l => Int -> [Item l] -> l </tt>	The fromListN function takes the input list's length as a hint
<tt style='background-color:#E8E8E8;'> GHC.Exts <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Exts.html#v:toList'>toList </a>  IsList l => l -> [Item l] </tt>	The toList function extracts a list of Item l from the structure l
<tt style='background-color:#E8E8E8;'> Control.Monad.Zip <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad-Zip.html#v:mzip'>mzip </a>  MonadZip m => m a -> m b -> m (a, b) </tt>	MonadZip type class
<tt style='background-color:#E8E8E8;'> GHC.StaticPtr <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-StaticPtr.html#v:deRefStaticPtr'>deRefStaticPtr </a>  StaticPtr a -> a </tt>	Dereferences a static pointer
<tt style='background-color:#E8E8E8;'> GHC.StaticPtr <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-StaticPtr.html#v:staticKey'>staticKey </a>  StaticPtr a -> StaticKey </tt>	The StaticKey that can be used to look up the given StaticPtr
<tt style='background-color:#E8E8E8;'> GHC.StaticPtr <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-StaticPtr.html#v:unsafeLookupStaticPtr'>unsafeLookupStaticPtr </a>  StaticKey -> IO (Maybe (StaticPtr a)) </tt>	Looks up a StaticPtr by its StaticKey
<tt style='background-color:#E8E8E8;'> GHC.StaticPtr <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-StaticPtr.html#v:StaticPtrInfo'>StaticPtrInfo </a>  String -> String -> String -> (Int, Int) -> StaticPtrInfo </tt>	Miscelaneous information available for debugging purposes
<tt style='background-color:#E8E8E8;'> GHC.StaticPtr <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-StaticPtr.html#v:[spInfoPackageKey]'>[spInfoPackageKey] </a>  StaticPtrInfo -> String </tt>	Package key of the package where the static pointer is defined
<tt style='background-color:#E8E8E8;'> GHC.StaticPtr <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-StaticPtr.html#v:[spInfoModuleName]'>[spInfoModuleName] </a>  StaticPtrInfo -> String </tt>	Name of the module where the static pointer is defined
<tt style='background-color:#E8E8E8;'> GHC.StaticPtr <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-StaticPtr.html#v:[spInfoName]'>[spInfoName] </a>  StaticPtrInfo -> String </tt>	An internal name that is distinct for every static pointer defined in a given module
<tt style='background-color:#E8E8E8;'> GHC.StaticPtr <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-StaticPtr.html#v:[spInfoSrcLoc]'>[spInfoSrcLoc] </a>  StaticPtrInfo -> (Int, Int) </tt>	Source location of the definition of the static pointer as a (Line, Column) pair
<tt style='background-color:#E8E8E8;'> GHC.StaticPtr <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-StaticPtr.html#v:staticPtrInfo'>staticPtrInfo </a>  StaticPtr a -> StaticPtrInfo </tt>	StaticPtrInfo of the given StaticPtr
<tt style='background-color:#E8E8E8;'> GHC.StaticPtr <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-StaticPtr.html#v:staticPtrKeys'>staticPtrKeys </a>  IO [StaticKey] </tt>	A list of all known keys
<tt style='background-color:#E8E8E8;'> Control.Concurrent.Chan <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent-Chan.html#v:newChan'>newChan </a>  IO (Chan a) </tt>	Build and returns a new instance of Chan
<tt style='background-color:#E8E8E8;'> Control.Concurrent.Chan <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent-Chan.html#v:writeChan'>writeChan </a>  Chan a -> a -> IO () </tt>	Write a value to a Chan
<tt style='background-color:#E8E8E8;'> Control.Concurrent.Chan <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent-Chan.html#v:readChan'>readChan </a>  Chan a -> IO a </tt>	Read the next value from the Chan
<tt style='background-color:#E8E8E8;'> Control.Concurrent.Chan <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent-Chan.html#v:dupChan'>dupChan </a>  Chan a -> IO (Chan a) </tt>	Duplicate a Chan: the duplicate channel begins empty, but data written to either channel from then on will be available from both
<tt style='background-color:#E8E8E8;'> Control.Concurrent.Chan <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent-Chan.html#v:unGetChan'>unGetChan </a>  Chan a -> a -> IO () </tt>	Deprecated: if you need this operation, use Control
<tt style='background-color:#E8E8E8;'> Control.Concurrent.Chan <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent-Chan.html#v:isEmptyChan'>isEmptyChan </a>  Chan a -> IO Bool </tt>	Deprecated: if you need this operation, use Control
<tt style='background-color:#E8E8E8;'> Control.Concurrent.Chan <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent-Chan.html#v:getChanContents'>getChanContents </a>  Chan a -> IO [a] </tt>	Return a lazy list representing the contents of the supplied Chan, much like hGetContents
<tt style='background-color:#E8E8E8;'> Control.Concurrent.Chan <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent-Chan.html#v:writeList2Chan'>writeList2Chan </a>  Chan a -> [a] -> IO () </tt>	Write an entire list of items to a Chan
<tt style='background-color:#E8E8E8;'> Control.Concurrent.QSem <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent-QSem.html#v:newQSem'>newQSem </a>  Int -> IO QSem </tt>	Build a new QSem with a supplied initial quantity
<tt style='background-color:#E8E8E8;'> Control.Concurrent.QSem <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent-QSem.html#v:waitQSem'>waitQSem </a>  QSem -> IO () </tt>	Wait for a unit to become available
<tt style='background-color:#E8E8E8;'> Control.Concurrent.QSem <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent-QSem.html#v:signalQSem'>signalQSem </a>  QSem -> IO () </tt>	Signal that a unit of the QSem is available
<tt style='background-color:#E8E8E8;'> Control.Concurrent.QSemN <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent-QSemN.html#v:newQSemN'>newQSemN </a>  Int -> IO QSemN </tt>	Build a new QSemN with a supplied initial quantity
<tt style='background-color:#E8E8E8;'> Control.Concurrent.QSemN <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent-QSemN.html#v:waitQSemN'>waitQSemN </a>  QSemN -> Int -> IO () </tt>	Wait for the specified quantity to become available
<tt style='background-color:#E8E8E8;'> Control.Concurrent.QSemN <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent-QSemN.html#v:signalQSemN'>signalQSemN </a>  QSemN -> Int -> IO () </tt>	Signal that a given quantity is now available from the QSemN
<tt style='background-color:#E8E8E8;'> Control.Concurrent <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent.html#v:myThreadId'>myThreadId </a>  IO ThreadId </tt>	Returns the ThreadId of the calling thread (GHC only)
<tt style='background-color:#E8E8E8;'> Control.Concurrent <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent.html#v:forkIO'>forkIO </a>  IO () -> IO ThreadId </tt>	Creates a new thread to run the IO computation passed as the first argument, and returns the ThreadId of the newly created thread
<tt style='background-color:#E8E8E8;'> Control.Concurrent <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent.html#v:forkFinally'>forkFinally </a>  IO a -> (Either SomeException a -> IO ()) -> IO ThreadId </tt>	fork a thread and call the supplied function when the thread is about to terminate, with an exception or a returned value
<tt style='background-color:#E8E8E8;'> Control.Concurrent <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent.html#v:killThread'>killThread </a>  ThreadId -> IO () </tt>	killThread raises the ThreadKilled exception in the given thread (GHC only)
<tt style='background-color:#E8E8E8;'> Control.Concurrent <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent.html#v:throwTo'>throwTo </a>  Exception e => ThreadId -> e -> IO () </tt>	throwTo raises an arbitrary exception in the target thread (GHC only)
<tt style='background-color:#E8E8E8;'> Control.Concurrent <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent.html#v:forkOn'>forkOn </a>  Int -> IO () -> IO ThreadId </tt>	Like forkIO, but lets you specify on which capability the thread should run
<tt style='background-color:#E8E8E8;'> Control.Concurrent <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent.html#v:getNumCapabilities'>getNumCapabilities </a>  IO Int </tt>	Returns the number of Haskell threads that can run truly simultaneously (on separate physical processors) at any given time
<tt style='background-color:#E8E8E8;'> Control.Concurrent <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent.html#v:setNumCapabilities'>setNumCapabilities </a>  Int -> IO () </tt>	Set the number of Haskell threads that can run truly simultaneously (on separate physical processors) at any given time
<tt style='background-color:#E8E8E8;'> Control.Concurrent <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent.html#v:threadCapability'>threadCapability </a>  ThreadId -> IO (Int, Bool) </tt>	returns the number of the capability on which the thread is currently running, and a boolean indicating whether the thread is locked to that capability or not
<tt style='background-color:#E8E8E8;'> Control.Concurrent <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent.html#v:yield'>yield </a>  IO () </tt>	The yield action allows (forces, in a co-operative multitasking implementation) a context-switch to any other currently runnable threads (if any), and is occasionally useful when implementing concurrency abstractions
<tt style='background-color:#E8E8E8;'> Control.Concurrent <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent.html#v:threadDelay'>threadDelay </a>  Int -> IO () </tt>	Suspends the current thread for a given number of microseconds (GHC only)
<tt style='background-color:#E8E8E8;'> Control.Concurrent <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent.html#v:threadWaitRead'>threadWaitRead </a>  Fd -> IO () </tt>	Block the current thread until data is available to read on the given file descriptor (GHC only)
<tt style='background-color:#E8E8E8;'> Control.Concurrent <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent.html#v:threadWaitWrite'>threadWaitWrite </a>  Fd -> IO () </tt>	Block the current thread until data can be written to the given file descriptor (GHC only)
<tt style='background-color:#E8E8E8;'> Control.Concurrent <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent.html#v:threadWaitReadSTM'>threadWaitReadSTM </a>  Fd -> IO (STM (), IO ()) </tt>	Returns an STM action that can be used to wait for data to read from a file descriptor
<tt style='background-color:#E8E8E8;'> Control.Concurrent <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent.html#v:threadWaitWriteSTM'>threadWaitWriteSTM </a>  Fd -> IO (STM (), IO ()) </tt>	Returns an STM action that can be used to wait until data can be written to a file descriptor
<tt style='background-color:#E8E8E8;'> Control.Concurrent <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent.html#v:rtsSupportsBoundThreads'>rtsSupportsBoundThreads </a>  Bool </tt>	True if bound threads are supported
<tt style='background-color:#E8E8E8;'> Control.Concurrent <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent.html#v:forkOS'>forkOS </a>  IO () -> IO ThreadId </tt>	Like forkIO, this sparks off a new thread to run the IO computation passed as the first argument, and returns the ThreadId of the newly created thread
<tt style='background-color:#E8E8E8;'> Control.Concurrent <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent.html#v:isCurrentThreadBound'>isCurrentThreadBound </a>  IO Bool </tt>	Returns True if the calling thread is bound, that is, if it is safe to use foreign libraries that rely on thread-local state from the calling thread
<tt style='background-color:#E8E8E8;'> Control.Concurrent <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent.html#v:runInBoundThread'>runInBoundThread </a>  IO a -> IO a </tt>	Run the IO computation passed as the first argument
<tt style='background-color:#E8E8E8;'> Control.Concurrent <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent.html#v:runInUnboundThread'>runInUnboundThread </a>  IO a -> IO a </tt>	Run the IO computation passed as the first argument
<tt style='background-color:#E8E8E8;'> Control.Concurrent <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Concurrent.html#v:mkWeakThreadId'>mkWeakThreadId </a>  ThreadId -> IO (Weak ThreadId) </tt>	make a weak pointer to a ThreadId
<tt style='background-color:#E8E8E8;'> Control.Monad.Instances <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad-Instances.html#v:fmap'>fmap </a>  Functor f => (a -> b) -> f a -> f b </tt>	The Functor class is used for types that can be mapped over
<tt style='background-color:#E8E8E8;'> Control.Monad.Instances <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad-Instances.html#v:(<$)'>(<$) </a>  Functor f => a -> f b -> f a </tt>	Replace all locations in the input with the same value
<tt style='background-color:#E8E8E8;'> Control.Monad.Instances <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad-Instances.html#v:(>>=)'>(>>=) </a>  Monad m => m a -> (a -> m b) -> m b </tt>	Sequentially compose two actions, passing any value produced by the first as an argument to the second
<tt style='background-color:#E8E8E8;'> Control.Monad.Instances <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad-Instances.html#v:(>>)'>(>>) </a>  Monad m => m a -> m b -> m b </tt>	Sequentially compose two actions, discarding any value produced by the first, like sequencing operators (such as the semicolon) in imperative languages
<tt style='background-color:#E8E8E8;'> Control.Monad.Instances <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad-Instances.html#v:return'>return </a>  Monad m => a -> m a </tt>	Inject a value into the monadic type
<tt style='background-color:#E8E8E8;'> Control.Monad.Instances <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad-Instances.html#v:fail'>fail </a>  Monad m => String -> m a </tt>	Fail with a message
<tt style='background-color:#E8E8E8;'> Control.Monad.ST <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad-ST.html#v:fixST'>fixST </a>  (a -> ST s a) -> ST s a </tt>	Allow the result of a state transformer computation to be used (lazily) inside the computation
<tt style='background-color:#E8E8E8;'> Control.Monad.ST <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad-ST.html#v:stToIO'>stToIO </a>  ST RealWorld a -> IO a </tt>	A monad transformer embedding strict state transformers in the IO monad
<tt style='background-color:#E8E8E8;'> Control.Monad.ST.Safe <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad-ST-Safe.html#v:fixST'>fixST </a>  (a -> ST s a) -> ST s a </tt>	Allow the result of a state transformer computation to be used (lazily) inside the computation
<tt style='background-color:#E8E8E8;'> Control.Monad.ST.Safe <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad-ST-Safe.html#v:stToIO'>stToIO </a>  ST RealWorld a -> IO a </tt>	A monad transformer embedding strict state transformers in the IO monad
<tt style='background-color:#E8E8E8;'> Control.Monad.ST.Unsafe <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad-ST-Unsafe.html#v:unsafeInterleaveST'>unsafeInterleaveST </a>  ST s a -> ST s a </tt>	This library provides support for strict state threads, as described in the PLDI '94 paper by John Launchbury and Simon Peyton Jones Lazy Functional State Threads
<tt style='background-color:#E8E8E8;'> Control.Monad.ST.Lazy <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad-ST-Lazy.html#v:fixST'>fixST </a>  (a -> ST s a) -> ST s a </tt>	Allow the result of a state transformer computation to be used (lazily) inside the computation
<tt style='background-color:#E8E8E8;'> Control.Monad.ST.Lazy <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad-ST-Lazy.html#v:strictToLazyST'>strictToLazyST </a>  ST s a -> ST s a </tt>	Convert a strict ST computation into a lazy one
<tt style='background-color:#E8E8E8;'> Control.Monad.ST.Lazy <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad-ST-Lazy.html#v:lazyToStrictST'>lazyToStrictST </a>  ST s a -> ST s a </tt>	Convert a lazy ST computation into a strict one
<tt style='background-color:#E8E8E8;'> Control.Monad.ST.Lazy <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad-ST-Lazy.html#v:stToIO'>stToIO </a>  ST RealWorld a -> IO a </tt>	A monad transformer embedding lazy state transformers in the IO monad
<tt style='background-color:#E8E8E8;'> Control.Monad.ST.Lazy.Safe <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad-ST-Lazy-Safe.html#v:fixST'>fixST </a>  (a -> ST s a) -> ST s a </tt>	Allow the result of a state transformer computation to be used (lazily) inside the computation
<tt style='background-color:#E8E8E8;'> Control.Monad.ST.Lazy.Safe <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad-ST-Lazy-Safe.html#v:strictToLazyST'>strictToLazyST </a>  ST s a -> ST s a </tt>	Convert a strict ST computation into a lazy one
<tt style='background-color:#E8E8E8;'> Control.Monad.ST.Lazy.Safe <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad-ST-Lazy-Safe.html#v:lazyToStrictST'>lazyToStrictST </a>  ST s a -> ST s a </tt>	Convert a lazy ST computation into a strict one
<tt style='background-color:#E8E8E8;'> Control.Monad.ST.Lazy.Safe <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad-ST-Lazy-Safe.html#v:stToIO'>stToIO </a>  ST RealWorld a -> IO a </tt>	A monad transformer embedding lazy state transformers in the IO monad
<tt style='background-color:#E8E8E8;'> Control.Monad.ST.Lazy.Unsafe <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Monad-ST-Lazy-Unsafe.html#v:unsafeInterleaveST'>unsafeInterleaveST </a>  ST s a -> ST s a </tt>	This module presents an identical interface to Control
<tt style='background-color:#E8E8E8;'> Data.Bifunctor <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Bifunctor.html#v:bimap'>bimap </a>  Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d </tt>	Map over both arguments at the same time
<tt style='background-color:#E8E8E8;'> Data.Bifunctor <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Bifunctor.html#v:first'>first </a>  Bifunctor p => (a -> b) -> p a c -> p b c </tt>	Map covariantly over the first argument
<tt style='background-color:#E8E8E8;'> Data.Bifunctor <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Bifunctor.html#v:second'>second </a>  Bifunctor p => (b -> c) -> p a b -> p a c </tt>	Map covariantly over the second argument
<tt style='background-color:#E8E8E8;'> Data.Complex <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Complex.html#v:(:+)'>(:+) </a>  !a -> !a -> Complex a </tt>	forms a complex number from its real and imaginary rectangular components
<tt style='background-color:#E8E8E8;'> Data.Complex <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Complex.html#v:realPart'>realPart </a>  Complex a -> a </tt>	Extracts the real part of a complex number
<tt style='background-color:#E8E8E8;'> Data.Complex <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Complex.html#v:imagPart'>imagPart </a>  Complex a -> a </tt>	Extracts the imaginary part of a complex number
<tt style='background-color:#E8E8E8;'> Data.Complex <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Complex.html#v:mkPolar'>mkPolar </a>  Floating a => a -> a -> Complex a </tt>	Form a complex number from polar components of magnitude and phase
<tt style='background-color:#E8E8E8;'> Data.Complex <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Complex.html#v:cis'>cis </a>  Floating a => a -> Complex a </tt>	cis t is a complex value with magnitude 1 and phase t (modulo 2*pi)
<tt style='background-color:#E8E8E8;'> Data.Complex <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Complex.html#v:polar'>polar </a>  (RealFloat a) => Complex a -> (a, a) </tt>	The function polar takes a complex number and returns a (magnitude, phase) pair in canonical form: the magnitude is nonnegative, and the phase in the range (-pi, pi]; if the magnitude is zero, then so is the phase
<tt style='background-color:#E8E8E8;'> Data.Complex <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Complex.html#v:magnitude'>magnitude </a>  (RealFloat a) => Complex a -> a </tt>	The nonnegative magnitude of a complex number
<tt style='background-color:#E8E8E8;'> Data.Complex <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Complex.html#v:phase'>phase </a>  (RealFloat a) => Complex a -> a </tt>	The phase of a complex number, in the range (-pi, pi]
<tt style='background-color:#E8E8E8;'> Data.Complex <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Complex.html#v:conjugate'>conjugate </a>  Num a => Complex a -> Complex a </tt>	The conjugate of a complex number
<tt style='background-color:#E8E8E8;'> Data.Fixed <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Fixed.html#v:div''>div' </a>  (Real a, Integral b) => a -> a -> b </tt>	generalisation of div to any instance of Real
<tt style='background-color:#E8E8E8;'> Data.Fixed <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Fixed.html#v:mod''>mod' </a>  (Real a) => a -> a -> a </tt>	generalisation of mod to any instance of Real
<tt style='background-color:#E8E8E8;'> Data.Fixed <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Fixed.html#v:divMod''>divMod' </a>  (Real a, Integral b) => a -> a -> (b, a) </tt>	generalisation of divMod to any instance of Real
<tt style='background-color:#E8E8E8;'> Data.Fixed <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Fixed.html#v:showFixed'>showFixed </a>  (HasResolution a) => Bool -> Fixed a -> String </tt>	First arg is whether to chop off trailing zeros
<tt style='background-color:#E8E8E8;'> Data.Functor.Identity <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Functor-Identity.html#v:Identity'>Identity </a>  a -> Identity a </tt>	Identity functor and monad
<tt style='background-color:#E8E8E8;'> Data.Ix <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Ix.html#v:range'>range </a>  Ix a => (a, a) -> [a] </tt>	The list of values in the subrange defined by a bounding pair
<tt style='background-color:#E8E8E8;'> Data.Ix <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Ix.html#v:index'>index </a>  Ix a => (a, a) -> a -> Int </tt>	The position of a subscript in the subrange
<tt style='background-color:#E8E8E8;'> Data.Ix <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Ix.html#v:inRange'>inRange </a>  Ix a => (a, a) -> a -> Bool </tt>	Returns True the given subscript lies in the range defined the bounding pair
<tt style='background-color:#E8E8E8;'> Data.Ix <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Ix.html#v:rangeSize'>rangeSize </a>  Ix a => (a, a) -> Int </tt>	The size of the subrange defined by a bounding pair
<tt style='background-color:#E8E8E8;'> Data.Ratio <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Ratio.html#v:(%)'>(%) </a>  (Integral a) => a -> a -> Ratio a </tt>	Forms the ratio of two integral numbers
<tt style='background-color:#E8E8E8;'> Data.Ratio <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Ratio.html#v:numerator'>numerator </a>  (Integral a) => Ratio a -> a </tt>	Extract the numerator of the ratio in reduced form: the numerator and denominator have no common factor and the denominator is positive
<tt style='background-color:#E8E8E8;'> Data.Ratio <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Ratio.html#v:denominator'>denominator </a>  (Integral a) => Ratio a -> a </tt>	Extract the denominator of the ratio in reduced form: the numerator and denominator have no common factor and the denominator is positive
<tt style='background-color:#E8E8E8;'> Data.Ratio <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Ratio.html#v:approxRational'>approxRational </a>  (RealFrac a) => a -> a -> Rational </tt>	approxRational, applied to two real fractional numbers x and epsilon, returns the simplest rational number within epsilon of x
<tt style='background-color:#E8E8E8;'> Data.STRef <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-STRef.html#v:newSTRef'>newSTRef </a>  a -> ST s (STRef s a) </tt>	Build a new STRef in the current state thread
<tt style='background-color:#E8E8E8;'> Data.STRef <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-STRef.html#v:readSTRef'>readSTRef </a>  STRef s a -> ST s a </tt>	Read the value of an STRef
<tt style='background-color:#E8E8E8;'> Data.STRef <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-STRef.html#v:writeSTRef'>writeSTRef </a>  STRef s a -> a -> ST s () </tt>	Write a new value into an STRef
<tt style='background-color:#E8E8E8;'> Data.STRef <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-STRef.html#v:modifySTRef'>modifySTRef </a>  STRef s a -> (a -> a) -> ST s () </tt>	Mutate the contents of an STRef
<tt style='background-color:#E8E8E8;'> Data.STRef <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-STRef.html#v:modifySTRef''>modifySTRef' </a>  STRef s a -> (a -> a) -> ST s () </tt>	Strict version of modifySTRef
<tt style='background-color:#E8E8E8;'> Data.STRef.Lazy <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-STRef-Lazy.html#v:newSTRef'>newSTRef </a>  a -> ST s (STRef s a) </tt>	a value of type STRef s a is a mutable variable in state thread s, containing a value of type a
<tt style='background-color:#E8E8E8;'> Data.Unique <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Unique.html#v:newUnique'>newUnique </a>  IO Unique </tt>	Creates a new object of type Unique
<tt style='background-color:#E8E8E8;'> Data.Unique <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Unique.html#v:hashUnique'>hashUnique </a>  Unique -> Int </tt>	Hashes a Unique into an Int
<tt style='background-color:#E8E8E8;'> Data.Void <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Void.html#v:absurd'>absurd </a>  Void -> a </tt>	Since Void values logically don't exist, this witnesses the logical reasoning tool of "ex falso quodlibet"
<tt style='background-color:#E8E8E8;'> Data.Void <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Void.html#v:vacuous'>vacuous </a>  Functor f => f Void -> f a </tt>	If Void is uninhabited then any Functor that holds only values of type Void is holding no values
<tt style='background-color:#E8E8E8;'> System.CPUTime <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-CPUTime.html#v:getCPUTime'>getCPUTime </a>  IO Integer </tt>	Computation getCPUTime returns the number of picoseconds CPU time used by the current program
<tt style='background-color:#E8E8E8;'> System.CPUTime <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-CPUTime.html#v:cpuTimePrecision'>cpuTimePrecision </a>  Integer </tt>	The cpuTimePrecision constant is the smallest measurable difference in CPU time that the implementation can record, and is given as an integral number of picoseconds
<tt style='background-color:#E8E8E8;'> System.Console.GetOpt <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-Console-GetOpt.html#v:getOpt'>getOpt </a>  ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String]) </tt>	Process the command-line, and return the list of values that matched (and those that didn't)
<tt style='background-color:#E8E8E8;'> System.Console.GetOpt <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-Console-GetOpt.html#v:getOpt''>getOpt' </a>  ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String], [String]) </tt>	This is almost the same as getOpt, but returns a quadruple consisting of the option arguments, a list of non-options, a list of unrecognized options, and a list of error messages
<tt style='background-color:#E8E8E8;'> System.Console.GetOpt <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-Console-GetOpt.html#v:usageInfo'>usageInfo </a>  String -> [OptDescr a] -> String </tt>	Return a string describing the usage of a command, derived from the header (first argument) and the options described by the second argument
<tt style='background-color:#E8E8E8;'> System.Console.GetOpt <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-Console-GetOpt.html#v:RequireOrder'>RequireOrder </a>  ArgOrder a </tt>	no option processing after first non-option
<tt style='background-color:#E8E8E8;'> System.Console.GetOpt <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-Console-GetOpt.html#v:Permute'>Permute </a>  ArgOrder a </tt>	freely intersperse options and non-options
<tt style='background-color:#E8E8E8;'> System.Console.GetOpt <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-Console-GetOpt.html#v:ReturnInOrder'>ReturnInOrder </a>  (String -> a) -> ArgOrder a </tt>	wrap non-options into options
<tt style='background-color:#E8E8E8;'> System.Console.GetOpt <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-Console-GetOpt.html#v:Option'>Option </a>  [Char] -> [String] -> (ArgDescr a) -> String -> OptDescr a </tt>	Each OptDescr describes a single option
<tt style='background-color:#E8E8E8;'> System.Console.GetOpt <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-Console-GetOpt.html#v:NoArg'>NoArg </a>  a -> ArgDescr a </tt>	no argument expected
<tt style='background-color:#E8E8E8;'> System.Console.GetOpt <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-Console-GetOpt.html#v:ReqArg'>ReqArg </a>  (String -> a) -> String -> ArgDescr a </tt>	option requires argument
<tt style='background-color:#E8E8E8;'> System.Console.GetOpt <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-Console-GetOpt.html#v:OptArg'>OptArg </a>  (Maybe String -> a) -> String -> ArgDescr a </tt>	optional argument
<tt style='background-color:#E8E8E8;'> System.Environment <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-Environment.html#v:getArgs'>getArgs </a>  IO [String] </tt>	Computation getArgs returns a list of the program's command line arguments (not including the program name)
<tt style='background-color:#E8E8E8;'> System.Environment <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-Environment.html#v:getProgName'>getProgName </a>  IO String </tt>	Computation getProgName returns the name of the program as it was invoked
<tt style='background-color:#E8E8E8;'> System.Environment <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-Environment.html#v:getExecutablePath'>getExecutablePath </a>  IO FilePath </tt>	Returns the absolute pathname of the current executable
<tt style='background-color:#E8E8E8;'> System.Environment <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-Environment.html#v:getEnv'>getEnv </a>  String -> IO String </tt>	Computation getEnv var returns the value of the environment variable var
<tt style='background-color:#E8E8E8;'> System.Environment <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-Environment.html#v:lookupEnv'>lookupEnv </a>  String -> IO (Maybe String) </tt>	Return the value of the environment variable var, or Nothing if there is no such value
<tt style='background-color:#E8E8E8;'> System.Environment <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-Environment.html#v:setEnv'>setEnv </a>  String -> String -> IO () </tt>	setEnv name value sets the specified environment variable to value
<tt style='background-color:#E8E8E8;'> System.Environment <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-Environment.html#v:unsetEnv'>unsetEnv </a>  String -> IO () </tt>	unSet name removes the specified environment variable from the environment of the current process
<tt style='background-color:#E8E8E8;'> System.Environment <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-Environment.html#v:withArgs'>withArgs </a>  [String] -> IO a -> IO a </tt>	withArgs args act - while executing action act, have getArgs return args
<tt style='background-color:#E8E8E8;'> System.Environment <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-Environment.html#v:withProgName'>withProgName </a>  String -> IO a -> IO a </tt>	withProgName name act - while executing action act, have getProgName return name
<tt style='background-color:#E8E8E8;'> System.Environment <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-Environment.html#v:getEnvironment'>getEnvironment </a>  IO [(String, String)] </tt>	getEnvironment retrieves the entire environment as a list of (key,value) pairs
<tt style='background-color:#E8E8E8;'> System.Exit <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-Exit.html#v:ExitSuccess'>ExitSuccess </a>  ExitCode </tt>	indicates successful termination;
<tt style='background-color:#E8E8E8;'> System.Exit <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-Exit.html#v:ExitFailure'>ExitFailure </a>  Int -> ExitCode </tt>	indicates program failure with an exit code
<tt style='background-color:#E8E8E8;'> System.Exit <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-Exit.html#v:exitWith'>exitWith </a>  ExitCode -> IO a </tt>	Computation exitWith code throws ExitCode code
<tt style='background-color:#E8E8E8;'> System.Exit <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-Exit.html#v:exitFailure'>exitFailure </a>  IO a </tt>	The computation exitFailure is equivalent to exitWith (ExitFailure exitfail), where exitfail is implementation-dependent
<tt style='background-color:#E8E8E8;'> System.Exit <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-Exit.html#v:exitSuccess'>exitSuccess </a>  IO a </tt>	The computation exitSuccess is equivalent to exitWith ExitSuccess, It terminates the program successfully
<tt style='background-color:#E8E8E8;'> System.Exit <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-Exit.html#v:die'>die </a>  String -> IO a </tt>	Write given error message to stderr and terminate with exitFailure
<tt style='background-color:#E8E8E8;'> System.Info <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-Info.html#v:os'>os </a>  String </tt>	The operating system on which the program is running
<tt style='background-color:#E8E8E8;'> System.Info <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-Info.html#v:arch'>arch </a>  String </tt>	The machine architecture on which the program is running
<tt style='background-color:#E8E8E8;'> System.Info <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-Info.html#v:compilerName'>compilerName </a>  String </tt>	The Haskell implementation with which the program was compiled or is being interpreted
<tt style='background-color:#E8E8E8;'> System.Info <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-Info.html#v:compilerVersion'>compilerVersion </a>  Version </tt>	The version of compilerName with which the program was compiled or is being interpreted
<tt style='background-color:#E8E8E8;'> System.Mem <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-Mem.html#v:performGC'>performGC </a>  IO () </tt>	Triggers an immediate garbage collection
<tt style='background-color:#E8E8E8;'> System.Mem <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-Mem.html#v:performMajorGC'>performMajorGC </a>  IO () </tt>	Triggers an immediate garbage collection
<tt style='background-color:#E8E8E8;'> System.Mem <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-Mem.html#v:performMinorGC'>performMinorGC </a>  IO () </tt>	Triggers an immediate minor garbage collection
<tt style='background-color:#E8E8E8;'> System.Mem.StableName <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-Mem-StableName.html#v:makeStableName'>makeStableName </a>  a -> IO (StableName a) </tt>	Makes a StableName for an arbitrary object
<tt style='background-color:#E8E8E8;'> System.Mem.StableName <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-Mem-StableName.html#v:hashStableName'>hashStableName </a>  StableName a -> Int </tt>	Convert a StableName to an Int
<tt style='background-color:#E8E8E8;'> System.Mem.StableName <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-Mem-StableName.html#v:eqStableName'>eqStableName </a>  StableName a -> StableName b -> Bool </tt>	Equality on StableName that does not require that the types of the arguments match
<tt style='background-color:#E8E8E8;'> System.Mem.Weak <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-Mem-Weak.html#v:mkWeak'>mkWeak </a>  k -> v -> Maybe (IO ()) -> IO (Weak v) </tt>	Establishes a weak pointer to k, with value v and a finalizer
<tt style='background-color:#E8E8E8;'> System.Mem.Weak <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-Mem-Weak.html#v:deRefWeak'>deRefWeak </a>  Weak v -> IO (Maybe v) </tt>	Dereferences a weak pointer
<tt style='background-color:#E8E8E8;'> System.Mem.Weak <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-Mem-Weak.html#v:finalize'>finalize </a>  Weak v -> IO () </tt>	Causes a the finalizer associated with a weak pointer to be run immediately
<tt style='background-color:#E8E8E8;'> System.Mem.Weak <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-Mem-Weak.html#v:mkWeakPtr'>mkWeakPtr </a>  k -> Maybe (IO ()) -> IO (Weak k) </tt>	A specialised version of mkWeak, where the key and the value are the same object:   mkWeakPtr key finalizer = mkWeak key key finalizer
<tt style='background-color:#E8E8E8;'> System.Mem.Weak <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-Mem-Weak.html#v:addFinalizer'>addFinalizer </a>  key -> IO () -> IO () </tt>	A specialised version of mkWeakPtr, where the Weak object returned is simply thrown away (however the finalizer will be remembered by the garbage collector, and will still be run when the key becomes unreachable)
<tt style='background-color:#E8E8E8;'> System.Mem.Weak <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-Mem-Weak.html#v:mkWeakPair'>mkWeakPair </a>  k -> v -> Maybe (IO ()) -> IO (Weak (k, v)) </tt>	A specialised version of mkWeak where the value is actually a pair of the key and value passed to mkWeakPair:   mkWeakPair key val finalizer = mkWeak key (key,val) finalizer   The advantage of this is that the key can be retrieved by deRefWeak in addition to the value
<tt style='background-color:#E8E8E8;'> System.Timeout <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/System-Timeout.html#v:timeout'>timeout </a>  Int -> IO a -> IO (Maybe a) </tt>	Wrap an IO computation to time out and return Nothing in case no result is available within n microseconds (1/10^6 seconds)
<tt style='background-color:#E8E8E8;'> Text.Printf <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Printf.html#v:printf'>printf </a>  (PrintfType r) => String -> r </tt>	Format a variable number of arguments with the C-style formatting string
<tt style='background-color:#E8E8E8;'> Text.Printf <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Printf.html#v:hPrintf'>hPrintf </a>  (HPrintfType r) => Handle -> String -> r </tt>	Similar to printf, except that output is via the specified Handle
<tt style='background-color:#E8E8E8;'> Text.Printf <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Printf.html#v:FieldFormat'>FieldFormat </a>  Maybe Int -> Maybe Int -> Maybe FormatAdjustment -> Maybe FormatSign -> Bool -> String -> Char -> FieldFormat </tt>	Description of field formatting for formatArg
<tt style='background-color:#E8E8E8;'> Text.Printf <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Printf.html#v:[fmtWidth]'>[fmtWidth] </a>  FieldFormat -> Maybe Int </tt>	Total width of the field
<tt style='background-color:#E8E8E8;'> Text.Printf <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Printf.html#v:[fmtPrecision]'>[fmtPrecision] </a>  FieldFormat -> Maybe Int </tt>	Secondary field width specifier
<tt style='background-color:#E8E8E8;'> Text.Printf <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Printf.html#v:[fmtAdjust]'>[fmtAdjust] </a>  FieldFormat -> Maybe FormatAdjustment </tt>	Kind of filling or padding to be done
<tt style='background-color:#E8E8E8;'> Text.Printf <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Printf.html#v:[fmtSign]'>[fmtSign] </a>  FieldFormat -> Maybe FormatSign </tt>	Whether to insist on a plus sign for positive numbers
<tt style='background-color:#E8E8E8;'> Text.Printf <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Printf.html#v:[fmtAlternate]'>[fmtAlternate] </a>  FieldFormat -> Bool </tt>	Indicates an "alternate format"
<tt style='background-color:#E8E8E8;'> Text.Printf <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Printf.html#v:[fmtModifiers]'>[fmtModifiers] </a>  FieldFormat -> String </tt>	Characters that appeared immediately to the left of fmtChar in the format and were accepted by the type's parseFormat
<tt style='background-color:#E8E8E8;'> Text.Printf <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Printf.html#v:[fmtChar]'>[fmtChar] </a>  FieldFormat -> Char </tt>	The format character printf was invoked with
<tt style='background-color:#E8E8E8;'> Text.Printf <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Printf.html#v:LeftAdjust'>LeftAdjust </a>  FormatAdjustment </tt>	Whether to left-adjust or zero-pad a field
<tt style='background-color:#E8E8E8;'> Text.Printf <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Printf.html#v:SignPlus'>SignPlus </a>  FormatSign </tt>	How to handle the sign of a numeric field
<tt style='background-color:#E8E8E8;'> Text.Printf <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Printf.html#v:vFmt'>vFmt </a>  Char -> FieldFormat -> FieldFormat </tt>	Substitute a 'v' format character with the given default format character in the FieldFormat
<tt style='background-color:#E8E8E8;'> Text.Printf <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Printf.html#v:FormatParse'>FormatParse </a>  String -> Char -> String -> FormatParse </tt>	The "format parser" walks over argument-type-specific modifier characters to find the primary format character
<tt style='background-color:#E8E8E8;'> Text.Printf <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Printf.html#v:[fpModifiers]'>[fpModifiers] </a>  FormatParse -> String </tt>	Any modifiers found
<tt style='background-color:#E8E8E8;'> Text.Printf <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Printf.html#v:[fpChar]'>[fpChar] </a>  FormatParse -> Char </tt>	Primary format character
<tt style='background-color:#E8E8E8;'> Text.Printf <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Printf.html#v:[fpRest]'>[fpRest] </a>  FormatParse -> String </tt>	Rest of the format string
<tt style='background-color:#E8E8E8;'> Text.Printf <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Printf.html#v:formatString'>formatString </a>  IsChar a => [a] -> FieldFormatter </tt>	Formatter for String values
<tt style='background-color:#E8E8E8;'> Text.Printf <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Printf.html#v:formatChar'>formatChar </a>  Char -> FieldFormatter </tt>	Formatter for Char values
<tt style='background-color:#E8E8E8;'> Text.Printf <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Printf.html#v:formatInt'>formatInt </a>  (Integral a, Bounded a) => a -> FieldFormatter </tt>	Formatter for Int values
<tt style='background-color:#E8E8E8;'> Text.Printf <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Printf.html#v:formatInteger'>formatInteger </a>  Integer -> FieldFormatter </tt>	Formatter for Integer values
<tt style='background-color:#E8E8E8;'> Text.Printf <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Printf.html#v:formatRealFloat'>formatRealFloat </a>  RealFloat a => a -> FieldFormatter </tt>	Formatter for RealFloat values
<tt style='background-color:#E8E8E8;'> Text.Printf <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Printf.html#v:errorBadFormat'>errorBadFormat </a>  Char -> a </tt>	Calls perror to indicate an unknown format letter for a given type
<tt style='background-color:#E8E8E8;'> Text.Printf <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Printf.html#v:errorShortFormat'>errorShortFormat </a>  a </tt>	Calls perror to indicate that the format string ended early
<tt style='background-color:#E8E8E8;'> Text.Printf <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Printf.html#v:errorMissingArgument'>errorMissingArgument </a>  a </tt>	Calls perror to indicate that there is a missing argument in the argument list
<tt style='background-color:#E8E8E8;'> Text.Printf <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Printf.html#v:errorBadArgument'>errorBadArgument </a>  a </tt>	Calls perror to indicate that there is a type error or similar in the given argument
<tt style='background-color:#E8E8E8;'> Text.Printf <a href='https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Printf.html#v:perror'>perror </a>  String -> a </tt>	Raises an error with a printf-specific prefix on the message string
