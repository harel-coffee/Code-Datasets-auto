haskell	Unsafe	Coerce	b	unsafeCoerce	UNK=a
haskell	Data	Tuple	a	fst	UNK=$tuple_2$ UNK=a UNK=b
haskell	Data	Tuple	b	snd	UNK=$tuple_2$ UNK=a UNK=b
haskell	Data	Tuple	c	curry	UNK=$f_2$ UNK=$tuple_2$ UNK=a UNK=b UNK=c UNK=a UNK=b
haskell	Data	Tuple	UNK	uncurry	UNK=$f_3$ UNK=a UNK=b UNK=c
haskell	Data	Tuple	UNK	swap	UNK=$tuple_2$ UNK=a UNK=b
haskell	Data	Maybe	UNK	Nothing	void
haskell	Data	Maybe	b	maybe	UNK=b UNK=$f_2$ UNK=a UNK=b UNK=Maybe UNK=a
haskell	Data	Maybe	Bool	isJust	UNK=Maybe UNK=a
haskell	Data	Maybe	Bool	isNothing	UNK=Maybe UNK=a
haskell	Data	Maybe	a	fromJust	UNK=Maybe UNK=a
haskell	Data	Maybe	a	fromMaybe	UNK=a UNK=Maybe UNK=a
haskell	Data	Maybe	UNK	listToMaybe	UNK=$list$ UNK=a
haskell	Data	Maybe	UNK	maybeToList	UNK=Maybe UNK=a
haskell	Data	Maybe	UNK	catMaybes	UNK=$list$ UNK=Maybe UNK=a
haskell	Data	Maybe	UNK	mapMaybe	UNK=$f_2$ UNK=a UNK=Maybe UNK=b UNK=$list$ UNK=a
haskell	Text	Show	ShowS	showsPrec	UNK=Int Show=a
haskell	Text	Show	String	show	Show=a
haskell	Text	Show	ShowS	showList	UNK=$list$ Show=a
haskell	Text	Show	ShowS	shows	Show=a
haskell	Text	Show	ShowS	showChar	UNK=Char
haskell	Text	Show	ShowS	showString	UNK=String
haskell	Text	Show	ShowS	showParen	UNK=Bool UNK=ShowS
haskell	Text	Show	ShowS	showListWith	UNK=$f_2$ UNK=a UNK=ShowS UNK=$list$ UNK=a
haskell	Data	Eq	Bool	(==)	Eq=a Eq=a
haskell	Data	Functor	UNK	fmap	UNK=$f_2$ UNK=a UNK=b Functor=f UNK=a
haskell	Data	Functor	UNK	(<$)	UNK=a Functor=f UNK=b
haskell	Data	Functor	UNK	($>)	Functor=f UNK=a UNK=b
haskell	Data	Functor	UNK	(<$>)	UNK=$f_2$ UNK=a UNK=b Functor=f UNK=a
haskell	Data	Functor	Functor	void	Functor=f UNK=a
haskell	Data	Function	a	id	UNK=a
haskell	Data	Function	a	const	UNK=a UNK=b
haskell	Data	Function	c	(DOT)	UNK=$f_2$ UNK=b UNK=c UNK=$f_2$ UNK=a UNK=b UNK=a
haskell	Data	Function	c	flip	UNK=$f_3$ UNK=a UNK=b UNK=c UNK=b UNK=a
haskell	Data	Function	b	($)	UNK=$f_2$ UNK=a UNK=b UNK=a
haskell	Data	Function	b	(&)	UNK=a UNK=$f_2$ UNK=a UNK=b
haskell	Data	Function	a	fix	UNK=$f_2$ UNK=a UNK=a
haskell	Data	Function	c	on	UNK=$f_3$ UNK=b UNK=b UNK=c UNK=$f_2$ UNK=a UNK=b UNK=a UNK=a
haskell	Data	Bool	Bool	False	void
haskell	Data	Bool	Bool	(&&)	UNK=Bool UNK=Bool
haskell	Data	Bool	Bool	(||)	UNK=Bool UNK=Bool
haskell	Data	Bool	Bool	not	UNK=Bool
haskell	Data	Bool	Bool	otherwise	void
haskell	Data	Bool	a	bool	UNK=a UNK=a UNK=Bool
haskell	GHC	Char	Char	chr	UNK=Int
haskell	Data.Bits.(	&	Bits	)	Bits=a Bits=a
haskell	Data.Bits.(	|	Bits	)	Bits=a Bits=a
haskell	Data	Bits	Bits	xor	Bits=a Bits=a
haskell	Data	Bits	Bits	complement	Bits=a
haskell	Data	Bits	Bits	shift	Bits=a UNK=Int
haskell	Data	Bits	Bits	rotate	Bits=a UNK=Int
haskell	Data	Bits	Bits	zeroBits	void
haskell	Data	Bits	Bits	bit	UNK=Int
haskell	Data	Bits	Bits	setBit	Bits=a UNK=Int
haskell	Data	Bits	Bits	clearBit	Bits=a UNK=Int
haskell	Data	Bits	Bits	complementBit	Bits=a UNK=Int
haskell	Data	Bits	Bool	testBit	Bits=a UNK=Int
haskell	Data	Bits	UNK	bitSizeMaybe	Bits=a
haskell	Data	Bits	Bool	isSigned	Bits=a
haskell	Data	Bits	Bits	shiftL	Bits=a UNK=Int
haskell	Data	Bits	Bits	unsafeShiftL	Bits=a UNK=Int
haskell	Data	Bits	Bits	shiftR	Bits=a UNK=Int
haskell	Data	Bits	Bits	unsafeShiftR	Bits=a UNK=Int
haskell	Data	Bits	Bits	rotateL	Bits=a UNK=Int
haskell	Data	Bits	Bits	rotateR	Bits=a UNK=Int
haskell	Data	Bits	Int	popCount	Bits=a
haskell	Data	Bits	Int	finiteBitSize	FiniteBits=b
haskell	Data	Bits	Int	countLeadingZeros	FiniteBits=b
haskell	Data	Bits	Int	countTrailingZeros	FiniteBits=b
haskell	Data	Bits	Bits/Num	bitDefault	UNK=Int
haskell	Data	Bits	Bool	testBitDefault	Bits/Num=a UNK=Int
haskell	Data	Bits	Int	popCountDefault	Bits/Num=a
haskell	Data	Bits	UNK	toIntegralSized	Integral/Bits=a
haskell	Data	Coerce	Coercible	coerce	Coercible=a
haskell	Text.ParserCombinators	ReadP	UNK	get	void
haskell	Text.ParserCombinators	ReadP	UNK	look	void
haskell	Text.ParserCombinators	ReadP	UNK	(+++)	UNK=ReadP UNK=a UNK=ReadP UNK=a
haskell	Text.ParserCombinators	ReadP	UNK	(<++)	UNK=ReadP UNK=a UNK=ReadP UNK=a
haskell	Text.ParserCombinators	ReadP	UNK	gather	UNK=ReadP UNK=a
haskell	Text.ParserCombinators	ReadP	UNK	pfail	void
haskell	Text.ParserCombinators	ReadP	ReadP	eof	void
haskell	Text.ParserCombinators	ReadP	UNK	satisfy	UNK=$f_2$ UNK=Char UNK=Bool
haskell	Text.ParserCombinators	ReadP	UNK	char	UNK=Char
haskell	Text.ParserCombinators	ReadP	UNK	string	UNK=String
haskell	Text.ParserCombinators	ReadP	UNK	munch	UNK=$f_2$ UNK=Char UNK=Bool
haskell	Text.ParserCombinators	ReadP	UNK	munch1	UNK=$f_2$ UNK=Char UNK=Bool
haskell	Text.ParserCombinators	ReadP	ReadP	skipSpaces	void
haskell	Text.ParserCombinators	ReadP	UNK	choice	UNK=$list$ UNK=ReadP UNK=a
haskell	Text.ParserCombinators	ReadP	UNK	count	UNK=Int UNK=ReadP UNK=a
haskell	Text.ParserCombinators	ReadP	UNK	between	UNK=ReadP UNK=open UNK=ReadP UNK=close UNK=ReadP UNK=a
haskell	Text.ParserCombinators	ReadP	UNK	option	UNK=a UNK=ReadP UNK=a
haskell	Text.ParserCombinators	ReadP	ReadP	optional	UNK=ReadP UNK=a
haskell	Text.ParserCombinators	ReadP	UNK	many	UNK=ReadP UNK=a
haskell	Text.ParserCombinators	ReadP	UNK	many1	UNK=ReadP UNK=a
haskell	Text.ParserCombinators	ReadP	ReadP	skipMany	UNK=ReadP UNK=a
haskell	Text.ParserCombinators	ReadP	ReadP	skipMany1	UNK=ReadP UNK=a
haskell	Text.ParserCombinators	ReadP	UNK	sepBy	UNK=ReadP UNK=a UNK=ReadP UNK=sep
haskell	Text.ParserCombinators	ReadP	UNK	sepBy1	UNK=ReadP UNK=a UNK=ReadP UNK=sep
haskell	Text.ParserCombinators	ReadP	UNK	endBy	UNK=ReadP UNK=a UNK=ReadP UNK=sep
haskell	Text.ParserCombinators	ReadP	UNK	endBy1	UNK=ReadP UNK=a UNK=ReadP UNK=sep
haskell	Text.ParserCombinators	ReadP	UNK	chainr	UNK=ReadP UNK=a UNK=ReadP UNK=$f_3$ UNK=a UNK=a UNK=a UNK=a
haskell	Text.ParserCombinators	ReadP	UNK	chainl	UNK=ReadP UNK=a UNK=ReadP UNK=$f_3$ UNK=a UNK=a UNK=a UNK=a
haskell	Text.ParserCombinators	ReadP	UNK	chainl1	UNK=ReadP UNK=a UNK=ReadP UNK=$f_3$ UNK=a UNK=a UNK=a
haskell	Text.ParserCombinators	ReadP	UNK	chainr1	UNK=ReadP UNK=a UNK=ReadP UNK=$f_3$ UNK=a UNK=a UNK=a
haskell	Text.ParserCombinators	ReadP	UNK	manyTill	UNK=ReadP UNK=a UNK=ReadP UNK=end
haskell	Text.ParserCombinators	ReadP	UNK	readP_to_S	UNK=ReadP UNK=a
haskell	Text.ParserCombinators	ReadP	UNK	readS_to_P	UNK=ReadS UNK=a
haskell	Text.ParserCombinators	ReadPrec	Prec	minPrec	void
haskell	Text.ParserCombinators	ReadPrec	UNK	lift	UNK=ReadP UNK=a
haskell	Text.ParserCombinators	ReadPrec	UNK	prec	UNK=Prec UNK=ReadPrec UNK=a
haskell	Text.ParserCombinators	ReadPrec	UNK	step	UNK=ReadPrec UNK=a
haskell	Text.ParserCombinators	ReadPrec	UNK	reset	UNK=ReadPrec UNK=a
haskell	Text.ParserCombinators	ReadPrec	UNK	get	void
haskell	Text.ParserCombinators	ReadPrec	UNK	look	void
haskell	Text.ParserCombinators	ReadPrec	UNK	(+++)	UNK=ReadPrec UNK=a UNK=ReadPrec UNK=a
haskell	Text.ParserCombinators	ReadPrec	UNK	(<++)	UNK=ReadPrec UNK=a UNK=ReadPrec UNK=a
haskell	Text.ParserCombinators	ReadPrec	UNK	pfail	void
haskell	Text.ParserCombinators	ReadPrec	UNK	choice	UNK=$list$ UNK=ReadPrec UNK=a
haskell	Text.Read	Lex	Lexeme	Char	UNK=Char
haskell	Text.Read	Lex	Lexeme	String	UNK=String
haskell	Text.Read	Lex	Lexeme	Punc	UNK=String
haskell	Text.Read	Lex	Lexeme	Ident	UNK=String
haskell	Text.Read	Lex	Lexeme	Symbol	UNK=String
haskell	Text.Read	Lex	UNK	hsLex	void
haskell	Data	Word	Word16	byteSwap16	UNK=Word16
haskell	Data	Word	Word32	byteSwap32	UNK=Word32
haskell	Data	Word	Word64	byteSwap64	UNK=Word64
haskell	Data	Ord	Ordering	compare	Ord=a Ord=a
haskell	Data	Ord	UNK	Down	UNK=a
haskell	Data	Ord	Ordering	comparing	UNK=$f_2$ UNK=b Ord=a UNK=b UNK=b
haskell	Data.Type	Coercion	UNK	Coercion	void
haskell	Data.Type	Coercion	b	coerceWith	UNK=Coercion UNK=a UNK=b UNK=a
haskell	Data.Type	Coercion	UNK	sym	UNK=Coercion UNK=a UNK=b
haskell	Data.Type	Coercion	UNK	trans	UNK=Coercion UNK=a UNK=b UNK=Coercion UNK=b UNK=c
haskell	Data.Type	Coercion	UNK	testCoercion	TestCoercion=f UNK=a TestCoercion=f UNK=b
haskell	Control	Category	UNK	id	void
haskell	Control	Category	UNK	(DOT)	Category=cat UNK=b UNK=c Category=cat UNK=a UNK=b
haskell	Control	Category	UNK	(<<<)	Category=cat UNK=b UNK=c Category=cat UNK=a UNK=b
haskell	Control	Category	UNK	(>>>)	Category=cat UNK=a UNK=b Category=cat UNK=b UNK=c
haskell	Data	Char	Bool	isControl	UNK=Char
haskell	Data	Char	Bool	isSpace	UNK=Char
haskell	Data	Char	Bool	isLower	UNK=Char
haskell	Data	Char	Bool	isUpper	UNK=Char
haskell	Data	Char	Bool	isAlpha	UNK=Char
haskell	Data	Char	Bool	isAlphaNum	UNK=Char
haskell	Data	Char	Bool	isPrint	UNK=Char
haskell	Data	Char	Bool	isDigit	UNK=Char
haskell	Data	Char	Bool	isOctDigit	UNK=Char
haskell	Data	Char	Bool	isHexDigit	UNK=Char
haskell	Data	Char	Bool	isLetter	UNK=Char
haskell	Data	Char	Bool	isMark	UNK=Char
haskell	Data	Char	Bool	isNumber	UNK=Char
haskell	Data	Char	Bool	isPunctuation	UNK=Char
haskell	Data	Char	Bool	isSymbol	UNK=Char
haskell	Data	Char	Bool	isSeparator	UNK=Char
haskell	Data	Char	Bool	isAscii	UNK=Char
haskell	Data	Char	Bool	isLatin1	UNK=Char
haskell	Data	Char	Bool	isAsciiUpper	UNK=Char
haskell	Data	Char	Bool	isAsciiLower	UNK=Char
haskell	Data	Char	GeneralCategory	UppercaseLetter	void
haskell	Data	Char	GeneralCategory	LowercaseLetter	void
haskell	Data	Char	GeneralCategory	TitlecaseLetter	void
haskell	Data	Char	GeneralCategory	ModifierLetter	void
haskell	Data	Char	GeneralCategory	OtherLetter	void
haskell	Data	Char	GeneralCategory	NonSpacingMark	void
haskell	Data	Char	GeneralCategory	SpacingCombiningMark	void
haskell	Data	Char	GeneralCategory	EnclosingMark	void
haskell	Data	Char	GeneralCategory	DecimalNumber	void
haskell	Data	Char	GeneralCategory	LetterNumber	void
haskell	Data	Char	GeneralCategory	OtherNumber	void
haskell	Data	Char	GeneralCategory	ConnectorPunctuation	void
haskell	Data	Char	GeneralCategory	DashPunctuation	void
haskell	Data	Char	GeneralCategory	OpenPunctuation	void
haskell	Data	Char	GeneralCategory	ClosePunctuation	void
haskell	Data	Char	GeneralCategory	InitialQuote	void
haskell	Data	Char	GeneralCategory	FinalQuote	void
haskell	Data	Char	GeneralCategory	OtherPunctuation	void
haskell	Data	Char	GeneralCategory	MathSymbol	void
haskell	Data	Char	GeneralCategory	CurrencySymbol	void
haskell	Data	Char	GeneralCategory	ModifierSymbol	void
haskell	Data	Char	GeneralCategory	OtherSymbol	void
haskell	Data	Char	GeneralCategory	Space	void
haskell	Data	Char	GeneralCategory	LineSeparator	void
haskell	Data	Char	GeneralCategory	ParagraphSeparator	void
haskell	Data	Char	GeneralCategory	Control	void
haskell	Data	Char	GeneralCategory	Format	void
haskell	Data	Char	GeneralCategory	Surrogate	void
haskell	Data	Char	GeneralCategory	PrivateUse	void
haskell	Data	Char	GeneralCategory	NotAssigned	void
haskell	Data	Char	GeneralCategory	generalCategory	UNK=Char
haskell	Data	Char	Char	toUpper	UNK=Char
haskell	Data	Char	Char	toLower	UNK=Char
haskell	Data	Char	Char	toTitle	UNK=Char
haskell	Data	Char	Int	digitToInt	UNK=Char
haskell	Data	Char	Char	intToDigit	UNK=Int
haskell	Data	Char	Int	ord	UNK=Char
haskell	Data	Char	Char	chr	UNK=Int
haskell	Data	Char	ShowS	showLitChar	UNK=Char
haskell	Data	Char	UNK	lexLitChar	void
haskell	Data	Char	UNK	readLitChar	void
haskell	GHC	OldList	Bool	null	UNK=$list$ UNK=a
haskell	GHC	OldList	Int	length	UNK=$list$ UNK=a
haskell	GHC	OldList	b	foldl	UNK=$f_3$ UNK=b UNK=a UNK=b UNK=b UNK=$list$ UNK=a
haskell	GHC	OldList	b	foldl'	UNK=$f_3$ UNK=b UNK=a UNK=b UNK=b UNK=$list$ UNK=a
haskell	GHC	OldList	a	foldl1	UNK=$f_3$ UNK=a UNK=a UNK=a UNK=$list$ UNK=a
haskell	GHC	OldList	b	foldr	UNK=$f_3$ UNK=a UNK=b UNK=b UNK=b UNK=$list$ UNK=a
haskell	GHC	OldList	a	foldr1	UNK=$f_3$ UNK=a UNK=a UNK=a UNK=$list$ UNK=a
haskell	GHC	OldList	UNK	concat	UNK=$list$ UNK=$list$ UNK=a
haskell	GHC	OldList	UNK	concatMap	UNK=$f_2$ UNK=a UNK=$list$ UNK=b UNK=$list$ UNK=a
haskell	GHC	OldList	Bool	and	UNK=$list$ UNK=Bool
haskell	GHC	OldList	Bool	or	UNK=$list$ UNK=Bool
haskell	GHC	OldList	Bool	any	UNK=$f_2$ UNK=a UNK=Bool UNK=$list$ UNK=a
haskell	GHC	OldList	Bool	all	UNK=$f_2$ UNK=a UNK=Bool UNK=$list$ UNK=a
haskell	GHC	OldList	Num	sum	UNK=$list$ Num=a
haskell	GHC	OldList	Num	product	UNK=$list$ Num=a
haskell	GHC	OldList	Ord	maximum	UNK=$list$ Ord=a
haskell	GHC	OldList	Ord	minimum	UNK=$list$ Ord=a
haskell	GHC	OldList	UNK	mapAccumL	UNK=$f_2$ UNK=acc UNK=$tuple_2$ UNK=acc UNK=y UNK=x UNK=acc UNK=$list$ UNK=x
haskell	GHC	OldList	UNK	mapAccumR	UNK=$f_2$ UNK=acc UNK=$tuple_2$ UNK=acc UNK=y UNK=x UNK=acc UNK=$list$ UNK=x
haskell	GHC	OldList	Bool	elem	Eq=a UNK=$list$ Eq=a
haskell	GHC	OldList	UNK	find	UNK=$f_2$ UNK=a UNK=Bool UNK=$list$ UNK=a
haskell	GHC	OldList	a	maximumBy	UNK=$f_3$ UNK=a UNK=a UNK=Ordering UNK=$list$ UNK=a
haskell	GHC	OldList	a	minimumBy	UNK=$f_3$ UNK=a UNK=a UNK=Ordering UNK=$list$ UNK=a
haskell	Data	Proxy	UNK	Proxy	void
haskell	Data	Proxy	a	asProxyTypeOf	UNK=a UNK=Proxy UNK=a
haskell	Data	Proxy	KProxy	KProxy	void
haskell	Numeric	core	ShowS	showSigned	UNK=$f_2$ Real=a UNK=ShowS UNK=Int Real=a
haskell	Numeric	core	ShowS	showIntAtBase	Integral/Show=a UNK=$f_2$ UNK=Int UNK=Char Integral/Show=a
haskell	Numeric	core	ShowS	showInt	Integral=a
haskell	Numeric	core	ShowS	showHex	Integral/Show=a
haskell	Numeric	core	ShowS	showOct	Integral/Show=a
haskell	Numeric	core	ShowS	showEFloat	UNK=Maybe UNK=Int RealFloat=a
haskell	Numeric	core	ShowS	showFFloat	UNK=Maybe UNK=Int RealFloat=a
haskell	Numeric	core	ShowS	showGFloat	UNK=Maybe UNK=Int RealFloat=a
haskell	Numeric	core	ShowS	showFFloatAlt	UNK=Maybe UNK=Int RealFloat=a
haskell	Numeric	core	ShowS	showGFloatAlt	UNK=Maybe UNK=Int RealFloat=a
haskell	Numeric	core	ShowS	showFloat	RealFloat=a
haskell	Numeric	core	UNK	floatToDigits	UNK=Integer RealFloat=a
haskell	Numeric	core	UNK	readSigned	UNK=ReadS Real=a
haskell	Numeric	core	UNK	readInt	Num=a UNK=$f_2$ UNK=Char UNK=Bool UNK=$f_2$ UNK=Char UNK=Int
haskell	Numeric	core	UNK	readDec	void
haskell	Numeric	core	UNK	readOct	void
haskell	Numeric	core	UNK	readHex	void
haskell	Numeric	core	UNK	readFloat	void
haskell	Numeric	core	UNK	lexDigits	void
haskell	Numeric	core	RealFloat	fromRat	UNK=Rational
haskell	Data.Typeable	Internal	UNK	Proxy	void
haskell	Data.Typeable	Internal	TypeRep	typeRep	UNK=proxy Typeable=a
haskell	Data.Typeable	Internal	TyCon	mkTyCon3	UNK=String UNK=String UNK=String
haskell	Data.Typeable	Internal	TypeRep	mkTyConApp	UNK=TyCon UNK=$list$ UNK=TypeRep
haskell	Data.Typeable	Internal	TypeRep	mkPolyTyConApp	UNK=TyCon UNK=$list$ UNK=KindRep UNK=$list$ UNK=TypeRep
haskell	Data.Typeable	Internal	TypeRep	mkAppTy	UNK=TypeRep UNK=TypeRep
haskell	Data.Typeable	Internal	TyCon	typeRepTyCon	UNK=TypeRep
haskell	Data.Typeable	Internal	TypeRep	typeRep#	UNK=Proxy# Typeable=a
haskell	Data.Typeable	Internal	TypeRep	mkFunTy	UNK=TypeRep UNK=TypeRep
haskell	Data.Typeable	Internal	UNK	splitTyConApp	UNK=TypeRep
haskell	Data.Typeable	Internal	UNK	splitPolyTyConApp	UNK=TypeRep
haskell	Data.Typeable	Internal	UNK	funResultTy	UNK=TypeRep UNK=TypeRep
haskell	Data.Typeable	Internal	UNK	typeRepArgs	UNK=TypeRep
haskell	Data.Typeable	Internal	Fingerprint	typeRepFingerprint	UNK=TypeRep
haskell	Data.Typeable	Internal	TypeRep	rnfTypeRep	void
haskell	Data.Typeable	Internal	String	tyConString	UNK=TyCon
haskell	Data.Typeable	Internal	TyCon	rnfTyCon	void
haskell	Data.Typeable	Internal	UNK	typeRepKinds	UNK=TypeRep
haskell	Data.Typeable	Internal	TypeRep	typeLitTypeRep	UNK=String
haskell	Foreign	StablePtr	UNK	newStablePtr	UNK=a
haskell	Foreign	StablePtr	UNK	deRefStablePtr	UNK=StablePtr UNK=a
haskell	Foreign	StablePtr	IO	freeStablePtr	UNK=StablePtr UNK=a
haskell	Foreign	StablePtr	Ptr	castStablePtrToPtr	UNK=StablePtr UNK=a
haskell	Foreign	StablePtr	UNK	castPtrToStablePtr	UNK=Ptr
haskell	Data	Typeable	TypeRep	typeRep	UNK=proxy Typeable=a
haskell	Data	Typeable	UNK	cast	Typeable=a
haskell	Data	Typeable	UNK	gcast	UNK=c Typeable=a
haskell	Data	Typeable	UNK	gcast1	UNK=c Typeable=t UNK=a
haskell	Data	Typeable	UNK	gcast2	UNK=c Typeable=t UNK=a UNK=b
haskell	Data	Typeable	UNK	Proxy	void
haskell	Data	Typeable	Fingerprint	typeRepFingerprint	UNK=TypeRep
haskell	Data	Typeable	TypeRep	rnfTypeRep	void
haskell	Data	Typeable	String	tyConString	UNK=TyCon
haskell	Data	Typeable	TyCon	rnfTyCon	void
haskell	Data	Typeable	TyCon	mkTyCon3	UNK=String UNK=String UNK=String
haskell	Data	Typeable	TypeRep	mkTyConApp	UNK=TyCon UNK=$list$ UNK=TypeRep
haskell	Data	Typeable	TypeRep	mkAppTy	UNK=TypeRep UNK=TypeRep
haskell	Data	Typeable	TypeRep	mkFunTy	UNK=TypeRep UNK=TypeRep
haskell	Data	Typeable	UNK	splitTyConApp	UNK=TypeRep
haskell	Data	Typeable	UNK	funResultTy	UNK=TypeRep UNK=TypeRep
haskell	Data	Typeable	TyCon	typeRepTyCon	UNK=TypeRep
haskell	Data	Typeable	UNK	typeRepArgs	UNK=TypeRep
haskell	Data	Either	UNK	Left	UNK=a
haskell	Data	Either	c	either	UNK=$f_2$ UNK=a UNK=c UNK=$f_2$ UNK=b UNK=c UNK=Either UNK=a UNK=b
haskell	Data	Either	UNK	lefts	UNK=$list$ UNK=Either UNK=a UNK=b
haskell	Data	Either	UNK	rights	UNK=$list$ UNK=Either UNK=a UNK=b
haskell	Data	Either	Bool	isLeft	UNK=Either UNK=a UNK=b
haskell	Data	Either	Bool	isRight	UNK=Either UNK=a UNK=b
haskell	Data	Either	UNK	partitionEithers	UNK=$list$ UNK=Either UNK=a UNK=b
haskell	GHC	Generics	UNK	U1	void
haskell	GHC	Generics	UNK	Par1	UNK=p
haskell	GHC	Generics	UNK	Rec1	UNK=f UNK=p
haskell	GHC	Generics	UNK	K1	UNK=c
haskell	GHC	Generics	UNK	M1	UNK=f UNK=p
haskell	GHC	Generics	UNK	L1	UNK=f UNK=p
haskell	GHC	Generics	UNK	(:*:)	UNK=f UNK=p UNK=g UNK=p
haskell	GHC	Generics	UNK	Comp1	UNK=f UNK=g UNK=p
haskell	GHC	Generics	Fixity	Prefix	void
haskell	GHC	Generics	Associativity	LeftAssociative	void
haskell	GHC	Generics	Arity	NoArity	void
haskell	GHC	Generics	Int	prec	UNK=Fixity
haskell	GHC	Generics	UNK	from	Generic=a
haskell	GHC	Generics	Generic	to	UNK=Rep Generic=a UNK=x
haskell	GHC	Generics	UNK	from1	Generic1=f UNK=a
haskell	GHC	Generics	UNK	to1	UNK=Rep1 Generic1=f UNK=a
haskell	Data	Monoid	Monoid	mempty	void
haskell	Data	Monoid	Monoid	mappend	Monoid=a Monoid=a
haskell	Data	Monoid	Monoid	mconcat	UNK=$list$ Monoid=a
haskell	Data	Monoid	Monoid	(<>)	Monoid=m Monoid=m
haskell	Data	Monoid	UNK	Dual	UNK=a
haskell	Data	Monoid	UNK	Endo	UNK=$f_2$ UNK=a UNK=a
haskell	Data	Monoid	All	All	UNK=Bool
haskell	Data	Monoid	Any	Any	UNK=Bool
haskell	Data	Monoid	UNK	Sum	UNK=a
haskell	Data	Monoid	UNK	Product	UNK=a
haskell	Data	Monoid	UNK	First	UNK=Maybe UNK=a
haskell	Data	Monoid	UNK	Last	UNK=Maybe UNK=a
haskell	Data	Monoid	UNK	Alt	UNK=f UNK=a
haskell	Data	Foldable	Monoid	fold	Foldable=t Monoid=m
haskell	Data	Foldable	Monoid	foldMap	UNK=$f_2$ UNK=a Monoid=m Foldable=t UNK=a
haskell	Data	Foldable	b	foldr	UNK=$f_3$ UNK=a UNK=b UNK=b UNK=b Foldable=t UNK=a
haskell	Data	Foldable	b	foldr'	UNK=$f_3$ UNK=a UNK=b UNK=b UNK=b Foldable=t UNK=a
haskell	Data	Foldable	b	foldl	UNK=$f_3$ UNK=b UNK=a UNK=b UNK=b Foldable=t UNK=a
haskell	Data	Foldable	b	foldl'	UNK=$f_3$ UNK=b UNK=a UNK=b UNK=b Foldable=t UNK=a
haskell	Data	Foldable	a	foldr1	UNK=$f_3$ UNK=a UNK=a UNK=a Foldable=t UNK=a
haskell	Data	Foldable	a	foldl1	UNK=$f_3$ UNK=a UNK=a UNK=a Foldable=t UNK=a
haskell	Data	Foldable	UNK	toList	Foldable=t UNK=a
haskell	Data	Foldable	Bool	null	Foldable=t UNK=a
haskell	Data	Foldable	Int	length	Foldable=t UNK=a
haskell	Data	Foldable	Bool	elem	Eq=a Foldable=t Eq=a
haskell	Data	Foldable	Ord	maximum	Foldable=t Ord=a
haskell	Data	Foldable	Ord	minimum	Foldable=t Ord=a
haskell	Data	Foldable	Num	sum	Foldable=t Num=a
haskell	Data	Foldable	Num	product	Foldable=t Num=a
haskell	Data	Foldable	UNK	foldrM	UNK=$f_3$ UNK=a UNK=b Monad=m UNK=b UNK=b Foldable=t UNK=a
haskell	Data	Foldable	UNK	foldlM	UNK=$f_3$ UNK=b UNK=a Monad=m UNK=b UNK=b Foldable=t UNK=a
haskell	Data	Foldable	Applicative	traverse_	UNK=$f_2$ UNK=a Applicative=f UNK=b Foldable=t UNK=a
haskell	Data	Foldable	Applicative	for_	Foldable=t UNK=a UNK=$f_2$ UNK=a Applicative=f UNK=b
haskell	Data	Foldable	Applicative	sequenceA_	Foldable=t Applicative=f UNK=a
haskell	Data	Foldable	UNK	asum	Foldable=t Alternative=f UNK=a
haskell	Data	Foldable	Monad	mapM_	UNK=$f_2$ UNK=a Monad=m UNK=b Foldable=t UNK=a
haskell	Data	Foldable	Monad	forM_	Foldable=t UNK=a UNK=$f_2$ UNK=a Monad=m UNK=b
haskell	Data	Foldable	Monad	sequence_	Foldable=t Monad=m UNK=a
haskell	Data	Foldable	UNK	msum	Foldable=t MonadPlus=m UNK=a
haskell	Data	Foldable	UNK	concat	Foldable=t UNK=$list$ UNK=a
haskell	Data	Foldable	UNK	concatMap	UNK=$f_2$ UNK=a UNK=$list$ UNK=b Foldable=t UNK=a
haskell	Data	Foldable	Bool	and	Foldable=t UNK=Bool
haskell	Data	Foldable	Bool	or	Foldable=t UNK=Bool
haskell	Data	Foldable	Bool	any	UNK=$f_2$ UNK=a UNK=Bool Foldable=t UNK=a
haskell	Data	Foldable	Bool	all	UNK=$f_2$ UNK=a UNK=Bool Foldable=t UNK=a
haskell	Data	Foldable	a	maximumBy	UNK=$f_3$ UNK=a UNK=a UNK=Ordering Foldable=t UNK=a
haskell	Data	Foldable	a	minimumBy	UNK=$f_3$ UNK=a UNK=a UNK=Ordering Foldable=t UNK=a
haskell	Data	Foldable	Bool	notElem	Eq=a Foldable=t Eq=a
haskell	Data	Foldable	UNK	find	UNK=$f_2$ UNK=a UNK=Bool Foldable=t UNK=a
haskell	Text	Read	UNK	readsPrec	UNK=Int
haskell	Text	Read	UNK	readList	void
haskell	Text	Read	UNK	readPrec	void
haskell	Text	Read	UNK	readListPrec	void
haskell	Text	Read	UNK	reads	void
haskell	Text	Read	Read	read	UNK=String
haskell	Text	Read	UNK	readParen	UNK=Bool UNK=ReadS UNK=a
haskell	Text	Read	UNK	lex	void
haskell	Text	Read	Lexeme	Char	UNK=Char
haskell	Text	Read	Lexeme	String	UNK=String
haskell	Text	Read	Lexeme	Punc	UNK=String
haskell	Text	Read	Lexeme	Ident	UNK=String
haskell	Text	Read	Lexeme	Symbol	UNK=String
haskell	Text	Read	UNK	lexP	void
haskell	Text	Read	UNK	parens	UNK=ReadPrec UNK=a
haskell	Text	Read	UNK	readListDefault	void
haskell	Text	Read	UNK	readListPrecDefault	void
haskell	Text	Read	UNK	readEither	UNK=String
haskell	Text	Read	UNK	readMaybe	UNK=String
haskell	Data	IORef	UNK	newIORef	UNK=a
haskell	Data	IORef	UNK	readIORef	UNK=IORef UNK=a
haskell	Data	IORef	IO	writeIORef	UNK=IORef UNK=a UNK=a
haskell	Data	IORef	IO	modifyIORef	UNK=IORef UNK=a UNK=$f_2$ UNK=a UNK=a
haskell	Data	IORef	IO	modifyIORef'	UNK=IORef UNK=a UNK=$f_2$ UNK=a UNK=a
haskell	Data	IORef	UNK	atomicModifyIORef	UNK=IORef UNK=a UNK=$f_2$ UNK=a UNK=$tuple_2$ UNK=a UNK=b
haskell	Data	IORef	UNK	atomicModifyIORef'	UNK=IORef UNK=a UNK=$f_2$ UNK=a UNK=$tuple_2$ UNK=a UNK=b
haskell	Data	IORef	IO	atomicWriteIORef	UNK=IORef UNK=a UNK=a
haskell	Data	IORef	UNK	mkWeakIORef	UNK=IORef UNK=a UNK=IO
haskell	Foreign.Marshal	Unsafe	a	unsafeLocalState	UNK=IO UNK=a
haskell	Data	Dynamic	Dynamic	toDyn	Typeable=a
haskell	Data	Dynamic	Typeable	fromDyn	UNK=Dynamic Typeable=a
haskell	Data	Dynamic	UNK	fromDynamic	UNK=Dynamic
haskell	Foreign	Storable	Int	sizeOf	Storable=a
haskell	Foreign	Storable	Int	alignment	Storable=a
haskell	Foreign	Storable	UNK	peekElemOff	UNK=Ptr Storable=a UNK=Int
haskell	Foreign	Storable	IO	pokeElemOff	UNK=Ptr Storable=a UNK=Int Storable=a
haskell	Foreign	Storable	UNK	peekByteOff	UNK=Ptr UNK=b UNK=Int
haskell	Foreign	Storable	IO	pokeByteOff	UNK=Ptr UNK=b UNK=Int Storable=a
haskell	Foreign	Storable	UNK	peek	UNK=Ptr Storable=a
haskell	Foreign	Storable	IO	poke	UNK=Ptr Storable=a Storable=a
haskell	Foreign.C	Types	CChar	CChar	UNK=Int8
haskell	Foreign.C	Types	CSChar	CSChar	UNK=Int8
haskell	Foreign.C	Types	CUChar	CUChar	UNK=Word8
haskell	Foreign.C	Types	CShort	CShort	UNK=Int16
haskell	Foreign.C	Types	CUShort	CUShort	UNK=Word16
haskell	Foreign.C	Types	CInt	CInt	UNK=Int32
haskell	Foreign.C	Types	CUInt	CUInt	UNK=Word32
haskell	Foreign.C	Types	CLong	CLong	UNK=Int64
haskell	Foreign.C	Types	CULong	CULong	UNK=Word64
haskell	Foreign.C	Types	CPtrdiff	CPtrdiff	UNK=Int64
haskell	Foreign.C	Types	CSize	CSize	UNK=Word64
haskell	Foreign.C	Types	CWchar	CWchar	UNK=Int32
haskell	Foreign.C	Types	CSigAtomic	CSigAtomic	UNK=Int32
haskell	Foreign.C	Types	CLLong	CLLong	UNK=Int64
haskell	Foreign.C	Types	CULLong	CULLong	UNK=Word64
haskell	Foreign.C	Types	CClock	CClock	UNK=Int64
haskell	Foreign.C	Types	CTime	CTime	UNK=Int64
haskell	Foreign.C	Types	CUSeconds	CUSeconds	UNK=Word32
haskell	Foreign.C	Types	CSUSeconds	CSUSeconds	UNK=Int64
haskell	Foreign.C	Types	CFloat	CFloat	UNK=Float
haskell	Foreign.C	Types	CDouble	CDouble	UNK=Double
haskell	Foreign	Concurrent	UNK	newForeignPtr	UNK=Ptr UNK=a UNK=IO
haskell	Foreign	Concurrent	IO	addForeignPtrFinalizer	UNK=ForeignPtr UNK=a UNK=IO
haskell	Foreign	Ptr	UNK	nullPtr	void
haskell	Foreign	Ptr	UNK	castPtr	UNK=Ptr UNK=a
haskell	Foreign	Ptr	UNK	plusPtr	UNK=Ptr UNK=a UNK=Int
haskell	Foreign	Ptr	UNK	alignPtr	UNK=Ptr UNK=a UNK=Int
haskell	Foreign	Ptr	Int	minusPtr	UNK=Ptr UNK=a UNK=Ptr UNK=b
haskell	Foreign	Ptr	UNK	nullFunPtr	void
haskell	Foreign	Ptr	UNK	castFunPtr	UNK=FunPtr UNK=a
haskell	Foreign	Ptr	UNK	castFunPtrToPtr	UNK=FunPtr UNK=a
haskell	Foreign	Ptr	UNK	castPtrToFunPtr	UNK=Ptr UNK=a
haskell	Foreign	Ptr	IO	freeHaskellFunPtr	UNK=FunPtr UNK=a
haskell	Foreign	Ptr	IntPtr	ptrToIntPtr	UNK=Ptr UNK=a
haskell	Foreign	Ptr	UNK	intPtrToPtr	UNK=IntPtr
haskell	Foreign	Ptr	WordPtr	ptrToWordPtr	UNK=Ptr UNK=a
haskell	Foreign	Ptr	UNK	wordPtrToPtr	UNK=WordPtr
haskell	Foreign	ForeignPtr	UNK	newForeignPtr	UNK=FinalizerPtr UNK=a UNK=Ptr UNK=a
haskell	Foreign	ForeignPtr	UNK	newForeignPtr_	UNK=Ptr UNK=a
haskell	Foreign	ForeignPtr	IO	addForeignPtrFinalizer	UNK=FinalizerPtr UNK=a UNK=ForeignPtr UNK=a
haskell	Foreign	ForeignPtr	UNK	newForeignPtrEnv	UNK=FinalizerEnvPtr UNK=env UNK=a UNK=Ptr UNK=env UNK=Ptr UNK=a
haskell	Foreign	ForeignPtr	IO	addForeignPtrFinalizerEnv	UNK=FinalizerEnvPtr UNK=env UNK=a UNK=Ptr UNK=env UNK=ForeignPtr UNK=a
haskell	Foreign	ForeignPtr	UNK	withForeignPtr	UNK=ForeignPtr UNK=a UNK=$f_2$ UNK=Ptr UNK=a UNK=IO UNK=b
haskell	Foreign	ForeignPtr	IO	finalizeForeignPtr	UNK=ForeignPtr UNK=a
haskell	Foreign	ForeignPtr	IO	touchForeignPtr	UNK=ForeignPtr UNK=a
haskell	Foreign	ForeignPtr	UNK	castForeignPtr	UNK=ForeignPtr UNK=a
haskell	Foreign	ForeignPtr	UNK	mallocForeignPtr	void
haskell	Foreign	ForeignPtr	UNK	mallocForeignPtrBytes	UNK=Int
haskell	Foreign	ForeignPtr	UNK	mallocForeignPtrArray	UNK=Int
haskell	Foreign	ForeignPtr	UNK	mallocForeignPtrArray0	UNK=Int
haskell	Foreign.ForeignPtr	Safe	UNK	newForeignPtr	UNK=FinalizerPtr UNK=a UNK=Ptr UNK=a
haskell	Foreign.ForeignPtr	Safe	UNK	newForeignPtr_	UNK=Ptr UNK=a
haskell	Foreign.ForeignPtr	Safe	IO	addForeignPtrFinalizer	UNK=FinalizerPtr UNK=a UNK=ForeignPtr UNK=a
haskell	Foreign.ForeignPtr	Safe	UNK	newForeignPtrEnv	UNK=FinalizerEnvPtr UNK=env UNK=a UNK=Ptr UNK=env UNK=Ptr UNK=a
haskell	Foreign.ForeignPtr	Safe	IO	addForeignPtrFinalizerEnv	UNK=FinalizerEnvPtr UNK=env UNK=a UNK=Ptr UNK=env UNK=ForeignPtr UNK=a
haskell	Foreign.ForeignPtr	Safe	UNK	withForeignPtr	UNK=ForeignPtr UNK=a UNK=$f_2$ UNK=Ptr UNK=a UNK=IO UNK=b
haskell	Foreign.ForeignPtr	Safe	IO	finalizeForeignPtr	UNK=ForeignPtr UNK=a
haskell	Foreign.ForeignPtr	Safe	IO	touchForeignPtr	UNK=ForeignPtr UNK=a
haskell	Foreign.ForeignPtr	Safe	UNK	castForeignPtr	UNK=ForeignPtr UNK=a
haskell	Foreign.ForeignPtr	Safe	UNK	mallocForeignPtr	void
haskell	Foreign.ForeignPtr	Safe	UNK	mallocForeignPtrBytes	UNK=Int
haskell	Foreign.ForeignPtr	Safe	UNK	mallocForeignPtrArray	UNK=Int
haskell	Foreign.ForeignPtr	Safe	UNK	mallocForeignPtrArray0	UNK=Int
haskell	Foreign.ForeignPtr	Unsafe	UNK	unsafeForeignPtrToPtr	UNK=ForeignPtr UNK=a
haskell	GHC.IO	Buffer	UNK	Buffer	UNK=! UNK=RawBuffer UNK=e UNK=BufferState UNK=!Int UNK=!Int UNK=!Int
haskell	GHC.IO	Buffer	UNK	slideContents	UNK=Buffer UNK=Word8
haskell	GHC.IO.Encoding	Types	UNK	BufferCodec	UNK=CodeBuffer UNK=from UNK=to UNK=$f_2$ UNK=Buffer UNK=from UNK=IO UNK=$tuple_2$ UNK=Buffer UNK=from UNK=Buffer UNK=to UNK=Buffer UNK=to UNK=IO UNK=IO UNK=state UNK=$f_2$ UNK=state UNK=IO
haskell	GHC.IO.Encoding	Types	UNK	[encode]	UNK=BufferCodec UNK=from UNK=to UNK=state
haskell	GHC.IO.Encoding	Types	UNK	[recover]	UNK=BufferCodec UNK=from UNK=to UNK=state UNK=Buffer UNK=from UNK=Buffer UNK=to
haskell	GHC.IO.Encoding	Types	IO	[close]	UNK=BufferCodec UNK=from UNK=to UNK=state
haskell	GHC.IO.Encoding	Types	UNK	[getState]	UNK=BufferCodec UNK=from UNK=to UNK=state
haskell	GHC.IO.Encoding	Types	TextEncoding	TextEncoding	UNK=String UNK=IO UNK=TextDecoder UNK=dstate UNK=IO UNK=TextEncoder UNK=estate
haskell	GHC.IO.Encoding	Types	String	[textEncodingName]	UNK=TextEncoding
haskell	GHC.IO.Encoding	Types	UNK	[mkTextDecoder]	UNK=TextEncoding
haskell	GHC.IO.Encoding	Types	UNK	[mkTextEncoder]	UNK=TextEncoding
haskell	GHC.IO.Encoding	Types	CodingProgress	InputUnderflow	void
haskell	GHC.IO.Encoding	Types	CodingProgress	OutputUnderflow	void
haskell	GHC.IO.Encoding	Types	CodingProgress	InvalidSequence	void
haskell	GHC.IO	Device	UNK	read	RawIO=a UNK=Ptr UNK=Word8 UNK=Int
haskell	GHC.IO	Device	UNK	readNonBlocking	RawIO=a UNK=Ptr UNK=Word8 UNK=Int
haskell	GHC.IO	Device	IO	write	RawIO=a UNK=Ptr UNK=Word8 UNK=Int
haskell	GHC.IO	Device	UNK	writeNonBlocking	RawIO=a UNK=Ptr UNK=Word8 UNK=Int
haskell	GHC.IO	Device	UNK	ready	IODevice=a UNK=Bool UNK=Int
haskell	GHC.IO	Device	IO	close	IODevice=a
haskell	GHC.IO	Device	UNK	isTerminal	IODevice=a
haskell	GHC.IO	Device	UNK	isSeekable	IODevice=a
haskell	GHC.IO	Device	IO	seek	IODevice=a UNK=SeekMode UNK=Integer
haskell	GHC.IO	Device	UNK	tell	IODevice=a
haskell	GHC.IO	Device	UNK	getSize	IODevice=a
haskell	GHC.IO	Device	IO	setSize	IODevice=a UNK=Integer
haskell	GHC.IO	Device	IO	setEcho	IODevice=a UNK=Bool
haskell	GHC.IO	Device	UNK	getEcho	IODevice=a
haskell	GHC.IO	Device	IO	setRaw	IODevice=a UNK=Bool
haskell	GHC.IO	Device	UNK	devType	IODevice=a
haskell	GHC.IO	Device	UNK	dup	IODevice=a
haskell	GHC.IO	Device	UNK	dup2	IODevice=a IODevice=a
haskell	GHC.IO	Device	IODeviceType	Directory	void
haskell	GHC.IO	Device	IODeviceType	Stream	void
haskell	GHC.IO	Device	IODeviceType	RegularFile	void
haskell	GHC.IO	Device	IODeviceType	RawDevice	void
haskell	GHC.IO	Device	SeekMode	AbsoluteSeek	void
haskell	GHC.IO	Device	SeekMode	RelativeSeek	void
haskell	GHC.IO	Device	SeekMode	SeekFromEnd	void
haskell	GHC.IO	BufferedIO	UNK	newBuffer	BufferedIO=dev UNK=BufferState
haskell	GHC.IO	BufferedIO	UNK	fillReadBuffer	BufferedIO=dev UNK=Buffer UNK=Word8
haskell	GHC.IO	BufferedIO	UNK	fillReadBuffer0	BufferedIO=dev UNK=Buffer UNK=Word8
haskell	GHC.IO	BufferedIO	UNK	emptyWriteBuffer	BufferedIO=dev UNK=Buffer UNK=Word8
haskell	GHC.IO	BufferedIO	UNK	flushWriteBuffer	BufferedIO=dev UNK=Buffer UNK=Word8
haskell	GHC.IO	BufferedIO	UNK	flushWriteBuffer0	BufferedIO=dev UNK=Buffer UNK=Word8
haskell	Foreign.Marshal	Alloc	UNK	alloca	UNK=$f_2$ UNK=Ptr Storable=a UNK=IO UNK=b
haskell	Foreign.Marshal	Alloc	UNK	allocaBytes	UNK=Int UNK=$f_2$ UNK=Ptr UNK=a UNK=IO UNK=b
haskell	Foreign.Marshal	Alloc	UNK	malloc	void
haskell	Foreign.Marshal	Alloc	UNK	mallocBytes	UNK=Int
haskell	Foreign.Marshal	Alloc	UNK	calloc	void
haskell	Foreign.Marshal	Alloc	UNK	callocBytes	UNK=Int
haskell	Foreign.Marshal	Alloc	UNK	realloc	UNK=Ptr UNK=a
haskell	Foreign.Marshal	Alloc	UNK	reallocBytes	UNK=Ptr UNK=a UNK=Int
haskell	Foreign.Marshal	Alloc	IO	free	UNK=Ptr UNK=a
haskell	Foreign.Marshal	Alloc	UNK	finalizerFree	void
haskell	Foreign.Marshal	Utils	UNK	with	Storable=a UNK=$f_2$ UNK=Ptr Storable=a UNK=IO UNK=b
haskell	Foreign.Marshal	Utils	UNK	new	Storable=a
haskell	Foreign.Marshal	Utils	Num	fromBool	UNK=Bool
haskell	Foreign.Marshal	Utils	Bool	toBool	Eq/Num=a
haskell	Foreign.Marshal	Utils	UNK	maybePeek	UNK=$f_2$ UNK=Ptr UNK=a UNK=IO UNK=b UNK=Ptr UNK=a
haskell	Foreign.Marshal	Utils	res	withMany	UNK=$f_2$ UNK=a UNK=res UNK=$f_2$ UNK=b UNK=res UNK=$list$ UNK=a UNK=$f_2$ UNK=$list$ UNK=b UNK=res
haskell	Foreign.Marshal	Utils	IO	copyBytes	UNK=Ptr UNK=a UNK=Ptr UNK=a UNK=Int
haskell	Foreign.Marshal	Utils	IO	moveBytes	UNK=Ptr UNK=a UNK=Ptr UNK=a UNK=Int
haskell	Foreign.Marshal	Utils	IO	fillBytes	UNK=Ptr UNK=a UNK=Word8 UNK=Int
haskell	Foreign.Marshal	Array	UNK	mallocArray	UNK=Int
haskell	Foreign.Marshal	Array	UNK	mallocArray0	UNK=Int
haskell	Foreign.Marshal	Array	UNK	allocaArray	UNK=Int UNK=$f_2$ UNK=Ptr Storable=a UNK=IO UNK=b
haskell	Foreign.Marshal	Array	UNK	allocaArray0	UNK=Int UNK=$f_2$ UNK=Ptr Storable=a UNK=IO UNK=b
haskell	Foreign.Marshal	Array	UNK	reallocArray	UNK=Ptr Storable=a UNK=Int
haskell	Foreign.Marshal	Array	UNK	reallocArray0	UNK=Ptr Storable=a UNK=Int
haskell	Foreign.Marshal	Array	UNK	callocArray	UNK=Int
haskell	Foreign.Marshal	Array	UNK	callocArray0	UNK=Int
haskell	Foreign.Marshal	Array	UNK	peekArray	UNK=Int UNK=Ptr Storable=a
haskell	Foreign.Marshal	Array	UNK	peekArray0	Storable/Eq=a UNK=Ptr Storable/Eq=a
haskell	Foreign.Marshal	Array	IO	pokeArray	UNK=Ptr Storable=a UNK=$list$ Storable=a
haskell	Foreign.Marshal	Array	IO	pokeArray0	Storable=a UNK=Ptr Storable=a UNK=$list$ Storable=a
haskell	Foreign.Marshal	Array	UNK	newArray	UNK=$list$ Storable=a
haskell	Foreign.Marshal	Array	UNK	newArray0	Storable=a UNK=$list$ Storable=a
haskell	Foreign.Marshal	Array	UNK	withArray	UNK=$list$ Storable=a UNK=$f_2$ UNK=Ptr Storable=a UNK=IO UNK=b
haskell	Foreign.Marshal	Array	UNK	withArray0	Storable=a UNK=$list$ Storable=a UNK=$f_2$ UNK=Ptr Storable=a UNK=IO UNK=b
haskell	Foreign.Marshal	Array	UNK	withArrayLen	UNK=$list$ Storable=a UNK=$f_3$ UNK=Int UNK=Ptr Storable=a UNK=IO UNK=b
haskell	Foreign.Marshal	Array	UNK	withArrayLen0	Storable=a UNK=$list$ Storable=a UNK=$f_3$ UNK=Int UNK=Ptr Storable=a UNK=IO UNK=b
haskell	Foreign.Marshal	Array	IO	copyArray	UNK=Ptr Storable=a UNK=Ptr Storable=a UNK=Int
haskell	Foreign.Marshal	Array	IO	moveArray	UNK=Ptr Storable=a UNK=Ptr Storable=a UNK=Int
haskell	Foreign.Marshal	Array	UNK	lengthArray0	Storable/Eq=a UNK=Ptr Storable/Eq=a
haskell	Foreign.Marshal	Array	UNK	advancePtr	UNK=Ptr Storable=a UNK=Int
haskell	GHC	Foreign	UNK	peekCString	UNK=TextEncoding UNK=CString
haskell	GHC	Foreign	UNK	peekCStringLen	UNK=TextEncoding UNK=CStringLen
haskell	GHC	Foreign	UNK	newCString	UNK=TextEncoding UNK=String
haskell	GHC	Foreign	UNK	newCStringLen	UNK=TextEncoding UNK=String
haskell	GHC	Foreign	UNK	withCString	UNK=TextEncoding UNK=String UNK=$f_2$ UNK=CString UNK=IO UNK=a
haskell	GHC	Foreign	UNK	withCStringLen	UNK=TextEncoding UNK=String UNK=$f_2$ UNK=CStringLen UNK=IO UNK=a
haskell	GHC	Foreign	UNK	charIsRepresentable	UNK=TextEncoding UNK=Char
haskell	Foreign.C	String	UNK	peekCString	UNK=CString
haskell	Foreign.C	String	UNK	peekCStringLen	UNK=CStringLen
haskell	Foreign.C	String	UNK	newCString	UNK=String
haskell	Foreign.C	String	UNK	newCStringLen	UNK=String
haskell	Foreign.C	String	UNK	withCString	UNK=String UNK=$f_2$ UNK=CString UNK=IO UNK=a
haskell	Foreign.C	String	UNK	withCStringLen	UNK=String UNK=$f_2$ UNK=CStringLen UNK=IO UNK=a
haskell	Foreign.C	String	CChar	castCharToCChar	UNK=Char
haskell	Foreign.C	String	Char	castCCharToChar	UNK=CChar
haskell	Foreign.C	String	CUChar	castCharToCUChar	UNK=Char
haskell	Foreign.C	String	Char	castCUCharToChar	UNK=CUChar
haskell	Foreign.C	String	CSChar	castCharToCSChar	UNK=Char
haskell	Foreign.C	String	Char	castCSCharToChar	UNK=CSChar
haskell	Foreign.C	String	UNK	peekCAString	UNK=CString
haskell	Foreign.C	String	UNK	peekCAStringLen	UNK=CStringLen
haskell	Foreign.C	String	UNK	newCAString	UNK=String
haskell	Foreign.C	String	UNK	newCAStringLen	UNK=String
haskell	Foreign.C	String	UNK	withCAString	UNK=String UNK=$f_2$ UNK=CString UNK=IO UNK=a
haskell	Foreign.C	String	UNK	withCAStringLen	UNK=String UNK=$f_2$ UNK=CStringLen UNK=IO UNK=a
haskell	Foreign.C	String	UNK	peekCWString	UNK=CWString
haskell	Foreign.C	String	UNK	peekCWStringLen	UNK=CWStringLen
haskell	Foreign.C	String	UNK	newCWString	UNK=String
haskell	Foreign.C	String	UNK	newCWStringLen	UNK=String
haskell	Foreign.C	String	UNK	withCWString	UNK=String UNK=$f_2$ UNK=CWString UNK=IO UNK=a
haskell	Foreign.C	String	UNK	withCWStringLen	UNK=String UNK=$f_2$ UNK=CWStringLen UNK=IO UNK=a
haskell	Foreign.Marshal	Error	UNK	throwIf	UNK=$f_2$ UNK=a UNK=Bool UNK=$f_2$ UNK=a UNK=String UNK=IO UNK=a
haskell	Foreign.Marshal	Error	IO	throwIf_	UNK=$f_2$ UNK=a UNK=Bool UNK=$f_2$ UNK=a UNK=String UNK=IO UNK=a
haskell	Foreign.Marshal	Error	UNK	throwIfNeg	UNK=$f_2$ Ord/Num=a UNK=String UNK=IO Ord/Num=a
haskell	Foreign.Marshal	Error	IO	throwIfNeg_	UNK=$f_2$ Ord/Num=a UNK=String UNK=IO Ord/Num=a
haskell	Foreign.Marshal	Error	UNK	throwIfNull	UNK=String UNK=IO UNK=Ptr UNK=a
haskell	Foreign.Marshal	Error	IO	void	UNK=IO UNK=a
haskell	Foreign.Marshal	Pool	UNK	newPool	void
haskell	Foreign.Marshal	Pool	IO	freePool	UNK=Pool
haskell	Foreign.Marshal	Pool	UNK	withPool	UNK=$f_2$ UNK=Pool UNK=IO UNK=b
haskell	Foreign.Marshal	Pool	UNK	pooledMalloc	UNK=Pool
haskell	Foreign.Marshal	Pool	UNK	pooledMallocBytes	UNK=Pool UNK=Int
haskell	Foreign.Marshal	Pool	UNK	pooledRealloc	UNK=Pool UNK=Ptr Storable=a
haskell	Foreign.Marshal	Pool	UNK	pooledReallocBytes	UNK=Pool UNK=Ptr UNK=a UNK=Int
haskell	Foreign.Marshal	Pool	UNK	pooledMallocArray	UNK=Pool UNK=Int
haskell	Foreign.Marshal	Pool	UNK	pooledMallocArray0	UNK=Pool UNK=Int
haskell	Foreign.Marshal	Pool	UNK	pooledReallocArray	UNK=Pool UNK=Ptr Storable=a UNK=Int
haskell	Foreign.Marshal	Pool	UNK	pooledReallocArray0	UNK=Pool UNK=Ptr Storable=a UNK=Int
haskell	Foreign.Marshal	Pool	UNK	pooledNew	UNK=Pool Storable=a
haskell	Foreign.Marshal	Pool	UNK	pooledNewArray	UNK=Pool UNK=$list$ Storable=a
haskell	Foreign.Marshal	Pool	UNK	pooledNewArray0	UNK=Pool Storable=a UNK=$list$ Storable=a
haskell	Foreign.C	Error	Errno	Errno	UNK=CInt
haskell	Foreign.C	Error	Bool	isValidErrno	UNK=Errno
haskell	Foreign.C	Error	UNK	getErrno	void
haskell	Foreign.C	Error	IO	resetErrno	void
haskell	Foreign.C	Error	IOError	errnoToIOError	UNK=String UNK=Errno UNK=Maybe UNK=Handle UNK=Maybe UNK=String
haskell	Foreign.C	Error	UNK	throwErrno	UNK=String
haskell	Foreign.C	Error	UNK	throwErrnoIf	UNK=$f_2$ UNK=a UNK=Bool UNK=String UNK=IO UNK=a
haskell	Foreign.C	Error	IO	throwErrnoIf_	UNK=$f_2$ UNK=a UNK=Bool UNK=String UNK=IO UNK=a
haskell	Foreign.C	Error	UNK	throwErrnoIfRetry	UNK=$f_2$ UNK=a UNK=Bool UNK=String UNK=IO UNK=a
haskell	Foreign.C	Error	IO	throwErrnoIfRetry_	UNK=$f_2$ UNK=a UNK=Bool UNK=String UNK=IO UNK=a
haskell	Foreign.C	Error	UNK	throwErrnoIfMinus1	UNK=String UNK=IO Eq/Num=a
haskell	Foreign.C	Error	IO	throwErrnoIfMinus1_	UNK=String UNK=IO Eq/Num=a
haskell	Foreign.C	Error	UNK	throwErrnoIfMinus1Retry	UNK=String UNK=IO Eq/Num=a
haskell	Foreign.C	Error	IO	throwErrnoIfMinus1Retry_	UNK=String UNK=IO Eq/Num=a
haskell	Foreign.C	Error	UNK	throwErrnoIfNull	UNK=String UNK=IO UNK=Ptr UNK=a
haskell	Foreign.C	Error	UNK	throwErrnoIfNullRetry	UNK=String UNK=IO UNK=Ptr UNK=a
haskell	Foreign.C	Error	UNK	throwErrnoIfRetryMayBlock	UNK=$f_2$ UNK=a UNK=Bool UNK=String UNK=IO UNK=a UNK=IO UNK=b
haskell	Foreign.C	Error	IO	throwErrnoIfRetryMayBlock_	UNK=$f_2$ UNK=a UNK=Bool UNK=String UNK=IO UNK=a UNK=IO UNK=b
haskell	Foreign.C	Error	UNK	throwErrnoIfMinus1RetryMayBlock	UNK=String UNK=IO Eq/Num=a UNK=IO UNK=b
haskell	Foreign.C	Error	IO	throwErrnoIfMinus1RetryMayBlock_	UNK=String UNK=IO Eq/Num=a UNK=IO UNK=b
haskell	Foreign.C	Error	UNK	throwErrnoIfNullRetryMayBlock	UNK=String UNK=IO UNK=Ptr UNK=a UNK=IO UNK=b
haskell	Foreign.C	Error	UNK	throwErrnoPath	UNK=String UNK=FilePath
haskell	Foreign.C	Error	UNK	throwErrnoPathIf	UNK=$f_2$ UNK=a UNK=Bool UNK=String UNK=FilePath UNK=IO UNK=a
haskell	Foreign.C	Error	IO	throwErrnoPathIf_	UNK=$f_2$ UNK=a UNK=Bool UNK=String UNK=FilePath UNK=IO UNK=a
haskell	Foreign.C	Error	UNK	throwErrnoPathIfNull	UNK=String UNK=FilePath UNK=IO UNK=Ptr UNK=a
haskell	Foreign.C	Error	UNK	throwErrnoPathIfMinus1	UNK=String UNK=FilePath UNK=IO Eq/Num=a
haskell	Foreign.C	Error	IO	throwErrnoPathIfMinus1_	UNK=String UNK=FilePath UNK=IO Eq/Num=a
haskell	System.Posix	Types	CDev	CDev	UNK=Word64
haskell	GHC.IO.Encoding	Failure	CodingFailureMode	ErrorOnCodingFailure	void
haskell	GHC.IO.Encoding	Failure	CodingFailureMode	IgnoreCodingFailure	void
haskell	GHC.IO.Encoding	Failure	CodingFailureMode	TransliterateCodingFailure	void
haskell	GHC.IO.Encoding	Failure	CodingFailureMode	RoundtripFailure	void
haskell	GHC.IO.Encoding	Failure	Bool	isSurrogate	UNK=Char
haskell	GHC.IO.Encoding	UTF8	TextEncoding	utf8	void
haskell	GHC.Conc	Sync	ThreadId	ThreadId	UNK=ThreadId#
haskell	GHC.Conc	Sync	UNK	forkIO	UNK=IO
haskell	GHC.Conc	Sync	UNK	forkOn	UNK=Int UNK=IO
haskell	GHC.Conc	Sync	Int	numCapabilities	void
haskell	GHC.Conc	Sync	UNK	getNumCapabilities	void
haskell	GHC.Conc	Sync	IO	setNumCapabilities	UNK=Int
haskell	GHC.Conc	Sync	UNK	getNumProcessors	void
haskell	GHC.Conc	Sync	UNK	numSparks	void
haskell	GHC.Conc	Sync	UNK	myThreadId	void
haskell	GHC.Conc	Sync	IO	killThread	UNK=ThreadId
haskell	GHC.Conc	Sync	IO	throwTo	UNK=ThreadId Exception=e
haskell	GHC.Conc	Sync	IO	runSparks	void
haskell	GHC.Conc	Sync	IO	yield	void
haskell	GHC.Conc	Sync	IO	labelThread	UNK=ThreadId UNK=String
haskell	GHC.Conc	Sync	UNK	mkWeakThreadId	UNK=ThreadId
haskell	GHC.Conc	Sync	ThreadStatus	ThreadRunning	void
haskell	GHC.Conc	Sync	ThreadStatus	ThreadFinished	void
haskell	GHC.Conc	Sync	ThreadStatus	ThreadBlocked	UNK=BlockReason
haskell	GHC.Conc	Sync	ThreadStatus	ThreadDied	void
haskell	GHC.Conc	Sync	BlockReason	BlockedOnMVar	void
haskell	GHC.Conc	Sync	BlockReason	BlockedOnBlackHole	void
haskell	GHC.Conc	Sync	BlockReason	BlockedOnException	void
haskell	GHC.Conc	Sync	BlockReason	BlockedOnSTM	void
haskell	GHC.Conc	Sync	BlockReason	BlockedOnForeignCall	void
haskell	GHC.Conc	Sync	BlockReason	BlockedOnOther	void
haskell	GHC.Conc	Sync	UNK	threadCapability	UNK=ThreadId
haskell	GHC.Conc	Sync	IO	setAllocationCounter	UNK=Int64
haskell	GHC.Conc	Sync	UNK	getAllocationCounter	void
haskell	GHC.Conc	Sync	IO	enableAllocationLimit	void
haskell	GHC.Conc	Sync	IO	disableAllocationLimit	void
haskell	GHC.Conc	Sync	UNK	STM	UNK=$f_2$ UNK=State# UNK=RealWorld UNK=$tuple_2$ UNK=# UNK=State# UNK=RealWorld UNK=a UNK=#
haskell	GHC.Conc	Sync	UNK	atomically	UNK=STM UNK=a
haskell	GHC.Conc	Sync	UNK	retry	void
haskell	GHC.Conc	Sync	UNK	orElse	UNK=STM UNK=a UNK=STM UNK=a
haskell	GHC.Conc	Sync	UNK	throwSTM	Exception=e
haskell	GHC.Conc	Sync	UNK	catchSTM	UNK=STM UNK=a UNK=$f_2$ Exception=e UNK=STM UNK=a
haskell	GHC.Conc	Sync	STM	alwaysSucceeds	UNK=STM UNK=a
haskell	GHC.Conc	Sync	STM	always	UNK=STM UNK=Bool
haskell	GHC.Conc	Sync	UNK	TVar	UNK=TVar# UNK=RealWorld UNK=a
haskell	GHC.Conc	Sync	UNK	newTVar	UNK=a
haskell	GHC.Conc	Sync	UNK	newTVarIO	UNK=a
haskell	GHC.Conc	Sync	UNK	readTVar	UNK=TVar UNK=a
haskell	GHC.Conc	Sync	UNK	readTVarIO	UNK=TVar UNK=a
haskell	GHC.Conc	Sync	STM	writeTVar	UNK=TVar UNK=a UNK=a
haskell	GHC.Conc	Sync	UNK	unsafeIOToSTM	UNK=IO UNK=a
haskell	Control.Exception	Base	SomeException	SomeException	UNK=e
haskell	Control.Exception	Base	SomeException	toException	Exception=e
haskell	Control.Exception	Base	String	displayException	Exception=e
haskell	Control.Exception	Base	ArithException	Overflow	void
haskell	Control.Exception	Base	ArrayException	IndexOutOfBounds	UNK=String
haskell	Control.Exception	Base	ArrayException	UndefinedElement	UNK=String
haskell	Control.Exception	Base	AssertionFailed	AssertionFailed	UNK=String
haskell	Control.Exception	Base	SomeAsyncException	SomeAsyncException	UNK=e
haskell	Control.Exception	Base	AsyncException	StackOverflow	void
haskell	Control.Exception	Base	AsyncException	HeapOverflow	void
haskell	Control.Exception	Base	AsyncException	ThreadKilled	void
haskell	Control.Exception	Base	AsyncException	UserInterrupt	void
haskell	Control.Exception	Base	NonTermination	NonTermination	void
haskell	Control.Exception	Base	NestedAtomically	NestedAtomically	void
haskell	Control.Exception	Base	BlockedIndefinitelyOnMVar	BlockedIndefinitelyOnMVar	void
haskell	Control.Exception	Base	BlockedIndefinitelyOnSTM	BlockedIndefinitelyOnSTM	void
haskell	Control.Exception	Base	AllocationLimitExceeded	AllocationLimitExceeded	void
haskell	Control.Exception	Base	Deadlock	Deadlock	void
haskell	Control.Exception	Base	NoMethodError	NoMethodError	UNK=String
haskell	Control.Exception	Base	PatternMatchFail	PatternMatchFail	UNK=String
haskell	Control.Exception	Base	RecConError	RecConError	UNK=String
haskell	Control.Exception	Base	RecSelError	RecSelError	UNK=String
haskell	Control.Exception	Base	RecUpdError	RecUpdError	UNK=String
haskell	Control.Exception	Base	ErrorCall	ErrorCall	UNK=String
haskell	Control.Exception	Base	UNK	throwIO	Exception=e
haskell	Control.Exception	Base	a	throw	Exception=e
haskell	Control.Exception	Base	UNK	ioError	UNK=IOError
haskell	Control.Exception	Base	IO	throwTo	UNK=ThreadId Exception=e
haskell	Control.Exception	Base	UNK	catch	UNK=IO UNK=a UNK=$f_2$ Exception=e UNK=IO UNK=a
haskell	Control.Exception	Base	UNK	catchJust	UNK=$f_2$ Exception=e UNK=Maybe UNK=b UNK=IO UNK=a UNK=$f_2$ UNK=b UNK=IO UNK=a
haskell	Control.Exception	Base	UNK	handle	UNK=$f_2$ Exception=e UNK=IO UNK=a UNK=IO UNK=a
haskell	Control.Exception	Base	UNK	handleJust	UNK=$f_2$ Exception=e UNK=Maybe UNK=b UNK=$f_2$ UNK=b UNK=IO UNK=a UNK=IO UNK=a
haskell	Control.Exception	Base	UNK	try	UNK=IO UNK=a
haskell	Control.Exception	Base	UNK	tryJust	UNK=$f_2$ Exception=e UNK=Maybe UNK=b UNK=IO UNK=a
haskell	Control.Exception	Base	UNK	onException	UNK=IO UNK=a UNK=IO UNK=b
haskell	Control.Exception	Base	UNK	evaluate	UNK=a
haskell	Control.Exception	Base	a	mapException	UNK=$f_2$ Exception=e1 Exception=e2 UNK=a
haskell	Control.Exception	Base	UNK	mask_	UNK=IO UNK=a
haskell	Control.Exception	Base	UNK	uninterruptibleMask_	UNK=IO UNK=a
haskell	Control.Exception	Base	MaskingState	Unmasked	void
haskell	Control.Exception	Base	MaskingState	MaskedInterruptible	void
haskell	Control.Exception	Base	MaskingState	MaskedUninterruptible	void
haskell	Control.Exception	Base	UNK	getMaskingState	void
haskell	Control.Exception	Base	a	assert	UNK=Bool UNK=a
haskell	Control.Exception	Base	UNK	bracket	UNK=IO UNK=a UNK=$f_2$ UNK=a UNK=IO UNK=b UNK=$f_2$ UNK=a UNK=IO UNK=c
haskell	Control.Exception	Base	UNK	bracket_	UNK=IO UNK=a UNK=IO UNK=b UNK=IO UNK=c
haskell	Control.Exception	Base	UNK	bracketOnError	UNK=IO UNK=a UNK=$f_2$ UNK=a UNK=IO UNK=b UNK=$f_2$ UNK=a UNK=IO UNK=c
haskell	Control.Exception	Base	UNK	finally	UNK=IO UNK=a UNK=IO UNK=b
haskell	Control.Concurrent	MVar	UNK	newEmptyMVar	void
haskell	Control.Concurrent	MVar	UNK	newMVar	UNK=a
haskell	Control.Concurrent	MVar	UNK	takeMVar	UNK=MVar UNK=a
haskell	Control.Concurrent	MVar	IO	putMVar	UNK=MVar UNK=a UNK=a
haskell	Control.Concurrent	MVar	UNK	readMVar	UNK=MVar UNK=a
haskell	Control.Concurrent	MVar	UNK	swapMVar	UNK=MVar UNK=a UNK=a
haskell	Control.Concurrent	MVar	UNK	tryTakeMVar	UNK=MVar UNK=a
haskell	Control.Concurrent	MVar	UNK	tryPutMVar	UNK=MVar UNK=a UNK=a
haskell	Control.Concurrent	MVar	UNK	isEmptyMVar	UNK=MVar UNK=a
haskell	Control.Concurrent	MVar	UNK	withMVar	UNK=MVar UNK=a UNK=$f_2$ UNK=a UNK=IO UNK=b
haskell	Control.Concurrent	MVar	UNK	withMVarMasked	UNK=MVar UNK=a UNK=$f_2$ UNK=a UNK=IO UNK=b
haskell	Control.Concurrent	MVar	IO	modifyMVar_	UNK=MVar UNK=a UNK=$f_2$ UNK=a UNK=IO UNK=a
haskell	Control.Concurrent	MVar	UNK	modifyMVar	UNK=MVar UNK=a UNK=$f_2$ UNK=a UNK=IO UNK=$tuple_2$ UNK=a UNK=b
haskell	Control.Concurrent	MVar	IO	modifyMVarMasked_	UNK=MVar UNK=a UNK=$f_2$ UNK=a UNK=IO UNK=a
haskell	Control.Concurrent	MVar	UNK	modifyMVarMasked	UNK=MVar UNK=a UNK=$f_2$ UNK=a UNK=IO UNK=$tuple_2$ UNK=a UNK=b
haskell	Control.Concurrent	MVar	UNK	tryReadMVar	UNK=MVar UNK=a
haskell	Control.Concurrent	MVar	UNK	mkWeakMVar	UNK=MVar UNK=a UNK=IO
haskell	Control.Concurrent	MVar	IO	addMVarFinalizer	UNK=MVar UNK=a UNK=IO
haskell	Control	Exception	SomeException	SomeException	UNK=e
haskell	Control	Exception	SomeException	toException	Exception=e
haskell	Control	Exception	String	displayException	Exception=e
haskell	Control	Exception	ArithException	Overflow	void
haskell	Control	Exception	ArrayException	IndexOutOfBounds	UNK=String
haskell	Control	Exception	ArrayException	UndefinedElement	UNK=String
haskell	Control	Exception	AssertionFailed	AssertionFailed	UNK=String
haskell	Control	Exception	SomeAsyncException	SomeAsyncException	UNK=e
haskell	Control	Exception	AsyncException	StackOverflow	void
haskell	Control	Exception	AsyncException	HeapOverflow	void
haskell	Control	Exception	AsyncException	ThreadKilled	void
haskell	Control	Exception	AsyncException	UserInterrupt	void
haskell	Control	Exception	NonTermination	NonTermination	void
haskell	Control	Exception	NestedAtomically	NestedAtomically	void
haskell	Control	Exception	BlockedIndefinitelyOnMVar	BlockedIndefinitelyOnMVar	void
haskell	Control	Exception	BlockedIndefinitelyOnSTM	BlockedIndefinitelyOnSTM	void
haskell	Control	Exception	AllocationLimitExceeded	AllocationLimitExceeded	void
haskell	Control	Exception	Deadlock	Deadlock	void
haskell	Control	Exception	NoMethodError	NoMethodError	UNK=String
haskell	Control	Exception	PatternMatchFail	PatternMatchFail	UNK=String
haskell	Control	Exception	RecConError	RecConError	UNK=String
haskell	Control	Exception	RecSelError	RecSelError	UNK=String
haskell	Control	Exception	RecUpdError	RecUpdError	UNK=String
haskell	Control	Exception	ErrorCall	ErrorCall	UNK=String
haskell	Control	Exception	a	throw	Exception=e
haskell	Control	Exception	UNK	throwIO	Exception=e
haskell	Control	Exception	UNK	ioError	UNK=IOError
haskell	Control	Exception	IO	throwTo	UNK=ThreadId Exception=e
haskell	Control	Exception	UNK	catch	UNK=IO UNK=a UNK=$f_2$ Exception=e UNK=IO UNK=a
haskell	Control	Exception	UNK	catches	UNK=IO UNK=a UNK=$list$ UNK=Handler UNK=a
haskell	Control	Exception	UNK	Handler	UNK=$f_2$ UNK=e UNK=IO UNK=a
haskell	Control	Exception	UNK	catchJust	UNK=$f_2$ Exception=e UNK=Maybe UNK=b UNK=IO UNK=a UNK=$f_2$ UNK=b UNK=IO UNK=a
haskell	Control	Exception	UNK	handle	UNK=$f_2$ Exception=e UNK=IO UNK=a UNK=IO UNK=a
haskell	Control	Exception	UNK	handleJust	UNK=$f_2$ Exception=e UNK=Maybe UNK=b UNK=$f_2$ UNK=b UNK=IO UNK=a UNK=IO UNK=a
haskell	Control	Exception	UNK	try	UNK=IO UNK=a
haskell	Control	Exception	UNK	tryJust	UNK=$f_2$ Exception=e UNK=Maybe UNK=b UNK=IO UNK=a
haskell	Control	Exception	UNK	evaluate	UNK=a
haskell	Control	Exception	a	mapException	UNK=$f_2$ Exception=e1 Exception=e2 UNK=a
haskell	Control	Exception	UNK	mask_	UNK=IO UNK=a
haskell	Control	Exception	UNK	uninterruptibleMask_	UNK=IO UNK=a
haskell	Control	Exception	MaskingState	Unmasked	void
haskell	Control	Exception	MaskingState	MaskedInterruptible	void
haskell	Control	Exception	MaskingState	MaskedUninterruptible	void
haskell	Control	Exception	UNK	getMaskingState	void
haskell	Control	Exception	IO	allowInterrupt	void
haskell	Control	Exception	a	assert	UNK=Bool UNK=a
haskell	Control	Exception	UNK	bracket	UNK=IO UNK=a UNK=$f_2$ UNK=a UNK=IO UNK=b UNK=$f_2$ UNK=a UNK=IO UNK=c
haskell	Control	Exception	UNK	bracket_	UNK=IO UNK=a UNK=IO UNK=b UNK=IO UNK=c
haskell	Control	Exception	UNK	bracketOnError	UNK=IO UNK=a UNK=$f_2$ UNK=a UNK=IO UNK=b UNK=$f_2$ UNK=a UNK=IO UNK=c
haskell	Control	Exception	UNK	finally	UNK=IO UNK=a UNK=IO UNK=b
haskell	Control	Exception	UNK	onException	UNK=IO UNK=a UNK=IO UNK=b
haskell	System.IO	Unsafe	a	unsafePerformIO	UNK=IO UNK=a
haskell	System.IO	Unsafe	a	unsafeDupablePerformIO	UNK=IO UNK=a
haskell	System.IO	Unsafe	UNK	unsafeInterleaveIO	UNK=IO UNK=a
haskell	System.IO	Unsafe	UNK	unsafeFixIO	UNK=$f_2$ UNK=a UNK=IO UNK=a
haskell	GHC.IO.Encoding	Latin1	TextEncoding	latin1	void
haskell	GHC.IO.Encoding	UTF16	TextEncoding	utf16	void
haskell	GHC.IO.Encoding	UTF32	TextEncoding	utf32	void
haskell	GHC.IO	Encoding	UNK	BufferCodec	UNK=CodeBuffer UNK=from UNK=to UNK=$f_2$ UNK=Buffer UNK=from UNK=IO UNK=$tuple_2$ UNK=Buffer UNK=from UNK=Buffer UNK=to UNK=Buffer UNK=to UNK=IO UNK=IO UNK=state UNK=$f_2$ UNK=state UNK=IO
haskell	GHC.IO	Encoding	UNK	[encode]	UNK=BufferCodec UNK=from UNK=to UNK=state
haskell	GHC.IO	Encoding	UNK	[recover]	UNK=BufferCodec UNK=from UNK=to UNK=state UNK=Buffer UNK=from UNK=Buffer UNK=to
haskell	GHC.IO	Encoding	IO	[close]	UNK=BufferCodec UNK=from UNK=to UNK=state
haskell	GHC.IO	Encoding	UNK	[getState]	UNK=BufferCodec UNK=from UNK=to UNK=state
haskell	GHC.IO	Encoding	TextEncoding	TextEncoding	UNK=String UNK=IO UNK=TextDecoder UNK=dstate UNK=IO UNK=TextEncoder UNK=estate
haskell	GHC.IO	Encoding	String	[textEncodingName]	UNK=TextEncoding
haskell	GHC.IO	Encoding	UNK	[mkTextDecoder]	UNK=TextEncoding
haskell	GHC.IO	Encoding	UNK	[mkTextEncoder]	UNK=TextEncoding
haskell	GHC.IO	Encoding	CodingProgress	InputUnderflow	void
haskell	GHC.IO	Encoding	CodingProgress	OutputUnderflow	void
haskell	GHC.IO	Encoding	CodingProgress	InvalidSequence	void
haskell	GHC.IO	Encoding	TextEncoding	latin1	void
haskell	GHC.IO	Encoding	TextEncoding	utf8	void
haskell	GHC.IO	Encoding	TextEncoding	utf8_bom	void
haskell	GHC.IO	Encoding	TextEncoding	utf16	void
haskell	GHC.IO	Encoding	TextEncoding	utf16le	void
haskell	GHC.IO	Encoding	TextEncoding	utf16be	void
haskell	GHC.IO	Encoding	TextEncoding	utf32	void
haskell	GHC.IO	Encoding	TextEncoding	utf32le	void
haskell	GHC.IO	Encoding	TextEncoding	utf32be	void
haskell	GHC.IO	Encoding	UNK	getLocaleEncoding	void
haskell	GHC.IO	Encoding	UNK	getFileSystemEncoding	void
haskell	GHC.IO	Encoding	UNK	getForeignEncoding	void
haskell	GHC.IO	Encoding	TextEncoding	char8	void
haskell	GHC.IO	Encoding	UNK	mkTextEncoding	UNK=String
haskell	System.IO	Error	IOError	userError	UNK=String
haskell	System.IO	Error	IOError	mkIOError	UNK=IOErrorType UNK=String UNK=Maybe UNK=Handle UNK=Maybe UNK=FilePath
haskell	System.IO	Error	IOError	annotateIOError	UNK=IOError UNK=String UNK=Maybe UNK=Handle UNK=Maybe UNK=FilePath
haskell	System.IO	Error	Bool	isAlreadyExistsError	UNK=IOError
haskell	System.IO	Error	Bool	isDoesNotExistError	UNK=IOError
haskell	System.IO	Error	Bool	isAlreadyInUseError	UNK=IOError
haskell	System.IO	Error	Bool	isFullError	UNK=IOError
haskell	System.IO	Error	Bool	isEOFError	UNK=IOError
haskell	System.IO	Error	Bool	isIllegalOperation	UNK=IOError
haskell	System.IO	Error	Bool	isPermissionError	UNK=IOError
haskell	System.IO	Error	Bool	isUserError	UNK=IOError
haskell	System.IO	Error	IOErrorType	alreadyExistsErrorType	void
haskell	System.IO	Error	IOErrorType	doesNotExistErrorType	void
haskell	System.IO	Error	IOErrorType	alreadyInUseErrorType	void
haskell	System.IO	Error	IOErrorType	fullErrorType	void
haskell	System.IO	Error	IOErrorType	eofErrorType	void
haskell	System.IO	Error	IOErrorType	illegalOperationErrorType	void
haskell	System.IO	Error	IOErrorType	permissionErrorType	void
haskell	System.IO	Error	IOErrorType	userErrorType	void
haskell	System.IO	Error	Bool	isAlreadyExistsErrorType	UNK=IOErrorType
haskell	System.IO	Error	Bool	isDoesNotExistErrorType	UNK=IOErrorType
haskell	System.IO	Error	Bool	isAlreadyInUseErrorType	UNK=IOErrorType
haskell	System.IO	Error	Bool	isFullErrorType	UNK=IOErrorType
haskell	System.IO	Error	Bool	isEOFErrorType	UNK=IOErrorType
haskell	System.IO	Error	Bool	isIllegalOperationErrorType	UNK=IOErrorType
haskell	System.IO	Error	Bool	isPermissionErrorType	UNK=IOErrorType
haskell	System.IO	Error	Bool	isUserErrorType	UNK=IOErrorType
haskell	System.IO	Error	UNK	ioError	UNK=IOError
haskell	System.IO	Error	UNK	catchIOError	UNK=IO UNK=a UNK=$f_2$ UNK=IOError UNK=IO UNK=a
haskell	System.IO	Error	UNK	tryIOError	UNK=IO UNK=a
haskell	System.IO	Error	UNK	modifyIOError	UNK=$f_2$ UNK=IOError UNK=IOError UNK=IO UNK=a
haskell	GHC.Conc	IO	IO	ensureIOManagerIsRunning	void
haskell	GHC.Conc	IO	IO	threadDelay	UNK=Int
haskell	GHC.Conc	IO	UNK	registerDelay	UNK=Int
haskell	GHC.Conc	IO	IO	threadWaitRead	UNK=Fd
haskell	GHC.Conc	IO	IO	threadWaitWrite	UNK=Fd
haskell	GHC.Conc	IO	UNK	threadWaitReadSTM	UNK=Fd
haskell	GHC.Conc	IO	UNK	threadWaitWriteSTM	UNK=Fd
haskell	GHC.Conc	IO	IO	closeFdWith	UNK=$f_2$ UNK=Fd UNK=IO UNK=Fd
haskell	GHC	Conc	ThreadId	ThreadId	UNK=ThreadId#
haskell	GHC	Conc	UNK	forkIO	UNK=IO
haskell	GHC	Conc	UNK	forkOn	UNK=Int UNK=IO
haskell	GHC	Conc	Int	numCapabilities	void
haskell	GHC	Conc	UNK	getNumCapabilities	void
haskell	GHC	Conc	IO	setNumCapabilities	UNK=Int
haskell	GHC	Conc	UNK	getNumProcessors	void
haskell	GHC	Conc	UNK	numSparks	void
haskell	GHC	Conc	UNK	myThreadId	void
haskell	GHC	Conc	IO	killThread	UNK=ThreadId
haskell	GHC	Conc	IO	throwTo	UNK=ThreadId Exception=e
haskell	GHC	Conc	IO	runSparks	void
haskell	GHC	Conc	IO	yield	void
haskell	GHC	Conc	IO	labelThread	UNK=ThreadId UNK=String
haskell	GHC	Conc	UNK	mkWeakThreadId	UNK=ThreadId
haskell	GHC	Conc	ThreadStatus	ThreadRunning	void
haskell	GHC	Conc	ThreadStatus	ThreadFinished	void
haskell	GHC	Conc	ThreadStatus	ThreadBlocked	UNK=BlockReason
haskell	GHC	Conc	ThreadStatus	ThreadDied	void
haskell	GHC	Conc	BlockReason	BlockedOnMVar	void
haskell	GHC	Conc	BlockReason	BlockedOnBlackHole	void
haskell	GHC	Conc	BlockReason	BlockedOnException	void
haskell	GHC	Conc	BlockReason	BlockedOnSTM	void
haskell	GHC	Conc	BlockReason	BlockedOnForeignCall	void
haskell	GHC	Conc	BlockReason	BlockedOnOther	void
haskell	GHC	Conc	UNK	threadCapability	UNK=ThreadId
haskell	GHC	Conc	IO	threadDelay	UNK=Int
haskell	GHC	Conc	UNK	registerDelay	UNK=Int
haskell	GHC	Conc	IO	threadWaitRead	UNK=Fd
haskell	GHC	Conc	IO	threadWaitWrite	UNK=Fd
haskell	GHC	Conc	UNK	threadWaitReadSTM	UNK=Fd
haskell	GHC	Conc	UNK	threadWaitWriteSTM	UNK=Fd
haskell	GHC	Conc	IO	closeFdWith	UNK=$f_2$ UNK=Fd UNK=IO UNK=Fd
haskell	GHC	Conc	IO	setAllocationCounter	UNK=Int64
haskell	GHC	Conc	UNK	getAllocationCounter	void
haskell	GHC	Conc	IO	enableAllocationLimit	void
haskell	GHC	Conc	IO	disableAllocationLimit	void
haskell	GHC	Conc	UNK	STM	UNK=$f_2$ UNK=State# UNK=RealWorld UNK=$tuple_2$ UNK=# UNK=State# UNK=RealWorld UNK=a UNK=#
haskell	GHC	Conc	UNK	atomically	UNK=STM UNK=a
haskell	GHC	Conc	UNK	retry	void
haskell	GHC	Conc	UNK	orElse	UNK=STM UNK=a UNK=STM UNK=a
haskell	GHC	Conc	UNK	throwSTM	Exception=e
haskell	GHC	Conc	UNK	catchSTM	UNK=STM UNK=a UNK=$f_2$ Exception=e UNK=STM UNK=a
haskell	GHC	Conc	STM	alwaysSucceeds	UNK=STM UNK=a
haskell	GHC	Conc	STM	always	UNK=STM UNK=Bool
haskell	GHC	Conc	UNK	TVar	UNK=TVar# UNK=RealWorld UNK=a
haskell	GHC	Conc	UNK	newTVar	UNK=a
haskell	GHC	Conc	UNK	newTVarIO	UNK=a
haskell	GHC	Conc	UNK	readTVar	UNK=TVar UNK=a
haskell	GHC	Conc	UNK	readTVarIO	UNK=TVar UNK=a
haskell	GHC	Conc	STM	writeTVar	UNK=TVar UNK=a UNK=a
haskell	GHC	Conc	UNK	unsafeIOToSTM	UNK=IO UNK=a
haskell	GHC.IO	Handle	BufferMode	NoBuffering	void
haskell	GHC.IO	Handle	BufferMode	LineBuffering	void
haskell	GHC.IO	Handle	BufferMode	BlockBuffering	UNK=Maybe UNK=Int
haskell	GHC.IO	Handle	UNK	mkFileHandle	IODevice/BufferedIO/Typeable=dev UNK=FilePath UNK=IOMode UNK=Maybe UNK=TextEncoding UNK=NewlineMode
haskell	GHC.IO	Handle	UNK	mkDuplexHandle	IODevice/BufferedIO/Typeable=dev UNK=FilePath UNK=Maybe UNK=TextEncoding UNK=NewlineMode
haskell	GHC.IO	Handle	UNK	hFileSize	UNK=Handle
haskell	GHC.IO	Handle	IO	hSetFileSize	UNK=Handle UNK=Integer
haskell	GHC.IO	Handle	UNK	hIsEOF	UNK=Handle
haskell	GHC.IO	Handle	UNK	hLookAhead	UNK=Handle
haskell	GHC.IO	Handle	IO	hSetBuffering	UNK=Handle UNK=BufferMode
haskell	GHC.IO	Handle	IO	hSetBinaryMode	UNK=Handle UNK=Bool
haskell	GHC.IO	Handle	IO	hSetEncoding	UNK=Handle UNK=TextEncoding
haskell	GHC.IO	Handle	UNK	hGetEncoding	UNK=Handle
haskell	GHC.IO	Handle	IO	hFlush	UNK=Handle
haskell	GHC.IO	Handle	IO	hFlushAll	UNK=Handle
haskell	GHC.IO	Handle	UNK	hDuplicate	UNK=Handle
haskell	GHC.IO	Handle	IO	hDuplicateTo	UNK=Handle UNK=Handle
haskell	GHC.IO	Handle	IO	hClose	UNK=Handle
haskell	GHC.IO	Handle	UNK	hGetPosn	UNK=Handle
haskell	GHC.IO	Handle	IO	hSetPosn	UNK=HandlePosn
haskell	GHC.IO	Handle	SeekMode	AbsoluteSeek	void
haskell	GHC.IO	Handle	SeekMode	RelativeSeek	void
haskell	GHC.IO	Handle	SeekMode	SeekFromEnd	void
haskell	GHC.IO	Handle	IO	hSeek	UNK=Handle UNK=SeekMode UNK=Integer
haskell	GHC.IO	Handle	UNK	hTell	UNK=Handle
haskell	GHC.IO	Handle	UNK	hGetBuffering	UNK=Handle
haskell	GHC.IO	Handle	IO	hSetEcho	UNK=Handle UNK=Bool
haskell	GHC.IO	Handle	UNK	hGetEcho	UNK=Handle
haskell	GHC.IO	Handle	UNK	hIsTerminalDevice	UNK=Handle
haskell	GHC.IO	Handle	IO	hSetNewlineMode	UNK=Handle UNK=NewlineMode
haskell	GHC.IO	Handle	NewlineMode	NewlineMode	UNK=Newline UNK=Newline
haskell	GHC.IO	Handle	Newline	[inputNL]	UNK=NewlineMode
haskell	GHC.IO	Handle	Newline	[outputNL]	UNK=NewlineMode
haskell	GHC.IO	Handle	Newline	nativeNewline	void
haskell	GHC.IO	Handle	NewlineMode	noNewlineTranslation	void
haskell	GHC.IO	Handle	NewlineMode	universalNewlineMode	void
haskell	GHC.IO	Handle	NewlineMode	nativeNewlineMode	void
haskell	GHC.IO	Handle	UNK	hShow	UNK=Handle
haskell	GHC.IO	Handle	UNK	hWaitForInput	UNK=Handle UNK=Int
haskell	GHC.IO	Handle	UNK	hGetChar	UNK=Handle
haskell	GHC.IO	Handle	UNK	hGetLine	UNK=Handle
haskell	GHC.IO	Handle	UNK	hGetContents	UNK=Handle
haskell	GHC.IO	Handle	IO	hPutChar	UNK=Handle UNK=Char
haskell	GHC.IO	Handle	IO	hPutStr	UNK=Handle UNK=String
haskell	GHC.IO	Handle	UNK	hGetBuf	UNK=Handle UNK=Ptr UNK=a UNK=Int
haskell	GHC.IO	Handle	UNK	hGetBufNonBlocking	UNK=Handle UNK=Ptr UNK=a UNK=Int
haskell	GHC.IO	Handle	IO	hPutBuf	UNK=Handle UNK=Ptr UNK=a UNK=Int
haskell	GHC.IO.Handle	FD	Handle	stdin	void
haskell	GHC.IO.Handle	FD	Handle	stdout	void
haskell	GHC.IO.Handle	FD	Handle	stderr	void
haskell	GHC.IO.Handle	FD	UNK	openFile	UNK=FilePath UNK=IOMode
haskell	GHC.IO.Handle	FD	UNK	openBinaryFile	UNK=FilePath UNK=IOMode
haskell	GHC.IO.Handle	FD	UNK	openFileBlocking	UNK=FilePath UNK=IOMode
haskell	GHC.IO.Handle	FD	UNK	fdToHandle	UNK=FD
haskell	GHC.IO.Handle	FD	UNK	fdToHandle'	UNK=CInt UNK=Maybe UNK=IODeviceType UNK=Bool UNK=FilePath UNK=IOMode UNK=Bool
haskell	GHC.IO.Handle	FD	UNK	isEOF	void
haskell	System	IO	UNK	fixIO	UNK=$f_2$ UNK=a UNK=IO UNK=a
haskell	System	IO	Handle	stdin	void
haskell	System	IO	Handle	stdout	void
haskell	System	IO	Handle	stderr	void
haskell	System	IO	UNK	withFile	UNK=FilePath UNK=IOMode UNK=$f_2$ UNK=Handle UNK=IO UNK=r
haskell	System	IO	UNK	openFile	UNK=FilePath UNK=IOMode
haskell	System	IO	IOMode	ReadMode	void
haskell	System	IO	IO	hClose	UNK=Handle
haskell	System	IO	UNK	readFile	UNK=FilePath
haskell	System	IO	IO	writeFile	UNK=FilePath UNK=String
haskell	System	IO	IO	appendFile	UNK=FilePath UNK=String
haskell	System	IO	UNK	hFileSize	UNK=Handle
haskell	System	IO	IO	hSetFileSize	UNK=Handle UNK=Integer
haskell	System	IO	UNK	hIsEOF	UNK=Handle
haskell	System	IO	UNK	isEOF	void
haskell	System	IO	BufferMode	NoBuffering	void
haskell	System	IO	BufferMode	LineBuffering	void
haskell	System	IO	BufferMode	BlockBuffering	UNK=Maybe UNK=Int
haskell	System	IO	IO	hSetBuffering	UNK=Handle UNK=BufferMode
haskell	System	IO	UNK	hGetBuffering	UNK=Handle
haskell	System	IO	IO	hFlush	UNK=Handle
haskell	System	IO	UNK	hGetPosn	UNK=Handle
haskell	System	IO	IO	hSetPosn	UNK=HandlePosn
haskell	System	IO	IO	hSeek	UNK=Handle UNK=SeekMode UNK=Integer
haskell	System	IO	SeekMode	AbsoluteSeek	void
haskell	System	IO	SeekMode	RelativeSeek	void
haskell	System	IO	SeekMode	SeekFromEnd	void
haskell	System	IO	UNK	hTell	UNK=Handle
haskell	System	IO	UNK	hIsTerminalDevice	UNK=Handle
haskell	System	IO	IO	hSetEcho	UNK=Handle UNK=Bool
haskell	System	IO	UNK	hGetEcho	UNK=Handle
haskell	System	IO	UNK	hShow	UNK=Handle
haskell	System	IO	UNK	hWaitForInput	UNK=Handle UNK=Int
haskell	System	IO	UNK	hReady	UNK=Handle
haskell	System	IO	UNK	hGetChar	UNK=Handle
haskell	System	IO	UNK	hGetLine	UNK=Handle
haskell	System	IO	UNK	hLookAhead	UNK=Handle
haskell	System	IO	UNK	hGetContents	UNK=Handle
haskell	System	IO	IO	hPutChar	UNK=Handle UNK=Char
haskell	System	IO	IO	hPutStr	UNK=Handle UNK=String
haskell	System	IO	IO	hPutStrLn	UNK=Handle UNK=String
haskell	System	IO	IO	hPrint	UNK=Handle Show=a
haskell	System	IO	IO	interact	UNK=$f_2$ UNK=String UNK=String
haskell	System	IO	IO	putChar	UNK=Char
haskell	System	IO	IO	putStr	UNK=String
haskell	System	IO	IO	putStrLn	UNK=String
haskell	System	IO	IO	print	Show=a
haskell	System	IO	UNK	getChar	void
haskell	System	IO	UNK	getLine	void
haskell	System	IO	UNK	getContents	void
haskell	System	IO	UNK	readIO	UNK=String
haskell	System	IO	UNK	readLn	void
haskell	System	IO	UNK	withBinaryFile	UNK=FilePath UNK=IOMode UNK=$f_2$ UNK=Handle UNK=IO UNK=r
haskell	System	IO	UNK	openBinaryFile	UNK=FilePath UNK=IOMode
haskell	System	IO	IO	hSetBinaryMode	UNK=Handle UNK=Bool
haskell	System	IO	IO	hPutBuf	UNK=Handle UNK=Ptr UNK=a UNK=Int
haskell	System	IO	UNK	hGetBuf	UNK=Handle UNK=Ptr UNK=a UNK=Int
haskell	System	IO	UNK	hGetBufSome	UNK=Handle UNK=Ptr UNK=a UNK=Int
haskell	System	IO	UNK	hGetBufNonBlocking	UNK=Handle UNK=Ptr UNK=a UNK=Int
haskell	System	IO	UNK	openTempFile	UNK=FilePath UNK=String
haskell	System	IO	UNK	openBinaryTempFile	UNK=FilePath UNK=String
haskell	System	IO	UNK	openTempFileWithDefaultPermissions	UNK=FilePath UNK=String
haskell	System	IO	UNK	openBinaryTempFileWithDefaultPermissions	UNK=FilePath UNK=String
haskell	System	IO	IO	hSetEncoding	UNK=Handle UNK=TextEncoding
haskell	System	IO	UNK	hGetEncoding	UNK=Handle
haskell	System	IO	TextEncoding	latin1	void
haskell	System	IO	TextEncoding	utf8	void
haskell	System	IO	TextEncoding	utf8_bom	void
haskell	System	IO	TextEncoding	utf16	void
haskell	System	IO	TextEncoding	utf16le	void
haskell	System	IO	TextEncoding	utf16be	void
haskell	System	IO	TextEncoding	utf32	void
haskell	System	IO	TextEncoding	utf32le	void
haskell	System	IO	TextEncoding	utf32be	void
haskell	System	IO	TextEncoding	localeEncoding	void
haskell	System	IO	TextEncoding	char8	void
haskell	System	IO	UNK	mkTextEncoding	UNK=String
haskell	System	IO	IO	hSetNewlineMode	UNK=Handle UNK=NewlineMode
haskell	System	IO	Newline	nativeNewline	void
haskell	System	IO	NewlineMode	NewlineMode	UNK=Newline UNK=Newline
haskell	System	IO	Newline	[inputNL]	UNK=NewlineMode
haskell	System	IO	Newline	[outputNL]	UNK=NewlineMode
haskell	System	IO	NewlineMode	noNewlineTranslation	void
haskell	System	IO	NewlineMode	universalNewlineMode	void
haskell	System	IO	NewlineMode	nativeNewlineMode	void
haskell	Control.Monad	Fix	UNK	mfix	UNK=$f_2$ UNK=a MonadFix=m UNK=a
haskell	Control.Monad	Fix	a	fix	UNK=$f_2$ UNK=a UNK=a
haskell	Control	Arrow	UNK	arr	UNK=$f_2$ UNK=b UNK=c
haskell	Control	Arrow	UNK	first	Arrow=a UNK=b UNK=c
haskell	Control	Arrow	UNK	second	Arrow=a UNK=b UNK=c
haskell	Control	Arrow	UNK	(***)	Arrow=a UNK=b UNK=c Arrow=a UNK=b' UNK=c'
haskell	Control	Arrow	UNK	(&&&)	Arrow=a UNK=b UNK=c Arrow=a UNK=b UNK=c'
haskell	Control	Arrow	UNK	Kleisli	UNK=$f_2$ UNK=a UNK=m UNK=b
haskell	Control	Arrow	UNK	returnA	void
haskell	Control	Arrow	UNK	(^>>)	UNK=$f_2$ UNK=b UNK=c Arrow=a UNK=c UNK=d
haskell	Control	Arrow	UNK	(>>^)	Arrow=a UNK=b UNK=c UNK=$f_2$ UNK=c UNK=d
haskell	Control	Arrow	UNK	(>>>)	Category=cat UNK=a UNK=b Category=cat UNK=b UNK=c
haskell	Control	Arrow	UNK	(<<<)	Category=cat UNK=b UNK=c Category=cat UNK=a UNK=b
haskell	Control	Arrow	UNK	(<<^)	Arrow=a UNK=c UNK=d UNK=$f_2$ UNK=b UNK=c
haskell	Control	Arrow	UNK	(^<<)	UNK=$f_2$ UNK=c UNK=d Arrow=a UNK=b UNK=c
haskell	Control	Arrow	UNK	(<+>)	ArrowPlus=a UNK=b UNK=c ArrowPlus=a UNK=b UNK=c
haskell	Control	Arrow	UNK	left	ArrowChoice=a UNK=b UNK=c
haskell	Control	Arrow	UNK	right	ArrowChoice=a UNK=b UNK=c
haskell	Control	Arrow	UNK	(+++)	ArrowChoice=a UNK=b UNK=c ArrowChoice=a UNK=b' UNK=c'
haskell	Control	Arrow	UNK	(|||)	ArrowChoice=a UNK=b UNK=d ArrowChoice=a UNK=c UNK=d
haskell	Control	Arrow	UNK	ArrowMonad	UNK=a UNK=b
haskell	Control	Arrow	UNK	leftApp	ArrowApply=a UNK=b UNK=c
haskell	Control	Arrow	UNK	loop	ArrowLoop=a UNK=$tuple_2$ UNK=b UNK=d UNK=$tuple_2$ UNK=c UNK=d
haskell	Control	Applicative	UNK	pure	UNK=a
haskell	Control	Applicative	UNK	(<*>)	Applicative=f UNK=$f_2$ UNK=a UNK=b Applicative=f UNK=a
haskell	Control	Applicative	UNK	(*>)	Applicative=f UNK=a Applicative=f UNK=b
haskell	Control	Applicative	UNK	(<*)	Applicative=f UNK=a Applicative=f UNK=b
haskell	Control	Applicative	UNK	empty	void
haskell	Control	Applicative	UNK	(<|>)	Alternative=f UNK=a Alternative=f UNK=a
haskell	Control	Applicative	UNK	some	Alternative=f UNK=a
haskell	Control	Applicative	UNK	many	Alternative=f UNK=a
haskell	Control	Applicative	UNK	ZipList	UNK=$list$ UNK=a
haskell	Control	Applicative	UNK	(<$>)	UNK=$f_2$ UNK=a UNK=b Functor=f UNK=a
haskell	Control	Applicative	UNK	(<$)	UNK=a Functor=f UNK=b
haskell	Control	Applicative	UNK	(<**>)	Applicative=f UNK=a Applicative=f UNK=$f_2$ UNK=a UNK=b
haskell	Control	Applicative	UNK	liftA	UNK=$f_2$ UNK=a UNK=b Applicative=f UNK=a
haskell	Control	Applicative	UNK	liftA2	UNK=$f_3$ UNK=a UNK=b UNK=c Applicative=f UNK=a Applicative=f UNK=b
haskell	Control	Applicative	UNK	liftA3	UNK=$f_4$ UNK=a UNK=b UNK=c UNK=d Applicative=f UNK=a Applicative=f UNK=b Applicative=f UNK=c
haskell	Control	Applicative	UNK	optional	Alternative=f UNK=a
haskell	Data	Traversable	UNK	traverse	UNK=$f_2$ UNK=a Applicative=f UNK=b Traversable=t UNK=a
haskell	Data	Traversable	UNK	sequenceA	Traversable=t Applicative=f UNK=a
haskell	Data	Traversable	UNK	mapM	UNK=$f_2$ UNK=a Monad=m UNK=b Traversable=t UNK=a
haskell	Data	Traversable	UNK	sequence	Traversable=t Monad=m UNK=a
haskell	Data	Traversable	UNK	for	Traversable=t UNK=a UNK=$f_2$ UNK=a Applicative=f UNK=b
haskell	Data	Traversable	UNK	forM	Traversable=t UNK=a UNK=$f_2$ UNK=a Monad=m UNK=b
haskell	Data	Traversable	UNK	mapAccumL	UNK=$f_2$ UNK=a UNK=$tuple_2$ UNK=a UNK=c UNK=b UNK=a Traversable=t UNK=b
haskell	Data	Traversable	UNK	mapAccumR	UNK=$f_2$ UNK=a UNK=$tuple_2$ UNK=a UNK=c UNK=b UNK=a Traversable=t UNK=b
haskell	Data	Traversable	UNK	fmapDefault	UNK=$f_2$ UNK=a UNK=b Traversable=t UNK=a
haskell	Data	Traversable	Monoid	foldMapDefault	UNK=$f_2$ UNK=a Monoid=m Traversable=t UNK=a
haskell	Control	Monad	UNK	fmap	UNK=$f_2$ UNK=a UNK=b Functor=f UNK=a
haskell	Control	Monad	UNK	(>>=)	Monad=m UNK=a UNK=$f_2$ UNK=a Monad=m UNK=b
haskell	Control	Monad	UNK	(>>)	Monad=m UNK=a Monad=m UNK=b
haskell	Control	Monad	UNK	return	UNK=a
haskell	Control	Monad	UNK	fail	UNK=String
haskell	Control	Monad	UNK	mzero	void
haskell	Control	Monad	UNK	mplus	MonadPlus=m UNK=a MonadPlus=m UNK=a
haskell	Control	Monad	UNK	mapM	UNK=$f_2$ UNK=a Monad=m UNK=b Traversable=t UNK=a
haskell	Control	Monad	Monad	mapM_	UNK=$f_2$ UNK=a Monad=m UNK=b Foldable=t UNK=a
haskell	Control	Monad	UNK	forM	Traversable=t UNK=a UNK=$f_2$ UNK=a Monad=m UNK=b
haskell	Control	Monad	Monad	forM_	Foldable=t UNK=a UNK=$f_2$ UNK=a Monad=m UNK=b
haskell	Control	Monad	UNK	sequence	Traversable=t Monad=m UNK=a
haskell	Control	Monad	Monad	sequence_	Foldable=t Monad=m UNK=a
haskell	Control	Monad	UNK	(=<<)	UNK=$f_2$ UNK=a Monad=m UNK=b Monad=m UNK=a
haskell	Control	Monad	UNK	(>=>)	UNK=$f_2$ UNK=a Monad=m UNK=b UNK=$f_2$ UNK=b Monad=m UNK=c
haskell	Control	Monad	UNK	(<=<)	UNK=$f_2$ UNK=b Monad=m UNK=c UNK=$f_2$ UNK=a Monad=m UNK=b
haskell	Control	Monad	UNK	forever	Monad=m UNK=a
haskell	Control	Monad	Functor	void	Functor=f UNK=a
haskell	Control	Monad	UNK	join	Monad=m Monad=m UNK=a
haskell	Control	Monad	UNK	msum	Foldable=t MonadPlus=m UNK=a
haskell	Control	Monad	UNK	mfilter	UNK=$f_2$ UNK=a UNK=Bool MonadPlus=m UNK=a
haskell	Control	Monad	UNK	filterM	UNK=$f_2$ UNK=a Monad=m UNK=Bool UNK=$list$ UNK=a
haskell	Control	Monad	UNK	mapAndUnzipM	UNK=$f_2$ UNK=a Monad=m UNK=$tuple_2$ UNK=b UNK=c UNK=$list$ UNK=a
haskell	Control	Monad	UNK	zipWithM	UNK=$f_3$ UNK=a UNK=b Monad=m UNK=c UNK=$list$ UNK=a UNK=$list$ UNK=b
haskell	Control	Monad	Monad	zipWithM_	UNK=$f_3$ UNK=a UNK=b Monad=m UNK=c UNK=$list$ UNK=a UNK=$list$ UNK=b
haskell	Control	Monad	UNK	foldM	UNK=$f_3$ UNK=b UNK=a Monad=m UNK=b UNK=b Foldable=t UNK=a
haskell	Control	Monad	Monad	foldM_	UNK=$f_3$ UNK=b UNK=a Monad=m UNK=b UNK=b Foldable=t UNK=a
haskell	Control	Monad	UNK	replicateM	UNK=Int Monad=m UNK=a
haskell	Control	Monad	Monad	replicateM_	UNK=Int Monad=m UNK=a
haskell	Control	Monad	Alternative	guard	UNK=Bool
haskell	Control	Monad	Applicative	when	UNK=Bool Applicative=f
haskell	Control	Monad	Applicative	unless	UNK=Bool Applicative=f
haskell	Control	Monad	UNK	liftM	UNK=$f_2$ UNK=a1 UNK=r Monad=m UNK=a1
haskell	Control	Monad	UNK	liftM2	UNK=$f_3$ UNK=a1 UNK=a2 UNK=r Monad=m UNK=a1 Monad=m UNK=a2
haskell	Control	Monad	UNK	liftM3	UNK=$f_4$ UNK=a1 UNK=a2 UNK=a3 UNK=r Monad=m UNK=a1 Monad=m UNK=a2 Monad=m UNK=a3
haskell	Control	Monad	UNK	liftM4	UNK=$f_5$ UNK=a1 UNK=a2 UNK=a3 UNK=a4 UNK=r Monad=m UNK=a1 Monad=m UNK=a2 Monad=m UNK=a3 Monad=m UNK=a4
haskell	Control	Monad	UNK	liftM5	UNK=$f_6$ UNK=a1 UNK=a2 UNK=a3 UNK=a4 UNK=a5 UNK=r Monad=m UNK=a1 Monad=m UNK=a2 Monad=m UNK=a3 Monad=m UNK=a4 Monad=m UNK=a5
haskell	Control	Monad	UNK	ap	Monad=m UNK=$f_2$ UNK=a UNK=b Monad=m UNK=a
haskell	Control	Monad	UNK	(<$!>)	UNK=$f_2$ UNK=a UNK=b Monad=m UNK=a
haskell	GHC	Stats	!Int64	[bytesAllocated]	UNK=GCStats
haskell	GHC	Stats	!Int64	[numGcs]	UNK=GCStats
haskell	GHC	Stats	!Int64	[maxBytesUsed]	UNK=GCStats
haskell	GHC	Stats	!Int64	[numByteUsageSamples]	UNK=GCStats
haskell	GHC	Stats	!Int64	[bytesCopied]	UNK=GCStats
haskell	GHC	Stats	!Int64	[currentBytesUsed]	UNK=GCStats
haskell	GHC	Stats	!Int64	[currentBytesSlop]	UNK=GCStats
haskell	GHC	Stats	!Int64	[maxBytesSlop]	UNK=GCStats
haskell	GHC	Stats	!Int64	[peakMegabytesAllocated]	UNK=GCStats
haskell	GHC	Stats	!Double	[mutatorWallSeconds]	UNK=GCStats
haskell	GHC	Stats	!Double	[gcCpuSeconds]	UNK=GCStats
haskell	GHC	Stats	!Double	[gcWallSeconds]	UNK=GCStats
haskell	GHC	Stats	!Double	[cpuSeconds]	UNK=GCStats
haskell	GHC	Stats	!Double	[wallSeconds]	UNK=GCStats
haskell	GHC	Stats	!Int64	[parMaxBytesCopied]	UNK=GCStats
haskell	GHC	Stats	UNK	getGCStats	void
haskell	GHC	Stats	UNK	getGCStatsEnabled	void
haskell	Data	List	UNK	(++)	UNK=$list$ UNK=a UNK=$list$ UNK=a
haskell	Data	List	a	head	UNK=$list$ UNK=a
haskell	Data	List	a	last	UNK=$list$ UNK=a
haskell	Data	List	UNK	tail	UNK=$list$ UNK=a
haskell	Data	List	UNK	init	UNK=$list$ UNK=a
haskell	Data	List	UNK	uncons	UNK=$list$ UNK=a
haskell	Data	List	Bool	null	Foldable=t UNK=a
haskell	Data	List	Int	length	Foldable=t UNK=a
haskell	Data	List	UNK	map	UNK=$f_2$ UNK=a UNK=b UNK=$list$ UNK=a
haskell	Data	List	UNK	reverse	UNK=$list$ UNK=a
haskell	Data	List	UNK	intersperse	UNK=a UNK=$list$ UNK=a
haskell	Data	List	UNK	intercalate	UNK=$list$ UNK=a UNK=$list$ UNK=$list$ UNK=a
haskell	Data	List	UNK	transpose	UNK=$list$ UNK=$list$ UNK=a
haskell	Data	List	UNK	subsequences	UNK=$list$ UNK=a
haskell	Data	List	UNK	permutations	UNK=$list$ UNK=a
haskell	Data	List	b	foldl	UNK=$f_3$ UNK=b UNK=a UNK=b UNK=b Foldable=t UNK=a
haskell	Data	List	b	foldl'	UNK=$f_3$ UNK=b UNK=a UNK=b UNK=b Foldable=t UNK=a
haskell	Data	List	a	foldl1	UNK=$f_3$ UNK=a UNK=a UNK=a Foldable=t UNK=a
haskell	Data	List	a	foldl1'	UNK=$f_3$ UNK=a UNK=a UNK=a UNK=$list$ UNK=a
haskell	Data	List	b	foldr	UNK=$f_3$ UNK=a UNK=b UNK=b UNK=b Foldable=t UNK=a
haskell	Data	List	a	foldr1	UNK=$f_3$ UNK=a UNK=a UNK=a Foldable=t UNK=a
haskell	Data	List	UNK	concat	Foldable=t UNK=$list$ UNK=a
haskell	Data	List	UNK	concatMap	UNK=$f_2$ UNK=a UNK=$list$ UNK=b Foldable=t UNK=a
haskell	Data	List	Bool	and	Foldable=t UNK=Bool
haskell	Data	List	Bool	or	Foldable=t UNK=Bool
haskell	Data	List	Bool	any	UNK=$f_2$ UNK=a UNK=Bool Foldable=t UNK=a
haskell	Data	List	Bool	all	UNK=$f_2$ UNK=a UNK=Bool Foldable=t UNK=a
haskell	Data	List	Num	sum	Foldable=t Num=a
haskell	Data	List	Num	product	Foldable=t Num=a
haskell	Data	List	Ord	maximum	Foldable=t Ord=a
haskell	Data	List	Ord	minimum	Foldable=t Ord=a
haskell	Data	List	UNK	scanl	UNK=$f_3$ UNK=b UNK=a UNK=b UNK=b UNK=$list$ UNK=a
haskell	Data	List	UNK	scanl'	UNK=$f_3$ UNK=b UNK=a UNK=b UNK=b UNK=$list$ UNK=a
haskell	Data	List	UNK	scanl1	UNK=$f_3$ UNK=a UNK=a UNK=a UNK=$list$ UNK=a
haskell	Data	List	UNK	scanr	UNK=$f_3$ UNK=a UNK=b UNK=b UNK=b UNK=$list$ UNK=a
haskell	Data	List	UNK	scanr1	UNK=$f_3$ UNK=a UNK=a UNK=a UNK=$list$ UNK=a
haskell	Data	List	UNK	mapAccumL	UNK=$f_2$ UNK=a UNK=$tuple_2$ UNK=a UNK=c UNK=b UNK=a Traversable=t UNK=b
haskell	Data	List	UNK	mapAccumR	UNK=$f_2$ UNK=a UNK=$tuple_2$ UNK=a UNK=c UNK=b UNK=a Traversable=t UNK=b
haskell	Data	List	UNK	iterate	UNK=$f_2$ UNK=a UNK=a UNK=a
haskell	Data	List	UNK	repeat	UNK=a
haskell	Data	List	UNK	replicate	UNK=Int UNK=a
haskell	Data	List	UNK	cycle	UNK=$list$ UNK=a
haskell	Data	List	UNK	unfoldr	UNK=$f_2$ UNK=b UNK=Maybe UNK=$tuple_2$ UNK=a UNK=b UNK=b
haskell	Data	List	UNK	take	UNK=Int UNK=$list$ UNK=a
haskell	Data	List	UNK	drop	UNK=Int UNK=$list$ UNK=a
haskell	Data	List	UNK	splitAt	UNK=Int UNK=$list$ UNK=a
haskell	Data	List	UNK	takeWhile	UNK=$f_2$ UNK=a UNK=Bool UNK=$list$ UNK=a
haskell	Data	List	UNK	dropWhile	UNK=$f_2$ UNK=a UNK=Bool UNK=$list$ UNK=a
haskell	Data	List	UNK	dropWhileEnd	UNK=$f_2$ UNK=a UNK=Bool UNK=$list$ UNK=a
haskell	Data	List	UNK	span	UNK=$f_2$ UNK=a UNK=Bool UNK=$list$ UNK=a
haskell	Data	List	UNK	break	UNK=$f_2$ UNK=a UNK=Bool UNK=$list$ UNK=a
haskell	Data	List	UNK	stripPrefix	UNK=$list$ Eq=a UNK=$list$ Eq=a
haskell	Data	List	UNK	group	UNK=$list$ Eq=a
haskell	Data	List	UNK	inits	UNK=$list$ UNK=a
haskell	Data	List	UNK	tails	UNK=$list$ UNK=a
haskell	Data	List	Bool	isPrefixOf	UNK=$list$ Eq=a UNK=$list$ Eq=a
haskell	Data	List	Bool	isSuffixOf	UNK=$list$ Eq=a UNK=$list$ Eq=a
haskell	Data	List	Bool	isInfixOf	UNK=$list$ Eq=a UNK=$list$ Eq=a
haskell	Data	List	Bool	isSubsequenceOf	UNK=$list$ Eq=a UNK=$list$ Eq=a
haskell	Data	List	Bool	elem	Eq=a Foldable=t Eq=a
haskell	Data	List	Bool	notElem	Eq=a Foldable=t Eq=a
haskell	Data	List	UNK	lookup	Eq=a UNK=$list$ UNK=$tuple_2$ Eq=a UNK=b
haskell	Data	List	UNK	find	UNK=$f_2$ UNK=a UNK=Bool Foldable=t UNK=a
haskell	Data	List	UNK	filter	UNK=$f_2$ UNK=a UNK=Bool UNK=$list$ UNK=a
haskell	Data	List	UNK	partition	UNK=$f_2$ UNK=a UNK=Bool UNK=$list$ UNK=a
haskell	Data	List	a	(!!)	UNK=$list$ UNK=a UNK=Int
haskell	Data	List	UNK	elemIndex	Eq=a UNK=$list$ Eq=a
haskell	Data	List	UNK	elemIndices	Eq=a UNK=$list$ Eq=a
haskell	Data	List	UNK	findIndex	UNK=$f_2$ UNK=a UNK=Bool UNK=$list$ UNK=a
haskell	Data	List	UNK	findIndices	UNK=$f_2$ UNK=a UNK=Bool UNK=$list$ UNK=a
haskell	Data	List	UNK	zip	UNK=$list$ UNK=a UNK=$list$ UNK=b
haskell	Data	List	UNK	zip3	UNK=$list$ UNK=a UNK=$list$ UNK=b UNK=$list$ UNK=c
haskell	Data	List	UNK	zip4	UNK=$list$ UNK=a UNK=$list$ UNK=b UNK=$list$ UNK=c UNK=$list$ UNK=d
haskell	Data	List	UNK	zip5	UNK=$list$ UNK=a UNK=$list$ UNK=b UNK=$list$ UNK=c UNK=$list$ UNK=d UNK=$list$ UNK=e
haskell	Data	List	UNK	zip6	UNK=$list$ UNK=a UNK=$list$ UNK=b UNK=$list$ UNK=c UNK=$list$ UNK=d UNK=$list$ UNK=e UNK=$list$ UNK=f
haskell	Data	List	UNK	zip7	UNK=$list$ UNK=a UNK=$list$ UNK=b UNK=$list$ UNK=c UNK=$list$ UNK=d UNK=$list$ UNK=e UNK=$list$ UNK=f UNK=$list$ UNK=g
haskell	Data	List	UNK	zipWith	UNK=$f_3$ UNK=a UNK=b UNK=c UNK=$list$ UNK=a UNK=$list$ UNK=b
haskell	Data	List	UNK	zipWith3	UNK=$f_4$ UNK=a UNK=b UNK=c UNK=d UNK=$list$ UNK=a UNK=$list$ UNK=b UNK=$list$ UNK=c
haskell	Data	List	UNK	zipWith4	UNK=$f_5$ UNK=a UNK=b UNK=c UNK=d UNK=e UNK=$list$ UNK=a UNK=$list$ UNK=b UNK=$list$ UNK=c UNK=$list$ UNK=d
haskell	Data	List	UNK	zipWith5	UNK=$f_6$ UNK=a UNK=b UNK=c UNK=d UNK=e UNK=f UNK=$list$ UNK=a UNK=$list$ UNK=b UNK=$list$ UNK=c UNK=$list$ UNK=d UNK=$list$ UNK=e
haskell	Data	List	UNK	zipWith6	UNK=$f_7$ UNK=a UNK=b UNK=c UNK=d UNK=e UNK=f UNK=g UNK=$list$ UNK=a UNK=$list$ UNK=b UNK=$list$ UNK=c UNK=$list$ UNK=d UNK=$list$ UNK=e UNK=$list$ UNK=f
haskell	Data	List	UNK	zipWith7	UNK=$f_8$ UNK=a UNK=b UNK=c UNK=d UNK=e UNK=f UNK=g UNK=h UNK=$list$ UNK=a UNK=$list$ UNK=b UNK=$list$ UNK=c UNK=$list$ UNK=d UNK=$list$ UNK=e UNK=$list$ UNK=f UNK=$list$ UNK=g
haskell	Data	List	UNK	unzip	UNK=$list$ UNK=$tuple_2$ UNK=a UNK=b
haskell	Data	List	UNK	unzip3	UNK=$list$ UNK=$tuple_3$ UNK=a UNK=b UNK=c
haskell	Data	List	UNK	unzip4	UNK=$list$ UNK=$tuple_4$ UNK=a UNK=b UNK=c UNK=d
haskell	Data	List	UNK	unzip5	UNK=$list$ UNK=$tuple_5$ UNK=a UNK=b UNK=c UNK=d UNK=e
haskell	Data	List	UNK	unzip6	UNK=$list$ UNK=$tuple_6$ UNK=a UNK=b UNK=c UNK=d UNK=e UNK=f
haskell	Data	List	UNK	unzip7	UNK=$list$ UNK=$tuple_7$ UNK=a UNK=b UNK=c UNK=d UNK=e UNK=f UNK=g
haskell	Data	List	UNK	lines	UNK=String
haskell	Data	List	UNK	words	UNK=String
haskell	Data	List	String	unlines	UNK=$list$ UNK=String
haskell	Data	List	String	unwords	UNK=$list$ UNK=String
haskell	Data	List	UNK	nub	UNK=$list$ Eq=a
haskell	Data	List	UNK	delete	Eq=a UNK=$list$ Eq=a
haskell	Data	List	UNK	(\\)	UNK=$list$ Eq=a UNK=$list$ Eq=a
haskell	Data	List	UNK	union	UNK=$list$ Eq=a UNK=$list$ Eq=a
haskell	Data	List	UNK	intersect	UNK=$list$ Eq=a UNK=$list$ Eq=a
haskell	Data	List	UNK	sort	UNK=$list$ Ord=a
haskell	Data	List	UNK	sortOn	UNK=$f_2$ UNK=a Ord=b UNK=$list$ UNK=a
haskell	Data	List	UNK	insert	Ord=a UNK=$list$ Ord=a
haskell	Data	List	UNK	nubBy	UNK=$f_3$ UNK=a UNK=a UNK=Bool UNK=$list$ UNK=a
haskell	Data	List	UNK	deleteBy	UNK=$f_3$ UNK=a UNK=a UNK=Bool UNK=a UNK=$list$ UNK=a
haskell	Data	List	UNK	deleteFirstsBy	UNK=$f_3$ UNK=a UNK=a UNK=Bool UNK=$list$ UNK=a UNK=$list$ UNK=a
haskell	Data	List	UNK	unionBy	UNK=$f_3$ UNK=a UNK=a UNK=Bool UNK=$list$ UNK=a UNK=$list$ UNK=a
haskell	Data	List	UNK	intersectBy	UNK=$f_3$ UNK=a UNK=a UNK=Bool UNK=$list$ UNK=a UNK=$list$ UNK=a
haskell	Data	List	UNK	groupBy	UNK=$f_3$ UNK=a UNK=a UNK=Bool UNK=$list$ UNK=a
haskell	Data	List	UNK	sortBy	UNK=$f_3$ UNK=a UNK=a UNK=Ordering UNK=$list$ UNK=a
haskell	Data	List	UNK	insertBy	UNK=$f_3$ UNK=a UNK=a UNK=Ordering UNK=a UNK=$list$ UNK=a
haskell	Data	List	a	maximumBy	UNK=$f_3$ UNK=a UNK=a UNK=Ordering Foldable=t UNK=a
haskell	Data	List	a	minimumBy	UNK=$f_3$ UNK=a UNK=a UNK=Ordering Foldable=t UNK=a
haskell	Data	List	Num	genericLength	UNK=$list$ UNK=a
haskell	Data	List	UNK	genericTake	Integral=i UNK=$list$ UNK=a
haskell	Data	List	UNK	genericDrop	Integral=i UNK=$list$ UNK=a
haskell	Data	List	UNK	genericSplitAt	Integral=i UNK=$list$ UNK=a
haskell	Data	List	a	genericIndex	UNK=$list$ UNK=a Integral=i
haskell	Data	List	UNK	genericReplicate	Integral=i UNK=a
haskell	Data	String	IsString	fromString	UNK=String
haskell	Data	String	UNK	lines	UNK=String
haskell	Data	String	UNK	words	UNK=String
haskell	Data	String	String	unlines	UNK=$list$ UNK=String
haskell	Data	String	String	unwords	UNK=$list$ UNK=String
haskell	Data	Version	Version	Version	UNK=$list$ UNK=Int UNK=$list$ UNK=String
haskell	Data	Version	UNK	[versionBranch]	UNK=Version
haskell	Data	Version	UNK	[versionTags]	UNK=Version
haskell	Data	Version	String	showVersion	UNK=Version
haskell	Data	Version	UNK	parseVersion	void
haskell	Data	Version	Version	makeVersion	UNK=$list$ UNK=Int
haskell	Data	Data	Constr	toConstr	Data=a
haskell	Data	Data	DataType	mkDataType	UNK=String UNK=$list$ UNK=Constr
haskell	Data	Data	DataType	mkIntType	UNK=String
haskell	Data	Data	DataType	mkFloatType	UNK=String
haskell	Data	Data	DataType	mkCharType	UNK=String
haskell	Data	Data	DataType	mkNoRepType	UNK=String
haskell	Data	Data	DataRep	AlgRep	UNK=$list$ UNK=Constr
haskell	Data	Data	Constr	repConstr	UNK=DataType UNK=ConstrRep
haskell	Data	Data	Bool	isAlgType	UNK=DataType
haskell	Data	Data	Constr	indexConstr	UNK=DataType UNK=ConIndex
haskell	Data	Data	ConIndex	maxConstrIndex	UNK=DataType
haskell	Data	Data	Bool	isNorepType	UNK=DataType
haskell	Data	Data	Fixity	Prefix	void
haskell	Data	Data	Constr	mkConstr	UNK=DataType UNK=String UNK=$list$ UNK=String UNK=Fixity
haskell	Data	Data	Constr	mkCharConstr	UNK=DataType UNK=Char
haskell	Data	Data	DataType	constrType	UNK=Constr
haskell	Data	Data	ConstrRep	AlgConstr	UNK=ConIndex
haskell	Data	Data	ConstrRep	constrRep	UNK=Constr
haskell	Data	Data	UNK	constrFields	UNK=Constr
haskell	Data	Data	Fixity	constrFixity	UNK=Constr
haskell	Data	Data	ConIndex	constrIndex	UNK=Constr
haskell	Data	Data	String	showConstr	UNK=Constr
haskell	Data	Data	UNK	readConstr	UNK=DataType UNK=String
haskell	Data	Data	String	tyconUQname	UNK=String
haskell	Data	Data	String	tyconModule	UNK=String
haskell	Data	Data	Data	fromConstr	UNK=Constr
haskell	GHC	Natural	Natural	NatS#	UNK=GmpLimb#
haskell	GHC	Natural	Bool	isValidNatural	UNK=Natural
haskell	GHC	Natural	Natural	wordToNatural	UNK=Word
haskell	GHC	Natural	UNK	naturalToWordMaybe	UNK=Natural
haskell	GHC	Natural	UNK	minusNaturalMaybe	UNK=Natural UNK=Natural
haskell	GHC	Natural	Natural	powModNatural	UNK=Natural UNK=Natural UNK=Natural
haskell	GHC.RTS	Flags	RTSFlags	RTSFlags	UNK=GCFlags UNK=ConcFlags UNK=MiscFlags UNK=DebugFlags UNK=CCFlags UNK=ProfFlags UNK=TraceFlags UNK=TickyFlags
haskell	GHC.RTS	Flags	Bool	[compact]	UNK=GCFlags
haskell	GHC.RTS	Flags	Bool	[sweep]	UNK=GCFlags
haskell	GHC.RTS	Flags	Word	[heapBase]	UNK=GCFlags
haskell	GHC.RTS	Flags	Word	[linkerMemBase]	UNK=MiscFlags
haskell	GHC.RTS	Flags	Bool	[linker]	UNK=DebugFlags
haskell	GHC.RTS	Flags	Bool	[squeeze]	UNK=DebugFlags
haskell	GHC.RTS	Flags	Bool	[hpc]	UNK=DebugFlags
haskell	GHC.RTS	Flags	Time	[heapProfileInterval]	UNK=ProfFlags
haskell	GHC.RTS	Flags	Word	[heapProfileIntervalTicks]	UNK=ProfFlags
haskell	GHC.RTS	Flags	Bool	[timestamp]	UNK=TraceFlags
haskell	GHC.RTS	Flags	Bool	[traceScheduler]	UNK=TraceFlags
haskell	GHC.RTS	Flags	Bool	[traceGc]	UNK=TraceFlags
haskell	GHC.RTS	Flags	Bool	[sparksSampled]	UNK=TraceFlags
haskell	GHC.RTS	Flags	Bool	[sparksFull]	UNK=TraceFlags
haskell	GHC.RTS	Flags	Bool	[user]	UNK=TraceFlags
haskell	GHC	Fingerprint	UNK	getFileHash	UNK=FilePath
haskell	GHC	Event	UNK	getSystemEventManager	void
haskell	GHC	Event	UNK	new	void
haskell	GHC	Event	Event	evtRead	void
haskell	GHC	Event	Event	evtWrite	void
haskell	GHC	Event	Lifetime	OneShot	void
haskell	GHC	Event	Lifetime	MultiShot	void
haskell	GHC	Event	UNK	registerFd	UNK=EventManager UNK=IOCallback UNK=Fd UNK=Event UNK=Lifetime
haskell	GHC	Event	IO	unregisterFd	UNK=EventManager UNK=FdKey
haskell	GHC	Event	UNK	unregisterFd_	UNK=EventManager UNK=FdKey
haskell	GHC	Event	IO	closeFd	UNK=EventManager UNK=$f_2$ UNK=Fd UNK=IO UNK=Fd
haskell	GHC	Event	UNK	registerTimeout	UNK=TimerManager UNK=Int UNK=TimeoutCallback
haskell	GHC	Event	IO	updateTimeout	UNK=TimerManager UNK=TimeoutKey UNK=Int
haskell	GHC	Event	IO	unregisterTimeout	UNK=TimerManager UNK=TimeoutKey
haskell	GHC	TypeLits	UNK	someNatVal	UNK=Integer
haskell	GHC	TypeLits	SomeSymbol	someSymbolVal	UNK=String
haskell	GHC	IP	IP	ip	void
haskell	Prelude	core	Bool	False	void
haskell	Prelude	core	Enum	succ	Enum=a
haskell	Prelude	core	Enum	pred	Enum=a
haskell	Prelude	core	Enum	toEnum	UNK=Int
haskell	Prelude	core	Int	fromEnum	Enum=a
haskell	Prelude	core	UNK	enumFrom	Enum=a
haskell	Prelude	core	UNK	enumFromTo	Enum=a Enum=a
haskell	Prelude	core	Bounded	minBound	void
haskell	Prelude	core	Num	(+)	Num=a Num=a
haskell	Prelude	core	Num	negate	Num=a
haskell	Prelude	core	Num	abs	Num=a
haskell	Prelude	core	Num	signum	Num=a
haskell	Prelude	core	Num	fromInteger	UNK=Integer
haskell	Prelude	core	Rational	toRational	Real=a
haskell	Prelude	core	Integral	quot	Integral=a Integral=a
haskell	Prelude	core	Integral	rem	Integral=a Integral=a
haskell	Prelude	core	Integral	div	Integral=a Integral=a
haskell	Prelude	core	Integral	mod	Integral=a Integral=a
haskell	Prelude	core	UNK	quotRem	Integral=a Integral=a
haskell	Prelude	core	UNK	divMod	Integral=a Integral=a
haskell	Prelude	core	Integer	toInteger	Integral=a
haskell	Prelude	core	Fractional	(/)	Fractional=a Fractional=a
haskell	Prelude	core	Fractional	recip	Fractional=a
haskell	Prelude	core	Fractional	fromRational	UNK=Rational
haskell	Prelude	core	Floating	pi	void
haskell	Prelude	core	UNK	properFraction	RealFrac=a
haskell	Prelude	core	Integral	truncate	RealFrac=a
haskell	Prelude	core	Integral	round	RealFrac=a
haskell	Prelude	core	Integral	ceiling	RealFrac=a
haskell	Prelude	core	Integral	floor	RealFrac=a
haskell	Prelude	core	Integer	floatRadix	RealFloat=a
haskell	Prelude	core	Int	floatDigits	RealFloat=a
haskell	Prelude	core	UNK	floatRange	RealFloat=a
haskell	Prelude	core	UNK	decodeFloat	RealFloat=a
haskell	Prelude	core	RealFloat	encodeFloat	UNK=Integer UNK=Int
haskell	Prelude	core	Int	exponent	RealFloat=a
haskell	Prelude	core	RealFloat	significand	RealFloat=a
haskell	Prelude	core	RealFloat	scaleFloat	UNK=Int RealFloat=a
haskell	Prelude	core	Bool	isNaN	RealFloat=a
haskell	Prelude	core	Bool	isInfinite	RealFloat=a
haskell	Prelude	core	Bool	isDenormalized	RealFloat=a
haskell	Prelude	core	Bool	isNegativeZero	RealFloat=a
haskell	Prelude	core	Bool	isIEEE	RealFloat=a
haskell	Prelude	core	RealFloat	atan2	RealFloat=a RealFloat=a
haskell	Prelude	core	Num	subtract	Num=a Num=a
haskell	Prelude	core	Integral	gcd	Integral=a Integral=a
haskell	Prelude	core	Integral	lcm	Integral=a Integral=a
haskell	Prelude	core	Num	(^)	Num=a Integral=b
haskell	Prelude	core	Fractional	(^^)	Fractional=a Integral=b
haskell	Prelude	core	Num	fromIntegral	Integral=a
haskell	Prelude	core	Fractional	realToFrac	Real=a
haskell	Prelude	core	a	until	UNK=$f_2$ UNK=a UNK=Bool UNK=$f_2$ UNK=a UNK=a UNK=a
haskell	Prelude	core	a	asTypeOf	UNK=a UNK=a
haskell	Prelude	core	a	error	UNK=$list$ UNK=Char
haskell	Prelude	core	a	undefined	void
haskell	Prelude	core	b	seq	UNK=a UNK=b
haskell	Prelude	core	b	($!)	UNK=$f_2$ UNK=a UNK=b UNK=a
haskell	GHC	SrcLoc	String	srcLocPackage	UNK=SrcLoc
haskell	GHC	Stack	UNK	currentCallStack	void
haskell	GHC	Stack	UNK	whoCreated	UNK=a
haskell	GHC	Stack	a	errorWithStackTrace	UNK=String
haskell	GHC	Stack	UNK	getCallStack	UNK=CallStack
haskell	Debug	Trace	a	trace	UNK=String UNK=a
haskell	Debug	Trace	String	traceId	UNK=String
haskell	Debug	Trace	b	traceShow	Show=a UNK=b
haskell	Debug	Trace	Show	traceShowId	Show=a
haskell	Debug	Trace	a	traceStack	UNK=String UNK=a
haskell	Debug	Trace	IO	traceIO	UNK=String
haskell	Debug	Trace	Monad	traceM	UNK=String
haskell	Debug	Trace	Monad	traceShowM	Show=a
haskell	Debug	Trace	IO	putTraceMsg	UNK=String
haskell	Debug	Trace	a	traceEvent	UNK=String UNK=a
haskell	Debug	Trace	IO	traceEventIO	UNK=String
haskell	Debug	Trace	a	traceMarker	UNK=String UNK=a
haskell	Debug	Trace	IO	traceMarkerIO	UNK=String
haskell	GHC	Exts	Int	I#	UNK=Int#
haskell	GHC	Exts	Word	W#	UNK=Word#
haskell	GHC	Exts	Float	F#	UNK=Float#
haskell	GHC	Exts	Double	D#	UNK=Double#
haskell	GHC	Exts	Char	C#	UNK=Char#
haskell	GHC	Exts	UNK	Ptr	UNK=Addr#
haskell	GHC	Exts	UNK	FunPtr	UNK=Addr#
haskell	GHC	Exts	Word#	shiftL#	UNK=Word# UNK=Int#
haskell	GHC	Exts	Word#	shiftRL#	UNK=Word# UNK=Int#
haskell	GHC	Exts	Int#	iShiftL#	UNK=Int# UNK=Int#
haskell	GHC	Exts	Int#	iShiftRA#	UNK=Int# UNK=Int#
haskell	GHC	Exts	Int#	iShiftRL#	UNK=Int# UNK=Int#
haskell	GHC	Exts	Bool	isTrue#	UNK=Int#
haskell	GHC	Exts	IsString	fromString	UNK=String
haskell	GHC	Exts	a	lazy	UNK=a
haskell	GHC	Exts	a	inline	UNK=a
haskell	GHC	Exts	Coercible	coerce	Coercible=a
haskell	GHC	Exts	UNK	Down	UNK=a
haskell	GHC	Exts	UNK	groupWith	UNK=$f_2$ UNK=a Ord=b UNK=$list$ UNK=a
haskell	GHC	Exts	UNK	sortWith	UNK=$f_2$ UNK=a Ord=b UNK=$list$ UNK=a
haskell	GHC	Exts	Eq	the	UNK=$list$ Eq=a
haskell	GHC	Exts	IO	traceEvent	UNK=String
haskell	GHC	Exts	UNK	currentCallStack	void
haskell	GHC	Exts	IsList	fromList	UNK=$list$ UNK=Item IsList=l
haskell	GHC	Exts	IsList	fromListN	UNK=Int UNK=$list$ UNK=Item IsList=l
haskell	GHC	Exts	UNK	toList	IsList=l
haskell	Control.Monad	Zip	UNK	mzip	MonadZip=m UNK=a MonadZip=m UNK=b
haskell	GHC	StaticPtr	a	deRefStaticPtr	UNK=StaticPtr UNK=a
haskell	GHC	StaticPtr	StaticKey	staticKey	UNK=StaticPtr UNK=a
haskell	GHC	StaticPtr	UNK	unsafeLookupStaticPtr	UNK=StaticKey
haskell	GHC	StaticPtr	StaticPtrInfo	StaticPtrInfo	UNK=String UNK=String UNK=String UNK=$tuple_2$ UNK=Int UNK=Int
haskell	GHC	StaticPtr	String	[spInfoPackageKey]	UNK=StaticPtrInfo
haskell	GHC	StaticPtr	String	[spInfoModuleName]	UNK=StaticPtrInfo
haskell	GHC	StaticPtr	String	[spInfoName]	UNK=StaticPtrInfo
haskell	GHC	StaticPtr	UNK	[spInfoSrcLoc]	UNK=StaticPtrInfo
haskell	GHC	StaticPtr	StaticPtrInfo	staticPtrInfo	UNK=StaticPtr UNK=a
haskell	GHC	StaticPtr	UNK	staticPtrKeys	void
haskell	Control.Concurrent	Chan	UNK	newChan	void
haskell	Control.Concurrent	Chan	IO	writeChan	UNK=Chan UNK=a UNK=a
haskell	Control.Concurrent	Chan	UNK	readChan	UNK=Chan UNK=a
haskell	Control.Concurrent	Chan	UNK	dupChan	UNK=Chan UNK=a
haskell	Control.Concurrent	Chan	IO	unGetChan	UNK=Chan UNK=a UNK=a
haskell	Control.Concurrent	Chan	UNK	isEmptyChan	UNK=Chan UNK=a
haskell	Control.Concurrent	Chan	UNK	getChanContents	UNK=Chan UNK=a
haskell	Control.Concurrent	Chan	IO	writeList2Chan	UNK=Chan UNK=a UNK=$list$ UNK=a
haskell	Control.Concurrent	QSem	UNK	newQSem	UNK=Int
haskell	Control.Concurrent	QSem	IO	waitQSem	UNK=QSem
haskell	Control.Concurrent	QSem	IO	signalQSem	UNK=QSem
haskell	Control.Concurrent	QSemN	UNK	newQSemN	UNK=Int
haskell	Control.Concurrent	QSemN	IO	waitQSemN	UNK=QSemN UNK=Int
haskell	Control.Concurrent	QSemN	IO	signalQSemN	UNK=QSemN UNK=Int
haskell	Control	Concurrent	UNK	myThreadId	void
haskell	Control	Concurrent	UNK	forkIO	UNK=IO
haskell	Control	Concurrent	UNK	forkFinally	UNK=IO UNK=a UNK=$f_2$ UNK=Either UNK=SomeException UNK=a UNK=IO
haskell	Control	Concurrent	IO	killThread	UNK=ThreadId
haskell	Control	Concurrent	IO	throwTo	UNK=ThreadId Exception=e
haskell	Control	Concurrent	UNK	forkOn	UNK=Int UNK=IO
haskell	Control	Concurrent	UNK	getNumCapabilities	void
haskell	Control	Concurrent	IO	setNumCapabilities	UNK=Int
haskell	Control	Concurrent	UNK	threadCapability	UNK=ThreadId
haskell	Control	Concurrent	IO	yield	void
haskell	Control	Concurrent	IO	threadDelay	UNK=Int
haskell	Control	Concurrent	IO	threadWaitRead	UNK=Fd
haskell	Control	Concurrent	IO	threadWaitWrite	UNK=Fd
haskell	Control	Concurrent	UNK	threadWaitReadSTM	UNK=Fd
haskell	Control	Concurrent	UNK	threadWaitWriteSTM	UNK=Fd
haskell	Control	Concurrent	Bool	rtsSupportsBoundThreads	void
haskell	Control	Concurrent	UNK	forkOS	UNK=IO
haskell	Control	Concurrent	UNK	isCurrentThreadBound	void
haskell	Control	Concurrent	UNK	runInBoundThread	UNK=IO UNK=a
haskell	Control	Concurrent	UNK	runInUnboundThread	UNK=IO UNK=a
haskell	Control	Concurrent	UNK	mkWeakThreadId	UNK=ThreadId
haskell	Control.Monad	Instances	UNK	fmap	UNK=$f_2$ UNK=a UNK=b Functor=f UNK=a
haskell	Control.Monad	Instances	UNK	(<$)	UNK=a Functor=f UNK=b
haskell	Control.Monad	Instances	UNK	(>>=)	Monad=m UNK=a UNK=$f_2$ UNK=a Monad=m UNK=b
haskell	Control.Monad	Instances	UNK	(>>)	Monad=m UNK=a Monad=m UNK=b
haskell	Control.Monad	Instances	UNK	return	UNK=a
haskell	Control.Monad	Instances	UNK	fail	UNK=String
haskell	Control.Monad	ST	UNK	fixST	UNK=$f_2$ UNK=a UNK=ST UNK=s UNK=a
haskell	Control.Monad	ST	UNK	stToIO	UNK=ST UNK=RealWorld UNK=a
haskell	Control.Monad.ST	Safe	UNK	fixST	UNK=$f_2$ UNK=a UNK=ST UNK=s UNK=a
haskell	Control.Monad.ST	Safe	UNK	stToIO	UNK=ST UNK=RealWorld UNK=a
haskell	Control.Monad.ST	Unsafe	UNK	unsafeInterleaveST	UNK=ST UNK=s UNK=a
haskell	Control.Monad.ST	Lazy	UNK	fixST	UNK=$f_2$ UNK=a UNK=ST UNK=s UNK=a
haskell	Control.Monad.ST	Lazy	UNK	strictToLazyST	UNK=ST UNK=s UNK=a
haskell	Control.Monad.ST	Lazy	UNK	lazyToStrictST	UNK=ST UNK=s UNK=a
haskell	Control.Monad.ST	Lazy	UNK	stToIO	UNK=ST UNK=RealWorld UNK=a
haskell	Control.Monad.ST.Lazy	Safe	UNK	fixST	UNK=$f_2$ UNK=a UNK=ST UNK=s UNK=a
haskell	Control.Monad.ST.Lazy	Safe	UNK	strictToLazyST	UNK=ST UNK=s UNK=a
haskell	Control.Monad.ST.Lazy	Safe	UNK	lazyToStrictST	UNK=ST UNK=s UNK=a
haskell	Control.Monad.ST.Lazy	Safe	UNK	stToIO	UNK=ST UNK=RealWorld UNK=a
haskell	Control.Monad.ST.Lazy	Unsafe	UNK	unsafeInterleaveST	UNK=ST UNK=s UNK=a
haskell	Data	Bifunctor	UNK	bimap	UNK=$f_2$ UNK=a UNK=b UNK=$f_2$ UNK=c UNK=d Bifunctor=p UNK=a UNK=c
haskell	Data	Bifunctor	UNK	first	UNK=$f_2$ UNK=a UNK=b Bifunctor=p UNK=a UNK=c
haskell	Data	Bifunctor	UNK	second	UNK=$f_2$ UNK=b UNK=c Bifunctor=p UNK=a UNK=b
haskell	Data	Complex	UNK	(:+)	UNK=!a UNK=!a
haskell	Data	Complex	a	realPart	UNK=Complex UNK=a
haskell	Data	Complex	a	imagPart	UNK=Complex UNK=a
haskell	Data	Complex	UNK	mkPolar	Floating=a Floating=a
haskell	Data	Complex	UNK	cis	Floating=a
haskell	Data	Complex	UNK	polar	UNK=Complex RealFloat=a
haskell	Data	Complex	RealFloat	magnitude	UNK=Complex RealFloat=a
haskell	Data	Complex	RealFloat	phase	UNK=Complex RealFloat=a
haskell	Data	Complex	UNK	conjugate	UNK=Complex Num=a
haskell	Data	Fixed	Integral	div'	Real=a Real=a
haskell	Data	Fixed	Real	mod'	Real=a Real=a
haskell	Data	Fixed	UNK	divMod'	Real=a Real=a
haskell	Data	Fixed	String	showFixed	UNK=Bool UNK=Fixed HasResolution=a
haskell	Data.Functor	Identity	UNK	Identity	UNK=a
haskell	Data	Ix	UNK	range	UNK=$tuple_2$ Ix=a Ix=a
haskell	Data	Ix	Int	index	UNK=$tuple_2$ Ix=a Ix=a Ix=a
haskell	Data	Ix	Bool	inRange	UNK=$tuple_2$ Ix=a Ix=a Ix=a
haskell	Data	Ix	Int	rangeSize	UNK=$tuple_2$ Ix=a Ix=a
haskell	Data	Ratio	UNK	(%)	Integral=a Integral=a
haskell	Data	Ratio	Integral	numerator	UNK=Ratio Integral=a
haskell	Data	Ratio	Integral	denominator	UNK=Ratio Integral=a
haskell	Data	Ratio	Rational	approxRational	RealFrac=a RealFrac=a
haskell	Data	STRef	UNK	newSTRef	UNK=a
haskell	Data	STRef	UNK	readSTRef	UNK=STRef UNK=s UNK=a
haskell	Data	STRef	UNK	writeSTRef	UNK=STRef UNK=s UNK=a UNK=a
haskell	Data	STRef	UNK	modifySTRef	UNK=STRef UNK=s UNK=a UNK=$f_2$ UNK=a UNK=a
haskell	Data	STRef	UNK	modifySTRef'	UNK=STRef UNK=s UNK=a UNK=$f_2$ UNK=a UNK=a
haskell	Data.STRef	Lazy	UNK	newSTRef	UNK=a
haskell	Data	Unique	UNK	newUnique	void
haskell	Data	Unique	Int	hashUnique	UNK=Unique
haskell	Data	Void	a	absurd	UNK=Void
haskell	Data	Void	UNK	vacuous	Functor=f UNK=Void
haskell	System	CPUTime	UNK	getCPUTime	void
haskell	System	CPUTime	Integer	cpuTimePrecision	void
haskell	System.Console	GetOpt	UNK	getOpt	UNK=ArgOrder UNK=a UNK=$list$ UNK=OptDescr UNK=a UNK=$list$ UNK=String
haskell	System.Console	GetOpt	UNK	getOpt'	UNK=ArgOrder UNK=a UNK=$list$ UNK=OptDescr UNK=a UNK=$list$ UNK=String
haskell	System.Console	GetOpt	String	usageInfo	UNK=String UNK=$list$ UNK=OptDescr UNK=a
haskell	System.Console	GetOpt	UNK	RequireOrder	void
haskell	System.Console	GetOpt	UNK	Permute	void
haskell	System.Console	GetOpt	UNK	ReturnInOrder	UNK=$f_2$ UNK=String UNK=a
haskell	System.Console	GetOpt	UNK	Option	UNK=$list$ UNK=Char UNK=$list$ UNK=String UNK=ArgDescr UNK=a UNK=String
haskell	System.Console	GetOpt	UNK	NoArg	UNK=a
haskell	System.Console	GetOpt	UNK	ReqArg	UNK=$f_2$ UNK=String UNK=a UNK=String
haskell	System.Console	GetOpt	UNK	OptArg	UNK=$f_2$ UNK=Maybe UNK=String UNK=a UNK=String
haskell	System	Environment	UNK	getArgs	void
haskell	System	Environment	UNK	getProgName	void
haskell	System	Environment	UNK	getExecutablePath	void
haskell	System	Environment	UNK	getEnv	UNK=String
haskell	System	Environment	UNK	lookupEnv	UNK=String
haskell	System	Environment	IO	setEnv	UNK=String UNK=String
haskell	System	Environment	IO	unsetEnv	UNK=String
haskell	System	Environment	UNK	withArgs	UNK=$list$ UNK=String UNK=IO UNK=a
haskell	System	Environment	UNK	withProgName	UNK=String UNK=IO UNK=a
haskell	System	Environment	UNK	getEnvironment	void
haskell	System	Exit	ExitCode	ExitSuccess	void
haskell	System	Exit	ExitCode	ExitFailure	UNK=Int
haskell	System	Exit	UNK	exitWith	UNK=ExitCode
haskell	System	Exit	UNK	exitFailure	void
haskell	System	Exit	UNK	exitSuccess	void
haskell	System	Exit	UNK	die	UNK=String
haskell	System	Info	String	os	void
haskell	System	Info	String	arch	void
haskell	System	Info	String	compilerName	void
haskell	System	Info	Version	compilerVersion	void
haskell	System	Mem	IO	performGC	void
haskell	System	Mem	IO	performMajorGC	void
haskell	System	Mem	IO	performMinorGC	void
haskell	System.Mem	StableName	UNK	makeStableName	UNK=a
haskell	System.Mem	StableName	Int	hashStableName	UNK=StableName UNK=a
haskell	System.Mem	StableName	Bool	eqStableName	UNK=StableName UNK=a UNK=StableName UNK=b
haskell	System.Mem	Weak	UNK	mkWeak	UNK=k UNK=v UNK=Maybe UNK=IO
haskell	System.Mem	Weak	UNK	deRefWeak	UNK=Weak UNK=v
haskell	System.Mem	Weak	IO	finalize	UNK=Weak UNK=v
haskell	System.Mem	Weak	UNK	mkWeakPtr	UNK=k UNK=Maybe UNK=IO
haskell	System.Mem	Weak	IO	addFinalizer	UNK=key UNK=IO
haskell	System.Mem	Weak	UNK	mkWeakPair	UNK=k UNK=v UNK=Maybe UNK=IO
haskell	System	Timeout	UNK	timeout	UNK=Int UNK=IO UNK=a
haskell	Text	Printf	PrintfType	printf	UNK=String
haskell	Text	Printf	HPrintfType	hPrintf	UNK=Handle UNK=String
haskell	Text	Printf	FieldFormat	FieldFormat	UNK=Maybe UNK=Int UNK=Maybe UNK=Int UNK=Maybe UNK=FormatAdjustment UNK=Maybe UNK=FormatSign UNK=Bool UNK=String UNK=Char
haskell	Text	Printf	UNK	[fmtWidth]	UNK=FieldFormat
haskell	Text	Printf	UNK	[fmtPrecision]	UNK=FieldFormat
haskell	Text	Printf	UNK	[fmtAdjust]	UNK=FieldFormat
haskell	Text	Printf	UNK	[fmtSign]	UNK=FieldFormat
haskell	Text	Printf	Bool	[fmtAlternate]	UNK=FieldFormat
haskell	Text	Printf	String	[fmtModifiers]	UNK=FieldFormat
haskell	Text	Printf	Char	[fmtChar]	UNK=FieldFormat
haskell	Text	Printf	FormatAdjustment	LeftAdjust	void
haskell	Text	Printf	FormatSign	SignPlus	void
haskell	Text	Printf	FieldFormat	vFmt	UNK=Char UNK=FieldFormat
haskell	Text	Printf	FormatParse	FormatParse	UNK=String UNK=Char UNK=String
haskell	Text	Printf	String	[fpModifiers]	UNK=FormatParse
haskell	Text	Printf	Char	[fpChar]	UNK=FormatParse
haskell	Text	Printf	String	[fpRest]	UNK=FormatParse
haskell	Text	Printf	FieldFormatter	formatString	UNK=$list$ IsChar=a
haskell	Text	Printf	FieldFormatter	formatChar	UNK=Char
haskell	Text	Printf	FieldFormatter	formatInt	Integral/Bounded=a
haskell	Text	Printf	FieldFormatter	formatInteger	UNK=Integer
haskell	Text	Printf	FieldFormatter	formatRealFloat	RealFloat=a
haskell	Text	Printf	a	errorBadFormat	UNK=Char
haskell	Text	Printf	a	errorShortFormat	void
haskell	Text	Printf	a	errorMissingArgument	void
haskell	Text	Printf	a	errorBadArgument	void
haskell	Text	Printf	a	perror	UNK=String
