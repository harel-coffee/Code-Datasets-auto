module	of the ||| combinatorics	count=1
function	[function_1] a where ||| [function_1] [function_2]	count=9
function	returns true if the ||| is	count=1
arg	in line ||| line	count=1
class	dtype ||| fraction field	count=9
function_arg	[function_1] morphism and ||| [arg_2] [function_1]	count=1
function	half ||| half	count=4
function	and ||| set	count=1
module	velocity of this ||| vector	count=1
arg	of msg ||| msg	count=2
function	index which is preferred ||| get preferred index	count=1
function	angular ||| angular	count=1
arg	k0 to k1 ||| u k0 k1	count=2
function	return the number ||| count	count=1
function	dummies can be substituted ||| get ordered dummies	count=1
function_arg	order [arg_2] ||| [function_1] at [arg_2]	count=1
arg	of t ||| t	count=1
function	for nthroot ||| nthroot	count=1
class	in the given ||| expr	count=1
arg	b m + b, ||| b a b	count=1
arg	x c if c ||| c min max	count=1
function	of conjunctions and disjunctions ||| distribute and over or	count=1
function	unifies the ||| unify	count=1
function	the digamma ||| digamma	count=1
module_class	the lagrange multipliers ||| physics mechanics lagranges	count=1
arg	n ||| n m	count=1
function_arg	centralizer of [arg_2] ||| [function_1] [arg_2]	count=1
module_class	[module_1] swap ||| [module_1] [class_2]	count=2
function	[function_1] num/den ||| [function_2] [function_1]	count=2
arg	check if a literal ||| lit	count=1
arg	g p k ||| g b p	count=1
function	multivariate polynomials over ||| dmp	count=1
function	objects by distributing ||| tensors from components	count=1
class	using ||| deprecated	count=1
class	basis in ||| ring	count=1
arg	lines ||| lines	count=1
function	codomain replaced by ||| codomain	count=1
function	string path to the ||| mod	count=1
arg	of alpha as ||| alpha pairs	count=1
arg	the argument passed by ||| cls arg k	count=1
class	using any ||| integral	count=1
module	the three parameters ||| physics	count=2
arg	of f and for ||| a d	count=1
function	cartan [function_2] ||| [function_2] [function_1]	count=5
arg	g h are ||| g h	count=6
function	[function_1] square-free ||| [function_2] [function_1]	count=13
arg	message [arg] is ||| [arg]	count=1
function	and ||| pretty try	count=1
function	of points ||| points	count=2
arg	in k[x] using the ||| f	count=1
arg	modulo o(x**prec) examples ||| p x prec	count=1
arg	f and g ||| f g exps x	count=1
arg	in x examples ||| x	count=1
function	finding powers of ||| af pow	count=1
arg	is replaced by ||| kwargs n	count=1
arg	of square-free polynomial using ||| polys k eps inf	count=1
function	[function_1] the extension ||| [function_1] ipython [function_2]	count=1
function	matrix to a scalar ||| scalar	count=1
arg	characters of msg ||| msg	count=1
module	a ||| series	count=2
function	wang/eez test ||| dmp zz wang test	count=1
arg	of self in h ||| h	count=1
function	input ||| bezout	count=2
function_arg	root of [arg_2] ||| [function_1] [arg_2]	count=17
arg	for n this ||| n	count=1
function	rational functions ||| as rational	count=1
function	[function_1] polynomial of ||| [function_1] [function_2]	count=4
function	imaginary part of a ||| imag	count=1
function	return the n-th coefficient ||| dmp nth	count=1
function_arg	[function_1] class initiated ||| [arg_2] [function_1]	count=4
function	a factory for ||| factory	count=1
function	solves a system ||| solve	count=1
arg	and for each ||| a	count=1
function	an algebraic number ||| algebraic field	count=2
function	zgate ||| zgate	count=1
function	reverse the [function_2] ||| [function_1] [function_2]	count=4
function	in integer [function_2] ||| [function_1] [function_2]	count=1
function	the convergence ||| is convergent	count=1
module	[module_1] of this ||| [module_1] [module_2]	count=1
module	sparse diagonal [module] from ||| [module]	count=1
class	polar ||| polar	count=1
module	returns the ||| physics quantum	count=4
module	quantum expression ||| quantum	count=1
function	there is free space ||| check free space	count=2
function	refine an isolating ||| refine	count=2
function	[function] vector of ||| [function]	count=2
function	time derivative of ||| dt	count=1
class	hole or create particle ||| fermion	count=2
function	fn -n x ||| spherical bessel fn minus	count=1
function	of the given ||| to	count=1
arg	[arg] on the ||| [arg]	count=3
module	the default printing of ||| physics	count=1
function	by a sympifyable ||| mul	count=1
function	[function_1] of rational ||| [function_1] [function_2]	count=5
function_arg	randomization [arg_2] ||| [function_1] function [arg_2]	count=1
function_arg	[function_1] [arg_2] ||| polys modified subresultants [function_1] [arg_2]	count=8
function	object has [function_2] ||| [function_2] [function_1]	count=1
function_arg	replace [arg_2] ||| [arg_2] [function_1]	count=2
arg	[arg_1] p == ||| [arg_1] [arg_2]	count=4
function	inverse mellin transform of ||| inverse mellin transform	count=1
function	the critical pair corresponding ||| critical pair	count=1
arg	small'' ||| deg_f deg_g row1 row2	count=1
module	[module] works by ||| [module]	count=3
function_arg	[function_1] [arg_2] ||| [function_1] expand [arg_2]	count=1
function_arg	[function_1] n ||| [arg_2] [function_1]	count=41
arg	[arg_1] a path ||| [arg_2] expr [arg_1]	count=1
class	sides ||| regular polygon	count=1
function	[function] form of ||| to [function]	count=2
function_arg	[function_1] in k ||| [arg_2] [function_1]	count=1
arg	g p ||| g b p	count=1
arg	two primes and e ||| e	count=1
arg	[arg_1] by ||| [arg_2] [arg_1]	count=10
function_arg	two assumptions [arg_2] ||| [function_1] [arg_2]	count=1
arg	about c i e ||| c	count=1
function	the ideal generated by ||| f5b	count=1
class	generated files ||| fcode	count=1
function	[function_1] normal form ||| [function_1] [function_2]	count=4
module	that only uses ||| core	count=2
class	gcd ||| polynomial ring base	count=1
function	postprocess an expression after ||| postprocess	count=1
class	coordinate ||| coord sys	count=4
module	following for the initialization ||| physics mechanics	count=1
arg	of space characters ||| s	count=1
class	scan ||| coset table	count=1
arg	f [arg_2] ||| series mrv max1 [arg_1] [arg_2]	count=3
function	number of roots ||| count roots	count=2
function	system of polynomial ||| poly system	count=3
class	[class] general ||| matrix [class]	count=1
function	returns a copy ||| copy	count=1
class	this ||| matrix	count=1
function	find the ||| find reasonable	count=1
function	rewrites ||| eval rewrite as	count=1
function	square ||| sqr	count=1
function	[function] of a ||| count [function]	count=1
function	factor ||| factor	count=7
function_arg	evaluate a [arg_2] ||| [arg_2] [function_1]	count=9
function	list of native ||| list	count=1
arg	keys are used to ||| keys	count=1
function	ordered [function] where each ||| normal ordered [function]	count=1
function	start ||| process	count=1
class	string of stringpicts ||| string pict	count=2
function	solves for ||| solve for	count=2
function	components the sorting is ||| components	count=1
function	gtkmathview a gtk ||| gtk	count=1
function	as iterator ||| iterator	count=1
function	module [function] time is ||| [function]	count=1
class	[class_1] product ||| [class_1] [class_2]	count=3
arg	< [arg_2] ||| [arg_1] a [arg_2]	count=1
module	of m, assuming that ||| solvers	count=1
function	of sympy ||| sympy	count=1
function	of a mul object ||| mul	count=1
arg	[arg_1] op ||| [arg_2] [arg_1]	count=3
function	find_substitutions sympy's [function] ||| manual [function]	count=1
class	representation ||| form	count=1
function	operator classes to ||| to state	count=1
module	and values the ||| geometry	count=1
function	semi-latus ||| semilatus	count=1
arg	vector constants ||| variable constant	count=1
function	according ||| bool	count=1
function	finds the domain of ||| not empty	count=1
function	index of a ||| index	count=1
function	first set of numerator ||| an	count=1
function	from a list ||| from list	count=6
arg	apply _hasattrs and _hastypes ||| attrs types	count=1
function	implementation of codomain ||| codomain	count=1
arg	matching_symbol if s ||| s matching_symbol	count=1
arg	to a second order ||| order	count=1
arg	convert ||| k1 a k0	count=4
class	space ||| point	count=1
function	leading degree ||| degree	count=1
function	a differential ||| ode	count=3
function	a symbol ||| symbol	count=1
function_arg	over [arg_2] ||| [function_1] lcm [arg_2]	count=1
arg	q [arg_2] ||| [arg_1] [arg_2]	count=5
function_arg	[function_1] [arg_2] is the plaintext ||| [function_1] [arg_2]	count=1
function	module and the ||| get mod func	count=1
function	chebyshev ||| chebyshevu	count=2
function	of the functions in ||| empty in	count=1
arg	occupations is a list ||| cls occupations	count=1
function	roots of a square-free ||| roots sqf	count=1
function	index which is preferred ||| preferred index	count=1
function	the discriminant ||| discriminant	count=1
arg	limit or ||| limit	count=1
function	[function_1] multiple ||| [function_1] [function_2]	count=4
module	the object ||| physics	count=1
arg	p ||| g p	count=1
function_arg	with controls ||| zbasis controls	count=1
function	compositeness test returns false ||| prp	count=1
function	of domain quotient ||| quotient domain	count=1
arg	expression in ||| expr	count=2
function_arg	[function_1] order ||| [arg_2] [function_1]	count=3
function_arg	[function_1] of f ||| [function_1] gcd [arg_2]	count=4
arg	free [arg_2] ||| [arg_1] [arg_2]	count=3
function	class into ||| func	count=1
arg	s over the ||| s x	count=1
arg	formats a codestring ||| codestring	count=1
function	according to ||| from	count=1
function	[function_1] transitivity ||| [function_2] [function_1]	count=6
module	a vector distance between ||| vector	count=1
function	mignotte [function_2] ||| [function_1] [function_2]	count=3
function	the traditional rules ||| traditional	count=1
class	partition is listed from ||| integer partition	count=1
class	list ||| frac field	count=1
function	list of polynomial generators ||| gens	count=1
function_arg	subs [arg_2] ||| [function_1] [arg_2]	count=2
function	return a base ||| base	count=1
arg	x_0 of ||| f m u	count=1
arg	no = -1 computes ||| no	count=1
module	rule based on the ||| strategies	count=1
class	or ||| expr with int limits	count=1
arg	a function which ||| function	count=2
class	and sort roots ||| root	count=2
class	for octave ||| octave	count=1
function	a boolean [function] simplified version ||| [function]	count=1
function	parametric ||| parametric	count=3
function	triangles ||| triangles	count=1
function	hankel [function_2] ||| [function_2] [function_1]	count=2
function	to a ||| tensorhead from tensmul	count=1
module	find optimization opportunities ||| simplify	count=1
function	and the ||| get	count=1
function	to the ||| get mod func	count=1
function	path to a ||| mod	count=1
function	[function_1] a sequence ||| [function_1] [function_2]	count=1
function	square-free factorization given ||| sqf	count=1
function	first defining ||| p1	count=1
function	with the proper line ||| get statement	count=1
class	return the homomorphism ||| homomorphism	count=1
module	integration using any hints ||| integrals	count=1
function	[function_1] finite difference ||| [function_1] [function_2]	count=1
class	[class_1] power series ||| [class_2] [class_1]	count=1
function	a piecewise form ||| as piecewise	count=2
class	this frame in terms ||| frame	count=1
function	returns the best ||| 1st homogeneous coeff best	count=1
function_arg	[function_1] of f ||| [arg_2] [function_1]	count=220
function	for :func dup_decompose ||| dup decompose	count=1
function	direction cosine [function] dcm ||| rotation [function]	count=1
function	factory for ||| factory	count=1
function	find_unit_clause but ||| clause	count=1
arg	stringpict and binding power ||| baseline binding unicode	count=1
function	[function_1] single gamma ||| [function_2] [function_1]	count=1
function_arg	root of p ||| root p n	count=2
function_arg	ideal [arg_2] ||| [arg_2] [function_1]	count=2
function	the label is the ||| label	count=1
module_class	the index [class_2] ||| [module_1] [class_2]	count=12
arg	3 1 2 ; [arg_1] [arg_2] ||| [arg_1] [arg_2]	count=3
function	integer modulus ||| modular integer	count=1
module	sum or product ||| concrete	count=1
arg	[arg_1] new ||| [arg_1] [arg_2]	count=3
class	differential ||| differential	count=1
arg	and n ||| n	count=1
function	lcm over a ring ||| rr lcm	count=1
arg	a condition [arg] ||| condition [arg]	count=1
arg	list range n shifted ||| n	count=1
function	if ||| is	count=6
function	pendulum on a sliding ||| link pendulum on	count=1
function	cross product operator ||| xor	count=1
arg	p [arg_2] ||| pow mod [arg_2] [arg_1]	count=1
function	path to the ||| mod	count=1
module	e [module] t(a b ||| [module]	count=1
function	circumcenter is ||| circumcenter	count=1
class	of this [class] ||| [class]	count=3
function	random complex ||| random	count=1
arg	two polynomials ||| g k	count=1
module	numerical method ||| holonomic	count=1
class	over distribution ||| single continuous distribution	count=1
arg	of ||| x n	count=2
function	phrase and if ||| and	count=1
class	lift ||| quotient ring	count=1
class	array of ||| array	count=1
class	ie the location ||| permutation	count=2
function	that no ||| refine	count=1
class	ideal ||| implemented ideal	count=1
function	true if indices are ||| indices	count=1
function	[function_1] roots ||| [function_2] [function_1]	count=27
function	the derivative of ||| diff	count=2
function	create new ||| new rawargs	count=1
arg	in the terms using ||| terms	count=1
function	the center ||| center	count=2
arg	m such ||| a m	count=1
function	truncation according to ||| rs	count=1
arg	expr around ||| expr	count=1
arg	[arg_1] x gives ||| [arg_1] a [arg_2]	count=1
function_arg	a gf [arg_2] ||| [arg_2] [function_1]	count=9
class	interval until it is ||| real interval	count=1
function_arg	subtract dense [arg_2] ||| [function_1] f [arg_2]	count=1
function	instance [function_2] ||| [function_1] [function_2]	count=1
class	index pos 0 ||| index	count=1
function_arg	polynomials [arg_2] ||| [function_1] expand [arg_2]	count=1
arg	[arg_1] j parameters ||| [arg_1] [arg_2]	count=1
function_arg	trial [arg_2] ||| [function_1] [arg_2]	count=2
function_arg	down [arg_2] ||| [function_1] rule [arg_2]	count=1
function	list of ||| list include	count=2
function	one (the lazy series ||| series	count=1
function	cartan ||| cartan	count=2
module	available and leverage it ||| pretty	count=1
function	and leverage it ||| pretty try use	count=1
function_arg	[function_1] x ||| [arg_2] [function_1]	count=12
arg	[arg_1] [arg_2] repeated squaring ||| [arg_1] [arg_2]	count=2
function	derivation ||| derivation	count=1
arg	is endnumber ||| endnumber	count=1
function	multiply together several ||| expand	count=1
module_class	[module_1] polygon ||| [module_1] [class_2]	count=10
function	to an ode ||| ode 1st homogeneous coeff	count=1
arg	s, and ||| s	count=1
function	direction ratio of ||| direction ratio	count=2
function	z ||| z	count=3
function	simplified [function_2] ||| [function_1] [function_2]	count=4
function_arg	[function_1] a polynomial ||| [function_1] [arg_2]	count=3
function_arg	[function_1] [arg_2] ordered ||| physics quantum [function_1] [arg_2]	count=1
function	of the ||| eval	count=1
function	name ||| name	count=1
function	always create [function_2] ||| [function_2] [function_1]	count=2
arg	the actual [arg_2] ||| [arg_2] [arg_1]	count=8
arg	x y ||| x y	count=1
function_arg	variations [arg_2] ||| [arg_2] [function_1]	count=1
function	closes the ||| close	count=1
function	[function_1] terms of ||| [function_2] [function_1]	count=3
arg	p in [arg_2] ||| [arg_1] [arg_2]	count=2
function	matrix of a ||| matrix	count=1
function_arg	set [arg_2] ||| [function_1] [arg_2]	count=1
module	the expressions ||| geometry	count=1
arg	word ||| word	count=1
arg	and b by checking ||| b	count=1
function_arg	exp [arg_2] ||| [arg_2] [function_1]	count=1
arg	two univariate polynomials ||| g	count=2
function	subset of ||| subset	count=1
function	[function_1] transform of ||| [function_1] [function_2]	count=12
function	form of singularity functions ||| as singularity function	count=1
function	[function_1] key ||| [function_1] [function_2]	count=1
arg	number ||| s	count=1
function	pendulum ||| n link pendulum	count=1
function	two entities are similar ||| similar	count=1
class	[class_1] interval ||| [class_1] [class_2] refine	count=1
arg	for constructing the string ||| grid morphisms_str_info	count=1
function	ode are ||| linear 2eq order1 type5	count=1
function_arg	orbit [arg_2] ||| [arg_2] [function_1]	count=4
arg	[x] and a ||| a	count=4
module	containers of polynomials ||| polys	count=1
arg	user in ||| weylelt	count=2
function	factory [function_2] ||| [function_2] [function_1]	count=2
function	denest ||| denest	count=1
module	return a ||| agca	count=1
function	inverse hankel transform ||| inverse hankel transform	count=3
function	returns ||| eval	count=1
arg	at x_0 [arg_2] ||| [arg_2] [arg_1]	count=10
function	[function_1] a square ||| [function_1] [function_2]	count=1
function	out generators ||| dict from expr no gens	count=1
function	the list of operators ||| operators	count=1
function	returns the generators ||| generators	count=1
arg	the given domain ||| symbol domain	count=2
function	an ordinary decimal ||| decimal	count=1
function	the coefficient of ||| coeff add	count=3
arg	to f ||| f	count=4
function_arg	term for f ||| term f n	count=1
function	compute the inverse mellin ||| inverse mellin	count=1
function	lucas [function_2] ||| [function_2] [function_1]	count=2
arg	negative coefficient ||| exprs	count=1
function	2-axis ||| axis2	count=1
arg	n items ||| n k	count=1
arg	length l1 ||| l1	count=1
arg	to the divergence ||| vect doit	count=1
function	rational numbers ||| rational	count=1
function_arg	terms from [arg_2] ||| [function_1] [arg_2]	count=1
arg	terms of f ||| f x m	count=1
function	[function_1] order on ||| [function_1] [function_2]	count=1
function	unify [function_2] ||| [function_2] [function_1]	count=3
module	stub that should be ||| core	count=1
module	in s, and ||| utilities	count=1
function	dummy associated ||| dummy	count=1
function	if ||| try use	count=2
arg	expression and [arg_2] ||| [arg_1] [arg_2] increment	count=1
class	this method ||| base	count=1
class	system into ||| system	count=1
function	diagonal morphism [function_2] ||| [function_2] free space [function_1]	count=1
function	trial division ||| dmp trial division	count=2
arg	expr >>> ||| expr	count=1
class	two multivariate ||| dmp	count=3
arg	as find_pure_symbol ||| symbols unknown_clauses	count=1
class	[class_1] stringpicts ||| [class_2] [class_1]	count=3
function	size ||| degree	count=1
function	postprocess an expression after ||| postprocess for cse	count=1
class	coordinate of the ||| point3d	count=1
module	random ||| stats	count=21
function	add the given ||| indent	count=1
arg	unit ||| unit	count=1
function	coefficients ||| coeff	count=4
arg	[arg_1] a in ||| [arg_2] [arg_1]	count=7
arg	a base and ||| base gens	count=2
arg	expr, given that \operatorname{re} [arg_1] [arg_2] ||| [arg_1] [arg_2]	count=2
function	unit_propagate ||| propagate	count=1
arg	an expression [arg_2] ||| [arg_2] [arg_1]	count=7
function_arg	add [arg_2] ||| [function_1] f [arg_2]	count=1
function	values ||| param dict	count=1
arg	switch ||| native	count=2
function	dummies can be ||| ordered dummies	count=1
arg	2 ; -1 if [arg_1] [arg_2] ||| physics epsilon [arg_1] [arg_2]	count=7
arg	in ||| f prefix funcname	count=1
arg	mellin transform of ||| x helper	count=1
function	[function_1] evaluate ||| [function_2] [function_1]	count=1
function	with [function] ||| [function]	count=1
function_arg	prints [arg_2] ||| [arg_2] [function_1]	count=4
module	that ||| solvers	count=6
arg	[arg] with ||| [arg]	count=4
class	used ||| table	count=1
function	basis in ||| groebner	count=1
function	presentation is to be ||| presentation	count=1
function_arg	strictly increasing [arg_2] ||| [function_1] [arg_2]	count=2
arg	free ||| free	count=1
function	the [function] ||| decrement [function]	count=2
arg	a small'' matrix ||| deg_f deg_g row1	count=1
function	simple ||| simple	count=1
function	a string ||| get mod func	count=1
function	list of terms ||| terms	count=1
arg	values to function arguments ||| func_args	count=1
function	series for ||| rs	count=1
function	partitions ||| partitions	count=1
arg	an interval s t ||| s t	count=1
function	minimal polynomial of cos ||| cos	count=1
arg	expression and ||| expression	count=1
function	returns intrinsic [function_2] ||| [function_2] [function_1]	count=1
class	of ||| set	count=1
arg	the factors has root ||| factors x	count=1
function	coefficients using ||| coeff	count=1
arg	[arg_1] and dum ||| [arg_1] [arg_2]	count=1
function_arg	division [arg_2] ||| [function_1] [arg_2]	count=8
function	common start of sequences ||| common prefix	count=1
function_arg	power [arg_2] ||| [function_1] expr [arg_2]	count=3
arg	[arg_1] beta x ||| [arg_1] a [arg_2]	count=1
arg	true if expr is ||| expr	count=1
module	square root [module] sqrt ||| [module]	count=1
arg	number n ||| n m	count=1
class	body orientation takes this ||| body	count=1
function	[function_1] set ||| [function_1] [function_2]	count=4
function	proper superset ||| proper superset	count=2
function	- a where ||| sub ground	count=3
arg	of operators ||| operators	count=1
arg	for the ||| parameter	count=3
arg	>>> from sympy import ||| iszerofunc simplify	count=1
arg	p ||| n p	count=1
class	this [class] and ||| [class]	count=1
arg	j k is equal ||| j k	count=1
arg	in all [arg] ||| expr [arg]	count=2
module	return a ||| polys	count=1
class	is ||| free module	count=1
arg	does not [arg] lexicographic ||| [arg]	count=1
function	gegenbauer polynomial of degree ||| gegenbauer poly	count=1
function	p-1 ||| pm1	count=1
class	method of coset ||| coset	count=1
arg	args ||| args	count=4
module	equation is used ||| solvers	count=1
function	basis is zero-dimensional ||| is zero dimensional	count=2
function_arg	[function_1] indices are ||| [function_1] data [arg_2]	count=2
function	transversal for ||| transversal	count=1
function	boundary conditions applied on ||| boundary conditions	count=1
module	given vector ||| vector	count=1
function	- g*h where ||| sub mul	count=3
function_arg	have precision prec ||| evalf subs prec	count=1
arg	[arg_1] [arg_2] m_3 \rangle ||| [arg_1] [arg_2]	count=12
function	restricted to values below ||| below	count=1
arg	[arg_1] not in ||| [arg_1] symbols [arg_2]	count=3
function	[function_1] [function_2] for ||| [function_2] pr [function_1]	count=1
function	form [function_2] ||| [function_1] [function_2]	count=6
module	in the ||| physics quantum	count=1
module	the get_dim method using ||| physics	count=1
function	forcing vector above ||| forcing	count=1
function	[function_1] well defined ||| [function_2] [function_1]	count=1
arg	an integral curve ||| vector_field param start_point	count=1
arg	variable ||| name	count=5
class	this gate needs to ||| gate	count=1
class	the generated files ||| octave code gen	count=1
module	implementation [module_2] ||| [module_2] [module_1]	count=3
function	cosine [function] dcm also ||| rotation [function]	count=1
function_arg	[function_1] n data ||| [arg_2] [function_1]	count=2
function_arg	[function_1] scalar ||| [arg_2] [function_1]	count=6
function	create function with ||| create function	count=1
class	of all the sequences ||| seq mul	count=1
function	polynomial [function] ||| [function] max	count=1
arg	passed by ||| k	count=1
class	returns a ||| module	count=1
function	available and leverage ||| try use	count=1
module	by the ||| physics mechanics	count=1
function	terms ||| terms	count=2
module	true if the ||| physics quantum	count=1
arg	target to [arg_2] ||| [arg_2] [arg_1]	count=1
arg	with h ||| h base orbits	count=1
function	tell whether ||| is expr	count=1
arg	has root v ||| x v	count=1
function	negative coefficient ||| opt	count=1
module	the state ||| physics quantum	count=6
function_arg	[function_1] tri to ||| [function_1] [arg_2]	count=2
function	replace [function_2] ||| [function_2] [function_1]	count=4
arg	alpha as ||| alpha pairs	count=1
function	3-tuple a ||| three	count=1
function_arg	adds [arg_2] ||| [function_1] morphisms [arg_2]	count=5
function	solveset to ||| solveset	count=1
arg	if directed ||| seq directed	count=1
arg	corresponding [arg] ||| n m [arg]	count=1
function	dmf ||| global polynomial	count=1
function	generates hermite ||| hermite	count=1
function	cancel common factors ||| cancel	count=4
arg	a single g ||| a	count=1
function	normal part of ||| normal	count=1
function	coherent states of 1d ||| coherent state	count=1
arg	[arg_1] beta x ||| [arg_2] [arg_1]	count=1
function	generates the next ||| next	count=2
class	the c series every ||| type c	count=1
arg	t = ||| t	count=1
function	the mul [function_2] ||| [function_2] [function_1]	count=2
class	of coset enumeration ||| coset table	count=2
function	ring associated with self ||| get ring	count=1
function	assignment ||| lit assigned	count=1
function	of the atanh of ||| rs atanh	count=1
class	a ||| octave code	count=1
function	integer representation ||| int repr	count=1
function	and evaluate a polynomial ||| eval	count=1
arg	[arg_1] [arg_2] ||| [arg_1] ops [arg_2]	count=8
arg	objects and the ||| objects	count=1
function	the whole [function_2] ||| [function_2] [function_1]	count=1
function	return 1 instead ||| combine inverse	count=1
function	bound on polynomial solutions ||| bound degree	count=1
arg	f and ||| a d de z	count=1
function	returns the label ||| label	count=1
class	a list ||| field	count=1
function	of ||| empty in	count=1
class	set ||| product set	count=2
arg	find ||| exprs order	count=1
arg	complexes such that no ||| cls complexes	count=1
function	zero coefficient ||| zero	count=1
function	applied on ||| apply on	count=1
arg	infinitesimals are the actual ||| func	count=1
function	a table ||| table	count=1
arg	the modulus ||| modulus	count=1
function	gray [function_2] ||| [function_2] [function_1]	count=1
arg	replaced ||| args kwargs	count=1
function	lower bound ||| lower	count=1
arg	n if modulus is ||| n modulus	count=1
arg	return expr ||| expr	count=1
arg	[arg_1] an expr ||| [arg_2] [arg_1]	count=6
module	the type of ||| physics	count=1
arg	[arg_1] op for ||| [arg_1] [arg_2]	count=1
arg	a in ||| a	count=4
function	minimal polynomial ||| minpoly op algebraic element	count=1
function	factor primitive square-free ||| wang	count=1
function	of [function] ||| [function]	count=8
class	the generated ||| gen	count=2
function_arg	a where [arg_2] ||| [arg_2] [function_1]	count=18
function_arg	[function_1] of f ||| [function_1] ground [arg_2]	count=3
class	returns the ||| permutation	count=2
function	[function_1] module of ||| [function_2] [function_1]	count=2
function	[function_1] decomposition algorithm ||| [function_2] [function_1]	count=1
class	[class_1] n-dim array ||| [class_1] [class_2]	count=2
function	the functions in finite_set ||| not empty in	count=1
function	is negative ||| is	count=1
function	convert indices ||| from indices	count=2
function	expr [function_2] ||| [function_1] [function_2]	count=1
class	mapping ||| llvmjit code	count=2
function	of symbolic ||| create param dict	count=1
arg	symbol with [arg_2] ||| [arg_2] [arg_1]	count=1
function	below fermi? >>> ||| only below fermi	count=2
arg	[arg_1] f ||| [arg_2] [arg_1]	count=34
function_arg	fraction [arg_2] ||| [function_1] convergents [arg_2]	count=1
function	instance to a rational ||| to rational	count=1
function	a string ||| mod func	count=1
function	a sentinel of ||| sentinel	count=1
class	p[i] > p[i+1] ||| permutation	count=1
function	from gray coding ||| gray	count=1
class	input of ||| region	count=1
function	[function_1] for nthroot ||| [function_2] [function_1]	count=2
function	[function_1] rank of ||| [function_1] [function_2]	count=3
arg	two univariate polynomials ||| g p	count=1
arg	continuous ||| mu s	count=1
arg	in the [arg] ||| [arg]	count=1
function	if indices are ||| indices	count=1
module	prints the ||| combinatorics	count=1
module	return -1 ||| core	count=1
function	[function_1] strictly decreasing ||| [function_2] [function_1]	count=4
module	sympy core ||| core	count=2
function	variation of coincidence routine ||| coincidence c	count=1
function	refine a [function_2] ||| [function_1] [function_2]	count=4
function	cos or ||| tr9	count=1
class	interval until it ||| real interval	count=2
function	ratio of a given ||| ratio	count=1
function	a [function] ||| lcm [function]	count=2
arg	and sin ||| rv first	count=1
function	to a class ||| func	count=1
function	of symbolic values ||| param dict	count=1
function_arg	polynomial [arg_2] ||| [function_1] [arg_2]	count=9
class	the location where p[i] ||| permutation	count=2
function	[function_1] function for ||| [function_2] [function_1]	count=4
class	a grid ||| diagram grid	count=1
arg	iterable ||| iterable	count=1
function_arg	sturm sequence [arg_2] ||| [function_1] [arg_2]	count=4
arg	rotations are applied ||| name angle1 angle2 angle3	count=1
arg	for n this is ||| n	count=1
arg	return the root if ||| root radicals	count=1
module	return ||| polys	count=2
function	this method returns ||| free	count=1
class	if ||| max base	count=1
function	be ||| process limits	count=2
function	has a constant term ||| has constant term	count=1
function	in the berkowitz algorithm ||| eval berkowitz	count=1
module	of the [module] the ||| [module]	count=2
module	token + parenthesisgroup into ||| parsing	count=1
function	right coset table ||| coset table	count=2
arg	of f defined ||| f k r nu	count=1
class	where ||| permutation	count=2
function	a wigner ||| wigner	count=1
arg	or product expression ||| expr	count=1
arg	performs the ||| matlist k	count=1
function	returns the components of ||| components	count=1
function	dispatch a [function_2] ||| [function_1] [function_2]	count=1
arg	so that only func ||| func hint	count=1
class	for the generated ||| fcode	count=1
function	down a ||| top down	count=1
function	generating function ||| generating function	count=1
function_arg	[function_1] [arg_2] construct it and returns ||| [function_1] [arg_2]	count=1
module	matrix and ||| matrices	count=3
function	proper subset of ||| proper subset	count=2
function	series expansion for ||| intcurve series	count=1
function	in integer ||| symbol int	count=1
function	the discrete ||| discrete	count=3
class	the location ||| permutation	count=2
function	comparing two labeled polynomials ||| lbp	count=1
class	from the atoms ||| basic	count=1
class	for the generated ||| code	count=1
function	path to ||| get mod	count=2
class	automatically ||| extension	count=1
arg	by differentiating under the ||| sym	count=1
arg	c i ||| n c condition	count=1
function	[function_1] integer ||| [function_1] [function_2]	count=7
function	a univariate ||| root	count=1
arg	contain nested square roots ||| nested	count=1
function	normal ordered [function] where each ||| normal ordered [function]	count=1
function	polynomial [function] ||| [function] l1	count=1
function	the coefficient from the ||| coeff	count=1
module	is available and ||| pretty	count=1
function	maximum proper divisor ||| max div	count=1
class	a ||| free	count=2
function	polynomials ||| dmp	count=1
function	[function_1] in z[x] ||| [function_2] [function_1]	count=6
module	of [module] knuth-morris-pratt algorithm ||| [module]	count=1
function	clear ||| dup clear	count=1
function	to an ode ||| ode 1st homogeneous	count=1
module	mathml code ||| mathml	count=1
arg	backend function ||| f t s_ simplify	count=1
arg	c^2 = [arg] ||| [arg]	count=3
function	series of "e" ||| series	count=1
class	the ||| code	count=2
arg	[arg_1] x note ||| [arg_1] [arg_2]	count=1
function	a class ||| mod func	count=1
function	differential equation ||| euler eq	count=2
function_arg	[function_1] element ||| [arg_2] [function_1]	count=1
function	matrix elements ||| elements	count=1
function_arg	[function_1] x_j ||| [arg_2] [function_1]	count=6
function	the functions ||| in	count=1
function	string ||| get mod func	count=2
arg	take ||| m	count=1
function	ode ||| order1 type4	count=1
module	symbolic base and ||| core	count=1
class	function ||| function	count=9
arg	order o ||| o k	count=1
class	of qubits this gate ||| gate	count=1
function	function [function_2] ||| [function_2] [function_1]	count=11
arg	their respective multiplicities ||| limit use_trial use_rho	count=1
function	which ||| not	count=1
module	x ||| elementary	count=1
module_class	[module_1] scheme ||| [module_1] [class_2]	count=1
function_arg	[function_1] for suitability ||| [function_1] [arg_2]	count=4
arg	the truth value of ||| cls	count=1
function	symbolic values ||| dict	count=1
function_arg	[function_1] in options=s ||| [function_1] [arg_2]	count=1
arg	msg ||| msg	count=4
arg	length l ||| l	count=1
function	of the underlying undirected ||| undirected	count=1
arg	with [arg] algebraic ||| [arg]	count=1
function	less than the ||| lt	count=1
function	f - ||| sub	count=3
function	in closed form ||| doit	count=1
arg	type of f ||| f x	count=1
arg	the given expression ||| expr ratio	count=2
function	lowering the degree ||| tr7	count=1
function	removes [function_2] ||| [function_1] [function_2] inds	count=1
function	to ||| apply	count=1
function_arg	1st [arg_2] ||| [function_1] exact [arg_2]	count=1
function	thus the ||| singleton	count=1
arg	in rules ||| p rules x	count=1
arg	controls targets and target_matrix ||| controls targets target_matrix nqubits	count=1
class	qubits this gate needs ||| cnot gate	count=1
function	steps ||| steps	count=1
arg	multiplication ||| scaler	count=1
function	from a [function_2] ||| [function_2] [function_1]	count=6
function	the identity [function_2] ||| [function_2] [function_1]	count=3
function_arg	transversal of the right [function_1] [arg_2] second method described in ||| [function_1] transversal [arg_2]	count=2
module_class	number of corners of [module_1] [class_2] ||| [module_1] [class_2]	count=2
function	sympy expression in ||| parse expr	count=2
function	compute the gcd ||| gcd	count=1
arg	commutation parameter c ||| c	count=1
module_class	[module_1] ray and ||| [module_1] [class_2]	count=2
arg	subtracting pt ||| z pt	count=2
arg	an accuracy ||| subs maxn chop	count=1
function	"get a zeros matrix ||| matrix zeros	count=1
module_class	if 'self' [class_2] ||| [module_1] [class_2]	count=2
module_class	the wave ||| physics optics twave	count=5
arg	mml ||| mml	count=1
function	digamma ||| digamma	count=1
arg	in a given frame ||| frame	count=1
module_class	[module_1] factorial ||| [module_1] [class_2]	count=2
class	that are generated ||| extension	count=1
arg	using g functions ||| g	count=1
arg	return product [arg_1] [arg_2] with int 1 so ||| [arg_1] [arg_2]	count=1
arg	[arg] which ||| [arg]	count=3
function	atanh of p, about ||| atanh	count=1
class	this [class] an eigenstate ||| [class]	count=1
function	generating function for ||| guess generating function	count=2
module	vector instance ||| vector	count=1
function	a unit ||| find unit	count=1
function	a function ||| function	count=2
arg	x c if c ||| c min	count=1
function	coefficients of ||| content	count=2
class	kb examples ||| kb	count=1
function	less than ||| lt	count=1
module	the input ||| combinatorics	count=1
module	to allow ||| core	count=1
function	sum to ||| sum	count=1
function	[function_1] distributed module ||| [function_2] [function_1]	count=1
module	finite_set in ||| calculus	count=1
arg	[arg_1] two ||| [arg_2] [arg_1]	count=2
arg	of f ||| f n	count=3
arg	m_1 m_2 ||| m_1	count=1
arg	j_2 j_3 ||| j_2 j_3	count=6
function	refine ||| inner refine real	count=1
arg	expr ||| expr simplify	count=1
module_class	along the [class_2] ||| [module_1] [class_2]	count=2
class	basis in ||| sub	count=1
function	type of ode are ||| 2eq order1 type6	count=1
function	finds the domain of ||| empty in	count=1
class	a permutation ie ||| permutation	count=2
arg	it into an ||| expr	count=1
function	[function_1] class ||| [function_1] [function_2]	count=4
class	the generated ||| fcode	count=1
class	sort roots ||| complex root of	count=1
function	[function_1] degrees ||| [function_2] [function_1]	count=6
module	vectors ||| vector	count=1
arg	\mathbb{z}_p and ||| evalpoints hpeval ring i	count=1
function_arg	finite [arg_2] ||| [function_1] diff derivative [arg_2]	count=1
arg	g modulo [arg_2] ||| [arg_2] [arg_1]	count=4
arg	source into expressions ||| source	count=1
class	[class_1] data ||| [class_2] [class_1]	count=6
function	to a fully ||| tensorhead from	count=1
arg	get_dim method using key ||| key	count=1
module_class	generates the [class_2] ||| [module_1] [class_2]	count=4
function	the coset [function_2] ||| [function_1] [function_2]	count=2
function	of the nth ||| nth	count=1
function_arg	[function_1] f as ||| [arg_2] [function_1]	count=1
module	p[i] < p[i+1] ||| combinatorics	count=1
function	hensel lifting in ||| dup zz hensel	count=2
function	a basic expression ||| basic	count=1
function	get the real ||| real	count=1
function	and negative coefficient muls ||| cse	count=1
arg	[arg_1] [arg_2] ||| [arg_2] grid [arg_1]	count=10
function	infimum ||| inf	count=1
function_arg	[function_1] f ||| polys dmp apply [function_1] [arg_2]	count=1
module	compute the ||| combinatorics	count=2
function	with hash [function_2] ||| [function_1] [function_2]	count=1
function	[function_1] exponent ||| [function_1] [function_2]	count=5
arg	a path ||| path	count=1
function	[function_1] type ||| [function_2] [function_1]	count=6
arg	p q ||| p q x	count=12
function_arg	transversal of the right [function_1] [arg_2] the second method described ||| [function_1] [arg_2]	count=2
function	greater ||| add	count=1
function	transversals from ||| transversals from bsgs	count=1
function	field ||| to field	count=2
module	this kroneckerdelta ||| concrete	count=1
function	= [function] a1 , ||| split [function]	count=1
function	addition ||| add	count=1
function	returns [function_2] ||| [function_2] [function_1]	count=15
class	or more linear ||| linear	count=1
class	which [class] preferred to ||| [class]	count=1
class	matrix with ||| matrix	count=1
arg	for two ||| g p	count=1
function	quadrants from a ||| intervals to quadrants	count=1
arg	in x_0 in k[x] ||| u	count=1
function	the next [function] taylor ||| taylor [function]	count=1
function	_eval_nseries if ||| nseries	count=1
function	in dictionary, [function] ||| [function] dict	count=3
function	takes as input two ||| as	count=1
module	that no bounding ||| polys	count=1
function	[function_1] rank ||| [function_2] [function_1]	count=3
function	(self[i j], [function] ||| [function] row	count=2
module	of ||| polys	count=101
module	if k ||| core	count=1
module	the class ||| utilities	count=1
function_arg	[function_1] root1 ||| [function_1] [arg_2] root2	count=1
class	method ||| basic	count=1
function	python's fraction ||| qq python	count=3
function	mapping ||| create param	count=1
module_class	for the curve ||| geometry curve	count=1
function	unit ||| one	count=3
arg	t ||| a d t	count=1
function	continuous subsequence ||| dmp slice	count=2
arg	plane varying t from ||| t	count=1
function	standardised right coset ||| coset	count=1
class	a single [class_2] ||| [class_1] [class_2]	count=1
function_arg	[function_1] i by ||| [function_1] rsa [arg_2]	count=2
class	c series every ||| type c	count=1
function	number of distinct real ||| real	count=1
function	subprocess with hash ||| subprocess with hash	count=1
function	[function_1] heuristic uses ||| [function_2] [function_1]	count=1
function	to real ||| convert to	count=1
module	by ||| simplify	count=1
function	the 1-axis ||| axis1	count=1
arg	that yields the k-tuples ||| k zeros	count=1
arg	q are in z[x] ||| q	count=2
function_arg	apply a [arg_2] ||| [arg_2] [function_1]	count=4
function	dmf object ||| fraction	count=1
class	xy-pic representation of ||| drawer	count=1
function	of k ||| of	count=1
arg	has already been sympify'ed ||| f symbol domain _check	count=1
function_arg	[function_1] p [x] ||| [function_1] monic f [arg_2]	count=3
function	bottom ||| bottom	count=1
function	take on ||| free	count=1
function	[function_1] homomorphism to ||| [function_1] [function_2]	count=2
arg	the ||| s	count=3
function	f - g*h where ||| sub mul	count=2
module_class	[module_1] [class_2] ||| [module_1] optics ray transfer [class_2]	count=4
function	of sin ||| minpoly sin	count=1
class	is currently ||| symbol factory	count=1
function_arg	[function_1] point ||| [function_1] force vec [arg_2]	count=1
arg	object by differentiating under ||| sym	count=1
function	normal ||| normal	count=9
function	find the minimum power ||| min pow	count=1
arg	numerical approximations [arg_2] ||| [arg_2] [arg_1]	count=4
arg	details ||| x re g	count=1
arg	with p ||| p	count=2
arg	j_3 j_4 j_5 j_6) ||| j_3 j_4	count=1
arg	j_2 m_2 | j_3 ||| j_2 j_3	count=1
class	writes ||| gen	count=2
function	using the horner scheme ||| eval	count=2
function	self to [function_2] ||| [function_1] [function_2]	count=2
function_arg	[function_1] f p ||| [function_1] puiseux2 [arg_2]	count=1
function	for computing the discrete ||| discrete	count=2
arg	to name [arg_2] ||| [arg_1] [arg_2]	count=3
function	linear differential [function_2] ||| [function_2] [function_1]	count=4
arg	curve ||| curve	count=1
arg	points in ||| points	count=1
function_arg	evaluate a [arg_2] ||| [function_1] f m a [arg_2]	count=2
module	lagrangian ||| physics mechanics	count=1
function	simple roots together ||| simple roots	count=2
function	jacobi ||| jacobi	count=2
function	[function_1] norm of ||| [function_2] [function_1]	count=10
function_arg	addends [arg_2] ||| [function_1] [arg_2]	count=2
module	accepts a [module] of ||| [module]	count=3
class	of a set ||| set	count=2
function	where each basic element ||| element	count=1
arg	return true if p ||| p	count=3
module	[module_1] wavefunction ||| [module_1] [module_2] differential operator function	count=1
function	ring ||| to ring	count=2
function	[function_1] a quasi-particle? ||| [function_1] [function_2]	count=1
arg	h are ||| h	count=4
function_arg	a holonomic [arg_2] ||| [arg_2] [function_1]	count=1
class	line ||| line	count=1
arg	ring provided p is ||| p c	count=1
arg	x_j = a ||| a j	count=2
function_arg	expressions generated [arg_2] ||| [function_1] [arg_2]	count=2
function	precedence of a ||| precedence	count=1
function	a polynomial [function] ||| [function] max	count=1
module	permutation representing ||| combinatorics	count=1
function	of ||| eval	count=2
function_arg	the extension in ||| extension ip	count=1
class	intervals ||| complex	count=1
arg	the argument passed by ||| arg k	count=1
function	entity parallel ||| parallel	count=1
function	recalculate the ground ||| retract	count=1
module_class	the controlled gate ||| physics quantum cgate	count=1
arg	the anti-derivative to the ||| meijerg risch	count=1
function_arg	[function_1] [arg_2] ||| [function_1] sqr f [arg_2]	count=2
arg	factors has root v ||| factors x v	count=1
arg	has root v ||| v	count=1
class	hole ||| fermion	count=4
function	non-zero elements in ||| nnz	count=1
function	bitlist corresponding [function_2] ||| [function_1] [function_2]	count=2
function_arg	[function_1] in q[x] ||| [function_1] [arg_2]	count=3
class	[class_1] with ||| [class_2] [class_1]	count=3
function_arg	extract from a tensexpr [function_1] [arg_2] ||| physics hep [function_1] [arg_2]	count=1
function	of triangles ||| list triangles	count=1
arg	the tuple m representing ||| m	count=1
arg	the beginning of ||| s	count=1
module	any hints given ||| integrals	count=1
function_arg	set [arg_2] ||| [function_1] comm i j [arg_2]	count=1
module_class	this point with ||| vector point	count=2
arg	in seq ||| seq	count=2
module	[module] p1) examples ||| [module]	count=3
arg	representing a ||| n p succ	count=1
function	outer indices of ||| indices	count=1
function	apply this ||| apply	count=1
function	lcm [function_2] ||| [function_2] [function_1]	count=14
arg	of square-free polynomial ||| polys k eps inf	count=1
arg	as a single ||| x a b	count=1
arg	given a random expression ||| expr	count=1
function	[function_1] truncation according ||| [function_2] [function_1]	count=2
arg	in x_0 of a ||| m u k	count=1
arg	rule if ||| cond rule	count=2
function	eye and tensor_product for ||| eye	count=1
function	the leading coefficient of ||| gf lc	count=1
function	function for :func dup_decompose ||| dup decompose	count=1
function	subgroup whose presentation is ||| reidemeister presentation	count=1
function	returns the symbols in ||| symbols	count=1
arg	[arg] used to ||| expression [arg]	count=2
class	that no ||| complex	count=1
function	returns angular [function_2] ||| [function_1] [function_2]	count=1
arg	process ||| fail	count=1
arg	mellin transform of ||| x	count=1
arg	\eta ||| match comp	count=4
arg	[arg_1] representing ||| [arg_2] [arg_1]	count=1
arg	and returns ||| msg	count=1
function	return the leading coefficient ||| lc	count=1
function	the first derivative of ||| fdiff	count=1
function_arg	basis [arg_2] ||| [arg_2] [function_1]	count=1
arg	a continuous ||| mu s	count=1
function	loads in ||| loads	count=1
module	from the list ||| physics	count=1
class	whether a replacement actually ||| basic	count=1
function	mul hint [function_2] ||| [function_2] [function_1]	count=2
function	the series [function_2] ||| [function_2] [function_1]	count=2
arg	a condition ||| condition	count=1
function	to y_i ||| deflate	count=1
function	the area ||| area	count=1
function	factor having root ||| choose factor	count=2
arg	[arg_1] representing ||| [arg_1] [arg_2]	count=1
function	string path to a ||| get mod func	count=1
class	standard basis in ||| module	count=1
module	[module_1] underlying dimension ||| [module_1] [module_2]	count=6
arg	[arg_1] is the ||| [arg_1] [arg_2]	count=1
arg	symbol ||| j_1	count=3
module	for each [module] ||| [module]	count=1
arg	of [arg] as ||| [arg]	count=1
module	where p[i] > p[i+1] ||| combinatorics	count=1
arg	modulo a constant p ||| p	count=1
function_arg	[function_1] f p ||| [function_1] [arg_2]	count=3
function_arg	[function_1] f s ||| [arg_2] [function_1]	count=10
arg	seq ||| seq	count=6
function	odd ||| odd	count=2
module_class	[module_1] polynomial ||| [module_1] [class_2]	count=20
arg	[arg_1] log-normal ||| [arg_2] [arg_1]	count=1
arg	t from 0 ||| t	count=1
function	subprocess ||| subprocess	count=1
function	return square-free part ||| sqf part	count=2
function	third heuristic ||| lie heuristic bivariate	count=1
function	decide how [function_2] ||| [function_1] [function_2]	count=1
class	[class] inject ||| [class]	count=2
class	matrix ||| sparse matrix	count=8
function	generates hermite [function_2] ||| [function_1] [function_2]	count=1
arg	tree ||| tree	count=3
arg	of the routines in ||| routines f prefix	count=2
class	group of ||| group	count=1
function	be written as ||| as	count=1
function	bound on ||| bound degree	count=1
function	sort generators in a ||| sort	count=1
module	gate identities from the ||| physics quantum	count=1
class	a group ||| permutation group	count=1
arg	function which performs gl ||| function	count=2
function	classes ||| class	count=1
function	the top ||| top	count=2
function	is [function] matrix ||| is [function]	count=1
function	[function_1] moment curve ||| [function_2] [function_1]	count=4
arg	function for functions checking ||| expression predicate interval	count=1
function	return [function] ||| [function]	count=1
arg	[arg_1] [arg_2] is a string and ||| [arg_2] [arg_1]	count=3
function	the transposed sparsematrix of ||| transpose	count=1
class	standard ||| sub module poly	count=1
function	ternary diophantine equation ||| diop ternary	count=1
arg	the ith ||| i j	count=1
arg	and for each di ||| a d de z	count=1
module	prime factors of ||| ntheory	count=2
function	reaction forces ||| reaction loads	count=1
function	*one* variable ||| eval nseries	count=1
function	+ g*h where ||| add mul	count=3
function_arg	expr cond [arg_2] ||| [function_1] [arg_2]	count=1
arg	two [arg_2] ||| [arg_2] [arg_1]	count=1
function	leverage it if ||| try use	count=1
function	[function_1] multiple of ||| geometry point [function_1] [function_2]	count=3
function	greatest factorial factorization ||| gff list	count=1
module	and leverage it if ||| printing	count=1
function_arg	[function_1] names and ||| [arg_2] [function_1]	count=2
function	piecewise form ||| as piecewise	count=2
function	that consists of syllables ||| syllables	count=1
function	[function_1] edge ||| [function_1] [function_2]	count=2
arg	test if f ||| f k irreducible	count=1
function_arg	preprocess [arg_2] ||| [function_1] [arg_2]	count=4
arg	mpf tuple normalized appropriately ||| mpf	count=1
class	commutator ||| group element	count=1
function	tensor product of ||| tensor	count=1
arg	f in k[x], useful ||| f u	count=1
arg	changes the point ||| lenics	count=1
function	the digamma function is ||| digamma	count=1
function	leverage it if possible ||| use	count=1
function_arg	subtract [arg_2] ||| [function_1] f [arg_2]	count=1
class	symbolic values ||| llvmjit code	count=1
function	returns the square root ||| sqrt	count=1
class	represented explicitly returns an ||| expr	count=1
arg	the supplied dictionary morphisms ||| morphisms	count=1
module	the name of the ||| utilities	count=1
arg	factors using ||| f factors u	count=1
function	polynomial gcd ||| gcd	count=7
class	this gate needs ||| cnot gate	count=1
class	crootof ||| root of	count=1
class	new tids ||| tids	count=1
function	[function_1] the trivial ||| [function_2] [function_1]	count=1
arg	compute partial fraction ||| f	count=1
function_arg	[function_1] f ||| [function_1] irreducible [arg_2]	count=2
class	standard ||| ring	count=1
function	delta ||| big delta	count=1
class	method ||| series	count=1
arg	argument passed by ||| k	count=1
arg	state corresponding [arg] ||| n [arg]	count=1
function	[function_1] coefficient iterator ||| [function_2] [function_1]	count=1
function_arg	[function_1] [arg_2] permutation group ||| [function_1] [arg_2]	count=1
function	function for sum ||| sum	count=1
function	returns the position ||| position	count=1
function	converts an add/mul of ||| qubit to	count=1
function	this heuristic uses the ||| lie heuristic	count=1
function	function is [function_2] ||| [function_2] [function_1]	count=14
function	permutation [function_2] ||| [function_1] [function_2]	count=7
module_class	self quot ||| polys agca free	count=1
arg	im ||| im	count=1
arg	formula to an accuracy ||| subs maxn chop	count=1
class	list of polynomial ||| frac	count=1
arg	the model ||| clauses model	count=1
function	be of ||| process limits	count=1
arg	of gen in self ||| gen	count=1
function	[function_1] [function_2] of ||| [function_1] [function_2]	count=80
function	map x_i**m_i [function_2] ||| [function_2] [function_1]	count=3
function	memoized version of a ||| memoize	count=1
class	coordinate system ||| coord sys cartesian	count=2
function	is strictly ||| is strictly	count=4
function	nine-point circle ||| nine point circle	count=1
arg	lb ||| lb	count=1
module_class	of the freegroup ||| combinatorics free group	count=1
function	an ordinary point ||| ordinary	count=1
function	lie group method of ||| lie group	count=1
class	and sort roots ||| root of	count=2
function	to another ||| connect to	count=1
function	of square-free ||| sqf	count=2
function	of the different types ||| naive	count=1
arg	of the [arg_2] ||| [arg_2] [arg_1]	count=1
function	computing i^e ||| rsa	count=1
arg	an expression ||| expr a	count=1
arg	differential equation ||| eq	count=2
module	returns [module_2] ||| [module_1] [module_2]	count=2
function	of a loop morphism ||| process loop morphism	count=1
function	evaluate ||| eval	count=7
module	x ||| series	count=1
arg	[arg] m_3 ||| j_1 [arg]	count=1
function	those that ||| free	count=1
function	to a string [function_1] [function_2] ||| printing [function_1] [function_2]	count=1
arg	the objects and the ||| objects merged_morphisms	count=1
module	geometry ||| geometry	count=1
function_arg	to check [arg_2] ||| [function_1] hom [arg_2]	count=3
function	available and ||| try	count=1
arg	message [arg] ||| i [arg]	count=1
module	the algorithm starts by ||| physics	count=1
function	path to the ||| get mod func	count=1
function	ode from ||| ode 1st	count=1
function	for ||| get	count=2
arg	c i e ||| n c condition	count=1
function	the finite difference ||| finite	count=1
arg	small'' matrix m to ||| deg_f deg_g row1 row2	count=1
arg	techniques ||| domain	count=1
function_arg	[function_1] j see ||| [function_1] i [arg_2]	count=1
function	[function_1] gf ||| [function_2] sqf [function_1]	count=1
function_arg	add [arg_2] ||| [arg_2] [function_1]	count=2
arg	returns l and u ||| k reverse	count=1
arg	create [arg] continuous ||| name [arg]	count=1
function	returns the symbols that ||| free symbols	count=2
function	remainder of ||| rem	count=5
function	free indices corresponding to ||| free indices	count=1
function	dimensions ||| shape	count=1
arg	d2 ||| d2	count=1
class	homomorphism obtained by ||| module homomorphism	count=1
function	and if ||| and join	count=1
function	finds the degree ||| find degree	count=1
class	for ||| class	count=1
class	rectangles of ||| root of	count=1
function	function ||| simplify	count=1
function	[function_1] real ||| [function_1] [function_2]	count=3
function	[function_1] of ||| [function_2] [function_1]	count=5
function	these type ||| linear 2eq order2	count=2
arg	on ||| l2	count=1
arg	for n data ||| n	count=1
arg	[arg] of morphisms ||| a [arg]	count=1
arg	anti-derivative ||| meijerg risch	count=1
module	of space characters to ||| utilities	count=1
arg	primes and e ||| e	count=1
class	standard basis in ||| poly ring	count=1
function	numerator ||| an	count=1
function	class into ||| mod func	count=1
function_arg	a sequence [arg_2] ||| [function_1] i [arg_2]	count=1
function_arg	solve a [arg_2] ||| [function_1] biquadratic f [arg_2]	count=1
function	use ||| pretty use	count=1
arg	find optimization opportunities in ||| exprs	count=1
function	a weibull ||| weibull	count=1
class	product with ||| tens mul	count=3
function	returns polynomial lcm of ||| lcm	count=1
arg	n ||| n candidates	count=1
arg	f into ||| f u	count=1
arg	expression expressions ||| expr callback_type	count=1
arg	field ||| field	count=8
arg	function for fast calculation ||| args expr modules printer	count=1
class	to ||| polynomial ring	count=3
class	a matrix ||| dense matrix	count=1
function	[function_1] root edge ||| [function_1] [function_2]	count=1
arg	with the comparison operator ||| op	count=1
function	gmpy's [function_2] ||| [function_2] [function_1]	count=4
class	to ||| printer	count=4
class	basic args ||| basic	count=1
arg	of f defined ||| f k r	count=1
arg	o ||| o	count=3
function	bound for [function_2] ||| [function_2] zz mignotte [function_1]	count=1
function	of p ||| p	count=1
function	find_substitutions sympy's [function] some trig ||| manual [function]	count=1
arg	and exponents ||| combine force	count=1
function	wang/eez test evaluation points ||| dmp zz wang test points	count=1
function	the third heuristic assumes ||| lie heuristic bivariate	count=1
function	the object excluding ||| free	count=1
arg	and returns the ciphertext ||| msg	count=1
class	compute the ideal ||| ideal	count=2
module	a list of ||| polys	count=4
class	sympy sets set ||| set	count=1
module	matrix to ||| matrices	count=1
module	new tensor indices ||| tensor	count=1
module	generates the ||| combinatorics	count=3
module	finds the ||| physics quantum	count=1
arg	[arg] reduced ||| [arg]	count=1
arg	fundamental strip ||| x strip	count=1
module	it ||| pretty	count=1
arg	[arg] row of ||| matlist [arg]	count=2
function	polynomial to ||| polynomial	count=4
arg	bound in the model ||| clauses model	count=1
arg	of subgroup ||| strategy	count=1
function_arg	modularinteger int [arg_2] ||| [arg_2] [function_1]	count=1
arg	is the public key ||| key	count=2
function_arg	integer partition [arg_2] ||| [function_1] [arg_2]	count=1
arg	and negative ||| exprs order	count=1
function	in finite_set in ||| not empty in	count=1
arg	point pt ||| pt	count=1
arg	[arg_1] cheap ||| [arg_2] [arg_1]	count=3
function	atan of p, ||| atan	count=1
arg	of size n ||| n g	count=1
function	instance to [function_2] ||| [function_2] [function_1]	count=2
function	2d n-link pendulum on ||| n link pendulum on	count=1
arg	k == 2 ||| k	count=1
function	the domain of the ||| in	count=1
module_class	a [class_2] ||| [module_1] [class_2]	count=4
arg	specified in y ||| y	count=1
arg	substitutes corresponding sols ||| sols func	count=1
function	[function] of ||| group [function]	count=3
module	wave travelling in the ||| physics	count=1
class	ie the location where ||| permutation	count=2
arg	[arg] and ||| a b [arg]	count=3
function	defined [function] ||| [function] new	count=1
class	singularity function expression ||| singularity function	count=1
function_arg	instance [arg_2] ||| [arg_2] [function_1]	count=2
class	ending ||| printer	count=1
function_arg	[function_1] in x_0 ||| [arg_2] [function_1]	count=1
function_arg	subtract [arg_2] ||| [arg_2] [function_1]	count=2
arg	in ||| ip	count=2
arg	base b ||| b order	count=3
arg	corresponding sols ||| sols	count=1
arg	specified [arg_2] ||| [arg_2] [arg_1]	count=4
function	terms from a ||| terms	count=2
function_arg	adds a [arg_2] ||| [function_1] [arg_2]	count=1
function_arg	numerator [arg_2] ||| [function_1] [arg_2]	count=1
function	triangle ||| triangle	count=5
class	writes ||| code gen	count=2
function	all the implications of ||| deduce all	count=1
class	tuples index ||| index structure	count=1
function	the functions ||| empty in	count=1
arg	[arg_1] [arg_2] is a plaintext message ||| crypto encipher elgamal [arg_2] [arg_1]	count=2
arg	of the ||| f	count=2
function_arg	pseudo-remainder of [arg_2] ||| [function_1] [arg_2]	count=2
arg	[arg_1] selected by ||| [arg_1] [arg_2]	count=5
function	automatically ||| auto	count=1
function	power and den is ||| power	count=1
function	reduced groebner basis ||| groebner	count=2
arg	set of points in ||| points	count=1
function	are disjoint ||| disjoint	count=2
arg	triangle ||| triangle	count=1
function	for solveset to return ||| solveset	count=1
arg	[arg_1] in z_p ||| [arg_2] [arg_1]	count=1
module_class	'rotation matrix' of [module_1] [class_2] ||| [module_1] [class_2]	count=8
arg	[arg_1] [arg_2] ||| [arg_1] args [arg_2]	count=2
arg	in x_j ||| j	count=2
class	lcm ||| polynomial ring	count=1
function	solve multivariate ||| dmp	count=1
function	berkowitz algorithm ||| berkowitz	count=1
function	sympy's [function] some ||| manual [function]	count=1
arg	c % [arg] ||| a [arg]	count=3
function_arg	denest [arg_2] ||| [arg_2] [function_1]	count=1
function	is available and leverage ||| try use	count=1
arg	the base scalars of ||| coord_sys	count=2
function	[function_1] num/den by ||| [function_2] [function_1]	count=2
function	to a class into ||| get mod func	count=1
function	postprocess ||| postprocess	count=1
arg	p if gcd a ||| a	count=1
arg	f in x_j ||| f m j	count=1
function	[function_1] of indices ||| [function_1] [function_2]	count=1
function_arg	multiply [arg_2] ||| [function_1] m [arg_2]	count=3
class	plane and another geometric ||| plane	count=1
arg	of constants ||| variable constant k	count=3
arg	[arg_1] modulo n ||| [arg_2] a [arg_1]	count=9
module	else none ||| core	count=1
function_arg	length [arg_2] ||| [function_1] [arg_2]	count=2
arg	p - 1 references ||| p	count=1
class	the polynomial [class_2] ||| [class_1] [class_2]	count=1
function	[function_1] the orbit ||| [function_2] [function_1]	count=6
function_arg	affine cipher ||| affine msg key	count=1
arg	set of operators ||| operators	count=1
function	evaluate a ||| dmp eval	count=1
module	permutation representing the ||| combinatorics	count=1
function	dictionary from [function_2] ||| [function_2] to [function_1]	count=1
arg	of constants ||| matlist variable constant	count=3
module	that are generated automatically ||| integrals	count=1
arg	[arg_1] if n ||| [arg_2] [arg_1]	count=2
arg	occupations is a ||| cls occupations	count=1
arg	after subtracting pt -- ||| z pt	count=1
arg	[arg_1] j ||| [arg_2] [arg_1]	count=2
class	writes a ||| octave code gen	count=1
function	values ||| create param	count=1
arg	product of a ||| a	count=1
arg	\operatorname{re} [arg] ||| expr [arg]	count=2
function	reversion of a ||| reversion	count=1
arg	q x prec ||| q x	count=2
arg	that appears in old ||| old	count=1
function	emanates ||| source	count=1
class	creating ||| index structure	count=1
arg	j_1 [arg_2] ||| clebsch gordan [arg_1] [arg_2]	count=4
module	the dictionary ||| physics quantum	count=1
arg	of ||| polys k eps inf	count=1
function	that no bounding rectangles ||| refine	count=1
function	z[x] [function] ||| subresultants [function]	count=6
function_arg	[function_1] gr ||| [arg_2] [function_1]	count=1
function	of classes ||| class	count=1
arg	objects ||| objects merged_morphisms	count=1
arg	is other ||| other	count=4
arg	variable with ||| name b eta	count=1
arg	f ||| f c u	count=2
function	nth root of ||| nth root1	count=1
function	class ||| class	count=3
function	a logistic ||| logistic	count=1
function	at a point ||| call	count=1
arg	lagrangesmethod lagrangian : sympifyable ||| lagrangian	count=1
function	unit_propagate but arguments are ||| propagate	count=1
function_arg	[function_1] [arg_2] ||| [function_1] single [arg_2]	count=4
function	written as ||| as f	count=1
arg	types ||| types	count=1
function	verify ||| verify	count=1
function	type ||| type	count=1
arg	b r are ||| b r	count=2
class	the ||| base	count=7
function	form lagrange's equations ||| form lagranges equations	count=3
function	mul hint see ||| mul	count=1
module	one step of ||| polys	count=1
function_arg	[function_1] local_dict ||| [arg_2] [function_1]	count=1
class	that take on ||| base	count=1
function	to an ode ||| ode	count=2
arg	[arg] then ||| [arg]	count=3
function	[function_1] free space ||| [function_1] [function_2]	count=6
function	+ ||| dmp add	count=1
function	to switch to ||| connect to	count=1
function	from binary coding to ||| to	count=1
function_arg	triangle tri ||| weld triangle tri	count=1
arg	x**n ||| n	count=1
function_arg	roots of f ||| count roots f	count=4
class	the [class] the ||| [class]	count=1
module_class	the body ||| physics mechanics body	count=1
module	returns ||| physics	count=1
function	expansion of the atan ||| rs atan	count=1
arg	occupations is ||| cls occupations	count=1
function	for product ||| product	count=1
arg	the key matrix ||| key	count=1
function	return the order ||| order	count=1
arg	tree join ||| tree join	count=2
class	complex [class_2] ||| [class_2] [class_1]	count=5
arg	polynomials [arg_1] [arg_2] ||| [arg_1] [arg_2]	count=16
function_arg	trial factors n ||| trial factors n	count=1
arg	q are ||| q	count=7
class	method returns the ||| series base	count=1
function_arg	puiseux series [arg_2] ||| [function_1] [arg_2]	count=5
arg	f ||| f coeff	count=5
function	in explicit ||| explicit	count=1
arg	alpha as a ||| degree generators alpha	count=1
function	fraction to ||| qq	count=2
function	[function_1] two ||| [function_2] [function_1]	count=2
arg	the objects and ||| objects merged_morphisms	count=1
function_arg	[function_1] of rv ||| [function_1] [arg_2]	count=2
function	the whole ||| whole	count=1
function	atan of p, ||| rs atan	count=1
class	this gate ||| cnot gate	count=1
function	default printing behavior of ||| sympystr	count=1
function	trace of ||| trace	count=2
function	path ||| get	count=2
function	mignotte bound ||| zz mignotte bound	count=2
function	[function_1] commutative ||| [function_1] [function_2]	count=1
function	is in the set ||| is	count=1
function	polynomial of sin ||| minpoly sin	count=1
class	> ||| permutation	count=1
class	word ||| free group element	count=2
function	into a string ||| func	count=1
function	full [function_2] ||| [function_2] [function_1]	count=2
arg	[arg_1] with already-processed ||| [arg_1] args [arg_2]	count=2
arg	of alpha ||| alpha	count=5
function	all [function_2] ||| [function_2] [function_1]	count=7
function	transitive ||| transitive	count=1
class	[class_1] of stringpicts ||| [class_2] [class_1]	count=2
arg	key ||| key seed	count=1
function	squares false if ||| squares	count=1
function	dummies ||| dummies	count=1
function_arg	transversals from [arg_2] ||| [function_1] [arg_2]	count=3
class	the xy-pic representation of ||| xypic diagram drawer	count=1
class	bounding rectangles of ||| complex root of	count=1
arg	try to eliminate x_0 ||| u	count=1
function	a factor ||| factor	count=1
arg	form ||| form	count=1
function	form x start stop ||| limits	count=1
arg	in phrase [arg_2] ||| [arg_1] symbols [arg_2]	count=1
arg	[arg_1] g using ||| [arg_1] [arg_2]	count=1
function	degree of ||| degree	count=3
function	[function_1] in ||| [function_2] zz [function_1]	count=3
arg	gens ||| gens	count=3
function	in ||| free	count=1
function	other, ||| gt	count=1
function	puiseux [function_2] ||| [function_2] [function_1]	count=5
function	refractive ||| refractive	count=1
arg	s as ||| s	count=1
function	ordinary ||| ordinary	count=1
arg	solutions of f ||| f	count=1
class	the sequences ||| seq	count=2
function	a method which gives ||| 1st	count=1
arg	takes clauses in cnf ||| clauses symbols	count=1
function	the module and ||| mod func	count=1
function	is properly normalized examples ||| is normalized	count=1
arg	mod [arg] that it ||| [arg]	count=1
function	[function_1] non-positive ||| [function_1] [function_2]	count=1
function	list of non-zero elements ||| list	count=1
module	standard basis ||| polys agca	count=1
arg	[arg_1] n ||| [arg_2] [arg_1]	count=28
arg	and y to the ||| y	count=1
module_class	quotient of [class_2] ||| [module_1] [class_2]	count=2
arg	information required for constructing ||| i j grid morphisms_str_info	count=1
function	non-zero structure ||| row structure	count=1
function	functions in finite_set ||| in	count=1
function	buckets ||| buckets	count=1
arg	radial wavefunction r_{nl} ||| nu r	count=1
arg	f by ||| f g auto	count=3
arg	function to ||| func	count=1
function	is strictly increasing ||| is strictly increasing	count=3
arg	e z at ||| e z	count=2
function	probability density ||| density	count=1
function	the ground n-th coefficient ||| dmp ground nth	count=1
function	and if symbols ||| check and	count=1
function	to z[x] ||| to int	count=2
function_arg	[function_1] [arg_2] key1=true) share at least ||| [function_1] [arg_2]	count=4
function	translate function ||| translate func	count=2
arg	return an ||| expr	count=3
function	format them ||| format	count=1
function	the truth value ||| eval cond	count=1
arg	apply f to all ||| f	count=1
function	of the functions ||| not empty	count=1
function	load the [function_2] ||| [function_1] ipython [function_2]	count=1
module	generate ||| polys agca	count=4
function	a simplified set of ||| simplified pairs	count=1
arg	a polynomial in ||| f p u	count=1
arg	a in k[x] ||| m a	count=1
function	to x_i**k_i in a ||| inflate	count=1
module	take ||| series	count=1
class	generated ||| gen	count=2
arg	function ||| func x x0	count=1
module	function calculates the angle ||| physics	count=1
function	generate viete's formulas for ||| viete	count=1
arg	expression ||| expression	count=2
function	degree of transitivity ||| transitivity degree	count=1
function_arg	[function_1] e ||| [arg_2] [function_1]	count=4
arg	gen in self gens ||| gen	count=1
function	wrapper to _eval_nseries if ||| nseries	count=1
function	is continuous ||| continuous domain	count=1
function	[function_1] evaluation points ||| [function_2] [function_1]	count=2
function	characters of phrase and ||| check and join	count=1
function	the domain of ||| empty	count=1
function	using lu decomposition given ||| lu	count=1
function	cosine [function] dcm ||| rotation [function]	count=1
class	of coset enumeration described ||| coset table	count=2
module_class	[module_1] a ||| [module_1] [class_2]	count=2
class	if the differential ||| differential	count=1
module	a string path ||| utilities	count=1
arg	if n ||| n	count=3
function	compute buckets for the ||| compute buckets	count=1
function	the quotient [function_2] ||| [function_1] [function_2]	count=2
function	class ||| get mod	count=2
class	the positions ||| permutation	count=2
function	a class into a ||| get	count=1
arg	g dx using g ||| g x	count=1
function_arg	a new [arg_2] ||| [arg_2] [function_1]	count=1
function_arg	the reduced [arg_2] ||| [function_1] [arg_2]	count=2
class	f_4 ||| type f	count=2
arg	alpha as a set ||| degree generators alpha	count=1
function	generating reflections of the ||| generators	count=1
function	[function_1] quasi-particle? create ||| [function_2] [function_1]	count=1
function	the linearizer ||| linearizer	count=1
function	x start stop ||| process limits	count=1
function	limit of each element ||| limit	count=1
arg	after common subexpression elimination ||| optimizations	count=1
function	perform the ||| doit	count=1
function	the hilbert [function] of the ||| [function]	count=1
arg	an indexed ||| x index radicals	count=1
function	are ||| auto	count=1
class	that take on a ||| base	count=1
function	of the underlying undirected ||| get undirected	count=1
arg	required for constructing ||| grid morphisms_str_info	count=1
module	returns gcd of polynomial ||| polys	count=1
module	to ||| domains	count=1
arg	n is prime (in ||| n	count=1
arg	for fast calculation of ||| expr modules printer	count=1
module_class	which the [class_2] ||| [module_1] [class_2]	count=4
arg	where f, g, h ||| g h	count=2
function	mapping of symbolic ||| create param dict	count=1
arg	runs [arg] ||| [arg]	count=1
function	a list of partial ||| partial	count=1
function	a square-free polynomial using ||| sqf	count=1
function_arg	dense [arg_2] ||| [function_1] sub [arg_2]	count=2
function	subprocess with hash randomization ||| in subprocess with hash randomization	count=1
function_arg	a gf [arg_2] ||| [function_1] from dict [arg_2]	count=3
function	[function_1] components the ||| [function_1] [function_2]	count=1
function_arg	lcm of f ||| lcm f	count=4
function	to another fraction field ||| fraction field	count=1
function	mellin [function_2] ||| [function_1] [function_2]	count=2
arg	diagram and the ||| diagram grid	count=1
function_arg	prime [arg_2] ||| [arg_2] [function_1]	count=1
function	[function_1] level ||| [function_1] [function_2]	count=1
function_arg	[function_1] using ||| [function_1] [arg_2]	count=3
class	print as a cycle ||| cycle	count=1
function	integer ||| pure symbol int	count=1
arg	k[x] using ||| u	count=1
function	cz^2 + ||| normal	count=1
module	**2 [module] csc x ||| [module]	count=1
arg	for details ||| x re g	count=1
function	decodes a morse ||| decode morse	count=1
arg	codestring ||| codestring	count=1
function_arg	term in x ||| term p x	count=2
arg	expansion ||| n x prec	count=1
class	__mod__ ||| ring	count=1
class	excluding those that ||| series	count=1
arg	and _hastypes ||| attrs types	count=1
function	[function_1] solvable ||| [function_1] [function_2]	count=1
arg	expr ||| expr assumptions	count=1
arg	of g ||| g x helper	count=2
function_arg	free space [arg_2] ||| [function_1] horizontal [arg_2]	count=1
function	with [function_2] ||| [function_1] [function_2]	count=2
function	new [function] has been ||| spread [function]	count=1
arg	mobius transform or ||| eps	count=1
arg	and g which ||| g exps	count=1
function	[function_1] function for ||| [function_1] [function_2]	count=4
function	values to ||| create param dict	count=1
function_arg	gf p [arg_2] ||| [arg_2] [function_1]	count=1
arg	splits the ||| callback	count=1
arg	a new key value ||| key value	count=1
function_arg	roots of [arg_2] ||| [function_1] [arg_2]	count=14
function_arg	[function_1] the routine ||| [arg_2] [function_1]	count=6
class	standard basis in ||| sub module poly	count=1
function	and ||| get	count=1
function	a boolean [function] simplified ||| [function]	count=1
class	to the module ||| module quotient ring	count=1
function	in finite_set in which ||| not	count=1
function	components ||| components free dum	count=1
function	phrase and ||| and join	count=1
function	and leverage it ||| pretty	count=1
function_arg	other, [arg_2] ||| [function_1] [arg_2]	count=2
function_arg	to power n ||| pow n	count=1
function	crootof object ||| rootof	count=1
arg	s ||| s x	count=1
arg	of the routine ||| routine	count=3
arg	multiplicities ||| multiplicities	count=1
arg	has root v ||| x v dom	count=1
function	the minimal [function_2] ||| [function_1] [function_2]	count=3
arg	denested [arg] after ||| [arg]	count=1
function_arg	[function_1] self other ||| [function_1] [arg_2]	count=2
function	[function_1] operators ||| [function_1] [function_2]	count=1
function	line ending ||| get statement	count=1
class	printer ||| printer	count=7
function	leverage it if possible ||| pretty try	count=1
function	calculates the delta ||| big delta	count=1
arg	solving first order differential ||| order match	count=1
function	coefficient [function_2] ||| [function_1] [function_2]	count=5
function	evaluate a polynomial in ||| eval	count=1
function_arg	the intersection [arg_2] ||| [function_1] [arg_2]	count=1
function_arg	[function_1] of the ||| [function_1] [arg_2]	count=1
function	made so far ||| simple compute conflict	count=1
function	[function_1] [function_2] of a ||| [function_1] [function_2]	count=18
function	around expand ||| expand power	count=2
arg	for constructing the ||| i j grid morphisms_str_info	count=1
class	on ||| expr op	count=1
class	those that ||| series base	count=1
function	multiply two ||| mul	count=2
function	return 1 instead of ||| combine inverse	count=1
class	of tuples index pos ||| index structure	count=1
function	field [function_2] ||| [function_1] [function_2]	count=2
function	and leverage it ||| pretty try	count=1
arg	[arg_1] b modulo ||| [arg_1] [arg_2]	count=3
function	[function_1] potential function ||| [function_2] [function_1]	count=6
arg	[arg_1] [arg_2] ||| [arg_2] j_3 [arg_1]	count=6
function_arg	direct product [arg_2] ||| [arg_2] [function_1]	count=3
arg	x_0 ||| u k	count=2
arg	[arg_1] [arg_2] ||| [arg_1] a [arg_2]	count=10
function	second defining ||| p2	count=1
function	polynomial in gf ||| gf	count=2
function	the nine-point [function_2] ||| [function_2] [function_1]	count=1
arg	a morphism [arg_2] ||| [arg_2] [arg_1]	count=2
function	excluding those that take ||| free	count=1
module	to the ||| physics	count=4
arg	[arg_1] \mathbb{z}_p[z]/(\check m_{\alpha} ||| [arg_1] minpoly [arg_2]	count=1
module	[module] rewrite the ||| [module]	count=1
function	to ||| tensorhead from tensmul	count=1
function	add ||| simple add	count=1
arg	a given [arg_2] ||| [arg_2] [arg_1]	count=4
function	square-free norm of ||| sqf norm	count=2
arg	the real inverse_mellin_transform ||| f s x_ strip	count=1
function	into ||| dup to	count=1
arg	c i e ||| c condition	count=1
module	equation or ||| solvers	count=1
module	the [module] ||| [module]	count=24
function	figure out generators ||| gens	count=1
class	with the proper line ||| code	count=1
arg	indices of expr ||| expr	count=1
arg	base scalars of the ||| coord_sys	count=2
function_arg	[function_1] [arg_2] of ||| [function_1] query value [arg_2]	count=1
module	the truth value ||| elementary	count=1
function	the [function] ||| [function]	count=15
function	[function_1] multiple ||| geometry point [function_1] [function_2]	count=3
function	inversions ||| inversions	count=1
module	value of the ||| functions elementary	count=1
module	with mathml ||| mathml	count=1
module	it if ||| printing	count=1
function	form of sign ||| as sign	count=1
module_class	return from [class_2] ||| [module_1] [class_2]	count=6
arg	numbers ||| numbers	count=1
function_arg	handling functions [arg_2] ||| [function_1] [arg_2]	count=1
function	involving absolute value function ||| abs	count=1
function	measure ||| measure	count=2
class	returns the positions of ||| permutation	count=2
function	diagonal morphism checks ||| diagonal	count=1
function	given function ||| function	count=1
function	permutation matrices pq ||| permutation matrices	count=2
module	basis ||| polys	count=1
arg	randomly selects numgates ||| numgates nqubits	count=1
class	in the group ||| group	count=1
function	_eval_nseries if assumptions ||| nseries	count=1
class	convert ||| python integer ring	count=1
class	transform ||| integral transform	count=1
function	number of partitions ||| count partitions	count=1
function	singularity functions ||| rewrite as singularity function	count=1
arg	col [arg_2] ||| [arg_1] [arg_2]	count=2
class	values to ||| llvmjit	count=1
function	helper function ||| helper	count=3
arg	and its attributes to ||| props add_identities	count=1
module	continuous random ||| stats	count=4
function	decompose power into ||| decompose power rat	count=1
arg	at a in k[x] ||| m a	count=1
module	of formal power series ||| series	count=1
function	return constant ||| get constant	count=1
arg	[arg_1] k of ||| [arg_2] [arg_1]	count=1
arg	[arg_1] and g ||| series mrv max1 [arg_1] [arg_2]	count=1
function	the dagger of ||| eval adjoint	count=1
arg	always in terms of ||| x n	count=1
arg	in the [arg_2] ||| [arg_2] [arg_1]	count=6
function	moment curve ||| moment	count=1
arg	[arg] n linear ||| [arg]	count=1
arg	formats a codestring with ||| codestring	count=1
function	intrinsic [function_2] ||| [function_2] [function_1]	count=1
arg	c ||| c condition	count=1
function	that ||| refine complexes	count=2
function_arg	of gcd [arg_2] ||| [arg_2] [function_1]	count=3
function	for a square-free ||| sqf	count=1
function	symbols in the object ||| symbols	count=1
function	module and the ||| mod	count=1
arg	terms using qm ||| terms	count=1
arg	for n data ||| n x	count=1
arg	[arg_1] given domain ||| [arg_1] [arg_2]	count=3
function	underlying undirected ||| get undirected graph	count=1
function	a normal ||| normal	count=2
arg	x tells ||| x	count=1
function	the next binary ordered ||| next binary	count=1
function	bending moment ||| bending moment	count=2
arg	in x_j [arg_2] ||| [arg_2] [arg_1]	count=6
function	nonnegative ||| nonnegative	count=1
function	forcing vector of ||| forcing full	count=1
class	the patterns ||| properties	count=1
arg	p == ||| p	count=2
arg	the morphisms of ||| morphisms	count=1
function	\mathbb{z}[x_0 \ldots x_{k-1}] using ||| modgcd multivariate	count=1
function	using a ||| modgcd	count=1
arg	self and other ||| other	count=7
function	in integer ||| find pure symbol int	count=1
arg	two [arg_2] ||| [arg_1] [arg_2]	count=1
function	allows functions to ||| function	count=1
function_arg	series [arg_2] ||| [arg_2] [function_1]	count=6
class	of ||| complex	count=1
arg	[arg_1] a ||| eval [arg_1] [arg_2]	count=1
arg	if a ||| a p	count=1
arg	the expression to ||| expr	count=1
function	phrase and if symbols ||| and	count=1
class	sequence ||| poly ring	count=1
function	new copy ||| copy	count=1
module_class	shorter axis of [module_1] [class_2] if it can be ||| [module_1] [class_2] minor	count=1
module_class	[module_1] dyadic ||| [module_1] [class_2]	count=11
module	automatically ||| integrals	count=1
function	[function_1] using lusolve ||| [function_1] [function_2]	count=1
function	for a horizontal morphism ||| horizontal	count=1
function_arg	[function_1] name and ||| [function_1] [arg_2]	count=2
function	matrix to rotate a ||| rotate	count=1
function	to function ||| function	count=1
function	[function_1] dmp_validate ||| [function_2] [function_1]	count=1
function	operators ||| operators to	count=1
arg	for details ||| x re	count=1
function	the orbit ||| orbit	count=2
class	from the atoms of ||| basic	count=1
function	f * ||| mul	count=1
arg	f from ||| f u	count=1
arg	representation ||| rep	count=3
class	the ||| code printer	count=2
function	by the amount given ||| decipher shift	count=1
arg	of lagrangesmethod lagrangian ||| lagrangian	count=1
function	for :func _dup_decompose ||| dup left decompose	count=1
arg	where f [arg_2] ||| [arg_2] [arg_1]	count=10
arg	order [arg] sn ||| [arg]	count=1
function	gauss-chebyshev ||| gauss chebyshev u	count=1
arg	p with respect ||| p	count=3
arg	[arg] reduced solution ||| [arg]	count=1
function	coefficient from the ||| coeff	count=1
module	the velocity of this ||| vector	count=1
function_arg	norm [arg_2] ||| [arg_2] [function_1]	count=14
module	class into a ||| utilities	count=1
arg	of a morphism ||| morphism	count=1
arg	if possible welds the ||| welding_edge	count=1
function	inverse cos ||| acos	count=1
function	push ||| push solid	count=1
arg	n raise ||| n	count=1
function	which gives the ||| 1st	count=1
function	decomposition itself ||| decomposition	count=1
function	space ||| space	count=8
arg	after subtracting [arg_2] ||| [arg_2] [arg_1]	count=4
function	converts a list of ||| to	count=1
arg	equation ||| eq	count=1
arg	modulo [arg_2] ||| [arg_2] [arg_1]	count=1
module	rectangles of non-conjugate ||| polys	count=1
class	matrix ||| dense matrix	count=4
function	[function_1] given function ||| [function_2] class [function_1] func_class f symbol	count=1
function_arg	zero scalar ||| zero e	count=2
function	this heuristic uses the ||| lie heuristic function sum	count=1
arg	[arg_1] [arg_2] with int 1 so ||| core prod [arg_1] [arg_2]	count=4
arg	given inequality or ||| f symbol domain	count=1
function	gmpy mpq object ||| qq gmpy	count=12
function	for the orbit ||| orbit	count=1
arg	space characters to ||| s	count=1
function_arg	[function_1] [arg_2] with terms whose squares ||| [function_1] [arg_2]	count=1
module	number of ||| liealgebras	count=1
function	cse on expression tree ||| tree cse	count=1
arg	of g ||| g x	count=1
arg	from triangles [arg_2] ||| [arg_2] [arg_1]	count=1
class	excluding ||| base	count=1
arg	combinations of n ||| n	count=1
function	list [function_2] ||| [function_2] [function_1]	count=27
function	[function_1] integer partition ||| [function_2] [function_1]	count=3
arg	pair of polynomials in ||| f g	count=1
arg	[arg_1] fringe and ||| [arg_1] welding_edge [arg_2]	count=1
class	[class] act on ||| [class]	count=3
function	of ascents ||| ascents	count=1
function	nth jacobi polynomial ||| jacobi	count=1
function	split a ||| split	count=1
arg	eliminate x_0 from ||| u k	count=1
class	quaternion orientation ||| quaternion orienter	count=1
arg	and exponents ||| force	count=1
function	unit ||| find unit	count=1
class	integral sign ||| integral	count=1
arg	[arg] inequalities and ||| [arg]	count=1
arg	to name ||| name	count=1
class	until it is of ||| real	count=1
module	function ||| functions special	count=3
class	diagram ||| diagram	count=2
arg	the mellin transform of ||| x helper	count=1
function	f - [function_2] ||| [function_2] [function_1]	count=5
function	next [function] taylor series ||| taylor [function]	count=1
class	no bounding rectangles ||| root of	count=1
arg	alpha as a ||| alpha pairs	count=1
class	add fact ||| fact	count=1
function	with ||| with	count=1
arg	into another quantum ||| choices seed	count=1
arg	other lies in the ||| other	count=1
function	[function] simplified version ||| [function]	count=1
module	if possible ||| printing pretty	count=1
function	form ||| as	count=2
function	method of undetermined coefficients ||| undetermined coefficients	count=1
function	holonomic ||| holonomic	count=1
arg	of f given ||| f	count=2
function_arg	polynomial gcd [arg_2] ||| [function_1] [arg_2]	count=6
arg	to z is correct ||| z tol a	count=1
function_arg	polynomial lcm [arg_2] ||| [arg_2] [function_1]	count=4
function	a tuple ||| as	count=2
function	[function] of ||| antidivisor [function]	count=2
arg	[arg_1] join ||| [arg_2] [arg_1]	count=1
function	type of ode ||| order1 type6	count=1
arg	< ||| cls	count=1
function	constants by functions in ||| variable	count=1
function	to a fully contravariant ||| from tensmul	count=1
function	the outer indices ||| indices	count=1
arg	and dum [arg_2] ||| [arg_2] [arg_1]	count=1
arg	x note that ||| x	count=1
module	is the ||| physics	count=2
function	tensors ||| tensor	count=1
class	whose elements ||| partition traverser	count=1
arg	rsolve_hypergeometric for details ||| re g	count=1
function	apply a ||| apply	count=1
function	using subresultants over ||| ff prs	count=2
class	on the intersection ||| op	count=1
arg	in the [arg] i ||| [arg]	count=1
function_arg	l1 norm [arg_2] ||| [function_1] [arg_2]	count=3
arg	f s , defined ||| f s t plane	count=1
function	a product ||| mul	count=5
arg	controls targets ||| controls targets	count=2
module	of ||| printing	count=1
arg	for op [arg_2] ||| [arg_2] [arg_1]	count=2
function	mellin ||| mellin	count=2
arg	required for constructing ||| j grid morphisms_str_info	count=1
function_arg	[function_1] grid ||| [function_1] triangles fringe [arg_2]	count=1
function	to a list ||| to sympy list	count=2
arg	[arg] form expected ||| [arg]	count=3
class	coordinate of the point ||| point3d	count=1
function	[function] function ||| eval rewrite [function]	count=3
arg	g in ||| g p k	count=1
function	the expression as ||| as	count=1
class	line and a point ||| line	count=1
arg	position ||| name position	count=1
arg	second default kind ||| kind	count=1
function	integer ||| find pure symbol int	count=1
function	the ||| get mod	count=4
function	key such that ||| key	count=1
function	second [function_2] ||| [function_2] [function_1]	count=3
function_arg	[function_1] routine ||| [arg_2] [function_1]	count=3
function	letter [function_2] ||| [function_2] [function_1]	count=4
function	generating function for a ||| guess generating function	count=1
arg	for suitability ||| t ct a	count=1
function	of functions ||| functions	count=1
function	[function_1] paths ||| [function_2] [function_1]	count=1
function	bra ||| bra	count=1
function	[function_1] parallel ||| [function_2] [function_1]	count=6
arg	in z_p ||| p k	count=2
arg	key matrix ||| key	count=1
arg	[arg_1] via prs ||| [arg_2] [arg_1]	count=3
module	and geometry ||| geometry	count=1
module	characters in ||| crypto	count=1
function	return the direct product ||| mul	count=1
function	the non-zero structure of ||| row structure	count=1
arg	of f and ||| a d	count=1
class	of the ||| properties	count=1
function	to which [function_2] ||| [function_2] [function_1]	count=2
function	sdm from a dictionary ||| sdm from dict	count=1
function	the ket ||| ket	count=1
module	gates ||| physics quantum	count=2
function	returns refractive [function_2] ||| [function_1] [function_2]	count=1
function	loop morphism ||| process loop morphism	count=2
function_arg	of irreducible [arg_2] ||| [function_1] list include [arg_2]	count=2
arg	n [arg] n ||| n [arg]	count=1
arg	polynomial irreducibility test ||| f p	count=1
arg	given ||| eps	count=1
function	the reduced representation of ||| trunc	count=1
class	a scalar ||| base covar derivative	count=1
arg	[arg_1] y z ||| [arg_2] [arg_1]	count=1
function	unicode output is available ||| use unicode	count=1
arg	u [arg_2] ||| [arg_2] [arg_1]	count=1
function	the positive [function_2] ||| [function_1] [function_2]	count=2
arg	0 mod(p** s + ||| s p	count=1
function	a new rootsystem ||| new	count=1
arg	with hilbert_space and ||| hilbert_space	count=1
function	hermite reduction - mack's ||| hermite	count=1
module	e [module] t(a ||| [module]	count=1
class	sparsematrix ||| sparse	count=1
class	polyhedra we can ||| polyhedron	count=1
arg	variable with ||| name r	count=1
arg	[arg] (default ||| [arg]	count=3
function	[function_1] laplace transform ||| [function_1] [function_2]	count=3
arg	apply do ||| do	count=1
function	a dictionary [function_2] ||| [function_2] to [function_1]	count=1
function	identity ||| random identity	count=1
function	the quotient homomorphism to ||| quotient hom	count=1
function	continuous ||| continuous rv	count=1
class	the matrix ||| mutable dense matrix	count=1
function	of cos ||| cos	count=1
arg	techniques [arg_2] ||| [arg_2] [arg_1]	count=2
arg	[arg_1] and b ||| [arg_1] [arg_2]	count=44
class	[class_1] system examples ||| [class_1] [class_2]	count=1
module	by ||| crypto	count=1
function	the primitive root of ||| primitive root	count=1
arg	value ||| value	count=4
function	[function_1] simple ||| [function_1] [function_2]	count=1
function_arg	[function_1] [arg_2] root2 ||| [function_1] [arg_2]	count=4
function	load the extension ||| load ipython extension	count=2
function	create new ||| new	count=1
function	wavenumber ||| wavenumber	count=1
module	of two polynomials ||| polys	count=1
arg	terms of [arg_2] ||| [arg_2] [arg_1]	count=2
arg	x_0 ||| m u	count=2
function	a multivariate ||| dmp	count=2
arg	it is the radius ||| x	count=1
arg	p [x] and ||| p k	count=1
function	generates a random integer ||| random integer	count=1
module	the other ||| physics	count=1
function	sign of an ||| sign	count=1
function	asin ||| asin	count=1
function	the series of "e" ||| series	count=1
function	inject them [function] its domain ||| drop [function]	count=1
arg	x_0 of a polynomial ||| f m u	count=1
module_class	[module_1] partition ||| [module_1] [class_2]	count=2
function	trailing coefficient of ||| gf tc	count=1
arg	triangles ||| triangles	count=2
arg	examples ||| d	count=1
arg	complexes such that ||| cls complexes	count=1
function	gmpy mpq ||| qq gmpy	count=12
function_arg	[function_1] a point ||| [arg_2] [function_1]	count=4
class	patterns ||| matrix	count=1
arg	that only func remains ||| func	count=1
arg	value of key2 ||| key2	count=1
function	on ||| apply on	count=1
function	2d n-link pendulum ||| link pendulum	count=1
function	[function_1] whole ||| [function_2] [function_1]	count=1
module	rl ||| physics quantum	count=1
function	the function to ||| function	count=1
function_arg	basic element [arg_2] ||| [function_1] f [arg_2]	count=3
function_arg	power of [arg_2] ||| [function_1] expr [arg_2]	count=3
function	of a finite ||| finite	count=1
arg	of the terms ||| x	count=1
module	random expression square root ||| stats	count=1
arg	of f [arg_2] ||| [arg_1] g [arg_2]	count=3
module_class	self with submodule ||| agca sub module	count=2
function	gray coding [function_2] ||| [function_1] [function_2]	count=1
class	for [class] ||| [class]	count=1
function	the focal [function_2] ||| [function_1] [function_2]	count=2
function	of scan ||| scan	count=3
module	finds ||| calculus	count=1
arg	adds muls pows ||| verbose	count=1
class	sparse ||| sparse	count=2
function	polynomial pseudo-division of ||| pdiv	count=1
class	total number of ||| type g	count=1
class	the root ||| root of	count=1
class	pair ||| cond pair	count=1
arg	form if a ||| a	count=1
arg	= ||| a b	count=1
function	[function_1] [function_2] ||| [function_1] list [function_2]	count=4
class	writes ||| code	count=1
function	wigner semicircle ||| wigner semicircle	count=2
arg	negative coefficient muls ||| order	count=1
function	blockmatrices ||| deblock	count=1
class	true ||| algebraic	count=4
class	number ||| g	count=1
function	field i e ||| field	count=4
function	the symbol in ||| symbol	count=1
class	a standard basis in ||| module poly ring	count=1
function	focal ||| focal	count=1
arg	[arg] used to ||| [arg]	count=1
function	no [function_2] ||| [function_2] [function_1]	count=2
class	for the generated files ||| code	count=1
arg	isolating interval of ||| f s t eps	count=2
function_arg	graph gr ||| graph certificate gr	count=1
arg	view expression or latex ||| expr	count=1
function	single g ||| single	count=1
arg	occuring in expr, given [arg_1] [arg_2] ||| [arg_1] [arg_2]	count=1
function	[function_1] with hash ||| [function_1] [function_2]	count=4
function_arg	[function_1] [arg_2] such that for the ||| [function_1] s _lambda [arg_2]	count=1
function	[function_1] monotonic ||| [function_2] [function_1]	count=5
function	compute a minimal ||| minimal	count=1
function	the focal ||| focal	count=1
module	solution to ||| solvers	count=1
arg	and 'other' ||| other	count=1
function_arg	irreducible factors [arg_2] ||| [function_1] list include [arg_2]	count=2
function	is [function] ||| [function]	count=3
module	for plotting ||| plotting	count=1
function_arg	[function_1] of ||| [function_1] f [arg_2]	count=1
function	whether function is ||| is rational function	count=1
arg	prop ||| prop base strong_gens	count=1
function	of terms ||| as terms	count=1
arg	[arg_1] expr ||| [arg_2] [arg_1]	count=8
function	in a piecewise form ||| as piecewise	count=1
class	is ||| symbol factory	count=1
arg	converts an expr ||| expr assign_to standard	count=1
class	in ||| sub module poly ring	count=2
function	[function] by its ||| [function]	count=1
function	irrational ||| irrational	count=1
function	monomial ||| monom	count=1
class	basic args like ||| basic	count=1
arg	length l1 on ||| l1 l2	count=2
function_arg	return [function_1] [arg_2] ||| utilities [function_1] [arg_2]	count=1
arg	of p ||| p	count=5
function	polynomials from ||| poly from	count=2
function	the minimal polynomial for ||| minpoly	count=1
function	the lmq upper bound ||| dup root upper bound	count=1
function	error ||| count error	count=1
arg	degree d [arg_2] ||| [arg_2] [arg_1]	count=2
function	register a handler ||| register	count=1
function	of the atanh ||| atanh	count=1
function	finds the degree ||| degree	count=1
arg	[arg_1] p - ||| [arg_2] [arg_1]	count=1
function	scalar potential function of ||| scalar potential	count=2
function_arg	a list [arg_2] ||| [arg_2] [function_1]	count=4
function_arg	[function_1] field ||| [function_1] [arg_2]	count=8
arg	expression to ||| expr	count=2
function	dense ||| dmp	count=2
arg	orig_vec [arg_2] ||| [arg_2] [arg_1]	count=1
arg	tri [arg_2] ||| [arg_1] welding_edge [arg_2]	count=4
function	canonical form of ||| canonical	count=1
arg	terms of f ||| f m n	count=4
function	print output of ||| print python	count=1
arg	and returns ||| msg key	count=1
function	rust [function_2] ||| [function_2] [function_1]	count=2
arg	, rs\_sin p x ||| p x	count=1
function	variation of scan routine ||| scan	count=1
arg	yield origin ||| origin z	count=1
class	ground domain a ||| poly	count=1
function	which the ||| empty in	count=1
function_arg	partition [arg_2] ||| [function_1] [arg_2]	count=1
arg	if a literal ||| lit	count=1
arg	location ||| location	count=1
function	expr with ||| get integer part	count=1
function	using ||| lu	count=1
function	[function_1] quasi-particle? ||| [function_1] [function_2]	count=1
arg	of expression over ||| expr var	count=2
function	negate a polynomial in ||| neg	count=1
function	has ||| has	count=2
function	all terms from a ||| all terms	count=1
function	ode from the ||| ode 1st homogeneous coeff	count=1
function	compute [function] where f ||| gf [function]	count=1
function	[function_1] rotational gradients ||| [function_2] [function_1]	count=1
arg	point [arg_2] ||| [arg_2] [arg_1]	count=8
arg	function p [arg] i e ||| [arg]	count=1
function	q[x] it is assumed ||| modified subresultants pg	count=1
module	get the version of ||| physics	count=1
function	[function_1] c(x_2 x_u)*x_0**i ||| [function_2] [function_1]	count=1
module	equal to the ||| physics	count=1
function	gets the subset ||| subset	count=1
class	isolating [class_2] ||| [class_1] [class_2] refine	count=1
function	[function_1] squares false ||| [function_2] [function_1]	count=3
arg	types [arg] ||| [arg]	count=1
function	push a ||| push	count=2
arg	the writer function out ||| out clear_globs	count=1
function	it if possible ||| pretty	count=1
function_arg	[function_1] and the ||| [arg_2] [function_1]	count=1
module	return numerator factor ||| core	count=1
class	element in ||| element	count=1
arg	algorithm i ||| g n y	count=1
module	the version ||| physics	count=1
arg	[arg] of ||| query value [arg]	count=1
arg	system of ||| x y z	count=1
function	number of [function_2] ||| [function_2] [function_1]	count=2
arg	representation ||| f rep	count=1
function_arg	[function_1] bits to ||| [function_1] n [arg_2]	count=1
arg	instance ||| arguments results local_vars	count=1
function	the inradius ||| apothem	count=1
function	[function_1] matrix of ||| [function_2] [function_1]	count=2
class	object excluding those that ||| series	count=1
function_arg	mellin transform [arg_2] ||| [function_1] [arg_2]	count=5
module	location where p[i] < ||| combinatorics	count=1
function_arg	g*h [arg_2] ||| [function_1] f [arg_2]	count=2
function	[function_1] a mul ||| [function_1] [function_2]	count=3
function	inverse ~a ||| af invert	count=1
function	eye and tensor_product ||| eye	count=1
arg	f ||| f atoms	count=1
function	reconstruct a [function_2] ||| [function_2] [function_1]	count=8
function	structure of ||| structure	count=1
function_arg	tan [arg_2] ||| [function_1] [arg_2]	count=2
function	non-primitive polyomials in z[x] ||| dup zz	count=1
module	sum or ||| concrete	count=1
arg	divides p - ||| p all_roots	count=1
arg	q are ||| q x	count=7
function	an algebraic [function_2] ||| [function_2] [function_1]	count=2
function	self [function] ||| [function]	count=2
arg	an integral curve ||| vector_field param start_point n	count=1
function	function for a sequence ||| function	count=1
function_arg	[function_1] [arg_2] used to construct it ||| [function_1] [arg_2]	count=1
arg	a list of factors ||| factors	count=1
arg	convert expr ||| expr	count=1
function	the sturm sequence of ||| dup sturm	count=1
arg	[arg_1] and b, ||| [arg_1] [arg_2]	count=34
arg	iterator of the seq ||| seq	count=1
function	a free ||| free	count=2
arg	text ||| text	count=2
function	polynomial pseudo-remainder of ||| prem	count=1
class	take on ||| series	count=1
arg	expansion of ||| prec	count=1
function_arg	[function_1] [arg_2] ||| [function_1] ddf shoup f [arg_2]	count=2
function	the outer indices of ||| indices	count=1
arg	this type of ||| x y t r	count=3
function	cyclotomic polnomial ||| dup cyclotomic	count=1
function	square-free normal ||| sqf normal	count=2
class	polyhedron ||| polyhedron	count=3
function	create particle if so ||| is	count=1
module_class	[module_1] gcd ||| [module_1] [class_2]	count=2
function	best solution to ||| homogeneous coeff best	count=1
function	available and ||| pretty	count=1
class	[class_1] [class_2] is called complete if ||| [class_1] [class_2]	count=1
module	faces of ||| combinatorics	count=1
function	pt1 ||| target cell	count=1
function_arg	logarithm of p ||| rs log p	count=2
arg	s + 1 ||| s	count=1
class	rectangles of non-conjugate ||| of	count=1
function	z i ] == ||| eval commutator zgate	count=1
module	try to ||| integrals	count=3
module	of the form ||| series	count=1
arg	at x_j = a ||| a j	count=1
function	a ll ||| ll	count=1
function	use [function_2] ||| [function_2] [function_1]	count=5
class	a ||| module poly	count=2
function	exponent ||| exponent	count=1
arg	polynomial ||| cls poly	count=5
function	a term ||| term	count=1
arg	the ith column ||| i	count=1
function	computes polynomial gcd and ||| gcd	count=1
arg	p q are ||| p q x	count=10
function	a simplified ||| simplify	count=1
function	terms from ||| terms	count=2
function	terms to ||| as	count=2
function	files default from which ||| test files	count=1
arg	for details ||| f x re	count=1
arg	qubit ||| qubit	count=1
arg	v ||| v dom	count=1
function	sum of ||| sum of	count=1
function_arg	[function_1] [arg_2] ||| [function_1] d [arg_2]	count=1
function	returns maximum [function_2] ||| [function_2] [function_1]	count=7
function	intersection ||| intersect	count=3
function	[function_1] denominator ||| [function_1] [function_2]	count=2
function	primitive root ||| primitive root	count=2
arg	given interval ||| expression interval symbol	count=6
module	return the truth ||| functions	count=1
function	push a ||| push wireframe	count=1
arg	is_simple self x tells ||| x	count=1
function_arg	[function_1] replaced by ||| [arg_2] [function_1]	count=3
module_class	implies __mod__ ||| polys domains ring	count=1
function	expressions generated ||| vpprint	count=1
function	quadrants from a list ||| intervals to quadrants	count=1
function	form of singularity functions ||| rewrite as singularity function	count=1
arg	y z ||| y z a	count=2
function	this vectormul ||| measure number	count=1
function	finite difference [function_2] ||| [function_1] [function_2]	count=1
function	each coordinate of self [function_1] [function_2] ||| [function_1] [function_2]	count=14
function	using a modular ||| modgcd	count=1
function	returns the opening statements ||| get routine opening	count=2
module	path to the ||| utilities	count=1
class	dtype ||| algebraic field	count=3
class	kb with ||| fact kb	count=1
function_arg	in gf [arg_2] ||| [function_1] ddf shoup f [arg_2]	count=1
function_arg	[function_1] parameter c ||| [arg_2] [function_1]	count=1
function_arg	[function_1] the given ||| [function_1] [arg_2]	count=17
function	pseudo-quotient of ||| pquo	count=1
function	using horner scheme ||| eval	count=1
arg	return a polynomial in ||| f p u k	count=1
function	of ascents in ||| ascents	count=1
function	performs the scaler-row ||| mulrowscaler	count=1
module	the position of this ||| physics vector	count=1
function_arg	resultant [arg_2] ||| [function_1] [arg_2]	count=3
function	list of x**(i*p) mod ||| gf frobenius monomial base	count=1
function	is [function] ||| is [function]	count=1
function	the leading nonzero ||| as leading	count=1
function	the real [function_2] ||| [function_1] [function_2]	count=1
arg	adds muls pows ||| exprs order verbose	count=1
arg	argument [arg] ||| [arg]	count=1
arg	coefficient muls ||| order	count=1
function	continuous subsequence of ||| slice	count=5
class	number of ||| g	count=1
function	reconstruct ||| rational reconstruction	count=1
arg	which the finite_set is ||| finset_intersection	count=1
function	the mellin ||| mellin	count=1
arg	f applied ||| f args	count=1
function	and ||| mod	count=1
function	elements ||| elements	count=2
function	inverse of ||| inverse	count=4
function	the exponent ||| exponent	count=1
module_class	the [class_2] ||| [module_1] mechanics symbolic [class_2]	count=1
module	a generator that ||| solvers	count=1
function_arg	[function_1] two labeled ||| [arg_2] [function_1]	count=1
function_arg	into irreducibles [arg_2] ||| [function_1] [arg_2]	count=3
function	recalculate ||| retract	count=1
function_arg	expectation [arg_2] ||| [arg_2] [function_1]	count=4
class	formal [class_2] ||| [class_1] [class_2]	count=2
class	[class_1] table ||| [class_1] [class_2] is complete	count=1
module	patterns ||| matrices	count=1
function	rust ||| rust code	count=1
function	\ldots x_{k-1}] from a ||| interpolate multivariate	count=1
function	variables with which ||| variables	count=1
module	create matrix ||| matrices	count=1
class	one step complex ||| complex	count=1
function_arg	set the [arg_2] ||| [function_1] comm [arg_2]	count=1
module_class	[module_1] prufer ||| [module_1] [class_2]	count=2
function	the log [function_2] ||| [function_2] [function_1]	count=2
function	[function_1] elements ||| [function_2] [function_1]	count=1
function	[function_1] with constant ||| [function_1] [function_2]	count=2
arg	for n ||| n x	count=1
function	computes polynomial gcd ||| gcd	count=3
function	leverage ||| try	count=1
class	generate ||| free	count=2
class	from the distribution ||| distribution	count=1
function	form x ||| process limits	count=1
class	the module ||| module quotient	count=1
function_arg	expr with [arg_2] ||| [function_1] [arg_2]	count=1
arg	[arg_1] [arg_2] ||| [arg_1] welding_edge [arg_2]	count=8
module	wrt this ||| vector	count=1
module	of [module] ||| [module]	count=32
class	coordinate ||| position state3d	count=2
function	[function_1] subset ||| [function_1] [function_2]	count=2
arg	w r t ||| otherpoint value	count=1
function	y_i to x_i**k_i in ||| inflate	count=1
function	sparse distributed module ||| sdm	count=1
arg	f to ||| f atoms	count=1
function	function to correct the ||| correct signature	count=1
arg	tri to ||| tri	count=1
arg	and for each ||| a d de	count=1
function	orientation orients the new ||| new	count=1
function	to ||| bin to	count=1
function_arg	[function_1] [arg_2] ||| [function_1] convergents [arg_2]	count=1
function	[function_1] modularinteger ||| [function_1] [function_2]	count=2
class	a ||| quotient	count=1
function_arg	[function_1] for op ||| [arg_2] [function_1]	count=3
arg	and e is ||| e	count=1
function	an ipython ||| ipython	count=1
arg	every non-blank line ||| indent	count=1
arg	i by ||| i	count=1
arg	h ||| h base orbits	count=1
class	functions ||| function	count=3
function	number of real ||| count real	count=1
arg	construct polynomials ||| opt	count=1
arg	a scalar [arg_2] ||| [arg_2] [arg_1]	count=3
function	j], [function] ||| [function] row	count=2
class	does the same thing ||| mixin	count=1
module_class	the elements ||| combinatorics permutation	count=1
arg	return a ||| a	count=1
class	associated with the ||| poly	count=1
arg	suitability ||| f t ct a	count=1
arg	varying t ||| t	count=1
function	polynomial pseudo-quotient of ||| pquo	count=1
module	a basis state ||| quantum	count=1
arg	f ||| f k inf sup	count=1
class	that take ||| series	count=1
function	creates an equal superposition ||| superposition	count=1
arg	f by ||| f c	count=6
arg	the factors ||| factors x	count=1
arg	component ||| expression component	count=1
function	block matrices for ||| block matrices	count=2
arg	calls x evalf(n \*\*options) ||| x n	count=1
class	outside ||| properties	count=1
function	sdm from [function_2] ||| [function_1] [function_2]	count=1
function	mellin [function_2] ||| [function_2] [function_1]	count=2
module	equal to the given ||| physics	count=1
function	for specific integer modulus ||| integer	count=1
class	a string [class_2] ||| [class_2] [class_1]	count=1
function	what intervals the expr ||| expr	count=1
class	other point ||| point	count=1
class	in rectangular form or ||| region	count=1
arg	and return ||| s	count=1
function	permutation matrix ||| permutation matrix	count=2
module	this function is the ||| physics	count=1
arg	phrase is [arg_2] ||| [arg_1] [arg_2]	count=1
function	size is the size ||| size	count=1
class	printer for ||| printer	count=2
module	equation or with a ||| solvers	count=1
class	the ||| type g	count=1
arg	of alpha as ||| degree generators alpha	count=1
arg	of ||| x x0 dir logx	count=1
arg	dx using g ||| g x	count=1
arg	information required for constructing ||| j grid morphisms_str_info	count=1
function_arg	symbol [arg_2] ||| [function_1] [arg_2]	count=1
function	the name ||| get	count=1
function	coefficient of ||| coeff monomial	count=1
function	not-empty ||| not empty	count=1
arg	[arg_1] x gives ||| [arg_2] [arg_1]	count=1
function	to have [function] coefficients try ||| to [function]	count=1
function_arg	[function_1] matching subexpressions ||| [arg_2] [function_1]	count=1
arg	a in ||| a p k	count=1
function	tensor product ||| combined tensor	count=1
module	returns [module_2] ||| [module_2] [module_1]	count=2
arg	l1 on ||| l1 l2	count=2
arg	helper to tell whether [arg_1] [arg_2] ||| simplify dotrig [arg_1] [arg_2]	count=3
function_arg	with [arg_2] ||| [function_1] [arg_2]	count=5
function	underlying undirected ||| undirected	count=1
arg	multiplicities ||| multiple radicals	count=1
arg	contain nested square ||| nested	count=1
arg	check if g ||| g	count=1
function	the proper ||| statement	count=1
arg	switch ||| f native	count=2
module	the quantity ||| physics units	count=1
function	expression in [function_2] ||| [function_1] [function_2]	count=2
arg	0 mod(p** s ||| s	count=1
arg	register the transformation used ||| to_sys from_coords to_exprs inverse	count=1
function_arg	extract from a [function_1] [arg_2] ||| [function_1] [arg_2]	count=1
arg	:func rsolve_hypergeometric for details ||| re	count=1
function	third heuristic ||| heuristic bivariate	count=1
arg	return namespace dict with ||| expr namespace	count=1
arg	f in k[x], useful ||| f k	count=1
class	this geometrical entity ||| entity	count=1
module_class	this ket ||| physics quantum ket	count=1
class	octave ||| octave	count=1
function	[function_1] square-free ||| [function_1] [function_2]	count=7
function	derivation of ||| derivation	count=1
function	defition of this vectormul ||| measure number	count=1
function_arg	square root [arg_2] ||| [function_1] depth [arg_2]	count=1
function_arg	[function_1] n for ||| [arg_2] [function_1]	count=1
function	recursive helper ||| rec degree	count=1
function	the interior of ||| interior	count=1
function	correct the values inside ||| correct	count=1
function	[function_1] [function_2] ||| [function_1] ipython [function_2]	count=2
arg	compute ||| f x dummies	count=1
class	generate ||| module quotient ring	count=1
class	line and ||| line	count=1
function	the vertex ||| vertex	count=1
class	medium ||| medium	count=5
arg	index to an index ||| index	count=2
arg	join ||| join	count=1
function	[function_1] a unit ||| [function_2] [function_1]	count=2
function_arg	[function_1] i ||| [function_1] [arg_2]	count=11
arg	[arg] form ||| [arg]	count=3
function	ode ||| order1	count=1
class	standard basis in ||| poly	count=1
arg	f ||| f i	count=1
function	if so ||| is	count=3
function	to each element ||| applyfunc	count=1
function	finite ||| apply finite	count=1
module_class	[module_1] prufer ||| [module_1] [class_2] new cls	count=1
function	[function_1] structure of ||| [function_1] [function_2]	count=3
function	functions in terms ||| hyper as	count=1
function	strictly increasing in the ||| strictly increasing	count=1
function	add c(x_2 x_u)*x_0**i ||| add term	count=1
arg	denester ||| denester	count=1
function	polynomials in k[x] ||| dup	count=1
function	for the taylor term ||| taylor term	count=1
module	+ bv_{2}) + ||| solvers	count=1
function	sign ||| contract metric	count=1
function	power ||| pow	count=2
function	nine-point circle of ||| nine point circle	count=1
function	heuristic assumes the infinitesimals ||| heuristic	count=1
module	returns the ||| combinatorics	count=3
class	the components ||| lazy	count=1
function	[function_1] primary ||| [function_2] [function_1]	count=1
function_arg	free module [arg_2] ||| [function_1] [arg_2]	count=2
class	the ground domain a ||| poly	count=1
function	rewrite functions in terms ||| rewrite	count=1
function	returns the coefficient of ||| coeff	count=1
module	qubits ||| quantum	count=1
module	for the ||| physics mechanics	count=1
arg	q ||| q x	count=9
arg	test ||| randomized	count=1
function_arg	derivative of f ||| derivative numerically f	count=2
function	sturm sequence ||| dup sturm	count=1
function	of codomain ||| codomain	count=1
function	product of tensors ||| tensor mul	count=1
function	treats xor ^, ||| convert xor	count=1
function_arg	[function_1] p ||| [function_1] a [arg_2]	count=2
module	[module_1] the ||| [module_2] [module_1]	count=28
function	a monomial ||| sdm monomial	count=1
function	square a ||| sqr	count=1
function	[function_1] univariate ||| [function_2] [function_1]	count=3
function	[function_1] dictionary from ||| [function_2] [function_1]	count=1
function	intervals the expr cond ||| sort expr cond	count=1
arg	j_2 j_3 [arg_2] ||| [arg_1] [arg_2]	count=7
function	[function_1] increasing in ||| [function_1] [function_2]	count=5
function_arg	[function_1] [arg_2] ||| physics quantum [function_1] [arg_2]	count=2
function	[function_1] of partitions ||| [function_2] [function_1]	count=3
module	of expression ||| polys	count=1
function	[function_1] linear ||| [function_2] [function_1]	count=1
arg	x**n == a ||| a n p	count=1
function	space characters to ||| indent	count=1
function_arg	monomial order [arg_2] ||| [function_1] [arg_2]	count=1
arg	returning ||| sort timeout slow enhance_asserts	count=1
function	quadratic in ||| quadratic	count=2
module	the truth value of ||| functions elementary	count=1
class	self domain ||| quotient ring	count=1
function_arg	the affine [arg_2] ||| [arg_2] [function_1]	count=2
function_arg	[function_1] p ||| [function_1] exquo f g [arg_2]	count=2
function	pollard's p-1 ||| pm1	count=1
module	the truth value of ||| functions	count=1
function_arg	primitive form [arg_2] ||| [arg_2] [function_1]	count=4
arg	the anti-derivative [arg_2] ||| [arg_2] [arg_1]	count=3
function	energy of ||| energy	count=2
function	"e" in "x" ||| calculate	count=1
arg	-> objects ||| objects	count=1
function_arg	[function_1] an expression ||| diffgeom covariant [function_1] [arg_2]	count=1
arg	d [arg_2] ||| [arg_1] [arg_2]	count=2
function	sinh ||| sinh	count=1
arg	f in gf p ||| f	count=3
function	gets the subset defined ||| subset	count=1
module	and ||| printing	count=1
arg	composite polynomial [arg_2] ||| [arg_1] [arg_2]	count=1
function	[function_1] sympy matrix ||| [function_2] [function_1]	count=3
function	morphism the length ||| length	count=1
module	conjugating the ||| physics optics	count=1
arg	variable with ||| name b	count=1
function	[function_1] a principal ||| [function_1] [function_2]	count=1
function_arg	[function_1] in ||| [function_1] f m u [arg_2]	count=1
function	of an add ||| add	count=1
function	quotient ||| dmp exquo	count=1
arg	p is ||| p	count=1
arg	f if it ||| f symbol gens	count=1
function_arg	[function_1] in s2 ||| [function_1] [arg_2] r	count=2
function	representation the coset rank ||| coset rank	count=1
function	is puiseux ||| is puiseux	count=2
function_arg	[function_1] of msg ||| [arg_2] [function_1]	count=1
function	next [function_2] ||| [function_2] [function_1]	count=2
module_class	the [class_2] ||| [module_1] vector [class_2]	count=2
arg	for expr ||| expr	count=1
arg	complexes such that no ||| complexes	count=1
module_class	1 about p1 of [module_1] [class_2] ||| [module_1] [class_2]	count=1
function	into a ||| vector to	count=1
module_class	[module_1] elements ||| [module_1] [class_2]	count=6
function_arg	[function_1] element elem ||| [arg_2] [function_1]	count=1
function	a line ||| line	count=1
function	[function_1] n-th coefficient ||| [function_1] [function_2]	count=3
arg	[arg] creates ||| [arg]	count=1
module	augmented by the kinematic ||| physics	count=1
function	length ||| length	count=5
function	a class into a ||| get mod func	count=1
class	with free indices substituted ||| tens	count=1
function	return the ||| eval cond	count=1
class	a subrange of pstack ||| multiset partition traverser	count=1
function	list of [function_2] ||| [function_2] [function_1]	count=26
arg	controls ||| controls	count=1
function	square the series ||| rs square	count=1
function	[function] in a ||| dup [function]	count=3
class	a set partition ||| partition	count=1
function	product of ||| tensor mul	count=1
arg	to two labeled polynomials ||| g	count=1
class	gcd ||| ring base	count=1
function	domain ||| not	count=1
arg	and token ||| token	count=1
module	equation with ||| solvers	count=4
arg	[arg_1] token ||| [arg_2] [arg_1]	count=3
module_class	[module_1] tensor ||| [module_1] [class_2]	count=2
module	the ||| physics vector	count=10
function_arg	[function_1] [arg_2] ||| [function_1] term [arg_2]	count=2
function	is small ||| small p	count=2
arg	[arg_1] lex order ||| [arg_1] [arg_2]	count=3
function	y_i to x_i**k_i ||| dmp inflate	count=1
function	heuristic is to find ||| heuristic	count=1
arg	[arg] n of ||| n [arg]	count=1
function_arg	[function_1] two permutations ||| [function_1] [arg_2]	count=8
function	pseudo-division of ||| pdiv	count=1
function	coset table of ||| coset table	count=1
function	the object excluding those ||| free	count=1
function	return the symbol target ||| target	count=1
class	mapping of symbolic values ||| llvmjit code	count=1
function_arg	the input [arg_2] ||| [function_1] [arg_2]	count=5
arg	components data ||| data	count=1
arg	scalar ||| scalar	count=1
class	by a groebner ||| groebner	count=1
rep	[module_class_1] [function_arg_2] ||| [module_class_1] schreier [function_arg_2]	count=2
module	bounding ||| polys	count=1
module_class	dimension system ||| units unit system	count=1
function_arg	get [arg_2] ||| physics quantum matrix cache [function_1] [arg_2]	count=1
function	dummy ||| dummy	count=1
function_arg	addends [arg_2] ||| [function_1] [arg_2] key1	count=2
arg	polynomial in k[x] ||| f u k	count=10
function	function with name ||| function base	count=1
function	the infimum ||| inf	count=1
function	space characters to the ||| indent	count=1
class	of coset ||| coset table	count=2
function	the atan of p, ||| rs atan	count=1
function_arg	square-free [arg_2] ||| [function_1] [arg_2]	count=3
module	returns a standard basis ||| polys agca	count=1
function	symbol for undefined variables ||| auto symbol	count=1
arg	growing the grid and ||| grid	count=1
function	[function_1] points for ||| [function_2] [function_1]	count=2
class	a string [class_2] ||| [class_1] [class_2]	count=1
function	[function_1] spherical harmonics ||| [function_2] [function_1]	count=3
class	extension ||| differential extension	count=1
function	return whether a partial ||| partial	count=1
arg	constructing the string ||| i j grid morphisms_str_info	count=1
function	undetermined [function_2] ||| [function_2] [function_1]	count=2
function	lu [function_2] ||| [function_2] [function_1]	count=1
function	square root in the ||| sqrt	count=1
function	square-free polynomial using the ||| sqf	count=1
arg	addition expression and call ||| expr	count=1
class	formal [class_2] ||| [class_2] [class_1]	count=2
function	composite ||| composite	count=1
function	generated ||| expr	count=1
function	[function_1] and beta ||| [function_1] [function_2]	count=1
function	an [function_1] [function_2] ||| [function_2] [function_1] func_class f symbol	count=4
function_arg	[function_1] sympy sense ||| [function_1] i [arg_2]	count=3
class	coset ||| coset table	count=2
function	splits ||| mod func	count=1
function	negative ||| opt cse	count=2
class	return a list of ||| frac field	count=1
function	of singularity functions ||| as singularity function	count=1
arg	of lagrangesmethod lagrangian : ||| lagrangian	count=1
function	the primitive form of ||| ground primitive	count=1
arg	the user in the ||| weylelt	count=2
function	alpha implication ||| alpha	count=1
function	real sets ||| as set	count=1
arg	a model or ||| expr model deep	count=1
module	p[i+1] ||| combinatorics	count=2
arg	index in ||| index	count=2
arg	f var compute ||| f var	count=1
function_arg	[function_1] [arg_2] ||| [function_1] path [arg_2]	count=8
function	below fermi? >>> from ||| only below fermi	count=1
function	the general ||| general	count=1
function_arg	root [arg_2] ||| [arg_2] [function_1]	count=11
class	if the function ||| holonomic function	count=1
function	shape dimension ||| shape	count=1
function	reconstruct every rational ||| rational reconstruction	count=1
arg	f to ||| f atoms nonbasic	count=1
function	intended or q[x] ||| vv	count=1
arg	[arg] modulo the ||| [arg]	count=1
class	create ||| subs set	count=1
function	canonicalize in tensor_can ||| indices canon args	count=1
function	the interior ||| interior	count=1
arg	[arg_1] selected ||| [arg_2] [arg_1]	count=5
module	form x start ||| series	count=1
arg	simplify the solution [arg_1] [arg_2] ||| [arg_1] [arg_2]	count=9
arg	on the components ||| components	count=1
function	the name of the ||| mod func	count=1
function_arg	points for [arg_2] ||| [arg_2] [function_1]	count=1
arg	an indexed root ||| x index radicals	count=1
function	to their coefficient ||| coefficients	count=1
function	returns all native coefficients ||| native coeffs	count=1
arg	of terms of f ||| f x m n	count=1
function	the primitive form ||| dmp ground primitive	count=1
arg	writer [arg_2] ||| [arg_2] [arg_1]	count=2
arg	dum indices [arg_2] ||| [arg_2] [arg_1]	count=1
arg	of [arg] ||| [arg]	count=1
function	the class ||| mod func	count=1
function_arg	division of [arg_2] ||| [function_1] [arg_2]	count=8
function	rational generating function ||| generating function	count=1
function	subtract dense ||| dmp sub	count=2
arg	similar bases and exponents ||| combine force	count=1
function_arg	[function_1] [arg_2] ||| [function_1] to to_sys [arg_2]	count=1
function	[function] function takes ||| add [function]	count=1
arg	g in ||| g k	count=1
arg	of expressions [arg] ||| [arg]	count=2
arg	[arg_1] the given ||| [arg_2] [arg_1]	count=6
class	sparse n-dim ||| sparse ndim	count=1
arg	of two permutation groups ||| other	count=1
function	set ||| pairs	count=1
module	the position ||| physics	count=1
function_arg	to a [arg_2] ||| [function_1] force [arg_2]	count=4
arg	efficiently test if f ||| f k	count=1
function_arg	[function_1] factor ||| [arg_2] [function_1]	count=3
function	the magnitude ||| magnitude	count=1
function	unit ||| unit	count=4
function	reflections of ||| generators	count=1
arg	of the diagram ||| diagram	count=1
class	generate a ||| poly ring	count=1
class	mapping of symbolic ||| code	count=1
function	the function is decreasing ||| is decreasing	count=1
module	as subgroup using ||| combinatorics	count=1
arg	element to self ||| element base	count=1
function	[function_1] a mul ||| [function_1] coeff [function_2]	count=1
function	best solution to ||| 1st homogeneous coeff best	count=1
function	von mises distribution ||| von mises	count=2
function	the derivative of the ||| derivative	count=1
class	docstrings ||| doc	count=1
module_class	[module_1] the atoms ||| [module_1] [class_2]	count=2
class	picture ||| string pict	count=1
function	create function with ||| create function base	count=2
arg	l is the term ||| l r n limits	count=1
function	heuristic assumes the infinitesimals ||| heuristic bivariate	count=1
arg	[arg] describe its ||| [arg]	count=3
arg	[arg_1] to expr ||| [arg_2] [arg_1]	count=8
arg	of f defined as ||| f k	count=1
arg	simplifies [arg_2] ||| [arg_2] [arg_1]	count=4
class	that no ||| root	count=1
arg	and d is ||| d	count=1
arg	of a field ||| field	count=2
arg	[arg_1] modulo o(x**prec) ||| [arg_1] [arg_2]	count=2
function	the symbol in ||| literal symbol	count=1
arg	to a base and ||| base	count=1
module_class	return [class_2] ||| [module_1] [class_2]	count=22
arg	[arg_1] optionally ||| [arg_1] condition [arg_2]	count=1
function	laplace ||| laplace	count=3
class	fortran ||| fcode gen	count=4
class	the ||| fcode gen	count=2
function	squares ||| squares	count=1
function	the subset defined ||| get subset	count=1
class	exploiting ||| sparse matrix	count=2
function	polynomial ||| polynomial	count=7
function	an [function] ||| is function class [function]	count=3
function	of ||| refine	count=1
function_arg	remove [arg_2] ||| [function_1] [arg_2]	count=1
function	the product of elements ||| mul	count=1
function	f - g*h where ||| dmp sub mul	count=1
function	an ordinary decimal instance ||| decimal	count=1
function	dictionary which expresses the ||| map	count=1
arg	subgroup [arg] using ||| [arg]	count=1
arg	field [arg_2] ||| [arg_1] [arg_2]	count=2
arg	stabilizer of [arg_2] ||| [arg_2] [arg_1]	count=2
arg	n raise an ||| n	count=1
function	linearly dense quartic inputs ||| f 2	count=2
class	coset [class_2] ||| [class_2] [class_1]	count=2
function	can be a symbol ||| symbols2i	count=1
function	coefficient of ||| as coeff	count=7
function	calculates the finite ||| apply finite	count=1
class	return a ||| frac	count=1
function_arg	the resultant [arg_2] ||| [function_1] [arg_2]	count=3
function	generator that ||| generator	count=1
class	[class] an ||| [class]	count=1
arg	convenience if reduction ||| ai bj	count=1
function	the entire free ||| full	count=2
class	return ||| complex root of	count=2
function	[function_1] all ||| [function_2] [function_1]	count=1
function	factors of ||| factors	count=2
module	r rows [module] ||| [module]	count=3
class	that ||| series	count=1
function	to ||| dmp to	count=1
arg	word ||| alpha word	count=1
arg	if directed ||| directed	count=1
arg	morphism is ||| morphism	count=1
module_class	color [class_2] ||| [module_1] color [class_2]	count=1
arg	and b, implies nothing ||| b	count=1
class	new referenceframe ||| reference	count=1
class	basis ||| poly	count=1
module_class	[module_1] [class_2] ||| [module_1] quantum [class_2] operators	count=1
function	c(x_2 x_u)*x_0**i ||| term	count=2
function	find the periodic ||| periodic	count=1
function	tensor product of different ||| combined tensor printing	count=1
function	unit polynomial ||| one	count=1
function_arg	nth moment [arg_2] ||| [arg_2] [function_1]	count=1
function	the expr cond ||| sort expr cond	count=2
arg	differentiating under the ||| sym	count=1
function	return the leading coefficient ||| gf lc	count=1
class	monomial ||| monomial	count=1
function_arg	numerator of a ||| numer a	count=2
class	[class_1] element in ||| [class_2] [class_1]	count=1
function	files default ||| files	count=1
arg	mapping in rules ||| rules x prec	count=1
function	diagram ||| build xypic string	count=1
class	a group ||| free group element	count=1
function_arg	down a [arg_2] ||| [arg_2] [function_1]	count=2
function	a sqrt otherwise false ||| sqrt	count=1
function_arg	[function_1] to_j, where ||| [arg_2] [function_1]	count=5
arg	morphisms [arg_2] ||| [arg_2] grid [arg_1]	count=1
function_arg	of sin [arg_2] ||| [function_1] [arg_2]	count=1
module	to [module] same ||| [module]	count=1
arg	of [arg] with ||| [arg]	count=1
function	[function_1] a gf ||| [function_2] [function_1]	count=5
class	standard basis ||| module poly	count=1
arg	polynomial expression [arg_2] ||| [arg_2] [arg_1]	count=1
function	scan performs a scanning ||| scan	count=1
function	a field [function_2] ||| [function_2] [function_1]	count=4
arg	of two univariate polynomials ||| g	count=1
function	a list ||| from list	count=1
arg	the finite_set ||| finset_intersection	count=1
arg	ub ||| ub	count=1
arg	polynomials in k[x] ||| polys u k	count=1
function	object has [function_2] ||| [function_1] [function_2]	count=1
function	a class into a ||| func	count=1
arg	p of ||| p t	count=1
function_arg	int [arg_2] ||| [arg_2] [function_1]	count=1
function	list of native ||| native	count=1
module_class	[module_1] submodule ||| [module_1] [class_2]	count=14
arg	beta x gives ||| x	count=1
function	of the symbols ||| symbols	count=2
module	name of ||| utilities	count=1
function	and transversals from a ||| transversals from bsgs	count=1
function_arg	[function_1] msg ||| [function_1] [arg_2]	count=1
function_arg	[function_1] sin x ||| [arg_2] [function_1]	count=1
class	enumerate ||| partition traverser	count=1
function	perform unit ||| unit prop	count=2
function	[function_1] [function_2] ||| [function_1] coeff [function_2]	count=2
arg	of polynomials in ||| f g	count=2
arg	private key ||| key	count=1
function	the subset defined ||| get subset from	count=1
function	divide ||| div	count=2
function	[function] false ||| needs [function]	count=7
arg	base and ||| group base gens	count=1
arg	a ||| m a	count=1
function	s, ||| indent	count=1
function	into ||| get mod	count=1
function	sequences defined [function] starting ||| assoc [function]	count=1
function_arg	[function_1] gr adjacency ||| [function_1] certificate [arg_2]	count=1
arg	a/d ||| d	count=1
arg	if e ||| e	count=1
arg	return denested [arg] after denesting ||| [arg]	count=1
arg	r [arg] is ||| r [arg]	count=1
module	permutation ie the location ||| combinatorics	count=2
class	no ||| complex root of	count=2
function	from beckerweispfenning93 p 216 ||| red	count=1
function	reduce [function_2] ||| [function_2] [function_1]	count=2
arg	dictionary morphisms ||| morphisms	count=1
function	order ||| order	count=15
function_arg	the gcd [arg_2] ||| [arg_2] [function_1]	count=1
function	a root to ||| root	count=2
module	without the added ||| physics vector	count=1
function	phrase and if ||| check and join	count=1
function_arg	[function_1] p [x] ||| [function_1] sqr f [arg_2]	count=1
function_arg	[function_1] [arg_2] ||| [function_1] function [arg_2]	count=7
arg	[arg_1] [inf sup] ||| [arg_1] [arg_2]	count=3
function_arg	[function_1] suitability ||| [function_1] [arg_2]	count=4
function	sparse matrix to a ||| sparse to	count=1
arg	[arg_1] targets and ||| [arg_1] [arg_2]	count=1
function	+ g*h where ||| dmp add mul	count=2
function	to take [function] wrt ||| [function]	count=1
function	factor primitive square-free ||| zassenhaus	count=1
function	[function_1] a scalar ||| [function_2] [function_1]	count=1
function_arg	[function_1] base and ||| [function_1] bsgs [arg_2]	count=1
arg	to two labeled ||| g ring	count=1
function	matrix to a sympy ||| to sympy	count=1
module	the object ||| series	count=1
arg	ops [arg_2] ||| [arg_2] [arg_1]	count=2
class	method returns the ||| series	count=1
arg	[arg_1] optionally ||| [arg_2] [arg_1]	count=1
function	outer indices of a ||| get indices	count=1
function	returns level associated ||| level	count=1
function	content and primitive ||| as content primitive	count=2
module_class	generate a [class_2] ||| [module_1] [class_2]	count=4
function	e ||| e	count=1
arg	order n [arg_2] ||| [arg_2] [arg_1]	count=1
arg	returns a coordsyscartesian ||| vector_names	count=1
module_class	[module_1] point ||| [module_1] [class_2]	count=13
arg	[arg_1] [arg_2] ||| [arg_1] y z [arg_2]	count=3
function	[function_1] mpq object ||| [function_2] [function_1]	count=12
arg	to eliminate x_0 from ||| u k	count=1
arg	and return eq ||| eq	count=1
arg	instance of cls given ||| cls rep lev dom	count=2
function	open ||| open	count=1
arg	of roots of f ||| f	count=2
class	return raw input ||| complex region	count=1
function	path to the ||| get	count=1
function_arg	[function_1] [arg_2] repeated squaring ||| [function_1] [arg_2]	count=1
function	files default from which ||| files	count=1
function	[function_1] iterable or ||| [function_2] [function_1]	count=1
arg	compute the monic ||| f	count=1
module	case [module] cf ||| [module]	count=1
function	to a list representation ||| as list	count=1
arg	[arg_1] expression ||| stats given [arg_2] [arg_1]	count=2
function	those which are free ||| free	count=1
class	for ||| code	count=1
function	strong [function_2] ||| [function_1] [function_2]	count=3
function	the directional [function_2] ||| [function_2] [function_1]	count=3
function_arg	degrees [arg_2] ||| [function_1] list [arg_2]	count=1
function	subresultant prs of ||| subresultants	count=1
function	and the ||| get mod func	count=1
function_arg	factors of [arg_2] ||| [arg_2] [function_1]	count=1
arg	s t ||| s t	count=1
arg	x_j [arg_2] ||| [arg_2] [arg_1]	count=9
arg	[arg_1] s ||| [arg_2] [arg_1]	count=8
arg	function for fast calculation ||| expr modules printer	count=1
function	[function_1] factors ||| [function_1] list [function_2]	count=2
function	threaded ||| threaded	count=1
function	object to dtype ||| from	count=8
module	if possible ||| pretty	count=1
module_class	self with [class_2] ||| [class_2] [module_1]	count=1
function	to an ode from ||| ode 1st homogeneous	count=1
arg	n this ||| n	count=1
function	is positive ||| is positive	count=5
function	[function_1] a power ||| [function_1] [function_2]	count=1
function	reduced to the ||| reduced	count=1
function	helper function for nthroot ||| nthroot solve	count=1
function_arg	[function_1] [arg_2] ||| [function_1] expr [arg_2]	count=37
arg	function ||| func x0	count=1
class	smallest affine [class] containing all ||| [class]	count=1
arg	fp_group a ||| elm_rounds simp_rounds	count=1
function	the sum ||| do sum	count=1
arg	[arg_1] d with ||| [arg_2] knots [arg_1]	count=2
function_arg	to gray [arg_2] ||| [function_1] [arg_2]	count=1
function	in ||| dup	count=4
arg	[arg_1] by index ||| [arg_1] [arg_2]	count=4
function_arg	[function_1] modulus ||| [function_1] f [arg_2]	count=1
function	check a ||| check	count=1
arg	[arg_1] via prs ||| [arg_1] [arg_2]	count=3
arg	scalar ||| e	count=2
function	the semi-latus ||| semilatus	count=1
class	product ||| product	count=3
class	whose elements have the ||| partition traverser	count=1
function	the name of the ||| func	count=1
arg	algorithm i e ||| g n	count=1
module	mapping ||| printing	count=1
function	the derived [function_2] ||| [function_2] [function_1]	count=1
function_arg	rotates [arg_2] ||| [arg_2] [function_1]	count=1
arg	n in x ||| n a x	count=1
function_arg	[function_1] p [x]/ ||| [arg_2] [function_1]	count=1
function	log [function_2] ||| [function_2] [function_1]	count=2
arg	a set of points ||| points	count=1
function	line ||| line	count=4
arg	k[x] using the ||| u	count=1
function	checks for the convergence ||| is convergent	count=1
arg	first if directed ||| directed	count=1
function_arg	[function_1] in a ||| [arg_2] [function_1]	count=1
function	wang/eez test evaluation ||| dmp zz wang test	count=1
function	[function] between the ||| set dict [function]	count=2
class	code [class_2] ||| [class_2] [class_1]	count=2
function	linear time [function] algorithm ||| [function]	count=2
class	partition is listed ||| partition	count=1
function	[function_1] ring ||| [function_2] [function_1]	count=8
arg	vector ||| vector	count=1
function	of the square-free normal ||| sqf normal	count=1
function_arg	printing [arg_2] ||| [function_1] [arg_2]	count=1
arg	simplifies the given expression ||| expr ratio measure fu	count=1
function	next to each other ||| next	count=1
function	bounding ||| refine complexes	count=2
function	inverse using lu decomposition ||| inverse lu	count=1
arg	[arg_1] n ||| physics energy [arg_2] [arg_1]	count=4
arg	a pair of polynomials ||| g	count=1
function_arg	[function_1] expr using ||| [arg_2] [function_1]	count=1
function_arg	extract from a [function_1] [arg_2] ||| physics hep [function_1] [arg_2]	count=1
function	direction [function_2] ||| [function_1] [function_2]	count=12
function	the partition [function] ||| next [function]	count=1
module	value (i ||| series	count=1
arg	point on [arg] ||| [arg]	count=1
arg	and negative coefficient muls ||| order	count=1
arg	m is the number ||| m	count=1
module	add the ||| utilities	count=1
arg	[arg_1] and b ||| categories diagram hom [arg_1] [arg_2]	count=1
function_arg	[function_1] [arg_2] ||| [function_1] operator int qubit [arg_2]	count=2
arg	[arg_1] with ||| [arg_2] [arg_1]	count=1
function	basic orbits relative ||| basic orbits	count=1
class	run ||| doc test runner	count=1
arg	[arg_1] p == ||| [arg_2] [arg_1]	count=4
module	matrices ||| matrices	count=9
function	part of the denominator ||| denom	count=1
function	[function_1] k ||| [function_1] [function_2]	count=2
module	return self raised ||| core	count=1
function	unsetting ||| lit unset	count=1
function	to a fully contravariant ||| tensorhead from	count=1
arg	anti-derivative [arg_2] ||| [arg_2] x [arg_1]	count=1
function	restricted to [function_2] ||| [function_2] [function_1]	count=1
module	and leverage it ||| printing pretty	count=1
module	matrix to a ||| matrices	count=1
arg	the ith prime number ||| i	count=1
function	the string path to ||| mod	count=1
class	julia ||| julia	count=1
module	this vector ||| vector	count=1
function_arg	[function_1] f ||| [function_1] ground [arg_2]	count=6
class	hole or create ||| fermion	count=2
function_arg	[function_1] n in ||| [function_1] [arg_2]	count=18
class	object excluding those ||| series base	count=1
arg	of f in k[x], ||| f u	count=1
arg	its attributes to ||| props add_identities	count=1
module	about the ||| physics	count=1
function	return constant term in ||| constant term	count=1
function	finite_set in which ||| empty in	count=1
arg	scalar field ||| scalar_field doit	count=1
function	generate necklaces that ||| necklaces	count=1
function	classes to their associated ||| operators to state	count=1
function	[function_1] irreducible factors ||| [function_2] [function_1]	count=18
function	system using lusolve ||| system lu	count=1
function	quotient in [function_2] ||| [function_2] [function_1]	count=2
function_arg	interval [arg_2] ||| plot [function_1] [arg_2]	count=4
arg	a single symbol ||| a b	count=1
arg	of n and ||| n	count=1
module	vector ||| vector	count=13
function_arg	[function_1] examples ||| [arg_2] [function_1]	count=1
arg	for details ||| f x re g	count=1
function	the hilbert [function_2] ||| [function_1] [function_2]	count=1
class	random ||| permutation group	count=2
arg	return the root if ||| cls root radicals	count=1
class	a standard basis in ||| module	count=1
function	the ground [function_2] ||| [function_1] [function_2]	count=2
arg	an expression old -> ||| old	count=1
function_arg	[function_1] x_j in ||| [function_1] f [arg_2]	count=2
arg	polynomial p ||| p u k	count=1
function_arg	dict representation ||| dict reorder rep	count=1
class	whether a ||| basic	count=1
function	the linear equation ax ||| linear	count=1
arg	i j see ||| i j	count=1
arg	a single symbol e ||| a	count=1
function	the slope ||| slope	count=1
function	number of roots ||| roots	count=6
function	[function_1] a univariate ||| [function_1] [function_2]	count=1
function	a line [function_2] ||| [function_2] [function_1]	count=2
function	[function_1] z ||| [function_2] [function_1]	count=1
class	for ||| code gen	count=2
arg	p ||| p domain	count=1
class	power [class_2] ||| [class_2] [class_1]	count=1
arg	[arg_1] modulo p ||| [arg_2] [arg_1]	count=1
function	[function_1] structure of ||| [function_2] [function_1]	count=3
module	derivative of [module] self ||| [module]	count=1
class	dtype ||| integer ring	count=1
arg	for n data points ||| n	count=1
function	the berkowitz algorithm to ||| det berkowitz	count=1
function	3-tuple a b ||| three	count=1
function	a product [function_2] ||| [function_1] as [function_2]	count=1
arg	boolean indicating whether i ||| i	count=1
module	return the truth value ||| functions	count=1
arg	root x [arg_1] [arg_2] ||| [arg_1] [arg_2]	count=4
module	numerical ||| holonomic	count=1
function	try [function] transformation ||| [function] rational	count=1
class	module ||| module quotient	count=1
function	[function_1] a polynomial ||| [function_2] [function_1]	count=1
arg	g in f[x] ||| g k	count=1
module	diagonal [module] from a ||| [module]	count=1
arg	item in args ||| args	count=1
arg	a base ||| base	count=1
module_class	[module_1] subset ||| [module_1] [class_2]	count=6
function	[function_1] ring i ||| [function_1] [function_2]	count=4
function	the atanh of ||| atanh	count=1
function	available and leverage it ||| pretty try use	count=1
function	vector ||| base vector	count=1
function	syllables from ||| sub syllables	count=1
function	return the function ||| function	count=1
function	xor ^, as ||| convert xor	count=1
function_arg	multiply tuple x ||| mul m x	count=2
class	the faces of the ||| polyhedron	count=1
arg	e [arg_2] ||| eapply func [arg_1] [arg_2]	count=4
arg	for x**n == a ||| a	count=1
module	the polyhedra ||| combinatorics	count=1
module	of the patterns ||| matrices	count=1
function	differentiate [function_2] ||| [function_1] [function_2]	count=3
function	returns the commutator of ||| commutator	count=1
function_arg	normal ordered [function_1] [arg_2] ordered ||| physics quantum normal ordered [function_1] [arg_2]	count=1
function	coding to [function_2] ||| [function_1] [function_2]	count=1
function	classes to ||| to	count=1
arg	algorithm ||| g n	count=1
arg	has already been sympify'ed ||| symbol domain _check	count=1
arg	[arg] relatively ||| p q [arg]	count=2
arg	[arg_1] [arg_2] ||| [arg_2] infinitesimals func [arg_1]	count=4
function	in z[x] ||| dup zz	count=4
function_arg	[function_1] instance ||| [function_1] [arg_2]	count=3
function	the commutator of ||| commutator	count=1
arg	[arg_1] if it ||| [arg_2] [arg_1]	count=1
function	ternary diophantine equation ax^2 ||| ternary	count=1
function	function is ||| is rational function	count=1
class	indices creating ||| index structure	count=1
function	free symbols of ||| free symbols	count=2
arg	of the [arg_2] ||| [arg_1] y z [arg_2]	count=1
arg	[arg] simple root ||| [arg]	count=3
module_class	[module_1] or ||| [module_1] [class_2]	count=2
arg	instance of ||| cls expr	count=1
function	distinct real ||| dup count real	count=1
function_arg	where [arg_2] ||| [function_1] [arg_2]	count=18
class	reduce ||| poly ring	count=1
function	sparse matrix to ||| sparse to	count=2
function_arg	[function_1] factors ||| [function_1] [arg_2]	count=1
function	factor square-free [function_2] ||| [function_2] [function_1]	count=2
function	coefficients try [function] transformation x ||| [function] rational	count=1
class	sequence of polynomials or ||| poly	count=1
function	bifid cipher decryption ||| decipher	count=1
function	lcm ||| lcm	count=8
function	slope the elastic curve ||| slope	count=1
function	of two [function_2] ||| [function_2] [function_1]	count=2
function	represents the slope the ||| slope	count=1
function	a continuous subsequence ||| dmp slice	count=2
function	irreducible factors ||| factor	count=3
function	apply a ||| termwise	count=1
arg	[arg_1] [arg_2] ||| [arg_2] g [arg_1]	count=1
arg	wrt [arg] ||| vect [arg]	count=4
arg	variable with a ||| name a	count=7
function	operators ||| as	count=1
arg	function for ||| expression predicate interval symbol	count=1
class	return a new code ||| code	count=1
class	generate ||| poly	count=1
function	of the ||| get mod	count=1
function	coefficient of a product ||| coeff mul	count=4
arg	poly ||| poly	count=2
function	[function_1] [function_2] cholesky factororization ||| [function_1] [function_2]	count=6
class	or ||| ring	count=1
class	p[i+1] ||| permutation	count=2
function_arg	pseudo-division [arg_2] ||| [function_1] [arg_2]	count=2
function_arg	expressions generated in ||| vpprint expr	count=1
arg	x0 ||| x0	count=2
function	dmf object to ||| fraction field	count=1
arg	for _match_div_rewrite ||| f g rexp	count=1
function	given function [function_2] ||| [function_2] [function_1]	count=1
module_class	on the body ||| physics mechanics body	count=1
arg	arguments and return eq ||| eq	count=1
module	[module_1] the ||| [module_1] [module_2]	count=28
function	symbols ||| symbols	count=6
function	quadrants from ||| quadrants	count=1
function	of the ||| get mod func	count=1
function	ordinary point ||| ordinary	count=1
function	clear denominators in a ||| rat clear denoms	count=1
function	to a class into ||| mod func	count=1
function	hint implements the lie ||| ode lie	count=1
module	or vector ||| vector	count=1
function_arg	[function_1] [arg_2] 1 through n where ||| [function_1] [arg_2]	count=2
arg	list of mpfval accuracy ||| prec target_prec	count=1
function_arg	new [arg_2] ||| [function_1] [arg_2]	count=1
function	[function_1] successfully decremented ||| [function_2] [function_1]	count=1
class	a monomial ||| monomial	count=1
arg	[arg_1] beta distribution ||| [arg_2] [arg_1]	count=1
function_arg	a key [arg_2] ||| [arg_2] [function_1]	count=1
function_arg	coset table [arg_2] ||| [arg_2] [function_1]	count=1
arg	model ||| clauses model	count=1
function	matrix representation ||| matrix	count=1
class	on the ||| expr op	count=1
function	subset defined by ||| get subset	count=1
function	python's ||| python	count=2
function	shallow copy ||| copy	count=1
function	cancellation ||| cancel	count=1
function	if the left ||| left	count=1
arg	p k ||| p	count=1
arg	composite polynomial ||| cls poly	count=3
function_arg	[function_1] x_j of ||| [function_1] [arg_2]	count=2
function	isolate real roots ||| isolate real roots	count=3
function	is the entire free ||| is full	count=2
arg	given field ||| field coord_sys	count=2
function	helper for solveset to ||| solveset	count=1
function	as ||| elgamal	count=1
function	centralizer ||| centralizer	count=1
function	as [function] ||| unit [function] int	count=3
function_arg	[function_1] polynomial techniques ||| [function_1] poly f symbol [arg_2]	count=1
function_arg	[function_1] m ||| utilities [function_1] [arg_2]	count=2
arg	e if ||| e cond	count=1
function	polynomial ring i e ||| poly ring	count=2
function	structure [function] *dummy* we ||| [function] contraction	count=1
arg	return a ||| a b	count=1
function	of descents in a ||| descents	count=1
arg	[arg_1] key ||| [arg_1] [arg_2]	count=3
class	truth value of the ||| piecewise	count=1
function	minimal ||| unify	count=1
arg	using ||| f	count=1
class	return ||| limits	count=1
class	hole ||| create fermion	count=1
function	return the ket ||| ket	count=1
function	the string ||| mod func	count=1
function_arg	[function_1] a given ||| [function_1] [arg_2]	count=3
function	product of cos or ||| tr9	count=1
arg	solve [arg] n linear ||| [arg]	count=1
function	morphisms ||| morphism closure	count=1
arg	in phrase is ||| phrase	count=1
arg	suitability ||| f t ct	count=1
module	is ||| core	count=1
function	the affine ||| affine	count=1
arg	a text ||| text color align	count=1
module	expected to be ||| logic algorithms	count=3
function_arg	series expansion [arg_2] ||| [function_1] min pow [arg_2]	count=1
arg	== b**e if n ||| n	count=1
arg	[arg] when ||| [arg]	count=3
function_arg	the symbol [arg_2] ||| [function_1] [arg_2]	count=1
module	the current ||| physics	count=1
class	column matrix ||| symbolic system	count=2
function	of a power ||| pow	count=1
function	a univariate ||| univariate	count=1
function_arg	indefinite integral [arg_2] ||| [function_1] [arg_2]	count=2
module	eigenstate instance for the ||| physics quantum	count=1
function	normal ordering ||| normal order terms	count=1
arg	of the terms ||| x x0	count=1
function	printed as [function] ||| needs [function]	count=1
arg	target to [arg_2] ||| [arg_1] [arg_2]	count=1
function_arg	[function_1] ops ||| [arg_2] [function_1]	count=5
arg	not false [arg] ||| [arg]	count=1
function	indices corresponding to those ||| indices	count=2
function	symbolic values to ||| param	count=1
function	time derivative ||| dt	count=1
function	multinomial form into ||| from dict	count=1
function	the element ||| element	count=1
function	bound on polynomial ||| bound	count=1
arg	independent [arg] knowledge of ||| [arg]	count=1
function	[function_1] base ||| [function_2] [function_1]	count=1
function	a ||| get statement	count=1
arg	in x ||| x alpha	count=1
function	phrase and if symbols ||| check and	count=1
function	to decide how ||| hprint	count=1
function	triangle ||| weld triangle	count=1
function	to a ||| from	count=3
arg	[arg_1] knots ||| [arg_1] [arg_2]	count=4
arg	of n ||| n	count=12
module	the ||| elementary	count=2
arg	x ||| a b x	count=1
class	of pstack if ||| multiset partition traverser	count=2
function_arg	[function_1] msg ||| [arg_2] [function_1]	count=2
function_arg	[function_1] msg ||| crypto encipher [function_1] [arg_2]	count=1
function_arg	true if f ||| is irreducible f	count=1
arg	k1 ||| k1	count=1
module_class	of the [class_2] ||| [module_1] ray transfer [class_2]	count=4
function	random integer partition summing ||| random integer partition	count=1
function	z distribution ||| z	count=1
function	values attained by other, ||| gt	count=1
class	for the symmetric/alternating group ||| group	count=1
function	[function] triangle ||| [function]	count=1
arg	of ||| x	count=20
function_arg	variations of [arg_2] ||| [function_1] [arg_2]	count=1
function_arg	[function_1] seq ||| [arg_2] [function_1]	count=1
class	root [class_2] ||| [class_1] [class_2] dynkin	count=1
function	[function_1] from positions ||| [function_2] [function_1]	count=8
function	precedence matrix this is ||| precedence matrix	count=1
arg	a vector constants ||| variable constant	count=1
function	represents [function] between this ||| [function]	count=1
function	apply ||| termwise	count=1
module	truth value of the ||| functions elementary	count=1
function	the truth value ||| cond	count=1
function	the quotient homomorphism ||| quotient hom	count=2
function	wrapper around the ||| wrapper	count=1
function_arg	encryption of [arg_2] ||| [arg_2] [function_1]	count=2
function	of descents ||| descents	count=1
function	this type of ode ||| order1	count=1
function	upper-hessenberg form ||| upper hessenberg	count=1
function	copy of the ||| structure copy	count=1
function	refine a ||| inner refine real	count=1
module	is a [module] number true ||| [module]	count=1
arg	op ex1 ||| op ex1	count=1
arg	of f in ||| f m	count=1
class	non-conjugate ||| root of	count=2
class	the ground domain ||| dmp	count=3
function	converts a term in ||| convert to	count=1
class	matrix ||| weyl group	count=1
class	of ||| f	count=1
module	of a [module] element-wise ||| [module]	count=1
class	total number ||| type g	count=1
class	rectangles of ||| complex root of	count=1
arg	d with ||| d	count=3
arg	[arg_1] [arg_2] ||| [arg_2] [arg_1]	count=1034
arg	fac*g where g ||| g x	count=1
function	interchange two limit tuples ||| reorder limit	count=1
arg	system ||| system	count=2
module	value [module] ||| [module]	count=1
function	unknown function [function_2] ||| [function_2] [function_1]	count=6
function	by^2 + cz^2 ||| normal	count=1
arg	the form x start ||| func	count=1
function	sorting ||| sort	count=1
function	operation count ||| count	count=1
function	a loop morphism ||| process loop morphism	count=2
arg	f ||| f k inf	count=1
function	devise [function_2] ||| [function_2] [function_1]	count=2
function	the direction ||| direction	count=3
module	gets the ||| combinatorics	count=1
function	evaluate ||| evalf	count=1
function_arg	[function_1] polynomial f ||| [arg_2] [function_1]	count=6
arg	and coefficient dictionary ||| coeff	count=1
class	this gate ||| gate	count=1
arg	of polynomials [arg_2] ||| [arg_2] [arg_1]	count=2
module	the unit ||| physics units	count=2
module	perform [module_2] ||| [module_2] [module_1]	count=1
function	[function_1] strictly ||| [function_2] [function_1]	count=8
function	solve a polynomial ||| solve poly	count=3
function	inverse of the ||| inverse	count=2
function	a common header for ||| get header	count=2
arg	or as a ||| x a	count=1
arg	first order ||| order	count=3
function	ode are ||| 2eq order1 type3	count=1
arg	modify [arg_2] ||| [arg_2] [arg_1]	count=9
module	words ||| combinatorics	count=1
function	below fermi? ||| below fermi	count=1
arg	not [arg] lexicographic order ||| [arg]	count=1
function_arg	[function_1] order ||| [function_1] eq func [arg_2]	count=1
arg	b m + ||| b	count=1
function	merge explicit ||| merge explicit	count=2
module	s, and return the ||| utilities	count=1
function	[function] the ||| comm [function]	count=2
module	the state ||| physics	count=2
arg	over the fundamental strip ||| strip	count=1
function	return the truth ||| eval	count=1
function	gcd and cofactors of ||| inner gcd	count=2
function	[function_1] definite ||| [function_2] [function_1]	count=1
function	rewrites ||| eval rewrite as heaviside	count=1
function	tensor product of different ||| combined tensor	count=1
function_arg	[function_1] isolating interval ||| [arg_2] [function_1]	count=2
class	the integral sign [1], ||| integral	count=1
arg	cls ||| cls	count=1
function	the convergence ||| convergent	count=1
arg	[arg_1] k is ||| [arg_2] [arg_1]	count=4
function	lc and a monic ||| monic	count=1
function	where ||| ground	count=3
arg	the function f x ||| f x	count=1
function	[function_1] plan consisting ||| [function_1] [function_2]	count=1
arg	get an element from ||| index	count=1
function	crt for ||| crt	count=1
arg	the real inverse_mellin_transform function ||| f s x_ strip	count=1
function_arg	[function_1] of f ||| [function_1] list [arg_2]	count=4
function	and leverage it ||| try	count=1
function	isomorphism [function_2] ||| [function_1] [function_2]	count=1
arg	find ||| order	count=1
function	the domain of ||| not	count=1
class	that no bounding ||| of	count=1
function	the leading degree ||| gf degree	count=1
arg	ex2 parameters ||| ex2	count=1
function	over ||| rr	count=4
function	von ||| von	count=1
arg	the routine ||| routine	count=3
arg	defined ||| k	count=1
function	an algebraic [function_2] ||| [function_1] [function_2]	count=2
function	a von mises distribution ||| von mises	count=1
module	we ||| combinatorics	count=1
module	function in the specified ||| physics quantum	count=1
function	an error ||| count error	count=1
function	arranged in ||| bifid	count=1
function_arg	[function_1] to n ||| [function_1] [arg_2]	count=7
function	[function] series ||| ode 1st [function]	count=1
function	real univariate ||| univariate	count=1
function	[function_1] roots ||| [function_1] [function_2]	count=27
function	of free indices corresponding ||| free indices	count=1
class	the ideal ||| ideal	count=2
class	sequence of ||| poly ring	count=1
function	coefficients of ||| ground content	count=1
function	[function_1] scalar ||| [function_1] [function_2]	count=1
class	fraction ||| dmf	count=1
class	adds and returns ||| add	count=1
function	the previous [function_2] ||| [function_1] [function_2]	count=2
arg	in the ||| f	count=1
arg	alpha ||| degree generators alpha	count=3
function	is of ||| of	count=1
arg	true if [arg] is ||| [arg]	count=1
arg	a model or not ||| model	count=1
function	geometric entity parallel ||| parallel	count=1
module	available and leverage ||| printing	count=1
function	remove common factors ||| factor	count=1
class	method returns the ||| base	count=1
module	the divergence [module] field computed ||| physics [module]	count=1
function	+ [function_2] ||| [function_2] [function_1]	count=6
function_arg	[function_1] of a ||| [function_1] at [arg_2]	count=3
function	from zero to infinity ||| definite 3	count=1
function	this heuristic ||| lie heuristic	count=3
arg	return eq with ||| eq	count=1
class	body ||| body orienter	count=2
function	of the atanh ||| rs atanh	count=1
function	wavelength ||| wavelength	count=1
class	the integral ||| integral	count=1
arg	in s2 deg_g ||| deg_g	count=1
arg	for f ||| f n	count=2
function	is ||| pretty try use	count=1
arg	[arg_1] a basis ||| [arg_1] [arg_2]	count=1
module	a sum that can ||| simplify	count=1
function	[function] a ||| [function]	count=12
function	part of [function_2] ||| [function_2] [function_1]	count=1
function	'/' separated [function_1] [function_2] (os ||| [function_2] [function_1] lst	count=3
function	a new copy of ||| copy	count=1
module	truth ||| functions elementary	count=2
module	of the [module] the indices ||| [module]	count=1
function	with respect [function] the ||| [function]	count=1
arg	f ||| f u	count=4
arg	actual infinitesimals of ||| infinitesimals func	count=2
arg	of two univariate ||| g	count=1
arg	if ||| symbol gens	count=1
module	the order of ||| physics quantum	count=1
class	with the proper ||| printer	count=1
arg	interval s t ||| s t	count=1
function	the given number of ||| indent	count=1
arg	= n ||| n	count=1
arg	operator in a basis ||| op basis	count=1
function	over ||| dmp ff	count=1
function_arg	scalar multiplication [arg_2] ||| [arg_2] [function_1]	count=2
function	by a ||| mul	count=1
function	stop ||| limits	count=1
arg	[arg_1] b the ||| [arg_2] [arg_1]	count=2
function	traditional rules of mathematics ||| traditional	count=1
class	the entries outside the ||| properties	count=1
function	terms ||| add terms	count=1
arg	normal_order look through each ||| recursive_limit _recursive_depth	count=1
function	differential ||| euler eq	count=2
arg	of the state corresponding [arg_1] [arg_2] ||| [arg_2] [arg_1]	count=5
function	convergents ||| convergents	count=1
class	determinant ||| determinant	count=2
function	bound on ||| bound	count=1
function	adjacency [function_2] ||| [function_2] [function_1]	count=2
function_arg	[function_1] to ||| [function_1] [arg_2]	count=13
function	tests whether [function] ||| [function] function class	count=1
arg	function to all terms ||| func	count=1
function	[function_1] matrix line ||| [function_2] [function_1]	count=4
function	normal form of ax^2 ||| normal	count=1
function	parse ||| parse order	count=2
function	real roots ||| dup count real roots	count=1
function_arg	[function_1] other ||| [function_1] [arg_2]	count=9
class	for julia ||| julia	count=1
class	gmpy's mpz to gmpy's ||| gmpyinteger ring	count=1
function	distinct real roots of ||| dup count real roots	count=1
function	rectangles of non-conjugate ||| refine complexes	count=1
function	of integers moved by ||| length	count=1
module_class	in the [class_2] ||| [module_1] mechanics symbolic [class_2]	count=1
class	currently at ||| symbol	count=1
function	and negative ||| cse	count=1
function	the cdf ||| cdf expression	count=2
class	generate ||| poly ring	count=1
function	to get the real ||| real	count=1
function	trigonometric ||| trig	count=1
function	[function_1] part of ||| [function_1] [function_2]	count=8
function	basic ||| basic	count=2
function	the domain of the ||| not	count=1
arg	polynomial at x_j ||| j	count=1
function	to the same expression ||| convert to	count=1
arg	objects and ||| objects merged_morphisms	count=1
class	to gmpy's mpz ||| gmpyinteger ring	count=2
class	entries outside the ||| properties	count=1
function	returns the loads in ||| loads	count=1
function	rewrites ||| eval rewrite	count=2
arg	fundamental strip given ||| x strip	count=1
function_arg	domain of [arg_2] ||| [function_1] [arg_2]	count=1
function	get ||| get index	count=2
function	gompertz ||| gompertz	count=1
function	finite_set in ||| not empty	count=1
function	finite_set in which ||| not	count=1
arg	of f s ||| f s x	count=2
module	total number ||| liealgebras	count=1
function_arg	expectation of [arg_2] ||| [arg_2] [function_1]	count=4
function	[function_1] randomization ||| [function_2] [function_1]	count=6
class	with the ||| code printer	count=1
function	basis for a ||| basis	count=1
function	always ||| only q annihilator	count=1
module	functions in finite_set in ||| calculus	count=1
arg	polynomial in [arg_2] ||| [arg_1] [arg_2]	count=5
function	[function_1] quadratic ||| [function_2] [function_1]	count=1
arg	func to every node ||| func	count=1
function_arg	leading coefficient [arg_2] ||| [arg_2] [function_1]	count=1
function	real roots ||| real roots	count=12
arg	n k ||| n k	count=2
function	a morse code with ||| morse	count=1
function	give the ||| dim	count=2
function	partition ||| partition	count=1
function	method returns ||| free	count=1
function	gets the bitlist corresponding ||| bitlist	count=1
function	as ||| doprint	count=1
function	the leading coeffcient ||| sdm lc	count=1
arg	gf_pow_mod f [arg_2] ||| [arg_2] [arg_1]	count=3
function	the class used to ||| class	count=1
function	integer ||| integer to term	count=1
function	[function_1] matrix ||| [function_2] [function_1]	count=8
function	rectum ||| rectum	count=1
arg	the ask system key ||| key	count=1
arg	is replaced ||| kwargs n	count=1
function	- [function_2] ||| [function_1] [function_2]	count=6
function	+ a where ||| add ground	count=3
function	files default from ||| get test files	count=1
function	two ||| product	count=1
function	[function_1] of operators ||| [function_1] [function_2]	count=1
module	specific ||| series	count=1
function	the underlying undirected ||| get undirected	count=1
function	of ||| create param	count=1
function	[function_1] and evaluate ||| [function_1] [function_2]	count=1
module	if possible ||| core	count=1
class	integration using any ||| integral	count=1
function	on a ||| call	count=1
function	identity ||| identity search	count=1
class	[class] which ||| [class]	count=1
module	take on ||| series	count=1
function_arg	from a [arg_2] ||| [arg_2] [function_1]	count=4
function_arg	return the [function_1] [arg_2] ||| diffgeom [function_1] [arg_2]	count=1
function_arg	[function_1] n examples ||| [arg_2] [function_1]	count=1
function	gate identity is ||| is	count=1
function_arg	[function_1] coords ||| [arg_2] [function_1]	count=1
arg	to an index ||| index	count=2
class	enumerate the partitions ||| partition traverser	count=1
function	presentation is to be ||| reidemeister presentation	count=1
function	variations ||| variations	count=1
function	radius ||| radius	count=1
function	representing a monomial ||| sdm monomial	count=1
function	to [function] between ||| set dict [function]	count=1
class	a positive exponent ||| base	count=1
function	coherent states of ||| coherent	count=1
function	common absolute value of ||| common	count=1
function	of syllables [function_2] ||| [function_2] [function_1]	count=6
function	it ||| try use	count=1
arg	a scalar field computed ||| scalar vect	count=1
class	that [class_2] ||| [class_2] [class_1]	count=3
function_arg	[function_1] gen ||| [arg_2] [function_1]	count=1
module_class	[module_1] point with ||| [module_1] [class_2]	count=8
module_class	[module_1] or product ||| [module_1] [class_2]	count=2
function	unify a multivariate fraction ||| unify	count=1
function	in finite_set in ||| empty in	count=1
function_arg	[function_1] numbers v ||| [arg_2] [function_1]	count=9
arg	c[n]*p**n modulo o(x**prec) ||| c x prec	count=1
module	if the ||| physics units	count=1
arg	of fpgroup h ||| h	count=1
function	hermite reduction ||| hermite reduce	count=1
function	the inverse ~a ||| af invert	count=1
function	quotient by ||| dmp quo	count=1
function	using ||| solve	count=1
function	polynomial [function] ||| [function] sqf list	count=1
class	or containers of ||| poly ring	count=1
arg	nested ||| nested	count=1
arg	[arg_1] order o ||| [arg_2] [arg_1]	count=5
arg	phrase is ||| phrase	count=1
function	[function_1] threaded ||| [function_2] [function_1]	count=4
function_arg	force to [arg_2] ||| [arg_2] [function_1]	count=5
class	value (i ||| series	count=1
class	wrappers this file contains ||| wrapper	count=2
function	true if the right ||| right	count=1
class	accumulationbounds object is less ||| accumulation bounds	count=1
function	returns a list ||| list	count=5
function	rational function ||| fraction	count=2
function	method converts ||| letter form to	count=1
arg	subtract [arg] ||| [arg]	count=3
function	parallel ||| parallel	count=1
arg	[arg_1] and b, ||| [arg_2] [arg_1]	count=34
arg	information required for constructing ||| grid morphisms_str_info	count=1
function	limits ||| limits	count=2
function_arg	zeros square [arg_2] ||| [function_1] [arg_2]	count=4
function	positive roots ||| positive roots	count=2
function	mellin transform of ||| mellin transform	count=2
function	mass ||| mass	count=1
arg	f and ||| a d	count=1
function	reduce a [function_2] ||| [function_2] [function_1]	count=2
arg	condition on input ||| condition message	count=2
function	allow derivatives wrt ||| diff wrt	count=1
function	above [function_2] ||| [function_1] [function_2]	count=4
function	[function_1] beta ||| [function_1] [function_2]	count=1
class	a sympy sets set ||| geometry set	count=1
function_arg	ode [arg_2] ||| [function_1] [arg_2]	count=1
function	is [function_2] ||| [function_1] [function_2]	count=91
class	faces of the ||| polyhedron	count=1
arg	and ||| exprs order	count=1
function	lmq lower bound for ||| lower bound	count=1
function	norm of the ||| norm	count=1
arg	p with respect to ||| p	count=3
class	kb with ||| kb	count=1
arg	[arg_1] transformation used ||| [arg_2] [arg_1]	count=2
function	finds the domain ||| empty in	count=1
arg	order of orig_vec ||| orig_vec	count=1
function_arg	[function_1] [arg_2] ||| find [function_1] symbol [arg_2]	count=1
arg	prints the expression ||| expr	count=1
function	value ||| free	count=1
module	return self raised to ||| core	count=1
arg	using vincent-akritas-strzebonski vas ||| f k eps	count=1
arg	convert f into ||| f	count=1
arg	j ||| j f	count=2
module	the get_unit ||| physics units	count=1
function	[function_1] the whole ||| [function_1] [function_2]	count=1
module_class	for [module_1] [class_2] ||| [module_1] [class_2]	count=2
function	[function_1] fraction ||| [function_2] [function_1]	count=12
module	< p[i+1] ||| combinatorics	count=1
arg	denests a list ||| av0 h max_depth_level	count=1
function	transform of f, ||| transform	count=3
function_arg	[function_1] multiplicities ||| [function_1] [arg_2]	count=1
function	sorting key such ||| sort key	count=2
function_arg	[function_1] x_j at ||| [arg_2] [function_1]	count=2
arg	\eta to ||| match comp	count=1
arg	[arg_1] in ||| eval [arg_1] p [arg_2]	count=1
arg	[arg_1] and k1 ||| [arg_1] [arg_2]	count=4
function_arg	[function_1] in ||| [arg_2] [function_1]	count=49
function	of square-free [function_2] ||| [function_1] list [function_2]	count=2
arg	[arg_1] [inf sup] ||| [arg_2] [arg_1]	count=3
arg	y z of the ||| y z	count=1
class	using any hints given ||| integral	count=1
class	the total number ||| type	count=1
function_arg	series expansion [arg_2] ||| [function_1] [arg_2]	count=3
arg	base and ||| base	count=3
arg	and the ||| grid	count=1
function	the trigamma function is ||| trigamma	count=1
arg	lhs - [arg_2] ||| [arg_2] [arg_1]	count=4
function_arg	- g*h [arg_2] ||| [function_1] [arg_2]	count=7
function	conditions applied ||| conditions	count=1
function	[function_1] a polynomial ||| [function_1] [function_2]	count=1
arg	[arg_1] in z_p ||| [arg_1] [arg_2]	count=1
class	using any hints ||| integral	count=1
function	a power series ||| power series	count=1
arg	muls ||| order	count=1
function	compositeness test returns ||| prp	count=1
arg	[arg_1] x for ||| [arg_1] [arg_2]	count=1
function	gegenbauer [function_2] ||| [function_2] [function_1]	count=1
function	to compute the hash ||| hashable content	count=1
module_class	the [class_2] ||| [module_1] units dimension [class_2]	count=3
arg	of the given ||| f	count=1
function	as a [function_2] ||| [function_1] [function_2]	count=2
class	[class] which passes ||| [class]	count=1
function	upper ||| root upper	count=1
class	that are generated ||| differential	count=1
function	return [function_1] [function_2] given interval ||| [function_1] [function_2]	count=1
function	[function_1] decreasing in ||| [function_1] [function_2]	count=9
arg	p2 in the coefficient ||| p2	count=1
function	trial ||| dup trial	count=1
arg	and format ||| format	count=1
arg	[arg_1] is suitable ||| [arg_1] [arg_2]	count=3
function	[function_1] positive root ||| [function_1] [function_2]	count=2
arg	n items ||| n	count=3
arg	in a rational ||| f	count=1
function	function to each element ||| applyfunc	count=2
function	random integer [function_2] ||| [function_2] [function_1]	count=3
function	det ||| det	count=1
function_arg	[function_1] [arg_2] ||| [function_1] add [arg_2]	count=2
function_arg	exact pseudo-quotient [arg_2] ||| [arg_2] [function_1]	count=2
arg	of t are ||| t	count=1
arg	that is suitable ||| iszerofunc simpfunc	count=1
arg	[arg_1] ex2 parameters ||| [arg_1] [arg_2]	count=2
arg	function target [arg_2] ||| [arg_1] [arg_2]	count=1
function	the expr cond ||| expr cond	count=1
function	their coefficient ||| coefficients dict	count=1
class	line ending ||| printer	count=1
function	print output of python() ||| print python	count=1
function	of mpf [function_2] ||| [function_2] [function_1]	count=2
function	an apply ||| apply operator int	count=2
function	asin of p, about ||| rs asin	count=1
arg	a continuous ||| mu k	count=1
function_arg	[function_1] [arg_2] ||| [function_1] add f g [arg_2]	count=2
class	returns ||| series base	count=2
arg	f to all expressions ||| f atoms	count=1
function	[function] '/' separated ||| [function] native	count=1
class	this frame in terms ||| reference frame	count=1
module_class	[module_1] parabola ||| [module_1] [class_2] intersection o	count=1
function	set from generators of ||| gens from	count=1
function	thus the only possible ||| singleton	count=1
function	- ||| sub	count=4
arg	x and y are ||| x y	count=1
function	homogeneous [function_2] ||| [function_2] [function_1]	count=6
module	string path to the ||| utilities	count=1
function_arg	[function_1] c ||| [function_1] scalar [arg_2]	count=1
function_arg	and cofactors [arg_2] ||| [function_1] gcd [arg_2]	count=5
function	an sdm [function_2] ||| [function_1] [function_2]	count=3
arg	of the condition ||| cond	count=1
arg	n data points ||| n	count=1
function	the number of real ||| real	count=1
arg	sympy expression expressions are ||| expr callback_type	count=1
arg	if n ||| n candidates	count=1
arg	targets [arg_2] ||| [arg_1] [arg_2]	count=1
function	function is monotonic in ||| is monotonic	count=1
arg	of terms of f ||| f m n k	count=1
class	specific value ||| base	count=1
arg	polynomial at x_0 ||| u k	count=1
function	[function_1] central ||| [function_1] [function_2]	count=3
function	another fraction field ||| fraction field	count=1
class	a partition ||| partition	count=1
arg	z ||| z	count=4
arg	monic gcd of two ||| g	count=1
function	is in the ||| is	count=2
function	rectangle is small enough ||| rectangle small p	count=1
function_arg	to power [arg_2] ||| [arg_2] [function_1]	count=2
function	[function_1] coefficient ||| [function_2] [function_1]	count=4
arg	condition [arg] given ||| condition [arg]	count=1
function	[function_1] cart ||| [function_2] [function_1]	count=5
function	of equivalent ||| equivalent	count=1
arg	[arg_1] divides p ||| [arg_1] [arg_2]	count=1
function	unify representations ||| unify	count=2
arg	if modulus ||| modulus	count=1
function_arg	posform [arg_2] ||| [function_1] [arg_2]	count=1
function	hilbert [function] of the ||| [function]	count=1
class	the total number of ||| type	count=1
arg	or product expression ||| expr x	count=1
function	and return the ||| indent	count=1
function	returns a copy of ||| structure copy	count=1
arg	of general form ||| x y t	count=1
class	a ||| ring	count=5
arg	performs ||| matlist k	count=1
arg	l1 ||| l1	count=1
function_arg	generates the [function_1] [arg_2] as a permutation group ||| [function_1] [arg_2]	count=1
function_arg	input [arg_2] ||| polys modified subresultants [function_1] [arg_2]	count=4
function_arg	and evaluate [arg_2] ||| [function_1] f m a [arg_2]	count=1
function_arg	symbol in [arg_2] ||| [function_1] [arg_2]	count=2
function	the bitlist corresponding to ||| bitlist from	count=1
function	hankel transform of ||| hankel transform	count=2
function	pohlig-hellman algorithm for computing ||| pohlig hellman	count=1
function	coefficient ||| opt	count=1
function	polynomial lcm over a ||| ff lcm	count=1
function	dot ||| and	count=1
function	real roots [function_2] ||| [function_2] [function_1]	count=3
function	with constant coefficients ||| constant	count=1
function	the scalar potential function ||| scalar potential	count=2
function	[function_1] log ||| [function_1] [function_2]	count=1
function	create an sdm from ||| sdm from	count=1
function	rational number ||| rational	count=1
module	[module] to ||| [module]	count=4
arg	ex ||| ex	count=1
function	the transformation matrix ||| transformation to	count=1
function	the event loop ||| event loop	count=2
function_arg	dense [arg_2] ||| [arg_2] [function_1]	count=6
arg	of ||| func	count=1
function	return ||| cond	count=1
function_arg	rank of g ||| rank g	count=2
arg	k ||| k d	count=1
class	a matrix ||| matrix	count=1
arg	p g p ||| g b p	count=1
arg	triangles could be ||| triangles fringe	count=2
function_arg	row [arg_2] ||| [arg_2] [function_1]	count=4
function	[function] of ||| second [function]	count=1
function	divisors ||| divisors	count=1
function	of self [function] ||| [function] scalar	count=1
class	(i ||| base	count=1
arg	token same effect as ||| token	count=1
arg	[arg_1] [x]/ ||| [arg_2] [arg_1]	count=1
class	from [class] ||| [class]	count=2
arg	true if a ||| a p	count=1
arg	and for ||| a d	count=1
arg	f p ||| f p	count=2
arg	sop [arg] pos ||| [arg] form	count=1
function	is iterable or ||| is iterable	count=2
function	modularinteger ||| ff	count=6
function	field [function_2] ||| [function_2] [function_1]	count=6
function	collins's resultant algorithm ||| collins	count=1
arg	model or ||| expr model deep	count=1
function	previous gray code ordered ||| prev gray	count=1
function	register ||| register	count=1
class	total number ||| g	count=1
function	to whether ||| from indices	count=1
class	body ||| body	count=3
class	linear entity which ||| linear entity	count=2
function	class into a string ||| get	count=1
function_arg	[function_1] [arg_2] ||| [function_1] field coord_sys [arg_2]	count=15
class	a polynomial [class_2] ||| [class_2] [class_1]	count=2
class	return the ||| base	count=1
function	dmf object to ||| fraction	count=1
module_class	quotient of fractions ||| polys frac element	count=1
function	the laplace ||| laplace	count=1
function	returns a list of ||| list include	count=2
function	[function_1] consistent ||| [function_1] [function_2]	count=1
function	in-place operation on col ||| col op	count=2
arg	suitability ||| t ct	count=1
arg	all ||| f	count=1
arg	x or ||| x	count=1
function_arg	degrees of f ||| degree list f	count=2
arg	[x] polynomial ||| k	count=2
module	to perform [module_2] ||| [module_2] [module_1]	count=1
arg	[arg_1] first order ||| [arg_1] func [arg_2]	count=1
arg	indicating whether i ||| i	count=1
function	factors ||| factor	count=1
arg	second order ||| eq func order match	count=1
arg	true if expr is ||| expr assumptions	count=1
class	[class_1] entity ||| [class_1] [class_2] perpendicular line	count=1
arg	namespace dict ||| namespace	count=1
function	absolute value of a, ||| abs	count=1
function	function to correct the ||| correct	count=1
function_arg	whether e ||| is expr e	count=1
function	start of sequences in ||| prefix	count=1
function	the series expansion ||| rs	count=1
arg	random expression ||| expr	count=1
arg	index1 row ||| matlist index1	count=1
function	other, ||| ge	count=1
module	by default on the ||| physics mechanics	count=1
arg	~ that [arg] ||| [arg]	count=1
class	proper ||| code	count=1
arg	h ||| h base	count=1
function_arg	functional decomposition [arg_2] ||| [arg_2] [function_1]	count=2
arg	expression and [arg_2] ||| [arg_2] [arg_1]	count=1
class	no bounding rectangles of ||| root	count=1
arg	[arg_1] a diagram ||| [arg_2] [arg_1]	count=5
module	the truth value of ||| elementary	count=1
function_arg	polynomial for [arg_2] ||| [function_1] [arg_2]	count=3
function	using the telescopic property ||| telescopic	count=1
function	in integer [function_2] ||| [function_2] [function_1]	count=1
function	ratio ||| ratio	count=2
class	known [class] 'rotation matrix' ||| coord [class]	count=1
function	mapping operator classes to ||| to	count=1
function_arg	[function_1] p [x] ||| [function_1] rem f [arg_2]	count=2
function	number ||| number	count=2
arg	function for ||| func	count=2
function	[function_1] polynomial of ||| [function_2] [function_1]	count=4
function	arranged in [function_2] ||| [function_2] [function_1]	count=1
function	of scan routine used ||| scan	count=1
function	is puiseux [function_2] ||| [function_2] [function_1]	count=2
class	or containers of ||| poly	count=1
function	maximum of a ||| imax	count=1
module	the form x start ||| series	count=1
class	a specific value (i ||| series	count=1
function	rationalize num/den by removing ||| rad rationalize	count=1
arg	expression about c i ||| c condition	count=1
function	the coset ||| coset	count=1
function	centralizer of a ||| centralizer	count=1
class	a list ||| frac	count=1
class	method to ||| method	count=3
arg	which [arg] the divisors ||| [arg]	count=1
function	to a raw ||| to raw	count=3
function	the index of ||| index	count=1
function	form base [function_2] ||| [function_1] [function_2]	count=1
function	for :func _dup_decompose ||| dup right decompose	count=1
module	_normal_order_factor to perform ||| quantum	count=1
class	we can ||| polyhedron	count=1
module	entity or infinity ||| geometry	count=1
function	lie group method of ||| ode lie group	count=1
arg	root v ||| v	count=1
class	the interval ||| interval	count=1
function_arg	[function_1] p ||| [function_1] sqf part [arg_2]	count=3
module	matrix containing the ||| physics mechanics	count=2
function_arg	minimal [arg_2] ||| [arg_2] [function_1]	count=1
function	trace ||| trace	count=4
module_class	[module_1] [class_2] ||| [module_1] units dimension [class_2]	count=7
function	* [function_2] ||| [function_2] [function_1]	count=1
arg	use a lexical closure ||| name latexname	count=1
function	type immutabledensematrix ||| as explicit	count=1
function	the cosh ||| cosh	count=1
arg	first if directed ||| seq directed	count=1
function_arg	helper [arg_2] ||| [arg_2] [function_1]	count=4
function_arg	into irreducibles in ||| list include f	count=2
module	string with mathml ||| mathml	count=1
function	name ||| get	count=1
arg	to ||| s	count=1
arg	truth value of the ||| cls	count=1
arg	qubit labels from ||| target labels	count=1
function	integer ||| int	count=1
module_class	[module_1] ket ||| [module_1] [class_2]	count=2
function	lexicographic rank ||| rank	count=1
function	refractive index ||| refractive index	count=2
function	[function] indices ||| get [function]	count=3
function	structure [function] *dummy* ||| [function] contraction	count=1
function	evaluate a polynomial in ||| eval in	count=1
class	printer for ||| py printer	count=1
module	in ||| agca	count=1
arg	list of ||| x	count=1
class	index pos ||| index	count=1
function_arg	gf [arg_2] ||| [function_1] rem f [arg_2]	count=2
function_arg	generates the [function_1] [arg_2] permutation group ||| combinatorics [function_1] group [arg_2]	count=1
arg	user in the ||| weylelt	count=2
arg	f and for each ||| a	count=1
module	sequence of ||| polys	count=1
arg	or the matching_symbol if ||| matching_symbol	count=1
arg	i j k ||| i j k	count=1
arg	dum [arg_2] ||| [arg_2] free [arg_1]	count=1
function	values below fermi? >>> ||| only below fermi	count=1
function	[function_1] series for ||| [function_2] [function_1]	count=13
class	return ||| of	count=1
function	unicode output is ||| pretty try use unicode	count=1
class	for the [class_2] ||| [class_2] [class_1]	count=2
class	transform ||| transform	count=2
function	returns speed of ||| speed	count=1
function	the direction ratio ||| direction ratio	count=4
arg	the universe ||| universe	count=1
function_arg	graph [arg_2] ||| [function_1] certificate [arg_2]	count=3
function	differentiate and evaluate a ||| dmp diff eval in	count=1
module_class	return [module_1] [class_2] ||| [module_1] quantum [class_2] operators	count=1
function	construct polynomials from ||| from	count=1
class	p[i] ||| permutation	count=2
function	modulo a prime ||| zz modular	count=1
function	give a useful signature ||| signature	count=1
function	[function_1] syllables ||| [function_1] [function_2]	count=3
function	the primitive form of ||| dmp ground primitive	count=1
function	of x**q = ||| nthroot mod1	count=1
arg	index2 ||| index2	count=1
function	lmq lower bound ||| dup root lower bound	count=1
arg	find optimization opportunities ||| order	count=1
module	returns a vector ||| vector	count=1
class	self ||| differential extension	count=1
function	[function_1] negative ||| [function_2] [function_1]	count=1
function_arg	this function simplifies [function_1] [arg_2] ||| [function_1] [arg_2]	count=1
arg	of e [arg_2] ||| [arg_2] [arg_1]	count=7
function	the leading coefficient ||| lc	count=1
class	of polynomial ||| frac field	count=1
arg	disjoint ||| complexes	count=1
arg	for ||| method	count=1
arg	for ||| expr	count=7
arg	stringpict and binding power ||| binding unicode	count=1
function	path to a ||| func	count=1
function	key ||| key	count=8
class	ordering of associative ||| free group element	count=1
arg	a polynomial in k[x] ||| m u k	count=1
module	into lists [module] which ||| [module]	count=1
function_arg	power or [arg_2] ||| [function_1] [arg_2]	count=2
function	rank of a ||| rank	count=3
function_arg	push a [arg_2] ||| [arg_2] [function_1]	count=8
arg	or an exponential ||| expr	count=1
arg	of this type of ||| x y t	count=3
function	pseudo-quotient ||| pquo	count=1
module	returns a standard ||| polys	count=1
function	make a [function_2] ||| [function_1] [function_2]	count=3
module	the clebsch-gordan coefficient ||| physics	count=1
function	[function_1] generators in ||| [function_1] [function_2]	count=1
function	spaces ||| spaces	count=1
function	convert ||| from	count=4
arg	-> objects mapping ||| objects	count=1
module	simplification ||| simplify	count=1
arg	the divergence ||| vect doit	count=1
arg	= [arg] the ||| d [arg]	count=1
module	a [module] expectation of ||| [module]	count=1
function	to the beginning ||| indent	count=1
function	two ||| two	count=1
arg	rs\_sin p x prec ||| p x prec	count=1
arg	s, and return ||| s	count=1
function	s, and return the ||| indent	count=1
arg	ground ||| f	count=1
arg	and for each ||| a d	count=1
function	compute the inverse ||| inverse	count=3
arg	identifier ||| identifier	count=1
function	list of irreducible factors ||| factor list	count=3
function	to [function_2] ||| [function_2] [function_1]	count=16
arg	for details ||| re	count=1
function_arg	resultant [arg_2] ||| [function_1] f [arg_2]	count=1
function	the method of undetermined ||| coeff undetermined	count=1
function	[function] function func ||| [function]	count=3
function	_solve ||| tsolve	count=1
module	name ||| utilities	count=1
function	[function_1] [function_2] ||| [function_1] constant coeff [function_2]	count=1
class	[class] is called ||| [class]	count=1
arg	order ||| eq func order match	count=6
function	root [function] directory ||| [function]	count=1
arg	and g [arg_2] ||| [arg_1] [arg_2]	count=2
arg	for constructing ||| morphisms_str_info	count=1
function	coefficients ||| coeffs	count=1
arg	p is not one ||| p	count=1
function	minimal polynomial for ||| minpoly op algebraic	count=1
arg	expansion ||| a prec	count=1
function	integer ||| modular integer	count=1
arg	disjoint and sort ||| cls complexes	count=1
function_arg	[function_1] [arg_2] ||| [function_1] eq func order [arg_2]	count=6
arg	rectangles of non-conjugate ||| cls	count=1
class	triangle ||| triangle	count=6
arg	binding power ||| binding	count=1
function	matrix is [function] matrix that ||| is [function]	count=1
class	morphism ||| morphism	count=2
class	a cython ||| cython	count=1
function_arg	[function_1] an exponential ||| [function_1] [arg_2]	count=4
function_arg	[function_1] [arg_2] ||| [function_1] puiseux2 [arg_2]	count=10
function	handling functions ||| function	count=1
class	the object excluding those ||| series	count=1
arg	square-free polynomial f in ||| f	count=2
function	fraction ||| qq	count=7
function	indefinite integral of ||| dmp integrate	count=2
arg	with length l ||| l d2	count=1
function_arg	[function_1] a field ||| [function_1] [arg_2]	count=8
function	a ||| call	count=1
arg	[arg_1] the components ||| [arg_2] [arg_1]	count=4
arg	exponents ||| force	count=1
function	to a class ||| get mod	count=1
module_class	[module_1] other point ||| [module_1] vector [class_2]	count=1
arg	following -- a ||| density set	count=1
arg	equation eq by converting ||| eq param	count=1
class	[class] words ||| [class]	count=3
arg	rule ||| rule fns	count=2
function	mapping of symbolic values ||| create	count=1
function	try [function] transformation x ||| [function] rational	count=1
arg	[arg_1] l ||| [arg_2] [arg_1]	count=2
arg	f in x_j ||| f	count=1
function	the coefficient ||| as coeff add	count=3
module	be of the form ||| series	count=1
function	[function_1] semicircle distribution ||| [function_2] [function_1]	count=2
function	the intersection of ||| intersection	count=2
class	the ||| matrix	count=3
function	calculates the delta ||| delta	count=1
arg	of f ||| f u k	count=1
function	in finite_set in which ||| empty	count=1
class	the generated files ||| octave code	count=1
function	[function] function ||| [function]	count=3
function	[function_1] not zero ||| [function_2] [function_1]	count=1
module	the equations of motion ||| physics mechanics	count=3
function	as [function] ||| find unit [function] int	count=3
function_arg	[function_1] of expr ||| [arg_2] [function_1]	count=3
arg	to two labeled polynomials ||| g ring	count=1
function_arg	[function_1] [arg_2] ||| [function_1] pow mod f [arg_2]	count=2
function	functions in finite_set ||| not empty in	count=1
function	the selfridge ||| lucas selfridge	count=1
function	the form of singularity ||| as singularity	count=1
function	a piecewise [function_2] ||| [function_2] [function_1]	count=4
function	instance of the linearizer ||| linearizer	count=1
function_arg	part [arg_2] ||| [function_1] [arg_2]	count=7
function	generating [function_2] ||| [function_1] [function_2]	count=6
function	[function_1] root ||| [function_2] isolate [function_1]	count=1
function	format an error ||| count error	count=1
function	gauss jordan elimination ||| gauss jordan	count=1
function	free module of ||| free module	count=1
function	the symbols that ||| symbols	count=2
function	converts a list given ||| form to	count=1
class	containers of ||| poly	count=1
function	a subgroup whose presentation ||| presentation	count=1
function	domain where a ||| where	count=1
arg	limits should be of ||| limits	count=1
arg	[arg_1] x the ||| [arg_1] [arg_2]	count=1
arg	n in ||| n a	count=2
module	be defined ||| core	count=1
arg	that no bounding ||| cls	count=1
arg	rule down a ||| rule	count=1
function_arg	[function_1] an expression ||| [function_1] [arg_2]	count=1
function	string path to ||| mod	count=2
module_class	returns a fraction ||| polys domains fraction	count=2
arg	in phrase is not ||| phrase	count=1
arg	system of ||| x y	count=1
class	we ||| polyhedron	count=1
function	this catagory ||| 2eq order2 type8	count=1
module_class	underlying dimension system ||| units unit system	count=1
arg	side of length l1 ||| l1	count=1
function	[function] belonging ||| [function]	count=2
function	extended euclidean algorithm of ||| gcdex	count=2
arg	points in ||| func points	count=1
class	a standard basis in ||| poly ring	count=1
arg	the following -- ||| density set	count=1
module	returns <n|alpha> for the ||| physics	count=1
function_arg	first derivative [arg_2] ||| [arg_2] [function_1]	count=1
module	matrix ||| matrices	count=28
function	compute the hilbert space ||| eval hilbert space	count=1
function	weak normal form ||| sdm nf mora	count=1
function_arg	[function_1] [arg_2] ||| [function_1] matrix [arg_2] format	count=3
arg	of every non-blank line ||| indent	count=1
arg	the root if ||| root radicals	count=1
function	what counter is currently ||| counter	count=1
function_arg	table [arg_2] ||| [arg_2] [function_1]	count=1
function	a k[x] ||| dup	count=2
function_arg	laplace transform [arg_2] ||| [function_1] [arg_2]	count=5
function	module and the name ||| get mod	count=1
arg	[arg_1] \; j_2 ||| [arg_2] [arg_1]	count=1
function_arg	[function_1] point center ||| [arg_2] [function_1]	count=4
arg	defined ||| k r nu	count=1
function	the symbols that will ||| symbols	count=1
function	writes a common header ||| header	count=2
arg	of an expression selected ||| expr func args	count=2
function_arg	of coefficients [arg_2] ||| [arg_2] [function_1]	count=3
function	the iterable ||| iterable	count=1
arg	find ||| exprs	count=1
function	and negative coefficient ||| opt	count=1
class	a set ||| set	count=4
arg	[arg_1] are in ||| [arg_1] [arg_2]	count=1
class	for the generated ||| octave code gen	count=1
function	square the ||| rs square	count=1
module	0 and ||| solvers	count=1
function	type of ode are ||| linear 2eq order1 type6	count=1
function_arg	nth root [arg_2] ||| [arg_2] [function_1]	count=2
function_arg	force to [arg_2] ||| [function_1] vec [arg_2]	count=1
function	returns the ||| free	count=1
module_class	matrices along self's ||| matrices matrix shaping	count=2
class	a complex ||| complex	count=1
function	the hilbert [function] of ||| [function]	count=1
arg	b ||| b x	count=1
arg	attrs ||| attrs	count=1
arg	simplifies ||| measure fu	count=1
function	fermi ||| fermi	count=3
function	lagrange's [function_2] ||| [function_1] [function_2]	count=3
arg	base b [arg_2] ||| [arg_2] a [arg_1]	count=3
function	set ||| set	count=9
function	the ground domain ||| ground	count=4
function	orbits relative to ||| orbits	count=1
function	of the class ||| func	count=1
function	routine creation for ||| routine	count=2
arg	b, ||| b	count=2
function	returns all monomials from ||| all monoms	count=1
function	dict ||| dict	count=10
function	triangles ||| list triangles	count=1
arg	group/set/element inside another ||| arg centr	count=1
function	available and ||| try use	count=1
class	group for a ||| group	count=1
function	multiply ||| mul ground	count=1
module	the ||| series	count=3
function	momentum of a system ||| momentum	count=1
function	contribution ||| laurent series	count=1
arg	separation ||| fun sep strategy	count=1
function	return square-free [function_2] ||| [function_1] [function_2]	count=3
function	returns true/false if ||| is	count=1
arg	[arg] creates a ||| [arg]	count=1
function	the form x start ||| process limits	count=1
function	of symbolic values ||| param	count=1
function_arg	[function_1] [arg_2] ||| [function_1] s baseline binding [arg_2]	count=1
class	new code ||| code	count=1
arg	[arg_1] join ||| [arg_1] [arg_2]	count=1
function_arg	[function_1] element to ||| [arg_2] [function_1]	count=1
arg	as a ||| a	count=2
arg	f g [arg_2] ||| [arg_2] [arg_1]	count=6
function	[function_1] components ||| [function_1] [function_2]	count=2
function_arg	n-th coefficient [arg_2] ||| [function_1] [arg_2]	count=6
module	matrix sum of ||| matrices expressions	count=1
arg	transform of ||| x helper	count=1
function_arg	sopform [arg_2] ||| [function_1] [arg_2]	count=1
module	on a ||| series	count=1
function_arg	directional derivative [arg_2] ||| [function_1] [arg_2]	count=4
function	run a ||| run in	count=1
function	expansion of the atanh ||| atanh	count=1
function	the largest subset ||| pairwise most common	count=1
arg	function for functions ||| expression predicate interval	count=1
function	simple [function_2] ||| [function_1] [function_2]	count=3
arg	solves a ||| eq	count=1
function_arg	convert [arg_2] ||| [function_1] [arg_2]	count=4
function	and recursively strip it ||| validate	count=1
arg	h a subgroup ||| fp_grp h	count=1
function	the opening statements of ||| opening	count=2
function_arg	row [arg_2] ||| [function_1] op [arg_2]	count=4
class	of self ||| matrix base	count=1
function	orbits relative to a ||| orbits	count=1
function	returns exact polynomial quotient ||| quo	count=1
function	the symbols ||| free symbols	count=1
module	calculate the ||| physics	count=5
arg	to n ||| n	count=5
function	differentiate [function_2] ||| [function_2] [function_1]	count=3
arg	value of n and ||| factors n	count=1
arg	in col [arg_2] ||| [arg_1] [arg_2]	count=2
arg	[arg_1] t = ||| [arg_2] [arg_1]	count=1
arg	for two univariate ||| g p	count=1
function	sympy's integer ||| sympy	count=1
arg	to create annihilators using ||| generator	count=1
function	a polynomial [function] ||| [function]	count=2
class	for the ||| code	count=1
function_arg	the triangle [arg_2] ||| [function_1] [arg_2]	count=6
module	polynomial modulo a ||| polys	count=1
function	the degree of the ||| degree	count=1
function	list of square-free factors ||| sqf list	count=1
arg	a symbol ||| symbol	count=1
function	the bending moment ||| bending moment	count=2
function_arg	negate [arg_2] ||| [function_1] [arg_2]	count=2
class	binomial ||| binomial	count=1
class	writes a ||| fcode gen	count=1
function	assumed ||| modified subresultants pg	count=1
function	degree of the poly ||| find degree	count=1
function	[function_1] rectum ||| [function_1] [function_2]	count=3
function	the lie ||| ode lie	count=1
function	the series ||| intcurve series	count=1
function	ode from ||| ode 1st homogeneous coeff	count=1
arg	of orig_vec [arg_2] ||| [arg_1] [arg_2]	count=1
module	get ||| combinatorics	count=1
arg	b m + ||| b a b	count=1
function	the event [function_2] ||| [function_2] [function_1]	count=1
module	new tensor indices to ||| tensor	count=1
arg	[arg] is ||| s2 r [arg]	count=3
arg	= lhs - rhs ||| lhs rhs	count=1
module	of subsset ||| series	count=1
function	[function_1] roots of ||| [function_1] [function_2]	count=14
class	[class_1] block with ||| [class_1] [class_2]	count=4
arg	[arg_1] defined ||| [arg_2] [arg_1]	count=2
function	of partial ||| partial	count=1
function	sin ||| minpoly sin	count=1
arg	[arg_1] selected ||| [arg_1] [arg_2]	count=5
arg	p of k[t ||| p t z	count=1
module	self with oth, that ||| agca	count=1
function_arg	return [function_1] [arg_2] ||| [function_1] [arg_2]	count=2
function	for _solve ||| tsolve	count=1
function	of the nth root ||| nth root1	count=1
function	convert the ground domain ||| dmp convert	count=1
function	in finite_set in which ||| in	count=1
function	[function_1] expression in ||| [function_2] [function_1]	count=2
function	into [function] form ||| linear eq to [function]	count=1
function	to a function ||| function	count=1
arg	in p with ||| p	count=1
function	is linear ||| is linear	count=2
function	two simple roots together ||| simple roots	count=1
class	whose ||| partition	count=1
function_arg	[function_1] rv ||| [arg_2] [function_1]	count=2
function	the precedence ||| precedence	count=1
function_arg	extended gcd [arg_2] ||| [function_1] [arg_2]	count=10
function	literal else false ||| literal	count=1
class	form ||| kanes method	count=2
arg	of levels in f ||| f k	count=1
arg	[arg_1] b modulo ||| [arg_2] [arg_1]	count=3
class	or containers of ||| ring	count=1
arg	a ||| series_rs a	count=1
function	the horner scheme ||| dmp eval	count=2
function	with sorted [function_2] ||| [function_2] [function_1]	count=4
function	pairs of ||| pairs	count=1
function	to a string [function_1] [function_2] ||| [function_1] [function_2]	count=1
function	optimization ||| opt cse	count=2
function	bra on the right ||| bra	count=1
function	with the euclidean ||| euclidean	count=1
function	form ||| process limits	count=2
function	helper function of pdsolve ||| helper	count=1
arg	namespace ||| namespace	count=1
class	generated ||| fcode gen	count=2
arg	b m ||| a b	count=1
function_arg	returns [arg_2] ||| [function_1] [arg_2]	count=5
function_arg	symmetric polynomial [arg_2] ||| [function_1] [arg_2]	count=1
arg	optionally ||| evaluate numsamples	count=1
function_arg	to [arg_2] ||| [function_1] force [arg_2]	count=4
module	the line and ||| physics quantum	count=1
function	a copy of the ||| copy	count=1
class	that ||| differential extension	count=2
arg	cipher [arg_2] ||| [arg_1] [arg_2]	count=1
function	leading degree of ||| degree	count=1
arg	expression and ||| expr	count=1
arg	characters of symbols with ||| symbols filter	count=1
function	from a [function_2] ||| [function_1] [function_2]	count=6
arg	in old with ||| old	count=1
arg	form if a < ||| cls a	count=1
class	an expression ||| expr	count=1
function	n-th coefficient of ||| dmp nth	count=1
function	the supremum ||| sup	count=1
function	is quadratic in ||| is quadratic	count=2
function_arg	the ideal [arg_2] ||| [arg_2] [function_1]	count=2
arg	differential ||| match	count=2
function	to the module ||| func	count=1
function	tensor product of ||| combined tensor printing	count=1
function	a raw ||| raw	count=1
function	finite rotation ||| orient	count=1
arg	expansion of ||| n x prec	count=1
arg	from sympy import lex ||| v order	count=1
module	the given operator ||| physics	count=2
arg	[arg_1] and the ||| [arg_1] [arg_2]	count=2
arg	target ||| target	count=2
arg	q are polynomials in ||| q	count=5
function	return the nth moment ||| moment	count=1
class	the polygon and values ||| polygon	count=1
arg	from the user in ||| weylelt	count=1
function	of mpf ||| mpf	count=1
arg	condition [arg_2] ||| [arg_2] [arg_1]	count=1
function	to an ode is ||| ode	count=1
function	of singularity ||| singularity	count=1
arg	a base and strong ||| group base gens	count=1
class	formats ||| code	count=1
function_arg	[function_1] to x ||| [function_1] [arg_2]	count=1
class	a string of stringpicts ||| string pict	count=1
function_arg	replace [arg_2] ||| [function_1] [arg_2]	count=1
arg	return a polynomial in ||| f p u	count=1
function	return the minimal polynomial ||| minpoly	count=1
function	this heuristic ||| lie heuristic function	count=1
function_arg	[function_1] f ||| [function_1] mul term [arg_2]	count=2
arg	for common subexpression elimination ||| optimizations	count=1
function	[function_1] of native ||| [function_2] [function_1]	count=1
function	[function_1] [function_2] ||| [function_1] indices [function_2]	count=1
class	returns ||| poly ring	count=2
module	up the ||| physics	count=1
function	[function_1] a primary ||| [function_2] [function_1]	count=1
function	compute square-free part of ||| sqf part	count=2
arg	if expr is bounded ||| expr	count=1
function	rr ||| rr	count=1
arg	terms of ||| x m n	count=1
function	periapsis ||| periapsis	count=1
class	in ||| sub module	count=1
module	the three parameters when ||| physics	count=2
arg	expression expressions are evaluated ||| expr callback_type	count=1
arg	e [arg_2] ||| [arg_1] [arg_2]	count=7
arg	of the state corresponding [arg_1] [arg_2] ||| physics energy [arg_2] [arg_1]	count=1
arg	with knots ||| knots	count=2
module	specific value (i ||| series	count=1
class	sympy sets set ||| geometry set	count=1
arg	returns the ith ||| i	count=2
module	the module and ||| utilities	count=1
function	the atan of ||| atan	count=1
arg	[arg] for each ||| eqs [arg]	count=2
class	or containers ||| poly	count=1
function	of the cdf ||| cdf expression	count=2
arg	a meijer ||| a	count=1
function	helper for division ||| div	count=2
function	of tensor [function_2] ||| [function_2] [function_1]	count=8
arg	of seq ||| seq	count=3
class	the table ||| table	count=1
arg	f given an interval ||| f	count=1
function	qubit ||| int qubit	count=1
arg	_symbolic_factor ||| expr opt method	count=1
module	matrix containing [module_2] ||| [module_2] [module_1]	count=1
function	multivariate diophantine equations ||| dmp zz diophantine	count=1
function_arg	instance [arg_2] ||| [function_1] cls args [arg_2]	count=1
function	differentiate and evaluate ||| diff eval in	count=1
module	for the initialization of ||| physics	count=1
arg	c i e e( ||| c	count=1
function	[function_1] energy ||| [function_1] [function_2]	count=4
arg	location ||| cls name location	count=1
function	the general [function] ternary form ||| diop ternary [function]	count=1
function	generating ||| generating	count=1
function	a basic expression ||| to basic	count=1
function_arg	discriminant of [arg_2] ||| [arg_2] [function_1]	count=1
function	of the class ||| get	count=1
module	with the ||| physics	count=2
arg	[arg_1] given expression ||| [arg_2] [arg_1]	count=2
arg	convert f from ||| f	count=1
function	[function_1] mul ||| [function_1] coeff [function_2]	count=1
arg	the property prop ||| prop base strong_gens tests	count=1
arg	in x ||| a x	count=1
arg	to subtract [arg] make ||| [arg]	count=1
function	column of ||| col	count=1
function	is not-empty ||| not empty in	count=1
function	a group ||| group	count=2
arg	f as a ||| f	count=2
function_arg	[function_1] g ||| [function_1] [arg_2]	count=11
arg	f a [arg_2] ||| [arg_2] [arg_1]	count=1
function	give ||| dim	count=2
module_class	find the subgroup ||| combinatorics permutation group	count=1
arg	small'' ||| deg_f deg_g row1	count=1
arg	solve [arg] ||| [arg]	count=2
arg	the real inverse_mellin_transform function ||| s x_ strip	count=1
arg	polynomial irreducibility test ||| f p k	count=2
function	postprocess an expression ||| postprocess for	count=1
module	in the object excluding ||| series	count=1
class	representation of ||| form	count=1
function	symbol for undefined variables ||| symbol	count=1
arg	an index in a ||| index	count=2
function	exponentiation ||| rs exp	count=1
arg	of n items ||| n	count=2
arg	a dmf ||| a k0	count=1
module	returns ||| polys agca	count=2
module	returns ||| mechanics	count=2
arg	the operations in ||| visual	count=1
function	strong lucas ||| strong lucas	count=2
function	increasing in ||| increasing	count=1
function	allow values below ||| below	count=1
module	vector in a ||| vector	count=2
class	the determinant ||| determinant	count=1
arg	from k0 to k1 ||| k0 k1	count=1
module_class	[module_1] [class_2] ||| [module_1] optics [class_2]	count=9
function	legendre [function_2] ||| [function_2] [function_1]	count=1
function	helper to tell whether ||| is expr	count=1
arg	gf_pow_mod f ||| f	count=1
function_arg	[function_1] rank rank ||| [arg_2] [function_1]	count=4
function_arg	matrix [arg_2] ||| [function_1] name [arg_2]	count=1
function	to its principal branch ||| principal branch	count=1
function_arg	matrix by its ||| matrix name m	count=1
function	polynomials in [function_2] ||| [function_2] [function_1]	count=1
arg	of general form ||| x y t eq	count=1
function	random bitlist of length ||| random bitstring	count=1
function	that are generated automatically ||| auto	count=1
arg	second order ||| func order	count=1
arg	message which differs slightly ||| is_independent is_plotting	count=1
arg	"node" ||| node	count=1
function	polynomial [function_2] ||| [function_1] [function_2]	count=12
function	loads ||| loads	count=1
arg	a unit in ||| unit	count=1
module	function does the ||| physics	count=1
function	domain a field ||| field	count=1
arg	the grid adds ||| grid skeleton	count=1
arg	rsolve_hypergeometric for details ||| x re g	count=1
module	be deprecated in the ||| physics	count=1
arg	[arg_1] targets ||| [arg_2] [arg_1]	count=1
arg	where n [arg] ||| expr symbolname startnumber [arg]	count=1
function	the quotient [function_2] ||| [function_2] [function_1]	count=2
class	write a cython ||| cython	count=1
function	evalf of ||| eval evalf	count=1
function	create a continuous ||| continuous rv	count=1
function	non-positive ||| nonpositive	count=3
function	nth root of ||| nth root	count=2
function	python subprocess ||| in subprocess	count=1
module	of the linearentity ||| geometry	count=1
arg	backend return ||| backend	count=1
class	standard basis ||| sub module	count=1
function	and leverage it if ||| use	count=1
module	travelling in the ||| physics	count=1
function	whether the function is ||| is	count=3
function	set the new value ||| set	count=1
function	given ||| to	count=2
class	input of the self ||| region	count=1
class	the atoms of ||| basic	count=1
function	the linear ||| linear	count=2
function	to a class ||| mod	count=1
arg	specified ||| superset	count=2
arg	[arg_1] origin ||| [arg_2] [arg_1]	count=2
arg	from gate_list and checks ||| gate_list	count=1
function_arg	[function_1] prec ||| [function_1] [arg_2]	count=1
module	and return the result ||| utilities	count=1
function	according to ||| signature from indices	count=1
arg	z_p ||| p	count=1
function	exact quotient ||| exquo	count=9
arg	root x [arg_1] [arg_2] ||| functions elementary root arg [arg_1] [arg_2]	count=4
module	a piecewise [module] ||| [module]	count=3
arg	[arg_1] b ||| ntheory digits [arg_1] [arg_2]	count=2
class	[class_1] table ||| [class_2] [class_1]	count=3
function	a proper superset ||| proper superset	count=2
arg	expressions into a ||| exprs	count=1
arg	derivative of f in ||| f symbol	count=1
class	list of indices creating ||| index structure	count=1
arg	determine multiplicities of factors ||| factors u	count=1
function	transpositions ||| transpositions	count=1
function	[function_1] properly normalized ||| [function_2] [function_1]	count=1
arg	algorithm i e find ||| g n y	count=1
module	see ||| pretty	count=1
arg	two integers [arg] root2 ||| [arg]	count=1
arg	column ||| col	count=1
module	possible ||| printing	count=1
arg	the fundamental strip ||| strip	count=1
function	[function] of ||| berkowitz [function]	count=1
arg	property prop ||| prop base strong_gens tests	count=1
arg	= a ||| a	count=3
module	simplify ||| physics hep	count=1
function	the level of self ||| level	count=1
arg	an expression into ||| expr	count=1
arg	register the transformation ||| to_sys from_coords to_exprs inverse	count=1
function	scalar multiple of the ||| scalar multiple	count=1
class	[class_1] element ||| [class_2] [class_1]	count=5
function	always ||| only q	count=1
function	in s, and return ||| indent	count=1
function	the covariant [function] ||| covariant [function]	count=1
function_arg	[function_1] [arg_2] ||| [function_1] tangent [arg_2]	count=1
arg	if ||| a	count=1
module	is not-empty ||| calculus	count=1
module	the loggamma function i ||| functions special	count=2
function	common [function_2] ||| [function_2] [function_1]	count=8
arg	controls targets [arg_2] ||| [arg_2] [arg_1]	count=1
function_arg	finding powers [arg_2] ||| [arg_2] [function_1]	count=1
function	generators in a ||| gens	count=1
function	[function_1] series ||| [function_2] [function_1]	count=15
module	logic operators and relationals ||| logic	count=1
function	single g functions of ||| single	count=1
arg	f [arg_2] ||| dup apply pairs [arg_1] [arg_2]	count=1
arg	g in z_p ||| g p k	count=2
function	common header ||| header	count=2
function	form of ||| form	count=1
function	recalculate the ||| retract	count=1
function	[function_1] an algebraic ||| [function_2] [function_1]	count=2
function	length of a ||| length	count=1
function	of a k t ||| k t	count=1
arg	3 1 2 ; [arg_1] [arg_2] 1 3 2 3 ||| [arg_1] [arg_2]	count=1
function	shift the function by ||| shift	count=1
arg	divides p ||| p	count=1
arg	z ||| z a	count=1
function_arg	term in [arg_2] ||| [function_1] [arg_2]	count=8
class	c code and ||| code	count=1
module	interactive ||| interactive	count=2
arg	polynomial p ||| p u	count=1
function	factors [function_2] ||| [function_2] [function_1]	count=2
function	terms [function_2] ||| [function_1] [function_2]	count=2
arg	[arg_1] args ||| [arg_2] [arg_1]	count=2
class	values ||| code	count=1
arg	targets and [arg_2] ||| [arg_1] [arg_2]	count=1
function	fermi? >>> from sympy ||| fermi	count=2
function	the square-free ||| sqf	count=1
arg	op ||| op	count=2
function	f * [function_2] ||| [function_2] [function_1]	count=1
function	to x_i**k_i in ||| inflate	count=1
function	form base [function_2] ||| [function_2] [function_1]	count=1
function	return square-free ||| dmp sqf	count=1
module	the list is ||| combinatorics	count=1
function_arg	gray coding ||| gray bin_list	count=1
function	into a [function_2] ||| [function_1] [function_2]	count=2
arg	[arg] n non ||| [arg]	count=1
function	as ||| as f	count=1
arg	compute the [arg_2] ||| [arg_1] [arg_2]	count=5
arg	the operations ||| visual	count=1
arg	of factors using ||| f factors u	count=1
arg	polynomials ||| g	count=7
function_arg	apply [arg_2] ||| [arg_2] [function_1]	count=5
function	z ||| commutator zgate	count=2
function	[function_1] single ||| hep [function_1] [function_2]	count=1
function	indices of [function_2] ||| [function_1] [function_2]	count=2
function	to replace constants by ||| simplify variable	count=1
function_arg	exp [arg_2] ||| [function_1] [arg_2]	count=1
function_arg	extension [arg_2] ||| [function_1] [arg_2]	count=1
arg	base argument can ||| base	count=1
arg	that only func ||| func hint	count=1
arg	z_p for ||| p	count=1
function	roots [function_2] ||| [function_2] [function_1]	count=3
function	perform a partial ||| partial	count=2
class	of polynomials or containers ||| poly ring	count=1
function	always create ||| only	count=2
function_arg	[function_1] [arg_2] terms whose squares are ||| [function_1] surds [arg_2]	count=1
function	direct products ||| perm af direct product	count=1
arg	to each other ||| other	count=1
class	sympy sets ||| geometry set	count=1
function	free [function_2] ||| [function_1] [function_2]	count=11
function	bending ||| bending	count=1
function	and negative ||| opt	count=1
arg	the operations in expr ||| expr visual	count=1
function	[function_1] roots of ||| [function_2] [function_1]	count=14
function	von mises ||| von mises	count=2
class	matrix of ||| matrix	count=2
class	of symbolic values ||| llvmjit	count=1
class	no bounding ||| complex	count=1
function	transforms ||| transform	count=1
function_arg	[function_1] two ||| [function_1] f [arg_2]	count=2
module	propagation ||| logic algorithms	count=2
function	f + g*h where ||| add mul	count=2
function	coefficient iterator ||| coefficients iterator	count=2
function_arg	cond [arg_2] ||| [arg_2] [function_1]	count=1
function	[function_1] with hash ||| [function_2] [function_1]	count=4
function_arg	[function_1] point ||| [function_1] vec [arg_2]	count=3
arg	variable with a ||| name lamda	count=1
arg	and negative coefficient muls ||| exprs	count=1
arg	isolating interval of a ||| f s t eps	count=2
function_arg	[function_1] [arg_2] share at least ||| [function_1] [arg_2] key1	count=4
class	[class] 'rotation matrix' ||| coord [class]	count=1
arg	[arg_1] origin ||| [arg_1] [arg_2]	count=2
function_arg	inverse sine [arg_2] ||| [arg_2] [function_1]	count=2
function	the bottom nodes first ||| bottom	count=1
arg	token+name is ||| name token expr	count=1
module	if the [module_2] ||| [module_1] [module_2]	count=2
arg	returns f ||| f	count=1
arg	[arg_1] start ||| core prod [arg_1] [arg_2]	count=6
class	used in ||| table	count=1
function	returns f - ||| dmp sub	count=1
function	the gauss-chebyshev ||| chebyshev u	count=1
function_arg	col [arg_2] ||| [function_1] op [arg_2]	count=1
arg	terms of f ||| f x	count=1
class	of tuples index ||| index structure	count=1
arg	mod [arg] to an ||| a [arg]	count=1
function_arg	[function_1] of alpha ||| [function_1] transversal [arg_2]	count=3
class	on a ||| series base	count=1
function	see ||| pretty try use	count=1
arg	adjusting exps ||| exps	count=1
arg	ax = b ||| b freevar	count=2
function	rational number \frac ||| rational	count=1
function	is quadratic ||| is quadratic	count=2
arg	row ||| matlist	count=1
function	euclidean ||| euclidean	count=2
arg	instance of fpgroup h ||| h	count=1
function	having root v it ||| choose	count=1
function	expr ||| sort expr	count=1
arg	expression [arg_2] ||| [arg_1] [arg_2]	count=1
function	[function_1] a sympy ||| [function_1] [function_2]	count=6
arg	function target ||| target	count=1
function_arg	the discriminant [arg_2] ||| [arg_2] [function_1]	count=1
arg	return namespace dict with ||| namespace	count=1
function	map x_i**m_i ||| multi	count=1
arg	of alpha ||| generators alpha	count=1
arg	2 ; -1 if [arg_1] [arg_2] 1 3 2 3 ||| [arg_1] [arg_2]	count=1
class	this linear [class_2] ||| [class_2] [class_1]	count=4
arg	functions or as a ||| x a b	count=1
function	of x**(i*p) mod ||| frobenius monomial base	count=1
function	curve or deflection ||| deflection	count=1
function	operators corresponding to ||| to operators	count=1
class	enumerate the ||| partition traverser	count=1
function	the new ||| init	count=1
function	convert modularinteger [function_2] ||| [function_1] [function_2]	count=1
arg	condition ||| cls cond	count=1
arg	of ||| x helper	count=1
function	expand ||| expand	count=8
arg	fundamental strip given by ||| x strip	count=1
module	string path ||| utilities	count=2
module	in finite_set in which ||| calculus	count=1
function	a vector ||| vector	count=1
arg	p with [arg_2] ||| [arg_2] [arg_1]	count=4
function	routine ||| routine	count=2
function	[function_1] line ||| [function_2] [function_1]	count=4
arg	of f by g ||| f g auto	count=3
module	[module] h\frac{d\chi}{dx} ||| [module]	count=3
function	an n\th ||| ode nth	count=5
function_arg	logarithm [arg_2] ||| [function_1] [arg_2]	count=2
class	of g_2" ||| type g	count=1
function	center ||| center	count=2
function	returns the best solution ||| homogeneous coeff best	count=1
arg	of length n raise ||| n	count=1
function	the integer ||| integer to term	count=1
function	[function_1] the denominator ||| [function_2] [function_1]	count=1
arg	[arg_1] in expr ||| [arg_2] [arg_1]	count=8
function	logarithmic derivative of a ||| log deriv	count=1
arg	objects mapping ||| objects	count=1
function	asin of ||| rs asin	count=1
function	trivial ||| trivial	count=1
arg	a condition on input ||| condition message	count=1
class	c [class_2] ||| [class_2] [class_1]	count=2
function	and leverage it ||| try use	count=1
arg	the series expansion of ||| x prec	count=4
module	that are generated ||| integrals	count=1
class	exploiting the sparsity of ||| sparse	count=2
function	the ||| indent	count=3
function	was [function_2] ||| [function_2] part [function_1]	count=1
function	reverse ||| reverse	count=1
module_class	[module_1] freegroup ||| [module_1] [class_2]	count=4
function	solve a [function_2] ||| [function_2] [function_1]	count=1
module	of the ||| utilities	count=1
function	pendulum on a ||| n link pendulum on	count=1
function	an fisher's [function_2] ||| [function_1] [function_2]	count=2
class	current system ||| system	count=1
function	[function_1] heuristic ||| [function_2] [function_1]	count=2
function	form x start ||| limits	count=1
function	the bra on ||| bra	count=1
function	function is a ||| is rational function	count=1
arg	p where ||| p	count=1
module	generator that ||| solvers	count=1
arg	test if p ||| p	count=1
arg	all [arg] are ||| [arg]	count=1
class	of the ||| type f	count=1
class	a sparse n-dim ||| sparse ndim	count=2
class	along self's last ||| matrix	count=2
arg	eliminate x_0 ||| u	count=1
arg	if self [arg] ||| [arg]	count=1
function	maximum ||| imax	count=1
function	number of the generator ||| generator	count=1
module	the basis ||| physics units	count=1
function	inequalities with rational coefficients ||| inequalities	count=1
arg	rhs but treats ||| rhs	count=1
arg	compute ||| f g u	count=1
arg	f s , ||| f s t plane	count=1
function	index of ||| index	count=3
function	name of the ||| get mod func	count=1
module	the object ||| physics quantum	count=1
arg	= b m ||| a b	count=1
function	and leverage it ||| use	count=1
arg	b ||| a b a b	count=1
function	zero to infinity ||| definite 3	count=1
function	integer representation ||| find pure symbol int repr	count=1
module	the divergence [module] ||| physics [module]	count=1
function	non-conjugate ||| refine complexes	count=2
module_class	partition of [module_1] [class_2] ||| [module_1] [class_2] partition	count=4
function	strong ||| strong	count=1
function	equation of [function_2] ||| [function_2] [function_1] func_class f symbol	count=1
module	qdots to the ||| physics	count=1
function	the ||| not empty	count=3
arg	a given backend ||| backend	count=1
function	which ||| not empty	count=1
function_arg	factors of f ||| include f all	count=2
arg	j ||| s j	count=1
function_arg	[function_1] in x ||| [function_1] p [arg_2]	count=4
function_arg	x**(i*p) mod [arg_2] ||| [function_1] [arg_2]	count=6
function	a new rootsystem object ||| new	count=1
arg	self [arg] are the ||| [arg]	count=1
class	coordinate system with ||| coord sys cartesian	count=1
function_arg	domain where [arg_2] ||| [arg_2] [function_1]	count=1
function	coincidence routine ||| coincidence	count=1
function	third heuristic assumes the ||| heuristic bivariate	count=1
function	single gamma matrix line ||| single line	count=1
function	motion ||| comb	count=1
class	representation with native coefficients ||| anp	count=1
function	return the truth value ||| eval	count=1
module	conjugating the ||| physics	count=1
function	the left ||| left	count=1
function	in explicit ||| explicit rhs	count=1
function	irreducible factors of ||| factor	count=3
function	that dummies ||| dummies	count=1
class	transform an expression ||| expr	count=1
function	returns the ||| get	count=1
arg	variable with a log-normal ||| name mean std	count=1
arg	[arg_1] k is ||| physics epsilon [arg_1] [arg_2]	count=3
function_arg	[function_1] gr adjacency ||| [arg_2] [function_1]	count=1
function	find 'executable' ||| find	count=1
module	containers ||| polys	count=1
function	of the atanh of ||| atanh	count=1
function	evaluate a polynomial ||| evaluate	count=1
function	of phrase and if ||| check and	count=1
class	a sparse [class_2] ||| [class_2] [class_1]	count=3
function	multiple ||| multiple	count=1
module	vector in a referenceframe ||| vector	count=2
function	formats ||| statement	count=1
class	corresponding to a group ||| group element	count=1
module	the form ||| physics	count=2
function	the expr ||| sort expr	count=1
arg	in k[x] ||| n u	count=1
function	[function_1] gcd ||| [function_1] ff trivial [function_2]	count=2
class	latex knows about ||| latex	count=1
function	sort of graph's vertices ||| sort	count=1
function_arg	[function_1] tri to ||| [arg_2] [function_1]	count=2
module	rearrange the order ||| physics quantum	count=1
function	the d ||| d	count=1
function_arg	[function_1] [arg_2] ||| [function_1] data [arg_2]	count=10
function	cross product convenience wrapper ||| cross	count=1
arg	variable representing ||| name p succ	count=2
function	labeled ||| lbp	count=2
function	is that dummies can ||| ordered dummies	count=1
arg	the routines [arg_2] ||| [arg_2] [arg_1]	count=3
arg	f g are polynomials ||| f g	count=1
function	truth ||| eval	count=1
function_arg	pseudo-remainder of f ||| prem f	count=2
function	helper function ||| helper simplify	count=2
arg	in ||| order	count=1
function	lowering the degree of ||| tr7	count=1
arg	[arg] when ||| rv do [arg]	count=3
function	finds the domain of ||| not	count=1
function	to a ||| func	count=1
arg	w r t ||| otherpoint	count=1
function	gives [function_1] [function_2] ||| 2nd [function_1] [function_2]	count=1
arg	key [arg_2] ||| [arg_2] [arg_1]	count=5
module	vector distance between this ||| vector	count=1
arg	steps ||| steps	count=1
function	a simplified ||| simplified	count=1
function_arg	xor ^, [arg_2] ||| [function_1] [arg_2]	count=1
function	two ||| zero mul	count=1
arg	[arg_1] prec ||| [arg_1] [arg_2]	count=5
function_arg	[function_1] alpha as ||| [function_1] [arg_2]	count=3
function	a rational ||| integer rational	count=1
function	[function_1] finite ||| [function_2] [function_1]	count=1
function	roots in linear ||| roots	count=1
class	[class_1] intervals ||| [class_2] [class_1]	count=2
arg	negative coefficient ||| exprs order	count=1
function	returns intrinsic ||| intrinsic	count=1
function	equation [function_2] ||| [function_2] [function_1]	count=2
function	[function_1] term in ||| [function_2] [function_1]	count=5
function	computes the indefinite integral ||| dmp integrate	count=2
function	of expressions generated ||| vpprint	count=1
class	cython file with ||| cython	count=1
function_arg	[function_1] expression ||| [function_1] [arg_2]	count=2
arg	all elements of seq ||| seq	count=1
class	integral sign [1], using ||| integral	count=1
class	of the function ||| holonomic function	count=1
function	the closing ||| get routine ending	count=1
function_arg	remainder of a ||| rem a	count=5
arg	[arg_1] path ||| [arg_2] expr [arg_1]	count=1
function	polynomial gcd and ||| gcd	count=1
class	controlled gate ||| cgate	count=1
class	polynomial coefficients ||| poly	count=1
module	the curl [module] field ||| physics [module]	count=1
function_arg	dummy associated [arg_2] ||| [function_1] [arg_2]	count=6
function	the primitive [function_2] ||| [function_1] [function_2]	count=4
arg	n and a ||| n	count=1
arg	k [arg_2] ||| [arg_2] [arg_1]	count=7
function	the atan ||| atan	count=1
function	the minimal polynomial ||| minpoly op	count=1
function	the length of ||| morphism length	count=1
function	the lmq lower bound ||| root lower bound	count=1
class	ie ||| permutation	count=2
function	opportunities in ||| cse	count=1
function	[function_1] annihilate particle ||| [function_1] [function_2]	count=1
arg	the writer function out ||| compileflags out clear_globs	count=1
function	row-sorted [function_2] ||| [function_1] [function_2]	count=4
arg	in options=s ||| expr	count=1
class	generate ||| free module poly	count=1
function	the directional [function_2] ||| [function_1] [function_2]	count=3
module	[module] z^2 ||| [module]	count=3
arg	expression and call _normal_order_factor ||| expr	count=1
function	a key ||| key	count=1
function_arg	centralizer of [arg_2] ||| [arg_2] [function_1]	count=2
function_arg	replace [arg_2] ||| [function_1] query value [arg_2]	count=1
function	[function_1] negative ||| [function_1] [function_2]	count=1
function	from a list of ||| interpolate	count=1
function_arg	[function_1] transformation ||| [function_1] [arg_2]	count=1
class	compute ||| python integer	count=4
module	return a set of ||| polys agca	count=1
class	create a dmf ||| dmf	count=1
class	intersection in ||| intersection	count=1
function	coefficients try [function] ||| [function] rational	count=2
arg	coefficient domain of p1 ||| p1	count=1
function_arg	update [arg_2] ||| [function_1] s _lambda [arg_2]	count=1
function_arg	check a [arg_2] ||| [arg_2] [function_1]	count=2
function	expand ||| expand delta	count=2
arg	true if a ||| a	count=6
arg	symbol with [arg_2] ||| [arg_1] [arg_2]	count=1
function	mapping of symbolic ||| param	count=1
class	create a ||| subs	count=1
module	currently ||| physics	count=1
class	referenceframe ||| reference	count=1
arg	[arg_1] divides p ||| [arg_2] [arg_1]	count=1
function	real element object ||| real	count=1
arg	of e [arg_2] ||| [arg_1] [arg_2]	count=7
class	[class] of ||| matrix [class]	count=1
class	complex isolating [class_2] ||| [class_2] [class_1]	count=1
module	positive literal ||| algorithms	count=1
arg	solution [arg] ||| [arg] z	count=1
function	differentiate and ||| diff	count=1
module	which the ||| physics quantum	count=2
arg	j_2 j_3 m_1 m_2 ||| j_2 j_3 m_1	count=1
function	wang/eez compute a set ||| dmp zz wang	count=1
function	its structure [function] *dummy* we ||| [function] contraction	count=1
arg	irreducibility test over finite ||| p	count=1
module	can ||| combinatorics	count=1
class	proper line ending ||| printer	count=1
module	get the ||| combinatorics	count=1
function	create a finite ||| finite	count=1
function	is a gate identity ||| random identity	count=1
function	object ||| free	count=1
arg	an equivalent sentence in ||| expr	count=2
function	greatest factorial ||| gff	count=1
function	modularinteger int ||| ff python	count=2
arg	a given annihilator ||| list_of parent negative	count=1
class	bounding ||| of	count=1
function	and ||| mod func	count=1
arg	numpy array ||| m dtype	count=1
function	a dictionary which expresses ||| map	count=1
function	is reducible ||| is reducible	count=1
arg	and ||| g	count=1
function	as g* a ||| as	count=1
arg	[arg_1] s t ||| [arg_1] [arg_2]	count=1
module	referenceframe ||| physics vector	count=1
function	[function] between this ||| [function]	count=2
function	bounding rectangles of non-conjugate ||| complexes	count=1
function	row echelon form ||| rref	count=1
function	a scalar ||| scalar	count=3
function	[function_1] a single ||| [function_2] [function_1]	count=1
arg	the writer function out ||| test compileflags out clear_globs	count=1
module	location ||| combinatorics	count=2
class	raising shapeerror ||| matrix arithmetic	count=1
function	a von [function_2] ||| [function_1] [function_2]	count=2
function	that dummies can ||| ordered dummies	count=1
arg	in x_0 of a ||| f m u k	count=1
function	previous [function_2] ||| [function_2] [function_1]	count=2
function_arg	[function_1] field in ||| [arg_2] [function_1]	count=4
function	[function_1] coefficients ||| [function_1] [function_2]	count=19
function	expression as a tuple ||| as	count=1
arg	muls ||| exprs order	count=1
arg	is replaced by ||| args kwargs	count=1
arg	in a rational function ||| f g	count=1
arg	m == 1 where ||| m	count=1
arg	expression e [arg_2] ||| [arg_1] [arg_2]	count=3
function	annihilate particle ||| annihilator	count=1
function_arg	[function_1] polynomial f ||| [function_1] ground [arg_2]	count=1
arg	a k[x] polynomial ||| f u k zero	count=1
arg	given a triangle ||| triangle	count=1
function	codestring ||| get statement	count=1
arg	given frame ||| frame	count=1
arg	a literal ||| lit cls	count=1
function	returns square-free part of ||| dmp sqf part	count=1
arg	n ||| n x x y	count=1
function	[function_1] quadratic ||| [function_1] [function_2]	count=1
function_arg	of cos [arg_2] ||| [arg_2] [function_1]	count=1
arg	number [arg_2] ||| [arg_2] [arg_1]	count=1
arg	first order differential equations ||| func order match	count=1
function	to values below ||| below	count=1
function	files ||| test files	count=2
function	multinomial ||| multinomial	count=1
function	atanh ||| atanh	count=1
arg	t ||| t k	count=1
function	in integer representation ||| int repr	count=1
function_arg	[function_1] [arg_2] ||| [function_1] to dict [arg_2]	count=9
module	the function in the ||| physics quantum	count=1
arg	fpgroup h a subgroup ||| fp_grp h	count=1
function	[function_1] square-free polynomial ||| [function_1] [function_2]	count=4
function	[function_1] [function_2] generators ||| [function_1] [function_2] of generators	count=1
function	independence between ||| independent	count=1
class	frame in ||| frame	count=1
function	next [function] taylor ||| taylor [function]	count=1
function	in the lower-hessenberg form ||| lower hessenberg	count=1
module	list the ||| combinatorics	count=1
function	points ||| points	count=3
function	rank of a matrix ||| rank	count=1
function	ascents in a permutation ||| ascents	count=1
function	the root [function] directory ||| [function]	count=1
function	split a symbol name ||| split	count=1
class	specific value ||| series base	count=1
function	the ecart ||| sdm ecart	count=1
class	latex knows about e ||| latex printer	count=1
arg	gf_pow_mod f p ||| f	count=1
function	converts a ||| convert to	count=2
function	sum of [function_2] ||| [function_2] [function_1]	count=3
function	is a homomorphism with ||| hom	count=1
function	derived [function_2] ||| [function_2] [function_1]	count=1
arg	modulo o(x**prec) ||| c x prec	count=1
function	reduce a ||| trunc	count=1
module	into ||| utilities	count=1
class	standard ||| poly ring	count=2
arg	factors using ||| f factors u k	count=1
arg	f and g which ||| f g	count=1
function_arg	[function_1] p ||| [function_1] monic f [arg_2]	count=3
class	is [class] ||| [class]	count=2
arg	and returns the ciphertext ||| msg key	count=1
function	heuristic ||| lie heuristic bivariate	count=1
function	wolfram mathematica [function] examples ||| mathematica [function]	count=1
arg	characters of symbols ||| symbols filter	count=1
arg	[arg_1] and format ||| matrix [arg_1] [arg_2]	count=1
class	where p[i] > ||| permutation	count=1
arg	field in ||| field	count=1
function	energy of a ||| energy	count=1
arg	function in a python ||| function	count=1
function	polynomial for ||| poly	count=1
function	f * [function_2] ||| [function_1] [function_2]	count=1
class	of indices creating new ||| index structure	count=1
function	returns level ||| level	count=1
function	tangent of ||| tan	count=1
arg	using polynomial techniques ||| domain	count=1
arg	[arg_1] subtracting pt ||| [arg_2] [arg_1]	count=3
arg	for medium p ||| p k	count=1
class	code a ||| code	count=1
function	hyperbolic functions in terms ||| hyper as	count=1
arg	in [inf sup] ||| inf sup	count=3
function	[function_1] logarithmic derivative ||| [function_1] [function_2]	count=1
arg	[arg_1] a ||| [arg_2] [arg_1]	count=40
function	x ||| process	count=1
arg	use by ||| s n	count=1
function	reduce the element ||| reduce element	count=2
function	set the ||| set domain	count=1
class	the total number ||| g	count=1
function	is strictly decreasing ||| is strictly decreasing	count=3
class	lagrange multipliers if ||| lagranges	count=1
module	a list ||| polys	count=1
function	factors of a univariate ||| root factors	count=1
function	specific integer modulus ||| integer	count=1
module	containing a simple kroneckerdelta ||| concrete	count=1
arg	for ||| parameter	count=3
function	an [function_1] [function_2] ||| [function_2] [function_1]	count=8
module	the location where ||| combinatorics	count=2
function_arg	[function_1] medium p ||| [function_1] zassenhaus f [arg_2]	count=1
function	a zero morphism ||| zero	count=1
function	in which the ||| not	count=1
module_class	the [class_2] ||| [module_1] [class_2] intersection o	count=1
arg	bounding ||| cls	count=1
module	a class ||| utilities	count=1
function	that no bounding rectangles ||| complexes	count=1
class	tuple of ||| basic	count=2
function	l1 norm of a ||| l1 norm	count=1
module_class	[module_1] [class_2] is called complete if ||| [module_1] [class_2] is complete	count=1
arg	its subgroup [arg] using the ||| [arg]	count=1
function	syllables from positions ||| sub syllables	count=2
function	[function_1] start ||| [function_1] [function_2]	count=4
function	letter [function_2] ||| [function_1] [function_2]	count=4
function	[function_1] of irreducible ||| [function_2] [function_1]	count=12
arg	b ||| b	count=15
module	coordinates which the ||| physics	count=1
arg	alpha ||| degree generators alpha pairs	count=1
arg	of terms of ||| x m	count=1
function	always create a ||| is only	count=2
arg	f g are ||| f g	count=1
function	full partial [function_2] ||| [function_2] [function_1]	count=2
arg	[arg_1] after subtracting ||| [arg_2] [arg_1]	count=3
function	the minimum [function_2] ||| [function_2] [function_1]	count=2
function	[function_1] polynomials in ||| [function_2] [function_1]	count=1
module	non-conjugate ||| polys	count=1
function	the sopform ||| sopform	count=1
function_arg	[function_1] differential equation ||| [function_1] eq func order [arg_2]	count=2
arg	of general ||| x y t eq	count=1
arg	symbol with p ||| symbol p	count=3
function	polynomial of an ||| polynomial	count=1
function	computes the sturm sequence ||| dup sturm	count=1
arg	op ex1 ex2 parameters ||| op ex1 ex2	count=1
module	by default on the ||| physics	count=1
class	of polynomial ||| frac	count=1
arg	the hypergeometric function target ||| target	count=1
function	return the trailing coefficient ||| gf tc	count=1
function	it ||| try	count=1
function	list of degrees ||| degree list	count=3
function_arg	from positions [arg_2] ||| [arg_2] [function_1]	count=1
class	momentum ||| px ket	count=1
function_arg	memoized version [arg_2] ||| [function_1] [arg_2]	count=1
function	on a [function_2] ||| [function_2] [function_1]	count=2
module	compute ||| polys domains	count=4
arg	token+name ||| name token expr	count=1
module	of ||| elementary	count=1
arg	k-tuples of nonnegative values ||| k zeros	count=1
function_arg	rotate [arg_2] ||| [arg_2] [function_1]	count=1
class	operators ||| state base	count=1
function	normalize a ||| normalize	count=2
class	which [class] preferred ||| [class]	count=1
function	converts a list given ||| letter form to	count=1
module	root [module] sqrt ||| [module]	count=1
class	integration using any hints ||| integral	count=1
arg	[arg] and a ||| a b [arg]	count=3
function	create a quasi-particle? ||| q creator	count=2
function	see the expand ||| expand	count=2
function	[function_1] open ||| [function_2] [function_1]	count=1
module_class	the [class_2] ||| [module_1] [class_2] minor	count=1
arg	in rules ||| rules x prec	count=1
function	the coefficient of a ||| as coeff add	count=3
function	it if ||| try	count=1
arg	products of tan or ||| rv	count=1
arg	f p g ||| f g	count=1
function	to their ||| to state	count=1
function	a [function_1] [function_2] ||| [function_1] [function_2]	count=2
class	the integral sign ||| integral	count=1
class	picture in ||| string pict	count=1
function	system for the ||| system	count=1
class	with no more than ||| partition	count=1
class	homomorphism obtained by ||| homomorphism	count=1
arg	old -> [arg_2] ||| [arg_1] [arg_2]	count=1
function	representation of ||| rep	count=1
function	f ||| dmp eject	count=1
arg	fringe [arg_2] ||| [arg_2] [arg_1]	count=3
function	the sum of ||| sum of	count=1
arg	main ||| s	count=2
function_arg	[function_1] instance from ||| [function_1] [arg_2]	count=4
function	from ||| sub	count=2
arg	check whether u ||| u	count=1
function	polynomials in [function_2] ||| [function_1] [function_2]	count=1
class	helper function of ||| dense	count=1
function	linear homogeneous [function_2] ||| [function_2] [function_1]	count=2
module	blockmatrices ||| matrices expressions	count=1
arg	func to [arg] ||| func [arg]	count=3
class	in ||| module poly	count=1
arg	a given field ||| field coord_sys	count=2
module	a sequence of polynomials ||| polys	count=1
function	of the atan ||| atan	count=1
function	name ||| mod	count=1
class	g=self ||| permutation group	count=1
class	function in ||| expr	count=1
class	from [class] inject ||| [class]	count=1
function	bareiss' fraction-free algorithm which ||| det bareiss	count=1
function	heuristic polynomial gcd ||| heu gcd	count=7
function	intended or q[x] it ||| vv 2	count=1
arg	[arg_1] and target_matrix ||| [arg_2] [arg_1]	count=2
class	isolation intervals ||| complex interval	count=2
arg	i j see _tensormanager ||| i j	count=1
arg	a condition [arg_2] ||| [arg_1] [arg_2]	count=1
class	ground domain a ||| dmp	count=2
module	in the specified arbitrary ||| physics quantum	count=1
function	descents ||| descents	count=1
module	of the particle the ||| physics	count=1
function	smallest primitive ||| primitive	count=1
class	the plot ||| pyglet plot	count=1
function_arg	addends [arg_2] ||| [arg_2] [function_1]	count=4
function	below ||| is below	count=1
function	lift ||| lift	count=1
function	lu the decomposition ||| lu	count=1
arg	takes clauses in ||| clauses	count=1
function	of symbolic values to ||| create param	count=1
class	is ||| symbol	count=1
arg	[arg_1] r are ||| [arg_2] [arg_1]	count=1
module	characters ||| utilities	count=1
function	maximum norm ||| max norm	count=5
class	for the ||| fcode	count=1
function_arg	have precision [arg_2] ||| [function_1] [arg_2]	count=1
function	types of functions ||| functions	count=1
function_arg	of operators [arg_2] ||| [function_1] obj [arg_2]	count=2
arg	m_1 \; [arg_2] ||| clebsch gordan [arg_2] [arg_1]	count=1
arg	to z ||| z tol a	count=1
function	find optimization opportunities ||| cse	count=1
arg	f [arg_2] ||| [arg_2] [arg_1]	count=113
function	[function_1] distributed ||| [function_2] to [function_1]	count=2
module	augmented by the ||| physics	count=1
arg	[arg_1] yield origin ||| [arg_2] [arg_1]	count=3
function	mpmath mpf ||| real field	count=5
module	class into ||| utilities	count=1
arg	about :math x_0 ||| n coefficient order _recur	count=1
arg	are in z[x] ||| x	count=1
function	create ||| create args	count=1
function	previous binary ordered ||| prev binary	count=2
arg	to infinity g1*g2 ||| g1 g2 x	count=1
class	name and same assumptions ||| symbol	count=1
arg	root if it ||| cls root radicals	count=1
function	return the ||| indent	count=1
arg	types for function ||| func_args	count=1
function	evaluate ||| dmp eval	count=1
arg	helper for ||| expr	count=1
arg	of two ||| g	count=6
arg	apply f to all ||| f atoms nonbasic	count=1
arg	namespace ||| expr namespace	count=1
function_arg	expression in [arg_2] ||| [function_1] [arg_2]	count=1
function_arg	[function_1] modulo ||| [function_1] [arg_2]	count=2
function_arg	monomials from f ||| monoms f	count=1
function_arg	return the covariant [function_1] [arg_2] ||| [function_1] [arg_2]	count=2
function	matrix to [function_2] ||| [function_1] [function_2]	count=1
function	alias was set ||| aliased	count=1
function	transversal for the ||| transversal	count=1
function	upper ||| upper	count=1
function	is a cyclotomic polnomial ||| is cyclotomic	count=1
class	a new tids ||| tids	count=1
arg	f [arg] ||| f [arg]	count=3
function_arg	this function simplifies a [function_1] [arg_2] ||| [function_1] logic [arg_2] deep	count=1
class	in the group ||| permutation group	count=1
arg	[arg_1] y ||| [arg_2] [arg_1]	count=1
function	domain of the ||| not	count=1
arg	x_0 of a ||| u	count=1
function_arg	parameters and [arg_2] ||| [function_1] [arg_2]	count=1
function	polynomial gcd of ||| gcd	count=2
function	the semi-latus rectum ||| semilatus rectum	count=1
arg	[arg_1] degree d ||| [arg_2] knots [arg_1]	count=2
class	any hints given ||| integral	count=1
function	of the functions in ||| empty	count=1
class	associative word ||| free group element	count=3
function_arg	an apply [arg_2] ||| [function_1] qubit [arg_2]	count=2
class	symbolic values ||| llvmjit	count=1
function	returns l1 ||| dmp l1	count=2
function	continuous subsequence of ||| dmp slice	count=2
arg	variable ||| name n	count=1
function	for [function_2] ||| [function_1] [function_2]	count=1
function	root of p ||| root	count=1
function	return the leading degree ||| degree	count=1
arg	q**n * f(p/q) ||| f p q	count=1
module	none if ||| core	count=1
arg	length l1 [arg_2] ||| [arg_2] [arg_1]	count=1
class	creates a set partition ||| partition	count=1
arg	of symbols with those ||| symbols filter	count=1
function_arg	integrate p with ||| rs integrate p	count=1
arg	[arg] turn is ||| matlist index1 [arg]	count=1
arg	to fringe [arg_2] ||| [arg_1] [arg_2]	count=3
function	in \mathbb{z}[x_0 \ldots x_{k-1}] ||| multivariate	count=1
function	derivatives ||| diff	count=2
function	in terms [function_2] ||| [function_2] [function_1]	count=1
class	create hole or create ||| create fermion	count=1
arg	k[t] and p in ||| p	count=1
module	permutation ie the ||| combinatorics	count=2
class	or containers of polynomials ||| ring	count=1
function	a derivative ||| derivative	count=1
function	resolve the order of ||| order	count=1
function	returns the symbol ||| symbol	count=1
function	returns the identity ||| identity	count=1
function	subset defined ||| subset	count=1
function	domain ||| in	count=1
arg	the writer function ||| clear_globs	count=1
module	objects handles the ||| physics	count=1
function	points for ||| points	count=1
arg	to the divergence ||| vect	count=1
arg	the given number ||| s	count=1
function	helper ||| helper simplify	count=1
function_arg	[function_1] f p ||| [arg_2] [function_1]	count=4
function	method converts a list ||| to	count=1
function	transcedental ||| transcendental	count=1
function	square-free ||| dup sqf	count=1
function	degrees of ||| degree	count=1
function	the mul ||| mul	count=1
function	to their ||| operators to	count=1
function	perpendicular ||| perpendicular	count=1
arg	k1 ||| k1 symbols	count=1
function_arg	[function_1] root1 and ||| [function_1] [arg_2] root2	count=1
arg	to rewrite [arg] using ||| [arg]	count=1
function	sum of ||| do sum of	count=2
function	of gcd ||| gcd	count=1
arg	ax = [arg_2] ||| [arg_2] [arg_1]	count=2
function_arg	gf [arg_2] ||| [function_1] to dict [arg_2]	count=3
class	returns the ||| type g	count=1
arg	index2 row which in ||| index2	count=1
function_arg	[function_1] of square-free ||| [arg_2] [function_1]	count=6
function	class for specific integer ||| modular integer	count=1
arg	elements of a ||| a	count=1
arg	f in lex order ||| f order	count=3
arg	expansion of ||| a prec	count=1
arg	eqs and ||| eqs	count=1
function	given [function_2] ||| [function_1] [function_2]	count=2
function	tensor [function_2] ||| [function_2] [function_1]	count=8
function	rewrite the ||| rewrite	count=2
arg	with respect to ||| a	count=1
arg	solving first order differential ||| eq func order match	count=1
arg	local_dict ||| local_dict	count=1
function	[function_1] decreasing ||| [function_1] [function_2]	count=9
function_arg	holonomic [arg_2] ||| [arg_2] [function_1]	count=1
module	apply ||| strategies	count=1
arg	a reasonably intelligent way ||| f_gens g_gens	count=1
arg	represents ||| arg h0	count=2
arg	a first order ||| order	count=2
function_arg	[function_1] isolating ||| [function_1] root [arg_2]	count=2
function	scan performs a ||| scan	count=1
function	gcd using subresultants ||| prs gcd	count=6
function	a number times pi ||| pi	count=1
function	to the module ||| get mod func	count=1
function	name of the class ||| get	count=1
module	given the faces ||| combinatorics	count=1
function	root or none references ||| root	count=1
arg	variable with a ||| name r	count=1
class	outer [class_2] ||| [class_2] [class_1]	count=2
function_arg	key [arg_2] ||| [arg_2] [function_1]	count=1
function	equation is [function_2] ||| [function_2] [function_1]	count=2
class	2-tuple ||| exp	count=1
arg	denominator of f and ||| a	count=1
function	scalar multiple ||| scalar multiple	count=2
arg	solves a first order ||| order	count=2
function	finds the domain ||| not empty	count=1
arg	field in a given ||| field	count=1
function	[function_1] is a ||| [function_2] [function_1]	count=3
function	be of the form ||| limits	count=1
arg	to object obj, substituting ||| obj	count=1
function_arg	[function_1] grid ||| [arg_2] [function_1]	count=1
class	excluding those that ||| series base	count=1
function	[function_1] cart under ||| [function_2] [function_1]	count=5
function_arg	[function_1] expr ||| [function_1] [arg_2]	count=2
function	homomorphism ||| hom	count=2
function	[function_1] multivariate ||| [function_2] [function_1]	count=1
function	general sine or cosine-type ||| sine cosine	count=1
function	for _minimal_polynomial_sq it selects ||| separate sq	count=1
class	ellipse ||| ellipse	count=3
function	gmpy mpq [function_2] ||| [function_2] [function_1]	count=2
function	and ||| func	count=1
class	return ||| piecewise	count=1
function	a ||| mod func	count=2
arg	of mpfval accuracy ||| prec target_prec	count=1
function_arg	solve the [arg_2] ||| [function_1] poly f symbol [arg_2]	count=1
arg	f ||| f m	count=9
arg	tuple m ||| m	count=1
class	those ||| series	count=1
function	lie group method ||| lie group	count=1
function	below fermi? ||| only below fermi	count=2
function	a polynomial from ||| poly from	count=4
class	the ground ||| poly	count=3
function_arg	gf [arg_2] ||| [function_1] gcdex f g [arg_2]	count=2
arg	given ||| s	count=1
module	case [module] cf algorithm ||| [module]	count=1
arg	an expr ||| expr	count=6
function_arg	free space [arg_2] ||| [function_1] diagonal [arg_2]	count=1
function	position ||| position	count=1
module	of this ||| functions elementary	count=2
function	equations [1]_ for a ||| equations	count=1
function	the letter [function_2] ||| [function_1] [function_2]	count=4
function	the limit of ||| limit	count=1
module	[module_1] of ||| [module_2] [module_1]	count=3
class	of subsset ||| subs	count=1
arg	the property prop ||| prop base strong_gens	count=1
class	that [class_2] ||| quantum [class_2] [class_1] operators	count=3
arg	d is not ||| d	count=1
function	[function_1] squares ||| [function_2] [function_1]	count=3
function	list of sympy ||| from sympy list	count=3
arg	f s ||| f s x	count=2
arg	of the terms ||| x x0 dir	count=1
class	field ||| field	count=1
arg	knots ||| knots	count=2
module	functions in ||| calculus	count=1
class	operator s [class_1] [class_2] eigenstate of ||| [class_2] [class_1]	count=1
class	for the ||| octave code gen	count=1
arg	the base b modulo ||| b	count=3
function	of coincidence routine ||| coincidence c	count=1
function	[function] of the ||| get [function]	count=1
function	sentinel of ||| sentinel	count=1
class	(i ||| series	count=1
function	common absolute ||| process common	count=1
function	the functions ||| not empty	count=1
function_arg	maximum norm [arg_2] ||| [function_1] [arg_2]	count=3
function	converts a term in ||| to	count=1
module	a, implies ||| domains	count=1
function	a line perpendicular to ||| perpendicular line	count=1
arg	objects and the relevant ||| objects merged_morphisms	count=1
function_arg	[function_1] f ||| [function_1] gcd [arg_2]	count=4
module	the ||| utilities	count=9
function	the forcing vector of ||| forcing full	count=1
module	logic operators and ||| logic	count=1
function	semi-latus rectum of ||| semilatus rectum	count=1
arg	a constant p ||| p	count=4
arg	limits should be of ||| func limits	count=1
function	traversal of ||| traversal	count=1
module	symbolic values ||| printing	count=1
arg	of f defined as ||| f k r	count=1
arg	two sets of expressions [arg_1] [arg_2] ||| series mrv max1 [arg_1] [arg_2]	count=3
function	can be written as ||| as	count=1
function	method to ||| method	count=1
module	the proper ||| printing	count=1
arg	the k-tuples of ||| k zeros	count=1
function	characters ||| indent	count=1
module	second frame is the ||| physics	count=1
arg	:func rsolve_hypergeometric for details ||| f x re	count=1
function	[function_1] of square-free ||| [function_2] [function_1]	count=6
function	disjoint negative root isolation ||| inner isolate negative	count=1
module	if ||| printing pretty	count=4
function	no bounding rectangles of ||| refine complexes	count=1
arg	compute ||| f x k	count=3
function	in terms of ||| hyper as	count=1
function	[function_1] mellin ||| [function_1] [function_2]	count=3
function	the proper line ||| get	count=1
arg	x_j of ||| f m j	count=1
function	rectangles ||| refine complexes	count=2
arg	[arg] gf ||| f [arg] p	count=2
function	non-commutative objects replaced ||| mask nc	count=1
function	the inverse mellin transform ||| inverse mellin transform	count=1
module	space characters ||| utilities	count=1
function	differential equation ||| ode	count=2
arg	to subtract [arg] ||| [arg]	count=3
function	list of irreducible ||| factor list	count=2
class	convert ||| integer ring	count=1
module	the result ||| utilities	count=1
function	create a quasi-particle? create ||| q creator	count=2
arg	of a in the ||| a	count=1
function	symbols ||| automatic symbols	count=1
arg	polynomials ||| g k	count=2
module	matrices ||| matrices expressions	count=2
class	the indexed object ||| indexed	count=1
function	forcing vector ||| forcing	count=2
function_arg	series [arg_2] ||| [function_1] min pow [arg_2]	count=1
function	lagrange's [function_2] ||| [function_2] [function_1]	count=3
function_arg	pseudo-remainder [arg_2] ||| [function_1] [arg_2]	count=2
arg	for internal use ||| s n	count=1
function	the asin ||| rs asin	count=1
function	using the horner scheme ||| dmp eval	count=2
function	[function_1] a square-free ||| [function_1] [function_2]	count=5
arg	[x] ||| k method	count=1
function	maximum [function_2] ||| [function_1] [function_2]	count=7
function_arg	polynomial f ||| poly f ring	count=1
arg	uncoupled tensor product ||| jcoupling_list	count=1
function	a row-sorted list ||| row list	count=2
module	to make ||| polys domains	count=1
class	of ||| poly ring	count=2
class	root [class] ||| [class]	count=3
class	mapping of symbolic ||| llvmjit code	count=1
function	full partial fraction decomposition ||| list full decomposition	count=1
function	[function_1] hankel transform ||| [function_1] [function_2]	count=3
arg	to yield origin ||| origin z	count=1
arg	eliminate x_0 from ||| u	count=1
function	a where ||| ground	count=3
arg	rs\_sin p [arg_2] ||| [arg_1] [arg_2]	count=2
module	of this sparsematrix ||| matrices	count=1
module	to self ||| core	count=1
function	has a [function_2] ||| [function_2] [function_1]	count=3
function	arguments of 'self' ||| args	count=1
arg	a given in ||| a	count=1
arg	of permutations of n ||| n	count=1
function	part [function] false otherwise ||| needs [function]	count=1
arg	from k0 [arg_2] ||| [arg_2] [arg_1]	count=1
class	point of all ||| point	count=1
arg	by [arg_2] ||| [arg_2] [arg_1]	count=6
function	hermite reduction ||| hermite	count=1
arg	optimization opportunities in ||| order	count=1
function	return the result ||| indent	count=1
function	an isotropic harmonic oscillator ||| e nl	count=1
arg	the routines [arg_2] ||| [arg_1] [arg_2]	count=3
arg	no ||| cls	count=1
function	computes the rank of ||| rank	count=1
function	apply [function_2] ||| [function_1] [function_2]	count=1
function	a rayleigh ||| rayleigh	count=1
function_arg	integer partition [arg_2] ||| [arg_2] [function_1]	count=1
arg	e is ||| e	count=1
module	of [module] computational ||| [module]	count=1
function_arg	increasing [arg_2] ||| [function_1] [arg_2]	count=2
function	perform the integration ||| doit	count=1
class	also known [class] 'rotation matrix' ||| coord [class]	count=1
function	multiply a ||| mul term	count=1
arg	value of ||| cls	count=1
function	list ||| list	count=20
arg	of ||| polys k eps	count=1
function	paths into ||| paths	count=1
function_arg	[function_1] of a ||| [function_1] expr [arg_2]	count=4
function	zeros square if ||| zeros	count=1
function	associate of a polynomial ||| poly	count=1
function	mpq to ||| qq	count=1
function_arg	the scaler-row [arg_2] ||| [arg_2] [function_1]	count=2
function_arg	[function_1] ops to ||| [arg_2] [function_1]	count=5
class	symbolic values to ||| code	count=1
function	existing structure on the ||| grow pseudopod	count=1
function	the linearizer ||| to linearizer	count=1
arg	true if [arg] on ||| [arg]	count=1
arg	[x] polynomial ||| symmetric	count=1
arg	and the object layout ||| grid	count=1
arg	two univariate ||| g	count=2
function_arg	adds a [arg_2] ||| [arg_2] [function_1]	count=6
arg	using hints ||| modulus power_base power_exp	count=1
function	be ||| limits	count=1
arg	at a ||| i a	count=1
function	[function_1] test evaluation ||| [function_1] [function_2]	count=1
function_arg	pseudo-remainder of [arg_2] ||| [arg_2] [function_1]	count=2
function	the jacobian matrix of ||| jacobian	count=1
module_class	[module_1] ray gives ||| [module_1] [class_2]	count=2
function	to a ||| to surface	count=1
function	remainder in gf ||| gf rem	count=3
function	special part of the ||| special	count=1
class	checks if the function ||| function	count=1
function	form of singularity functions ||| singularity function	count=1
arg	[arg_1] is the ||| [arg_2] [arg_1]	count=1
arg	[arg_1] [arg_2] ||| [arg_1] condition [arg_2]	count=1
class	the ||| fcode	count=1
arg	u ||| k reverse	count=1
arg	of square-free polynomial ||| polys	count=1
function	which comes under ||| 2eq order2 type11	count=1
function_arg	expression [arg_2] ||| [function_1] [arg_2] increment	count=2
class	permutation ie ||| permutation	count=2
function	a factor having root ||| choose factor	count=1
function_arg	[function_1] no ||| [arg_2] [function_1]	count=2
class	dimension ||| type c	count=1
function	[function_1] [function_2] ||| [function_2] linear constant coeff [function_1]	count=1
function	a multivariate ||| multivariate	count=1
arg	polynomial [arg_2] ||| [arg_2] [arg_1]	count=9
arg	modulus ||| modulus	count=1
function_arg	[function_1] [arg_2] ||| [function_1] reorder [arg_2]	count=1
arg	constructing ||| morphisms_str_info	count=1
function	centroid ||| centroid	count=1
function	roots ||| isolate real roots	count=2
class	for the generated ||| gen	count=2
function	a list of square-free ||| sqf list	count=1
function	to the ||| mod func	count=1
function	primitive form ||| dmp ground primitive	count=1
module	the index of ||| physics	count=3
function	quasi-particle? create ||| q creator	count=2
function	below fermi examples ||| below fermi	count=1
class	subsset ||| set	count=1
function	[function_1] puiseux ||| [function_1] [function_2]	count=1
module	on the ||| physics mechanics	count=1
arg	[arg_1] function out ||| [arg_2] [arg_1]	count=8
class	[class] of ||| multiset [class]	count=1
class	is ||| factory	count=1
function	orients the new ||| init	count=1
function	get a list ||| get	count=6
class	rational functions ||| frac	count=1
arg	the environment ||| pretty_print order use_unicode use_latex	count=1
class	create a new tids ||| tids	count=1
function	an ode ||| ode 1st homogeneous	count=1
module	a string path to ||| utilities	count=1
function_arg	[function_1] [arg_2] ||| [function_1] gcd [arg_2]	count=20
class	list ||| frac	count=1
function	product ||| tensor mul	count=1
class	a fockstateket else multiply ||| annihilate boson	count=1
function	to the same expression ||| to	count=1
function	[function_1] g*h ||| [function_2] [function_1]	count=14
arg	j_1 ||| j_1	count=1
arg	factors of target_units, whenever ||| target_units	count=1
module	a finite random ||| stats	count=1
arg	of an expression ||| expr syms	count=1
function	[function_1] number to ||| [function_2] [function_1]	count=3
arg	second order ||| func order match	count=1
arg	data ||| data	count=2
arg	k0 and ||| k0	count=1
function	tuples representing monomials ||| monomial	count=2
module	of a, implies ||| polys domains	count=1
function	leverage it if ||| try	count=1
class	product with ordered free ||| tens mul	count=1
arg	public key [arg_2] ||| [arg_2] [arg_1]	count=1
arg	contain nested ||| nested	count=1
function_arg	return encryption [arg_2] ||| [function_1] rsa [arg_2]	count=2
function	list into part ||| split list	count=1
arg	elements of t are ||| t	count=1
function	a ring ||| ring	count=2
function	functions to ||| function	count=1
arg	f in k[x], ||| f	count=2
arg	f ||| f n	count=8
arg	first order [arg_2] ||| [arg_2] infinitesimals func [arg_1]	count=1
arg	x examples ||| x	count=1
class	that ||| of	count=1
class	a_n ||| type a	count=1
arg	expansion ||| p x prec	count=5
function_arg	[function_1] local_dict ||| [function_1] [arg_2]	count=1
function	a rr ||| rr	count=1
arg	and o for ||| o	count=1
arg	order ||| order	count=19
arg	small'' ||| deg_f deg_g	count=1
function	cz^2 ||| to normal	count=1
class	with the ||| printer	count=1
arg	the element elem ||| elem	count=1
function	as g* a ||| as f	count=1
arg	[arg_1] > a ||| [arg_2] [arg_1]	count=1
class	with ||| code printer	count=2
function	y to x**m ||| inflate	count=1
arg	the point p ||| p	count=2
function	of ||| create param dict	count=1
arg	q are polynomials ||| q	count=5
module	eigenstate of [module] ||| [module]	count=3
function	the number [function_2] ||| [function_2] [function_1]	count=2
module_class	[module_1] point ||| [module_1] vector [class_2]	count=2
module	scanning process on the ||| combinatorics	count=1
arg	that the polynomial p ||| p	count=1
arg	of alpha as a ||| alpha	count=1
class	c ||| c	count=1
function_arg	[function_1] factors n ||| [function_1] [arg_2]	count=1
arg	about c i ||| n c condition	count=1
class	make the ||| generic	count=2
function	an ode from ||| ode 1st homogeneous	count=1
function	leverage ||| pretty try use	count=1
function	compute the degree of ||| degree	count=1
function_arg	[function_1] is replaced ||| [arg_2] [function_1]	count=4
function_arg	[function_1] p ||| [function_1] f [arg_2]	count=3
class	of non-conjugate ||| complex	count=1
function	to a fully contravariant ||| tensorhead from tensmul	count=1
class	expression ||| expr	count=3
arg	m_{\alpha} z )[x] with ||| minpoly p	count=1
arg	\* ||| dir pat init_only	count=1
function	postprocess an expression ||| postprocess for cse	count=1
function	to a ||| from tensmul	count=1
arg	expression ||| expr callback_type	count=1
function	square-free [function_2] ||| [function_2] factor [function_1]	count=1
class	data of the table ||| table	count=1
class	series ||| fourier series	count=1
function	using subresultants [function_2] ||| [function_2] [function_1]	count=18
arg	of ||| x n logx	count=1
function	class into a ||| mod func	count=1
function	scalar [function_2] ||| [function_1] [function_2]	count=15
function	[function_1] is ||| [function_2] [function_1]	count=5
arg	x_j in ||| n j	count=1
class	partition ||| partition	count=5
module	opportunities in ||| simplify	count=1
arg	as a meijer ||| a	count=1
function_arg	pseudo-quotient [arg_2] ||| [function_1] [arg_2]	count=2
arg	_match_div_rewrite ||| expr f g rexp	count=1
function	free indices ||| free indices	count=4
arg	of a [arg_2] ||| [arg_1] [arg_2]	count=35
function_arg	other, where [arg_2] ||| [arg_2] [function_1]	count=2
function	give the dimension ||| dim	count=1
function	negative coefficient ||| opt cse	count=1
arg	convert a ||| k1 a	count=24
arg	a ||| a b c	count=1
function_arg	[function_1] x of ||| [function_1] [arg_2]	count=3
arg	h are [arg_2] ||| [arg_1] [arg_2]	count=2
class	writes a ||| code gen	count=1
function	to which ||| to	count=1
class	with ordered ||| tens	count=1
function	the square root ||| sqrt	count=1
function	nth [function_2] ||| [function_1] [function_2]	count=2
arg	if all [arg] are ||| [arg]	count=1
arg	characters to the beginning ||| s	count=1
function	the scalar potential difference ||| scalar potential difference	count=1
arg	list range n ||| n	count=1
function	which when printed will ||| uniquely named	count=1
class	generate ||| free module quotient ring	count=1
class	polynomial [class_2] ||| [class_1] [class_2]	count=3
function_arg	transversals from [arg_2] ||| [arg_2] [function_1]	count=3
module	the given eigenstate ||| physics	count=1
function	medial ||| medial	count=1
function	to another ||| to	count=1
arg	to create annihilators using ||| base generator	count=1
module_class	of complex isolating ||| polys complex	count=1
module	s, ||| utilities	count=1
class	of a qexpr ||| qexpr	count=1
function	identity [function_2] ||| [function_1] [function_2]	count=1
arg	[arg_1] is suitable ||| [arg_2] [arg_1]	count=3
function	rational generating ||| guess generating	count=1
arg	as a ||| x a	count=1
arg	polynomial f in ||| f minpoly	count=1
arg	symbol [arg_2] ||| [arg_2] [arg_1]	count=1
class	generate a ||| free	count=2
arg	rank rank ||| rank	count=2
module	handles the default printing ||| physics quantum	count=1
function	[function_1] mul object ||| [function_1] [function_2]	count=2
function	best solution ||| best	count=1
function	[function_1] [function_2] for ||| [function_2] [function_1]	count=1
function	[function] matrixbase ||| [function]	count=2
module	to make a ||| polys domains	count=1
arg	occupations is a ||| occupations	count=1
function_arg	[function_1] [arg_2] to construct it and ||| [function_1] [arg_2]	count=1
function	to _eval_nseries if ||| nseries	count=1
function	the risch ||| risch	count=1
arg	the index ||| index	count=1
class	represents the ||| del	count=1
function	[function] = ||| special diop [function]	count=1
arg	bound ||| b cq	count=1
function	the next ||| next	count=3
module_class	does the [class_2] ||| [module_1] [class_2]	count=2
arg	subtracting ||| z	count=1
function	of this sparsematrix ||| eval	count=1
function	get [function_2] ||| [function_2] [function_1]	count=6
class	simple root [class] ||| type [class]	count=1
function	mapping of ||| param	count=1
arg	p [arg_2] ||| [arg_2] [arg_1]	count=72
arg	register the [arg_2] ||| [arg_2] [arg_1]	count=8
class	intersection in terms of ||| intersection	count=1
class	singularity function expression using ||| singularity function	count=1
function	add two [function_2] ||| [function_1] [function_2]	count=5
module	to rearrange the ||| physics	count=1
function_arg	generated [arg_2] ||| [function_1] code [arg_2]	count=1
class	a standard basis ||| sub module poly	count=1
function	factor polynomials ||| dmp factor	count=1
function_arg	[function_1] composite polynomial ||| [arg_2] [function_1]	count=4
function_arg	derivative of [arg_2] ||| [function_1] [arg_2]	count=4
arg	for ||| tri	count=1
function	from gray [function_2] ||| [function_1] [function_2]	count=1
function	truth value of the ||| eval cond	count=1
function	function with name ||| function	count=1
function	pairs ||| pairs	count=1
function	return [function_1] [function_2] given interval ||| [function_1] [function_2] expression interval symbol	count=1
arg	eq with ||| eq	count=1
function	linear [function_2] ||| [function_2] [function_1]	count=7
function_arg	[function_1] cf ||| [function_1] convergents [arg_2]	count=1
function	a zeros matrix for ||| matrix zeros	count=1
arg	compute the ||| f	count=12
class	lagrange multipliers ||| lagranges	count=1
arg	tri to [arg_2] ||| [arg_1] welding_edge [arg_2]	count=4
function	at a point or ||| call	count=1
function	which the triangle ||| find triangle	count=1
class	matrix with elements represented ||| matrix	count=1
arg	mul sorted in canonical ||| mul	count=1
module	into a string path ||| utilities	count=1
class	rectangles ||| complex root	count=1
function	sum of k ||| sum of	count=1
arg	phrase [arg_2] ||| [arg_1] [arg_2]	count=1
arg	sm ||| sm	count=2
function	intrinsic impedance ||| intrinsic impedance	count=2
function	direct product ||| mul	count=1
function_arg	[function_1] scalar ||| [function_1] [arg_2]	count=6
function	and return ||| indent	count=1
function	to gray ||| bin to gray	count=2
function	in terms of ||| in terms of	count=3
class	[class_1] method ||| [class_1] [class_2]	count=1
class	for the function ||| function	count=1
function	about 0 ||| rs series	count=1
module_class	the line ||| geometry linear	count=1
function	of the functions in ||| in	count=1
arg	returns the energy [arg_1] [arg_2] ||| physics energy [arg_2] [arg_1]	count=1
module	which the ||| geometry	count=2
function	potential function of ||| potential	count=2
function_arg	a new [arg_2] ||| [function_1] [arg_2]	count=1
function	operator classes to ||| operators to	count=1
function	+ g*h ||| dmp add mul	count=2
arg	orbit [arg] no ||| [arg]	count=1
function	the extension ||| extension	count=1
arg	a literal ||| lit	count=1
arg	dx using g ||| g	count=1
arg	n and either a ||| factors n	count=1
arg	a ||| a n p	count=1
module	assumptions system ||| assumptions	count=1
class	initialize ||| pretty form	count=1
class	body orientation takes this ||| body orienter	count=1
function	[function] represents the ||| [function]	count=2
arg	convert a ||| a	count=1
class	files ||| octave code	count=1
arg	types for function arguments ||| func_args	count=1
arg	expression ||| expr x y	count=1
arg	n ||| n nth	count=1
class	this method ||| series	count=1
function	inhomogeneous ||| rsolve ratio	count=1
arg	separation approach ||| fun sep strategy	count=1
function	add [function_2] ||| [function_2] [function_1]	count=2
arg	and returns the ||| msg key	count=1
function	series expansion ||| intcurve series	count=1
function	multiply a [function_2] ||| [function_2] [function_1]	count=4
function	potential [function_2] ||| [function_1] [function_2]	count=6
arg	a, d = b ||| b	count=1
function	returns the inverse of ||| inverse	count=2
function	an [function_1] [function_2] ||| [function_2] class [function_1] func_class f symbol	count=4
function	primitive polynomial [function_2] ||| [function_2] [function_1]	count=2
function	restricted to values below ||| only below	count=1
arg	to the beginning ||| s	count=1
function	the functions in ||| empty in	count=1
function	generates n-th swinnerton-dyer polynomial ||| swinnerton dyer poly	count=1
function_arg	[function_1] to n ||| [function_1] of squares [arg_2]	count=1
arg	reduces expression ||| expr	count=1
function	of the atan of ||| atan	count=1
function	muls ||| opt	count=1
function	into a ||| mod	count=1
function	separate ||| separate	count=1
function_arg	term in p ||| term p	count=2
class	body orientation takes ||| body	count=1
arg	for constructing the ||| morphisms_str_info	count=1
module	branching ||| strategies branch	count=1
function_arg	[function_1] for f ||| [function_1] puiseux2 [arg_2]	count=1
module	replaced with [module] ||| [module]	count=1
function	of eye ||| eye	count=1
arg	mapping in rules ||| rules	count=1
function	"get a zeros ||| zeros	count=1
arg	a vector constants ||| variable constant k	count=1
function	the inverse ~a of ||| af invert	count=1
function	[function_1] factors ||| [function_1] [function_2]	count=3
function	of indices corresponding ||| indices	count=1
function	construct field [function_2] ||| [function_2] [function_1]	count=2
module	augments qdots to the ||| physics	count=1
arg	whether indices are ||| indices free	count=1
arg	b the first ||| b	count=1
arg	in t ||| f t	count=2
function	generates cyclotomic polynomial of ||| cyclotomic poly	count=1
arg	equation eq by ||| eq param syms permute	count=1
function_arg	domain of f ||| domain f	count=2
function	finds the domain of ||| empty	count=1
arg	[arg] < 2^64 ||| [arg]	count=1
function	inverse laplace [function_2] ||| [function_2] [function_1]	count=2
function	a property where ||| memoize property	count=1
class	generate a ||| module quotient ring	count=1
function	the length ||| length	count=3
function	smallest primitive root or ||| primitive root	count=1
class	the picture in ||| string pict	count=1
function	singularity ||| rewrite as singularity	count=1
function	k squares false if ||| squares	count=1
module_class	returns tensor product ||| tensor tens mul	count=1
class	of symbolic ||| llvmjit code	count=1
class	will exist when the ||| integral	count=1
arg	k-tuples ||| k zeros	count=1
function	expand the ||| expand	count=1
function	rational ||| integer rational	count=1
arg	acquire a readable object ||| pkgname	count=1
function	a list into ||| split list	count=1
function	start stop ||| process limits	count=1
arg	strip ||| strip	count=1
function_arg	roots of [arg_2] ||| [arg_2] [function_1]	count=14
class	a standard basis ||| module poly ring	count=1
function	elastic curve or deflection ||| deflection	count=1
function	system using lusolve and ||| system lu	count=1
module	to the ||| utilities	count=2
function	to a ||| tensorhead from	count=1
function	be the primitive ||| primitive	count=1
function	compute f * a ||| mul	count=1
arg	length [arg_2] ||| [arg_1] [arg_2]	count=1
arg	of order n ||| n	count=3
function	map x_i**m_i [function_2] ||| [function_1] [function_2]	count=3
module	with [module] examples ||| [module]	count=1
function	z i ||| zgate	count=1
arg	to rewrite [arg] using a ||| [arg]	count=1
function	pseudo-remainder ||| prem	count=2
function	coefficients ||| dmp ground content	count=1
arg	required for constructing the ||| morphisms_str_info	count=1
function	[function] given interval ||| is [function]	count=1
function	directional [function_2] ||| [function_2] [function_1]	count=3
module	of ||| functions elementary	count=2
function	denominators but keep the ||| denoms	count=1
class	basis in ||| poly	count=1
function	f ||| eval integral	count=1
class	associative ||| free group element	count=5
function_arg	length of [arg_2] ||| [function_1] [arg_2]	count=2
arg	u v ||| u v	count=2
class	coordinate of ||| point3d	count=1
function_arg	[function_1] [arg_2] objects ||| [function_1] [arg_2]	count=4
module	the variables ||| physics vector	count=1
function	the opening statements ||| opening	count=2
class	the ||| type	count=1
class	copy ||| mutable dense matrix	count=1
function	function to ||| func	count=1
module	the integration ||| integrals	count=1
arg	[arg_1] point pt ||| [arg_2] [arg_1]	count=1
function	the set of triangles ||| list triangles	count=1
function	length of a ||| morphism length	count=1
function	jacobian matrix ||| jacobian	count=1
function_arg	[function_1] of the ||| [arg_2] [function_1]	count=1
function	the domain ||| empty	count=1
function	is not zero and ||| is zero	count=1
function	returns magnetic permeability ||| permeability	count=1
function	the derivative ||| derivative	count=1
function_arg	expression in local_dict ||| expr s local_dict	count=1
function	the form x start ||| limits	count=1
function	s, and ||| indent	count=1
module	given vector in given ||| vector	count=1
arg	information required for constructing ||| morphisms_str_info	count=1
function	below fermi? >>> ||| below fermi	count=1
function	unknown function that ||| search function	count=2
class	symbolic values to ||| llvmjit code	count=1
arg	modulo p for two ||| p	count=1
function_arg	[function_1] expr ||| [function_1] min pow [arg_2]	count=2
arg	rhs ||| rhs	count=1
arg	the fundamental strip ||| x strip	count=1
arg	the given level ||| level args	count=1
function	name of the ||| get mod	count=1
function	returns the symbols in ||| free symbols	count=1
arg	method should recursively remove ||| radical clear	count=1
function	part of a polynomial ||| part	count=1
function_arg	of operators ops ||| operators obj ops	count=1
class	generated files ||| gen	count=2
module	productsets ||| sets	count=1
function_arg	multiply [arg_2] ||| [function_1] term [arg_2]	count=2
function	be the union ||| union	count=1
function	to replace constants ||| simplify variable	count=2
module	this ||| categories	count=3
arg	internal use by the ||| s	count=1
class	curve is not made ||| curve	count=1
function	shift ||| shift	count=1
arg	about c i ||| c condition	count=1
function	numerator parameters ||| ap	count=1
arg	indices in group of ||| indices	count=1
module	returns tensor ||| tensor	count=2
function	& operator ||| and	count=1
function	evaluate the ||| eval	count=2
function	form kane's equations ||| kanes equations	count=1
function	to correct the ||| correct signature	count=1
function	a list of irreducible ||| factor list	count=2
class	of the patterns ||| properties	count=1
module	dtype ||| polys domains	count=1
function	find_unit_clause but arguments ||| clause	count=1
function	is ||| not	count=1
arg	[arg_1] defined as ||| [arg_1] [arg_2]	count=2
arg	p - ||| p	count=1
arg	[arg_1] == j ||| [arg_1] [arg_2]	count=1
arg	terms of ||| x m	count=1
function	the unique [function] of ||| multiset [function]	count=1
function	for ||| cg simp	count=1
function_arg	trailing coefficient [arg_2] ||| [function_1] [arg_2]	count=1
function	are free [function_2] ||| [function_1] [function_2]	count=1
class	an object of ||| expr	count=1
function	[function_1] rank of ||| [function_2] [function_1]	count=3
function	lcm over ||| ff lcm	count=1
function	domain of ||| empty	count=1
function	[function_1] tests ||| [function_2] [function_1]	count=2
function	direction ratio of a ||| direction cosine	count=1
function	sequences ||| seq	count=1
function	module ||| get mod	count=1
module	return a set ||| agca	count=1
function	convert an algebraic ||| algebraic	count=1
class	subset ||| subset	count=9
module	stub to allow ||| core	count=1
function	[function] given ||| is [function]	count=1
function_arg	[function_1] (i ||| [function_1] [arg_2]	count=6
class	self ||| base	count=1
arg	[arg_1] ex2 parameters ||| [arg_2] [arg_1]	count=2
function	every rational ||| rational	count=1
module	finite_set ||| calculus	count=1
function	[function_1] lower-hessenberg form ||| [function_2] [function_1]	count=1
arg	p [x] ||| p k	count=22
arg	public key [arg_2] ||| crypto encipher elgamal [arg_2] [arg_1]	count=1
function	[function_1] the substitution ||| [function_1] [function_2]	count=3
function	full partial fraction decomposition ||| apart list full decomposition	count=1
class	cython file ||| cython	count=1
function	according to whether ||| signature from indices	count=1
arg	the grid adds ||| grid	count=1
function	[function_1] of partitions ||| [function_1] [function_2]	count=3
arg	tensmul object it ||| tensmul	count=1
function	as a [function_2] ||| [function_2] [function_1]	count=3
function	reconstruct ||| rational reconstruction func	count=1
arg	col [arg_2] ||| [arg_2] [arg_1]	count=2
function	[function_1] a function ||| [function_2] [function_1]	count=1
arg	x start ||| func	count=1
function	returns the transposed sparsematrix ||| eval transpose	count=1
function	the asin of ||| asin	count=1
function	converts a ||| letter form to	count=1
class	a single basis ||| var bosonic basis	count=2
arg	a function ||| function	count=3
function	cyclotomic ||| cyclotomic	count=1
arg	[arg_1] subtracting pt ||| scale [arg_1] [arg_2]	count=1
arg	of the seq ||| seq	count=1
module	are ||| integrals	count=1
arg	for shifting i ||| base generator	count=1
module	a [module] expectation ||| [module]	count=1
function_arg	numerator [arg_2] ||| [arg_2] [function_1]	count=1
function	the limit of each ||| limit	count=1
function	handle dummy symbols ||| dummy eq	count=1
arg	gcd a [arg_2] ||| [arg_1] [arg_2]	count=4
module	true if the ||| physics	count=1
arg	of the ||| x x0	count=1
function	mapping of symbolic ||| param dict	count=1
function	function to its ||| simplify	count=1
module	be of the ||| series	count=1
arg	circuit ||| circuit	count=3
arg	p_i ||| p_i	count=1
class	the group ||| group	count=6
function	rows in ||| height	count=1
module	formal power series ||| series	count=2
arg	tan or ||| rv	count=1
function	adjacency matrix ||| get adjacency matrix	count=1
function_arg	gcd of [arg_2] ||| [arg_2] [function_1]	count=19
function	the primitive root ||| primitive root	count=2
function	that helps find ||| search	count=1
function	of transitivity ||| transitivity	count=1
function_arg	[function_1] [arg_2] ||| [function_1] dumx [arg_2]	count=1
module	the class ||| physics	count=1
function	method converts a list ||| letter form to	count=1
class	delta ||| kronecker delta	count=2
class	is currently ||| factory	count=1
module	handles the default ||| physics	count=1
function	for finding powers of ||| af pow	count=1
class	basis ||| var bosonic basis	count=1
function	alpha and [function_2] ||| [function_1] [function_2]	count=1
function	floor ||| floor	count=1
module	value of ||| functions	count=1
class	the homomorphism obtained ||| module homomorphism	count=1
function	time [function] algorithm ||| [function]	count=2
function	a plan consisting of ||| plan	count=1
function	in terms of ||| as	count=1
arg	a field [arg_2] ||| [arg_2] [arg_1]	count=1
module	a standard basis in ||| polys	count=1
function	alpha [function_2] ||| [function_1] [function_2]	count=1
function	if possible ||| try	count=1
function	[function_1] a sympy ||| [function_2] [function_1]	count=6
function	parametric surface plot ||| parametric surface	count=1
module	< ||| combinatorics	count=1
function_arg	[function_1] name and ||| [arg_2] [function_1]	count=2
arg	of polynomials ||| g	count=1
module	given ||| combinatorics	count=1
arg	[arg_1] respect to ||| [arg_2] [arg_1]	count=2
function	this method converts ||| form to	count=1
function	is [function_2] ||| [function_2] [function_1]	count=103
arg	two univariate ||| g p	count=1
arg	of p1 ||| p1	count=1
arg	input k ||| k	count=1
arg	[arg_1] x ||| [arg_2] [arg_1]	count=33
module	return a set of ||| agca	count=1
arg	factors n ||| factors n	count=2
class	a quasi-particle? annihilate hole ||| fermion	count=1
class	an element ||| generalized	count=1
module	\frac{d\chi}{dx} + ||| solvers	count=1
function	transpose of ||| transpose	count=1
function	operator classes to ||| to	count=1
function	tangent to the ellipse? ||| tangent	count=1
function	the normalized [function] ||| [function]	count=3
arg	[arg_1] [arg_2] ||| [arg_2] s [arg_1]	count=4
arg	[arg_1] with p ||| [arg_2] [arg_1]	count=1
function	minimal polynomial for ||| minpoly op algebraic element	count=1
function	diagonal morphism [function_2] ||| [function_2] [function_1]	count=4
class	of a polynomial ||| poly	count=6
function	ordinary if ||| ord	count=1
function	module ||| func	count=1
function	of undetermined ||| undetermined	count=1
function	javascript code parameters ||| jscode	count=1
function	of tensor ||| tensor	count=2
arg	as a single g ||| x a	count=1
function	zeros [function_2] ||| [function_2] [function_1]	count=6
arg	order the purpose ||| verbose	count=1
function	returns the order ||| order	count=5
arg	for displaying [arg] representation's ||| [arg]	count=1
function_arg	[function_1] the grid ||| [arg_2] [function_1]	count=2
function	[function_1] mises distribution ||| [function_1] [function_2]	count=2
function	[function_1] l1 ||| [function_1] [function_2]	count=1
function	[function] prufer sequence ||| [function]	count=3
function	symbols in ||| symbols	count=3
function	the atanh of p, ||| atanh	count=1
function	scalar potential difference between ||| scalar potential difference	count=1
function_arg	term [arg_2] ||| [function_1] f [arg_2]	count=1
module	[module] or only ||| [module]	count=2
function_arg	list from [arg_2] ||| [function_1] [arg_2]	count=2
function	p a is ||| is	count=1
function	compute ||| multivariate p	count=1
function	restricted with respect ||| restricted	count=1
function	difference ||| difference	count=2
function	in gf p [x] ||| dup gf	count=1
function	intervals are disjoint ||| disjoint	count=1
arg	g when ||| g	count=1
arg	p0 ||| dumx_flat p0	count=1
function_arg	subs [arg_2] ||| [arg_2] [function_1]	count=2
function	finite_set in ||| empty	count=1
function	symbols ||| constant symbols	count=1
class	that take on ||| series	count=1
function	leading coefficient of ||| gf lc	count=1
function	computes polynomial lcm over ||| dmp ff lcm	count=1
function	expr with ||| get integer	count=1
module	[module_1] unit name ||| [module_1] [module_2]	count=2
arg	of f ||| f m n j	count=1
function_arg	polynomial gcd [arg_2] ||| [arg_2] [function_1]	count=6
function	display the string representation ||| str	count=1
function	domain of the functions ||| in	count=1
arg	by sets and l ||| sets	count=1
function	ecart ||| sdm ecart	count=1
function	multiply a labeled ||| lbp mul	count=3
function	to ||| pow	count=1
function	generates legendre [function_2] ||| [function_1] [function_2]	count=1
function	new rootsystem object this ||| new	count=1
function	as a comment ||| get comment	count=1
module	[module_1] system ||| [module_1] [module_2]	count=4
arg	morphisms of the diagram ||| diagram	count=1
arg	base and ||| group base	count=1
arg	parameter c ||| c	count=1
arg	f in k[x] ||| f u k	count=6
function	cartan matrix ||| cartan matrix	count=3
function	matrix representation this ||| matrix	count=1
function	an empty column ||| column	count=1
function	returns the transformation matrix ||| transformation to	count=1
function	finite_set ||| not	count=1
function_arg	[function_1] [arg_2] ||| [function_1] diff derivative [arg_2]	count=4
function	the conjugate of a ||| conjugate	count=1
function	interior of ||| interior	count=1
arg	return [arg_1] [arg_2] with int 1 so ||| core prod [arg_1] [arg_2]	count=1
function	a nested tuple ||| to tuple	count=1
function	mignotte bound for ||| zz mignotte bound	count=2
arg	q are in z[x] ||| q x	count=2
function	[function_1] k squares ||| [function_2] [function_1]	count=3
arg	free and dum ||| free dum	count=3
arg	\; j_2 [arg_2] ||| [arg_1] [arg_2]	count=1
function	operator classes to their ||| operators to	count=1
function	maximum proper divisor of ||| max div	count=1
function	a morse ||| morse	count=1
function	[function_1] base ||| [function_1] [function_2]	count=1
arg	x representing a monomial ||| x	count=1
class	function ||| holonomic function	count=3
class	generated files ||| fcode gen	count=1
function	forcing vector of ||| forcing	count=1
function	in finite_set ||| empty	count=1
module	every [module] unique ||| [module]	count=2
function	[function_1] on a ||| [function_2] [function_1]	count=4
function	minimal polynomial of sin ||| sin	count=1
arg	f and ||| a	count=1
arg	convert a k[x] polynomial ||| f u k zero	count=1
class	rotation ||| sys cartesian	count=1
function	scalar [function_2] ||| [function_2] [function_1]	count=17
class	method ||| method	count=1
function	coefficient of a summation ||| coeff add	count=3
arg	to an accuracy ||| subs maxn chop	count=1
class	non-conjugate ||| complex root of	count=2
arg	if a circuit ||| circuit	count=1
function_arg	hilbert space [arg_2] ||| [function_1] [arg_2]	count=1
arg	f in k[x] ||| f c i u	count=1
arg	[arg_1] m_1 ||| [arg_2] [arg_1]	count=1
arg	coefficient ||| order	count=1
arg	f g are polynomials ||| f g x	count=1
arg	performs scaler ||| scaler k	count=1
class	of the point in ||| point	count=1
arg	[inf sup] ||| k inf sup	count=1
function	apply ||| apply operator	count=2
arg	given order order ||| order	count=1
function	[function_1] function with ||| [function_1] [function_2]	count=1
class	returns the ||| g	count=1
module_class	gcd of polynomial ||| polys poly	count=1
arg	k[x] ||| u k	count=22
function	is iterable or not ||| is iterable	count=1
module_class	computes the [class_2] ||| [module_1] [class_2]	count=2
function	rank of ||| rank	count=4
function	hankel ||| hankel	count=3
arg	less than other ||| other	count=1
module	list of expressions as ||| integrals	count=1
arg	and b have the ||| b	count=1
arg	to function arguments ||| func_args	count=1
function	a row-sorted list of ||| row list	count=1
function_arg	returns lhs - ||| inverse lhs	count=1
class	returns a ||| poly	count=1
function	map x**m to y ||| multi deflate	count=1
function	[function_1] expand ||| [function_2] [function_1]	count=14
function	use lu the decomposition ||| det lu	count=1
arg	are in ||| x method	count=1
function	list into part a ||| split list	count=1
function	[function_1] mises ||| [function_1] [function_2]	count=2
function	[function_1] mpq ||| [function_2] [function_1]	count=14
function	[function_1] factors ||| [function_2] [function_1]	count=5
module_class	[module_1] factors of ||| [module_1] [class_2]	count=4
arg	type of ||| x y	count=3
function	a root of ||| indexed root	count=1
function	solve a system of ||| solve	count=1
function	common ending of sequences ||| common suffix	count=1
function	differentiate and [function_2] ||| [function_1] [function_2]	count=4
module	a string ||| utilities	count=1
class	printer for ||| num py printer	count=1
function	real ||| real field	count=1
module	matrix and returns ||| matrices	count=2
function	altitudes ||| altitudes	count=1
function_arg	their [arg_2] ||| [arg_2] [function_1]	count=1
arg	certain coordinate ||| point1 point2	count=1
function	[function_1] to dtype ||| [function_2] [function_1]	count=24
class	for f ||| hyper rep	count=1
function	amplitude ||| amplitude	count=1
function	hermite [function_2] ||| [function_2] [function_1]	count=1
arg	returns true if f ||| f	count=13
function	the basic [function_2] ||| [function_1] [function_2]	count=3
class	basis ||| sub	count=1
arg	prime with p == ||| p	count=1
class	this complex ||| complex	count=1
function	heuristic ||| lie heuristic	count=3
function	whose presentation is ||| presentation	count=1
function	the substitution [function_2] ||| [function_1] [function_2] eq func	count=1
function	the quadratic ternary diophantine ||| diop ternary quadratic	count=1
function	construct lagrange interpolating ||| interpolating	count=1
function	imaginary part of ||| imag	count=1
arg	tri [arg_2] ||| [arg_2] [arg_1]	count=4
function	of free [function_2] ||| [function_1] [function_2]	count=5
arg	ex see http //mathworld ||| ex x	count=2
arg	over [arg] >>> from ||| f [arg]	count=1
function	string ||| mod	count=2
function_arg	[function_1] given interval ||| [arg_2] [function_1]	count=17
arg	condition ||| condition	count=1
class	two multivariate fractions ||| dmf	count=3
function_arg	a square-free [arg_2] ||| [function_1] [arg_2]	count=3
function	cyclic notation from ||| cyclic form	count=1
arg	polynomial in ||| f p u k	count=1
module	return -1 0 1 ||| core	count=1
function	whether function [function_2] ||| [function_2] [function_1]	count=4
function	cyclic notation from the ||| cyclic form	count=1
function_arg	rational numbers v ||| rational v x	count=2
arg	triangles ||| triangles edges	count=1
function	buckets for ||| buckets	count=1
class	of stringpicts ||| pict	count=1
arg	the given ||| s	count=1
function_arg	groups i ||| comm i	count=1
function	clause to the theory ||| clause	count=1
function_arg	[function_1] polynomials in ||| [function_1] [arg_2]	count=4
arg	is the term ||| r n limits	count=1
function	from [function_2] ||| [function_2] [function_1]	count=15
module	implementation [module_2] ||| [module_1] [module_2]	count=3
function	presentation is to ||| presentation	count=1
function	the inverse hankel transform ||| inverse hankel transform	count=1
arg	internal use ||| s n	count=1
function	characters to the ||| indent	count=1
function	primitive root of ||| primitive root	count=2
function	[function] between ||| set dict [function]	count=2
class	entries outside ||| properties	count=1
arg	in f ||| f	count=4
arg	[arg_1] coefficient d ||| [arg_1] [arg_2]	count=2
function_arg	remove [arg_2] ||| [arg_2] [function_1]	count=2
function	construct a new ||| new	count=3
function_arg	function simplifies a boolean [function_1] [arg_2] ||| [function_1] [arg_2]	count=1
arg	polynomial ||| poly	count=6
function	[function] from terms ||| [function]	count=2
module	args [module] *are* exprs ||| [module]	count=1
function	in ||| cse	count=1
function	clairaut ||| nonlinear 2eq order1 type5	count=1
arg	create [arg] continuous random ||| name [arg]	count=1
class	returns a standard basis ||| sub module poly	count=1
class	proper line ending ||| code printer	count=1
function	add ||| add	count=19
class	are generated automatically ||| differential extension	count=1
function	a bubble [function] ||| gate [function]	count=2
module	the get_dim ||| physics units	count=1
arg	key must be a ||| key	count=1
function	to ||| connect to	count=1
arg	compute numerical approximations of ||| n maxsteps cleanup	count=2
function	order on ||| order	count=1
function	the module ||| mod func	count=1
function	[function_1] number ||| [function_1] [function_2]	count=3
module	of time in the ||| physics	count=1
function_arg	[function_1] h ||| [function_1] [arg_2]	count=4
function	return a vector ||| vector	count=1
arg	of f in ||| f symbol	count=1
function	generated files ||| get	count=2
class	string of ||| string	count=1
arg	the argument passed by ||| k	count=1
function	horner scheme ||| dmp eval	count=2
function	single gamma [function_2] ||| [function_2] [function_1]	count=3
module	matrix multiplication one ||| matrices	count=1
function	or deflection ||| deflection	count=1
arg	cls given a ||| cls rep lev dom	count=2
module	that ||| polys	count=1
function_arg	pairs [arg_2] ||| polys dmp apply [function_1] [arg_2]	count=2
function	full partial [function_2] ||| [function_1] [function_2]	count=2
function	and evaluate ||| eval	count=1
function	separated [function] ||| convert to native [function]	count=3
class	rectangles of non-conjugate ||| complex	count=1
arg	[arg_1] j_2 ||| [arg_2] [arg_1]	count=1
function	the name ||| mod	count=1
class	real [class_2] ||| [class_1] [class_2]	count=1
class	[class_1] array ||| [class_2] [class_1]	count=3
function	specific integer ||| modular integer	count=1
function	submodule ||| submodule	count=6
module	split into multiple tokens ||| parsing	count=1
module	the integration using ||| integrals	count=1
arg	variable with a ||| name alpha beta	count=1
arg	opportunities ||| exprs order	count=1
arg	of ||| k	count=1
arg	to ||| func	count=1
function_arg	[function_1] two labeled ||| [function_1] f [arg_2]	count=1
arg	differential equation with ||| match	count=2
function	ode are ||| 2eq order1	count=1
arg	of f ||| f	count=102
arg	the k-tuples ||| k zeros	count=1
function	a holonomic ||| holonomic	count=1
function_arg	a to [arg_2] ||| [function_1] sympy [arg_2]	count=8
class	returns an object ||| expr	count=1
function	accuracy [function] number with ||| [function]	count=1
function	creates the generating reflections ||| generators	count=1
function	with constant [function_2] ||| [function_1] [function_2]	count=3
function	add ||| indent	count=1
function	string ||| get mod	count=2
arg	substitutes corresponding sols ||| sols	count=1
function	[function_1] fermi? >>> ||| [function_1] [function_2]	count=8
class	method for equality ||| immutable	count=1
module	this method returns the ||| series	count=1
function_arg	resultant of [arg_2] ||| [function_1] f [arg_2]	count=1
function	the log hint see ||| log	count=1
module	return the ||| matrices	count=1
function	slope the ||| slope	count=1
function	paths into [function_2] ||| [function_2] [function_1]	count=2
function	of blockmatrices ||| deblock	count=1
arg	col that is suitable ||| col iszerofunc simpfunc	count=1
module	computing formal power series ||| series	count=1
arg	[arg_1] b the ||| ntheory digits [arg_1] [arg_2]	count=2
function	positive ||| positive	count=10
class	specific value (i ||| series	count=1
arg	of the terms of ||| x x0 dir	count=1
arg	takes clauses in cnf ||| clauses	count=1
arg	beta distribution ||| alpha beta	count=1
arg	i [arg_2] ||| [arg_1] [arg_2]	count=3
arg	in k ||| f p k	count=2
function	is ||| not empty in	count=1
arg	[arg_1] t ||| [arg_1] [arg_2]	count=8
function	to ||| create param	count=1
function	minimal polynomial of cos ||| minpoly cos	count=1
function	polynomial [function_2] ||| [function_2] [function_1]	count=14
function	geometric entity parallel to ||| parallel	count=1
class	of this sparsematrix ||| sparse	count=1
class	the column matrix f ||| symbolic system	count=1
function	diagram ||| xypic string	count=1
module	returns the ||| matrices	count=1
function	(mod(p**k)) does/doesn't exist ||| nthpow residue bign prime power	count=1
function	derivatives for ||| diff	count=1
function_arg	scalar multiplication c ||| mul scalar c	count=1
arg	[arg_1] respect to ||| [arg_1] z [arg_2]	count=2
arg	of f and ||| a d de	count=1
function_arg	element x ||| element x	count=1
arg	the given expression ||| expr	count=4
arg	not [arg] ||| [arg]	count=1
arg	irreducibility test over ||| p	count=1
function	leverage it ||| pretty	count=1
class	c matrix ||| dense matrix	count=1
arg	and \eta to ||| match comp	count=1
class	a group ||| group element	count=1
function	acceleration ||| acc	count=2
function	if a is of ||| of	count=1
arg	self and s2 ||| s2	count=1
arg	function for :func _factor ||| opt method	count=1
arg	the [arg] ||| f [arg]	count=1
arg	fringe and returns ||| fringe grid	count=2
class	generators from [class] inject them ||| [class]	count=1
class	a line ||| line	count=1
class	a list of ||| frac field	count=1
class	[class_1] until ||| [class_2] [class_1]	count=6
function	= m where \gcd ||| cornacchia	count=1
arg	the polynomial p ||| p	count=1
arg	difference of a ||| a	count=1
function	of the derivative of ||| diff	count=1
function	written as g* ||| as	count=1
function	a polynomial ring i ||| old poly ring	count=1
module	formats ||| printing	count=1
class	an element in ||| element	count=1
function	define the system of ||| classify sysode	count=1
function	[function_1] polynomial for ||| [function_2] [function_1]	count=4
function_arg	the orbit [arg_2] ||| [function_1] transversal [arg_2]	count=3
function	circumcenter is the ||| circumcenter	count=1
function	in k[x] ||| dup	count=32
function	the total ||| total	count=1
arg	old ||| old	count=1
function	the lie [function_2] ||| [function_1] [function_2]	count=4
function	function that ||| search function	count=2
function	is ||| empty	count=1
class	root ||| root	count=3
class	[class_1] with ||| tensor [class_2] [class_1]	count=1
function	quadrants ||| intervals to quadrants	count=1
function	python fraction [function_2] ||| [function_2] [function_1]	count=2
function	in a group ||| group	count=1
function	form examples ||| as	count=1
arg	common subexpression elimination ||| optimizations	count=2
module	to make ||| domains	count=1
function	multinomial [function_2] ||| [function_1] [function_2]	count=2
function	gcd of two univariate ||| gcd	count=1
module	the two class ||| combinatorics	count=1
arg	algorithm ||| f x extension	count=1
function	string path to a ||| mod	count=1
function	to ||| signature from	count=1
function	as ||| as numer	count=1
function_arg	a gf [arg_2] ||| [function_1] sqf part [arg_2]	count=3
function	full partial ||| list full	count=1
function	inverse mellin [function_2] ||| [function_1] [function_2]	count=2
class	the ||| octave code	count=1
arg	of f and ||| a d de z	count=1
function	[function_1] of two ||| [function_2] [function_1]	count=2
arg	key [arg_2] ||| crypto encipher elgamal [arg_2] [arg_1]	count=1
function	which the triangle ||| triangle	count=1
arg	is return an ||| expr	count=1
function_arg	[function_1] p ||| [function_1] iter a [arg_2]	count=1
class	window ||| window	count=1
function	fraction object ||| qq	count=4
module	returns whether the ||| combinatorics	count=1
function	as an ||| as	count=1
function_arg	mod [arg_2] ||| [function_1] a [arg_2]	count=1
function	[function_1] module ||| [function_2] [function_1]	count=8
function	the asin of p, ||| asin	count=1
module	the total number ||| liealgebras	count=1
arg	subgroup of gr ||| gr	count=1
arg	b m + b, ||| a b a b	count=1
class	complex isolating ||| complex	count=1
function_arg	module of [arg_2] ||| [arg_2] [function_1]	count=3
function	set the new ||| set	count=1
arg	a coordsyscartesian with its ||| vector_names	count=1
function	of singularity functions ||| rewrite as singularity function	count=1
function	to a sympy matrix ||| to sympy	count=2
function	the sides ||| sides	count=1
class	or product ||| expr with	count=1
function	returns the position ||| position wrt	count=1
class	the linearentity ||| linear entity	count=1
function	and a polynomial ||| poly	count=1
module	or containers ||| polys	count=1
module	excluding those that ||| series	count=1
function	tensor product of ||| tensor product	count=4
function	return constant ||| constant	count=1
function	sympy matrix/complex number to ||| sympy to	count=1
function	representation to dok representation ||| csrtodok	count=1
function	the tree [function] of ||| tree [function]	count=1
class	product [class_2] ||| [class_2] [class_1]	count=9
function	[function] in the ||| [function]	count=1
class	free ||| quotient ring	count=1
function_arg	bifid cipher ||| bifid5 msg key	count=1
module	the data in the ||| physics	count=2
function	the derived [function_2] ||| [function_1] [function_2]	count=1
function	cos**2 with 1 - ||| tr6	count=1
arg	of n if modulus ||| n modulus	count=1
function_arg	instance [arg_2] ||| [function_1] cls [arg_2]	count=1
class	of the ||| matrix	count=1
function	[function] in ||| [function]	count=3
class	the total ||| type	count=1
function	list ||| as list	count=2
class	bounding ||| complex	count=1
function	returns speed of the ||| speed	count=1
function	[function_1] for threaded ||| [function_2] [function_1]	count=4
class	the generated files ||| gen	count=2
function_arg	decryption of [arg_2] ||| [arg_2] [function_1]	count=1
class	of a polynomial expression ||| poly	count=1
function	a von ||| von	count=1
arg	only apply rule ||| rule	count=1
function	its principal ||| principal	count=1
arg	constructing ||| grid morphisms_str_info	count=1
function	triangle it ||| triangle	count=1
class	smallest affine [class] containing ||| [class]	count=1
function	a nested tuple ||| dmp to tuple	count=1
function	the result ||| indent	count=1
function	sdm from a ||| sdm from	count=2
arg	n and either ||| factors n	count=1
module	check if the ||| physics	count=3
function	sets ||| sets	count=1
arg	the solution [arg] ||| [arg]	count=2
function	[function_1] strictly ||| [function_1] [function_2]	count=8
arg	f as ||| f	count=2
function	can get the edges ||| edges	count=1
class	produces [class] ||| [class]	count=3
arg	x start stop ||| func	count=1
arg	d with knots ||| d knots	count=4
arg	variable with a ||| name k l	count=1
arg	x_0 ||| u	count=4
function	the total degree ||| total degree	count=2
arg	x tells whether the ||| x	count=1
class	root it takes ||| root	count=1
function_arg	[function_1] f ||| [function_1] term [arg_2]	count=1
arg	p k ||| b p	count=1
arg	msg to ||| msg	count=1
function	function for :func _dup_decompose ||| dup right decompose	count=1
function	n-link pendulum ||| pendulum	count=1
function	to the ||| func	count=1
module	gcd of polynomial ||| polys	count=1
function	gate identity ||| identity search	count=1
function	[function_1] morphism ||| [function_1] [function_2]	count=4
function	[function_1] zero matrix ||| [function_1] [function_2]	count=1
arg	a second order ||| eq func order match	count=1
function	[function_1] ranking ||| [function_2] [function_1]	count=6
function	out generators ||| from expr no gens	count=1
function_arg	apply [function_1] [arg_2] ||| [function_1] [arg_2]	count=6
function	g*h ||| mul	count=6
function	degree ||| sdm deg	count=1
function	factor [function_2] ||| [function_1] [function_2]	count=3
class	is return the homomorphism ||| homomorphism	count=1
function	times pi ||| pi	count=1
class	atoms of ||| basic	count=1
function	k squares ||| squares	count=1
arg	[arg] using ||| [arg]	count=3
arg	p in [arg_2] ||| [arg_2] [arg_1]	count=2
arg	divergence ||| vect doit	count=1
arg	s2 ||| s2	count=2
arg	mml a string with ||| mml	count=1
arg	stabilizer [arg_2] ||| [arg_2] [arg_1]	count=2
function	a class into a ||| mod func	count=1
function	a k t ||| k t	count=2
function	the width ||| width	count=1
function	polynomial generators ||| gens	count=1
class	real [class_2] ||| [class_2] [class_1]	count=1
class	__pow__ ||| domain	count=1
function	angle ||| angle	count=2
arg	points in \mathbb{z}_p and ||| evalpoints hpeval ring i	count=1
function	to canonical [function] storing ||| process [function]	count=1
module_class	the regularpolygon is ||| geometry regular polygon	count=1
arg	x_0 = a in ||| f a u	count=1
function	n-link pendulum on ||| n link pendulum on	count=1
class	of coset [class_2] ||| [class_1] [class_2]	count=1
class	patterns ||| properties	count=1
function	[function_1] partition ||| [function_2] [function_1]	count=4
function	coefficient ||| opt cse	count=2
arg	optionally [arg_2] ||| [arg_2] [arg_1]	count=2
class	creating new ||| tids	count=1
function	all monomials from ||| all monoms	count=4
function	sum of single ||| single	count=1
function	[function_1] in k[x] ||| polys [function_2] [function_1]	count=4
class	the ||| integral	count=1
arg	a polynomial at x_0 ||| u k	count=1
function	cosine between 2 points ||| cosine	count=1
function	delta coefficient of ||| big delta coeff	count=1
function	see ||| try	count=1
arg	ith ||| i	count=9
module_class	the [class_2] ||| [module_1] quantum [class_2]	count=1
arg	property prop ||| prop	count=1
module	to set the ||| physics	count=1
function_arg	[function_1] [arg_2] as a permutation group ||| combinatorics [function_1] group [arg_2]	count=1
function_arg	[function_1] g ||| [arg_2] [function_1]	count=11
function	size of ||| degree	count=1
function_arg	[function_1] of seq ||| [function_1] [arg_2]	count=1
module	quantum expression ||| physics quantum	count=1
function	always picks the same ||| pick	count=1
arg	\int_{c+i\infty}^{c-i\infty} f [arg_2] ||| [arg_2] [arg_1]	count=1
class	as the ||| sys cartesian	count=1
function	refine a positive ||| refine real	count=1
function	polynomial of an algebraic ||| polynomial	count=1
module	sets ||| sets	count=1
module	a basis state instance ||| quantum	count=1
function	[function] corresponding to ||| [function]	count=1
class	in the object excluding ||| base	count=1
function	[function_1] condition ||| [function_1] [function_2]	count=1
module	given ||| physics	count=1
function	symmetric polynomial ||| symmetric poly	count=2
arg	ub ||| multiplicities ub	count=1
module	[module] field ||| physics [module]	count=4
function	dummies can ||| get ordered dummies	count=1
arg	by a ||| c	count=2
module	the plane along the ||| geometry	count=1
arg	code ||| code	count=1
module	that can be ||| simplify	count=1
function	value of the ||| eval cond	count=1
arg	from_to to to_j, where ||| from_i to_j	count=1
function	refine [function_2] ||| [function_1] [function_2]	count=4
function	treats xor ||| convert xor	count=1
function_arg	[function_1] for op ||| [function_1] [arg_2]	count=3
arg	start ||| start	count=1
class	plot ||| pyglet plot	count=1
function_arg	[function_1] [arg_2] case ||| special diop [function_1] [arg_2]	count=1
arg	of f with ||| f	count=2
arg	isolating interval of a ||| t eps	count=2
arg	if self [arg] are ||| [arg]	count=1
arg	matching subexpressions ||| map simultaneous	count=1
module_class	[module_1] wavefunction ||| [module_1] [class_2]	count=8
class	[class_1] gate ||| [class_1] [class_2]	count=1
arg	determines if a circuit ||| circuit	count=1
function	intervals the expr ||| sort expr	count=1
class	containers ||| poly	count=1
function	to which the ||| to	count=1
function	term in ||| term	count=5
arg	[arg_1] path ||| [arg_2] [arg_1]	count=5
function	a dictionary from ||| dict	count=1
function	orbits of self, ||| orbits	count=1
function	create [function_2] ||| [function_1] [function_2]	count=4
arg	[arg] used ||| expression [arg]	count=2
arg	small'' matrix ||| deg_f deg_g row1	count=1
class	this frame in ||| reference frame	count=1
arg	of k0 and k1 ||| k0 k1 symbols	count=1
function	in hensel lifting ||| hensel	count=1
class	[class_1] [class_2] ||| [class_2] [class_1] simple root	count=4
function	define ||| classify sysode	count=1
function	the z ||| z	count=2
class	tuple of information about ||| basic	count=1
function	dagger ||| eval adjoint	count=1
function	the lower [function_2] ||| [function_2] [function_1]	count=2
function_arg	[function_1] [arg_2] ||| [function_1] memo [arg_2]	count=1
function	module ||| module	count=3
arg	key value ||| key value	count=2
function	to the ||| get mod	count=1
arg	returns a coordsyscartesian with ||| vector_names	count=1
function	it ||| pretty	count=1
function	negate a ||| dmp neg	count=1
function	inverse [function_2] ||| [function_1] [function_2]	count=9
class	object excluding ||| series base	count=1
module_class	[module_1] associative ||| [module_1] [class_2]	count=6
function	inverse of the cdf ||| inverse cdf expression	count=2
class	associative word self ||| free group element	count=3
function	figure out generators ||| parallel dict from expr no gens	count=1
arg	of square-free polynomial ||| polys k	count=1
function_arg	[function_1] [arg_2] for ||| [function_1] [arg_2]	count=4
function	and is [function_2] ||| [function_1] [function_2]	count=4
arg	f ||| f atoms nonbasic	count=1
function	best ||| homogeneous coeff best	count=2
function	mapping operator classes to ||| operators to state	count=1
function	class into ||| mod	count=1
class	limits [class_2] ||| [class_2] [class_1]	count=2
function	functions in ||| in	count=1
function	factor a [function_2] ||| [function_1] [function_2]	count=2
function	key such that horizontal ||| key	count=1
function	[function_1] map ||| [function_2] [function_1]	count=3
function	the previous binary ordered ||| prev binary	count=1
function	recursive helper for :func ||| rec	count=1
function_arg	reduced representation [arg_2] ||| [arg_2] [function_1]	count=3
class	p by an element ||| element	count=1
class	a groebner ||| groebner	count=2
arg	it's variable form ||| maxterm variables	count=1
module	value ||| functions	count=1
arg	arrowstringdescription describing the ||| morphisms_str_info	count=1
function_arg	a normal [arg_2] ||| [function_1] [arg_2]	count=1
function	matrix [function_2] ||| [function_1] [function_2]	count=3
function	polynomial ||| poly	count=15
class	components data ||| data lazy	count=1
function	[function] given precision ||| [function]	count=1
function	limit ||| limit	count=2
function	nested tuple of tuples ||| dmp to tuple	count=1
function	return the minimal polynomial ||| minpoly op algebraic element	count=1
module	and pdsolve in ||| solvers	count=1
arg	of ||| x x0 dir	count=1
function	rational number \frac a ||| rational	count=1
arg	in the list of ||| x	count=1
function	set of minterms ||| pairs	count=1
function	sequence of rational numbers ||| rational	count=1
function_arg	[function_1] controls ||| [arg_2] [function_1]	count=4
function	[function_1] positive ||| [function_1] [function_2]	count=2
class	create a ||| subs set	count=1
arg	sol ||| sol	count=1
function	symbol in ||| literal symbol	count=1
function	returns the domain where ||| where	count=1
module	that only uses the ||| core	count=2
function	number to a ||| to	count=1
class	of a matrix ||| dense matrix	count=1
function_arg	subresultant prs [arg_2] ||| [arg_2] [function_1]	count=3
arg	a model ||| model deep	count=1
module_class	multiplies the dyadic ||| physics vector dyadic	count=1
class	automatically ||| differential	count=1
arg	[arg_1] point pt ||| [arg_1] [arg_2]	count=1
function	using a modular algorithm ||| modgcd	count=1
arg	integral fac*g where g ||| g x	count=1
arg	of key2 ||| key2	count=1
arg	with p2 in ||| p2	count=1
function	solve [function_2] ||| [function_2] [function_1]	count=1
function	the new ||| new	count=1
function	the scalar ||| scalar	count=3
function_arg	gf [arg_2] ||| [function_1] exquo f [arg_2]	count=1
function	expression in terms ||| in terms	count=2
function	rational power and ||| rational power	count=1
function	isolate real [function_2] ||| [function_2] [function_1]	count=12
arg	rules ||| rules x prec	count=1
function	a chi ||| chi	count=1
function	and the name of ||| func	count=1
function	map x_i**m_i ||| dmp multi	count=1
function	convert the ground domain ||| dmp	count=1
arg	in ||| f p u k	count=1
function	matrix is [function] matrix ||| is [function]	count=1
arg	expression expr ||| expr	count=1
arg	oracle ||| oracle	count=1
class	that ||| complex root of	count=2
arg	[arg_1] eq ||| [arg_2] [arg_1]	count=2
function	evaluate this ||| eval evalf	count=1
function	with all ||| deduce all	count=1
class	the meijer g-function ||| meijerg	count=1
module	and c columns ||| matrices	count=1
function	function is strictly decreasing ||| is strictly decreasing	count=1
function	factor polynomials [function_2] ||| [function_1] [function_2]	count=1
function	reverse the order ||| reverse order	count=3
module	a standard basis ||| agca	count=1
arg	writer ||| clear_globs	count=1
function	sympy coefficients ||| from sympy	count=1
module	[module] works ||| [module]	count=3
module_class	self with [class_2] ||| [module_1] [class_2]	count=1
function	separable 1st ||| separable	count=1
module	returns a standard ||| agca	count=1
class	domain that contains ||| domain	count=1
arg	of the given expression ||| expr	count=3
function	topological sort ||| topological sort	count=2
function	always destroy a quasi-particle? ||| only q annihilator	count=1
function	rational function to ||| fraction field	count=2
function	legendre polynomial of degree ||| legendre poly	count=1
class	root system examples ||| root system	count=2
arg	if [arg] is a ||| [arg]	count=1
function	the quadratic ||| quadratic	count=1
module	the targets ||| physics	count=2
arg	create new instance ||| cls	count=1
arg	j k ||| j k	count=2
function	lower in ||| sub	count=1
function	young's modulus ||| elastic modulus	count=1
function	in which ||| not	count=1
function	subset ||| subset from	count=1
function	edge ||| edge	count=1
class	containers ||| ring	count=1
function_arg	addition [arg_2] ||| [arg_2] [function_1]	count=1
class	a qexpr ||| qexpr	count=1
class	elements of a matrix ||| mutable dense matrix	count=1
arg	s + ||| s p	count=1
function	characters to ||| indent	count=1
arg	coordsyscartesian with ||| vector_names	count=1
module	containing [module_2] ||| [module_2] [module_1]	count=1
function	the coefficient [function_2] ||| [function_2] [function_1]	count=4
class	quotient ||| quotient module	count=1
function	mpz ||| from zz gmpy	count=1
function	the forcing vector of ||| forcing	count=1
arg	a scalar ||| scalar	count=1
arg	g [arg] parameters func, ||| [arg]	count=1
function	a common start ||| common prefix	count=2
function	is the upper-hessenberg form ||| is upper hessenberg	count=1
function_arg	by recurrence [arg_2] ||| [function_1] memo [arg_2]	count=1
arg	or as a ||| x a b	count=1
function	is not-empty ||| not empty	count=1
arg	the intervals in the ||| f	count=1
module	symbols syms ||| core	count=1
function	integer [function_2] ||| [function_1] [function_2]	count=5
function	quasi-particle? ||| q creator	count=2
arg	a diagram ||| diagram	count=1
arg	the line in ||| k	count=1
module_class	[module_1] motion ||| [module_1] [class_2]	count=2
function_arg	[function_1] of msg ||| [function_1] [arg_2]	count=1
function_arg	a function [arg_2] ||| [function_1] [arg_2]	count=1
function	respect [function] the ||| [function]	count=1
arg	[arg_1] interval s ||| [arg_2] [arg_1]	count=2
arg	types for ||| func_args	count=1
arg	t = core_t ||| t	count=1
module	containing [module_2] ||| [module_1] [module_2]	count=1
class	method returns ||| series	count=1
function	evaluate the derivative of ||| eval derivative	count=1
class	a generator for free ||| free	count=1
function_arg	[function_1] element elem ||| [function_1] [arg_2]	count=1
function_arg	transversal of the right [function_1] [arg_2] second method described in ||| [function_1] [arg_2]	count=2
function	integer partition summing ||| integer partition	count=2
arg	and b by ||| b	count=1
module	given symbols ||| core	count=1
module	qexpr objects handles the ||| physics quantum	count=1
arg	anti-derivative to the function ||| meijerg risch	count=1
function	logarithmic ||| log	count=1
arg	of self where m ||| m	count=1
function	substitution ||| substitution	count=1
module	[module_1] of ||| [module_1] [module_2]	count=3
arg	for suitability ||| f t ct	count=1
function_arg	a linear polynomial ||| linear f	count=1
arg	n if modulus ||| n modulus	count=1
arg	s [arg_2] ||| integrals simplifyconds expr [arg_1] [arg_2]	count=1
function	associated with self ||| get	count=1
class	a cycle ||| cycle	count=1
class	raise [class_2] ||| [class_2] [class_1]	count=2
function	the primitive form ||| primitive	count=2
function	the list ||| list	count=1
arg	sols ||| sols func	count=1
function	reduced ||| reduced	count=2
function	computes the parity ||| parity	count=1
arg	the mapping in rules ||| rules	count=1
function	kinetic energy ||| kinetic energy	count=1
function	bottom ||| bottom up	count=1
module_class	[module_1] outer product ||| [module_1] [class_2]	count=4
arg	result ||| s	count=1
module_class	[module_1] coset table ||| [module_1] [class_2]	count=1
function	row-sorted list ||| row list	count=2
class	index of this fermionicoperator ||| fermionic operator	count=3
function_arg	the input [arg_2] ||| [arg_2] [function_1]	count=13
function	written as g* ||| as f	count=1
function_arg	is o ||| is tangent o	count=1
function	degrees ||| degree	count=1
function	f + g*h ||| dmp add mul	count=2
function	common header for ||| get header	count=2
arg	in expr to ||| expr	count=2
function	domain ||| domain	count=5
function	ordered [function] where ||| normal ordered [function]	count=1
function_arg	[function_1] that ||| [arg_2] [function_1]	count=4
function	returns l1 norm of ||| dmp l1 norm	count=1
arg	base and strong ||| base	count=2
function	potential difference between ||| potential difference	count=2
function	return [function] corresponding ||| [function]	count=1
function	decreasing ||| decreasing	count=2
function	central [function_2] ||| [function_2] [function_1]	count=1
function	number of real ||| real	count=1
function_arg	groups i j ||| comm i j	count=1
module	wavefunction ||| quantum	count=1
function	reversion of ||| reversion	count=1
class	exploiting the sparsity of ||| sparse matrix	count=1
function	for the ||| get	count=2
arg	col that is ||| col	count=1
class	in ||| module	count=1
module	the following for the ||| physics mechanics	count=1
module	of other ||| core	count=1
function_arg	term [arg_2] ||| [arg_2] [function_1]	count=10
function	solve a system ||| solve	count=1
function	subset defined ||| get subset	count=1
class	as ||| cartesian	count=1
function	factor [function_2] ||| [function_2] [function_1]	count=9
class	non-conjugate ||| complex	count=1
arg	in the given domain ||| f symbol domain	count=1
function	to a ||| mod	count=1
function	reduced ||| trunc	count=1
arg	multiplicities of factors using ||| f factors k	count=1
function	convert ||| convert	count=3
module	the domain ||| calculus	count=1
arg	b m + ||| a b	count=1
arg	if possible welds ||| welding_edge	count=1
function	leading degree of ||| dmp degree	count=1
class	those that take ||| series	count=1
function	zero matrix [function_2] ||| [function_1] [function_2]	count=3
function	and the name ||| get	count=1
function	determine outer indices of ||| get indices	count=2
arg	for n data points ||| n x	count=1
arg	convert f into ||| f u	count=1
function	buckets for the ||| buckets	count=1
class	groebner ||| groebner	count=2
function	the subset defined by ||| subset	count=1
class	associated with ||| poly	count=1
arg	is the ||| r n	count=1
function	values below ||| only below	count=1
function_arg	[function_1] polynomial ||| [arg_2] [function_1]	count=9
function_arg	the orbit [arg_2] ||| [function_1] [arg_2]	count=1
function	contribution of f to ||| laurent series	count=1
module	[module] monomials ||| [module]	count=3
module	given number ||| utilities	count=1
arg	in k[x] ||| m u k	count=1
arg	subtract [arg] make ||| [arg]	count=1
module	ending the [module] if ||| [module]	count=1
arg	yield origin ||| origin	count=1
class	matrix ||| mutable dense matrix	count=2
function	[function_1] rank ||| [function_1] [function_2]	count=3
arg	of f in k[x] ||| f m n u	count=1
arg	constructing the string representation ||| i j grid morphisms_str_info	count=1
function	path to the ||| mod func	count=1
function	[function_1] series for ||| [function_1] [function_2]	count=7
function_arg	[function_1] i by ||| [arg_2] [function_1]	count=2
function	method which gives ||| 1st	count=1
function	initialize from ||| init	count=1
function	[function_1] quadratic in ||| [function_1] [function_2]	count=1
function	coefficient muls ||| cse	count=1
function	the expr [function_2] ||| [function_2] [function_1]	count=1
function	gets the subset defined ||| get subset	count=1
class	exponent ||| base	count=1
function_arg	[function_1] a condition ||| [arg_2] [function_1]	count=1
function	common [function_2] ||| [function_1] [function_2]	count=8
function	[function_1] coding to ||| [function_2] [function_1]	count=3
module	for each [module] 0 ||| [module]	count=1
arg	on gens ||| arg gens	count=1
function	conditions to ||| to	count=1
function	to their coefficient ||| coefficients dict	count=1
function	if unicode output is ||| unicode	count=1
function	for threaded ||| threaded	count=1
function	reconstruct ||| reconstruction int	count=1
function	is available and ||| try	count=1
function	rust ||| rust	count=1
module	> 0 and ||| solvers	count=1
function	the coefficient of ||| coeff monomial	count=1
function	system using ||| solve linear system lu	count=1
function	[function_1] a tuple ||| [function_2] [function_1]	count=2
function	the bra ||| bra	count=1
arg	creates a small'' matrix ||| deg_f deg_g	count=1
class	polynomials or ||| ring	count=1
function	derivative of ||| diff	count=2
function	finds the degree of ||| degree	count=1
function_arg	sympy [arg_2] ||| [arg_2] [function_1]	count=1
function	ratio between ||| ratio	count=1
arg	factors has root ||| factors x	count=1
class	matrix ||| mutable sparse matrix	count=1
arg	compared to each other ||| other	count=1
module	self with ||| core	count=1
function	[function_1] laplace ||| [function_1] [function_2]	count=3
arg	in col that is ||| col	count=1
function	- g*h where ||| dmp sub mul	count=2
function	heuristic uses ||| heuristic	count=1
function	returns this function in [function_1] [function_2] ||| [function_1] [function_2]	count=2
arg	-> x + ||| x	count=1
class	generated ||| fcode	count=1
class	formal power ||| formal power	count=2
function	generate necklaces that may ||| necklaces	count=1
class	picture in characters ||| string pict	count=1
class	a tids ||| tids	count=1
arg	rule down ||| rule	count=1
class	entity which ||| entity	count=1
function_arg	[function_1] multiplication ||| [function_1] row [arg_2]	count=3
function	remainder ||| rem	count=7
function	functions in finite_set in ||| not empty	count=1
function_arg	rank of [arg_2] ||| [arg_2] [function_1]	count=4
function	[function] '/' ||| [function] native	count=1
arg	a base and ||| group base gens	count=1
function_arg	[function_1] point center ||| [function_1] force [arg_2]	count=1
function_arg	partition summing [arg_2] ||| [arg_2] [function_1]	count=1
function	[function_1] [function_2] ||| [function_2] [function_1]	count=1234
module	eigenstate instance for the ||| physics	count=1
module	in s, ||| utilities	count=1
module	the version ||| physics quantum	count=1
module	in ||| printing	count=1
function	set as output parameters ||| solveset	count=1
arg	free and ||| free	count=1
function	heuristic assumes the infinitesimals ||| lie heuristic	count=1
function	[function_1] binary ordered ||| [function_1] [function_2]	count=6
class	of polynomials or ||| poly	count=1
module	and ||| pretty	count=1
function	m to be triangularized ||| create ma	count=1
class	this method and should ||| linear	count=1
function	is a sentinel ||| is sentinel	count=3
class	more than ||| partition	count=1
function	inverse using ||| eval inverse	count=2
arg	targets [arg_2] ||| [arg_2] [arg_1]	count=1
function	sequence in the ||| sequence	count=1
class	polynomial p by an ||| poly	count=1
arg	is true optionally ||| given_condition numsamples evaluate	count=1
arg	sin x **2 ||| rv max pow	count=2
arg	divisors which [arg] the ||| [arg]	count=1
function_arg	[function_1] n for ||| [function_1] d [arg_2]	count=1
function	loads given ||| load	count=1
arg	euler eq ||| eq	count=1
arg	of a polynomial ||| minpoly	count=1
arg	for :func _factor ||| expr opt method	count=1
arg	taken k at ||| k replacement	count=2
function	[function] single ||| gamma [function]	count=1
arg	name and identifier ||| identifier	count=1
arg	compute ||| f x	count=4
arg	to_sys ||| to_sys	count=1
function_arg	the resultant [arg_2] ||| [arg_2] [function_1]	count=3
function	sparse matrix [function_2] ||| [function_2] [function_1]	count=4
function	self to ||| to	count=1
module	of g_2" ||| liealgebras	count=1
arg	item in col that ||| col	count=1
arg	transform of ||| x	count=1
class	returns ||| ring	count=1
function	the form ||| process limits	count=1
function	[function] polynomials ||| subresultants [function]	count=1
function	of ||| get	count=1
arg	of points ||| points	count=2
function_arg	expectation [arg_2] ||| [function_1] [arg_2]	count=4
class	free ||| free	count=4
class	the transform ||| integral transform	count=1
function	christoffel symbols for ||| to christoffel 2nd	count=1
function	reducible by checking ||| reducible	count=1
function	[function_1] lu the ||| [function_1] [function_2]	count=1
arg	modulo o(x**prec) examples ||| p1 x prec	count=1
function	quotient ||| quotient	count=7
function_arg	nth moment [arg_2] ||| [function_1] [arg_2]	count=1
function	as a comment ||| comment	count=1
function	dummies can be ||| get ordered dummies	count=1
function	tests whether [function_1] [function_2] ||| [function_1] [function_2] func_class f symbol	count=4
module	+ 1 at ||| solvers	count=1
module	return the ||| geometry	count=1
class	column matrix f corresponding ||| symbolic	count=1
arg	[arg_1] t ||| [arg_2] [arg_1]	count=8
class	of polygon ||| polygon	count=1
arg	is a model or ||| model	count=1
function	quantity to ||| to	count=1
function_arg	[function_1] expression e ||| [function_1] [arg_2]	count=2
arg	two sets of expressions [arg_1] [arg_2] ||| [arg_1] [arg_2]	count=3
function	previous ||| prev	count=2
module	[module] monomials which ||| [module]	count=3
function	the axis [function_2] ||| [function_1] [function_2]	count=1
function	multinomial coefficient [function_2] ||| [function_2] [function_1]	count=1
arg	c i e ||| n c	count=1
module	returns the ||| functions elementary	count=1
function	[function] of the ||| [function]	count=10
arg	s > [arg_2] ||| [arg_2] [arg_1]	count=1
class	group ||| fp group	count=1
arg	c i ||| c	count=1
function	the opening statements ||| get routine opening	count=2
function	of roots ||| count roots	count=2
module	the get_unit method ||| physics	count=1
arg	transform an expression into ||| expr	count=1
arg	supplied dictionary morphisms ||| morphisms	count=1
arg	the factors has ||| factors	count=1
function	list of irreducible factors ||| factor list include	count=2
function_arg	quotient [arg_2] ||| [function_1] [arg_2]	count=15
function	a unit polynomial ||| one	count=1
function	gcd ||| gf gcd	count=1
function	this ||| vector	count=1
function_arg	the element [arg_2] ||| [arg_2] [function_1]	count=3
function	- ||| dmp sub	count=1
function	which ||| in	count=1
module_class	the subgroup ||| combinatorics permutation group	count=1
function	new ||| orient new	count=1
arg	arbitrary constants [arg] have numbers ||| [arg] symbolname startnumber	count=1
arg	if expr ||| expr assumptions	count=1
arg	t and the order ||| t	count=1
class	[class_1] [class_2] ||| [class_2] [class_1]	count=47
arg	limit or [arg_2] ||| [arg_1] [arg_2]	count=3
function	the event ||| event	count=1
arg	by sets ||| sets	count=1
function	those that take ||| free	count=1
class	of associative ||| free group element	count=2
function_arg	sum to [arg_2] ||| [function_1] of squares [arg_2]	count=1
function	[function_1] principal ||| [function_1] [function_2]	count=1
arg	of the terms of ||| x	count=1
function_arg	[function_1] s2 ||| [function_1] [arg_2] r	count=1
function	a new ||| new	count=5
arg	a tree running it ||| fns	count=1
arg	of constants ||| matlist variable constant k	count=3
arg	j_3 m_1 m_2 m_3) ||| j_3 m_1	count=1
module	is available and ||| printing	count=1
function_arg	multiplication of ||| mul f	count=1
arg	basis in sdm form ||| extended	count=1
arg	with [arg] algebraic function ||| [arg]	count=1
function	of a polynomial ||| poly	count=1
function	sort to rearrange ||| sort	count=1
function	whole [function_2] ||| [function_1] [function_2]	count=1
function_arg	[function_1] [arg_2] ||| [function_1] mul f [arg_2]	count=1
function	leverage it if ||| pretty	count=1
arg	levels using ||| gens new_gens	count=1
function	which holds for ||| small	count=1
arg	of this system of ||| x y z	count=1
arg	a random expression ||| expr	count=1
function_arg	degree [arg_2] ||| [function_1] [arg_2]	count=1
function	success ||| once	count=1
function	zero matrix to ||| matrix to	count=6
arg	for simple [arg] 1 ||| [arg]	count=1
function	pendulum on [function_2] ||| [function_1] [function_2]	count=2
function	and ||| try use	count=1
function	the taylor [function_2] ||| [function_1] [function_2]	count=1
function	is ||| is simple	count=1
arg	an [arg_2] ||| [arg_2] [arg_1]	count=4
function_arg	[function_1] of g ||| [function_1] [arg_2]	count=5
function	represent a gate ||| represent	count=1
function	of the given function ||| function	count=1
arg	estr using in order ||| estr	count=1
module	for the ||| utilities	count=2
function	adds a ||| add	count=1
function	finite_set ||| in	count=1
arg	or as a single ||| a	count=1
function	[function_1] ratio between ||| [function_1] [function_2]	count=3
function	[function_1] n-th coefficient ||| [function_2] [function_1]	count=3
module	returns the gcd of ||| polys	count=2
arg	the math expression ||| expr	count=1
function	of rows in ||| height	count=1
function	a list of native ||| list	count=1
class	elements of the matrix ||| matrix	count=1
class	py default ||| py	count=1
function	a specific ||| free	count=1
module	tensors ||| tensor	count=1
module	if the ||| physics quantum	count=1
function_arg	[function_1] f ||| [function_1] list [arg_2]	count=4
arg	m_1 \; ||| m_1	count=1
function	lowering the ||| tr7	count=1
function	the unknown function that ||| search function	count=1
arg	superset ||| superset	count=1
class	take on a ||| series base	count=1
function	a fourier ||| fourier	count=1
module	the canonical base dimensions ||| physics units	count=1
module	function is the ||| physics	count=1
module	leverage it if possible ||| pretty	count=1
function	class into a string ||| mod func	count=1
function_arg	[function_1] a rule ||| [function_1] [arg_2]	count=1
arg	[arg] to ||| [arg] assign_to	count=1
class	basis ||| poly ring	count=2
arg	[arg_1] dum ||| [arg_1] [arg_2]	count=1
function	the non-zero ||| row	count=1
class	does the ||| mixin	count=1
arg	to ||| k1 a k0	count=2
arg	x + ||| x	count=1
arg	[arg_1] degree d ||| [arg_2] [arg_1]	count=2
function	certificate ||| certificate	count=1
function	the hypergeometric ||| hyperexpand	count=1
arg	self by state ||| state	count=2
function	x_i**k_i in a polynomial ||| dmp inflate	count=1
function	ratio of a ||| ratio	count=1
function_arg	quotient [arg_2] ||| [function_1] ground [arg_2]	count=6
function	returns left ||| left	count=1
module	it if possible ||| pretty	count=1
arg	multiplicities of factors using ||| f factors u k	count=1
arg	y [arg_2] ||| [arg_2] [arg_1]	count=4
class	sequence ||| poly	count=1
function	non-central chi ||| chi noncentral	count=2
function	return whether [function_1] [function_2] given interval ||| [function_1] [function_2]	count=1
function	into ||| to	count=2
arg	differential equation either ||| eq	count=1
function	focal length ||| focal length	count=1
function	the sum [function_2] ||| [function_2] [function_1]	count=6
arg	list of the digits [arg_1] [arg_2] ||| [arg_1] [arg_2]	count=4
function	binary coding to ||| bin to	count=1
function	[function_1] sympy expression ||| [function_2] [function_1]	count=1
class	a standard basis in ||| ring	count=1
module	of the ||| elementary	count=1
class	annihilate hole ||| create fermion	count=1
function	method returns the symbols ||| symbols	count=1
function_arg	orbit of [arg_2] ||| [function_1] [arg_2]	count=2
arg	== 2 and n ||| n	count=1
function	alpha and beta ||| alpha beta	count=3
function	of real [function_2] ||| [function_2] [function_1]	count=2
function	logarithmic derivative [function_2] ||| [function_1] [function_2]	count=2
arg	to expr ||| expr	count=1
function	the form of ||| form	count=1
function	a finite rotation ||| orient	count=1
function	in ||| not empty	count=2
arg	monic square-free polynomial f ||| f	count=2
class	line perpendicular to this [class_1] [class_2] which passes through ||| [class_1] [class_2]	count=1
module	perform [module_2] ||| [module_1] [module_2]	count=1
arg	e ||| e x	count=1
arg	strip given by ||| x strip	count=1
arg	system key must ||| key	count=1
function	return encryption ||| encipher	count=1
function	ben-or's ||| irred p ben or	count=1
function	applied on ||| on	count=1
function	printing of expressions generated ||| vprint	count=1
function_arg	[function_1] expr using ||| [function_1] [arg_2]	count=1
function	from positions from_to ||| sub	count=1
class	kb ||| prop kb	count=1
function	apply a ||| apply xsl	count=1
module	to ||| physics quantum	count=2
arg	to z is ||| z tol a	count=1
function	[function_1] ending of ||| [function_2] [function_1]	count=4
function	[function_1] k squares ||| [function_1] [function_2]	count=3
module	the referenceframe ||| physics	count=2
arg	expression with bosonic ||| expr	count=1
arg	in k[x] ||| m n u	count=1
function_arg	[function_1] of ||| [function_1] [arg_2]	count=21
arg	a new key ||| key	count=1
function	functions in finite_set in ||| not	count=1
arg	isolating interval ||| t eps	count=2
function	sentinel of a ||| sentinel	count=1
function	expression which is ||| expr	count=1
arg	in the [arg_2] ||| [arg_1] [arg_2]	count=6
function	random element ||| random stab	count=1
function	the best solution to ||| homogeneous coeff best	count=1
class	the code ||| code	count=1
function	return constant term ||| get constant term	count=2
arg	i ||| i z	count=2
arg	[arg_1] and g ||| [arg_1] [arg_2]	count=51
function	topological sort of graph's ||| topological sort	count=1
arg	of f ||| f m	count=9
class	the matrix ||| mutable sparse matrix	count=1
arg	func ||| func hint	count=1
function	multiply together several polynomials ||| dmp expand	count=1
module	the form ||| physics mechanics	count=1
function	a rational number \frac ||| rational	count=1
function	[function_1] monotonic ||| [function_1] [function_2] expression interval symbol	count=5
function	returns wavelength ||| wavelength	count=1
arg	s2 deg_g ||| deg_g	count=1
function	returns ||| groebner	count=1
function	[function_1] the order ||| [function_2] [function_1]	count=1
function_arg	of irreducible [arg_2] ||| [arg_2] [function_1]	count=2
function	[function_1] table ||| [function_2] [function_1]	count=3
function	to set ||| set	count=2
function_arg	[function_1] e and ||| [function_1] [arg_2]	count=4
arg	s + 1 from ||| s p	count=1
function	the symbols in the ||| symbols	count=1
arg	[arg_1] and returns ||| [arg_2] [arg_1]	count=3
function	in the ground domain ||| ground	count=1
arg	the user ||| weylelt	count=2
function	function is decreasing ||| is decreasing	count=2
function	name of ||| get mod	count=1
arg	and dum indices ||| dum	count=1
arg	the root if ||| root	count=1
function	of symbolic ||| create	count=1
arg	and u ||| k reverse	count=1
arg	the given ||| expression	count=3
module	matrix and a ||| matrices	count=1
arg	each [arg] ||| [arg] sols	count=3
function	to latex handling functions ||| print function	count=1
function	solves an n\th ||| ode nth	count=5
arg	in subs to ||| subs	count=1
function	to ||| param dict	count=1
arg	instance of roots of ||| cls expr	count=1
arg	[arg_1] row ||| [arg_2] [arg_1]	count=3
function	wang/eez ||| dmp zz wang	count=3
module	the version of ||| physics	count=1
function	f * a ||| mul	count=1
function	isolate real [function_2] ||| [function_1] [function_2]	count=12
function	precedence of a given ||| precedence	count=1
module	to self ||| polys agca	count=2
function	python subprocess ||| subprocess	count=1
arg	[arg_1] g and ||| [arg_2] [arg_1]	count=1
function	separate variables in partial ||| pde separate	count=1
function	the form ||| form	count=1
function	gcd of coefficients ||| ground content	count=1
function	list representation ||| as list	count=1
module_class	[module_1] [class_2] complete if it has ||| [module_1] [class_2] is complete	count=1
arg	a ||| b a	count=1
module	of time in the ||| physics vector	count=1
function	the module and ||| func	count=1
arg	y z ||| y z	count=1
function	subgroup whose presentation ||| reidemeister presentation	count=1
arg	= b m + ||| a b	count=1
function	polynomial of order ||| poly	count=2
function	[function] that ||| [function] simple	count=1
arg	a single g function ||| a	count=1
arg	a lexical closure ||| name latexname	count=1
function	handling functions ||| print function	count=1
module	are polynomials in ||| polys	count=1
arg	[arg_1] n digits ||| [arg_2] [arg_1]	count=4
function	elements examples ||| empty	count=1
function	true if ||| is square	count=1
function	is properly normalized ||| is normalized	count=2
function	of christoffel symbols for ||| christoffel 1st	count=1
function	[function_1] trivial ||| [function_2] [function_1]	count=1
arg	[arg_1] f and ||| [arg_2] [arg_1]	count=8
arg	return namespace ||| namespace	count=1
function	the beginning ||| indent	count=1
function	an fisher's [function_2] ||| [function_2] [function_1]	count=2
function	roots up to ||| dup inner isolate real roots	count=1
function	the real ||| real	count=2
arg	into order of per_vec ||| per_vec	count=1
function	[function_1] k t ||| [function_1] [function_2]	count=2
function_arg	[function_1] cipher encryption ||| [arg_2] [function_1]	count=3
class	compute ||| gmpyinteger ring	count=3
function	[function_1] sentinel ||| [function_1] [function_2]	count=1
class	known [class] ||| coord [class]	count=1
module	a labeled polynomial ||| polys	count=1
class	compute ||| python integer ring	count=3
function_arg	the posform [arg_2] ||| [function_1] [arg_2]	count=1
arg	the components ||| components	count=1
module	[module] point ||| [module]	count=1
function	expr cond ||| expr cond	count=1
function	[function_1] generators ||| [function_2] [function_1]	count=9
arg	a rational [arg] modulo ||| [arg]	count=1
arg	[arg_1] field ||| [arg_2] [arg_1]	count=14
function	[function] of a ||| berkowitz [function]	count=1
class	elements ||| free module	count=1
function_arg	[function_1] running it ||| [arg_2] [function_1]	count=4
function	ending ||| get statement	count=1
function	root or none ||| root	count=1
module	using the ||| physics	count=1
function	diagram ||| handle groups	count=1
function_arg	multiply dense [arg_2] ||| [function_1] f [arg_2]	count=1
function	down a tree ||| top down	count=1
class	plot ||| plot	count=2
arg	replaced ||| kwargs n	count=1
function	real sets ||| set	count=3
function	[function_1] length ||| [function_2] [function_1]	count=2
function_arg	[function_1] c ||| [function_1] cls r [arg_2]	count=2
function	content and primitive ||| content primitive	count=1
function_arg	[function_1] j ||| [arg_2] [function_1]	count=6
function_arg	if key is [function_1] [arg_2] to ||| categories diagram [function_1] union dictionary [arg_2] value	count=3
module	coefficient ||| simplify	count=1
function	function -> meijerg lookup ||| create lookup	count=1
function	the inverse hankel ||| inverse hankel	count=2
function	a positive root of ||| root	count=2
class	[class] equalities ||| [class]	count=1
function	finds the ||| empty	count=1
arg	subgroup using strategy ||| strategy	count=1
function	mpq [function_2] ||| [function_2] [function_1]	count=2
arg	equations in eq ||| eq funcs	count=1
arg	a field ||| field	count=5
arg	arg ||| arg	count=2
function_arg	basis for [arg_2] ||| [function_1] [arg_2]	count=1
arg	angle radians counterclockwise about ||| angle	count=1
arg	it is the ||| x	count=1
function_arg	dense [arg_2] ||| [function_1] mul f [arg_2]	count=1
function	cosine ||| cosine	count=1
class	that ||| differential	count=1
function	delta coefficient ||| delta coeff	count=1
class	the xy-pic representation of ||| diagram drawer	count=1
function	log hint see ||| log	count=1
arg	[arg_1] s , ||| [arg_2] [arg_1]	count=2
class	atoms of self those ||| basic	count=1
class	a ||| module	count=3
function	operator classes to their ||| operators to state	count=1
function	use ||| det	count=1
class	intersection in terms ||| intersection	count=1
function	cauchy-euler equidimensional ordinary differential ||| euler	count=1
module	angle by which the ||| geometry	count=1
function	truth value of ||| eval cond	count=1
function	meijer g ||| meijer	count=1
function	the number [function_2] ||| [function_1] [function_2]	count=2
function	helper [function_2] ||| [function_2] [function_1]	count=2
arg	the mapping in rules ||| p rules	count=1
function	independence between ||| pspace independent	count=1
function	are contained in ||| similar	count=1
function	values to ||| create	count=1
class	of the coefficients ||| dmp	count=1
function	of free [function_2] ||| [function_2] [function_1]	count=5
arg	[arg_1] by ||| [arg_1] [arg_2]	count=4
function	equations of motion in ||| comb	count=1
function	z ||| zgate	count=1
function	expression for the hypergeometric ||| hyperexpand	count=1
module	of a [module] expectation ||| [module]	count=1
class	of ||| field	count=1
function	3-tuple a b c ||| three	count=1
function	degree ||| degree	count=5
arg	of a and b, ||| a b	count=16
function	using lusolve ||| lu	count=1
class	returns a standard ||| sub module	count=1
function	represent this ||| represent	count=1
function	trial [function_2] ||| [function_1] [function_2]	count=2
function	in [function_2] ||| [function_1] ff trivial [function_2]	count=2
function	reverse the order of ||| reverse order	count=1
function	of real sets ||| set	count=3
function_arg	polynomial quotient [arg_2] ||| [function_1] [arg_2]	count=4
arg	an expression to ||| cls expr x	count=1
function	construct new ||| new	count=1
function_arg	apply [arg_2] ||| [function_1] operator int qubit [arg_2]	count=2
class	[class_1] code ||| [class_2] [class_1]	count=3
function	return true if ||| is	count=2
function_arg	[function_1] matrix ||| [function_1] [arg_2]	count=6
class	standard ||| poly	count=1
class	the transform is evaluated ||| transform	count=1
arg	f ||| f order	count=2
function	the series expansion for ||| series	count=1
class	should implement [class] ||| [class]	count=3
module	holonomic ||| holonomic	count=1
arg	or as a ||| a	count=1
module	pretty ||| printing pretty	count=3
arg	variable with [arg_2] ||| [arg_2] [arg_1]	count=9
arg	routines in ||| routines f prefix funcname	count=1
class	on a specific ||| series base	count=1
function	a certificate ||| certificate	count=1
function_arg	[function_1] morphism ||| [function_1] [arg_2]	count=2
function	bisection ||| depth first select	count=1
arg	:math \int_{c+i\infty}^{c-i\infty} f ||| f	count=1
function	a rational ||| rational prec	count=1
arg	in f ||| f k	count=2
class	of pstack if possible ||| multiset partition traverser	count=2
function	for solveset ||| solveset	count=1
function	and if ||| and	count=1
function	functions in finite_set ||| empty in	count=1
function	a list representation ||| list	count=1
class	returns the total number ||| g	count=1
function_arg	order on gens ||| order arg gens	count=2
arg	[arg_1] cheap ||| [arg_1] [arg_2]	count=3
module	returns this function ||| functions elementary	count=2
function	returns maximum ||| max	count=2
module	specific lie algebra examples ||| liealgebras	count=1
function	numerator of ||| numer	count=1
function	puiseux series ||| rs puiseux2	count=2
function	to the module ||| get	count=1
function	the function is ||| is	count=4
function_arg	the symbol [arg_2] ||| [arg_2] [function_1]	count=1
class	the sequences ||| seq mul	count=1
function	polynomial remainder [function_2] ||| [function_2] [function_1]	count=2
arg	of cls ||| cls	count=1
function	symbols in the object ||| free symbols	count=1
function	bra on the ||| bra	count=1
class	returns an ||| expr	count=1
arg	arg into two parts ||| arg	count=1
function	the vsids ||| vsids	count=1
function_arg	pseudo-remainder [arg_2] ||| [arg_2] [function_1]	count=2
function	the symbols in ||| symbols	count=3
function	run the ||| run	count=1
module	available and leverage ||| pretty	count=1
function	generators ||| gens	count=8
arg	rank [arg] ||| [arg]	count=2
arg	of a polynomial ||| cls poly	count=2
function	the number ||| count	count=3
function	finite_set ||| not empty in	count=2
function	[function_1] norm ||| [function_1] [function_2]	count=14
class	used in the coset-table ||| table	count=1
class	the object excluding those ||| base	count=1
function	coefficients using the ||| coeff	count=1
function	subgroup whose presentation is ||| presentation	count=1
arg	x -> x ||| x	count=1
arg	class initiated ||| q_ind qd_ind q_dep qd_dep	count=1
module	test ||| assumptions handlers	count=1
function	scale the function ||| scale	count=1
function_arg	polynomial pseudo-division [arg_2] ||| [arg_2] [function_1]	count=2
function	index [function_2] ||| [function_2] [function_1]	count=4
function	diagonal morphism checks whether ||| diagonal	count=1
module	function for ||| series	count=1
function	absolute value of ||| abs	count=1
arg	as a ||| a b	count=2
arg	differentiating under ||| sym	count=1
arg	if all [arg] are true ||| [arg]	count=1
function	clauses contains the unit ||| unit	count=1
function	[function_1] coding to ||| [function_1] [function_2]	count=3
function	sum [function_2] ||| [function_2] [function_1]	count=6
class	basis in ||| sub module	count=1
arg	with private key msg ||| msg key	count=1
arg	x ||| a x	count=1
module	generates [module] dihedral ||| [module]	count=1
function	equation of the given ||| equation	count=1
function	transpose ||| transpose	count=1
arg	mobius transform or an ||| m k eps	count=1
arg	rotations are applied in ||| angle1 angle2 angle3 rot_order	count=1
function	mpq object ||| qq	count=6
function	the bodies ||| bodies	count=1
arg	local_dict ||| s local_dict	count=1
function	[function] in a ||| reverse [function]	count=1
module	is a sum that ||| simplify	count=1
function	power or ||| pow	count=1
arg	expression or latex ||| expr	count=1
function	roots up ||| isolate real roots	count=1
arg	of f and for ||| a d de z	count=1
function	n ||| n p	count=1
module	to arguments ||| core	count=1
class	of the relational ||| relational	count=1
function	find optimization ||| opt cse	count=1
function	a rational ||| eval rational	count=1
arg	running it ||| brule fns	count=1
function	[function] taylor ||| taylor [function]	count=1
arg	self ||| other	count=1
function	of the ||| func	count=1
function	argument [function] false ||| needs [function]	count=1
arg	[arg_1] irreducibility test ||| [arg_1] [arg_2]	count=1
arg	apply a rule down ||| rule	count=1
function	a string path ||| get mod func	count=1
module	the dictionary mapping ||| physics	count=1
module_class	[module_1] system ||| [module_1] units dimension [class_2]	count=1
module_class	of the polyhedron ||| combinatorics polyhedron	count=1
module_class	[module_1] system ||| [class_2] [module_1]	count=2
class	tuples index ||| index	count=1
function	series ||| series	count=7
arg	for x**n == a ||| a n	count=1
function	instance to ||| as	count=1
function	the length of ||| length	count=1
function	the form of singularity ||| singularity	count=1
function	true if ||| is number	count=1
arg	a sympy expression ||| expr	count=1
function	the direct ||| direct	count=1
module	rearrange the order of ||| physics	count=1
function	to self dtype ||| from	count=1
arg	x y z of ||| x y z	count=1
function_arg	[function_1] replaced ||| [arg_2] [function_1]	count=3
function	convex hull surrounding ||| convex hull	count=2
arg	self to other ||| other	count=2
function	[function_1] homomorphism to ||| [function_2] [function_1]	count=2
arg	of square-free polynomial using ||| polys k eps	count=1
arg	targets and target_matrix ||| targets target_matrix nqubits	count=3
class	returns the ||| sparse	count=1
function	exponentiation of ||| rs exp	count=1
arg	function in ||| function	count=1
arg	n with [arg_2] ||| [arg_2] [arg_1]	count=1
function	finite_set in which the ||| not	count=1
arg	the comparison operator ||| op	count=1
module	the specified qubits ||| physics quantum	count=1
class	of the exponential ||| exp	count=1
function	equation of ||| equation	count=1
arg	a p == ||| a p	count=2
module	replaced with [module] examples ||| [module]	count=1
function	computes the gauss-chebyshev ||| chebyshev t	count=1
function	muls ||| cse	count=1
arg	using ||| f k	count=1
function	compute ||| compute	count=1
function	symbols that ||| symbols	count=2
module	ax^2 ||| solvers	count=1
function	to a set of ||| to	count=1
function	a class into a ||| mod	count=1
function	[function_1] difference between ||| [function_2] [function_1]	count=4
arg	given two ||| other	count=1
function	product of multiple ||| product	count=2
function	leverage it ||| pretty try	count=1
function	a method to ||| method	count=1
arg	[arg_1] to fringe ||| [arg_2] [arg_1]	count=1
arg	of trigonometric ||| rv	count=1
arg	grid adds an edge ||| grid skeleton	count=1
arg	variable representing ||| name n p succ	count=1
arg	space ||| s	count=1
module	with mathml code ||| utilities mathml	count=1
function	mapping of symbolic values ||| dict	count=1
class	column matrix f ||| symbolic system	count=1
function	sympy's number ||| sympy	count=2
module	a permutation ie the ||| combinatorics	count=2
function_arg	expr with [arg_2] ||| [arg_2] [function_1]	count=5
function	converts a list ||| letter form to	count=1
function	real [function_2] ||| [function_2] [function_1]	count=24
module	basis state instance corresponding ||| quantum	count=1
arg	data to a tensmul ||| tensmul	count=1
arg	[arg_1] if all ||| [arg_2] [arg_1]	count=1
arg	in a rational function ||| f g include	count=1
function	eye and ||| matrix eye	count=1
function	[function_1] indices ||| [function_2] [function_1]	count=12
function	order a multiplication expression ||| order	count=1
function	sorted [function_2] ||| [function_1] [function_2]	count=1
function	exact polynomial quotient ||| dmp quo	count=1
arg	variable with ||| name	count=23
function	[function_1] non-negative ||| [function_2] [function_1]	count=2
function	[function_1] components ||| [function_2] [function_1]	count=2
function	the coefficient ||| as coeff	count=7
arg	a small'' matrix m ||| deg_f	count=1
arg	rsolve_hypergeometric for details ||| x re	count=1
class	in ||| series base	count=2
function	solution of a differential ||| ode	count=1
function	index, meaning ||| has	count=1
module	qubits this ||| quantum	count=2
arg	the grid ||| grid skeleton	count=1
function	start stop ||| limits	count=1
function	the lu [function_2] ||| [function_2] [function_1]	count=1
function_arg	[function_1] eq ||| [arg_2] [function_1]	count=2
function_arg	[function_1] in x ||| [function_1] [arg_2]	count=2
arg	root if ||| cls root	count=1
arg	denominator of f and ||| a d de	count=1
function_arg	[function_1] of alpha ||| [arg_2] [function_1]	count=9
class	no bounding rectangles of ||| complex root	count=1
arg	expr is bounded false ||| expr assumptions	count=1
arg	h ||| fp_grp h	count=1
function_arg	[function_1] [arg_2] with terms whose squares ||| [function_1] surds [arg_2]	count=1
module	the given eigenstate ||| physics quantum	count=1
function	intersection of 'self' ||| intersection	count=1
arg	eq ||| eq y x	count=1
function	of pauli ||| pauli	count=1
module	the ||| physics	count=236
module	into ||| parsing	count=1
arg	z0 using ||| z0 dir	count=1
function	name of ||| mod func	count=1
function	run all [function_2] ||| [function_2] [function_1]	count=1
function	the berkowitz algorithm ||| eval det berkowitz	count=1
function	square-free factorization given a ||| splitfactor sqf	count=1
function	[function_1] pos ||| [function_2] [function_1]	count=1
class	[class_1] basis ||| [class_2] [class_1]	count=11
arg	a second order ||| func order	count=1
module_class	[module_1] polynomial coefficients ||| [module_1] [class_2]	count=2
module	object excluding those that ||| series	count=1
class	sort roots ||| complex root	count=1
module	solution to a second ||| solvers	count=1
module	return a set ||| polys agca	count=1
function_arg	gf [arg_2] ||| [function_1] exquo f g [arg_2]	count=1
function	primitive root of p ||| primitive root	count=1
function	splits a list ||| split list	count=1
arg	a first order ||| func order	count=2
function	the gray code ||| gray	count=2
function	from gray coding to ||| gray to	count=1
function	[function_1] raw dict ||| [function_2] [function_1]	count=1
arg	x_0 = a ||| a u k	count=2
function	reconstruct every ||| reconstruction int	count=1
class	get ||| tens mul	count=2
function	is a principal ||| is principal	count=3
module	the string path to ||| utilities	count=1
function	the given ||| to	count=2
module	list the list is ||| combinatorics	count=1
function	returns maximum ||| dmp max	count=2
function	univariate ||| univariate	count=1
function	[function_1] that helps ||| [function_2] [function_1]	count=6
arg	_strip with h ||| h base	count=1
function	conjunctions and disjunctions ||| distribute or over and	count=1
module	couple ||| physics quantum	count=1
function	the variables ||| variables	count=2
module	a [module] in k[x] ||| [module]	count=1
function	get the edges ||| edges	count=1
function	use pollard's rho ||| rho	count=1
function_arg	[function_1] g is ||| [function_1] [arg_2]	count=5
function	anp object ||| algebraic	count=3
class	create ||| subs	count=1
module	the inverse ||| physics quantum	count=1
arg	isolating ||| eps	count=2
function	of sin ||| sin	count=1
function	calculate the derivative ||| diff	count=1
module	should be ||| core	count=1
function	fraction and a polynomial ||| poly	count=1
function_arg	[function_1] to ||| [arg_2] [function_1]	count=13
function	transform ||| cosine transform	count=1
function	is not-empty ||| empty	count=1
module	of equation ||| solvers	count=1
function	procedure of diophantine ||| diophantine	count=1
arg	[arg_1] irreducibility ||| [arg_2] [arg_1]	count=1
function	[function_1] two terms ||| [function_1] [function_2]	count=2
function	property where the lookup ||| memoize property	count=1
function	creates a new ||| new	count=1
module	branching ||| branch	count=1
arg	of general ||| x y t	count=1
function	eye and tensor_product for ||| matrix eye	count=1
module_class	dimension [class_2] ||| [module_1] [class_2]	count=1
function	expand the first ||| expand	count=1
function	of two terms ||| as two	count=2
arg	sum c[n]*p**n modulo o(x**prec) ||| c x prec	count=1
function_arg	a dummy [arg_2] ||| [function_1] [arg_2]	count=6
class	ray and a point ||| ray	count=1
function_arg	domain [arg_2] ||| [function_1] [arg_2]	count=1
class	of other functions ||| basic	count=1
module	of space characters ||| utilities	count=1
class	this ||| sparse matrix	count=2
arg	operators ||| operators	count=1
function	returns the best solution ||| 1st homogeneous coeff best	count=1
function	a list of native ||| from list	count=1
arg	in eq ||| eq	count=1
function	into a basic expression ||| basic	count=1
arg	a tensmul object it ||| tensmul	count=1
class	code ||| code	count=12
function_arg	[function_1] [arg_2] ||| [function_1] subs [arg_2]	count=2
function_arg	the length [arg_2] ||| [function_1] [arg_2]	count=2
arg	k = a ||| k a	count=2
arg	a and b are ||| a b tolerance	count=1
class	to ||| integer ring	count=1
function	[function_1] central ||| [function_2] [function_1]	count=3
class	system into a ||| system	count=1
function	affine ||| affine	count=1
function_arg	leading coefficient [arg_2] ||| [function_1] [arg_2]	count=1
arg	convert f from k[x ||| f	count=1
arg	a unit ||| unit	count=1
function_arg	coefficient [arg_2] ||| [function_1] [arg_2]	count=1
arg	[arg_1] [arg_2] a string of ||| [arg_2] [arg_1]	count=4
function_arg	inversion 1/p [arg_2] ||| [arg_2] [function_1]	count=2
function	[function] for ||| [function] pr	count=1
arg	[arg_1] first order ||| [arg_2] [arg_1]	count=5
class	[class_1] series every ||| [class_2] [class_1] simple root	count=3
function	bernoulli ||| bernoulli	count=2
module	a list the list ||| combinatorics	count=1
arg	x or the ||| x	count=1
function	on it ||| on	count=1
function_arg	to a [arg_2] ||| [function_1] force vec [arg_2]	count=1
arg	p1 ||| p1	count=3
function	[function_1] cdf ||| [function_1] [function_2]	count=2
class	root system examples ||| root system dynkin	count=1
function	into a ||| func	count=1
arg	f given a ||| f m k	count=1
function	minimal [function_2] ||| [function_2] [function_1]	count=3
module	[module] otherframe ||| [module]	count=1
module	compute the ||| physics	count=3
function	[function_1] non-positive ||| [function_2] [function_1]	count=1
function	of space characters to ||| indent	count=1
function	[function_1] a submodule ||| [function_1] [function_2]	count=1
class	the c ||| c	count=1
function_arg	intersection [arg_2] ||| [arg_2] [function_1]	count=1
function	symbol [function_2] ||| find [function_2] [function_1]	count=4
arg	symbols with ||| symbols filter	count=1
function	[function_1] of rational ||| [function_2] [function_1]	count=5
function_arg	jacobian matrix [arg_2] ||| [function_1] [arg_2]	count=1
arg	whether indices are ||| indices	count=1
arg	into an ||| expr	count=1
function	use the berkowitz algorithm ||| eval det berkowitz	count=1
function	isolate real roots of ||| isolate real roots	count=2
function_arg	multiplication [arg_2] ||| [function_1] scalar [arg_2]	count=2
function	converts a hypergeometric ||| hyper	count=1
function_arg	[function_1] base ||| [function_1] [arg_2]	count=3
function	is the given geometric ||| is	count=2
function	a dictionary ||| dict	count=2
function_arg	[function_1] [arg_2] ||| [function_1] from indices [arg_2]	count=1
function_arg	[function_1] isolating ||| [arg_2] [function_1]	count=2
class	of exp ||| exp base	count=1
class	polynomials or containers ||| poly ring	count=1
module	[module_1] wavefunction ||| [module_1] [module_2]	count=1
function	function is strictly ||| is strictly	count=4
function_arg	multiply [arg_2] ||| [function_1] ground [arg_2]	count=6
arg	combinatorial term [arg] ||| [arg]	count=1
class	with ||| tens	count=2
function	a free module ||| free module	count=2
class	of ||| type f	count=1
module	the initialization of ||| physics mechanics	count=1
module	sparse ||| tensor array	count=2
arg	negative ||| exprs	count=1
function	triangular ||| triangular	count=3
function	refine ||| refine	count=1
arg	of rank k ||| rank	count=1
function	singularity ||| as singularity	count=1
arg	apply rule [arg_2] ||| [arg_2] [arg_1]	count=2
function	scan routine used in ||| scan	count=1
class	than ||| partition	count=1
arg	x of [arg_2] ||| [arg_1] [arg_2]	count=1
arg	irreducibility test over finite ||| p k	count=1
arg	ex2 parameters ||| ex2 x	count=1
arg	operating point ||| op_point	count=1
arg	mml a string ||| mml	count=1
function	functions in ||| not	count=1
class	of ||| subs set	count=1
class	state is ||| state	count=1
arg	f to all ||| f	count=1
class	are generated ||| differential extension	count=1
arg	apply [arg] to pairs ||| f g [arg]	count=1
class	partition is listed ||| integer partition	count=1
function	index position to ||| to	count=1
function_arg	zeros square [arg_2] ||| [arg_2] [function_1]	count=6
function	multivariate ||| dmp	count=6
arg	i ||| i	count=18
function	two bivariate integer ||| bivariate	count=1
class	python's int ||| python integer	count=1
arg	z )[x] with the ||| minpoly	count=1
function	derivative of each element ||| diff	count=1
class	if ||| min max base	count=1
function	cartan [function_2] ||| [function_1] [function_2]	count=5
arg	in \mathbb{z}_p and ||| evalpoints hpeval ring i	count=1
function	excluding those that ||| free	count=1
function_arg	[function_1] [arg_2] ||| [function_1] obj [arg_2]	count=10
class	with the proper ||| code printer	count=1
module	please read the ||| physics	count=1
function	[function_1] the constant ||| [function_2] [function_1]	count=2
function	of this catagory ||| 2eq order2 type8	count=1
arg	replaced by the function ||| args kwargs n	count=1
function	triangle it should ||| triangle	count=1
function	z[x] ||| int	count=2
module	without the ||| physics	count=1
function_arg	apply a rule [function_1] [arg_2] ||| [function_1] [arg_2]	count=6
function_arg	[function_1] [arg_2] ||| [function_1] bsgs [arg_2]	count=8
function	motion in explicit ||| explicit	count=1
class	from string ||| string	count=1
function	[function_1] loop ||| [function_1] [function_2]	count=2
function	pivot ||| reasonable pivot	count=1
function	beyond ||| next	count=1
function	[function_1] code parameters ||| [function_2] [function_1]	count=1
function	[function_1] apply ||| [function_2] [function_1]	count=4
class	of coset enumeration ||| coset	count=2
arg	[arg_1] a log-normal ||| [arg_1] [arg_2]	count=1
module	a standard basis in ||| agca	count=1
function	generating function ||| guess generating function	count=2
arg	using vincent-akritas-strzebonski ||| f k	count=1
function	indices [function_2] ||| [function_2] [function_1]	count=4
function	[function_1] on ||| [function_1] [function_2]	count=4
function_arg	[function_1] terms of ||| [function_1] f [arg_2]	count=2
arg	in k[x] ||| u k	count=18
arg	m_1 [arg_2] ||| [arg_2] j_3 [arg_1]	count=3
function_arg	[function_1] k ||| [function_1] l l [arg_2]	count=1
arg	[arg] given a ||| condition [arg]	count=1
arg	refraction at planar surface ||| incident medium1 medium2 normal	count=1
function	the deductions ||| deductions	count=1
function	of symbolic values to ||| create	count=1
function	them [function] its domain ||| drop [function]	count=1
arg	_hastypes to [arg_2] ||| [arg_2] [arg_1]	count=2
function	by ||| get	count=1
function_arg	[function_1] running it ||| [function_1] rule [arg_2]	count=1
class	integral sign [1], ||| integral	count=1
function	[function_1] substitution ||| [function_1] [function_2]	count=3
module	compute the ||| physics mechanics	count=1
module	self with oth, ||| agca	count=1
function	beginning of ||| indent	count=1
arg	subexpression of f ||| f	count=1
function	the expression as a ||| as	count=1
function	increment the [function_2] ||| [function_1] [function_2]	count=3
function_arg	series expansion [arg_2] ||| [arg_2] [function_1]	count=4
module	random expression i ||| stats	count=1
function	the quadratic ternary diophantine ||| ternary quadratic	count=1
arg	data ||| data x	count=1
function	all the implications of ||| all	count=1
function	to below fermi examples ||| below fermi	count=1
class	is ||| fraction field	count=1
arg	do to ||| do	count=1
function	n-link pendulum [function_2] ||| [function_1] [function_2]	count=5
arg	[arg_1] if ||| [arg_1] [arg_2]	count=1
class	no bounding rectangles ||| complex root	count=1
function_arg	a [function_1] [arg_2] ||| [function_1] [arg_2]	count=6
arg	containing ||| limit	count=1
arg	a p == 1 ||| a p	count=1
arg	expression ||| expr condition	count=2
function	reducible ||| reducible	count=1
arg	base b ||| b	count=3
module_class	in the [class_2] ||| [module_1] [class_2]	count=8
function	return ||| indent	count=1
function	list of native coefficients ||| from list	count=1
module	lie algebra determines the ||| liealgebras	count=1
class	plane ||| plane	count=8
class	all the sequences ||| seq	count=2
function	[function_1] isomorphism ||| [function_2] [function_1]	count=2
function_arg	[function_1] polynomials in ||| [function_1] mul [arg_2]	count=1
function	with all ||| all	count=1
function	the class ||| get mod	count=1
function	is strictly increasing in ||| is strictly increasing	count=1
arg	equations in eq ||| eq	count=1
arg	if [arg] is ||| [arg]	count=1
class	in the ||| base	count=1
class	of polynomials ||| ring	count=2
function_arg	prints expr using ||| print expr	count=1
arg	p0 from dumx ||| dumx dumx_flat p0	count=2
arg	[arg] to ||| [arg]	count=9
arg	subcircuit [arg] if it ||| [arg] subcircuit replace	count=1
function	[function] function takes ||| add simple [function]	count=1
function	intersection ||| intersection	count=4
arg	in s, and return ||| s	count=1
function	computes ||| dmp	count=3
class	returns ||| module poly	count=1
function	alpha and [function_2] ||| [function_2] [function_1]	count=1
function	a list into ||| list	count=1
arg	of a scalar ||| scalar	count=1
class	the function ||| holonomic function	count=3
function	if unicode output is ||| use unicode	count=1
function	return the quotient ||| quotient	count=1
function	finds the domain ||| not empty in	count=1
function_arg	function simplifies a boolean [function_1] [arg_2] ||| [function_1] logic [arg_2] deep	count=1
arg	[arg_1] to x ||| [arg_2] [arg_1]	count=3
function	returns the size ||| degree	count=1
function	always destroy ||| is only q	count=1
function_arg	of rational [arg_2] ||| [arg_2] [function_1]	count=1
arg	order ||| func order	count=10
function	it if ||| use	count=1
function	dmf ||| fraction	count=1
module	if possible ||| printing	count=1
function	nested tuple of ||| to tuple	count=1
function	to an ode ||| ode 1st	count=1
function	be of ||| limits	count=1
function_arg	[function_1] component ||| physics hep [function_1] [arg_2]	count=2
function	functions in finite_set in ||| in	count=1
class	the truth value of ||| piecewise	count=1
arg	a polynomial in k[x] ||| f m u k	count=1
function_arg	[function_1] 'other' ||| [arg_2] [function_1]	count=1
function	parametric surface ||| parametric surface	count=1
arg	s of ||| s	count=1
function	is puiseux series ||| rs is puiseux	count=2
arg	beta x ||| b x	count=1
arg	if a and b ||| a b	count=2
arg	suitable ||| iszerofunc simpfunc	count=1
function	[function_1] successfully decremented ||| [function_2] part [function_1]	count=1
class	[class_1] interval ||| [class_1] [class_2]	count=3
function	jacobian matrix of ||| jacobian	count=1
function	the right [function] by ||| [function]	count=1
function	of the ||| process	count=1
class	evaluate ||| evalf mixin	count=1
function	largest subset ||| pairwise most common	count=1
function	[function] from ||| [function]	count=7
function	[function_1] [function_2] ||| [function_2] part [function_1]	count=1
function	if possible ||| use	count=1
function_arg	[function_1] x representing ||| [arg_2] [function_1]	count=1
class	of this ||| sparse	count=1
arg	of functions ||| functions	count=1
arg	p ||| p u	count=2
function	instance to a ||| to	count=1
function	the string path to ||| func	count=1
function	result ||| result	count=1
function	form ||| limits	count=1
function	unit triangular ||| unit triangular	count=2
function	parallel to this ||| parallel	count=1
arg	p in ||| f p u	count=1
function	returns evaluation over ||| eval	count=1
arg	compute partial fraction ||| f x dummies	count=1
function	operation on [function_2] ||| [function_2] [function_1]	count=10
arg	alpha beta x gives ||| b x	count=1
function_arg	posform [arg_2] ||| [arg_2] [function_1]	count=1
function	non-central [function_2] ||| [function_2] [function_1]	count=2
arg	two univariate polynomials in ||| g	count=1
function	[function_1] sum to ||| [function_2] [function_1]	count=4
function	on a ||| on	count=1
class	in the ||| series	count=1
function	boolean [function] ||| [function]	count=1
arg	given annihilator ||| list_of parent negative	count=1
module	literal ||| logic algorithms	count=1
class	from the kb ||| kb	count=1
module	[module] of ||| [module]	count=1
function	returns maximum norm ||| dmp max norm	count=3
function	a finite difference ||| finite difference	count=2
function	legendre [function_2] ||| [function_1] [function_2]	count=1
arg	optimization opportunities in ||| exprs	count=1
class	currently at ||| factory	count=1
arg	permutations of n ||| n	count=1
module	a positive literal ||| logic algorithms	count=1
function	[function_1] constant term ||| [function_1] [function_2]	count=1
arg	user in the form ||| weylelt	count=1
function	the direct [function] ||| direct [function]	count=1
function	representation ||| form	count=1
module_class	[module_1] ellipse ||| [module_1] [class_2]	count=3
module_class	[module_1] __mod__ ||| [module_1] [class_2]	count=2
arg	from k0 ||| k0	count=1
function_arg	sine [arg_2] ||| [function_1] [arg_2]	count=2
function	normal ordered [function] where ||| normal ordered [function]	count=1
module_class	of [module_1] [class_2] object ||| [module_1] [class_2]	count=1
arg	phrase [arg_2] ||| [arg_1] symbols [arg_2]	count=1
arg	of the specified ||| superset	count=2
arg	of polynomials in k[x] ||| f g u k	count=1
arg	[arg] of ||| a [arg]	count=1
function	[function_1] decomposition algorithm ||| [function_1] [function_2]	count=1
class	__abs__ ||| domain	count=1
function	be written as ||| as f	count=1
arg	2 and n is ||| n	count=1
function	in terms ||| as	count=1
function	col ||| col	count=2
class	sequence of polynomials ||| poly ring	count=1
function	polynomial quotient ||| dmp quo	count=1
arg	f given [arg_2] ||| [arg_1] [arg_2]	count=2
function	:func _dup_decompose ||| dup left decompose	count=1
function	linear coefficients ||| linear coefficients	count=2
arg	_hastypes [arg_2] ||| [arg_2] [arg_1]	count=2
function	k[x] using horner scheme ||| dup eval	count=1
function	that dummies can ||| dummies	count=1
function_arg	[function_1] [arg_2] such that for the ||| [function_1] [arg_2]	count=1
function	with constant ||| constant coeff	count=1
function	coordinates ||| coordinates	count=2
module_class	[module_1] sought after ||| [module_1] [class_2]	count=3
function	compute the orbit of ||| orbit	count=1
function	evaluate a polynomial ||| eval	count=2
arg	:func rsolve_hypergeometric for details ||| x re g	count=1
function	values above ||| only above	count=1
function	[function_1] cancellation deg ||| [function_2] [function_1]	count=1
arg	p [x] polynomial ||| f p k	count=4
arg	in the mul ||| mul	count=1
function	devise ||| devise	count=1
class	of indices creating ||| index structure	count=1
class	writes ||| fcode gen	count=2
arg	of the given representation ||| f	count=1
function	negative coefficient muls ||| opt	count=1
function	[function_1] a raw ||| [function_1] [function_2]	count=1
function_arg	leading degree [arg_2] ||| [function_1] [arg_2]	count=3
arg	c ||| c	count=6
arg	returns true if two ||| other	count=6
class	dyadic and a ||| dyadic	count=1
function	of a list ||| list	count=1
arg	true if expr ||| expr	count=2
function	this method converts a ||| letter form to	count=1
module	no bounding rectangles of ||| polys	count=1
function_arg	[function_1] bits to ||| [arg_2] [function_1]	count=1
arg	variable representing a ||| name n p succ	count=1
arg	in expr, given that [arg_1] [arg_2] ||| [arg_1] [arg_2]	count=1
function	the gray code ranking ||| rank gray	count=1
function	what counter ||| counter	count=1
module	clause l the ||| algorithms	count=1
function_arg	linear [arg_2] ||| [function_1] [arg_2]	count=1
function	positional [function_2] ||| [function_1] [function_2]	count=1
function	quadratic in all its ||| quadratic	count=2
arg	n ||| n x x	count=1
arg	the sequence ||| seq	count=2
function	[function_1] order ||| [function_1] [function_2]	count=3
arg	for [arg_2] ||| [arg_2] [arg_1]	count=2
module_class	the curve ||| geometry curve	count=1
module	the underlying [module_2] ||| [module_1] [module_2]	count=2
arg	in [arg_2] ||| [arg_1] p [arg_2]	count=1
function	of symbolic values to ||| dict	count=1
function_arg	[function_1] [arg_2] (default is '|') and ||| [function_1] [arg_2]	count=3
function	the frobenius map parameters ||| frobenius map	count=1
function	the medial ||| medial	count=1
function	[function_1] set of ||| [function_2] [function_1]	count=4
function	this [function] eliminates one ||| elimination [function]	count=1
function	system of [function_2] ||| [function_2] [function_1]	count=2
function_arg	groups [arg_2] ||| [function_1] [arg_2]	count=3
arg	if a given scipy ||| circuit nqubits identity_only eps	count=1
module	an ||| core	count=1
arg	and a ||| a	count=5
function_arg	bivariate integer [arg_2] ||| [arg_2] [function_1]	count=1
arg	opportunities ||| order	count=1
function	into a basic expression ||| to basic	count=1
arg	2 ; -1 if [arg_1] [arg_2] 2 1 or 2 ||| [arg_1] [arg_2]	count=1
function	wrapper around ||| wrapper	count=1
function	1 instead of ||| combine inverse	count=1
class	bounding rectangles ||| root	count=1
function	returns f + g*h ||| add mul	count=2
arg	cf ||| cf	count=1
arg	such ||| a	count=1
function	finite ||| finite	count=5
arg	with private key ||| key	count=1
arg	polynomial in k[x] ||| u k	count=3
function	of the matrix ||| eval matrix	count=1
class	limits ||| with int limits	count=2
arg	apply func to [arg_1] [arg_2] ||| eapply func [arg_1] [arg_2]	count=4
arg	f in f[x] ||| f k	count=1
arg	enforce ||| inv_perm	count=1
arg	fp_group ||| elm_rounds simp_rounds	count=1
class	point object ||| point	count=1
function	in ||| empty	count=2
class	creation for julia ||| julia	count=1
class	of ||| llvmjit code	count=2
function_arg	coefficients of [arg_2] ||| [function_1] [arg_2]	count=3
function	[function_1] heuristic uses ||| [function_1] [function_2]	count=1
arg	n [arg_2] ||| functions elementary root arg [arg_1] [arg_2]	count=4
arg	3 angular momenta for ||| aa bb cc prec	count=1
function	into a tuple ||| dup to tuple	count=3
function	get a ||| get	count=7
function	cholesky factorization ||| cholesky	count=1
arg	rsolve_hypergeometric for details ||| f x re	count=1
function	to a list ||| list	count=1
function	rotation ||| orient	count=1
function	[1 ||| lex	count=1
arg	a meijer ||| a b	count=1
function	measure of ||| measure	count=1
module	in the ||| physics	count=13
function	symbol for ||| auto symbol	count=1
function	ascents in ||| ascents	count=1
arg	of theta in ||| theta	count=3
arg	replaced by the ||| kwargs	count=1
arg	rank rank over self ||| rank	count=1
function	[function_1] rotational gradients ||| [function_1] [function_2]	count=1
class	integration ||| integral	count=1
class	writes a ||| fcode	count=1
function_arg	[function_1] process ||| [arg_2] [function_1]	count=2
arg	wrt a given field ||| field coord_sys	count=1
function	evaluate the parts of ||| eval	count=1
function	a matrix if components ||| matrix	count=1
function	random complex values if ||| random	count=1
arg	function out ||| test compileflags out	count=1
function_arg	[function_1] in k[x] ||| [function_1] expand [arg_2]	count=1
function_arg	over [arg_2] ||| [arg_2] [function_1]	count=1
module	or containers of ||| polys	count=1
arg	order ||| order match	count=8
function_arg	helper [arg_2] ||| [function_1] [arg_2]	count=4
function	for the function prototype ||| get prototype	count=2
function	not zero ||| zero	count=1
function_arg	[function_1] [arg_2] is omitted ||| [function_1] [arg_2]	count=6
function	system ||| solve linear system	count=1
function	expr ||| count ops	count=1
arg	position ||| position	count=1
module	see if ||| pretty	count=1
arg	of f in f[x] ||| f	count=1
class	tensor product ||| tensor product	count=2
function	matrix to rotate ||| rotate	count=1
function	of zeros square if ||| zeros	count=1
arg	'other' ||| other	count=1
class	basis ||| bosonic basis	count=1
arg	a start ||| a start	count=1
function	list of indices ||| indices	count=1
arg	to two ||| g	count=1
function	[function_1] fraction object ||| [function_2] [function_1]	count=8
module	basic function for printing ||| printing	count=1
class	of symbolic values to ||| code	count=1
arg	the rotations are applied ||| name angle1 angle2 angle3	count=1
class	of ||| properties	count=1
function_arg	the reduced [arg_2] ||| [function_1] f [arg_2]	count=1
arg	isolating interval of ||| s t eps	count=2
function	[function_1] a series ||| [function_2] [function_1]	count=4
arg	an expression f 3 ||| f	count=1
arg	at a in ||| f m a	count=1
arg	series modulo o(x**prec) examples ||| p1 x prec	count=1
module	take on a ||| series	count=1
arg	row-wise ||| matlist1 matlist2 k	count=1
arg	modulo a polynomial p ||| p u	count=1
function	log hint ||| log	count=1
class	a diagram ||| diagram	count=1
function	is available and leverage ||| use	count=1
arg	of two polynomials in ||| g	count=3
function	into a string path ||| mod func	count=1
function	real roots of a ||| real roots	count=4
function	"least common multiple" ||| sdm monomial lcm	count=1
arg	k[t], returns (n1 ||| de coefficientd z	count=1
function	solves a system of ||| solve	count=1
module	sparse matrix ||| matrices	count=1
function_arg	multiplication of two ||| mul f g	count=1
function	[function_1] subset of ||| [function_1] [function_2]	count=2
function_arg	degrees of [arg_2] ||| [arg_2] [function_1]	count=1
function	n-th coefficient of ||| nth	count=4
function	finite difference ||| finite difference	count=2
class	to this [class] which ||| [class]	count=1
class	symbolic values ||| code	count=1
function	add c(x_2 x_u)*x_0**i to ||| add term	count=1
module	create a ||| series	count=1
function_arg	[function_1] p [x] ||| [function_1] from dict [arg_2]	count=3
function	the [function] of the ||| [function]	count=1
function	the following ||| numer denom	count=1
arg	is replaced ||| kwargs	count=1
function	[function_1] matrix to ||| [function_2] [function_1]	count=2
function	the root [function] directory and ||| [function]	count=1
module	is a [module] number ||| [module]	count=1
function	possible ||| try use	count=1
function	into a ||| dup to	count=1
module	the order of ||| physics	count=1
class	or ||| poly ring	count=1
function	form of singularity ||| as singularity	count=1
function	lmq upper bound for ||| dup root upper bound	count=1
module	of the class ||| utilities	count=1
class	[class] 'rotation ||| coord [class]	count=1
class	a standard basis ||| sub module	count=1
function	the functions in ||| in	count=1
arg	[arg_1] and returns ||| [arg_1] [arg_2]	count=3
function	atanh of p, about ||| rs atanh	count=1
function	with [function_2] ||| [function_2] [function_1]	count=2
function_arg	power [arg_2] ||| [arg_2] [function_1]	count=5
function	the lower central ||| lower central	count=2
module	function for printing ||| printing	count=1
function	always create a quasi-particle? ||| is only q creator	count=1
class	rotate ||| geometry entity	count=1
function	concatenates ||| col join	count=1
function	return the components ||| components	count=1
arg	the components data ndarray ||| data	count=1
module	the form obj ||| physics mechanics	count=1
class	coordinate system with ||| coord sys	count=2
arg	[arg] (default is ||| [arg]	count=3
function_arg	[function_1] function for ||| [arg_2] [function_1]	count=1
function	univariate ||| root	count=1
class	the ring ||| ring	count=1
function_arg	[function_1] coords ||| [function_1] to to_sys [arg_2]	count=1
arg	x of ||| n x	count=1
class	update the kb ||| kb	count=1
function	convert the ||| convert	count=1
module	the added integration ||| physics vector	count=1
function	pendulum ||| link pendulum	count=1
function	groebner basis is zero-dimensional ||| is zero dimensional	count=1
class	polynomial p by ||| poly	count=1
function	number of [function_2] ||| [function_1] [function_2]	count=2
function	t ||| t	count=1
function	cross product between ||| cross	count=1
function	return tuple representation ||| as tuple	count=1
function	[function_1] "x" ||| [function_2] [function_1]	count=2
arg	domain of [arg_2] ||| [arg_2] [arg_1]	count=2
function	common ending ||| common suffix	count=2
arg	[arg_1] yield origin ||| [arg_1] [arg_2]	count=3
arg	new instance [arg_2] ||| [arg_1] [arg_2]	count=1
function	[function_1] inequality ||| [function_2] [function_1]	count=2
function	polynomial lcm of ||| lcm	count=2
function	laguerre [function_2] ||| [function_2] [function_1]	count=1
arg	p k using the ||| b p	count=1
function	files default from ||| test files	count=1
arg	terms ||| terms	count=2
arg	the root if ||| cls root radicals	count=1
arg	about c ||| n c	count=1
module	convert the quantity ||| physics	count=1
arg	p [x]/ g using ||| n g p	count=1
function	take a continuous subsequence ||| slice	count=5
function	to take [function] wrt to ||| [function]	count=1
module	of tensors ||| tensor	count=1
function	event [function_2] ||| [function_2] [function_1]	count=1
function	small enough ||| small	count=1
arg	s > a ||| s a	count=1
function	refine a ||| dup outer refine real	count=1
function	function for a ||| function	count=1
function_arg	[function_1] a field ||| [arg_2] [function_1]	count=8
function	if matrix is ||| is	count=1
class	dimension ||| type b	count=1
arg	coefficient d ||| d	count=2
function	and the name of ||| mod func	count=1
class	of pstack ||| multiset partition traverser	count=1
class	[class_1] n-dim ||| [class_2] [class_1]	count=2
arg	by a key ||| key	count=1
function_arg	to check [arg_2] ||| [arg_2] [function_1]	count=3
function_arg	addends of [arg_2] ||| [function_1] [arg_2] key1	count=2
function	whether function [function_2] ||| [function_2] rational [function_1]	count=4
arg	determine the ||| expr return_dummies	count=1
function	as a ||| as numer denom	count=1
function	the cartan matrix ||| cartan matrix	count=2
function	is available ||| pretty try	count=1
class	sparse n-dim array of ||| sparse ndim array	count=1
function	returns the variables ||| variables	count=1
function	gmpy's mpq ||| qq gmpy	count=2
module	find ||| simplify	count=1
class	occupation numbers ||| fock state	count=1
function_arg	[function_1] of a ||| [arg_2] [function_1]	count=46
arg	[arg_1] h ||| [arg_2] [arg_1]	count=4
arg	of square-free polynomial using ||| polys k	count=1
function	greatest factorial factorization of ||| gff list	count=1
arg	a 2-d point about ||| th	count=1
function	path to ||| get mod func	count=2
arg	o ||| o k	count=1
function	return the series expansion ||| intcurve series	count=1
function	have initial ||| have init	count=1
arg	of f ||| f x m	count=1
arg	in the sympy sense ||| include	count=1
function	[function_1] list of ||| [function_1] [function_2]	count=3
function	[function_1] using a ||| [function_2] [function_1]	count=4
arg	equal to n ||| n	count=1
arg	variable ||| name p	count=1
class	transform is evaluated ||| transform	count=1
arg	[x] for medium p ||| p k	count=1
arg	[arg_1] symbol ||| [arg_2] [arg_1]	count=4
function	replace constants by functions ||| simplify variable	count=1
function	full partial fraction decomposition ||| full decomposition	count=1
function	rational generating [function_2] ||| [function_2] [function_1]	count=6
function	width ||| width	count=1
arg	compute partial fraction ||| f x	count=1
function	the block ||| block	count=1
arg	z )[x] using a ||| minpoly	count=1
function	cyclotomic [function_2] ||| [function_1] [function_2]	count=3
function	proper line ||| get statement	count=1
function	run all [function_2] ||| [function_1] [function_2]	count=1
function	from sympy to ||| from sympy	count=2
module	on the ||| combinatorics	count=1
function	sort of ||| sort	count=1
module	a [module] that follows ||| [module]	count=1
function	reduce ||| trunc	count=1
function	the proper line ||| statement	count=1
module	a checked [module] for ||| [module]	count=1
function	recursive helper function for ||| rec degree	count=1
module	[module_1] the three ||| [module_2] [module_1]	count=2
function_arg	ben-or's [arg_2] ||| [function_1] [arg_2]	count=5
function	computes the discriminant ||| discriminant	count=1
function_arg	[function_1] an expression ||| [arg_2] [function_1]	count=6
function	on ||| on	count=2
arg	strip given by ||| strip	count=1
function	a proper ||| proper	count=2
function	path to a class ||| mod func	count=1
function	full partial fraction ||| list full	count=1
arg	func remains in ||| func hint	count=1
arg	p [arg_2] ||| [arg_1] [arg_2]	count=62
function	[function_1] structure ||| [function_1] [function_2]	count=3
function	the truth value of ||| cond	count=1
class	body orientation ||| body orienter	count=1
function	an explicit [function] possibly ||| [function]	count=1
class	that no bounding rectangles ||| root	count=1
function	an ode ||| ode 1st	count=1
function	a root ||| root	count=3
arg	of symbols ||| symbols filter	count=1
class	a scalar ||| covar derivative	count=1
function	lmq lower bound ||| lower bound	count=1
function	[function_1] zero-dimensional ||| [function_1] [function_2]	count=5
function	to ||| create	count=1
function_arg	[function_1] of f ||| polys dmp apply [function_1] [arg_2]	count=1
function	difference between two ||| difference	count=1
class	return ||| permutation group	count=1
function_arg	[function_1] function which ||| [arg_2] [function_1]	count=2
arg	by [arg] ||| [arg] z	count=2
function	careful! any evalf of ||| evalf	count=1
function_arg	in gf [arg_2] ||| [function_1] gcd f g [arg_2]	count=2
function	polynomial of cos ||| minpoly cos	count=1
function	multiply a sequence ||| mul	count=1
function_arg	lcm of [arg_2] ||| [function_1] [arg_2]	count=8
function	multivariate polynomials over ||| dmp gf	count=1
function	to correct the ||| correct	count=1
function_arg	- g*h [arg_2] ||| [function_1] f [arg_2]	count=1
function	[function_1] triangle ||| [function_2] [function_1]	count=2
module_class	returns [class_2] ||| [module_1] [class_2]	count=14
function	a non-central ||| noncentral	count=1
function_arg	to couple [arg_2] ||| [arg_2] [function_1]	count=3
function_arg	of coefficients [arg_2] ||| [function_1] [arg_2]	count=3
arg	generate a ||| a	count=1
arg	item in the sequence ||| seq	count=1
arg	by g ||| g auto	count=6
function	gray coding [function_2] ||| [function_2] [function_1]	count=1
function	computes the gauss-chebyshev ||| gauss chebyshev u	count=1
function	[function_1] a fourier ||| [function_2] [function_1]	count=1
arg	[arg_1] x ||| [arg_1] [arg_2]	count=28
arg	theta in ||| theta	count=3
function	of the underlying undirected ||| get undirected graph	count=1
function	smallest primitive root ||| primitive root	count=2
function	exponent of ||| exponent	count=1
function	and beta ||| beta	count=1
function	down ||| down	count=2
function	f - a where ||| sub ground	count=1
class	mapping of ||| code	count=1
function	operators ||| operators	count=2
function	less ||| lt	count=1
function	next to each ||| next	count=1
arg	a condition on that ||| condition	count=1
function_arg	continuous subsequence [arg_2] ||| [function_1] f [arg_2]	count=1
function	heuristic assumes the ||| lie heuristic	count=1
function	method converts a list ||| form to	count=1
class	[class] uses the ||| [class]	count=1
class	self to the module ||| module	count=1
class	the polynomial ||| poly	count=2
arg	[arg_1] if ||| eapply func [arg_1] [arg_2]	count=1
arg	message [arg] is a ||| [arg]	count=1
function	around ||| power exp	count=2
function	identity is a ||| is	count=1
arg	n and ||| factors n	count=1
arg	] to k[ x_j ||| j	count=1
function	b ||| change ics	count=1
function	[function_1] fourier ||| [function_2] sin [function_1]	count=1
function	interval for most functions ||| interval	count=1
class	generate ||| module poly	count=1
function_arg	[function_1] from intqubit ||| [arg_2] [function_1]	count=3
class	number [class] ||| [class]	count=1
function	intended ||| vv 2	count=1
arg	given backend return ||| backend	count=1
function	a simplified [function_2] ||| [function_1] [function_2]	count=4
function	equation [function_2] ||| [function_2] [function_1] func_class f symbol	count=1
function_arg	[function_1] p [x] ||| [function_1] neg [arg_2]	count=4
class	dictionary mapping ||| mul	count=1
arg	f ||| f n k	count=5
arg	g are ||| g x	count=1
function	[function_1] sort of ||| [function_2] [function_1]	count=1
arg	polynomial in x_j at ||| j	count=1
class	compute the determinant ||| matrix determinant	count=1
function_arg	[function_1] element to ||| [function_1] [arg_2]	count=1
class	a density ||| density	count=1
class	the truth value ||| piecewise	count=1
function	tree as a ||| tree	count=1
arg	real inverse_mellin_transform function this ||| s x_ strip	count=1
arg	dum indices on ||| dum	count=1
arg	or second default kind ||| kind	count=1
function_arg	norm of [arg_2] ||| [arg_2] [function_1]	count=16
arg	a single symbol e ||| a b w	count=1
function_arg	sopform [arg_2] ||| [arg_2] [function_1]	count=1
function	the best solution ||| coeff best	count=1
class	generated ||| octave code gen	count=2
arg	sum is also a ||| root1 root2	count=1
class	compute ||| ring	count=1
arg	algorithm i ||| g n	count=1
function	evalf ||| evalf	count=1
function_arg	linearizer [arg_2] ||| [arg_2] [function_1]	count=3
function	basic element is ||| element	count=1
arg	set of operators a ||| operators	count=1
arg	function ||| argindex	count=1
function	make a [function_2] ||| [function_2] [function_1]	count=3
arg	for two univariate polynomials ||| g p	count=1
arg	f in the given ||| f	count=1
arg	\xi ||| match comp	count=1
function	addends ||| addends	count=1
function	returned by residue_reduce() ||| residue reduce	count=1
function	the lmq lower bound ||| dup root lower bound	count=1
class	and d) [class] a, such ||| [class]	count=1
class	value ||| series	count=1
function	[function_1] constant ||| [function_1] [function_2]	count=3
function	the new coordsyscartesian with ||| init	count=1
class	the generated ||| octave	count=1
function	[function_1] k t ||| [function_2] [function_1]	count=2
module_class	the [class_2] ||| [module_1] optics ray transfer [class_2]	count=4
function	reverse [function_2] ||| [function_2] [function_1]	count=3
function_arg	when [arg_2] ||| [function_1] [arg_2]	count=4
function	ode from the two ||| ode 1st homogeneous	count=1
arg	col that ||| col	count=1
function	compute the hash ||| hashable content	count=1
class	of symbolic ||| llvmjit	count=1
arg	lhs - ||| lhs	count=2
module	none ||| core	count=2
function	coefficient from ||| coeff	count=1
arg	constant p in ||| f p	count=2
function	the form x ||| process	count=1
arg	mod(p** s ||| s p	count=1
class	returns the ||| series	count=1
arg	operations in expr ||| expr visual	count=2
function	splits a list into ||| split list	count=1
function	an integer ||| term to integer	count=1
arg	namespace dict with function ||| expr namespace	count=1
class	whose elements have the ||| partition	count=1
arg	an ||| cls	count=6
arg	of target_units, whenever ||| target_units	count=1
class	polar numbers is flaky ||| polar	count=1
module	self with oth, that ||| polys agca	count=1
function	gtk ||| gtk	count=1
class	py ||| sym py	count=1
class	files ||| octave	count=1
function	chi-squared ||| chi squared	count=1
class	plane and another ||| plane	count=1
arg	is normally ||| independent recursive_limit _recursive_depth	count=1
function	using lusolve and ||| lu	count=1
arg	x_j in k[x] ||| m n j	count=1
function	compute square-free [function_2] ||| [function_2] [function_1]	count=4
arg	variable with a ||| name a b c	count=1
function	a rational generating function ||| guess generating function	count=1
arg	apply func to every ||| func	count=1
function	returns intrinsic [function_2] ||| [function_1] [function_2]	count=1
function	[function_1] elements ||| [function_1] [function_2]	count=1
module	positions ||| combinatorics	count=2
class	a ||| gen	count=2
function	horizontal morphism checks ||| horizontal	count=1
module_class	step of [class_2] ||| [module_1] [class_2]	count=2
function	'/' separated [function_1] [function_2] (os ||| [function_2] [function_1]	count=3
arg	it converts components data ||| data	count=1
function	run the examples in ||| run	count=1
function	is available and ||| pretty	count=1
function	free module ||| free module	count=1
class	col ||| sparse matrix	count=1
function	the ket on the ||| ket	count=1
module	from sympy core ||| core	count=1
function	a loop ||| process loop	count=1
class	of the ||| entity	count=1
class	returns ||| g	count=1
arg	given ||| symbol	count=1
function_arg	[function_1] f with ||| [arg_2] [function_1]	count=2
function	function with ||| function	count=1
class	linear [class_2] ||| [class_1] [class_2]	count=4
function	[function_1] thus ||| [function_2] [function_1]	count=4
function	the standardised right coset ||| coset	count=1
function	linearizer class initiated from ||| to linearizer	count=1
function	gives the direction cosine ||| direction cosine	count=1
class	(i ||| series base	count=2
function	random [function_2] ||| [function_1] [function_2]	count=5
arg	from k0 to k1 ||| u k0 k1	count=1
function	semi-latus [function_2] ||| [function_2] [function_1]	count=1
class	the xy-pic representation of ||| drawer	count=1
arg	and b have ||| b	count=1
arg	two ||| g k	count=1
function	[function_1] root edge ||| [function_2] [function_1]	count=1
function	technique ||| technique	count=1
function	of the class ||| mod	count=1
function	the strided scheme ||| strides	count=1
function	a class ||| get mod func	count=1
function	find_unit_clause but arguments are ||| clause	count=1
function	into a nested tuple ||| dmp to tuple	count=1
module	matrix ||| physics quantum	count=1
function	quadratic ternary diophantine equation ||| diop ternary quadratic normal	count=1
function	singularity functions ||| singularity function	count=1
arg	_hasattrs and _hastypes ||| attrs types	count=1
function	[function_1] a finite ||| [function_2] [function_1]	count=1
function	[function] argument ||| [function]	count=1
arg	[arg_1] x_0 ||| [arg_2] [arg_1]	count=2
function	normalize all coefficients ||| gf normal	count=1
function	return [function_1] [function_2] ||| [function_1] [function_2] expression interval symbol	count=2
arg	finite_set is ||| finset_intersection	count=1
function	square-free polynomial ||| sqf	count=3
function	paths into a ||| paths	count=1
arg	by removing superfluous factors ||| period full_pb	count=1
function	splits ||| get mod func	count=1
arg	g modulo p ||| g p	count=1
arg	expression ||| expr	count=28
class	the given ||| expr	count=2
function	frequency ||| frequency	count=1
arg	function for ||| expression predicate interval	count=1
arg	rv that ||| rv	count=1
arg	index1 ||| index1	count=1
function	[function_1] where ||| [function_1] [function_2]	count=9
function_arg	[function_1] to x ||| [arg_2] [function_1]	count=1
function	maximum of ||| imax	count=1
class	return ||| matrix base	count=1
function_arg	return a transversal of [function_1] [arg_2] second method described in ||| [function_1] transversal [arg_2]	count=2
function	homogeneous ||| homogeneous	count=2
arg	ops to ||| ops	count=1
function	[function] objects ||| [function]	count=1
function	always destroy ||| is only q annihilator	count=1
arg	expansion of an expression ||| expr a prec	count=1
function_arg	[function_1] where f ||| [function_1] [arg_2]	count=16
arg	medium p ||| p k	count=1
arg	add the ||| s	count=1
function_arg	a root [arg_2] ||| [arg_2] [function_1]	count=2
arg	by ||| k	count=1
module	+ 1 ||| solvers	count=1
class	the ||| linear entity	count=2
arg	differential equation ||| match	count=2
function	lie algebra associated with ||| lie algebra	count=3
arg	of f ||| p f	count=1
function	distinct real ||| count real	count=1
function	the positional [function_2] ||| [function_2] [function_1]	count=1
function	+ cz^2 + dxy ||| normal	count=1
function	solve multivariate ||| dmp zz	count=1
arg	k[x] ||| u k zero	count=1
function	[function_1] surface ||| plotting plot3d [function_1] [function_2]	count=1
function	is a sequence ||| is sequence	count=3
function_arg	floor [arg_2] ||| [arg_2] [function_1]	count=2
function	it is assumed ||| modified subresultants pg	count=1
arg	make poly ||| poly	count=1
module	the initialization of lagrangesmethod ||| physics mechanics	count=1
function	into a string path ||| func	count=1
function	subgroup whose presentation ||| presentation	count=1
module	none if the constancy ||| core	count=1
function	sorted [function_2] ||| [function_2] [function_1]	count=1
module	matrix ||| tensor array	count=1
class	non-conjugate ||| of	count=1
class	to ||| latex printer	count=4
function	exact domain ||| exact	count=1
function	parse and configure ||| parse order	count=1
function	linearize ||| linearize	count=2
class	n-dim array ||| ndim array	count=2
function	derivative of ||| derivative	count=3
arg	characters to ||| s	count=1
module	[module] the expression ||| [module]	count=1
function	a subset ||| subset	count=1
function	as hlt+lookahead method of ||| look ahead	count=1
class	no bounding ||| complex root of	count=1
class	write a cython file ||| cython	count=1
function_arg	element is [arg_2] ||| [arg_2] [function_1]	count=4
function	postprocess an expression ||| postprocess	count=1
function	method for the taylor ||| taylor	count=1
arg	compute numerical approximations ||| n maxsteps cleanup	count=2
arg	n [arg] n of ||| n [arg]	count=1
function	be used to couple ||| couple	count=1
function	is a cyclotomic polnomial ||| dup cyclotomic p	count=1
class	the ground ||| dmp	count=1
function	pollard's rho ||| rho	count=1
arg	in p [arg_2] ||| [arg_1] [arg_2]	count=1
class	morphisms of a diagram ||| diagram	count=1
function_arg	a sequence [arg_2] ||| [arg_2] [function_1]	count=1
function_arg	sequence [arg_2] ||| [function_1] i [arg_2]	count=1
function	coefficient ||| coefficients	count=1
module	augmented by the kinematic ||| physics mechanics	count=1
function	variation of parameters ||| variation of parameters	count=2
class	the kb ||| prop kb	count=1
arg	k is equal ||| k	count=1
arg	expression about c ||| n c condition	count=1
module	method adds up the ||| physics	count=1
function_arg	an error [arg_2] ||| [function_1] [arg_2]	count=1
module	leverage it if possible ||| printing pretty	count=1
function_arg	dict [arg_2] ||| [function_1] reorder [arg_2]	count=1
arg	using vincent-akritas-strzebonski vas continued ||| f k	count=1
function_arg	true if two ||| is disjoint other	count=2
function	total [function_2] ||| [function_2] [function_1]	count=2
class	return ||| field	count=1
function	[function_1] free indices ||| [function_1] [function_2]	count=2
function	the derivation ||| derivation	count=1
function	algebraic ||| algebraic	count=1
class	a root ||| root	count=1
function	berkowitz algorithm [function] ||| eval berkowitz [function]	count=1
function	is written [function_2] ||| [function_2] [function_1]	count=2
class	the picture ||| string pict	count=1
class	no bounding rectangles ||| root	count=1
arg	is replaced by ||| args kwargs n	count=1
module	prime factors ||| ntheory	count=2
function	degree of the ||| find degree	count=1
function	pohlig-hellman algorithm [function_2] ||| [function_2] log [function_1]	count=1
function	refine a [function_2] ||| [function_2] [function_1]	count=4
arg	in x_0 in k[x] ||| m u k	count=1
arg	evaluate [arg_1] [arg_2] ||| eval [arg_1] p [arg_2]	count=1
function	f + a where ||| add ground	count=1
arg	j_1 [arg_2] ||| [arg_2] [arg_1]	count=6
module	(real=true) with ||| geometry	count=1
function	solve the equation using ||| solve	count=1
function	leading nonzero ||| as leading	count=1
function	according to whether ||| from indices	count=1
function	[function_1] [function_2] in a ||| [function_1] [function_2]	count=2
module	takes this ||| vector	count=1
function	of ||| of	count=4
arg	that [arg] ||| [arg]	count=1
function	[function_1] a product ||| [function_2] [function_1]	count=8
function	written as g* a ||| as	count=1
function_arg	discriminant [arg_2] ||| [arg_2] [function_1]	count=1
module_class	[module_1] body ||| [module_1] [class_2]	count=8
module	-- return number ||| core	count=1
arg	x_j in k[x] ||| m j u	count=3
arg	h are ||| h k	count=2
function	[function_1] evaluation points ||| [function_1] [function_2]	count=2
arg	a polynomial ||| cls poly	count=2
function	a power ||| power	count=1
function_arg	[function_1] an ||| [function_1] add [arg_2]	count=1
module	function and returns the ||| functions elementary	count=1
function	the largest subset of ||| pairwise most common	count=1
function	wrapper around expand ||| expand power	count=2
class	g_2 ||| type g	count=1
arg	with [arg] turn is ||| matlist index1 [arg]	count=1
arg	to fringe and returns ||| fringe grid	count=1
arg	for constructing ||| grid morphisms_str_info	count=1
function	the generated ||| get	count=2
function	to ||| state to	count=1
function	[function_1] polynomials ||| [function_2] [function_1]	count=2
function	leverage it if ||| pretty try use	count=1
arg	variable with [arg_2] ||| [arg_1] p [arg_2]	count=1
arg	to the curl ||| vect doit	count=1
function	equation with constant coefficients ||| constant coeff	count=4
function	parity ||| parity	count=1
function	a shallow copy of ||| copy	count=1
module	and ||| core	count=2
function	[function_1] principal ||| [function_2] [function_1]	count=1
function	of rational ||| rational	count=1
function	[function_1] ring ||| [function_1] [function_2]	count=8
function	bound ||| bound	count=2
function	gate ||| gate	count=1
module	it if ||| pretty	count=1
arg	g modulo ||| g	count=1
arg	an expression [arg_2] ||| [arg_1] [arg_2]	count=7
module	the actual work ||| physics	count=1
module	the list of possible ||| physics	count=1
arg	cong 0 mod(p** s ||| s	count=1
function	ben-or's ||| gf irred p ben or	count=1
module	the domain of ||| calculus	count=1
function	solves the general ||| diop general	count=1
arg	system of two ||| g	count=1
module	of two [module] expressions ||| [module]	count=2
function	largest subset of elements ||| pairwise most common	count=1
function	create a gf ||| gf	count=2
module	a class into a ||| utilities	count=1
function	helper for solveset ||| solveset	count=1
function	of [function_2] ||| [function_1] [function_2]	count=4
class	from which docstrings ||| doc tests	count=1
class	adds ||| add	count=1
function	equations into [function] form ||| linear eq to [function]	count=1
arg	instance from ||| cls	count=1
arg	g functions assuming ||| g	count=1
function	the primitive ||| primitive	count=1
function	a list ||| list include	count=2
class	a ||| series	count=1
function	compute the hilbert ||| eval hilbert	count=1
class	to compute the determinant ||| matrix determinant	count=1
class	meijer g-function ||| meijerg	count=1
arg	z of the equation ||| z	count=1
function	finite_set ||| empty	count=1
arg	cipher [arg_2] ||| [arg_2] [arg_1]	count=1
class	[class] of a ||| multiset [class]	count=1
arg	p is ||| p c	count=1
function	a polynomial [function] ||| [function] sqf	count=1
arg	function for the ||| func	count=2
function	to their associated ||| to	count=1
function	the name of ||| get mod func	count=1
function	a homomorphism ||| hom	count=1
arg	[arg_1] interval ||| [arg_2] [arg_1]	count=9
function	a root of a ||| indexed root	count=1
function	according to ||| signature from	count=1
function	[function_1] power ||| [function_1] [function_2]	count=3
function	list of irreducible ||| factor list include	count=6
module	diagonal [module] from ||| [module]	count=1
function	inoutargument and result ||| result variables	count=1
module	from the list ||| physics quantum	count=1
arg	f ||| f roots	count=1
function	in the series expansion ||| rs	count=1
module	of two [module] expressions two ||| [module]	count=1
function	whether there is ||| check	count=2
class	generated ||| code gen	count=2
arg	d with knots ||| d knots n	count=3
function	[function_1] decomposition ||| [function_2] [function_1]	count=1
module	of ||| calculus	count=1
function	[function_1] and ||| find [function_2] [function_1]	count=2
function	trace [function_2] ||| [function_2] [function_1]	count=6
function	posform ||| posform	count=1
function	triangle ||| find triangle	count=1
function	a gf ||| gf	count=5
function	closing ||| get routine ending	count=1
arg	f x , \xi ||| match comp	count=1
arg	isolating interval ||| eps	count=2
function	and ||| and join	count=1
function	mignotte [function_2] ||| [function_2] [function_1]	count=3
function	sequences at ||| seq	count=1
function_arg	term in [arg_2] ||| [arg_2] [function_1]	count=10
class	a grid laid out ||| grid	count=1
function	the width of ||| width	count=1
arg	interval s [arg_2] ||| [arg_2] [arg_1]	count=1
arg	[arg] uses ||| [arg]	count=3
arg	func remains in unevaluated ||| func hint	count=1
function	the string ||| get mod func	count=1
arg	normal_order look through ||| recursive_limit _recursive_depth	count=1
class	mutabledensendimarray to ||| dense ndim	count=1
function_arg	[function_1] in k[x] ||| [arg_2] [function_1]	count=32
arg	of terms of f ||| f x m	count=1
arg	composite polynomial [arg_2] ||| [arg_2] [arg_1]	count=1
module	those ||| series	count=1
class	partition of ||| integer partition	count=1
function_arg	[function_1] [arg_2] ||| [function_1] diagram [arg_2]	count=4
arg	[arg_1] and the ||| [arg_2] [arg_1]	count=2
arg	grid ||| grid	count=1
arg	-> x ||| x	count=1
function	meijerg ||| meijerg	count=1
function_arg	[function_1] [arg_2] '|') and words by ||| [function_1] [arg_2]	count=3
function_arg	convert element to ||| convert element base	count=1
function_arg	operators [arg_2] ||| [function_1] obj [arg_2]	count=2
function_arg	apply [arg_2] ||| [function_1] [arg_2]	count=1
arg	in sdm form ||| extended	count=1
arg	symbols with those of ||| symbols	count=1
module	as ||| integrals	count=1
arg	solves a transcendental equation ||| eq	count=1
function_arg	matrix to [arg_2] ||| [arg_2] [function_1]	count=2
function	+ ||| add	count=6
class	[class_1] [class_2] examples ||| [class_1] [class_2]	count=1
module	the list ||| physics quantum	count=1
arg	or multiplicative separation approach ||| fun sep strategy	count=1
class	compute real root ||| root of	count=1
module	of the polyhedra we ||| combinatorics	count=1
arg	y are : ||| y	count=1
module	to the beginning of ||| utilities	count=1
arg	expression ||| expr var evaluate	count=2
arg	mobius transform or an ||| eps	count=1
function	point ||| point	count=8
function	gate identity ||| random identity	count=1
arg	[arg_1] g and ||| [arg_1] [arg_2]	count=1
arg	function g ||| g a	count=1
module_class	list of polynomial ||| polys poly ring	count=1
arg	a single ||| x a	count=1
arg	return namespace dict ||| expr namespace	count=1
module_class	[module_1] is ||| [module_1] [class_2]	count=22
function	string path to ||| get	count=2
arg	and negative coefficient ||| exprs	count=1
function	the squares of which ||| of squares	count=1
arg	in expr to ||| expr x	count=1
function_arg	cond [arg_2] ||| [function_1] [arg_2]	count=1
module_class	'self' is ||| sets interval	count=1
arg	root if it is ||| cls root radicals	count=1
module	symbols ||| core	count=2
module	[module] 0 ||| [module]	count=1
arg	it [arg] are ||| [arg]	count=1
arg	by [arg] \cdot v ||| [arg] w a	count=1
function	is assumed ||| sturm pg	count=1
function	[function_1] and its ||| [function_2] [function_1]	count=2
function	plan consisting ||| plan	count=1
module	[module] n ||| [module]	count=1
function	convert a sympy ||| sympy	count=2
arg	to f ||| f c k	count=1
function	root to ||| root	count=2
function	to a fully contravariant ||| data tensorhead from	count=1
function	a string ||| get	count=1
function	returns the conjugate ||| conjugate	count=1
function	c(x_2 x_u)*x_0**i to ||| term	count=1
function	[function_1] a tuple ||| [function_1] [function_2]	count=2
function	into a string ||| mod func	count=1
arg	to f in k[x] ||| f c i u	count=1
function	the quadratic [function_2] ||| [function_2] [function_1]	count=6
module	by the kinematic differential ||| physics mechanics	count=1
class	> p[i+1] ||| permutation	count=1
function	[function_1] start ||| [function_2] [function_1]	count=4
class	bounding rectangles ||| complex root	count=1
function	the gcd of ||| gcd	count=2
function_arg	with small [arg_2] ||| [function_1] n [arg_2]	count=4
function	field isomorphism [function_2] ||| [function_2] [function_1]	count=1
function_arg	the discriminant [arg_2] ||| [function_1] [arg_2]	count=1
module	standard basis in ||| polys	count=1
module	vector in given ||| vector	count=1
module	factors [module] a rational ||| [module]	count=1
function	the matrix ||| matrix	count=5
class	where the root ||| root of	count=1
module	domain of the ||| calculus	count=1
class	returns ||| sub module poly	count=1
class	is ||| interval	count=1
arg	state corresponding [arg] ||| [arg]	count=1
arg	e is a sum ||| e	count=1
function	the triangle ||| triangle	count=2
function	representation of a ||| form	count=1
arg	q are polynomials in ||| q x method	count=2
function	monotonicity ||| monotonicity	count=1
module	of polynomial ||| polys	count=2
function	the domain ||| in	count=1
function	a rational generating function ||| generating function	count=1
function	of the underlying undirected ||| undirected graph	count=1
function	create a new ||| new	count=1
module	x start ||| series	count=1
function_arg	term for ||| term f n	count=1
function_arg	logarithm [arg_2] ||| [arg_2] [function_1]	count=2
class	for the generated files ||| octave code	count=1
arg	\; j_2 m_2 ||| j_2	count=1
function_arg	rational [arg_2] ||| [function_1] [arg_2]	count=1
function	[function_1] a k[x] ||| [function_2] [function_1]	count=2
arg	[arg_1] y are ||| [arg_1] [arg_2]	count=1
class	return the homomorphism obtained ||| homomorphism	count=1
module_class	a, implies [class_2] ||| [module_1] [class_2]	count=2
function	mapping of symbolic values ||| param	count=1
module_class	[module_1] plane and ||| [module_1] [class_2]	count=2
function	a free module of ||| free module	count=1
function_arg	addends of [arg_2] ||| [arg_2] [function_1]	count=4
arg	encrypt message [arg] ||| i [arg]	count=1
arg	[inf sup] ||| inf sup	count=3
class	entries outside the main ||| properties	count=1
function	indices of a mul ||| indices mul	count=1
class	generated files ||| octave code	count=1
arg	f as a product ||| f	count=1
function	sparse matrix to a ||| to	count=1
module	ending ||| printing	count=1
function	into a string path ||| get mod	count=1
function_arg	according to [arg_2] ||| [function_1] [arg_2]	count=1
module	to gtkmathview a ||| printing	count=1
module_class	belonging [module_1] [class_2] ||| [module_1] [class_2] element	count=1
function	returns the best solution ||| coeff best	count=1
module	a standard ||| polys	count=1
arg	to quantum number n ||| n m r	count=1
module	returns true ||| domains	count=4
class	the generated ||| code	count=1
class	mutabledensendimarray to ||| ndim	count=2
arg	of space ||| s	count=1
module	we can get the ||| combinatorics	count=1
function	of tensor [function_2] ||| [function_1] [function_2]	count=8
arg	of operators a ||| operators	count=1
function	vertices ||| vertices	count=2
arg	convert [arg_2] ||| [arg_1] [arg_2]	count=24
class	coset enumeration described on ||| coset	count=2
function	are equivalent ||| eq	count=4
arg	converts components data ||| data	count=1
function	the minimal polynomial for ||| minpoly op algebraic element	count=1
function	[function_1] type ||| [function_1] [function_2]	count=4
class	object excluding ||| base	count=1
function	an ode from ||| ode 1st homogeneous coeff	count=1
function	to a raw dict ||| to raw dict	count=1
arg	rank ||| rank	count=3
class	elements of a matrix ||| dense matrix	count=1
function	[function_1] using cholesky ||| [function_2] [function_1]	count=2
module	from which the ||| geometry	count=1
arg	than limit or cheap ||| limit use_trial use_rho use_pm1	count=1
arg	self where other ||| other	count=1
function	the bodies in ||| bodies	count=1
arg	p ||| p	count=87
arg	length l2 on ||| l2	count=1
function	the name of the ||| mod	count=1
function	direction ratio of a ||| direction ratio	count=1
function	the trigamma ||| trigamma	count=1
arg	of constants ||| variable constant	count=3
function	the transitive ||| transitive	count=1
function	atanh of ||| rs atanh	count=1
module	returns this ||| functions elementary	count=1
arg	the ||| func	count=1
function_arg	int to ||| python k1 a	count=1
function_arg	gf [arg_2] ||| [function_1] add f g [arg_2]	count=2
function_arg	randomization [arg_2] ||| [arg_2] [function_1]	count=1
class	in the object ||| series	count=1
function	[function_1] equation ||| [function_2] [function_1]	count=4
module	possible ||| printing pretty	count=2
function	[function_1] a labeled ||| [function_2] [function_1]	count=2
function	descents in a permutation ||| descents	count=1
module	for [module] this ||| [module]	count=1
arg	true if [arg] on the ||| [arg]	count=1
module	the variables of ||| physics	count=1
arg	lagrangian ||| lagrangian	count=1
function	[function_1] mises ||| [function_2] [function_1]	count=2
function	- g*h ||| dmp sub mul	count=2
arg	and g modulo a ||| g	count=1
function	the derivation of an ||| derivation	count=1
function	as a table ||| table	count=1
arg	\int_{c+i\infty}^{c-i\infty} f ||| f	count=1
function_arg	transform [arg_2] ||| [function_1] [arg_2]	count=13
arg	b split should be ||| split	count=1
module	system ||| mechanics	count=2
function	[function_1] cart under ||| [function_1] [function_2]	count=5
class	the ||| polyhedron	count=3
class	for ||| hyper rep	count=4
function_arg	[function_1] [arg_2] repeated squaring ||| [function_1] pow mod f [arg_2]	count=1
class	the complex ||| complex	count=3
class	and sort roots ||| complex root of	count=1
function	given ||| indent	count=1
class	the ||| properties	count=1
arg	q are in ||| q	count=2
class	inverse ||| continuous distribution	count=1
arg	pt1 and ||| pt1	count=1
function	operators corresponding to ||| state to operators	count=2
function	by other, where ||| ge	count=1
function	series of ||| series	count=2
class	the exponential ||| exp	count=1
function	of simple roots that ||| simple roots	count=1
arg	arguments without changing the ||| radical clear fraction	count=1
arg	with [arg] turn ||| matlist index1 [arg]	count=1
module	clause l ||| logic algorithms	count=1
function_arg	form [arg_2] ||| [arg_2] [function_1]	count=2
function_arg	in [arg_2] ||| [function_1] [arg_2]	count=5
function	lagrangian of a ||| lagrangian	count=1
function	successfully decremented ||| decrement	count=1
function	return [function_1] [function_2] ||| [function_1] [function_2]	count=2
function	hermite reduction - ||| hermite	count=1
arg	by its [arg_2] ||| [arg_2] [arg_1]	count=2
module	the specified ||| physics	count=1
function	method converts a ||| form to	count=1
function	refine ||| refine real	count=1
function	exponent ||| exp	count=1
class	in ||| poly	count=1
function	variables with which the ||| variables	count=1
function_arg	[function_1] with already-processed ||| [function_1] cls args [arg_2]	count=1
function	anp ||| algebraic field	count=3
function	ode from the ||| ode 1st homogeneous	count=1
module	path to ||| utilities	count=2
function	[function_1] equation of ||| [function_1] [function_2] func_class f symbol	count=4
function	attained by other, ||| gt	count=1
function	of ||| empty	count=1
class	method to ||| lagranges method	count=1
function	lagrange's equations ||| lagranges equations	count=2
function	the order ||| order	count=11
function	zeros ||| zeros	count=2
function	of ||| indent	count=2
arg	of two ||| f g	count=5
function	rational [function_2] ||| [function_1] [function_2]	count=1
arg	indices are covariant ||| indices free dum	count=1
function	and returns the matrix ||| matrix	count=1
function_arg	to whether [arg_2] ||| [arg_2] [function_1]	count=3
function	replace ||| replace	count=2
class	return a list of ||| field	count=1
function	transversal for the orbit ||| orbit transversal	count=1
module	range from the ||| physics	count=1
module	the total [module_2] ||| [module_1] [module_2]	count=2
class	polyhedra ||| polyhedron	count=1
arg	[arg_1] [arg_2] ||| [arg_1] func [arg_2]	count=3
class	the ||| gen	count=2
function_arg	[function_1] polynomial in ||| [function_1] [arg_2]	count=10
function	gcd of ||| gcd	count=14
function	symbolic values ||| create	count=1
arg	f in ||| f n	count=2
arg	x_0 of a polynomial ||| m u	count=1
module	values the ||| geometry	count=1
function	of eye ||| matrix eye	count=1
function	of the circumcircle ||| circumradius	count=1
function_arg	[function_1] free and ||| [function_1] components [arg_2]	count=1
arg	[arg_1] is ||| [arg_2] [arg_1]	count=1
function	as input two vectors ||| as	count=1
arg	for constructing the ||| grid morphisms_str_info	count=1
function	constant [function_2] ||| [function_2] [function_1]	count=7
function	the linear equation ||| linear	count=1
module	time in the ||| physics	count=1
arg	at a ||| m a	count=1
arg	and returns ||| grid	count=1
arg	of elements of a ||| a	count=1
arg	expression of the operations ||| visual	count=1
function	diagonal morphism ||| diagonal	count=1
arg	literals return an ||| expr	count=2
arg	of polynomials in k[x] ||| polys u k	count=1
function	current top part on ||| top part	count=1
function	of ||| eval cond	count=2
function_arg	of operators [arg_2] ||| [arg_2] [function_1]	count=7
function	returns the intersection ||| intersection	count=1
function_arg	xor ^, [arg_2] ||| [arg_2] [function_1]	count=1
function_arg	[function_1] x representing ||| [function_1] m [arg_2]	count=1
function	computes polynomial lcm of ||| lcm	count=1
arg	a rule down a ||| rule	count=1
module	be ||| series	count=1
function	[function_1] product ||| [function_2] [function_1]	count=12
function	find optimization ||| opt	count=1
arg	a triangle ||| triangle	count=1
function_arg	this is a [function_1] [arg_2] order [3] ||| [function_1] nonlex [arg_2]	count=1
module	part ||| integrals	count=1
function	try [function] ||| [function] rational	count=2
class	[class_1] transform is ||| [class_1] [class_2]	count=1
function	direction ratio of a ||| direction	count=1
function	power [function_2] ||| 2nd [function_1] [function_2]	count=1
arg	tuple x representing a ||| x	count=1
function	in finite_set ||| not empty	count=1
function	functions ||| empty in	count=1
module	clause ||| logic algorithms	count=3
module	differential [module] ||| [module]	count=1
function	gmpy mpz ||| zz gmpy	count=6
arg	n k of ||| n k d	count=2
function	the nth moment ||| moment	count=1
function_arg	[function_1] other is ||| [function_1] [arg_2]	count=1
module_class	the other [class_2] ||| [module_1] [class_2]	count=1
function	the direction [function_2] ||| [function_1] [function_2]	count=12
function	orbit ||| orbit	count=4
function	rubik's ||| rubik	count=1
function	constant term ||| get constant term	count=2
function	potential energy ||| potential energy	count=2
arg	test if a ||| randomized	count=1
arg	returns a ||| a	count=3
module	return terms ||| core	count=1
arg	view expression ||| expr	count=1
module	leverage it ||| printing	count=1
arg	equation eq by converting ||| eq param syms permute	count=1
function_arg	[function_1] [arg_2] numbers 1 through n ||| [function_1] [arg_2]	count=2
function_arg	continuous subsequence [arg_2] ||| [arg_2] [function_1]	count=6
function	homogeneous [function_1] [function_2] ||| [function_1] [function_2]	count=1
function	parse and configure ||| parse	count=1
function	ground [function_2] ||| [function_2] [function_1]	count=2
function	mapping of ||| create	count=1
arg	[arg_1] [arg_2] \rangle ||| [arg_2] [arg_1]	count=1
function_arg	[function_1] a base ||| [function_1] [arg_2]	count=3
arg	condition is true ||| condition given_condition	count=1
arg	return an [arg_2] ||| [arg_2] [arg_1]	count=2
arg	as a ||| x a b	count=1
function_arg	[function_1] transformation ||| [arg_2] [function_1]	count=1
function	module ||| get mod func	count=1
function_arg	order of [arg_2] ||| [function_1] [arg_2]	count=1
arg	return expr ||| expr evaluate	count=1
class	containers of polynomials ||| poly	count=1
arg	[arg_1] t = ||| [arg_1] [arg_2]	count=1
module	we can get ||| combinatorics	count=1
function	evaluate ||| evaluate	count=1
arg	rational [arg] modulo ||| [arg]	count=1
function_arg	[function_1] [arg_2] special case ||| special diop [function_1] [arg_2]	count=1
arg	for _match_div_rewrite ||| expr f g rexp	count=1
arg	re im ||| re im	count=2
arg	[arg] row ||| matlist [arg]	count=2
function	forcing vector ||| forcing full	count=1
function	function prototype of the ||| get prototype	count=2
function	returns a ||| groebner	count=1
function	generated automatically ||| auto	count=1
arg	[arg] corresponding ||| msg [arg]	count=2
function	variables with ||| subs	count=1
function	[function_1] table of ||| [function_1] [function_2]	count=3
function	an sdm ||| sdm	count=1
arg	a beta distribution ||| alpha beta	count=1
module	of polynomials or containers ||| polys	count=1
module	other ||| core	count=1
function	root [function] directory and ||| [function]	count=1
arg	points ||| func points	count=1
function	compute the orbit ||| orbit	count=1
function	the positive ||| positive	count=5
module	the object excluding those ||| series	count=1
function	simple roots that ||| simple roots	count=1
function	finds ||| empty	count=1
function	rectangles ||| complexes	count=1
arg	pair of polynomials ||| g	count=1
class	poly ||| poly	count=4
class	containers of polynomials ||| poly ring	count=1
function	coefficient of a summation ||| as coeff add	count=3
function	gives [function_1] [function_2] ||| [function_1] [function_2]	count=1
function	mises distribution ||| mises	count=1
function	of triangles ||| triangles	count=1
module_class	of polynomial coefficients ||| polys poly	count=1
function	symbolic ||| param dict	count=1
arg	modify [arg_2] ||| [arg_2] func args [arg_1]	count=1
function_arg	[function_1] [arg_2] ||| [function_1] linear eq func [arg_2]	count=1
function_arg	f [arg_2] ||| [function_1] f [arg_2]	count=1
class	coordinate system ||| coord sys	count=3
function	tensor product of different ||| tensor	count=1
function	string path ||| get	count=2
arg	n k ||| n k d	count=2
function	y_i to x_i**k_i in ||| dmp inflate	count=1
class	the total number ||| type g	count=1
function	to the ||| to	count=1
function	computes the adjacency matrix ||| get adjacency matrix	count=1
function_arg	[function_1] for ||| [function_1] [arg_2] triangle_sizes	count=3
function_arg	resultant of f ||| resultant f	count=2
function	factor ||| gf factor	count=2
function	evaluation over ||| eval	count=1
arg	p2 ||| p2	count=2
function	a scalar multiple of ||| scalar multiple	count=1
function_arg	numerator of [arg_2] ||| [arg_2] [function_1]	count=1
function	[function_1] function class ||| [function_2] [function_1]	count=1
function	the edges ||| edges	count=1
function_arg	[function_1] [arg_2] ||| [function_1] field [arg_2]	count=5
module	[module] rewrite ||| [module]	count=2
module	contracted ||| physics	count=1
arg	selected [arg_2] ||| [arg_2] [arg_1]	count=1
function_arg	exact quotient [arg_2] ||| [function_1] ground [arg_2]	count=1
function	square root in ||| sqrt	count=1
function	sum ||| add	count=1
function	order a multiplication ||| order	count=1
function	[function_1] real roots ||| [function_1] [function_2]	count=3
function_arg	subresultant prs [arg_2] ||| [function_1] f [arg_2]	count=3
function	no [function_2] ||| [function_1] [function_2]	count=2
arg	of f and g ||| f g auto	count=1
function	domain of ||| not	count=1
class	formal power [class_2] ||| [class_1] [class_2]	count=1
function	[function_1] the cdf ||| [function_2] [function_1]	count=2
function	apply state to self ||| apply	count=2
module	checks if the ||| combinatorics	count=1
function	evaluate a polynomial at ||| eval	count=1
function	a non-integer [function] ||| has [function]	count=3
function	the b ||| b	count=1
function	rational ||| rational	count=10
arg	o(x**prec) ||| x prec	count=1
arg	[arg_1] [arg_2] ||| [arg_1] z [arg_2]	count=6
class	that no ||| of	count=1
function_arg	[function_1] a base ||| [function_1] bsgs [arg_2]	count=1
module	single component tensor ||| tensor	count=1
function	run a ||| run	count=1
arg	namespace dict ||| expr namespace	count=1
arg	data ndarray according ||| data	count=1
function	of pi ||| pi	count=1
function	order of ||| order	count=9
function	normal form ||| normal	count=1
function	symbolic ||| symbolic	count=1
function	represents the bending ||| bending	count=1
function	[function_1] maximum norm ||| [function_1] [function_2]	count=1
arg	strip given by strip= ||| strip	count=1
arg	at x_j [arg_2] ||| [arg_2] [arg_1]	count=2
function	terms to their coefficient ||| as coefficients dict	count=1
function	top part on ||| top part	count=1
arg	at a in ||| a	count=2
arg	of an expression ||| expr syms func evaluate	count=1
function	shallow copy of subsset ||| copy	count=1
function	to ||| operators to	count=1
function	the coset rank of ||| coset rank	count=1
function	increasing in the ||| increasing	count=1
function_arg	a polynomial [arg_2] ||| [arg_2] [function_1]	count=1
arg	return eq ||| eq	count=1
function	multiply [function_2] ||| [function_2] [function_1]	count=6
arg	x_j in ||| m j	count=1
function_arg	[function_1] [arg_2] ||| [function_1] sub f [arg_2]	count=1
arg	of the routines in ||| routines f	count=2
function	[function_1] roots together ||| [function_1] [function_2]	count=3
function	of syllables from ||| sub syllables	count=1
function	trace map ||| trace map	count=2
class	complex isolating interval ||| complex interval	count=2
arg	k == [arg_2] ||| [arg_2] [arg_1]	count=4
function	returns the matrix ||| matrix	count=2
function	a force to ||| apply force	count=2
arg	character in phrase ||| phrase	count=1
function	mapping of ||| create param	count=1
function	roots of ||| roots	count=10
module	get the ||| physics quantum	count=1
arg	base b [arg_2] ||| [arg_2] [arg_1]	count=3
module	function is the inverse ||| physics	count=1
function	construct new ||| init	count=1
function_arg	from a [arg_2] ||| [function_1] bsgs [arg_2]	count=4
function	to be triangularized ||| create ma	count=1
class	docstrings ||| doc tests	count=2
class	dtype ||| rational field	count=3
module_class	number [module_1] [class_2] act on ||| [module_1] [class_2]	count=2
function	berkowitz algorithm to compute ||| det berkowitz	count=1
function	convergence ||| is convergent	count=1
module	the integration using any ||| integrals	count=1
function_arg	[function_1] [arg_2] ||| geometry linear entity span [function_1] [arg_2]	count=2
function	characters to the beginning ||| indent	count=1
arg	coordinate and speed ||| q_ind q_dep u_ind u_dep	count=1
arg	terms ||| terms x	count=1
function	the n-th coefficient ||| dmp nth	count=1
arg	[arg_1] ex1 ||| [arg_2] [arg_1]	count=1
arg	f to all expressions ||| f	count=1
class	the hypergeometric ||| hyper	count=2
arg	the morphisms [arg_2] ||| [arg_2] grid [arg_1]	count=1
function	returns a copy of ||| copy	count=1
function_arg	[function_1] difference formula ||| [arg_2] [function_1]	count=4
module	that no ||| polys	count=1
module	return ||| ntheory	count=2
function	always destroy a ||| is only	count=1
function	for [function_2] ||| [function_2] [function_1]	count=1
class	this method returns the ||| series	count=1
module	vector in given coordinate ||| vector	count=1
class	root [class] ||| type [class]	count=1
arg	the mellin transform of ||| x	count=1
function	be of ||| process	count=1
arg	modify parts [arg_2] ||| [arg_2] [arg_1]	count=9
class	for the generated ||| fcode gen	count=1
module	the polyhedra we can ||| combinatorics	count=1
function	forcing vector of the ||| forcing	count=1
class	complex root to the ||| complex root of	count=1
arg	taking opt_subs into account ||| exprs symbols opt_subs order	count=1
function	[function] formed ||| [function]	count=3
function	linearize the system about ||| linearize	count=1
class	ray ||| ray	count=3
module	evaluates ||| plotting intervalmath	count=14
function	gmpy's ||| gmpy	count=1
function	all tests ||| all tests	count=2
function	a list of irreducible ||| factor list include	count=2
function	converts a list given ||| to	count=1
function	[function_1] [function_2] ||| find [function_2] [function_1]	count=4
function	the functions in finite_set ||| not empty	count=1
function	key for ||| key	count=1
function	heuristic polynomial gcd ||| qq heu gcd	count=1
function	returns exact polynomial quotient ||| dmp quo	count=1
function	matrix for a ||| matrix	count=1
module_class	[module_1] swap gate ||| [module_1] [class_2]	count=2
function	available and leverage it ||| try use	count=1
function	the function is monotonic ||| is monotonic	count=1
function	a rational generating ||| guess generating	count=1
arg	_strip with h ||| h base orbits	count=1
function	negative ||| opt	count=1
function_arg	quotient of a ||| quo a	count=8
function	a common absolute ||| process common	count=1
arg	of ||| x y z t	count=1
function_arg	independence between a ||| pspace independent a	count=1
function	a 1st ||| 1st	count=1
function	loads given to ||| load	count=1
function	roots of [function_2] ||| [function_2] [function_1]	count=4
module	sparsematrix ||| matrices	count=1
arg	orig_vec [arg_2] ||| [arg_1] [arg_2]	count=1
arg	on the environment ||| pretty_print order use_unicode use_latex	count=1
function	the logarithm of ||| rs log	count=1
function	for specific integer modulus ||| modular integer	count=1
function	to a tuple ||| to tuple	count=3
function_arg	[function_1] [arg_2] ||| [function_1] force [arg_2]	count=8
class	using ||| integral	count=1
function	[function_1] code parameters ||| printing [function_1] [function_2]	count=1
arg	in a frame ||| frame	count=1
function	[function] n returns ||| [function]	count=1
function_arg	[function_1] p [x] ||| [function_1] f [arg_2]	count=5
module	be defined by ||| core	count=1
function	computes the number ||| count	count=1
arg	public key ||| key	count=3
function	the lie group method ||| ode lie group	count=1
function	a differential equation ||| ode	count=1
function	[function_1] a constant ||| [function_1] [function_2]	count=1
function_arg	memoized version [arg_2] ||| [arg_2] [function_1]	count=1
module	x **2 [module] csc x ||| [module]	count=1
function_arg	rotate [arg_2] ||| [function_1] [arg_2]	count=1
class	sympy sets set of ||| geometry set	count=1
arg	expression parameters ||| expr	count=1
class	a single [class_2] ||| [class_2] [class_1]	count=1
arg	series expansion of ||| p x prec	count=4
function	converts sympy's ||| matrix2numpy	count=1
arg	about c i e ||| n c	count=1
function	nice order of classes ||| class	count=1
class	from the kb ||| prop kb	count=1
class	sequence of polynomials or ||| ring	count=1
class	homomorphism obtained ||| module homomorphism	count=1
function	product [function_2] ||| [function_1] as [function_2]	count=1
function	unique [function] of multiset ||| multiset [function]	count=1
function	given function class ||| function class	count=2
function_arg	extension in ||| extension ip	count=1
function	truncation ||| rs	count=1
function	gruntz algorithm ||| gruntz	count=1
function	c code parameters ||| ccode	count=1
function	simple [function_2] ||| [function_2] [function_1]	count=3
arg	[arg] produces ||| [arg] groups merged_morphisms	count=3
class	returns the ||| series base	count=1
module	does the actual ||| physics	count=1
module	the added integration constant ||| physics	count=1
function_arg	intersection with another ||| intersection other	count=1
arg	an expression ||| expr	count=12
arg	x of [arg_2] ||| [arg_2] [arg_1]	count=7
function_arg	the plot [function_1] [arg_2] ||| [function_1] [arg_2]	count=4
arg	by x [arg] ||| x [arg]	count=1
function	bra on ||| bra	count=1
function	[function_1] line ||| plotting plot3d [function_1] [function_2]	count=1
function	a gtk ||| gtk	count=1
arg	function ||| expression	count=1
function	the minimum ||| min	count=1
function	to infinity ||| definite 3	count=1
function	linear differential equation with ||| linear	count=2
function	list of x**(i*p) mod ||| frobenius monomial base	count=1
function	the subset defined ||| subset	count=1
function	pendulum on a ||| pendulum on	count=1
function	d^2 = ||| four	count=1
function	wrapper of crt for ||| crt	count=1
arg	representing a ||| p succ	count=2
function	[function_1] a mul ||| [function_2] [function_1]	count=4
function	generators ||| from expr no gens	count=1
function	allow values below ||| is below	count=1
class	space ||| space orienter	count=2
class	basis in ||| module poly	count=1
module	by the kinematic ||| physics mechanics	count=1
function	element which should ||| element	count=1
arg	orientation or [arg] wrt another ||| [arg]	count=1
class	excluding those that take ||| series	count=1
arg	[arg_1] m_1 \; ||| [arg_2] [arg_1]	count=1
function_arg	[function_1] x0 ||| [function_1] [arg_2]	count=1
arg	[arg] the special ||| d [arg]	count=1
function_arg	multiplication [arg_2] ||| [function_1] [arg_2]	count=2
arg	a list of implications ||| implications	count=1
class	writes a ||| octave code	count=1
arg	coordsyscartesian ||| vector_names	count=1
function	a string path ||| mod	count=1
function	python's int ||| zz python	count=1
arg	m representing ||| m	count=1
function	truth value of the ||| eval	count=1
function_arg	have precision [arg_2] ||| [arg_2] [function_1]	count=1
function	gf p [x]/ ||| gf	count=1
class	as ||| sys cartesian	count=1
function	apply on a ||| call	count=1
function	function to replace ||| simplify	count=1
module	a ||| agca	count=3
class	of indices creating new ||| tids	count=1
function	the underlying undirected ||| get undirected graph	count=1
arg	routines ||| routines	count=2
module	below the ||| physics	count=3
function	normalized version of self ||| normalized	count=1
function_arg	prime [arg_2] ||| [function_1] resultant f g [arg_2]	count=1
arg	a diagram [arg_2] ||| [arg_1] [arg_2]	count=4
module	returns a basis state ||| quantum	count=1
class	formal power [class_2] ||| [class_2] [class_1]	count=1
function_arg	[function_1] [arg_2] as a permutation group ||| [function_1] [arg_2]	count=1
function	tuple wrt the following ||| numer denom	count=1
function	opportunities ||| opt cse	count=2
class	put a string of ||| string	count=1
arg	the routines in c ||| routines f prefix	count=1
module	space characters to the ||| utilities	count=1
function	a sympy ||| parse	count=1
class	a linear ||| linear	count=2
function	are free [function_2] ||| [function_2] [function_1]	count=1
function_arg	[function_1] of i ||| [function_1] rsa [arg_2]	count=2
module	of coefficients ||| polys	count=1
arg	f as a product ||| f x	count=1
arg	the mapping in rules ||| p rules x prec	count=1
module	divergence [module] field ||| physics [module]	count=1
function	on [function_2] ||| [function_1] [function_2]	count=2
module_class	ranks the [class_2] ||| [module_1] [class_2]	count=4
module	t2 e [module] t(a ||| [module]	count=1
arg	[arg] is omitted ||| cls r [arg]	count=2
function	is [function] matrix that ||| is [function]	count=1
module	the inner product operator ||| physics	count=1
function	and ||| try	count=1
function_arg	parameters and [arg_2] ||| [arg_2] [function_1]	count=1
arg	subgroup [arg_2] ||| [arg_2] [arg_1]	count=2
function	a [function] ||| solve [function]	count=1
function	[function_1] moment ||| [function_1] [function_2]	count=5
arg	functions or as a ||| a	count=1
arg	with knots ||| knots n	count=1
function	[function_1] [function_2] ||| [function_2] sqf [function_1]	count=3
function	groebner bases ||| groebner	count=1
function	an ||| operator int	count=1
function	m-th order derivative of ||| diff	count=1
arg	\mathbb{z}_p and a ||| evalpoints hpeval ring i	count=1
function	given ||| expr if	count=2
function	insert ||| random insert	count=1
arg	function for functions checking ||| expression predicate	count=1
function	a wrapper ||| wrapper	count=1
function_arg	[function_1] p [x] ||| [function_1] irreducible n [arg_2]	count=2
module	~sympy solvers ||| solvers	count=1
function	real ||| real root	count=2
function	in the form of ||| form	count=1
function	diagonal entries ||| diagonal	count=1
function_arg	cyclotomic polynomial [arg_2] ||| [arg_2] [function_1]	count=3
arg	using ||| f k eps	count=1
arg	[arg] repeated ||| f [arg]	count=2
class	factorial ||| polynomial ring	count=1
function	polynomial ring i ||| poly ring	count=3
function	consists of syllables from ||| sub syllables	count=1
arg	order ||| func order match	count=7
function	lambdify ||| sample iter lambdify	count=1
function	symbolic values to ||| create param	count=1
arg	and y [arg_2] ||| [arg_1] [arg_2]	count=5
function	wigner [function_2] ||| [function_1] [function_2]	count=2
class	the atoms ||| basic	count=1
module	sequence of polynomials ||| polys	count=1
arg	group [arg] as ||| [arg]	count=1
module	the ||| matrices	count=3
function	perform a ll ||| ll	count=1
function	multipliers ||| multipliers	count=1
arg	product [arg] ||| [arg]	count=1
arg	comparison operator ||| op	count=1
class	cache ||| matrix cache	count=1
arg	[arg_1] g ||| [arg_1] [arg_2]	count=12
module	in s, and return ||| utilities	count=1
module	using any hints given ||| integrals	count=1
function	javascript ||| jscode	count=1
class	s [class] this ||| state [class]	count=1
arg	size n ||| n g	count=1
arg	the variable ||| variable	count=1
function	the trigamma function ||| trigamma	count=1
function	[function_1] to a ||| [function_2] [function_1]	count=15
function	to an expr ||| expr	count=1
function	second set of denominator ||| bother	count=1
function	whether function ||| function	count=1
function_arg	the linearizer [arg_2] ||| [function_1] [arg_2]	count=3
function	free list of tuples ||| free	count=1
arg	compute \frac f [arg_1] [arg_2] ||| div f [arg_1] [arg_2]	count=7
arg	[arg_1] v ||| [arg_2] [arg_1]	count=3
function_arg	holonomic [arg_2] ||| [function_1] [arg_2]	count=1
function	differentiate ||| dmp diff	count=1
class	simple root [class_1] [class_2] ||| [class_2] [class_1]	count=2
arg	of a field in ||| field	count=1
module	augmented by the ||| physics mechanics	count=1
function	an expr ||| expr	count=1
function	the rank of ||| rank	count=1
function	infinity ||| definite 3	count=1
function	generating function for ||| generating function	count=1
class	evaluate the transform in ||| integral transform	count=1
arg	register the ||| from_coords to_exprs inverse	count=1
module	the list of possible ||| physics quantum	count=1
arg	func to every ||| func	count=1
function	[function_1] mellin ||| [function_2] [function_1]	count=3
function	find optimization ||| cse	count=1
function	that take on ||| free	count=1
function	angular [function_2] ||| [function_2] [function_1]	count=1
function	semicircle distribution ||| semicircle	count=1
class	refine an [class_1] [class_2] ||| [class_1] [class_2]	count=1
arg	if gcd a ||| a	count=1
function	u_2 = \frac{\text{<independent ||| indep div dep	count=1
arg	functions ||| function	count=1
arg	num ||| num	count=1
arg	of s ||| s	count=1
function	functions ||| not	count=1
arg	first order ||| eq func order	count=2
function	ordering is that dummies ||| ordered dummies	count=1
arg	rsolve_hypergeometric for details ||| re	count=1
arg	[arg_1] p ||| [arg_2] [arg_1]	count=11
module	convenience wrapper for vector ||| vector	count=1
function	the truth value of ||| eval	count=1
function	the amplitude ||| amplitude	count=1
arg	f ||| f m n j	count=1
arg	of two permutation ||| other	count=1
arg	the partial differential ||| eq hint func order	count=1
arg	0 mod(p** s + ||| s	count=1
arg	transformation ||| to_sys coords	count=1
arg	[arg_1] in ||| [arg_1] [arg_2]	count=9
class	for the generated files ||| fcode	count=1
function	using lusolve and returns ||| lu	count=1
function_arg	compute lcm [arg_2] ||| [arg_2] [function_1]	count=2
function	coset table ||| coset table	count=1
arg	n in x ||| n x	count=16
module	curl [module] field ||| physics [module]	count=1
arg	of the form ||| func	count=1
module_class	wrt this [class_2] ||| [module_1] [class_2]	count=2
arg	if f ||| f k	count=2
class	the polygon and ||| polygon	count=1
arg	two points [arg] ||| [arg] pt2 edge	count=3
function	x_i**k_i ||| dmp inflate	count=2
arg	[arg_1] k[x] ||| [arg_1] g [arg_2]	count=6
arg	in x_0 ||| u k	count=1
arg	\mathbb{z}_p[z]/(\check m_{\alpha} z )[x] ||| minpoly p	count=1
arg	[arg] terms of ||| [arg]	count=1
function	derivative of the current ||| derivative	count=1
module	on ||| series	count=1
arg	m_1 [arg_2] ||| [arg_2] [arg_1]	count=5
function_arg	[function_1] f x ||| [arg_2] [function_1]	count=1
arg	and b [arg_2] ||| [arg_2] [arg_1]	count=1
arg	points ||| points	count=3
function	[function_1] order a ||| [function_2] [function_1]	count=1
function	of motion in explicit ||| explicit	count=1
function_arg	[function_1] [arg_2] ||| [function_1] qubit [arg_2]	count=4
function	modulo a prime ||| dmp zz modular	count=1
class	specific ||| base	count=1
function	[function_1] transversals relative ||| [function_1] [function_2]	count=1
function	third heuristic assumes ||| heuristic bivariate	count=1
arg	alpha as ||| degree generators alpha	count=1
function	direction vector ||| direction	count=1
function	gmpy mpq object to ||| qq gmpy	count=6
function	[function_1] a where ||| [function_2] [function_1]	count=9
function	returns the best solution ||| best	count=1
function	compute the gcd of ||| gf gcd	count=1
arg	and y after ||| y	count=1
function_arg	[function_1] [arg_2] using horner scheme ||| [function_1] eval f a [arg_2]	count=1
function	finds the ||| in	count=1
function	dispatch ||| dispatch	count=1
arg	in x_j at ||| j	count=1
module	the leading coefficient of ||| polys	count=1
class	to the module ||| module	count=1
function	ode are ||| 2eq order1 type4	count=1
class	of tuples index pos ||| index	count=1
function	of ||| mod	count=1
arg	f and for ||| a	count=1
function	[function_1] of ||| [function_1] [function_2]	count=5
class	the homomorphism obtained by ||| homomorphism	count=1
class	the proper ||| code printer	count=1
function	it is assumed ||| subresultants rem	count=1
arg	of keys ||| keys	count=1
function	intended or q[x] ||| vv 2	count=1
class	files ||| gen	count=2
function	[function_1] norm of ||| [function_1] [function_2]	count=10
function	reducible by ||| reducible	count=1
function	ode from the ||| ode	count=1
function	normal part ||| normal	count=1
function	list of degrees of ||| degree list	count=1
class	a ||| free module quotient	count=1
function	gcd of two univariate ||| gf gcd	count=1
arg	"=" for a ||| a	count=1
function	which ||| empty in	count=1
arg	x y [arg_2] ||| holzer [arg_1] [arg_2]	count=4
function	[function_1] potential ||| [function_2] [function_1]	count=3
arg	is a model ||| model	count=1
module	values to ||| printing	count=1
function	a homomorphism with same ||| hom	count=1
arg	given set of points ||| points	count=1
arg	checks if g ||| g	count=1
function	is that dummies ||| ordered dummies	count=1
function	[function_1] an isomorphism ||| [function_1] [function_2]	count=1
arg	h are in k[x] ||| h u	count=2
function_arg	evaluate [arg_2] ||| [arg_2] [function_1]	count=6
function	x_i**k_i in a ||| dmp inflate	count=1
function_arg	and evaluate [arg_2] ||| [function_1] [arg_2]	count=3
function	c code ||| ccode	count=1
function	rotated ||| rotation	count=1
function	the general ||| diop general	count=1
function	and the name ||| get mod func	count=1
function	leading coefficient ||| gf lc	count=1
function	rust [function_2] ||| printing [function_1] [function_2]	count=2
function	free symbols ||| free symbols	count=4
function_arg	remainder of [arg_2] ||| [function_1] [arg_2]	count=13
arg	other is not a ||| other	count=1
function	return ||| refine	count=1
class	for multivariate functions ||| function	count=1
arg	z at [arg_2] ||| [arg_1] [arg_2]	count=2
function	[function_1] mul object ||| [function_2] [function_1]	count=2
function_arg	a transversal of the [function_1] [arg_2] second method described in ||| [function_1] transversal [arg_2]	count=2
arg	at a in ||| m a	count=1
arg	property prop ||| prop base	count=1
function	exact polynomial quotient ||| quo	count=1
function	with the ||| get statement	count=1
function	[function_1] cosine ||| [function_1] [function_2]	count=3
arg	in the ||| u k	count=1
function	cofactors of ||| inner	count=2
function_arg	[function_1] sin x ||| [function_1] [arg_2]	count=1
arg	satisfying the property prop ||| prop base strong_gens tests	count=1
function	series ||| rs series	count=1
class	gate ||| gate	count=3
arg	orbit [arg] no input ||| [arg]	count=1
arg	if it [arg] are ||| [arg]	count=1
module_class	if the [class_2] ||| [module_1] [class_2]	count=6
arg	[arg] are comparable ||| [arg]	count=1
arg	backend function ||| s_ simplify	count=1
function	converts an ||| to	count=1
function	make [function_2] ||| [function_1] [function_2]	count=3
function	num/den by removing ||| rad	count=1
function_arg	from [arg_2] ||| [arg_2] [function_1]	count=4
arg	tensmul ||| tensmul	count=1
arg	a text ||| text	count=2
function_arg	the multiplication [arg_2] ||| [arg_2] [function_1]	count=2
function	index of a dummy ||| index	count=1
function_arg	normal ordered [function_1] [arg_2] ||| physics quantum normal ordered [function_1] [arg_2]	count=1
class	those that take on ||| base	count=1
function	a dict representation ||| dict	count=1
function	frobenius map parameters ||| gf frobenius map	count=1
function	return a group of ||| group	count=1
arg	self x ||| x	count=1
class	submodule ||| module poly ring	count=1
arg	in old ||| old	count=1
function	the ||| not empty in	count=3
function	from a dictionary ||| from dict	count=3
arg	x of degree ||| n x	count=1
function	the closing ||| ending	count=1
function	expectation ||| expectation	count=2
function	create [function_2] ||| [function_2] [function_1]	count=4
arg	msg ||| msg key	count=1
arg	respect to x note ||| x	count=1
function	unicode output ||| unicode	count=1
function	files ||| get	count=2
function	rewrites ||| rewrite	count=1
arg	function for the method ||| func order	count=1
class	correct ||| data lazy evaluator	count=1
function	:func dup_decompose ||| dup decompose	count=1
function_arg	the scaler-row [arg_2] ||| [function_1] [arg_2]	count=1
function_arg	generates [function_1] [arg_2] permutation group ||| [function_1] [arg_2]	count=1
class	polynomial element ||| poly element	count=4
function	given ||| if	count=2
function	the foci ||| foci	count=1
function	coding to gray ||| to gray	count=1
arg	[arg] m_3 \rangle ||| j_1 j_2 [arg]	count=2
arg	backend return the ||| backend	count=1
function	m-th order derivative in ||| diff in	count=1
class	apply ||| commutator	count=1
arg	group on [arg] elements ||| [arg]	count=1
function	multiply inplace the ||| imul num	count=1
module_class	[module_1] composite morphism ||| [module_1] [class_2]	count=4
function	orbits of self, ordered ||| orbits	count=1
function	careful! any evalf ||| evalf	count=1
class	whose elements have ||| partition	count=1
function	[function_1] bound ||| [function_1] [function_2]	count=1
module	finds the domain of ||| calculus	count=1
function	in [function_2] ||| [function_2] [function_1]	count=10
module	of the functions ||| calculus	count=1
function	equation with constant ||| constant	count=4
function	if ||| try	count=2
function	where self is written ||| coeff	count=1
function	path to ||| mod func	count=2
arg	and coefficient ||| coeff	count=1
function	polynomial of ||| poly	count=2
arg	returns a ||| w a	count=1
class	true if ||| algebraic	count=4
class	along self's last and ||| matrix shaping	count=2
function	nonpositive ||| nonpositive	count=1
arg	m_1 \; j_2 ||| j_2 j_3 m_1	count=2
class	[class] but which ||| [class]	count=2
arg	a polynomial at x_0 ||| u	count=1
function	lu decomposition itself ||| lu decomposition	count=2
arg	[arg_1] two polynomials ||| [arg_1] [arg_2]	count=3
function_arg	[function_1] polynomial techniques ||| [arg_2] [function_1]	count=1
arg	function target [arg_2] ||| [arg_2] [arg_1]	count=1
function	binomial ||| binomial	count=1
function	kane's ||| kanes	count=1
function	[function] given ||| [function]	count=3
arg	disjoint and ||| cls complexes	count=1
function	is the [function_2] ||| [function_2] [function_1]	count=16
arg	characters of symbols with ||| symbols	count=1
module	returns the number of ||| combinatorics	count=1
module	the initialization ||| physics	count=1
function	to addends ||| addends	count=1
arg	by ||| cls arg k	count=1
module	a quantum ||| quantum	count=1
arg	value of the condition ||| cond	count=1
arg	self [arg] ||| [arg]	count=1
function	see if unicode output ||| try use unicode	count=1
class	of ||| frac	count=1
arg	or equal to n ||| n nth	count=1
class	rootsum ||| root sum	count=1
arg	a polynomial [arg_2] ||| [arg_2] [arg_1]	count=4
class	bounding rectangles of non-conjugate ||| complex root of	count=1
function	representation of freegroupelement ||| rep	count=1
module_class	[module_1] roots ||| [module_1] [class_2]	count=8
function_arg	[function_1] name ||| [function_1] [arg_2]	count=2
arg	equation eq (ax^2 ||| eq	count=1
arg	of two polynomials ||| g k includeprs	count=1
class	a permutation ie the ||| permutation	count=2
arg	[arg_1] and g ||| [arg_2] [arg_1]	count=55
function	of ||| param	count=1
arg	[arg_1] k ||| physics epsilon [arg_1] [arg_2]	count=3
module_class	[module_1] word ||| [module_1] [class_2]	count=8
arg	univariate polynomials in \mathbb{z}_p[x] ||| fp gp p	count=1
module	this ||| vector	count=7
arg	n examples ||| n	count=1
function	checks for the convergence ||| convergent	count=1
arg	and their respective multiplicities ||| limit use_trial use_rho	count=1
arg	x gives the ||| x	count=1
function	[function_1] thus ||| [function_1] [function_2]	count=4
arg	appropriate for this language ||| name expr argument_sequence global_vars	count=1
arg	bits to ||| bits str	count=1
arg	in eq ||| eq funcs	count=1
arg	[arg_1] curve ||| [arg_2] [arg_1]	count=1
function	sorting key ||| sort key	count=2
module	factor matrices ||| matrices	count=1
class	returns a tids ||| tids	count=1
class	raise ||| element	count=1
arg	appears in old with ||| old	count=1
function	a python subprocess with ||| subprocess with	count=1
class	generated automatically ||| extension	count=1
function	have precision ||| evalf subs	count=1
function	no cancellation deg ||| no cancel	count=2
function	given number of space ||| indent	count=1
arg	anti-derivative to [arg_2] ||| [arg_2] x [arg_1]	count=1
module	polyhedra we can get ||| combinatorics	count=1
function	exponentiation of ||| exp	count=1
function	of the series ||| series	count=1
arg	[arg_1] subtracting ||| [arg_1] [arg_2]	count=2
class	power [class_2] ||| [class_1] [class_2]	count=1
arg	series expansion of the ||| x prec	count=5
arg	this type of ||| x	count=3
function	a list of degrees ||| degree list	count=1
function	polynomial from [function_2] ||| [function_2] [function_1]	count=1
arg	length n raise ||| n	count=1
class	xy-pic representation of ||| diagram drawer	count=1
arg	p [x] ||| g p k	count=3
function	the domain where ||| where	count=1
class	can ||| polyhedron	count=1
function	map y_i to x_i**k_i ||| dmp inflate	count=1
arg	a continuous ||| mu b	count=1
function	no cancellation ||| no cancel	count=2
function	the matrix ||| eval matrix	count=1
arg	e [arg_2] ||| [arg_2] [arg_1]	count=11
arg	the backend function ||| t s_ simplify	count=1
arg	another subcircuit [arg] if ||| [arg] subcircuit replace	count=1
function	gray code [function_2] ||| [function_2] [function_1]	count=2
function	[function_1] and primitive ||| [function_2] [function_1]	count=2
module	leverage it if ||| printing	count=1
class	of a diagram ||| diagram	count=1
function	+ cz^2 ||| to normal	count=1
arg	[arg] \in k[x_0 ||| [arg]	count=6
function	for a diagonal ||| diagonal	count=1
module	the acceleration of this ||| vector	count=1
module	the given operator or ||| physics	count=1
arg	to_j, where ||| from_i to_j	count=1
function	ascents in a ||| ascents	count=1
function	the real [function_2] ||| [function_2] [function_1]	count=1
arg	list of ||| expr x	count=1
arg	b [arg_2] ||| [arg_1] [arg_2]	count=3
function	f - g*h ||| sub mul	count=3
class	freegroup ||| free group	count=2
class	submodule ||| quotient ring	count=1
arg	set of points in ||| func points	count=1
arg	roots of f ||| f	count=2
class	that no bounding ||| complex	count=1
class	check ||| module homomorphism	count=1
arg	specified rank ||| rank superset	count=4
class	the determinant ||| matrix determinant	count=1
function	components of ||| components	count=2
arg	the morphisms [arg_2] ||| [arg_2] [arg_1]	count=9
function	entire free ||| full	count=2
arg	[x] ||| symmetric	count=2
function_arg	this function simplifies a [function_1] [arg_2] ||| [function_1] [arg_2]	count=1
arg	first order differential ||| func order match	count=1
function	[function_1] square ||| [function_1] [function_2]	count=1
function	[function] derivative ||| requires [function]	count=3
function	of syllables ||| syllables	count=2
arg	is the ||| r	count=1
class	return a list of ||| frac	count=1
function	entity parallel to the ||| parallel	count=1
module	the form obj force ||| physics	count=1
arg	mpfval accuracy ||| prec target_prec	count=1
function_arg	[function_1] of two ||| [arg_2] [function_1]	count=12
function	of eye and ||| eye	count=1
module	lie algebra has ||| liealgebras	count=3
class	< p[i+1] ||| permutation	count=1
arg	for the input t ||| t	count=1
function	down a ||| down	count=2
module	the variables of ||| physics vector	count=1
function	compute lcm of ||| lcm	count=1
module	in ||| utilities	count=4
class	and same assumptions ||| symbol	count=1
arg	k \in ||| k	count=1
function	dimension of the vector ||| dimension	count=4
arg	hypergeometric function target to ||| target	count=1
arg	delta ||| delta	count=1
arg	simple [arg] ||| expr [arg]	count=1
function	error ||| var count error	count=1
arg	for constructing ||| i j grid morphisms_str_info	count=1
module	truth value ||| elementary	count=1
arg	by a path ||| path	count=1
function	name ||| get mod	count=1
function	[function_1] [function_2] tensexpr ||| [function_1] [function_2]	count=14
function	simplified set of minterms ||| simplified pairs	count=1
arg	and a column ||| column	count=1
arg	e z ||| e z	count=2
function	indices corresponding to ||| indices	count=2
class	that take on a ||| series	count=1
function	reorder ||| reorder	count=2
function_arg	input [arg_2] ||| [arg_2] [function_1]	count=13
function_arg	converts [arg_2] ||| [arg_2] [function_1]	count=2
arg	prop ||| prop base	count=1
function	as hlt+lookahead method ||| look ahead	count=1
arg	in a certain coordinate ||| point1 point2	count=1
arg	grid adds an ||| grid skeleton	count=1
function	the string path ||| func	count=1
function	square-free polynomial using ||| sqf	count=1
function	of ||| not empty	count=1
function	returns the magnitude ||| magnitude	count=1
function	a morphism the length ||| length	count=1
module	clause l the ||| logic algorithms	count=1
function	nilpotent ||| nilpotent	count=1
function_arg	hypergeometric [arg_2] ||| [arg_2] [function_1]	count=1
arg	x_j in [arg_2] ||| [arg_2] [arg_1]	count=1
arg	function f ||| f	count=2
function	polynomial remainder ||| rem	count=1
arg	data ndarray ||| data	count=1
function	parametric ||| param	count=1
arg	of ||| x y t	count=4
function	exact ||| exact	count=1
function	two simple [function_2] ||| [function_2] [function_1]	count=3
arg	the result ||| s	count=1
arg	value of the condition ||| cls cond	count=1
arg	no = [arg_2] ||| [arg_2] [arg_1]	count=2
function	made so far is ||| simple compute conflict	count=1
function	the truth ||| cond	count=1
function	and its value if ||| pure	count=1
function	horner scheme ||| eval	count=2
arg	construct a ||| rep opt	count=1
function	evaluate the ||| evalf	count=1
module	is currently at ||| physics	count=1
arg	[arg_1] q x ||| [arg_1] [arg_2]	count=3
arg	this system of ||| x	count=1
function_arg	[function_1] j ||| [function_1] i [arg_2]	count=1
function	second moment ||| second moment	count=2
function	morse code with ||| morse	count=1
function	truth value ||| eval	count=1
function	root [function_2] ||| [function_2] [function_1]	count=2
function_arg	reduced [arg_2] ||| [arg_2] [function_1]	count=3
arg	operator in ||| op	count=1
arg	true if [arg] is a ||| [arg]	count=1
function_arg	separable 1st [arg_2] ||| [function_1] eq func [arg_2]	count=1
function_arg	to [arg_2] ||| [arg_2] [function_1]	count=9
class	a cython file with ||| cython	count=1
function	at a ||| call	count=1
function	and ||| simple	count=1
function	with math-related macros from ||| macros	count=1
function	of irreducible factors ||| factor	count=3
module	the initialization of lagrangesmethod ||| physics	count=1
function	atan of p, about ||| rs atan	count=1
arg	a system of two ||| g	count=1
function	the whole [function_2] ||| [function_1] [function_2]	count=1
class	of the polygon ||| polygon	count=1
arg	[arg_1] if modulus ||| [arg_1] [arg_2]	count=3
class	files ||| fcode gen	count=2
module	[module] or ||| [module]	count=2
module	returns ||| series	count=1
module_class	[module_1] ellipse ||| [module_1] [class_2] minor	count=1
module_class	[module_1] point with ||| [class_2] [module_1]	count=8
function	[function_1] [function_2] ||| [function_2] from [function_1]	count=2
function	a zero polynomial ||| zero	count=1
arg	by a constant ||| c	count=1
function	strided scheme ||| strides	count=1
function	half [function_2] ||| [function_2] [function_1]	count=6
arg	and g ||| g	count=36
class	[class] is convex ||| [class]	count=3
arg	belong to ||| strict	count=1
function	integrate ||| rs integrate	count=1
arg	q are polynomials in ||| q x	count=5
function_arg	variations of seq ||| variations seq	count=2
class	interval [class_2] ||| [class_2] [class_1]	count=10
class	helper [class_2] ||| [class_2] [class_1]	count=4
function	the module ||| mod	count=1
function_arg	[function_1] an expression ||| diffgeom [function_1] [arg_2]	count=2
class	the ||| code gen	count=2
module	for a [module] ||| [module]	count=2
class	limits ||| with limits	count=1
arg	[arg_1] to t ||| [arg_2] [arg_1]	count=1
function	full partial ||| apart list full	count=1
function	shift the ||| shift	count=1
function	hypergeometric ||| hyper	count=2
arg	_symbolic_factor ||| opt method	count=1
arg	root if ||| cls root radicals	count=1
function	optimization opportunities in ||| cse	count=1
function	commutator ||| commutator	count=1
arg	of p [arg_2] ||| [arg_2] [arg_1]	count=1
arg	isolating ||| f s t eps	count=2
function_arg	integrate p ||| rs integrate p	count=1
arg	override geometryentity ||| pt	count=3
arg	self x tells whether ||| x	count=1
module	be of ||| series	count=1
function_arg	subtract polynomials ||| sub f g	count=1
arg	indices are covariant or ||| indices free	count=1
class	which docstrings ||| doc	count=1
arg	of f [arg_2] ||| dup apply pairs [arg_1] [arg_2]	count=1
function_arg	[function_1] free and ||| [arg_2] [function_1]	count=1
arg	given the objects and ||| objects merged_morphisms	count=1
arg	the [arg] s ||| [arg]	count=1
class	n-dim [class_2] ||| [class_2] [class_1]	count=2
function	"guess" a rational generating ||| generating	count=1
arg	b the first element ||| b	count=1
function	a new [function] has been ||| spread [function]	count=1
function	iterable or not ||| iterable	count=1
arg	key must be ||| key	count=1
function	only ||| only	count=2
arg	product expression ||| expr x y	count=1
arg	letters separated by sep ||| msg sep	count=1
function_arg	[function_1] [arg_2] ||| [function_1] gcd f g [arg_2]	count=4
function	[function_1] a sentinel ||| [function_1] [function_2]	count=1
function	unicode output ||| use unicode	count=1
function	minimum element moved by ||| min	count=1
arg	new key [arg_2] ||| [arg_1] [arg_2]	count=1
function_arg	[function_1] order n ||| [function_1] [arg_2]	count=6
class	a derivative ||| derivative	count=1
arg	g functions assuming the ||| g	count=1
arg	of rv that ||| rv	count=1
function	stop ||| process limits	count=2
function	to ||| get mod	count=2
arg	\mathbb{z}_p[z]/(\check m_{\alpha} [arg_2] ||| [arg_2] [arg_1]	count=6
function	generates legendre ||| legendre	count=1
function	evalf of ||| evalf	count=1
arg	an add/mul of qubit ||| qubit	count=1
function	factors of self ||| factors	count=1
function	in a python subprocess ||| subprocess	count=1
function_arg	renumber [arg_2] ||| [function_1] [arg_2]	count=4
function	extra [function_2] ||| [function_2] [function_1]	count=4
arg	l1 [arg_2] ||| [arg_2] [arg_1]	count=1
arg	[arg_1] q ||| [arg_1] [arg_2]	count=12
function	horizontal morphism [function_2] ||| [function_2] space [function_1]	count=1
function	or annihilate particle ||| q annihilator	count=2
function	no bounding ||| complexes	count=1
module	at ||| physics	count=1
arg	[arg] uses warshall's ||| [arg]	count=3
arg	expression with bosonic or ||| expr	count=1
function	system ||| system	count=3
function	wang/eez compute a ||| dmp zz wang	count=1
function	of phrase and ||| check and	count=1
function	the index ||| index	count=3
function	a wrapper around the ||| wrapper	count=1
function	matrix/complex number to ||| to	count=1
arg	[arg_1] and ||| [arg_2] [arg_1]	count=5
function	central [function_2] ||| [function_1] [function_2]	count=1
class	system [class] ||| [class]	count=3
function	cross product ||| cross	count=1
arg	j_3 [arg_2] ||| [arg_2] [arg_1]	count=7
function	is the size ||| size	count=1
function	preprocess ||| preprocess for cse	count=1
function	m-th order derivative ||| dmp diff	count=2
function	distance ||| distance	count=3
module	a vector ||| vector	count=3
function	[function_1] symbols ||| [function_2] [function_1]	count=5
function	[function_1] a univariate ||| [function_2] [function_1]	count=3
class	a root it ||| root	count=1
function_arg	[function_1] [arg_2] of the ||| [function_1] [arg_2]	count=10
function_arg	[function_1] morphism ||| [function_1] morphisms [arg_2]	count=1
module	value of ||| functions elementary	count=1
function	proper superset of ||| proper superset	count=2
function	function to replace constants ||| simplify variable	count=1
function	negative [function_2] ||| [function_2] isolate [function_1]	count=1
module	leverage ||| pretty	count=1
arg	f p [arg_2] ||| [arg_2] [arg_1]	count=7
arg	a polynomial expression ||| expression	count=1
function	test evaluation points for ||| test points	count=1
function	of ode ||| order1 type6	count=1
arg	f g ||| f g	count=9
function	all ||| all	count=7
function	and infinities ||| a coeff	count=1
function	the complement ||| complement	count=1
module_class	module [class_2] ||| [module_1] module [class_2]	count=2
function_arg	the sopform [arg_2] ||| [function_1] [arg_2]	count=1
function	symbol ||| auto symbol	count=1
class	returns a tuple of ||| basic	count=1
module_class	matrices along ||| matrices matrix shaping	count=2
function	root of ||| root	count=6
function	compute the reduced representation ||| trunc	count=1
function	that ||| complexes	count=1
arg	point center of mass ||| vec point	count=1
function_arg	gf [arg_2] ||| [function_1] monic f [arg_2]	count=2
arg	g ||| g k	count=1
class	a matrix ||| mutable dense matrix	count=1
arg	root if it is ||| root radicals	count=1
function	latex handling functions ||| print function	count=1
function	[function_1] moment of ||| [function_2] [function_1]	count=1
function	nth moment ||| moment	count=1
module_class	[module_1] free ||| [module_1] [class_2]	count=2
function_arg	from an ||| from expr cls	count=1
arg	q are polynomials ||| q x	count=5
function	compute a general hankel ||| hankel	count=1
arg	system of ||| x y z t	count=1
function	monomial order on ||| order	count=1
function	given orbit is only ||| only	count=1
arg	function p [arg] i ||| [arg]	count=1
arg	the [arg_1] [arg_2] ||| [arg_2] [arg_1]	count=2
function	leading coefficient ||| lc	count=1
function_arg	[function_1] x of ||| [arg_2] [function_1]	count=3
function_arg	[function_1] f ||| [arg_2] [function_1]	count=257
module	rearrange the order of ||| physics quantum	count=1
module_class	of the parabola ||| geometry parabola	count=3
arg	[arg_1] rhs ||| [arg_2] [arg_1]	count=1
function	complex [function_2] ||| [function_1] [function_2]	count=1
function	of phrase and if ||| check and join	count=1
function	unify [function_2] ||| [function_1] [function_2]	count=3
function_arg	d^2 [arg_2] ||| [function_1] [arg_2]	count=1
class	function in sympy simplify ||| expr	count=1
module	returns true if the ||| physics quantum	count=1
arg	expr, given that \operatorname{re} [arg_1] [arg_2] ||| integrals simplifyconds expr [arg_1] [arg_2]	count=2
function	return the series ||| series	count=1
function	for the generated files ||| get	count=2
arg	x_0 of a ||| m u	count=1
arg	[arg_1] z ||| holzer [arg_1] [arg_2]	count=1
function	returns the interior of ||| interior	count=1
function	lagrange's equations of ||| lagranges equations	count=2
module_class	the ray and ||| geometry ray	count=1
arg	derivative of f in ||| f	count=1
class	system examples ||| system	count=1
arg	continuous ||| mu	count=2
class	new code block ||| code block	count=2
function	return the ket on ||| ket	count=1
arg	series modulo o(x**prec) ||| p x prec	count=1
function	variation of [function_2] ||| [function_2] [function_1]	count=1
function	a series ||| rs	count=1
class	enumerate the partitions ||| traverser	count=1
function	generates laguerre ||| laguerre	count=1
class	this [class] entity ||| [class]	count=1
class	put a string ||| string	count=1
class	the partition is ||| integer partition	count=1
function	smallest primitive [function_2] ||| [function_1] [function_2]	count=4
function_arg	where f ||| ground f	count=3
function_arg	refine an [arg_2] ||| [arg_2] [function_1]	count=8
class	a code ||| code	count=1
module	and negative coefficient ||| simplify	count=1
function	cyclic notation from ||| cyclic	count=1
function	[function_1] heuristic finds ||| [function_1] [function_2]	count=1
arg	with ||| replace pos	count=1
function	return the jacobian matrix ||| jacobian	count=1
arg	[arg_1] value ||| [arg_2] [arg_1]	count=4
class	operator s [class_1] [class_2] an eigenstate of ||| quantum [class_2] [class_1] operators	count=1
arg	[arg_1] x prec ||| [arg_1] [arg_2]	count=8
function	available ||| pretty try use	count=1
function	returns l1 ||| l1	count=2
class	xy-pic representation ||| xypic diagram drawer	count=1
function	rust code parameters ||| rust code	count=1
arg	r ||| r	count=1
function_arg	[function_1] or an ||| [function_1] [arg_2]	count=4
function	performing the multiplication ||| mul	count=1
arg	symbols with those ||| symbols	count=1
arg	if e is a ||| e	count=1
function_arg	[function_1] enabled ||| [function_1] function [arg_2]	count=7
module	under the ||| physics mechanics	count=1
class	generators from [class] inject ||| [class]	count=1
module_class	[module_1] gate ||| [class_2] [module_1]	count=2
arg	if p ||| p	count=5
module	find the ||| physics	count=1
arg	with already-processed ||| is_commutative	count=1
function_arg	addition of [arg_2] ||| [function_1] [arg_2]	count=1
class	is currently ||| symbol	count=1
arg	f with respect to ||| f	count=1
function	files default from which ||| get test files	count=1
function	matrix if ||| matrix	count=1
arg	ex1 ex2 parameters ||| ex1 ex2	count=1
class	a ||| code gen	count=2
module	the form x ||| series	count=1
function_arg	[function_1] for computation ||| [arg_2] [function_1]	count=2
function	a python subprocess ||| in subprocess	count=1
function	a finite [function_2] ||| [function_1] [function_2]	count=1
class	of this fermionicoperator allow ||| fermionic operator	count=1
arg	f in k[x], ||| f k	count=1
function	diagonal ||| diagonal	count=1
function	returns the loads ||| loads	count=1
arg	as ||| tokens	count=1
function	is ||| try	count=1
function	bit vectors in ||| selections	count=1
function_arg	[function_1] [arg_2] n of a positive ||| [function_1] [arg_2]	count=5
arg	ex1 [arg_2] ||| [arg_1] [arg_2]	count=1
module	beta root of ||| polys	count=1
function	another fraction ||| fraction	count=1
arg	partial model ||| clauses symbols model	count=2
function	to format an error ||| error	count=1
function	object from components ||| from	count=1
arg	rv ||| rv	count=1
function	[function_1] groebner basis ||| [function_1] [function_2]	count=1
function	the integer ||| integer	count=1
function	the string path to ||| get	count=1
function	of real roots of ||| count real roots	count=1
class	of the picture in ||| string pict	count=1
function	clairaut ||| 2eq order1 type5	count=1
function	helper to tell whether ||| is	count=1
module	two [module] expressions also ||| [module]	count=1
function	of numerator ||| an	count=1
function	trailing coefficient ||| gf tc	count=1
function	normal order a ||| normal order	count=2
function	element ||| element	count=3
arg	[arg_1] k -> ||| [arg_2] [arg_1]	count=1
function	pairs of coefficients of ||| pairs	count=1
function	puiseux series ||| rs is puiseux	count=1
arg	constants [arg] have numbers ||| [arg] symbolname startnumber	count=1
function_arg	op [arg_2] ||| [function_1] op [arg_2]	count=2
class	mpz to gmpy's ||| gmpyinteger ring	count=1
module_class	[module_1] with submodule ||| [module_1] [class_2]	count=3
class	return a list ||| frac field	count=1
class	mapping of ||| llvmjit	count=1
arg	polynomials f g are ||| f g x	count=1
function	postprocess ||| postprocess for cse	count=1
arg	f ||| p f	count=1
function	distinct real [function_2] ||| [function_2] [function_1]	count=2
module	if ||| pretty	count=2
class	a specific ||| series base	count=1
module	the order ||| physics	count=1
arg	n [arg] ||| expr symbolname startnumber [arg]	count=1
function	canonical [function] storing ||| process [function]	count=1
arg	f ||| f m k	count=2
function	[function_1] linear in ||| [function_2] [function_1]	count=1
module	true if self ||| agca	count=10
arg	[arg] 1 ||| i j [arg]	count=1
function	random element from ||| random	count=1
function	exact pseudo-quotient of ||| pexquo	count=1
arg	of a polynomial ||| poly	count=2
function	gauss ||| gauss	count=1
arg	in x_j at a ||| f m a j	count=1
function	substitution ||| subs	count=2
function	in-place operation on row ||| row op	count=4
function_arg	[function_1] of an ||| [function_1] [arg_2]	count=10
function	see ||| pretty try	count=1
module_class	the current [class_2] ||| [module_1] units dimension [class_2]	count=4
arg	base and strong generating ||| base	count=2
function	ascents ||| ascents	count=1
arg	name and [arg_2] ||| [arg_1] [arg_2]	count=4
function	of the ||| mod func	count=1
class	the total number of ||| g	count=1
arg	exponents ||| combine force	count=1
function	returns the n-th coefficient ||| nth	count=1
function	the non-zero structure ||| row structure	count=2
arg	[arg_1] p g ||| [arg_2] [arg_1]	count=3
arg	h are [arg_2] ||| [arg_2] [arg_1]	count=2
function	reversion of a series ||| rs series reversion	count=1
class	and ||| relational	count=1
function	ode ||| ode 1st homogeneous coeff	count=1
function	be of the form ||| process limits	count=1
function	integer partition summing to ||| integer partition	count=1
arg	creates a small'' ||| deg_f deg_g	count=1
function	symbols that will ||| free symbols	count=1
function_arg	[function_1] c is ||| [arg_2] [function_1]	count=2
function	are structurally the same ||| aresame	count=1
arg	type of ||| x y t	count=3
function_arg	[function_1] c ||| [function_1] comm i j [arg_2]	count=1
function	the label ||| label	count=3
arg	whether u [arg_2] ||| [arg_2] [arg_1]	count=1
arg	x and y after ||| x y	count=1
function	real element object to ||| real	count=1
function	returns a standard ||| groebner	count=1
function	converts ||| convert to	count=2
function	of self [function] ||| [function]	count=2
module	to factorint which return ||| core	count=1
function	explicit [function] possibly ||| [function]	count=1
arg	a log-normal distribution ||| mean std	count=1
function	[function_1] square ||| [function_2] [function_1]	count=1
function	the argument ||| argument	count=1
class	of the polyhedra ||| polyhedron	count=1
arg	j_4 j_5 j_6 j_7 ||| j_4	count=1
function	raw dict ||| raw dict	count=2
function	printed as [function] false ||| needs [function]	count=1
function	return a random ||| random	count=2
function	fast multiplication ||| mul	count=1
class	positions ||| permutation	count=2
function	a wigner semicircle ||| wigner semicircle	count=2
class	generate a ||| free module poly	count=1
function	the n-th coefficient ||| nth	count=3
function	quotient [function_2] ||| [function_2] [function_1]	count=2
arg	of eq such ||| eq	count=1
function	the additive [function] symbol ||| remove [function]	count=1
function	differentiate and ||| dmp diff	count=1
arg	opportunities in ||| order	count=1
function	the cartan matrix for ||| cartan matrix	count=3
function	with sorted components the ||| sorted components	count=1
module_class	if the elements ||| combinatorics permutation	count=1
function	scalar potential ||| scalar potential	count=2
function	returns all [function_2] ||| [function_1] [function_2]	count=3
function_arg	normal [arg_2] ||| [function_1] [arg_2]	count=1
class	method of coset enumeration ||| coset	count=1
arg	for the [arg] points ||| [arg]	count=1
function	cot ||| cot	count=1
function	the matrix corresponding to ||| matrix	count=1
arg	gen in ||| gen	count=1
arg	s ||| s p	count=1
function_arg	[function_1] j see ||| [arg_2] [function_1]	count=1
function	tensor product of different ||| tensor printing	count=1
function	[function] summation ||| telescopic [function]	count=2
function_arg	return the [function_1] [arg_2] ||| [function_1] [arg_2]	count=2
arg	index index ||| index	count=1
function	the next [function_2] ||| [function_1] [function_2]	count=2
arg	[arg_1] z ||| [arg_1] [arg_2]	count=6
class	of g_2" ||| g	count=1
function	the bending moment curve ||| bending moment	count=1
module	the kinematic differential equations ||| physics	count=1
arg	characters ||| s	count=1
function	jacobi polynomial of degree ||| jacobi poly	count=1
module	the simplified list ||| physics quantum	count=1
function	lucas ||| lucas	count=1
function	is an isomorphism ||| is isomorphism	count=2
function	has a [function_2] ||| [function_1] [function_2]	count=3
module	string path to a ||| utilities	count=1
arg	eqs ||| eqs	count=1
function	length of ||| length	count=1
arg	if it is a ||| symbol gens	count=1
arg	of f s over ||| f s x	count=1
function	finite_set in ||| empty in	count=1
module	return iterator in which ||| utilities	count=1
function	ending of ||| suffix	count=1
arg	the solution [arg] ||| [arg] z	count=1
function	the atan of ||| rs atan	count=1
arg	univariate series expansion ||| n x prec	count=1
function_arg	[function_1] using vincent-akritas-strzebonski ||| [function_1] [arg_2]	count=3
arg	p q are ||| p q	count=7
function	of objects that appear ||| objects	count=1
function_arg	[function_1] two permutation ||| [function_1] [arg_2]	count=2
function	is assumed ||| modified subresultants pg	count=1
arg	[arg_1] [arg_2] used to construct it ||| [arg_1] [arg_2] increment	count=8
function	computes the gauss-chebyshev ||| gauss chebyshev t	count=1
arg	to infinity g1*g2 ||| g1 g2	count=1
module	that no bounding rectangles ||| polys	count=1
function	a list ||| split list	count=1
arg	similar bases and exponents ||| deep combine force	count=1
arg	of f [arg_2] ||| [arg_2] [arg_1]	count=53
function	arguments ||| args	count=1
module	[module] the ||| [module]	count=2
arg	an index in ||| index	count=2
function	to rotate ||| rotate	count=1
module	random variable given the ||| stats	count=1
function	copy ||| structure copy	count=1
module	of the ||| functions elementary	count=1
function	define the ||| classify sysode	count=1
function_arg	[function_1] polynomials in ||| [arg_2] [function_1]	count=6
function	of a complex ||| complex	count=1
arg	where n [arg] - ||| expr symbolname startnumber [arg]	count=1
module	available ||| printing pretty	count=2
function_arg	unify representations of ||| unify f	count=1
function_arg	distance between [arg_2] ||| [function_1] [arg_2]	count=4
function	create an sdm ||| sdm	count=1
function	2d n-link pendulum ||| n link pendulum	count=1
function	paths into a list ||| paths	count=1
module_class	[module_1] plane ||| [module_1] [class_2] arbitrary point	count=1
class	excluding those ||| series	count=1
function	element which should be ||| element	count=1
class	a standard basis ||| poly	count=1
class	a groebner [class_2] ||| [class_2] [class_1]	count=2
arg	given inequality or ||| symbol domain	count=1
class	at ||| factory	count=1
function	asin ||| rs asin	count=2
function	and is [function_2] ||| [function_2] [function_1]	count=4
arg	dx using g functions ||| g x	count=1
arg	all partions of n ||| n	count=1
function	perpendicular to ||| perpendicular	count=1
function_arg	tell whether e ||| is expr e	count=1
function	dtype ||| from	count=16
function_arg	a finite [arg_2] ||| [function_1] diff derivative [arg_2]	count=1
function	scalar potential difference ||| scalar potential difference	count=3
function	dv/v where f ||| recognize log derivative	count=1
function	[function_1] decomposition itself ||| [function_2] [function_1]	count=4
function	merge [function_2] ||| [function_2] [function_1]	count=2
module	call _normal_order_factor to perform ||| quantum	count=1
function_arg	interval [arg_2] ||| [arg_2] [function_1]	count=12
arg	for n data ||| n x x	count=1
function	the poly last inserted ||| final touches	count=1
arg	f in [inf sup] ||| f inf sup	count=1
module	a string with mathml ||| utilities mathml	count=1
arg	[arg] r ||| [arg] r	count=2
class	a groebner [class_2] ||| [class_1] [class_2]	count=2
function	represent a [function_2] ||| [function_1] [function_2]	count=1
function	register ||| register handler	count=1
function	in-place operation on ||| op	count=6
function	to render a function ||| function	count=1
function	returns the base ||| base	count=1
function	new copy of a ||| copy	count=1
arg	polynomials in ||| f g k	count=4
class	line ||| linear	count=1
function	f = [function] ||| [function]	count=2
module_class	[module_1] integer ||| [module_1] [class_2]	count=1
function	f** -1 mod x**n ||| dmp revert	count=1
arg	+ by = c ||| c a b t	count=1
arg	sep ||| msg sep	count=1
arg	gcd a m ||| m	count=1
function	critical pair corresponding to ||| critical pair	count=1
function	redirect an apply ||| apply operator int	count=2
class	of this sparsematrix ||| sparse matrix	count=1
module	s, and return ||| utilities	count=1
arg	equation ||| eq param	count=1
function	[function_1] normal ||| [function_2] [function_1]	count=4
function	matrix to [function_2] ||| [function_2] [function_1]	count=1
function	of a finite ||| as finite	count=1
class	this method returns the ||| base	count=1
function_arg	[function_1] [arg_2] case ||| [function_1] [arg_2]	count=3
class	remainder ||| gmpyrational field	count=1
function	to the ||| get	count=1
module_class	[module_1] generators ||| [module_1] [class_2]	count=8
function	[function_1] one ||| [function_2] [function_1]	count=2
function	[function_1] [function_2] ||| [function_2] zz [function_1]	count=4
function	difference between two points ||| difference	count=1
function	given generators ||| from expr if gens	count=2
arg	fpgroup h a subgroup ||| h	count=1
function	subset ||| subset	count=3
function_arg	[function_1] [arg_2] the special case ||| [function_1] d [arg_2]	count=1
function	the subset ||| subset from	count=1
arg	group [arg] ||| [arg]	count=1
function	[function_1] modulus ||| [function_1] [function_2]	count=1
function	the ground [function_2] ||| [function_2] [function_1]	count=2
function	minimum [function_2] ||| [function_1] [function_2]	count=2
function	of the generator that ||| generator	count=1
function	inverse ||| inverse	count=13
function	anp [function_2] ||| [function_2] [function_1]	count=4
function	that ||| free	count=1
function_arg	substitution [arg_2] ||| [function_1] [arg_2]	count=1
module	of a [module] row-wise ||| [module]	count=2
function	derived ||| derived	count=1
function	a field ||| to field	count=1
function	string path to the ||| get mod func	count=1
function	careful! any evalf of ||| eval evalf	count=1
function	simplify ||| simplify	count=2
function	critical pair corresponding ||| critical pair	count=1
function	standardised right coset table ||| coset table	count=1
function_arg	[function_1] [arg_2] ||| [function_1] rule [arg_2]	count=6
function	and evaluate ||| eval in	count=1
arg	if ||| a b	count=1
module_class	matrices [class_2] ||| [module_1] [class_2]	count=16
arg	ops to [arg_2] ||| [arg_2] [arg_1]	count=2
arg	vector of constants ||| matlist variable constant k	count=3
function_arg	[function_1] p ||| [function_1] sqr f [arg_2]	count=1
module_class	[module_1] scheme ||| [module_1] color [class_2]	count=1
class	of matrix ||| sparse matrix	count=1
function	dmp ||| global polynomial ring	count=1
function	symbolic values to ||| dict	count=1
class	evaluate the transform ||| transform	count=1
function	sdm [function_2] ||| [function_1] [function_2]	count=3
class	if the differential ||| differential operator	count=1
function_arg	[function_1] to name ||| [arg_2] [function_1]	count=3
class	method of coset ||| coset table	count=1
class	position ||| sys cartesian	count=1
arg	the plane varying t ||| t	count=1
arg	literal ||| lit	count=1
module	and leverage it if ||| printing pretty	count=1
arg	an n x n ||| cls n	count=2
function	the coefficient ||| coeff	count=10
arg	[arg_1] pt -- ||| [arg_2] [arg_1]	count=4
function	lu [function_2] ||| [function_1] [function_2]	count=1
class	a ||| frac	count=1
function	lower in rank ||| sub	count=1
function	[function_1] row ||| [function_2] [function_1]	count=16
arg	a sympy expression ||| expr callback_type	count=1
function	truth value ||| eval cond	count=1
arg	compute ||| f	count=23
function	transform ||| transform	count=8
function	computes the transitive ||| transitive	count=1
arg	x ||| b x	count=2
arg	[arg_1] function f ||| [arg_2] [arg_1]	count=2
function	berkowitz algorithm ||| det berkowitz	count=1
arg	of a and b ||| a b	count=17
class	of the indexed object ||| indexed	count=1
arg	to b ||| b	count=1
function	the base of ||| base	count=1
module	each [module] 0 ||| [module]	count=1
function	add the given number ||| indent	count=1
function	be written as g* ||| as f	count=1
function	the quadratic ||| quadratic normal	count=1
function	is quadratic in all ||| is quadratic	count=1
class	the column matrix ||| symbolic	count=1
function	sum ||| sum	count=4
module	truth value of ||| functions	count=1
function	the expr [function_2] ||| [function_1] [function_2]	count=1
function	product of elements ||| mul	count=1
function	[function_1] sliding cart ||| [function_1] [function_2]	count=5
arg	transformation used to ||| to_sys	count=1
function	[function_1] term ||| [function_1] [function_2]	count=9
function	sequence in ||| seq	count=1
arg	series expansion of ||| a prec	count=1
function	to which the triangle ||| triangle to	count=1
function	bitlist corresponding [function_2] ||| [function_2] [function_1]	count=2
function	the order of a ||| order	count=3
function_arg	set the [arg_2] ||| categories diagram [function_1] dict union dictionary [arg_2] value	count=1
function	trial division ||| trial division	count=2
arg	a single symbol e ||| a b	count=1
module_class	return a [module_1] [class_2] ||| [module_1] [class_2]	count=4
arg	[arg_1] s , ||| [arg_1] [arg_2]	count=2
arg	g in k[x] ||| g u k	count=2
function	to a string of [function_1] [function_2] ||| printing [function_1] [function_2]	count=3
function_arg	new [arg_2] ||| [arg_2] [function_1]	count=1
function_arg	the order [arg_2] ||| [function_1] at [arg_2]	count=1
arg	compute basic ||| strong_gens_distr	count=1
function	a rl ||| rl	count=1
function_arg	constant term [arg_2] ||| [arg_2] [function_1]	count=8
arg	rhs but ||| rhs	count=1
function_arg	decryption [arg_2] ||| [arg_2] [function_1]	count=1
function_arg	[function_1] [arg_2] ||| polys [function_1] [arg_2]	count=14
function	level ||| level	count=4
arg	equation eq by ||| eq param syms	count=1
module	calculates the clebsch-gordan ||| physics	count=1
arg	[arg_1] q x ||| [arg_2] [arg_1]	count=3
arg	set of polynomials g ||| g	count=1
function	christoffel symbols for ||| christoffel 2nd	count=1
class	to ||| rational field	count=1
function	restricted ||| only	count=1
function	speed of ||| speed	count=1
module	module ||| polys agca	count=4
arg	of a given ||| expr	count=1
function	encryption ||| encipher	count=1
arg	a single symbol ||| a	count=1
function	sum of k squares ||| sum of squares	count=1
function	[function_1] matrix ||| [function_1] [function_2]	count=8
function	two simple [function_2] ||| [function_1] [function_2]	count=3
function	is decreasing in the ||| is decreasing	count=1
function	primitive [function_2] ||| [function_2] [function_1]	count=6
arg	field curve ||| field curve	count=2
arg	field [arg_2] ||| [arg_2] [arg_1]	count=2
function	[function_1] multivariate ||| [function_1] [function_2]	count=1
function_arg	decryption of [arg_2] ||| [function_1] [arg_2]	count=1
function	intersection of a ||| intersection	count=1
function	[function_1] mellin transform ||| [function_2] [function_1]	count=3
arg	number of levels in ||| k	count=1
arg	a set of points ||| points incremental	count=1
function	symbols ||| enable automatic symbols	count=1
arg	target to yield ||| target	count=1
function	a sympy [function_2] ||| [function_2] [function_1]	count=4
function	christoffel symbols for the ||| to christoffel 1st	count=1
module	the actual ||| physics	count=1
arg	== b**e if n ||| n candidates big factor	count=1
class	to the module ||| module quotient	count=1
arg	[arg_1] such ||| ntheory symmetric residue [arg_2] [arg_1]	count=1
function	random integer [function_2] ||| [function_1] [function_2]	count=3
function	[function_1] random generators ||| [function_2] pr [function_1]	count=1
function	for the generated ||| get	count=2
arg	to two labeled ||| g	count=1
function	returns the scalar ||| scalar	count=3
function	reconstruct a rational ||| rational reconstruction	count=1
function	proper line ||| get	count=1
arg	of [arg] ||| n [arg] b	count=9
function	of christoffel symbols for ||| christoffel 2nd	count=1
function	frobenius map parameters ||| frobenius map	count=1
function	raw [function_2] ||| [function_1] [function_2]	count=1
function	hint implements the lie ||| lie	count=1
function	a sparse distributed module ||| sdm	count=1
function_arg	[function_1] for n ||| [function_1] [arg_2]	count=2
class	pstack if possible returning ||| multiset partition traverser	count=2
arg	solutions of f ||| p f	count=1
function	find optimization opportunities ||| opt cse	count=1
function_arg	derivative of [arg_2] ||| [function_1] numerically [arg_2]	count=7
arg	in k[x] using ||| f	count=1
class	the module ||| module	count=1
function_arg	a prime [arg_2] ||| [arg_2] [function_1]	count=1
function_arg	rotate a [arg_2] ||| [arg_2] [function_1]	count=2
module	get the version of ||| physics quantum	count=1
class	outside the main ||| properties	count=1
function	if the right ||| right	count=1
function_arg	[function_1] pairs affect ||| [arg_2] [function_1]	count=5
module_class	[module_1] category ||| [module_1] [class_2]	count=2
module	the two class representatives ||| combinatorics	count=1
function_arg	lambdify [arg_2] ||| [arg_2] [function_1]	count=2
module	self ||| core	count=2
class	bounding rectangles of non-conjugate ||| complex root	count=1
arg	rules ||| p rules x	count=1
function_arg	[function_1] h as ||| [arg_2] [function_1]	count=4
arg	a polynomial expression and ||| expression	count=1
function	of christoffel symbols for ||| to christoffel 1st	count=1
arg	corresponding [arg] ||| n [arg]	count=1
function_arg	[function_1] in k[x] ||| [function_1] lcm [arg_2]	count=1
function	[function_1] properly normalized ||| [function_1] [function_2]	count=1
module	assumptions ||| assumptions	count=1
arg	if f ||| f	count=14
function	returns square-free part ||| dmp sqf part	count=3
function	polynomials in z[x] ||| dup zz	count=2
function	permutation matrix to change ||| permutation matrix	count=1
function	monomial ||| sdm monomial	count=1
function	isotropic harmonic oscillator ||| e nl	count=1
module_class	of the ray ||| geometry ray	count=1
class	a standard ||| module	count=1
function_arg	addition of two ||| add other	count=2
function	that no bounding ||| refine complexes	count=1
arg	bases and exponents ||| deep combine force	count=1
arg	for details ||| re g	count=1
arg	by a constant value ||| c	count=1
function	check ||| check	count=3
class	explicitly returns an ||| expr	count=1
function	k squares false ||| squares	count=1
function	in the object excluding ||| free	count=1
module	to perform ||| quantum	count=1
function	function for ||| function	count=1
function	return the bra ||| bra	count=1
function	a polynomial [function] ||| [function] l1	count=1
class	apply on ||| commutator	count=1
function	form ||| form	count=9
function	roots ||| roots	count=24
function	permutation matrix to ||| permutation matrix	count=2
arg	of square-free ||| polys k	count=1
arg	integrate [arg] over ||| [arg] a	count=1
function	of equivalent ||| generate equivalent	count=1
function_arg	[function_1] p0 ||| [arg_2] [function_1]	count=1
arg	polynomial expression and the ||| expression	count=1
function	helper function to solve ||| solve	count=1
arg	b ||| b order	count=3
module	vector [module_2] ||| [module_1] [module_2]	count=1
function	is a submodule ||| is submodule	count=9
arg	beginning ||| s	count=1
function	returns the symbols that ||| symbols	count=2
arg	denominator of f and ||| a d de z	count=1
function	characters of phrase and ||| check and	count=1
module	p[i] < ||| combinatorics	count=1
function	reduce a system of ||| reduce	count=2
class	to this [class] entity which ||| [class]	count=1
function	tangent ||| tan	count=1
arg	x_j ||| m n j	count=1
module	standard basis in ||| agca	count=1
function	point is located ||| point	count=1
function_arg	[function_1] p ||| [function_1] [arg_2]	count=16
arg	[arg_1] basis ||| [arg_1] [arg_2]	count=1
arg	given the objects ||| objects merged_morphisms	count=1
function	terms of real sets ||| set	count=3
arg	f ||| f c k	count=1
function	in finite_set ||| in	count=1
function	calculates the jacobian ||| jacobian	count=1
function	[function_1] explicit ||| [function_1] [function_2] matmul	count=1
module	of [module_2] ||| [module_1] [module_2]	count=46
arg	polynomial f in ||| f n	count=1
class	standard ||| module poly ring	count=2
arg	and the variable ||| variable	count=1
arg	a transformation ||| to_sys	count=1
module	which ||| quantum	count=1
arg	x**n == a ||| a n p k	count=1
module	that should be defined ||| core	count=1
function	modulus ||| modulus	count=1
arg	if it [arg] are comparable ||| [arg]	count=1
function	decomposition ||| decomposition	count=1
class	of ||| piecewise	count=1
function	berkowitz algorithm to ||| berkowitz	count=1
class	submodule ||| free module quotient ring	count=1
function	return constant [function_2] ||| [function_1] [function_2]	count=2
function	functions in finite_set in ||| not empty in	count=1
class	are ||| differential extension	count=2
class	is currently at ||| factory	count=1
module	function ||| functions elementary	count=4
arg	only func remains in ||| func	count=1
function	is reducible by checking ||| is reducible	count=1
function_arg	[function_1] f ||| polys [function_1] [arg_2]	count=1
function	into a sparse ||| vector to	count=1
function	into its piecewise form ||| as piecewise	count=1
function	classes to their ||| to state	count=1
arg	state ||| state	count=4
arg	vector of constants ||| variable constant	count=3
function	print ||| print	count=2
class	given the faces ||| polyhedron	count=1
module	simplify ||| simplify	count=1
function	the subset ||| get subset from	count=1
function	indices of [function_2] ||| [function_2] [function_1]	count=2
function	poly last inserted ||| final touches	count=1
arg	the user in ||| weylelt	count=2
function_arg	[function_1] in k ||| [function_1] [arg_2]	count=1
function	represent a ||| represent	count=1
function	[function_1] [function_2] ||| [function_1] [function_2] lst	count=4
function	returns l1 [function_2] ||| [function_1] [function_2]	count=7
function	into ||| vector to	count=1
class	fockstateket else multiply self ||| annihilate boson	count=1
function	a diagonal ||| diagonal	count=1
arg	in \mathbb{z}_p[x0 \ldots x{k-1}] ||| p degbound	count=1
function	a proper subset of ||| proper subset	count=1
class	of ||| poly	count=2
class	line in 3d ||| linear entity3d	count=1
function	differentiate ||| diff	count=1
arg	f ||| f m n k	count=1
arg	[arg_1] | j_3 ||| [arg_1] [arg_2]	count=2
class	of polynomial ||| field	count=1
arg	of f given an ||| f	count=1
function	the mul hint see ||| mul	count=1
class	a root it takes ||| root	count=1
function	numerator ||| numer	count=1
arg	of [arg_2] ||| [arg_1] [arg_2]	count=2
function	limit of each ||| limit	count=1
function	of inversions ||| inversions	count=1
class	the ||| matrix properties	count=1
function	decryption ||| decipher bifid5	count=1
arg	equal to the curl ||| vect doit	count=1
arg	apply f to all ||| f atoms	count=1
arg	from sympy import lex ||| order	count=1
function_arg	points [arg_2] ||| [function_1] [arg_2]	count=1
arg	condition [arg_2] ||| [arg_1] [arg_2]	count=1
function	expectation of ||| expectation	count=2
arg	bounding rectangles of ||| cls	count=1
function	zero matrix [function_2] ||| [function_2] [function_1]	count=3
arg	the intervals in ||| f	count=1
arg	by [arg] \cdot ||| [arg] w a	count=1
function	[function_1] group ||| [function_1] [function_2]	count=4
function	excluding those ||| free	count=1
function	hensel lifting [function_2] ||| [function_2] zz [function_1]	count=2
function	to switch to another ||| connect to	count=1
class	new code [class_2] ||| [class_1] [class_2]	count=2
arg	of the key ||| key	count=1
function	solves a differential ||| ode	count=2
arg	defined by [arg] \cdot v ||| [arg] w a	count=1
function	integer modulus ||| integer	count=1
function	[function_1] subset ||| [function_2] [function_1]	count=2
arg	as a single g ||| x a b	count=1
function	is ||| is	count=112
function	the name of the ||| get	count=1
arg	a polynomial ||| minpoly p	count=1
function_arg	[function_1] controls ||| [function_1] [arg_2]	count=4
function	second moment of area ||| second moment	count=1
function_arg	[function_1] x_j = ||| [function_1] tail f [arg_2]	count=1
function	simplify a mul ||| mul	count=1
function	remove ||| dumx remove	count=1
arg	[arg_1] subtracting ||| scale [arg_1] [arg_2]	count=1
module	return a list ||| polys	count=1
class	excluding those ||| base	count=1
class	of the ||| polyhedron	count=1
function	return the components of ||| components	count=1
function	[function_1] sequence in ||| [function_1] [function_2]	count=1
arg	apply a rule ||| rule	count=3
class	convert a monomial ||| monomial	count=1
function_arg	1st [arg_2] ||| [arg_2] [function_1]	count=2
arg	a small'' ||| deg_f deg_g row1	count=1
function	compute the gcd of ||| gcd	count=1
function	x_i**k_i ||| inflate	count=1
function	the module and ||| get	count=1
function	reduce the [function_2] ||| [function_1] [function_2]	count=1
function	row ||| row	count=6
class	formats ||| printer	count=1
class	complex isolating intervals ||| complex	count=1
arg	[x] ||| k	count=14
function	base and ||| as base	count=2
function	an ode from ||| ode 1st	count=1
arg	degree d with knots ||| d knots n	count=1
module	the canonical ||| physics units	count=1
function	path to ||| func	count=2
function	mpmath mpf object ||| real field	count=5
arg	[arg_1] n ||| [arg_1] [arg_2]	count=3
function	evaluate the derivative ||| eval derivative	count=3
function	sympy matrix/complex number ||| sympy	count=1
class	transform is ||| transform	count=1
function	class into a ||| get	count=1
function	[function_1] tree ||| [function_2] [function_1]	count=4
arg	[arg_1] coefficient d ||| [arg_2] [arg_1]	count=2
function	returns refractive index ||| refractive index	count=2
function	a system of ||| system	count=1
function_arg	multivariate series [arg_2] ||| [arg_2] [function_1]	count=3
function	in which ||| empty in	count=1
function_arg	[function_1] n ||| [function_1] [arg_2]	count=39
function	lift the ||| lift	count=1
function	polynomial to a ||| to	count=1
function	[function_1] base exponent ||| [function_1] [function_2]	count=1
module	and [module] ||| [module]	count=3
class	in ||| module poly ring	count=2
class	of polar ||| polar	count=1
function_arg	two assumptions [arg_2] ||| [arg_2] [function_1]	count=1
arg	alpha as a ||| alpha	count=1
module_class	belonging [module_1] [class_2] ||| [module_1] [class_2]	count=1
arg	= b ||| b a b	count=1
class	a line and a ||| line	count=1
function_arg	[function_1] in expr ||| [arg_2] [function_1]	count=4
arg	symbols with ||| symbols	count=1
arg	using vincent-akritas-strzebonski vas continued ||| f k eps	count=1
function	minimal polynomial ||| minpoly	count=3
arg	j_2 [arg_2] ||| [arg_1] [arg_2]	count=11
function	all native coefficients ||| native coeffs	count=1
arg	interval s ||| s	count=1
function	for the constant ||| constant	count=1
arg	solution [arg] ||| [arg]	count=2
class	returns ||| matrix	count=1
module	matrix containing ||| mechanics	count=1
class	the transform is ||| transform	count=1
arg	of levels in ||| k	count=1
class	components ||| lazy	count=1
class	quaternion orientation orients the ||| quaternion orienter	count=1
function	integer [function_2] ||| [function_2] [function_1]	count=5
function	symbol target ||| target	count=1
arg	switch to ||| f native	count=2
function_arg	[function_1] f ||| [function_1] numerically [arg_2]	count=1
function	if ||| pretty try	count=2
function	permutation ||| permutation	count=2
module	returns a ||| agca	count=1
arg	a beta ||| alpha beta	count=1
module	matrix multiplication one row ||| matrices	count=1
class	latex knows about e ||| latex	count=1
arg	operator [arg_2] ||| [arg_1] [arg_2]	count=1
function	number of rows in ||| height	count=1
function	multinomial [function_2] ||| [function_2] [function_1]	count=2
function_arg	[function_1] ops to ||| [function_1] obj [arg_2]	count=5
arg	of f in k[x], ||| f k	count=1
function	ode from the two ||| ode 1st homogeneous coeff	count=1
function_arg	order of [arg_2] ||| diffgeom covariant [function_1] [arg_2]	count=1
function	around expand ||| expand power base	count=2
function	[function_1] an isomorphism ||| [function_2] [function_1]	count=1
function	[function_1] from a ||| [function_2] [function_1]	count=9
function	from ||| poly from	count=2
arg	[arg] - ||| expr symbolname startnumber [arg]	count=1
function	generators ||| parallel dict from expr no gens	count=1
arg	of the ||| x	count=2
function	to the ||| indent	count=1
class	polygon ||| polygon	count=8
arg	a + sign*s this ||| a sign	count=1
module	beginning of ||| utilities	count=1
function	fermi? >>> ||| fermi	count=2
arg	expression ||| expr var	count=2
function	the minimal polynomial ||| minpoly op algebraic	count=1
function	subprocess [function_2] ||| [function_1] [function_2]	count=3
function	argument [function] ||| needs [function]	count=1
class	free [class_2] ||| [class_2] [class_1]	count=1
arg	b modulo ||| b order	count=3
function	name of the class ||| mod func	count=1
function	operation on col ||| col op	count=3
arg	coefficient ||| exprs order	count=1
function_arg	a function [arg_2] ||| [arg_2] [function_1]	count=1
function	finite_set in which the ||| empty	count=1
class	corresponding to a group ||| group	count=1
function	returns the base of ||| base	count=1
function_arg	sympy matrix ||| sympy m	count=1
function	the hilbert [function_2] ||| [function_2] [function_1]	count=1
arg	e z at the ||| e z	count=1
arg	h a subgroup whose ||| h	count=1
function	[function_1] field ||| [function_2] [function_1]	count=3
function_arg	logarithm of [arg_2] ||| [function_1] [arg_2]	count=2
function	a horizontal ||| horizontal	count=1
arg	of key ||| key	count=3
class	on a ||| series	count=1
function	to which the triangle ||| find triangle to	count=1
arg	and b [arg_2] ||| [arg_1] [arg_2]	count=1
arg	transformation q**n * f(p/q) ||| p q	count=1
function	load the ||| load	count=1
function	full partial ||| full	count=1
function	a list ||| as list	count=1
function_arg	of degrees [arg_2] ||| [arg_2] [function_1]	count=1
arg	f in [inf sup] ||| f k inf sup	count=1
function	on a sliding ||| on	count=1
function	[function_1] moment ||| [function_2] [function_1]	count=5
arg	function f ||| f args	count=1
arg	differential equations in eq ||| eq	count=1
class	returns a tensor [class_1] [class_2] ||| tensor [class_2] [class_1]	count=1
function	has only integer powers ||| has integer powers	count=1
arg	of points ||| points incremental	count=1
arg	isolating interval ||| f s t eps	count=2
function_arg	at [arg_2] ||| [function_1] a [arg_2]	count=5
function	a string path ||| get mod	count=1
function	symbolic ||| param	count=1
module	returns a standard basis ||| polys	count=1
module	truth ||| functions	count=1
module	this function ||| physics quantum	count=1
arg	get an indexed ||| index radicals	count=1
arg	[arg_1] components data ||| [arg_2] [arg_1]	count=2
function_arg	subtract [arg_2] ||| [function_1] [arg_2]	count=1
module	of a vector ||| vector	count=2
function	of free ||| free	count=3
function	sort to ||| sort	count=1
function	that no bounding ||| refine	count=1
arg	c from self ||| c	count=1
arg	via prs ||| includeprs	count=1
function	default printing behavior ||| sympystr	count=1
module	function ||| functions	count=6
function	multiply dense ||| dmp mul	count=2
class	as a cycle ||| cycle	count=1
function	[function_1] equation ||| [function_1] [function_2] func_class f symbol	count=4
function	singularity functions ||| eval rewrite as singularity function	count=1
function	[function_1] thus the ||| [function_1] [function_2]	count=4
class	the ||| printer	count=1
function	the cyclic notation from ||| cyclic form	count=1
function	the ||| not	count=3
function	fails if the lu ||| lu	count=1
function	[function_1] polynomial in ||| [function_1] [function_2]	count=1
class	take on a specific ||| base	count=1
arg	keys are used ||| keys	count=1
arg	[arg_1] in k[x] ||| [arg_2] [arg_1]	count=32
arg	is ||| r	count=1
function	direction cosine [function] dcm also ||| rotation [function]	count=1
function	solves a ||| solve	count=1
arg	interval ||| interval	count=3
function_arg	term in [arg_2] ||| [function_1] p [arg_2]	count=2
function	_minimal_polynomial_sq it selects a ||| separate sq	count=1
arg	variable in the terms ||| terms	count=1
function	isolate ||| isolate	count=3
function	[function_1] matrices pq ||| [function_2] [function_1]	count=1
module	can get the ||| combinatorics	count=1
module	[module_1] unit ||| [module_1] [module_2]	count=2
function_arg	directional derivative [arg_2] ||| [arg_2] [function_1]	count=4
function	the quotient ||| quotient	count=1
class	returns the total number ||| type g	count=1
arg	f s over ||| f s	count=1
function_arg	[function_1] differential ||| [function_1] eq func order [arg_2]	count=2
function	python subprocess with hash ||| in subprocess with hash	count=1
function_arg	distance between two ||| distance other	count=2
function_arg	h [arg_2] ||| [arg_2] [function_1]	count=2
module	leverage it ||| printing pretty	count=1
arg	the specified rank ||| rank superset	count=4
class	those morphisms [class] their properties ||| [class]	count=1
function	clear [function_2] ||| [function_1] [function_2]	count=2
module	that ||| simplify	count=2
function	series for ||| series	count=2
function	symbolic values ||| param	count=1
function	gcd of coefficients ||| dmp ground content	count=1
arg	routines in c ||| routines f	count=1
class	new code [class_2] ||| [class_2] [class_1]	count=2
function_arg	the orbit [arg_2] ||| [arg_2] [function_1]	count=4
class	self to the module ||| module quotient	count=1
arg	in a ||| f g	count=1
function	tensor ||| combined tensor	count=1
function	of two bivariate integer ||| bivariate	count=1
arg	tree [arg_2] ||| [arg_1] [arg_2]	count=1
class	a list of polynomial ||| field	count=1
function	system [function_2] ||| [function_1] [function_2]	count=4
module	the kinematic differential ||| physics mechanics	count=1
function	[function_1] equation of ||| [function_2] [function_1]	count=4
class	[class] iteration ||| [class]	count=3
function	a k [function_2] ||| [function_2] [function_1]	count=1
function	to a list representation ||| list	count=1
arg	re [arg_2] ||| [arg_2] [arg_1]	count=1
arg	rules ||| p rules	count=1
function	a unit ||| one	count=3
function	dummy associated to ||| dummy	count=1
arg	g in f[x] ||| g	count=1
function	is assumed ||| subresultants rem	count=1
function	digamma function ||| digamma	count=1
arg	given the objects and ||| objects	count=1
function	heuristic [function_2] ||| [function_1] [function_2]	count=3
function	direct [function] several ||| direct [function]	count=1
function	a 3-tuple ||| three	count=1
function_arg	[function_1] [arg_2] ||| [function_1] force vec [arg_2]	count=2
arg	return characters of key ||| key	count=1
arg	of the operations ||| visual	count=1
function	this [function] eliminates ||| elimination [function]	count=1
arg	at a ||| a	count=2
function	represents [function] ||| [function]	count=1
function_arg	the series [arg_2] ||| [arg_2] [function_1]	count=1
function	create a continuous ||| continuous	count=1
function	is non-positive ||| is nonpositive	count=4
function	traversal of a tree ||| traversal	count=1
function	decodes a morse ||| morse	count=1
function	[function_1] a multivariate ||| [function_2] [function_1]	count=1
arg	with hilbert_space and args ||| hilbert_space	count=1
function	coding to ||| bin to	count=1
function_arg	trial [arg_2] ||| [arg_2] [function_1]	count=2
function	[function_1] monotonic in ||| [function_2] [function_1]	count=5
arg	l is ||| l r	count=1
function	power series expansion ||| series	count=1
function	given generators ||| parallel dict from expr if gens	count=1
arg	a in the i-th ||| a	count=1
function_arg	cofactors of [arg_2] ||| [function_1] gcd [arg_2]	count=5
class	a finiteset in ||| finite set	count=1
arg	and for each di ||| a d	count=1
function	sequence ||| seq	count=1
function	positive [function] given ||| [function]	count=1
module	using ||| integrals	count=1
function	be in integer ||| find pure symbol int	count=1
class	ket ||| ket	count=1
function	returns the closing ||| ending	count=1
function	[function_1] math ||| [function_2] [function_1]	count=4
function	the proper line ending ||| get	count=1
module	excluding those ||| series	count=1
class	polynomials or containers of ||| ring	count=1
function	transversals from a ||| transversals from bsgs	count=1
module	of the form x ||| series	count=1
class	a ||| sub module poly	count=1
function_arg	total degree [arg_2] ||| [function_1] [arg_2]	count=1
function	factory for threaded ||| threaded factory	count=3
function	converts a ||| to	count=3
function_arg	[function_1] x ||| [function_1] f [arg_2]	count=1
function	singularity ||| singularity	count=1
class	category ||| category	count=1
module	literal ||| algorithms	count=1
function_arg	[function_1] [arg_2] using two-arg functor whose ||| [function_1] op [arg_2]	count=5
arg	types ||| func_args	count=1
function	for specific integer ||| integer	count=1
function	refine a positive ||| inner refine real	count=1
function	path to the module ||| get mod	count=1
function	[function] distribution ||| [function]	count=1
arg	the objects and ||| objects	count=1
function	[function_1] lagrange's equations ||| [function_2] [function_1]	count=1
function_arg	[function_1] replaced by ||| [function_1] f [arg_2]	count=3
function	[function_1] cosine between ||| [function_2] [function_1]	count=3
arg	of square-free polynomial ||| polys k eps	count=1
function	[function_1] start of ||| [function_1] [function_2]	count=4
function	the premises of this ||| premises	count=1
function_arg	orbit [arg_2] ||| [function_1] [arg_2]	count=1
function_arg	coefficients [arg_2] ||| [function_1] [arg_2]	count=3
arg	n digits ||| n	count=1
module	x *-2 [module] 1 + ||| [module]	count=1
class	the ground domain ||| poly	count=1
function	heuristic assumes ||| heuristic bivariate	count=1
arg	helper function for _invert ||| f g_ys symbol	count=2
arg	variable with a ||| name sigma	count=1
arg	of p ||| p n	count=2
function	a string path ||| get	count=1
function	math-related macros from ||| macros	count=1
arg	of the key ||| key symbols	count=1
arg	[arg] objects ||| [arg]	count=3
arg	polynomial at x_j = ||| a	count=1
module	we can ||| combinatorics	count=1
function	[function_1] [function_2] ||| hep [function_1] [function_2]	count=17
function_arg	check [arg_2] ||| [arg_2] [function_1]	count=2
arg	a polynomial in ||| f p	count=1
arg	in an expression ||| expr	count=1
function	level of ||| level	count=2
arg	points in \mathbb{z}_p ||| evalpoints hpeval ring i	count=1
class	compute ||| number	count=1
arg	root if it is ||| root	count=1
function	set of ||| pairs	count=1
module	polynomial coefficients ||| polys	count=1
function	dummy having the same ||| dummy	count=1
function_arg	[function_1] if c ||| [arg_2] [function_1]	count=4
function_arg	multiplication c ||| mul scalar c	count=1
function	[function_1] length ||| [function_1] [function_2]	count=2
arg	size n ||| n	count=1
function	for a horizontal ||| horizontal	count=1
function	lu ||| lu	count=2
function	is ||| use	count=1
class	the proper line ||| code printer	count=1
arg	eq that contain ||| eq	count=1
class	[class_1] array of ||| [class_2] [class_1]	count=3
function_arg	[function_1] expression e ||| [arg_2] [function_1]	count=2
function	list of square-free factors ||| sqf list include	count=1
arg	g [arg_2] ||| [arg_2] [arg_1]	count=15
arg	is ||| other	count=2
arg	1 if k ||| k	count=1
function	the nth root of ||| nth root	count=1
function	primitive polynomial ||| dmp primitive	count=1
function	compute f - ||| sub	count=1
function	the letter representation ||| letter form	count=2
function	values above fermi? >>> ||| above fermi	count=1
module	product [module] ||| [module]	count=1
function_arg	[function_1] [arg_2] ||| [function_1] disjoint [arg_2]	count=3
arg	[arg_1] differential equation ||| [arg_2] [arg_1]	count=14
arg	for constructing the string ||| j grid morphisms_str_info	count=1
arg	of f in ||| f	count=9
function	equation with constant coefficients ||| constant	count=1
function	simple roots together the ||| simple roots	count=1
function	remainder sequence prs ||| prs	count=3
function	differential ||| ode	count=4
module	truth value of the ||| functions	count=1
function_arg	quotient [arg_2] ||| [arg_2] [function_1]	count=21
function_arg	[function_1] medium p ||| [arg_2] [function_1]	count=1
arg	the public key ||| key	count=2
function	reversion of [function_2] ||| [function_2] [function_1]	count=2
function_arg	[function_1] p [x]/ ||| [function_1] pow mod f [arg_2]	count=1
function	[function_1] matrices for ||| [function_2] [function_1]	count=1
function	matrix to change ||| matrix	count=1
function	of independent generators ||| basis	count=5
function	[function_1] the triangle ||| [function_2] [function_1]	count=2
arg	to fringe ||| fringe	count=1
function	root of a ||| root	count=2
function	number n ||| n	count=1
module	number of space ||| utilities	count=1
module	class ||| utilities	count=2
function	reverse [function_2] ||| [function_1] [function_2]	count=3
class	[class_1] n-dim ||| [class_1] [class_2]	count=2
function	of roots of ||| roots	count=3
function	a quasi-particle? ||| q creator	count=2
function	_minimal_polynomial_sq it selects ||| separate sq	count=1
class	point of all zeros ||| point	count=1
arg	x for x->oo ||| x	count=1
class	on ||| commutator	count=1
function	make a dictionary from ||| to dict	count=1
function	[function_1] transversals relative ||| [function_2] [function_1]	count=1
function_arg	[function_1] a transformation ||| [function_1] [arg_2]	count=2
function	trial multiplication algorithm ||| trial mul	count=1
module	for the generated files ||| utilities	count=2
function	[function_1] key ||| [function_2] [function_1]	count=1
function	polynomial trace ||| trace	count=1
function	algorithms performing the multiplication ||| mul	count=1
function	[function_1] cancellation ||| [function_1] [function_2]	count=1
arg	an expression selected by ||| expr func args	count=2
function	speed of the electromagnetic ||| speed	count=1
function	of the atan ||| rs atan	count=1
arg	[arg_1] alpha ||| [arg_2] [arg_1]	count=2
function	is strictly decreasing in ||| is strictly decreasing	count=1
function	returns the leading nonzero ||| as leading	count=1
function	[function_1] class ||| [function_2] [function_1]	count=4
function	the minimal polynomial ||| minimal polynomial	count=2
arg	f at ||| f i	count=1
function	attained by other, ||| ge	count=1
function	two terms ||| as two	count=2
class	list of polynomial ||| field	count=1
class	[class] inject them ||| [class]	count=2
arg	a f ||| f	count=1
function	object from components ||| from components	count=1
function	apply state to ||| apply operator	count=2
arg	and g which ||| g	count=1
function	interval for most ||| interval	count=1
function	fraction decomposition algorithm ||| decomposition	count=1
function	[function_1] factors of ||| [function_2] [function_1]	count=5
module	the algorithm ||| physics	count=1
module	only apply branching rule ||| strategies branch	count=1
function	denominator ||| denom	count=7
function	base ||| base	count=5
function	known as hlt+lookahead method ||| look ahead	count=1
module	returns a ||| domains	count=9
module	being the ||| combinatorics	count=1
function	coeff is ||| coeff	count=1
arg	false [arg] < 2^64 ||| [arg]	count=1
class	ring ||| ring	count=2
class	for a ||| base	count=1
function_arg	division [arg_2] ||| [arg_2] [function_1]	count=8
arg	j_2 m_2 | ||| j_2	count=1
function	the berkowitz algorithm ||| det berkowitz	count=1
class	nothing ||| field	count=1
module	the ||| physics quantum	count=46
function	hyperbolic functions in terms ||| as	count=1
arg	elements of k0 and ||| k0	count=1
class	state of ||| state	count=1
arg	that only func ||| func	count=1
function	if a solution for ||| is	count=1
module	the positions of ||| combinatorics	count=2
arg	[arg_1] p for ||| div f [arg_1] [arg_2]	count=1
function	hull surrounding the ||| hull	count=1
arg	of f ||| f m k	count=2
function	the code by ||| code	count=1
function	is positive ||| is	count=1
arg	== a ||| a n p k	count=1
module	to ||| core	count=1
arg	pointer in s2 deg_g ||| deg_g	count=1
function_arg	[function_1] [arg_2] special case ||| [function_1] [arg_2]	count=3
function	is reducible by ||| is reducible	count=1
function	heuristic [function_2] ||| [function_2] [function_1]	count=3
function	gcd of coefficients ||| content	count=2
class	number ||| type g	count=1
arg	beta x ||| x	count=1
function_arg	g*h [arg_2] ||| [arg_2] [function_1]	count=16
arg	self where m ||| m	count=1
arg	expression expressions are ||| expr	count=1
module	the [module] if ||| [module]	count=1
class	given line in 3d ||| linear entity3d	count=1
class	gate needs ||| gate	count=2
arg	instance ||| cls	count=5
function	into ||| get mod func	count=1
function	a sympy matrix/complex number ||| sympy	count=1
class	a ||| commutator	count=1
function	the amount given ||| decipher shift	count=1
arg	model ||| clauses symbols model	count=2
function	qexpr ||| qexpr	count=1
class	the c [class_2] ||| [class_2] [class_1]	count=2
arg	of this type of ||| x y t r	count=3
arg	v ||| x v dom	count=1
arg	order n [arg_2] ||| [arg_1] [arg_2]	count=1
function	identity is ||| is	count=1
function	of ||| limits	count=1
function	area ||| area	count=1
function	pendulum on ||| n link pendulum on	count=1
arg	prime with p ||| p	count=1
function	extract common content from ||| dmp ground extract	count=1
arg	[arg_1] and ||| [arg_1] [arg_2]	count=5
function	the earth rotation ||| type3	count=1
function_arg	bernoulli [arg_2] ||| [function_1] name p succ [arg_2]	count=1
class	polynomial ||| field	count=1
class	line perpendicular to this [class_1] [class_2] which passes through ||| [class_1] [class_2] perpendicular line	count=1
function_arg	[function_1] n data ||| [function_1] [arg_2]	count=2
class	other functions ||| basic	count=1
function	transposed sparsematrix ||| transpose	count=1
module	of this ||| polys	count=4
arg	of expr and ||| expr	count=1
function_arg	set the [arg_2] ||| [function_1] comm i j [arg_2]	count=1
function	to another fraction ||| fraction	count=1
function	loads a boolean expression ||| load	count=1
function	if unicode output ||| use unicode	count=1
arg	from k0 [arg_2] ||| [arg_1] [arg_2]	count=1
function_arg	orbit of [arg_2] ||| [arg_2] [function_1]	count=10
function	zero module element ||| sdm zero	count=1
function	the ||| empty in	count=3
arg	n ||| n candidates big factor	count=1
function	[function_1] a dict ||| [function_1] sympy [function_2]	count=1
function	uses the log ||| log	count=1
function	available and leverage it ||| pretty try	count=1
function	module and the name ||| mod	count=1
function	lie group method ||| ode lie group	count=2
function	[function_1] points ||| [function_2] [function_1]	count=2
arg	col ||| col	count=1
function	evaluate a ||| evaluate	count=1
class	the fortran ||| fcode gen	count=2
module	to a class into ||| utilities	count=1
arg	only func ||| func	count=1
function	base of ||| base	count=1
function	to [function_2] ||| [function_1] [function_2]	count=12
function	list into part ||| list	count=1
function	fraction to a ||| fraction	count=1
arg	root if ||| root radicals	count=1
function	mapping of symbolic ||| create param	count=1
function	in [function_2] ||| [function_1] [function_2] of generators	count=3
function	is ||| p	count=3
function	returns the amplitude ||| amplitude	count=1
class	tuples index pos 0 ||| index	count=1
arg	negative coefficient muls ||| exprs	count=1
function	[function_1] even ||| [function_1] [function_2]	count=1
function	gcd [function_2] ||| [function_2] [function_1]	count=32
arg	of two [arg_2] ||| [arg_2] [arg_1]	count=1
function	[function_1] a quasi-particle? ||| [function_2] [function_1]	count=1
function_arg	[function_1] p parameters ||| [function_1] iter a [arg_2]	count=1
function_arg	split [arg_2] ||| [arg_2] [function_1]	count=3
arg	two univariate [arg_2] ||| [arg_1] minpoly [arg_2]	count=1
function	domain ||| empty in	count=1
function	above [function_2] ||| [function_2] [function_1]	count=4
function	[function] of ||| bending [function]	count=1
function	print output of python() ||| print	count=1
function	of basis ||| basis	count=1
module_class	[module_1] prufer ||| [module_1] [class_2] tree	count=1
module	function and returns ||| functions elementary	count=1
function	single gamma ||| single	count=1
module	with mathml ||| utilities mathml	count=1
arg	evaluation points in \mathbb{z}_p ||| evalpoints hpeval ring i	count=1
function	variation of ||| variation of	count=1
arg	condition on that expression ||| expr condition	count=1
function	decryption of ||| decipher bifid5	count=1
function	[function_1] term in ||| [function_1] [function_2]	count=5
arg	of f ||| f u	count=1
function	subs ||| subs	count=1
function_arg	[function_1] e and ||| [arg_2] [function_1]	count=4
arg	modulo a polynomial p ||| p	count=1
function	and a mutable list ||| set	count=1
arg	and ||| a d de	count=1
function	[function_1] the discrete ||| [function_2] log [function_1]	count=1
class	domain of a polynomial ||| poly	count=1
arg	expression about c i ||| n c condition	count=1
arg	lhs - rhs ||| lhs rhs	count=2
function	into a nested tuple ||| to tuple	count=1
function	to a rational ||| to rational prec	count=3
module_class	[module_1] quot ||| [module_1] [class_2]	count=2
function	returns a simplified ||| simplify	count=1
function	is written as ||| as coeff	count=2
function	[function_1] terms from ||| [function_1] [function_2]	count=1
arg	g in z_p for ||| g p k	count=1
class	factor where the root ||| complex root of	count=1
function_arg	from a tensexpr all [function_1] [arg_2] ||| [function_1] [arg_2]	count=1
function	total [function_2] ||| [function_1] [function_2]	count=2
class	coordinate system with respect ||| coord sys cartesian	count=1
arg	anti-derivative to the ||| meijerg risch	count=1
arg	[arg_1] dum indices ||| [arg_2] [arg_1]	count=1
function	[function_1] integer partition ||| [function_1] [function_2]	count=3
function	mpmath mpf [function_2] ||| [function_2] [function_1]	count=8
function	to a rational ||| to rational	count=1
class	return ||| complex root	count=1
module	return -1 0 ||| core	count=1
function_arg	[function_1] f at ||| [arg_2] [function_1]	count=1
arg	or second default kind ||| d kind	count=1
class	this linear [class_2] ||| [class_1] [class_2]	count=4
function_arg	laplace transform [arg_2] ||| [arg_2] [function_1]	count=5
arg	n shifted to ||| n	count=1
arg	a subcircuit [arg] another ||| circuit subcircuit [arg]	count=1
arg	g [arg_2] ||| [arg_1] [arg_2]	count=11
arg	if expr is ||| expr	count=1
function_arg	polynomial [arg_2] ||| [arg_2] [function_1]	count=9
function	a ||| func	count=2
class	x c matrix of ||| matrix	count=2
module	to the given ||| physics	count=1
function	[function_1] unicode ||| [function_2] [function_1]	count=1
function	[function_1] decreasing in ||| [function_2] [function_1]	count=9
function	weibull ||| weibull	count=1
function	modularinteger [function_2] ||| [function_2] [function_1]	count=1
class	currently at ||| symbol factory	count=1
function	monomials from a univariate ||| monoms	count=1
class	from a sparse ||| sparse	count=1
function	the coefficient of ||| as coeff add	count=3
arg	an expression ||| expr syms func evaluate	count=1
arg	n alpha ||| n	count=1
module_class	the interior angle ||| geometry regular	count=1
function	exponentiation of a series ||| rs exp	count=1
function	[function_1] coefficients using ||| [function_2] [function_1]	count=2
arg	small'' matrix m to ||| deg_f deg_g row1	count=1
function	has [function_2] ||| [function_1] [function_2]	count=4
function_arg	trial factors ||| trial factors	count=1
class	gmpy's ||| gmpyinteger ring	count=3
class	[class] not as ||| [class]	count=3
module	the ||| physics optics	count=1
function	zero ||| zero	count=16
function	correct the values ||| correct signature	count=1
arg	, \xi ||| match comp	count=1
function	as a ||| as	count=6
function_arg	autonomous system [arg_2] ||| [function_1] [arg_2]	count=3
function	it's matrix representation ||| matrix	count=1
arg	x_0 of a ||| f m u	count=1
function	generators ||| generators	count=1
arg	of size n ||| n	count=1
function	an ode from the ||| ode 1st	count=1
function_arg	[function_1] cipher encryption ||| [function_1] [arg_2]	count=3
function	returns the total degree ||| total degree	count=1
module	without the added integration ||| physics vector	count=1
function	in ||| not	count=2
arg	function is used ||| l	count=1
function	of the ||| eval cond	count=1
arg	modulo [arg_2] ||| [arg_1] [arg_2]	count=1
function	expr ||| expr	count=1
function	order of a ||| order	count=3
arg	in x_0 ||| f m u k	count=1
function_arg	[function_1] difference formula ||| [function_1] diff derivative [arg_2]	count=4
function	polynomial from a ||| from	count=1
function	refine an ||| refine	count=3
class	that take ||| series base	count=1
function	tensor product ||| tensor	count=1
function	dot product ||| dot	count=2
function	the 2-axis ||| axis2	count=1
function	generates symmetric [function_2] ||| [function_2] [function_1]	count=3
function_arg	[function_1] two polynomials ||| [arg_2] [function_1]	count=5
arg	that oth ||| oth	count=1
function	sets to the ||| sets	count=1
function	sparsity of the matrix ||| matrix	count=1
arg	a mobius transform or ||| m k eps	count=1
function	"restricted growth string" ||| rgs	count=1
arg	modulo p for ||| p	count=1
function	the limit ||| limit	count=1
module	of symbolic values to ||| printing	count=1
function	decimal instance to ||| decimal to	count=3
class	object excluding those that ||| series base	count=1
arg	:class arrowstringdescription describing ||| morphisms_str_info	count=1
function	truth ||| eval cond	count=2
arg	optimized _strip with h ||| h base	count=1
function	representation of ||| form	count=1
function	mapping of symbolic ||| create	count=1
arg	no bounding ||| cls	count=1
function	of ascents in a ||| ascents	count=1
function	random generators ||| random	count=1
arg	or not [arg] ||| [arg]	count=1
class	root it takes ||| root system	count=1
class	subsset ||| subs set	count=1
function	hash [function_2] ||| [function_2] [function_1]	count=1
class	exploiting the ||| sparse	count=2
arg	modulo o(x**prec) ||| p x prec	count=3
module	given the ||| combinatorics	count=1
arg	key must ||| key	count=1
class	no ||| complex root	count=1
function	returns rank ||| rank	count=1
function	the potential [function_2] ||| [function_1] [function_2]	count=2
arg	a composite polynomial ||| poly	count=3
function	free symbols of a ||| free symbols	count=1
function	form ||| process	count=1
arg	using g ||| g x	count=1
function	returns the expression ||| expr	count=1
class	checks if the differential ||| differential operator	count=1
arg	a codestring ||| codestring	count=1
arg	to f ||| f c u k	count=1
function	the nine-point ||| nine point	count=1
function	create a finite ||| finite rv	count=1
function	[function_1] l1 ||| [function_2] [function_1]	count=1
arg	eqs and checks that ||| eqs	count=1
function_arg	treats xor [arg_2] ||| [arg_2] [function_1]	count=1
function	to a [function_1] [function_2] ||| printing [function_1] [function_2]	count=1
arg	in terms of ||| x n logx	count=1
arg	associated to name ||| name	count=1
class	commutator ||| free group element	count=1
function	path to ||| mod	count=2
function	returns l1 norm of ||| l1 norm	count=1
module	the supplied ||| physics	count=1
arg	polynomial expression and ||| expression	count=1
function	a list of native ||| native	count=1
arg	[arg_1] is ||| [arg_1] [arg_2]	count=1
function	a sympy [function_2] ||| [function_1] [function_2]	count=4
function	spherical harmonics ||| ynm	count=1
class	regularpolygon ||| regular polygon	count=2
arg	= gcd a m ||| m	count=1
function	the functions ||| empty	count=1
function	the length of a ||| morphism length	count=1
arg	constructing the string representation ||| grid morphisms_str_info	count=1
arg	a fraction ||| a	count=1
class	excluding those ||| series base	count=1
module	of the generalized ||| physics mechanics	count=1
function_arg	[function_1] f in ||| [arg_2] [function_1]	count=47
module	the inverse of ||| physics quantum	count=1
function	wrapper around ||| power base	count=1
class	self to ||| extension	count=1
arg	x = a ||| a	count=1
function	binary ordered ||| unrank binary	count=1
arg	rules ||| rules x	count=1
class	root to the given ||| root of	count=1
arg	argument passed by ||| arg k	count=1
module	number ||| utilities	count=1
function	relative accuracy [function] ||| [function]	count=1
arg	is not in ||| filter	count=1
function	remove leading zeros from ||| strip	count=1
module	args [module] *are* ||| [module]	count=1
arg	expression about c ||| c	count=1
module	rewrite logic operators ||| logic	count=1
module	the ||| printing	count=1
class	generate a ||| quotient ring	count=1
arg	m is the ||| m	count=1
function	this ||| eval	count=1
arg	g is ||| g	count=1
class	the xy-pic representation ||| xypic diagram drawer	count=1
module	the functions ||| calculus	count=1
class	the kb with ||| kb	count=1
function	trotter-johnson ||| trotterjohnson	count=1
arg	k[x] polynomial ||| f u k	count=1
class	group for ||| group	count=1
arg	p [x] ||| p symmetric	count=3
function	having root ||| choose	count=1
function	replace constants ||| simplify variable	count=2
module	labeled polynomial ||| polys	count=1
module_class	of roots ||| liealgebras type g	count=1
function_arg	the ideal other ||| ideal other	count=1
function	is not-empty ||| empty in	count=1
class	at ||| symbol	count=1
class	should be used ||| base	count=1
function	intended or q[x] it ||| vv	count=1
function_arg	pseudo-division of [arg_2] ||| [function_1] [arg_2]	count=2
function	the telescopic property ||| telescopic	count=1
arg	order n in x ||| n x	count=1
module	of this ||| vector	count=4
module	deprecated in the ||| physics	count=1
function	reflections of the ||| generators	count=1
function	proper [function_2] ||| [function_2] [function_1]	count=6
class	the proper line ending ||| printer	count=1
class	coordinate system with ||| coord	count=2
arg	n with ||| n	count=1
function	symmetry ||| symmetry	count=1
function	sympy's ||| sympy	count=3
arg	denested [arg] after denesting ||| [arg]	count=1
function	see ||| use	count=1
class	gauss ||| matrix base	count=1
function	ode from the two ||| ode	count=1
function	subtract ||| sub	count=5
arg	the letters of s ||| s	count=1
function	subprocess with [function_2] ||| [function_2] [function_1]	count=2
function	the class of objects ||| objects	count=1
class	current system into ||| system	count=1
function_arg	over a [arg_2] ||| [function_1] lcm [arg_2]	count=1
module	return iterator in ||| utilities	count=1
function	the string path ||| mod func	count=1
function	minimum ||| min	count=4
module	check if the underlying ||| physics	count=1
function	any evalf ||| evalf	count=1
function	[function_1] subset of ||| [function_2] [function_1]	count=2
arg	n data points ||| n x x y	count=1
function	or annihilate particle if ||| is q annihilator	count=1
class	gate ||| cnot gate	count=1
module	used to set the ||| physics	count=1
arg	an accuracy of ||| subs maxn chop	count=1
function	level of self ||| level	count=2
function	factor multivariate polynomials over ||| dmp gf factor	count=1
function	the functions in finite_set ||| empty	count=1
arg	[arg_1] with already-processed ||| [arg_2] [arg_1]	count=2
class	space ||| space	count=2
class	generate ||| module poly ring	count=1
arg	input word ||| alpha word	count=1
class	of other ||| basic	count=1
arg	true ||| small	count=1
function_arg	coefficients [arg_2] ||| [arg_2] [function_1]	count=3
arg	a [arg_2] ||| simplify dotrig [arg_1] [arg_2]	count=3
arg	to a second order ||| func order match	count=1
class	the components [class_2] ||| [class_2] [class_1]	count=2
arg	results using the writer ||| clear_globs	count=1
function	rotational gradients ||| rot grad	count=1
function	of ||| param dict	count=1
class	if a group ||| group	count=1
function	definite ||| definite	count=1
arg	scipy ||| circuit nqubits identity_only	count=1
arg	[arg_1] b ||| [arg_1] [arg_2]	count=6
function	primitive form ||| ground primitive	count=1
function	is one ||| is primitive	count=2
arg	takes the sequence ||| seq	count=1
function	root to the ||| root	count=2
arg	j_4 j_5 j_6 ||| j_4	count=1
function	mutable ||| mutable	count=1
function	term of the series ||| series	count=1
function	forcing vector of the ||| forcing full	count=1
function_arg	transversal of the right [function_1] [arg_2] the second method described ||| [function_1] transversal [arg_2]	count=2
function	of [function] polynomials ||| integrate [function]	count=1
arg	a rule down ||| rule	count=1
function	explicit [function] possibly trimming ||| [function]	count=1
function_arg	whether [arg_2] ||| [arg_2] [function_1]	count=4
arg	only func ||| func hint	count=1
function	pow of the ||| pow	count=1
function_arg	finite [arg_2] ||| [arg_2] [function_1]	count=1
arg	equation eq by ||| eq	count=1
function_arg	diagram [arg_2] ||| [arg_2] [function_1]	count=4
arg	in symbols ||| symbols filter	count=2
function	is a sentinel of ||| is sentinel	count=1
arg	[arg_1] , defined ||| [arg_2] [arg_1]	count=3
arg	expected value ||| condition numsamples evaluate	count=1
function	the slope the elastic ||| slope	count=1
function	as part [function] false ||| needs [function]	count=1
arg	dmp out of the ||| kill	count=1
function	computes the indefinite integral ||| integrate	count=3
arg	center of mass by ||| vec	count=1
function	on the top ||| top	count=2
arg	function arguments ||| func_args	count=1
arg	start ||| func	count=1
function	cosine between 2 ||| cosine	count=1
function	[function_1] ratio of ||| [function_2] [function_1]	count=2
arg	the rotations are applied ||| angle1 angle2 angle3 rot_order	count=1
function	both integers then ||| param	count=1
arg	that contain nested square ||| nested	count=1
module	the default printing of ||| physics quantum	count=1
arg	and u ||| reverse	count=1
function	[function_1] power of ||| [function_2] [function_1]	count=3
arg	that oth is ||| oth	count=1
function	by computing i^e ||| rsa	count=1
arg	computes floor expr ||| expr	count=1
function_arg	gf [arg_2] ||| [function_1] ddf shoup f [arg_2]	count=1
arg	[arg] < ||| [arg]	count=1
class	[class] a, ||| [class]	count=1
function_arg	a holonomic [arg_2] ||| [function_1] [arg_2]	count=1
module	the default printing ||| physics quantum	count=1
module	rearrange the ||| physics quantum	count=1
function	positive integer n, factorint ||| factorint	count=1
function	gcd ||| gcd	count=30
function	degree of ||| find degree	count=1
function	subprocess with [function_2] ||| [function_1] [function_2]	count=2
function_arg	positive root [arg_2] ||| [function_1] [arg_2]	count=8
function	a constant term ||| constant term	count=2
module	or below the fermi ||| physics	count=3
class	excluding ||| series	count=1
arg	[arg_1] im ||| [arg_2] [arg_1]	count=1
arg	objects and ||| objects	count=1
module	the get_dim method using ||| physics units	count=1
module	available and ||| pretty	count=1
function	the homogeneous ||| homogenize	count=1
function	linearize the system ||| linearize	count=1
function	decide how ||| hprint	count=1
arg	of the index index ||| index	count=1
function	interval of a root ||| root	count=2
function	printed as [function] false otherwise ||| needs [function]	count=1
class	returns ||| sub module	count=1
function	additive [function] symbol if ||| remove [function]	count=1
function	a horizontal morphism ||| horizontal	count=1
function	num/den by removing square ||| rad	count=1
function	[function_1] extension ||| [function_2] [function_1]	count=1
function	over ||| dup rr	count=3
arg	a parametric representation for ||| a	count=1
arg	are [arg] ||| subset [arg]	count=1
function	dictionary from a ||| dict	count=1
module	return terms of series ||| core	count=1
function	free indices corresponding ||| free indices	count=2
module	generated ||| integrals	count=1
function	find ||| opt	count=1
function	series expansion for ||| series	count=1
function	dual ||| dual	count=2
arg	if it is ||| symbol	count=1
function	replaced by ||| call	count=1
function	variable with [function] distribution ||| [function]	count=1
class	the coefficients ||| dmp	count=1
arg	for n ||| n x x	count=1
module	object excluding those ||| series	count=1
function	the limits ||| limits	count=1
function_arg	basis [arg_2] ||| [function_1] [arg_2]	count=1
function	free list ||| free	count=1
arg	prop ||| prop base strong_gens tests	count=1
function	an identity ||| identity	count=1
function	a multivariate [function_2] ||| [function_1] [function_2]	count=1
function	ordinary decimal instance ||| decimal	count=1
class	[class] diagonal ||| matrix [class]	count=2
arg	f defined ||| f k r	count=1
function	hilbert ||| eval hilbert	count=1
arg	r are linear ||| r	count=1
arg	[arg_1] suitable for ||| [arg_1] [arg_2]	count=2
function_arg	initialize from [arg_2] ||| [function_1] s baseline binding [arg_2]	count=1
arg	[arg_1] by a ||| [arg_1] [arg_2]	count=3
function	finite_set in which the ||| empty in	count=1
class	of f_4 ||| type f	count=1
function	check if ||| is	count=1
module	to simplify ||| simplify	count=2
function	dimension ||| dimension	count=7
arg	in the model ||| clauses model	count=1
function	return the truth ||| eval cond	count=1
function	flatten ||| flatten	count=1
function	calculates the finite difference ||| finite	count=1
function	berkowitz ||| berkowitz	count=2
arg	g and order ||| g	count=1
function	strictly decreasing in ||| strictly decreasing	count=2
arg	occupations is ||| occupations	count=1
class	bounding rectangles of non-conjugate ||| root	count=1
module	the terms ||| physics	count=1
class	the homomorphism obtained ||| homomorphism	count=1
function	heurisch ||| heurisch	count=1
arg	a log-normal ||| mean std	count=1
arg	h ||| h	count=8
arg	in k[x] ||| f g u k	count=4
arg	in x ||| a b x	count=1
function	returns the precedence of ||| precedence	count=1
arg	mellin transform of g ||| g x	count=1
module	of polynomials ||| polys	count=3
function	finds ||| not empty in	count=1
function_arg	h [arg_2] ||| [function_1] h [arg_2]	count=2
arg	negative ||| order	count=1
function	pohlig-hellman algorithm ||| pohlig hellman	count=1
function	[function_1] inequality ||| [function_1] [function_2]	count=2
arg	root1 ||| root1	count=1
arg	r are ||| r	count=1
function	the parity ||| parity	count=1
function	return the basic ||| basic	count=1
function	root or ||| root	count=1
arg	s over the fundamental ||| s	count=1
function_arg	[function_1] suitability ||| [arg_2] [function_1]	count=4
function	symbols of a ||| symbols	count=1
function	higher ||| add	count=1
arg	j ||| j	count=10
arg	return the series expansion ||| prec	count=1
function	sparse zero matrix to ||| sparse matrix to	count=1
function	lie ||| ode lie	count=1
function	is solvable ||| is solvable	count=2
function	the number of ||| number	count=1
function	factor multivariate ||| dmp gf factor	count=1
module	list of ||| polys	count=4
arg	of factors using ||| f factors u k	count=1
function	[function_1] simple roots ||| [function_2] [function_1]	count=1
arg	grid adds an edge ||| grid	count=1
function	a sentinel of a ||| sentinel	count=1
arg	x0 to b ||| b	count=1
function	the incircle ||| incircle	count=1
function	the string path ||| mod	count=1
function	are similar ||| similar	count=1
arg	interval s t ||| s t k	count=2
module_class	[module_1] product with ||| [module_1] [class_2]	count=2
function	object of type immutabledensematrix ||| as explicit	count=1
arg	f [arg_2] ||| eval [arg_1] [arg_2]	count=2
function_arg	expr cond [arg_2] ||| [arg_2] [function_1]	count=1
function	of undetermined coefficients ||| coeff undetermined coefficients	count=2
function	[function_1] polynomial ||| [function_1] [function_2]	count=10
function	coefficients at an ordinary ||| ordinary	count=1
arg	p of k[t 1/t] ||| p t z	count=1
class	[class_1] series every ||| [class_2] [class_1]	count=3
arg	in ||| filter	count=1
arg	scalar field ||| scalar_field	count=2
function	and the primitive form ||| ground primitive	count=1
arg	sympy expression ||| expr	count=1
class	[class_1] system ||| [class_2] [class_1]	count=2
arg	s over ||| s	count=1
arg	polynomial expression [arg_2] ||| [arg_1] [arg_2] increment	count=1
arg	about c ||| n c condition	count=1
class	we can get the ||| polyhedron	count=1
function	form x ||| limits	count=1
class	plane and ||| plane	count=1
function	multivariate ||| multivariate	count=1
function_arg	[function_1] n ||| [function_1] of squares [arg_2]	count=1
function	[function_1] of operators ||| [function_2] [function_1]	count=1
function	method converts a ||| letter form to	count=1
function	to a ||| to	count=15
class	symbolic values to ||| llvmjit	count=1
arg	n [arg_2] ||| [arg_2] [arg_1]	count=16
arg	mpf tuple normalized appropriately ||| mpf prec	count=1
function	over a ||| ff	count=2
arg	y z of the ||| y z a	count=1
arg	a simplified version eq' ||| subs exponents_only	count=1
function	[function] function ||| add [function]	count=1
function	bounding rectangles of non-conjugate ||| refine complexes	count=1
function	apply additional ||| apply	count=1
class	the faces of ||| polyhedron	count=1
arg	x or the main ||| x	count=1
arg	[arg] of a ||| expr [arg]	count=3
function	the unit ||| unit	count=1
function	circumcircle ||| circumcircle	count=1
function	polynomial pseudo-quotient ||| pquo	count=1
class	for the generated files ||| code gen	count=1
function_arg	[function_1] isolating interval ||| [function_1] root [arg_2]	count=2
class	an element ||| element	count=1
module	the line ||| physics quantum	count=1
arg	elements of a start ||| a start	count=1
rep	return factors [function_arg_2] ||| [module_class_1] [function_arg_2]	count=6
class	self to ||| differential extension	count=1
function	ode ||| order1 type5	count=1
arg	split arg ||| arg	count=1
function	with homogeneous coefficients using ||| homogeneous coeff	count=1
function	[function_1] sequence ||| [function_1] [function_2]	count=1
function	reduced representation of ||| trunc	count=1
module_class	[module_1] dyadic ||| [class_2] [module_1]	count=2
function_arg	[function_1] [arg_2] ||| [function_1] name [arg_2]	count=2
function	[function_1] submodule ||| [function_1] [function_2]	count=4
function	pi ||| pi	count=2
function	the n-th coefficient of ||| dmp nth	count=1
function	mapping of symbolic values ||| create param	count=1
arg	function for functions ||| expression predicate	count=1
function	tree as a list ||| tree	count=1
arg	eq such ||| eq	count=1
function	returns f - g*h ||| dmp sub mul	count=1
function	evaluate the given formula ||| evalf	count=1
arg	the specified ||| superset	count=2
function	set the ||| set	count=4
function	polynomial lcm [function_2] ||| [function_2] [function_1]	count=14
arg	from triangles ||| triangles	count=1
arg	grid ||| grid skeleton	count=1
function	fraction object to dtype ||| from qq	count=1
function	parameters ||| parameters	count=3
class	distribution ||| continuous distribution	count=1
function	a ring ||| to ring	count=1
module	return the truth ||| functions elementary	count=1
arg	converts the string s ||| s	count=1
arg	of this function ||| argindex	count=30
function	cholesky factorization of a ||| cholesky	count=1
arg	from intqubit ||| qubits	count=1
function	trigamma function is the ||| trigamma	count=1
module	computes a list of ||| polys	count=1
function	[function_1] superset of ||| [function_2] [function_1]	count=2
arg	to find an ||| func	count=1
function	the domain ||| not	count=1
arg	expr around point ||| expr	count=1
function	the series expansion for ||| intcurve series	count=1
function	to ||| to	count=48
function	the inverse of ||| inverse	count=2
module	returns ||| combinatorics	count=2
function_arg	[function_1] polynomials ||| [function_1] sub f [arg_2]	count=1
function	lambdify ||| iter lambdify	count=1
arg	of g is the ||| g	count=1
function	creates a new ||| orient new	count=1
class	elements ||| free	count=1
class	a ||| frac field	count=1
arg	of k0 [arg_2] ||| [arg_1] [arg_2]	count=1
module	basis state ||| quantum	count=1
arg	evaluate f a ||| eval f a	count=1
function	top nodes ||| top	count=2
function	optimization opportunities ||| opt cse	count=1
function	linearly dense quartic inputs ||| 2	count=2
function	the class ||| mod	count=1
arg	[arg_1] encryption ||| [arg_1] [arg_2]	count=1
arg	[arg_1] g p ||| [arg_2] [arg_1]	count=3
arg	solves a transcendental ||| eq sym	count=1
class	in ||| series	count=1
class	[class] of the ||| matrix [class]	count=1
arg	[arg_1] rhs ||| [arg_1] [arg_2]	count=1
arg	switch to a ||| f native zero	count=1
function	ll ||| ll	count=1
class	if a group ||| permutation group	count=1
function	the length ||| morphism length	count=1
function	terms to their coefficient ||| as coefficients	count=1
arg	[arg_1] a beta ||| [arg_1] [arg_2]	count=1
function	the next lexicographically ordered ||| next lexicographic	count=1
function	and conditions to ||| to	count=1
arg	col that [arg_2] ||| [arg_2] [arg_1]	count=3
module	of polynomials or ||| polys	count=1
arg	by its ||| m	count=1
arg	evalf 2 if it [arg_1] [arg_2] are comparable else none ||| [arg_1] [arg_2]	count=1
function	list from ||| dict list	count=1
module	returns a ||| polys	count=1
function	[function_1] binary ordered ||| [function_2] [function_1]	count=6
function	mapping ||| create param dict	count=1
arg	small'' matrix m to ||| deg_f	count=1
function	[function_1] repeated ||| [function_2] [function_1]	count=1
function	bound on polynomial ||| bound degree	count=1
function	converts a term ||| to	count=1
function	to y_i in ||| deflate	count=1
function	ex ||| expression domain	count=1
function	[function_1] dictionary ||| [function_1] [function_2]	count=5
class	a standard basis in ||| sub module	count=1
module	the three ||| physics	count=2
function	rectangles of non-conjugate ||| complexes	count=1
function	taylor term ||| taylor term	count=2
module	return [module] operator ||| [module]	count=1
arg	if df ||| df	count=1
function	block [function_2] ||| [function_1] [function_2]	count=2
function	of the non-zero ||| row	count=1
function_arg	of x [arg_2] ||| [arg_2] [function_1]	count=1
function	other, where ||| gt	count=1
function	division ||| division	count=2
function	lagrange's ||| lagranges	count=1
function	domain of the functions ||| empty	count=1
function	splitting square-free ||| splitfactor sqf	count=1
arg	order o ||| o	count=1
function_arg	cofactors of [arg_2] ||| [arg_2] [function_1]	count=5
function	in finite_set ||| not	count=1
arg	f in k[x] ||| f m n u	count=1
function	inverse hankel transform of ||| inverse hankel transform	count=1
module	the divergence [module] field ||| physics [module]	count=1
function	derived [function_2] ||| [function_1] [function_2]	count=1
class	basis in ||| sub module poly ring	count=1
function	which comes under this ||| 2eq order2 type11	count=1
function	a scalar return ||| scalar	count=1
arg	[arg_1] r are ||| [arg_1] [arg_2]	count=1
class	lagrange multipliers if necessary ||| lagranges	count=1
function	account the earth rotation ||| type3	count=1
module	> p[i+1] ||| combinatorics	count=1
function	[function_1] circle ||| [function_2] [function_1]	count=2
function	return constant term in ||| get constant term	count=1
function	to a set of ||| to surface	count=1
arg	of the ||| x x0 dir	count=1
function	block ||| block	count=2
function	finds the ||| not	count=1
module	divergence [module] ||| physics [module]	count=1
function_arg	polynomial of [arg_2] ||| [function_1] [arg_2]	count=4
function	the minimal polynomial for ||| minpoly op algebraic	count=1
function	be in integer representation ||| pure symbol int repr	count=1
arg	expansion of ||| x prec	count=5
function	hlt+lookahead method of ||| look ahead	count=1
function	[function_1] representation of ||| [function_2] [function_1]	count=4
function	the forcing vector ||| forcing	count=1
function	interval for ||| interval	count=1
function	[function_1] to y_i ||| [function_2] [function_1]	count=1
function	the vertices ||| vertices	count=2
function_arg	domain [arg_2] ||| [arg_2] [function_1]	count=1
function	form x start stop ||| process limits	count=1
function	returns polynomial lcm ||| lcm	count=1
class	using lu decomposition ||| deprecated	count=1
function	traditional rules of ||| traditional	count=1
function	approximation of the derivative ||| diff	count=1
arg	n in ||| n	count=9
function_arg	[function_1] multiplication ||| [arg_2] [function_1]	count=3
class	returns ||| poly	count=1
function	[function] objects from ||| [function]	count=1
arg	[arg_1] given ||| [arg_1] [arg_2]	count=3
function	the berkowitz algorithm ||| berkowitz	count=1
arg	polynomial expression ||| expression	count=1
class	a ||| free module quotient ring	count=1
function	path to a ||| get mod	count=1
function_arg	evaluate [arg_2] ||| [function_1] ground [arg_2]	count=2
module_class	along the plane ||| geometry plane	count=1
arg	grid adds ||| grid skeleton	count=1
function_arg	manipulate parts [arg_2] ||| [function_1] path [arg_2]	count=4
function	next ||| next	count=5
function_arg	and cofactors [arg_2] ||| [arg_2] [function_1]	count=5
function	a prime ||| modular	count=1
function	(so the list ||| list	count=1
arg	and y ||| y	count=6
arg	this system of ||| x y	count=1
function	evaluate the [function_2] ||| [function_1] [function_2]	count=4
function_arg	[function_1] two ||| [function_1] disjoint [arg_2]	count=3
function	homogeneous [function_1] [function_2] ||| [function_1] 2nd power series [function_2]	count=1
function	be in integer ||| symbol int	count=1
function	sympy matrix/complex [function_2] ||| [function_1] [function_2]	count=3
arg	of symbols with those ||| symbols	count=1
module	available and leverage it ||| printing	count=1
function	symbol in ||| symbol	count=1
arg	of :class arrowstringdescription describing ||| morphisms_str_info	count=1
module	a [module] number true ||| [module]	count=1
class	[class_1] [class_2] at ||| [class_2] [class_1]	count=1
function	[function_1] is ||| [function_2] rational [function_1]	count=3
function	[function_1] gray ||| [function_1] [function_2]	count=4
class	indexed object ||| indexed	count=1
function	compute the ecart ||| sdm ecart	count=1
function	parse and configure the ||| parse	count=1
arg	transformation ||| to_sys	count=2
function	a class into ||| func	count=1
arg	[arg_1] q are ||| [arg_2] [arg_1]	count=7
class	code ||| ufuncify code	count=1
arg	in h as a ||| h	count=1
module	a [module] of coefficients ||| [module]	count=3
function_arg	a sympy matrix ||| sympy m	count=1
module	generated files ||| utilities	count=2
function	the length of a ||| length	count=1
function	rationalize ||| rationalize	count=1
class	converts mutabledensendimarray to ||| dense ndim	count=1
module	the ||| integrals	count=1
function	pseudo-division ||| pdiv	count=2
function	a pivot ||| pivot	count=1
function	degree [function_2] ||| [function_2] [function_1]	count=4
arg	p [arg] i e ||| [arg]	count=1
arg	backend function ||| t s_ simplify	count=1
function	the components of the ||| components	count=1
arg	x ||| func	count=1
module	an interpolating [module] for ||| [module]	count=1
arg	f in ||| f m	count=1
class	return ||| permutation	count=2
class	returns a standard ||| poly	count=1
module_class	the intersection of [module_1] [class_2] and another geometrical entity ||| [module_1] [class_2]	count=1
arg	variable with ||| name k theta	count=1
module	parameters ||| functions special	count=5
function	a useful signature ||| signature	count=1
function	used to set ||| set	count=2
arg	[arg_1] j k ||| physics epsilon [arg_1] [arg_2]	count=1
arg	dmp out of ||| kill	count=1
function	multivariate value nested l-levels ||| dmp nest	count=1
function	[function_1] iterator ||| [function_1] [function_2]	count=2
function_arg	the triangle tri ||| weld triangle tri	count=1
function	the vsids heuristic ||| vsids	count=1
arg	[x]/ g using ||| n g	count=1
function	the direct [function] several ||| direct [function]	count=1
function	matrix is [function_2] ||| [function_1] [function_2]	count=1
function	[function] cholesky ||| row [function] symbolic	count=1
function	[function_1] [function_2] ||| [function_2] sin [function_1]	count=3
function	input ||| sylvester	count=1
function	unique [function] of ||| multiset [function]	count=1
arg	bits to the right ||| bits str	count=1
arg	q [arg_2] ||| [arg_2] [arg_1]	count=5
class	where p[i] < ||| permutation	count=1
arg	could be ||| fringe	count=1
function	integer ||| integer	count=7
class	of the table ||| table	count=1
function	and the name of ||| get mod func	count=1
class	take on a specific ||| series	count=1
function	sympy [function_2] ||| [function_2] [function_1]	count=1
arg	of d with key ||| d key	count=1
function	and leverage it if ||| try use	count=1
function	scan routine ||| scan	count=3
function	create ||| create	count=2
arg	limits should ||| limits	count=1
module	polynomials or ||| polys	count=1
arg	n ||| n k	count=3
function	was [function_2] ||| [function_2] [function_1]	count=1
arg	[arg] modulo ||| [arg]	count=1
function	entire free module ||| full module	count=4
function	system for ||| system	count=1
function_arg	[function_1] x_j = ||| [arg_2] [function_1]	count=1
class	the real ||| real	count=1
module_class	[module_1] wave ||| [module_1] [class_2]	count=15
function	list of polynomials ||| list	count=1
class	a standard ||| sub	count=1
class	outside the ||| properties	count=1
function	outer indices [function_2] ||| [function_1] [function_2]	count=2
function	always create [function_2] ||| [function_1] [function_2]	count=2
function	[function_1] algebraic ||| [function_2] [function_1]	count=1
module	[module] unique ||| [module]	count=3
function	should be roots ||| roots	count=1
arg	a and b ||| a b	count=47
function	by recurrence ||| recurrence	count=2
function	a monomial order on ||| order	count=1
function	[function_1] partition summing ||| [function_1] [function_2]	count=4
function	binary coding to gray ||| to gray	count=1
arg	a vector of constants ||| matlist variable constant k	count=3
function	[function_1] z distribution ||| [function_1] [function_2]	count=1
class	polar numbers is flaky ||| polar lift	count=1
function	of ||| dict	count=1
function	components and ||| components and	count=1
module	the sympy ||| physics	count=2
function	the supplied [function] ||| [function]	count=3
function_arg	independence between [arg_2] ||| [arg_2] [function_1]	count=4
function	is ||| not empty	count=1
function	to replace [function_2] ||| [function_2] [function_1]	count=4
function	sign ||| as sign	count=1
function_arg	[function_1] of rv ||| [arg_2] [function_1]	count=2
function_arg	in gf [arg_2] ||| [function_1] edf zassenhaus f [arg_2]	count=3
module	does the index ||| physics	count=1
arg	a polynomial f in ||| f minpoly p	count=1
arg	k0 [arg_2] ||| [arg_1] [arg_2]	count=2
function	normal [function_2] ||| [function_1] [function_2]	count=5
function_arg	[function_1] p [x] ||| [function_1] exquo f [arg_2]	count=2
function	root ||| root	count=13
function	finds the ||| not empty	count=1
module_class	step of real ||| polys real	count=1
function	accuracy [function] ||| [function]	count=1
arg	in phrase [arg_2] ||| [arg_2] [arg_1]	count=2
arg	if a ||| a	count=14
function	focal distance of ||| focus distance	count=1
arg	mobius transform or ||| m k eps	count=1
function	groebner basis is ||| is	count=1
function	equations in ||| implicit	count=1
function_arg	[function_1] [arg_2] ||| [function_1] tail f [arg_2]	count=3
function	[function_1] terms from ||| [function_2] [function_1]	count=1
arg	f and g ||| f g	count=60
function	phrase and if symbols ||| and join	count=1
function	initialize [function_2] ||| [function_2] [function_1]	count=3
module_class	'self' [class_2] ||| [module_1] [class_2]	count=2
function	return the index of ||| index	count=1
function	extra strong [function_2] ||| [function_2] [function_1]	count=3
function	g = [function] a1 , ||| split [function]	count=1
function	the class ||| get mod func	count=1
arg	a in ||| m a	count=1
arg	x tells whether ||| x	count=1
arg	in [arg_2] ||| [arg_2] [arg_1]	count=50
module	that converts ||| solvers	count=1
module	meth ~sympy solvers ||| solvers	count=1
function	[function_1] ratio of ||| [function_1] [function_2]	count=2
arg	if a [arg_2] ||| [arg_1] [arg_2]	count=3
function	[function] of the ||| group [function]	count=3
function	square-free [function_2] ||| [function_2] [function_1]	count=22
arg	a given scipy ||| circuit nqubits identity_only eps	count=1
function_arg	function [arg_2] ||| [function_1] [arg_2]	count=3
class	generate ||| module	count=2
function	explicit ||| explicit	count=3
function	try to recognise ||| try	count=1
function	whole ring ||| whole ring	count=2
function	[function_1] dict ||| [function_1] [function_2]	count=10
class	submodule ||| quotient module	count=1
arg	the given position ||| name position	count=1
arg	element ||| element base	count=1
function	returns the strided scheme ||| strides	count=1
class	generated ||| octave	count=1
class	integer ||| integer	count=2
arg	function for functions ||| expression	count=1
function	[function_1] partitions ||| [function_2] [function_1]	count=3
arg	ex ||| ex x	count=1
function	translate substrings ||| translate str	count=1
class	return the truth value ||| piecewise	count=1
function	above ||| above	count=1
function	needs ||| needs	count=4
function	[function_1] [function_2] ||| [function_1] [function_2] eq func	count=6
function	[function_1] a k ||| [function_1] [function_2]	count=3
function	square-free factorization given ||| splitfactor sqf	count=1
arg	n data ||| n x x	count=1
function	[function] transformation x ||| [function] rational	count=1
function	are free ||| free	count=1
function	transversals ||| transversals	count=1
function	instance to [function_2] ||| [function_1] [function_2]	count=2
function	[function_1] representation ||| [function_2] [function_1]	count=7
function_arg	if key is [function_1] [arg_2] to ||| [function_1] [arg_2]	count=3
function_arg	lcm of a ||| lcm a	count=4
arg	in args ||| args	count=1
function	ternary diophantine ||| ternary	count=1
function	generating function for a ||| generating function	count=1
function	have initial [function_2] ||| [function_1] [function_2]	count=1
arg	in x_0 of ||| u k	count=1
arg	[arg_1] z at ||| [arg_1] [arg_2]	count=4
module	triangular matrix ||| matrices	count=1
module	lie algebra has a ||| liealgebras	count=3
class	checks if the differential ||| differential	count=1
arg	transformation q**n * f(p/q) ||| f p q	count=1
class	return ||| root of	count=2
function	returns the norm of ||| norm	count=1
function	a common ||| process common	count=1
function	a simplified set ||| simplified pairs	count=2
function	a zero matrix to ||| matrix to	count=1
module	for a ||| vector	count=1
function	index of the inverse ||| index	count=1
class	creates a new referenceframe ||| reference	count=1
function_arg	the scaler-row [arg_2] ||| [function_1] row [arg_2]	count=1
arg	its subgroup [arg] using ||| [arg]	count=1
arg	to return the expression ||| expr	count=1
function	equation of the ||| equation	count=1
arg	at x_j = ||| a	count=1
function	a 2d n-link pendulum ||| link pendulum	count=1
arg	base scalars ||| coord_sys	count=2
function	[function_1] code ||| printing [function_1] [function_2]	count=4
function	[function_1] extended gcd ||| [function_1] [function_2]	count=1
function_arg	multiply f ||| mul ground f	count=1
function	is odd ||| is odd	count=2
arg	pt -- ||| pt	count=1
module	gate identities from the ||| physics	count=1
class	writes a ||| octave	count=1
arg	[arg_1] im ||| [arg_1] [arg_2]	count=1
class	along ||| matrix shaping	count=4
arg	expansion of the ||| n x prec	count=1
arg	certain coordinate system ||| point1 point2	count=1
function	norm of ||| norm	count=9
arg	two univariate polynomials over ||| g p	count=1
function	roots up to ||| roots	count=1
class	basic args like tuple ||| basic	count=1
class	of the real ||| real	count=1
arg	[arg_1] are ||| [arg_2] [arg_1]	count=5
function	[function] polynomials ||| modified subresultants [function]	count=1
function	a string path to ||| mod func	count=1
arg	given domain for ||| symbol domain	count=2
class	from [class] inject them ||| [class]	count=1
function	z i ||| eval commutator zgate	count=1
function	the reduced groebner basis ||| groebner	count=1
function	of ||| not empty in	count=1
module	integer -- return ||| core	count=1
function	and ||| check and	count=1
function	annihilate particle [function_2] ||| [function_2] [function_1]	count=4
class	the ring ||| poly ring	count=1
function	of the asin ||| rs asin	count=1
function	of coincidence routine ||| coincidence	count=1
function_arg	[function_1] the grid ||| [function_1] triangles fringe [arg_2]	count=2
module	frame is the ||| physics	count=1
function	the content and primitive ||| as content primitive	count=1
arg	in col that ||| col	count=1
arg	property prop ||| prop base strong_gens	count=1
function	returns the smallest primitive ||| primitive	count=1
function	gets the subset defined ||| get subset from	count=1
arg	n ||| n verbose	count=1
function	a finite ||| finite rv	count=1
function	the potential ||| potential	count=2
function_arg	square-free part [arg_2] ||| [arg_2] [function_1]	count=5
module	the default ||| physics quantum	count=1
arg	of f ||| f order	count=2
arg	two points or ||| other	count=1
function	returns the domain ||| domain	count=1
function	any evalf ||| eval evalf	count=1
class	code block with ||| code block	count=2
arg	of a unit in ||| unit	count=1
class	root to the ||| root of	count=1
function	[function] m ||| [function]	count=2
function_arg	[function_1] using ||| [arg_2] [function_1]	count=3
module	the simplified ||| physics	count=1
function	orientation orients the new ||| init	count=1
function	functions ||| not empty	count=1
module_class	[module_1] [class_2] ||| [module_1] color [class_2]	count=1
class	composite ||| composite	count=2
arg	find optimization opportunities ||| exprs	count=1
function	m where \gcd ||| cornacchia	count=1
function_arg	set the [arg_2] ||| [function_1] f [arg_2]	count=2
function	bound ||| bound degree	count=2
function	of the form x ||| limits	count=1
class	dtype ||| ring base	count=4
class	along self's ||| matrix shaping	count=2
function	returns the closing ||| routine ending	count=1
class	for ||| base	count=3
function	tree ||| tree	count=1
function	echelon form ||| rref	count=1
arg	if it already is ||| f symbol	count=1
class	grid laid out according ||| diagram grid	count=1
arg	to ||| k1 a	count=4
function	product ||| product	count=4
function	[function_1] a submodule ||| [function_2] [function_1]	count=1
arg	side with length l ||| l d2	count=1
function_arg	[function_1] [arg_2] ||| [function_1] cls [arg_2]	count=1
class	or containers ||| poly ring	count=1
function	fraction decomposition ||| decomposition	count=1
function	the functions ||| not	count=1
function	truth value of the ||| cond	count=1
function	of a root ||| root	count=2
arg	p1 with p2 ||| p2	count=1
function	[function_1] if ||| [function_2] q [function_1]	count=1
function	angular velocity ||| angular velocity	count=2
function	create a property where ||| memoize property	count=1
class	distribution ||| discrete distribution	count=1
arg	key i ||| i key seed	count=1
arg	[arg_1] and format ||| [arg_2] [arg_1]	count=1
arg	the given scalar field ||| scalar_field	count=1
function	gets the subset ||| get subset	count=1
function	[function] corresponding ||| [function]	count=1
function	sets to ||| sets	count=1
function_arg	other, [arg_2] ||| [arg_2] [function_1]	count=2
function	[function_1] line plot ||| plotting plot3d [function_1] [function_2]	count=1
arg	a polynomial in k[x] ||| f u k	count=5
arg	msg to the ||| msg	count=1
module	can get ||| combinatorics	count=1
function	returns polynomial gcd ||| gcd	count=1
function_arg	[function_1] function for ||| [function_1] [arg_2]	count=1
function_arg	index [arg_2] ||| [function_1] [arg_2]	count=3
function	the degree [function_2] ||| [function_2] [function_1]	count=4
function	the degree of transitivity ||| transitivity degree	count=1
function	[function_1] entity parallel ||| [function_2] [function_1]	count=1
arg	[arg] piecewise form ||| [arg]	count=3
arg	a certain ||| point1 point2	count=1
function	lazy series ||| series	count=1
function	differential equation ||| eq	count=2
arg	k-tuples of ||| k zeros	count=1
class	module ||| sub module	count=2
function	laplace [function_2] ||| [function_1] [function_2]	count=2
function	method converts ||| to	count=1
function	equations ||| implicit	count=2
arg	of two ||| g k	count=1
function	orbits and transversals from ||| orbits transversals from bsgs	count=1
function	constant coefficients ||| constant	count=1
function	the primitive form ||| ground primitive	count=1
arg	field computed ||| vect	count=3
arg	s ||| s	count=12
function	proper superset of 'other' ||| proper superset	count=1
arg	of msg to ||| msg	count=1
class	dtype ||| python rational field	count=2
arg	in rules ||| rules	count=1
arg	polynomial p [arg_2] ||| [arg_2] [arg_1]	count=2
function	the constant ||| constant	count=1
function_arg	direct product [arg_2] ||| [function_1] [arg_2]	count=3
arg	re [arg_2] ||| [arg_1] [arg_2]	count=1
arg	infinity g1*g2 ||| g1 g2 x	count=1
function	set of numerator ||| an	count=1
function_arg	denominator of [arg_2] ||| [function_1] [arg_2]	count=3
module	quantum ||| physics quantum	count=1
function	[function_1] moment curve ||| [function_1] [function_2]	count=4
module	in the referenceframe ||| physics	count=1
arg	monic square-free polynomial f ||| f n	count=1
function	a complex ||| complex	count=1
class	linearize ||| kanes method	count=1
function_arg	[function_1] [arg_2] is omitted ||| [function_1] cls r [arg_2]	count=6
arg	given number ||| s	count=1
function	coefficients of ||| dmp ground content	count=1
function	-> a/b -> ||| numer denom	count=1
arg	[arg_1] on ||| [arg_2] [arg_1]	count=4
function	the name of ||| mod func	count=1
arg	and gens2 ||| gens2 signed	count=1
arg	given scipy ||| circuit nqubits identity_only eps	count=1
function	print output ||| print	count=1
function	[function_1] table ||| [function_1] [function_2]	count=3
module	[module_1] [module_2] ||| [module_2] [module_1]	count=76
function	mpmath's mpf to dtype ||| from real field	count=1
arg	pt ||| pt	count=1
class	standard basis ||| poly	count=1
module	wrapper for vector ||| vector	count=1
arg	splits the string ||| callback	count=1
function	quotient by ||| quo	count=2
function	the symbols ||| constant symbols	count=1
class	take ||| series	count=1
function	width of ||| width	count=1
arg	details ||| x re	count=1
function_arg	[function_1] p [x] ||| [function_1] quo f g [arg_2]	count=2
module	f corresponding to the ||| physics	count=1
class	the truth ||| piecewise	count=1
arg	lex ||| v order	count=1
class	symbolic ||| llvmjit code	count=2
function	the semi-latus [function_2] ||| [function_2] [function_1]	count=1
function	module and the ||| get mod	count=1
function	[function_1] iterable ||| [function_2] [function_1]	count=1
function	unify generators in ||| unify gens	count=2
function_arg	[function_1] of a ||| [function_1] [arg_2]	count=39
function	the existing structure on ||| grow pseudopod	count=1
function	the coset table self ||| coset table	count=1
class	a ||| code printer	count=2
function	the bending ||| bending	count=1
function	returns angular ||| angular	count=1
function_arg	to addends [arg_2] ||| [function_1] [arg_2] key1	count=2
function	translate [function_2] ||| [function_1] [function_2]	count=1
function	the unknown function ||| function	count=1
arg	in \mathbb{z}_p[x] ||| fp gp p	count=1
class	from ||| free group element	count=1
function	list of free indices ||| free indices	count=2
function	finite difference approximation ||| finite	count=1
arg	for constructing the ||| j grid morphisms_str_info	count=1
function_arg	[function_1] polynomial ||| [function_1] f [arg_2]	count=1
function_arg	norm of f ||| norm f	count=8
arg	a model or not ||| expr model	count=1
module_class	[module_1] basic args ||| [module_1] [class_2]	count=6
function	a free [function_2] ||| [function_2] [function_1]	count=2
arg	the [arg] ||| [arg]	count=1
arg	[arg_1] k of ||| [arg_1] [arg_2]	count=1
class	add ||| root system	count=1
function	[function_1] imaginary part ||| [function_2] [function_1]	count=2
module	the truth ||| functions	count=1
function	and leverage it if ||| pretty try	count=1
class	polynomials in the given ||| expr	count=1
function	vsids ||| vsids	count=1
function	order of classes ||| class key	count=1
module	a matrix containing the ||| physics mechanics	count=1
class	the ordering of associative ||| free group element	count=1
function	is commutative ||| is commutative	count=2
arg	for n data ||| n x x y	count=1
class	of ||| sparse matrix	count=2
arg	for :func _factor ||| opt method	count=1
module_class	[module_1] system into ||| [module_1] units dimension [class_2]	count=1
function	selfridge ||| lucas selfridge	count=1
arg	multiply self by state ||| state	count=1
arg	s + ||| s	count=1
arg	given combinatorial term [arg_1] [arg_2] ||| hypersimp [arg_1] [arg_2]	count=1
function	the previous [function_2] ||| [function_2] [function_1]	count=2
arg	the function f applied ||| f args	count=1
function	the berkowitz algorithm to ||| berkowitz	count=1
function	[function_1] if so ||| [function_2] q [function_1]	count=1
function	use lu the ||| det lu	count=2
function	logarithm ||| rs log	count=1
function_arg	ben-or's [arg_2] ||| [arg_2] [function_1]	count=5
function	conjugate ||| conjugate	count=2
function	see if ||| try	count=1
function	product of tensors ||| mul	count=1
function	leverage it ||| try use	count=1
function	matrix corresponding ||| matrix	count=1
module	the simplified list of ||| physics	count=1
function	intended or ||| vv	count=1
class	the root ||| complex root of	count=1
module	the particle the ||| physics	count=1
class	a standard ||| ring	count=1
class	symmetric/alternating group ||| group	count=1
arg	a ||| x a	count=1
function	best solution to an ||| coeff best	count=1
function	function ||| function base	count=1
function	homogeneous coefficients [function_2] ||| [function_1] [function_2]	count=2
arg	expression expressions ||| expr	count=1
function_arg	[function_1] function which ||| [function_1] [arg_2]	count=2
function	graph ||| graph	count=1
class	apply ||| create fermion	count=1
function	the union ||| union	count=2
function	postprocess an expression after ||| postprocess for	count=1
function	mul object ||| mul	count=1
function_arg	[function_1] [arg_2] (default is '|') and ||| [function_1] [arg_2] mapping	count=3
function	square the ||| square	count=1
function	plan consisting of shift ||| plan	count=1
arg	expression to a polynomial ||| expr	count=1
function	to ||| from	count=5
function	laguerre ||| laguerre	count=2
arg	self [arg] are ||| [arg]	count=1
arg	a model or ||| model	count=1
function	gamma matrix line inside ||| line	count=1
class	of the fortran ||| fcode gen	count=2
function	the matrix corresponding ||| matrix	count=1
function	extract common content from ||| ground extract	count=1
arg	package name and identifier ||| identifier	count=1
arg	[arg_1] an expression ||| [arg_2] func args [arg_1]	count=1
class	[class] root ||| [class] root	count=2
function	the ||| statement	count=1
arg	x_j of a polynomial ||| j	count=1
function	fraction ||| fraction	count=4
arg	by the user ||| weylelt	count=1
module	of [module] examples ||| [module]	count=1
function	direct [function] several groups ||| direct [function]	count=1
function	edge the ||| edge	count=1
function_arg	d^2 = n ||| four squares n	count=2
function	x^2 - dy^2 ||| dn	count=1
arg	and g which ||| g exps x	count=1
module	with [module] ||| [module]	count=1
function	a field associated with ||| get field	count=1
function	the previous ||| prev	count=2
function	[function_1] heuristic ||| [function_1] [function_2]	count=2
function	if a solution ||| is	count=1
class	[class] general square ||| matrix [class]	count=1
arg	and ||| grid	count=2
function	precedence matrix this ||| get precedence matrix	count=1
class	returns the ||| sparse matrix	count=1
function_arg	[function_1] for the ||| plot [function_1] [arg_2]	count=1
function	the content and primitive ||| content primitive	count=1
module_class	[module_1] coset ||| [module_1] [class_2]	count=2
class	polygon convex? a polygon ||| polygon	count=1
arg	an exponential ||| expr	count=1
arg	base argument ||| base	count=1
arg	operator in [arg_2] ||| [arg_2] [arg_1]	count=1
function	use pollard's rho ||| pollard rho	count=1
arg	to make poly compatible ||| poly	count=1
arg	register ||| from_coords to_exprs inverse	count=1
arg	[arg] (if key1=true) ||| [arg] do key2	count=2
module	characters ||| crypto	count=1
arg	variable with a ||| name k	count=4
arg	[arg_1] if modulus ||| [arg_2] [arg_1]	count=3
module	it if possible ||| printing	count=1
function	the best solution ||| best	count=1
function	the leading coefficient ||| gf lc	count=1
function	the euclidean ||| euclidean	count=1
arg	j see _tensormanager ||| j	count=1
function	new ||| new	count=6
function	finite_set in ||| not empty in	count=1
arg	condition on that ||| condition	count=1
function	build [function_2] ||| [function_1] [function_2]	count=2
module	rearrange the ||| physics	count=1
function	the symbols that will ||| free symbols	count=1
rep	the schreier [function_arg_2] ||| [module_class_1] [function_arg_2]	count=1
function	1st ||| 1st	count=3
class	of self domain ||| ring	count=1
class	input of the ||| region	count=1
module	finite random ||| stats	count=1
class	the ||| series	count=2
function	apply the list of ||| apply	count=1
class	update the kb with ||| kb	count=1
function	the magnitude of ||| magnitude	count=1
module_class	a [module_1] [class_2] ||| [module_1] [class_2]	count=2
module	*-2 [module] 1 + ||| [module]	count=1
function	returns the commutator ||| commutator	count=1
class	xy-pic representation of ||| xypic diagram drawer	count=1
function_arg	norm of [arg_2] ||| [function_1] [arg_2]	count=16
arg	an item in col ||| col	count=1
function	[function] false otherwise ||| needs [function]	count=7
arg	list of the digits [arg_1] [arg_2] ||| ntheory digits [arg_1] [arg_2]	count=4
arg	is used ||| l	count=1
function_arg	[function_1] [arg_2] ||| [function_1] numerically [arg_2]	count=14
function	recursive helper function ||| rec	count=1
function	cyclic ||| cyclic	count=1
arg	and a in ||| a	count=4
function	core ||| core	count=1
function	eye and ||| eye	count=1
arg	two ||| g p	count=1
arg	field in ||| field coord_sys	count=1
function	real roots with ||| real roots	count=1
function	dummy having ||| dummy	count=1
function	for finding powers ||| af pow	count=1
function	the class used ||| class	count=1
function	hash [function_2] ||| [function_1] [function_2]	count=1
function	parametric [function_2] ||| plotting plot3d [function_1] [function_2]	count=4
function	value of the ||| eval	count=1
function	has a constant ||| has constant	count=3
arg	[arg] for ||| i j [arg]	count=3
class	this lambda ||| lambda	count=1
function	start ||| limits	count=1
function_arg	polynomial lcm [arg_2] ||| [function_1] [arg_2]	count=4
function	finite difference ||| apply finite	count=1
function	devise a [function_2] ||| [function_2] [function_1]	count=3
function	mignotte bound for univariate ||| zz mignotte bound	count=1
module	values ||| printing	count=1
class	bounding rectangles of ||| root of	count=1
function	list ||| split list	count=2
arg	in adds muls pows ||| verbose	count=1
module_class	this [class_2] ||| [class_2] [module_1]	count=7
function	derivative of the ||| derivative	count=1
arg	and target_matrix ||| target_matrix nqubits	count=1
module	in pretty ||| pretty	count=1
arg	compute ||| f k	count=2
function	[function_1] degree of ||| [function_1] [function_2]	count=3
function	the form of sign ||| as sign	count=1
function	of a differential ||| ode	count=1
arg	in \mathbb{z}_p and a ||| evalpoints hpeval ring i	count=1
arg	are in z[x] or ||| x method	count=1
function_arg	l1 norm [arg_2] ||| [arg_2] [function_1]	count=3
arg	terms using ||| terms	count=1
arg	variable with ||| name lamda	count=1
function	return the det ||| det	count=1
function	[function_1] all tests ||| [function_2] [function_1]	count=1
arg	p g p k ||| g b p	count=1
function	[function_1] lucas ||| [function_2] [function_1]	count=2
class	returns a standard ||| sub	count=1
class	create ||| set	count=1
arg	components data ndarray according ||| data	count=1
class	that ||| root	count=1
arg	a in k[x] ||| f m a	count=1
class	[class_1] system ||| [class_1] [class_2]	count=1
arg	by differentiating under ||| sym	count=1
module	available ||| pretty	count=1
function	power series expansion of ||| series	count=1
arg	using ||| f k eps inf	count=1
arg	column ||| column	count=1
function	the proper ||| get statement	count=1
function	as input two ||| as	count=1
arg	[arg_1] p q ||| [arg_1] [arg_2]	count=2
function	condition ||| condition	count=1
arg	k0 to k1 ||| k0 k1	count=1
function	a quasi-particle? create ||| q creator	count=2
function	a gate identity ||| random identity	count=1
arg	axis ||| axis angle	count=1
function	module and the name ||| mod func	count=1
arg	eq [arg_2] ||| [arg_2] [arg_1]	count=1
class	dimension ||| type g	count=1
function	generate linear constraints on ||| linear constraints	count=1
function_arg	initialize from [arg_2] ||| [arg_2] [function_1]	count=2
function	class into a string ||| get mod func	count=1
function	[function_1] factors of ||| [function_1] [function_2]	count=3
module	of the ||| geometry	count=1
class	relational ||| relational	count=1
function	passed ||| to state	count=1
function	into a ||| get	count=1
arg	for f p ||| f p	count=2
function	identity is a permutation ||| is	count=1
arg	polynomial in ||| f p	count=1
module_class	string [class_2] ||| [module_1] string [class_2]	count=1
function	is decreasing ||| is decreasing	count=2
module_class	returns a [class_2] ||| [module_1] [class_2]	count=2
function	the lie group method ||| lie group	count=1
function	recursive helper ||| rec degree in	count=1
function	anp object to dtype ||| from algebraic field	count=2
function	identity ||| identity	count=5
arg	[arg_1] in c ||| [arg_2] [arg_1]	count=3
function	[function_1] method to ||| [function_2] [function_1]	count=1
function_arg	[function_1] tri ||| [arg_2] [function_1]	count=2
arg	root v ||| x v	count=1
function	ode ||| order1 type3	count=1
function_arg	[function_1] [arg_2] ||| [function_1] of squares [arg_2]	count=2
function	to x_i**k_i ||| dmp inflate	count=1
function	[function_1] number to ||| [function_1] [function_2]	count=3
class	containing ||| operations	count=1
function_arg	real roots [arg_2] ||| [arg_2] [function_1]	count=11
function	unit [function_2] ||| [function_2] [function_1]	count=1
class	partition is ||| integer partition	count=1
arg	binding power ||| baseline binding	count=1
function	expr is [function] ||| is [function]	count=1
function	the functions in finite_set ||| empty in	count=1
function	the content ||| content	count=1
arg	required for constructing ||| i j grid morphisms_str_info	count=1
function	series expansion ||| rs	count=1
function	polynomial quotient [function_2] ||| [function_2] [function_1]	count=2
function	dictionary [function_2] ||| [function_2] [function_1]	count=1
class	power ||| power	count=1
arg	\langle [arg_1] [arg_2] ||| clebsch gordan [arg_1] [arg_2]	count=4
class	set partition ||| partition	count=1
function	path to a class ||| mod	count=1
arg	occupations is a list ||| occupations	count=1
function	convert [function_2] ||| [function_2] [function_1]	count=5
function	if they are square ||| squares	count=1
arg	symbols -> objects ||| objects	count=1
function	files default from ||| files	count=1
arg	g ||| g a	count=1
function	[function_1] transform ||| [function_1] [function_2]	count=12
function	a 3d [function] ||| plot3d [function]	count=4
class	[class_1] entity which ||| [class_2] [class_1]	count=3
function	is that dummies can ||| dummies	count=1
function	exponentiation ||| exp	count=1
arg	a ||| f m a	count=1
module	a quantum expression ||| physics quantum	count=1
function	the taylor term ||| taylor term	count=2
class	rectangles of ||| complex root	count=1
arg	this system of ||| x y z	count=1
function_arg	[function_1] [arg_2] ||| [function_1] gcdex f g [arg_2]	count=4
function_arg	index of gen ||| index gen	count=2
class	specific value (i ||| base	count=1
function	variable with [function] ||| [function]	count=1
function	the module and ||| mod	count=1
module_class	[module_1] associative word ||| [module_1] [class_2]	count=6
function	to qubit ||| int qubit	count=1
function	traversal ||| traversal	count=1
function	the generator that is ||| generator	count=1
function	form of singularity functions ||| eval rewrite as singularity function	count=1
function_arg	gf [arg_2] ||| [function_1] pow mod [arg_2]	count=1
arg	multiplicative separation ||| fun sep strategy	count=1
function_arg	[function_1] [arg_2] share at least ||| [function_1] [arg_2]	count=4
function	is available and leverage ||| pretty try use	count=1
function_arg	return a transversal of [function_1] [arg_2] the second method described ||| [function_1] transversal [arg_2]	count=2
function_arg	[function_1] where f ||| [arg_2] [function_1]	count=16
function	reduced groebner basis for ||| groebner	count=1
class	a standard basis ||| module	count=1
function	return ||| eval	count=1
arg	)/lm p2 ||| p2	count=1
function	that no bounding ||| complexes	count=1
function	format an error ||| var count error	count=1
function	classes ||| class key	count=2
class	grid laid ||| grid	count=1
arg	the partial ||| hint	count=1
function	symbols that will exist ||| symbols	count=1
class	run ||| test runner	count=1
class	to a group ||| group	count=1
function	to ||| convert to	count=2
arg	of two polynomials ||| g k	count=1
function	semicircle ||| semicircle	count=1
arg	the mapping in rules ||| rules x prec	count=1
function_arg	operators [arg_2] ||| [function_1] [arg_2]	count=5
arg	levels in f ||| f k	count=2
function	tuple ||| as	count=4
arg	optimized _strip with h ||| h	count=1
function	representation of a loop ||| loop	count=1
arg	write an expression with ||| expr	count=1
function_arg	minimal polynomial [arg_2] ||| [arg_2] [function_1]	count=3
function_arg	floor [arg_2] ||| [function_1] [arg_2]	count=2
module	for the initialization ||| physics	count=1
function	this method converts a ||| to	count=1
class	is ||| delta	count=1
function	return [function] corresponding to ||| [function]	count=1
module	given number of ||| utilities	count=1
arg	transversals and result ||| transversals	count=1
arg	[arg_1] op for ||| [arg_2] [arg_1]	count=3
module	available and leverage ||| printing pretty	count=1
class	submodule ||| free module poly ring	count=1
class	is ||| sub module	count=2
class	[class_1] morphism ||| [class_1] [class_2]	count=2
arg	to other ||| other	count=1
function	strictly [function_2] ||| [function_1] [function_2]	count=6
arg	f [arg] ||| f [arg] a	count=3
function	a ||| statement	count=1
function	a set of basis ||| basis	count=1
function	helper function of dsolve ||| helper simplify	count=1
function	hermite reduction - ||| hermite reduce	count=1
function	ben-or's ||| p ben or	count=1
arg	and s2 ||| s2	count=1
function	find the lowest index ||| find	count=1
function	unicode output ||| try use unicode	count=1
arg	fpgroup h ||| fp_grp h	count=1
function	of the linearizer ||| linearizer	count=1
function	the ||| empty	count=3
arg	fringe ||| fringe	count=1
arg	return the series expansion ||| x prec	count=4
class	list of ||| field	count=1
function	[function_1] term ||| [function_2] [function_1]	count=9
arg	p [x] ||| p k method	count=2
function	of tensor product ||| tensor product	count=4
arg	of f ||| f m n k	count=1
arg	q divides ||| q	count=1
function	[function_1] surface ||| [function_2] [function_1]	count=1
class	[class_1] an element ||| [class_2] [class_1]	count=2
function	hensel lifting ||| hensel	count=2
class	return a ||| field	count=1
arg	to ||| a	count=1
class	index pos 0 , ||| index	count=1
arg	is a model or ||| expr model	count=1
function	values to ||| dict	count=1
function	the variables with ||| variables	count=1
function_arg	generates [function_1] [arg_2] a permutation group ||| [function_1] [arg_2]	count=1
module	checked [module] for ||| [module]	count=1
function	focal [function_2] ||| [function_1] [function_2]	count=2
function	[function_1] a square-free ||| [function_2] [function_1]	count=5
function_arg	polynomial pseudo-remainder [arg_2] ||| [arg_2] [function_1]	count=2
function	construct polynomials from ||| poly from	count=1
function	inject generators into this ||| inject	count=3
arg	evaluate [arg_1] [arg_2] ||| eval [arg_1] [arg_2]	count=2
function_arg	a list [arg_2] ||| [function_1] [arg_2]	count=4
arg	for an integral curve ||| vector_field param start_point n	count=1
arg	is appropriate for ||| name expr argument_sequence global_vars	count=1
function	return the n-th coefficient ||| nth	count=2
arg	f given [arg_2] ||| [arg_2] [arg_1]	count=2
arg	and dum [arg_2] ||| [arg_2] free [arg_1]	count=1
function	[function_1] order on ||| [function_2] [function_1]	count=1
arg	rsolve_hypergeometric for details ||| f x re g	count=1
function	scalar return larger matrices ||| scalar	count=1
function	[function_1] function ||| [function_2] class [function_1] func_class f symbol	count=1
function	returns the ||| eval	count=1
function	opportunities ||| opt	count=1
function	multivariate polynomials ||| dmp	count=1
arg	p is not ||| p	count=1
function_arg	partition [arg_2] ||| [arg_2] [function_1]	count=1
arg	truth ||| cls	count=1
arg	it [arg] ||| [arg]	count=1
arg	to a second order ||| eq func order match	count=1
class	tests whether a set ||| product set	count=1
function	hilbert [function] of ||| [function]	count=1
function_arg	mod [arg_2] ||| [function_1] iter a [arg_2]	count=2
function	[function_1] scalar multiple ||| [function_2] [function_1]	count=1
arg	converts an expr ||| expr assign_to	count=2
function	[function_1] ending ||| [function_1] [function_2]	count=4
function	orbits [function_2] ||| [function_1] [function_2]	count=2
arg	elements of seq ||| seq	count=1
function	the form of products ||| form	count=1
arg	finite_set ||| finset_intersection	count=1
function	a string ||| func	count=1
function	[function_1] extended gcd ||| [function_2] [function_1]	count=1
arg	two permutation ||| other	count=1
arg	tri ||| tri	count=1
function	m-th order derivative ||| diff	count=4
function	a random integer ||| random integer	count=2
class	quaternion ||| quaternion	count=1
arg	p q are polynomials ||| p q x method	count=2
function	function with name and ||| function base	count=1
function	[function_1] constant term ||| [function_2] [function_1]	count=1
module_class	[module_1] point in ||| [module_1] [class_2]	count=3
module	and pdsolve in the ||| solvers	count=1
module	polyhedra we can ||| combinatorics	count=1
function	electric permittivity ||| permittivity	count=1
function	k[y] ||| dmp trunc	count=1
function	syllables from positions from_to ||| sub syllables	count=1
module	(real=true) with the same ||| geometry	count=1
function	always destroy ||| only q	count=1
class	polynomials or containers ||| ring	count=1
function	ode ||| ode 1st	count=1
function_arg	rewrite [arg_2] ||| [arg_2] [function_1]	count=4
arg	[arg_1] index2 ||| [arg_1] [arg_2]	count=6
module	returns true ||| polys domains	count=4
function	rho ||| rho	count=1
arg	at a in ||| i a	count=1
class	mutabledensendimarray to matrix ||| ndim	count=1
function	sympy's [function] ||| manual [function]	count=1
arg	k0 and [arg_2] ||| [arg_2] [arg_1]	count=1
arg	return product [arg_1] [arg_2] with int 1 so ||| core prod [arg_1] [arg_2]	count=1
function	ideal generated by ||| f5b	count=1
function	helper function for ||| helper	count=1
function	bound for [function_2] ||| [function_2] [function_1]	count=1
function	gmpy ||| gmpy	count=6
arg	x_j of a polynomial ||| f m j	count=1
module	create ||| series	count=1
class	[class_1] [class_2] of a ||| [class_2] [class_1]	count=6
class	that ||| complex root	count=1
function	parse and ||| parse	count=1
function	[function_1] rational number ||| [function_2] [function_1]	count=2
arg	of the terms of ||| x x0 dir logx	count=1
function	and ||| get mod	count=1
arg	the given level ||| level	count=1
arg	expr ||| expr simplified	count=1
function	mignotte ||| zz mignotte	count=1
function	a ||| free	count=1
function	possible ||| pretty try use	count=1
class	qexpr ||| qexpr	count=1
class	array ||| ndim array	count=1
function	with all the ||| all	count=1
function	undetermined coefficients ||| coeff undetermined coefficients	count=2
module_class	[module_1] submodule ||| [class_2] [module_1]	count=2
module	to the ||| physics mechanics	count=1
function	implements the lie group ||| ode lie group	count=1
function	[function_1] dict ||| [function_2] [function_1]	count=11
function	build a monomial ||| build product	count=1
function	from ||| parallel poly from	count=2
module	number of space characters ||| utilities	count=1
function_arg	[function_1] [arg_2] ||| [function_1] irreducible n [arg_2]	count=4
function_arg	[function_1] (i ||| [function_1] diagonal [arg_2]	count=5
function_arg	translate function [arg_2] ||| [arg_2] [function_1]	count=2
function	values above [function_2] ||| [function_1] [function_2]	count=4
class	of the ||| f	count=1
function	get a [function_2] ||| [function_1] [function_2]	count=9
function	a sentinel ||| sentinel	count=1
function	the vertical radius ||| vradius	count=1
function	instance [function_2] ||| [function_2] [function_1]	count=1
module	or containers of polynomials ||| polys	count=1
class	enumerate ||| traverser	count=1
function	latex handling functions ||| function	count=1
function	return whether [function_1] [function_2] given interval ||| [function_1] [function_2] expression interval symbol	count=1
function	tensor product of ||| combined tensor	count=1
class	and d) [class] a, ||| [class]	count=1
function_arg	gf [arg_2] ||| [function_1] eval f a [arg_2]	count=1
module	every [module] unique root ||| [module]	count=2
module	the given symbols ||| core	count=1
arg	where t = ||| t	count=1
arg	of f by ||| f c	count=2
arg	columns if c ||| c	count=1
function	of motion in ||| comb	count=1
function	version of eye and ||| eye	count=1
function_arg	the ideal i ||| ideal i	count=1
arg	[arg_1] at a ||| [arg_2] [arg_1]	count=8
function	in gcd ||| gcd	count=2
function	type of ||| 2eq	count=1
function	a root of ||| root	count=1
function	python fraction object to ||| qq python	count=4
module	return numerator ||| core	count=1
class	point in a given ||| point	count=1
arg	a vector of constants ||| variable constant k	count=3
class	total ||| g	count=1
function	to addends of ||| addends	count=1
function	the non-zero [function_2] ||| [function_2] [function_1]	count=3
function	the intersection ||| intersection	count=3
arg	f [arg_2] ||| [arg_2] s [arg_1]	count=1
function	a string ||| mod	count=1
arg	r [arg] is omitted ||| r [arg]	count=1
module	positions of ||| combinatorics	count=2
function	correct the values ||| correct	count=1
arg	f with [arg_2] ||| [arg_1] [arg_2]	count=4
function	division with remainder over ||| rr div	count=1
function	compute the laplace ||| laplace	count=1
function	decreasing in the ||| decreasing	count=2
function	jacobian ||| jacobian	count=1
function	a polynomial [function_2] ||| [function_1] [function_2]	count=11
function_arg	[function_1] p ||| [function_1] neg [arg_2]	count=4
arg	mapping in rules ||| p rules x	count=1
arg	a diagram and ||| diagram grid	count=2
function	class into a ||| mod	count=1
function	nine-point [function_2] ||| [function_2] [function_1]	count=1
class	a grid ||| grid	count=1
function	heuristic ||| heuristic	count=6
function	to check ||| check	count=1
arg	interval s [arg_2] ||| [arg_1] [arg_2]	count=1
function_arg	matrix to [arg_2] ||| [function_1] [arg_2]	count=2
function	velocity ||| vel	count=3
function	symbol [function] ||| [function]	count=3
function	this heuristic uses ||| lie heuristic function sum	count=1
module	solution to a ||| solvers	count=1
module	random expression i e ||| stats	count=1
function	[function_1] start of ||| [function_2] [function_1]	count=4
function_arg	rotates [arg_2] ||| [function_1] l l [arg_2]	count=1
arg	[arg_1] using ||| [arg_2] [arg_1]	count=8
class	to this [class] ||| [class]	count=1
function	[function_1] division ||| [function_2] [function_1]	count=2
arg	operator ||| op	count=2
function	in integer representation ||| find pure symbol int repr	count=1
function	the leading degree of ||| dmp degree	count=1
arg	the base argument ||| base	count=1
module	setup conjugating the ||| physics	count=1
function	of the class ||| get mod func	count=1
function	the module ||| get	count=1
class	[class] equalities and ||| [class]	count=1
function	event ||| event	count=1
function	method returns the symbols ||| free symbols	count=1
module	the line and return ||| physics quantum	count=1
class	whether ||| basic	count=1
class	with ordered free ||| tens	count=1
module	faces of the polyhedra ||| combinatorics	count=1
arg	is of sufficiently small ||| dx	count=1
function	directional ||| directional	count=1
function	real [function_2] ||| [function_1] [function_2]	count=24
function	random integer partition ||| random integer partition	count=3
function	characters of phrase and ||| and join	count=1
function	this [function_2] ||| [function_2] [function_1]	count=8
arg	p x [arg_2] ||| [arg_2] [arg_1]	count=1
class	latex knows ||| latex printer	count=1
function	[function_1] loop ||| [function_2] [function_1]	count=2
function_arg	[function_1] [arg_2] ||| [function_1] multivariate [arg_2]	count=1
function	a binomial ||| binomial	count=1
arg	base argument can be ||| base	count=1
function	third heuristic ||| heuristic	count=1
function	path to a class ||| get mod	count=1
arg	arrowstringdescription describing the morphisms ||| morphisms morphisms_str_info	count=1
function	dict ||| as dict	count=2
function_arg	[function_1] of qubit ||| [function_1] matrix [arg_2] format	count=1
arg	[arg_1] s t ||| [arg_2] [arg_1]	count=1
arg	polynomial equations ||| f	count=1
function	finite difference approximation of ||| apply finite	count=1
arg	expression ||| expr length	count=1
function	the normalized version of ||| normalized	count=1
function	used to switch to ||| connect to	count=1
function	octave or matlab ||| octave	count=1
arg	dum indices ||| dum	count=1
function_arg	[function_1] [arg_2] ||| [function_1] diagonal [arg_2]	count=5
function	a ||| get mod func	count=2
class	r [class] ||| [class]	count=4
function	create function ||| create function base	count=2
arg	p ||| p prec	count=1
function	it if possible ||| pretty try	count=1
module	be ||| core	count=1
function_arg	denominator [arg_2] ||| [function_1] [arg_2]	count=3
module	the total number of ||| physics	count=1
module	to rearrange the order ||| physics quantum	count=1
arg	default kind ||| d kind	count=1
module	[module] examples ||| [module]	count=1
function	a proper superset of ||| proper superset	count=1
function	particle if so ||| is	count=2
module_class	dimension [class_2] ||| [class_2] [module_1]	count=1
function	the nth [function_2] ||| [function_1] [function_2]	count=2
arg	of symbols with ||| symbols	count=1
function	the variables with ||| subs	count=1
function_arg	[function_1] x examples ||| [arg_2] [function_1]	count=4
function	lower ||| lower	count=2
arg	symbols with those of ||| symbols filter	count=1
class	ground domain ||| dmp	count=4
function	module and the ||| func	count=1
class	format ||| code printer	count=1
class	group ||| group	count=22
arg	for n data points ||| n x x	count=1
arg	a given inequality or ||| symbol domain	count=1
arg	m == ||| m	count=1
function_arg	series for f ||| rs puiseux2 f	count=2
function	q[x] it is assumed ||| sturm amv	count=1
function_arg	module of [arg_2] ||| [function_1] [arg_2]	count=3
function	value ||| cond	count=1
arg	x [arg_2] ||| [arg_1] [arg_2]	count=10
function	the module ||| get mod func	count=1
arg	public key n e ||| key	count=1
module	returns a ||| polys domains	count=9
function	quadrants from a list ||| to quadrants	count=1
class	the integration ||| integral	count=1
arg	constructing the ||| i j grid morphisms_str_info	count=1
function	computing the discrete ||| discrete	count=2
module	it if possible ||| printing pretty	count=1
function	[function_1] homomorphism on ||| [function_2] [function_1]	count=7
function	with denominator at most ||| denominator	count=1
function	the scalar potential ||| scalar potential	count=2
function_arg	rational [arg_2] ||| [arg_2] [function_1]	count=1
function	monomials from a ||| monoms	count=1
arg	over [arg] >>> ||| f [arg]	count=1
class	a finiteset in terms ||| finite set	count=1
function	that no ||| refine complexes	count=1
class	with submodule ||| sub	count=1
function_arg	the bifid [arg_2] ||| [function_1] [arg_2]	count=1
class	location where p[i] < ||| permutation	count=1
arg	this type of ||| x y t	count=3
function	8 references ||| tonelli shanks	count=1
function	with constant coefficients using ||| constant	count=1
arg	construct a ||| opt	count=1
function	an algebraic ||| algebraic	count=2
function_arg	evaluation points [arg_2] ||| [function_1] [arg_2]	count=1
function	is a square-free ||| is sqf	count=3
function	a diagonal morphism ||| diagonal	count=1
function	[function_1] tuple ||| [function_2] [function_1]	count=8
function_arg	[function_1] another ||| [arg_2] [function_1]	count=2
arg	z )[x] using ||| minpoly	count=1
function	factor a ||| factor	count=1
arg	algorithm i e find ||| g	count=1
function	of the ||| cond	count=1
function	the function ||| function	count=2
arg	x and y ||| x y	count=6
class	[class_1] entity ||| [class_1] [class_2]	count=3
module	the initialization ||| physics mechanics	count=1
class	on the ||| op	count=1
module	the equations of ||| physics mechanics	count=4
function	as a ||| as real	count=1
arg	trig over [arg] >>> ||| f [arg]	count=1
class	a groebner basis ||| groebner basis	count=4
function	[function] if ||| is [function]	count=3
class	of the matrix ||| mutable sparse matrix	count=1
function	a common header ||| header	count=2
class	more linear ||| linear	count=1
function	y_i to x_i**k_i ||| inflate	count=1
function	generators of ||| gens	count=1
arg	be of ||| func	count=1
class	root ||| root of	count=5
function	the nine-point circle ||| nine point circle	count=1
arg	length n ||| cls n	count=1
function_arg	number [arg_2] ||| [function_1] [arg_2]	count=1
function_arg	with [arg_2] ||| [arg_2] [function_1]	count=9
function	[function_1] power and ||| solvers has [function_1] [function_2]	count=1
module	add the given ||| utilities	count=1
function	scalar ||| scalar	count=7
class	using lu ||| deprecated	count=1
class	take ||| series base	count=2
function	lmq upper bound ||| upper bound	count=1
function	compute square-free [function_2] ||| [function_1] [function_2]	count=4
function	these [function_2] ||| [function_2] [function_1]	count=4
function	subprocess with ||| in subprocess with	count=2
function_arg	[function_1] controls targets ||| [function_1] [arg_2]	count=4
arg	f if it is ||| f symbol gens	count=1
function	factory ||| factory	count=1
module	formats a ||| printing	count=1
function	using [function_2] ||| [function_1] [function_2]	count=1
class	isolating [class_2] ||| [class_2] [class_1]	count=1
function	the norm ||| norm	count=1
arg	at x_0 = a ||| a u k	count=1
function	number of inversions ||| inversions	count=1
function_arg	c(x_2 x_u)*x_0**i [arg_2] ||| [arg_2] [function_1]	count=2
function_arg	factors [arg_2] ||| [function_1] [arg_2]	count=1
function_arg	[function_1] [arg_2] objects ||| [function_1] matrix [arg_2] format	count=4
function	the a ||| a	count=1
class	pstack if possible ||| multiset partition traverser	count=2
function	returns an immutable version ||| as immutable	count=2
function	lagrangian of a multibody ||| lagrangian	count=1
function	vectormul ||| measure number	count=1
function	particle if ||| is	count=2
function	o ||| o	count=1
function	returns square-free [function_2] ||| [function_1] [function_2]	count=4
module	returns ||| agca	count=1
arg	a ||| x a b	count=1
function_arg	[function_1] i ||| [arg_2] [function_1]	count=17
function_arg	add polynomials ||| add f g	count=1
arg	[arg_1] p ||| div [arg_1] [arg_2]	count=2
class	point ||| point	count=10
module	rule ||| strategies	count=1
function	always destroy a quasi-particle? ||| is only q	count=1
function	returns e^x, the inverse ||| inverse	count=1
function	euclidean polynomial ||| euclidean	count=1
function	axis [function_2] ||| [function_1] [function_2]	count=1
arg	the point other ||| other	count=1
function_arg	[function_1] p [x] ||| [function_1] factor sqf f [arg_2]	count=2
function	the minimal polynomial for ||| minpoly op	count=1
class	with the ||| poly	count=1
module	the total ||| liealgebras	count=1
arg	expr is bounded false ||| expr	count=1
function	checking function monotonicity ||| monotonicity	count=1
module	that can be written ||| simplify	count=1
function	buckets for the fours ||| buckets	count=1
module	of a [module] ||| [module]	count=8
arg	of k0 and ||| k0	count=1
function	of all ||| all	count=1
function	over a ring ||| dmp rr	count=1
function	values below [function_2] ||| [function_2] [function_1]	count=4
function_arg	[function_1] of f ||| [function_1] list include [arg_2]	count=4
arg	p of k[t ||| p	count=1
function_arg	basic element [arg_2] ||| [arg_2] [function_1]	count=3
function	resultant ||| resultant	count=5
arg	an indexed root ||| f x index radicals	count=1
function	common header ||| get header	count=2
arg	compute partial fraction decomposition ||| f x	count=1
function	schreier ||| schreier	count=1
function	those that take on ||| free	count=1
module	factors [module] a ||| [module]	count=1
function_arg	[function_1] k ||| [arg_2] [function_1]	count=3
function	non-zero structure of ||| row structure	count=1
function	create a derivative ||| derivative	count=1
arg	z of ||| z a	count=1
arg	\langle [arg_1] [arg_2] ||| [arg_1] [arg_2]	count=6
function	return generators for ||| gens	count=1
function	returns maximum norm of ||| max norm	count=1
function	mellin transform ||| mellin transform	count=2
class	field ||| vector field	count=2
arg	[arg_1] order ||| [arg_2] [arg_1]	count=2
function	strictly increasing ||| strictly increasing	count=2
function	a copy of ||| copy	count=1
arg	into ||| order	count=1
function_arg	[function_1] polynomial in ||| [arg_2] [function_1]	count=10
function	in terms ||| in terms	count=3
class	root ||| complex root of	count=2
class	:class poly ||| poly	count=1
arg	[arg_1] field computed ||| [arg_2] [arg_1]	count=3
function	see if unicode output ||| unicode	count=1
module	vector for ||| vector	count=1
class	by an element in ||| element	count=1
class	get ||| root of	count=1
function	xor ||| convert xor	count=1
function	tree [function] of ||| tree [function]	count=1
arg	l ||| l	count=4
function_arg	degree of f ||| degree f	count=2
function	compute square-free ||| sqf	count=3
function	gate identity ||| identity	count=1
function	the form of sign ||| sign	count=1
function	motion in ||| comb	count=1
function_arg	primitive form [arg_2] ||| [function_1] [arg_2]	count=4
function	full ||| full	count=1
module_class	ranks the gray ||| combinatorics gray	count=1
arg	dimensions r [arg] is omitted ||| r [arg]	count=1
function	[function_1] multiple of ||| [function_1] [function_2]	count=4
function	the ground ||| dmp ground	count=1
class	this frame ||| frame	count=1
function	[function_1] difference ||| [function_1] [function_2]	count=7
function	be in integer ||| int	count=1
arg	symbols -> objects mapping ||| objects	count=1
module	instance ||| core	count=1
arg	f in k[x], useful ||| f	count=2
arg	fundamental strip given ||| strip	count=1
arg	each [arg] ||| expr [arg]	count=1
function	[function_1] upper-hessenberg form ||| [function_1] [function_2]	count=1
function	numbers to ||| from	count=1
arg	[arg_1] p for ||| [arg_2] [arg_1]	count=3
arg	factors of f ||| f	count=2
function	domain ||| empty	count=1
arg	[arg_1] [arg_2] ||| [arg_1] c [arg_2]	count=2
arg	name [arg_2] ||| matrix [arg_1] [arg_2]	count=1
function	leverage it if ||| use	count=1
module	mapping of symbolic values ||| printing	count=1
module	string ||| printing pretty	count=2
arg	polynomials in k[x] ||| f g u k	count=3
function	is ||| empty in	count=1
arg	are in ||| x	count=1
function	gf p [x] for ||| gf	count=3
function	find the lowest ||| find	count=1
function_arg	denominator [arg_2] ||| [arg_2] [function_1]	count=3
arg	var occurs in ||| var x	count=1
arg	return the residual mod [arg_1] [arg_2] that it is within ||| ntheory symmetric residue [arg_2] [arg_1]	count=1
function	orients the new ||| new	count=1
function	the conjugate of ||| conjugate	count=1
module	s, and ||| utilities	count=1
function	[function_1] a square ||| [function_2] [function_1]	count=1
arg	or ||| expr	count=1
class	for the generated files ||| gen	count=2
arg	c i e e( ||| c condition	count=1
function	differentiate and evaluate a ||| diff eval	count=1
class	elements of the group ||| permutation group	count=1
arg	import lex ||| v order	count=1
function	minimum of ||| imin	count=1
class	n-dim [class_2] ||| [class_1] [class_2]	count=2
function	system for [function_2] ||| [function_2] [function_1]	count=2
function	logic to decide how ||| hprint	count=1
function	is available and leverage ||| try	count=1
function	calculate core ||| core	count=1
arg	representation of a polynomial ||| minpoly	count=1
module	of the ||| matrices	count=1
function	[function_1] indices ||| [function_1] [function_2]	count=12
arg	setup ||| stringify_func use_latex euler	count=1
arg	[arg_1] prec ||| [arg_2] [arg_1]	count=5
arg	a single ||| a	count=2
function	always destroy a quasi-particle? ||| only q	count=1
function	size of the ||| degree	count=1
function	heuristic assumes ||| lie heuristic bivariate	count=1
class	the kb ||| kb	count=2
arg	respect to ||| tol a	count=1
arg	in a ||| f	count=1
arg	[arg_1] q are ||| [arg_1] [arg_2]	count=7
arg	substitution x -> x ||| x	count=1
class	outer product ||| outer product	count=4
function	number of roots of ||| roots	count=3
class	transform in ||| transform	count=1
arg	is not in symbols ||| symbols filter	count=1
function	using the substitution ||| subs	count=1
function	the precedence of a ||| precedence	count=1
arg	unit in ||| unit	count=1
function	[function_1] level of ||| [function_2] [function_1]	count=1
class	new code block with ||| code block	count=1
function	and leverage it if ||| try	count=1
arg	expressions [arg] ||| [arg]	count=2
class	containers of ||| poly ring	count=1
class	standard ||| module poly	count=1
function	the transformation matrix ||| transformation	count=1
class	define this linear ||| linear	count=1
arg	phrase is [arg_2] ||| [arg_1] symbols [arg_2]	count=1
function	bitlist corresponding to a ||| bitlist from	count=1
arg	that \operatorname{re} [arg] ||| expr [arg]	count=2
function	finds ||| not empty	count=1
function	instance to a ||| as	count=1
arg	optimization ||| exprs	count=1
module	the system about the ||| physics	count=1
arg	whether [arg] ||| [arg]	count=4
arg	be of the form ||| func	count=1
arg	other is not ||| other	count=1
function	with respect [function] the given ||| [function]	count=1
function	a_j ||| tail	count=1
class	that are ||| differential extension	count=1
function	primitive [function_2] ||| [function_1] [function_2]	count=6
module_class	[module_1] that ||| [module_1] quantum state [class_2] operators	count=1
function	it if ||| pretty try use	count=1
arg	d is not a ||| d	count=1
function_arg	[function_1] tuple x ||| [function_1] m [arg_2]	count=1
function	f - g*h ||| dmp sub mul	count=2
function	the ||| mod	count=4
function	cos ||| cos	count=2
function	the lmq upper bound ||| upper bound	count=1
function	objects that appear ||| objects	count=1
function_arg	this is a linear [function_1] [arg_2] [3] ||| [function_1] [arg_2]	count=1
arg	orig_vec ||| orig_vec	count=1
arg	for _match_div_rewrite ||| g rexp	count=1
arg	n alpha [arg_2] ||| [arg_2] [arg_1]	count=3
arg	s , defined as ||| s t plane	count=1
function	[function_1] degree ||| [function_1] [function_2]	count=3
function	hypertangent polynomials ||| hypertangent polynomial	count=1
arg	details ||| re g	count=1
function	sparsematrix ||| eval	count=1
function	on a specific value ||| free	count=1
arg	public key ||| key seed	count=1
arg	component ||| component	count=1
arg	= ||| a	count=2
function_arg	hash randomization [arg_2] ||| [function_1] function [arg_2]	count=1
function	gets the subset ||| get subset from	count=1
function	with non-zero diagonal entries ||| diagonal	count=1
function	build a [function_2] ||| [function_1] [function_2]	count=2
module	process on the ||| combinatorics	count=1
function	direction ratio of ||| direction	count=1
arg	matrix by [arg] ||| [arg]	count=1
module	rr ||| physics quantum	count=1
function	contribution of ||| laurent series	count=1
function	to the module and ||| func	count=1
function	r ||| rcode	count=1
function	square-free norm ||| dmp sqf norm	count=2
function	memoized version ||| memoize	count=1
function	session ||| init	count=1
function	[function_1] whole ||| [function_1] [function_2]	count=1
class	where the root ||| complex root of	count=1
function	an argument [function] ||| needs [function]	count=1
module_class	the plane ||| geometry plane	count=5
function	[function_1] hash randomization ||| [function_2] [function_1]	count=5
function	module and ||| func	count=1
module	this ||| matrices	count=1
function	ket on ||| ket	count=1
arg	[arg_1] to ||| [arg_1] z [arg_2]	count=2
module_class	the constructor for [module_1] [class_2] object ||| [module_1] [class_2]	count=1
function	[function_1] components the ||| [function_2] [function_1]	count=1
class	generated files ||| octave code gen	count=1
module_class	[module_1] sought after ||| [module_1] quantum [class_2]	count=3
function_arg	root [arg_2] ||| [function_1] [arg_2]	count=11
arg	provided p is ||| p c	count=1
function	returns the inverse ||| inverse	count=3
arg	to t ||| a d t	count=1
function_arg	gf p [arg_2] ||| [function_1] zassenhaus f [arg_2]	count=1
function	see canonicalize in tensor_can ||| indices canon args	count=1
arg	[arg_1] the given ||| [arg_1] [arg_2]	count=4
function	name of ||| get	count=1
module	standard ||| polys	count=1
module	the generated files ||| utilities	count=2
arg	[arg_1] [x] ||| [arg_2] [arg_1]	count=16
arg	a triangle and an ||| triangle	count=1
function	is a homomorphism ||| hom	count=1
class	generated by a groebner ||| groebner	count=1
function_arg	element [arg_2] ||| [function_1] [arg_2]	count=3
function	there is free ||| check free	count=4
arg	k0 ||| k0	count=2
function_arg	points for [arg_2] ||| [function_1] [arg_2]	count=1
function	for the hypergeometric ||| hyperexpand	count=1
function_arg	rank [arg_2] ||| [function_1] [arg_2]	count=3
function	of the generator ||| generator	count=1
function_arg	[function_1] of expression ||| [function_1] [arg_2]	count=2
arg	[arg_1] x ||| [arg_1] a [arg_2]	count=1
class	isolation [class_2] ||| [class_2] [class_1]	count=2
arg	s as a product ||| s	count=1
function	minimal degree for ||| min	count=1
function	return a matrix ||| matrix	count=1
arg	series expansion of ||| x prec	count=5
function_arg	[function_1] [arg_2] the supplied ||| [function_1] [arg_2] triangle_sizes	count=3
arg	get an element ||| index	count=1
function	settings ||| settings	count=1
module	a ||| printing	count=1
function	[function_1] primary ||| [function_1] [function_2]	count=1
arg	op for the generator ||| op	count=1
function	delta [function_2] ||| [function_1] [function_2]	count=1
function_arg	[function_1] factor ||| [function_1] [arg_2]	count=3
class	cython ||| cython	count=1
class	the generated files ||| fcode	count=1
function	of a univariate ||| root	count=1
arg	[arg_1] given ||| [arg_2] [arg_1]	count=5
function	heuristic uses ||| heuristic function	count=1
class	quaternion ||| quaternion orienter	count=1
function	list of transpositions ||| transpositions	count=1
function_arg	[function_1] differential equation ||| [arg_2] [function_1]	count=3
arg	if all ||| cond	count=1
arg	with public key ||| key	count=1
function	arranged in [function_2] ||| [function_1] [function_2]	count=1
arg	of f ||| f all	count=2
function_arg	[function_1] [arg_2] ||| [function_1] components [arg_2]	count=6
function	an integer ||| integer	count=1
module	return true if ||| core	count=1
function_arg	deltaintegrate f ||| deltaintegrate f	count=1
function	the symbol target ||| target	count=1
function_arg	remainder of f ||| rem f	count=4
function	substitution with [function_2] ||| [function_2] [function_1]	count=8
arg	x_j of [arg_2] ||| [arg_2] [arg_1]	count=1
function	as self ||| as	count=1
function	of square-free factors ||| sqf list include	count=1
arg	[arg] is a ||| [arg]	count=5
function_arg	[function_1] key ||| [function_1] [arg_2]	count=1
module	at [module] specified ||| [module]	count=1
module	path to a class ||| utilities	count=1
function	[function_1] root of ||| [function_1] [function_2]	count=9
module	line ending ||| printing	count=1
function	crt for [function_2] ||| [function_2] [function_1]	count=2
function	the minimal [function_2] ||| [function_2] [function_1]	count=3
function	performs the bifid ||| bifid5	count=1
function	list of native coefficients ||| list	count=1
class	a specific value (i ||| series base	count=1
function	its principal ||| my principal	count=1
function	exponent of the ||| exponent	count=1
arg	compute gf_pow_mod f ||| f	count=1
arg	is a model ||| model deep	count=1
arg	in the sequence ||| seq	count=1
arg	find optimization ||| exprs	count=1
arg	algorithm see [clo] p64 ||| fv	count=1
function	return leading coefficient ||| lc	count=1
arg	for n ||| n	count=5
function	return a dummy ||| dummy	count=1
function	third heuristic assumes the ||| lie heuristic	count=1
function	variation of scan ||| scan	count=1
function	the gauss-lobatto ||| gauss lobatto	count=1
function	wrapper ||| wrapper	count=1
class	step complex ||| complex	count=1
function	the bifid ||| bifid5	count=1
arg	1 2 ; -1 [arg_1] [arg_2] 1 3 2 3 ||| [arg_1] [arg_2]	count=1
function	is well defined ||| is consistent	count=2
arg	the given the universe ||| universe	count=1
function_arg	true if [arg_2] ||| [function_1] similar [arg_2]	count=1
arg	f ||| f c u k	count=2
function	of "e" in "x" ||| calculate	count=1
function	beginning ||| indent	count=1
class	standard basis ||| module poly ring	count=1
arg	expression about c i ||| n c	count=1
class	this fermionicoperator restricted ||| fermionic operator	count=2
function	as a ||| as numer	count=1
function	refine a positive ||| dup inner refine real	count=1
function_arg	if key is in [function_1] [arg_2] ||| categories diagram [function_1] union [arg_2] value	count=3
function	calculates the finite difference ||| apply finite	count=1
arg	f ||| f	count=270
function_arg	[function_1] modulo o(x**prec) ||| [arg_2] [function_1]	count=3
function	rotational gradients [function_2] ||| [function_1] [function_2]	count=1
function	[function_1] paths into ||| [function_2] [function_1]	count=1
arg	subtracting pt -- ||| z pt	count=2
function	finite [function_2] ||| [function_2] [function_1]	count=1
arg	gcd of two polynomials ||| g	count=3
arg	expr is ||| expr	count=1
function	return the inverse ||| inv	count=1
arg	expr using the ||| expr	count=1
function_arg	[function_1] [arg_2] ||| [function_1] x n [arg_2]	count=2
function	the focal [function_2] ||| [function_2] [function_1]	count=2
arg	checks for ||| expr	count=1
module	take on a specific ||| series	count=1
function	the third heuristic ||| heuristic	count=1
function	product replacement ||| pr	count=1
function	square-free [function_2] ||| [function_1] [function_2]	count=19
function	of operators ||| operators	count=1
class	of the ||| matrix properties	count=1
function	a scalar return larger ||| scalar	count=1
function	in which the ||| not empty	count=1
arg	of ||| polys k	count=1
function_arg	[function_1] gen in ||| [function_1] [arg_2]	count=1
function	[function_1] homomorphism ||| [function_2] [function_1]	count=2
function	of arguments ||| args	count=1
function	generates cyclotomic [function_2] ||| [function_2] [function_1]	count=3
arg	factors ||| factors u	count=1
function	[function_1] equations ||| [function_1] [function_2]	count=2
function	of ode are ||| 2eq order1 type6	count=1
function_arg	coset rank [arg_2] ||| [function_1] [arg_2]	count=3
arg	where f [arg_2] ||| [arg_1] [arg_2]	count=10
function	adds a force ||| force	count=1
arg	into the tuple m ||| m	count=1
function	list [function_2] ||| [function_1] [function_2]	count=1
arg	quantum number [arg_2] ||| physics energy [arg_2] [arg_1]	count=1
module	[module] integer ||| [module]	count=2
arg	list x by ||| x	count=1
class	ie the ||| permutation	count=2
function	hash randomization ||| hash randomization	count=2
arg	= [arg] the special ||| d [arg]	count=1
function	minimal degree ||| min	count=1
function	additive [function] symbol ||| remove [function]	count=1
arg	[arg_1] k -> ||| functions elementary root arg [arg_1] [arg_2]	count=1
function	to gray ||| to gray	count=1
function_arg	of sin [arg_2] ||| [arg_2] [function_1]	count=1
function	matrix m corresponding to ||| implicit mat	count=1
function	extracted [function] y ||| [function]	count=1
function	and if symbols is ||| and	count=1
function	is available ||| try use	count=1
function	axis [function_2] ||| [function_2] [function_1]	count=1
function_arg	[function_1] a morphism ||| [function_1] morphisms [arg_2]	count=1
arg	compute the monic gcd ||| f	count=1
function	trial ||| dmp trial	count=1
function	series expansion of ||| rs	count=1
function	for ||| vars	count=1
arg	check if p ||| p	count=1
function	lie [function_2] ||| [function_2] [function_1]	count=4
function	true if ||| is	count=9
function	find 'executable' in the ||| find	count=1
arg	for fast calculation ||| expr modules printer	count=1
arg	k ||| u k	count=1
module	negative coefficient ||| simplify	count=1
function	on ||| call	count=1
function	a loop morphism ||| loop morphism	count=1
function	optimization opportunities ||| cse	count=1
function	variation of [function_2] ||| [function_1] [function_2]	count=1
module_class	[module_1] integer n ||| [module_1] [class_2]	count=1
arg	options ||| options	count=1
function	wang/eez [function_2] ||| [function_1] [function_2]	count=4
class	generate ||| ring	count=2
function_arg	gf [arg_2] ||| [function_1] gcd f g [arg_2]	count=2
arg	gcd of two ||| g	count=1
function	calculates the delta coefficient ||| delta coeff	count=1
arg	formats a text ||| text	count=1
function	tests ||| tests	count=1
function	of phrase and ||| check and join	count=1
module_class	returns an ||| polys domains real	count=1
module	polyhedra we ||| combinatorics	count=1
function	are both integers then ||| param	count=1
arg	free and dum indices ||| free dum	count=1
arg	satisfying the property prop ||| prop	count=1
arg	of n ||| factors n	count=1
function	a python subprocess ||| subprocess	count=1
function_arg	in gf [arg_2] ||| [function_1] exquo f g [arg_2]	count=1
function	construct field ||| field	count=1
function	build a [function_2] ||| [function_2] [function_1]	count=2
function	it if possible ||| use	count=1
arg	if n ||| n candidates big	count=1
arg	using g functions assuming ||| g	count=1
arg	z )[x] ||| minpoly p	count=1
module	gcd of ||| polys	count=4
function	was successfully decremented ||| decrement	count=1
function	a 3-tuple a b ||| three	count=1
arg	cheap to compute ||| use_trial use_rho use_pm1	count=1
function	the taylor ||| taylor	count=1
arg	+ sign*s this is ||| sign	count=1
function	to ||| data tensorhead from	count=1
function	[function_1] fourier ||| [function_2] [function_1]	count=1
function_arg	[function_1] x0 ||| [arg_2] [function_1]	count=1
function	represents [function] between ||| [function]	count=1
function	splitting square-free factorization ||| splitfactor sqf	count=1
class	to ||| complex field	count=1
function	compose ||| compose	count=1
class	number of ||| type g	count=1
arg	that stands next to ||| element	count=1
class	return a list ||| field	count=1
arg	with p2 in the ||| p2	count=1
function	and leverage ||| pretty try use	count=1
function	a system [function_2] ||| [function_2] [function_1]	count=2
function	copy of the ||| copy	count=1
function	rational number \frac ||| integer rational	count=1
function_arg	by other, [arg_2] ||| [arg_2] [function_1]	count=2
function	division with remainder ||| div	count=2
function	have precision ||| evalf	count=1
function	can be written as ||| can do	count=1
function	compute the inverse laplace ||| inverse laplace	count=1
class	of symbolic values ||| code	count=1
arg	[arg_1] h are ||| [arg_1] [arg_2]	count=12
function	the lower bound ||| lower	count=1
arg	k ||| k	count=19
function_arg	[function_1] [arg_2] used to construct it ||| [function_1] expression [arg_2] increment	count=1
function	to a dict ||| to sympy dict	count=2
function	covariant [function] ||| covariant [function]	count=1
function	generalized multivariate polynomial ring ||| polynomial ring	count=1
module_class	[module_1] a fraction ||| [module_1] [class_2]	count=2
arg	two permutations ||| other	count=2
function	returns the lower bound ||| lower	count=1
arg	list ||| list	count=1
class	files ||| fcode	count=1
function	around ||| power	count=2
function	takes as ||| as	count=1
class	containing the ||| operations	count=1
function	[function_1] level of ||| [function_1] [function_2]	count=1
function	the "restricted growth string" ||| rgs	count=1
function	with the proper ||| statement	count=1
function	return basic transversals relative ||| basic transversals	count=1
module	qdots to the ||| physics mechanics	count=1
function	of non-conjugate ||| refine complexes	count=1
function	string of ||| str	count=1
function	a 2d n-link pendulum ||| pendulum	count=1
function	of ||| func	count=1
function_arg	[function_1] [arg_2] ||| [function_1] [arg_2] root2	count=5
module	objects handles the default ||| physics	count=1
arg	by a an element ||| c	count=2
function	generalized multivariate polynomial ||| polynomial	count=1
arg	[arg_1] a in ||| eval [arg_1] [arg_2]	count=1
arg	eq with ||| eq name	count=2
function	use [function_2] ||| [function_1] [function_2]	count=5
class	of ||| root	count=1
function	monotonic ||| monotonic	count=1
function	syllables ||| syllables	count=2
function	lie group ||| lie group	count=1
module	the patterns ||| matrices	count=1
arg	integer n ||| n	count=1
function	[function_1] laplace ||| [function_2] [function_1]	count=3
class	a ||| series base	count=2
class	quaternion orientation orients the ||| quaternion	count=1
function	sympy ||| from sympy	count=1
function_arg	[function_1] [arg_2] root2 ||| [function_1] [arg_2] root2	count=4
class	that no bounding ||| root	count=1
module_class	returns tensor [class_2] ||| [module_1] tens [class_2]	count=1
arg	[arg] and then ||| [arg]	count=3
function	and result ||| result	count=1
function	qubit ||| qubit	count=1
function	the indefinite integral ||| integrate	count=3
function	evaluation points ||| points	count=1
arg	x by the ||| x	count=1
function	to a class into ||| func	count=1
module	contracted terms ||| physics	count=1
function	term ||| term	count=6
function	values below fermi? >>> ||| below fermi	count=1
function_arg	[function_1] euler eq ||| [arg_2] [function_1]	count=2
arg	[arg_1] k[x] ||| [arg_1] c [arg_2]	count=2
module	performs the ||| physics	count=1
function	[function] prufer ||| [function]	count=3
class	compute ||| g function	count=1
function	generates chebyshev ||| chebyshevt	count=1
arg	to make poly ||| poly	count=1
function	interior of a ||| interior	count=1
function	[function_1] log ||| [function_2] [function_1]	count=1
function_arg	[function_1] v ||| [function_1] [arg_2]	count=8
function	coefficient of a ||| as coeff add	count=3
arg	an ||| func	count=1
arg	[arg_1] \mathbb{z}_p[z]/(\check m_{\alpha} ||| [arg_2] [arg_1]	count=1
module	the pde \frac{d\chi}{dx} + ||| solvers	count=1
arg	routines in ||| routines f prefix	count=3
class	returns ||| type	count=1
function	polynomial remainder in gf ||| gf rem	count=1
function	the coefficient [function_2] ||| [function_1] [function_2]	count=4
function	classes to their ||| operators to	count=1
arg	in x_j ||| m j	count=1
function	math-related macros from math ||| math macros	count=1
arg	at x_0 ||| u	count=1
function	minimal ||| minimal	count=3
class	p[i] > ||| permutation	count=1
function	factory for [function_2] ||| [function_2] [function_1]	count=2
module	are polynomials [module] z[x] or ||| [module]	count=1
arg	tuple m representing a ||| m	count=1
class	standard basis ||| sub module poly ring	count=1
function	coefficient ||| coeff add	count=3
function	square-free [function_2] ||| [function_1] list [function_2]	count=2
arg	anti-derivative [arg_2] ||| [arg_2] [arg_1]	count=3
function	lower ||| sub	count=1
arg	[arg_1] to z ||| [arg_2] [arg_1]	count=2
function	the inverse laplace transform ||| inverse laplace transform	count=1
function	n\th ||| ode nth	count=5
function	of distinct real roots ||| real roots	count=1
arg	[arg] if it ||| [arg] subcircuit replace	count=1
function	to rotate a ||| rotate	count=1
function_arg	the linearizer [arg_2] ||| [arg_2] [function_1]	count=3
function_arg	[function_1] a scalar ||| [arg_2] [function_1]	count=4
function	cofactors ||| inner	count=2
arg	algorithm i e find ||| g n	count=1
function	for independence between ||| pspace independent	count=1
module	a [module] element-wise ||| [module]	count=1
function	a property where the ||| property	count=1
arg	determine multiplicities of factors ||| factors	count=2
module	in a [module] in k[x] ||| [module]	count=1
module	tensor indices to complete ||| tensor	count=2
arg	of the factors ||| factors	count=1
function	more important ||| important	count=1
function	returns the norm ||| norm	count=1
arg	the other ||| other	count=1
function	preprocess ||| preprocess for	count=1
class	corresponding to a group ||| free group	count=1
arg	targets ||| targets	count=1
module	list ||| polys	count=1
module	look [module] pure literals ||| [module]	count=1
arg	[arg_1] domain ||| [arg_1] [arg_2]	count=6
function	sympy expression ||| expr	count=1
function_arg	strictly decreasing [arg_2] ||| [arg_2] [function_1]	count=2
function	implements the lie group ||| lie group	count=1
function	a sliding cart under ||| cart	count=1
arg	sympy expression expressions ||| expr	count=1
class	basis ||| ring	count=1
arg	efficiently test if f ||| f	count=1
arg	[arg] inequalities ||| [arg]	count=1
function	returns square-free [function_2] ||| [function_2] [function_1]	count=4
function	laplace inversion ||| inversion	count=1
function	row-sorted [function_2] ||| [function_2] [function_1]	count=4
class	quaternion orientation ||| quaternion	count=1
function	using formula ||| atanh	count=1
arg	c is ||| c	count=1
arg	func ||| func	count=3
arg	> a ||| a	count=1
arg	rotations are applied in ||| name angle1 angle2 angle3	count=1
function_arg	in gf [arg_2] ||| [function_1] neg [arg_2]	count=2
class	a tuple of ||| basic	count=1
function_arg	[function_1] eq ||| [function_1] [arg_2]	count=2
class	of ||| matrix properties	count=1
function	that are generated ||| auto	count=1
class	coordinate ||| point	count=1
function	the sum of k ||| sum of	count=1
arg	proper handlers ||| basename arg	count=1
function	[function_1] quasi-particle? create ||| [function_1] [function_2]	count=1
module	returns ||| liealgebras	count=1
function	returns whether each coordinate [function_1] [function_2] ||| [function_1] [function_2]	count=4
function	linear equation ax ||| linear	count=1
module_class	[module_1] atoms of ||| [module_1] [class_2]	count=2
function	form of a finite ||| finite	count=1
function_arg	get [arg_2] ||| [function_1] [arg_2]	count=2
class	of this [class] and ||| [class]	count=1
function	[function_1] [function_2] of ||| [function_2] [function_1]	count=18
function	ode are ||| linear 2eq order1	count=1
function	according to whether ||| signature from	count=1
function	returns a copy ||| structure copy	count=1
class	this module ||| module	count=2
arg	as find_pure_symbol but arguments ||| symbols unknown_clauses	count=1
arg	f as a sum ||| f	count=1
function	lie [function_2] ||| [function_1] [function_2]	count=4
function_arg	reorder [arg_2] ||| [arg_2] [function_1]	count=1
function_arg	the gcd [arg_2] ||| [function_1] f [arg_2]	count=1
arg	constructing ||| i j grid morphisms_str_info	count=1
class	is currently at ||| symbol factory	count=1
function	the operation count ||| count	count=1
function	mapping of ||| dict	count=1
function	return constant [function_2] ||| [function_2] [function_1]	count=2
arg	a second order ||| order	count=1
function	* ||| mul	count=2
arg	rotations are applied ||| angle1 angle2 angle3 rot_order	count=1
class	polynomials ||| ring	count=2
function	is a gate identity ||| random identity search	count=1
function	presentation ||| reidemeister presentation	count=2
function	the event [function_2] ||| [function_1] [function_2]	count=1
function_arg	space [arg_2] ||| [function_1] [arg_2]	count=1
arg	f if it is ||| f symbol	count=1
class	of ||| type	count=2
arg	equal to n ||| n nth	count=1
class	[class_1] element in ||| [class_1] [class_2]	count=1
class	table ||| table	count=3
function	of the functions ||| not empty in	count=1
arg	x representing a ||| x	count=1
function	[function_1] tuple ||| [function_1] [function_2]	count=2
class	bounding rectangles of non-conjugate ||| root of	count=1
function	quotient in ||| exquo	count=1
class	data ||| module element	count=1
function	be of the ||| process limits	count=1
arg	for two univariate ||| g	count=1
arg	from dumx ||| dumx	count=1
class	on ||| series	count=1
module	path ||| utilities	count=2
arg	key n ||| key	count=1
function_arg	[function_1] instance ||| [arg_2] [function_1]	count=3
arg	divides p - 1 ||| p	count=1
class	frame ||| frame	count=1
module	x ||| functions elementary	count=1
arg	two ||| g ring	count=1
module	equation is used for ||| solvers	count=1
class	expression ||| expression	count=1
function	random integer ||| random integer	count=2
function	crt [function_2] ||| [function_2] [function_1]	count=2
function	generated ||| get	count=2
function_arg	where [arg_2] ||| [arg_2] [function_1]	count=18
function_arg	[function_1] gr ||| [function_1] certificate [arg_2]	count=1
function	reducible by checking if ||| reducible	count=1
module	the supplied ||| physics vector	count=1
arg	lex order ||| order	count=3
arg	of coefficients of f ||| f	count=1
function	compute square-free part ||| sqf part	count=4
function	with [function] distribution ||| [function]	count=1
arg	value to or reset ||| value	count=1
function	form lagrange's ||| form lagranges	count=2
arg	that is appropriate for ||| name expr argument_sequence global_vars	count=1
arg	= b ||| b	count=1
arg	l [arg_2] ||| [arg_2] [arg_1]	count=4
function	returns the directional derivative ||| directional derivative	count=1
function	wrapper around expand ||| expand power base	count=2
function	[function_1] equations of ||| [function_1] [function_2]	count=2
function	[function_1] difference ||| [function_2] [function_1]	count=7
function	of all ||| measure all	count=1
arg	if ||| min	count=1
arg	sympy sense ||| include	count=1
function	into a ||| mod func	count=1
class	polynomial [class_2] ||| [class_2] [class_1]	count=3
class	basic ||| permutation group	count=2
module	ternary form [module] + ||| [module]	count=1
module	negative ||| simplify	count=1
function	[function_1] maximum ||| [function_1] [function_2]	count=1
class	body orientation takes ||| body orienter	count=1
function	pohlig-hellman algorithm for ||| pohlig hellman	count=1
module	of the system ||| physics mechanics	count=2
function	distribute ||| distribute	count=1
function	another ||| pos	count=1
function	subresultant prs sequence ||| subresultants	count=1
arg	of the operations in ||| visual	count=1
function_arg	[function_1] p ||| [function_1] add f g [arg_2]	count=1
function	expression in ||| expr	count=2
arg	that only func remains ||| func hint	count=1
function_arg	ideal other ||| ideal other	count=1
arg	a rational [arg] ||| [arg]	count=1
function	a piecewise form examples ||| as piecewise	count=1
arg	polynomial techniques ||| domain	count=1
function_arg	[function_1] and ||| [arg_2] [function_1]	count=1
function_arg	apply [arg_2] ||| [function_1] f [arg_2]	count=2
function	trigamma function is ||| trigamma	count=1
arg	c i e ||| c	count=1
arg	or as a ||| a b	count=1
function_arg	[function_1] x_j of ||| [arg_2] [function_1]	count=2
arg	x_0 of ||| m u	count=1
function	of the more important ||| important	count=1
class	kb ||| fact kb	count=2
function	k [function_2] ||| [function_1] [function_2]	count=1
function	consistent ||| consistent	count=1
function	evaluate the parts ||| eval	count=1
arg	f defined as ||| f k r	count=1
function	of non-conjugate ||| refine	count=1
class	division ||| poly element	count=1
module	number of ||| utilities	count=1
function	if so would that ||| is	count=3
function	argument of the ||| argument	count=3
function	find the lowest index ||| find reasonable	count=1
arg	only func remains in ||| func hint	count=1
class	state of this one ||| state	count=1
class	at ||| symbol factory	count=1
function	equation of [function_2] ||| [function_2] class [function_1] func_class f symbol	count=1
function	dummies can ||| dummies	count=1
class	[class_1] code of ||| [class_1] [class_2]	count=1
module	which return ||| core	count=1
function	von [function_2] ||| [function_2] [function_1]	count=2
function	pt1 ||| choose target cell	count=1
function	polynomial pseudo-remainder ||| prem	count=1
function	to their ||| to	count=1
module	x **2 [module] csc ||| [module]	count=1
module	on a ||| diffgeom	count=1
module_class	[module_1] n-dim array ||| [module_1] sparse [class_2]	count=1
function	set attributes that ||| attrs	count=1
arg	[arg_1] j_2 m_2 ||| [arg_2] j_3 [arg_1]	count=1
arg	truth value ||| cls	count=1
function	list of partial ||| partial	count=1
arg	polynomial by index ||| cls poly index	count=2
class	formats a ||| code	count=1
arg	n and ||| n	count=2
module_class	[module_1] [class_2] called complete if it ||| [module_1] [class_2]	count=1
function	to the module ||| get mod	count=1
function	to a dict ||| dict	count=1
function	alpha implication tables ||| alpha	count=1
function	[function_1] generators of ||| [function_2] [function_1]	count=6
function_arg	[function_1] x_j in ||| [arg_2] [function_1]	count=2
module	if k in d ||| core	count=1
arg	of rank rank ||| rank	count=2
arg	[arg_1] j_2 ||| [arg_2] j_3 [arg_1]	count=1
arg	intervals in [arg_2] ||| [arg_2] [arg_1]	count=5
class	swap [class_2] ||| [class_1] [class_2]	count=1
function	the radius ||| radius	count=1
class	this fermionicoperator ||| fermionic operator	count=4
class	integer ||| gmpyinteger	count=1
function	chi ||| chi	count=2
arg	self to other ||| other num	count=1
function	[function_1] with constant ||| [function_2] [function_1]	count=2
class	the object ||| series	count=1
arg	convert a ||| k1 a k0	count=49
function_arg	dummy [arg_2] ||| [function_1] [arg_2]	count=6
function	[function_1] partial ||| [function_2] linear constant coeff [function_1]	count=1
module_class	[module_1] dyadic in ||| [module_1] [class_2]	count=2
function	the indefinite integral ||| dmp integrate	count=2
function	to real ||| to	count=1
function	map y_i to x_i**k_i ||| inflate	count=1
function	gauss-lobatto ||| lobatto	count=1
arg	a series modulo o(x**prec) ||| p x prec	count=1
function_arg	[function_1] name ||| [arg_2] [function_1]	count=2
function	[function_1] paths ||| [function_1] [function_2] lst	count=1
function	raw cse on expression ||| cse	count=1
arg	i j k is ||| i j k	count=1
module	return from ||| core	count=1
function	no bounding rectangles of ||| complexes	count=1
arg	a single g ||| x a b	count=1
arg	n raise an error ||| n	count=1
function	in terms of the ||| in terms	count=1
function	type ||| linear 2eq	count=1
arg	tri to [arg_2] ||| [arg_2] [arg_1]	count=4
class	of matrix ||| matrix	count=3
arg	[arg_1] to x ||| [arg_1] [arg_2]	count=3
function	apply state ||| apply	count=2
class	using ||| matrix base	count=1
arg	a field in k[x] ||| u k	count=1
function	a polynomial ring ||| old poly ring	count=2
function	reconstruct every [function_2] ||| [function_2] [function_1]	count=2
function	hensel ||| hensel	count=1
function	bounding rectangles of non-conjugate ||| refine	count=1
module	or ||| polys	count=1
function	the proper line ending ||| statement	count=1
arg	real inverse_mellin_transform function ||| f s x_ strip	count=1
module	of an algebraic ||| polys	count=1
function_arg	[function_1] this function ||| [function_1] [arg_2]	count=8
function	nth ||| nth	count=1
arg	given a second condition ||| condition	count=1
arg	of f s , ||| f s t plane	count=1
function	the coefficient of a ||| coeff	count=7
arg	if expr ||| expr simplified	count=1
function	horizontal morphism checks whether ||| horizontal	count=1
function	in s, and ||| indent	count=1
class	expresses a derivative ||| derivative	count=1
class	returns the total ||| type	count=1
function_arg	[function_1] [arg_2] ||| [function_1] lcm [arg_2]	count=3
function	name of the ||| func	count=1
function	the more important ||| important	count=1
class	grid ||| diagram grid	count=2
function	register a handler in ||| register	count=1
arg	a single g function ||| x a	count=1
arg	a point ||| point	count=1
arg	equal to the divergence ||| vect doit	count=1
module	convert the quantity ||| physics units	count=1
arg	whose rank [arg] less ||| [arg]	count=1
arg	triangles [arg_2] ||| [arg_2] [arg_1]	count=1
function	this function in the [function_1] [function_2] ||| [function_1] [function_2]	count=6
function_arg	associated with [arg_2] ||| [function_1] [arg_2]	count=1
function_arg	[function_1] differential equation ||| [function_1] [arg_2]	count=1
class	retrieving ||| complex root of	count=1
arg	form ||| func	count=1
function_arg	[function_1] [arg_2] ||| [function_1] min pow [arg_2]	count=8
arg	rule down a tree ||| rule	count=1
module	under the ||| physics	count=1
arg	input a polynomial expression ||| expression	count=1
arg	rules ||| rules	count=1
function	[function_1] lu ||| [function_2] [function_1]	count=1
function	topological [function_2] ||| [function_2] [function_1]	count=4
function	angle bisectors ||| bisectors	count=1
function_arg	gcd [arg_2] ||| [function_1] f [arg_2]	count=1
class	[class_1] block with ||| [class_2] [class_1]	count=4
arg	poly compatible with ||| poly	count=1
arg	symbol ||| symbol	count=2
class	this linear ||| linear	count=3
arg	for constructing ||| j grid morphisms_str_info	count=1
arg	polynomial ||| minpoly	count=1
module	one else none ||| core	count=1
function	of the symbols in ||| symbols	count=2
arg	function ||| func order match	count=2
arg	input word ||| word	count=1
function	amount given ||| decipher shift	count=1
function	compute the reduced ||| trunc	count=1
arg	irreducibility test over ||| p k	count=1
function	[function_1] root or ||| [function_1] [function_2]	count=3
function	correct the values inside ||| correct signature	count=1
function	[function_1] [function_2] ||| [function_2] factor [function_1]	count=1
module	permutation using a ||| combinatorics	count=1
function_arg	to addends [arg_2] ||| [function_1] [arg_2]	count=2
function	indices are ||| indices	count=1
class	root to ||| root of	count=1
function	a list [function_2] ||| [function_2] [function_1]	count=26
function	descents in a ||| descents	count=1
arg	[arg] on ||| [arg]	count=3
arg	the root if it ||| cls root radicals	count=1
class	the symmetric/alternating group ||| group	count=1
arg	of a polynomial f ||| f minpoly	count=1
function_arg	[function_1] function ||| [arg_2] [function_1]	count=16
function	general hankel ||| hankel	count=1
arg	list of \* ||| dir pat init_only	count=1
class	the partition is ||| partition	count=1
arg	n ||| n de	count=1
arg	is replaced ||| args kwargs n	count=1
function	are contained in the ||| similar	count=1
arg	multiplicities of factors ||| factors	count=2
arg	base ||| base	count=5
function	underlying undirected ||| undirected graph	count=1
function	over ||| ff	count=2
function	the circumcircle ||| circumradius	count=1
function	path to a ||| get mod func	count=1
class	dtype ||| quotient ring	count=1
function	set of triangles ||| triangles	count=1
function	returns the exponent of ||| exponent	count=1
function_arg	[function_1] of two ||| [function_1] [arg_2]	count=10
function	using subresultants over ||| rr prs	count=2
function	distinct real ||| real	count=1
arg	apply on a scalar ||| scalar_field	count=1
function	list of quadratic ||| quadratic	count=1
module	module and ||| utilities	count=1
arg	s over the fundamental ||| s x	count=1
arg	a model ||| expr model deep	count=1
arg	as a meijer ||| a b	count=1
arg	[arg_1] by g ||| [arg_2] [arg_1]	count=6
arg	rewrite [arg] using ||| [arg]	count=1
arg	dsolve ||| eq func dict ics	count=1
function	phrase and ||| check and join	count=1
function	the domain of the ||| not empty in	count=1
function	compute f + ||| add	count=1
function_arg	[function_1] polynomials in ||| [function_1] sub [arg_2]	count=1
function_arg	[function_1] a morphism ||| [function_1] [arg_2]	count=3
arg	[arg] have ||| [arg] symbolname startnumber	count=1
function	the components of ||| components	count=2
function	factor a square-free polynomial ||| factor sqf	count=1
arg	seed ||| seed	count=2
class	standard basis in ||| sub	count=1
function	fraction [function_2] ||| [function_2] [function_1]	count=2
function	symbolic ||| create	count=1
arg	p is not one ||| p c	count=1
function	the lie ||| lie	count=1
function	a zeros ||| zeros	count=1
function_arg	[function_1] to n ||| [arg_2] [function_1]	count=8
function	as [function] false otherwise ||| needs [function]	count=1
function	utility function to correct ||| correct signature	count=1
class	curve is ||| curve	count=1
function_arg	input [arg_2] ||| [function_1] [arg_2]	count=5
function	postprocess an ||| postprocess for	count=1
arg	intervals in the given ||| f symbol	count=1
arg	a single ||| a b	count=2
module	which [module_2] ||| [module_1] [module_2]	count=1
arg	p ||| p t z	count=1
function	module and ||| mod	count=1
function	[function] single line ||| gamma [function]	count=1
arg	of terms of f ||| f	count=4
module	returns the total ||| liealgebras	count=1
function	name of the class ||| mod	count=1
arg	a text ||| text color	count=1
arg	given ||| ratio	count=1
arg	n data ||| n x x y	count=1
function	gets the subset defined ||| subset from	count=1
class	standard basis ||| ring	count=1
function	generators ||| expr no gens	count=1
arg	[arg_1] from dumx ||| [arg_2] [arg_1]	count=2
function	[function_1] a power ||| [function_2] [function_1]	count=1
module	scores ||| logic algorithms	count=1
function	construct a polynomial from ||| poly from	count=1
function	the c ||| c	count=1
arg	not false [arg] < ||| [arg]	count=1
function	a new line parallel ||| parallel line	count=1
arg	divides p - 1 ||| p all_roots	count=1
function	random ||| random	count=8
function	result ||| indent	count=1
function	logarithm ||| log	count=1
function_arg	calculate core [arg_2] ||| [function_1] [arg_2]	count=3
function	helper function [function_2] ||| [function_2] [function_1]	count=2
function	is the whole ||| is whole	count=3
class	[class_1] the transform ||| [class_1] [class_2]	count=1
class	a standard basis in ||| poly	count=1
function	figure out generators ||| expr no gens	count=1
arg	after subtracting pt ||| z pt	count=2
function_arg	expression to [arg_2] ||| [function_1] [arg_2]	count=1
function_arg	converts an [arg_2] ||| [arg_2] [function_1]	count=2
function	by other, ||| ge	count=1
module	matrix sum of the ||| matrices expressions	count=1
function_arg	error [arg_2] ||| [arg_2] [function_1]	count=1
function_arg	[function_1] p with ||| [function_1] a [arg_2]	count=1
arg	over the fundamental strip ||| x strip	count=1
arg	equation eq ||| eq param syms permute	count=1
function	over a ||| dmp rr	count=1
function	apply additional beta-rules ||| apply	count=1
module	total ||| liealgebras	count=1
function	[function_1] irreducible ||| [function_2] [function_1]	count=12
function	[function_1] decreasing ||| [function_2] [function_1]	count=9
arg	a polynomial in ||| f	count=6
arg	the given ||| symbol	count=1
arg	stabilizer of ||| schreier_vector _random_prec	count=1
function	anp ||| algebraic	count=3
arg	lexical closure ||| name latexname	count=1
arg	x gives ||| b x	count=1
function	polynomial from dmp to ||| from	count=1
arg	[arg_1] p ||| [arg_1] [arg_2]	count=8
function_arg	[function_1] representation ||| [function_1] reorder [arg_2]	count=1
arg	3 1 2 ; [arg_1] [arg_2] ||| physics epsilon [arg_1] [arg_2]	count=3
module_class	implies __abs__ ||| polys domains domain	count=1
function	isolate real ||| isolate real	count=3
function_arg	[function_1] = n ||| [arg_2] [function_1]	count=1
function	path to a ||| mod func	count=1
arg	operations [arg_2] ||| [arg_2] [arg_1]	count=2
arg	f ||| f c	count=5
arg	[arg_1] name ||| [arg_2] [arg_1]	count=2
function	codomain ||| codomain	count=2
arg	by index ||| index	count=1
arg	k[x] [arg_2] ||| [arg_2] [arg_1]	count=2
arg	[arg_1] two ||| [arg_1] [arg_2]	count=2
function	loads a ||| load	count=1
function	opportunities in ||| opt	count=1
function	an sdm [function_2] ||| [function_2] [function_1]	count=3
arg	return the series expansion ||| a prec	count=1
module	value of the ||| functions	count=1
arg	the denester ||| denester	count=1
function_arg	[function_1] given ||| [arg_2] [function_1]	count=19
arg	name [arg_2] ||| [arg_2] [arg_1]	count=4
function	computes the order ||| order	count=2
function	[function_1] power ||| solvers has [function_1] [function_2]	count=1
function	the product ||| mul	count=1
arg	b modulo ||| b	count=3
function	n-link pendulum ||| n link pendulum	count=1
class	generate ||| free module quotient	count=1
function	of the form x ||| process	count=1
function	dimensions of ||| shape	count=1
function	mpf ||| mpf	count=1
module	to rearrange the ||| physics quantum	count=1
function	returns f - ||| sub	count=2
arg	constructing the string ||| j grid morphisms_str_info	count=1
function_arg	generates the [function_1] [arg_2] a permutation group ||| combinatorics [function_1] group [arg_2]	count=1
function	in gf ||| gf	count=17
function	version of scan ||| scan	count=2
function	roots of [function_2] ||| [function_1] [function_2]	count=4
function	and the ||| func	count=1
function_arg	index of [arg_2] ||| [arg_2] [function_1]	count=4
function	quadrants ||| to quadrants	count=1
function	of this ||| eval	count=1
arg	[arg] "seq" ||| cls [arg]	count=2
class	to a group ||| free group	count=1
function	default files ||| test files	count=1
function	a list ||| list	count=15
function	[function_1] a sentinel ||| [function_2] [function_1]	count=1
function	[function_1] inversion 1/p ||| [function_2] [function_1]	count=1
class	[class] diagonal are ||| matrix [class]	count=2
function	self is written as ||| as coeff	count=1
function	solveset ||| solveset	count=1
module	the canonical ordering is ||| physics	count=1
function	row-sorted list of non-zero ||| row list	count=1
function	the ||| limits	count=1
function	[function_1] associated with ||| [function_2] [function_1]	count=4
arg	complexes such ||| complexes	count=1
module	of [module] given ||| [module]	count=2
module	of ||| tensor	count=1
class	multivariate fractions ||| dmf	count=3
arg	c i ||| n c	count=1
arg	[arg] used ||| [arg]	count=1
arg	z at the ||| z	count=1
function	finite_set ||| empty in	count=2
class	scalar ||| covar derivative	count=1
function_arg	[function_1] representation ||| [arg_2] [function_1]	count=1
function_arg	[function_1] gen ||| [function_1] [arg_2]	count=1
function	coefficients ||| ground content	count=1
class	refine an [class_1] [class_2] ||| [class_1] [class_2] refine	count=1
function	unique cyclically reduced version ||| identity cyclic reduction	count=1
function	of real roots of ||| real roots	count=1
arg	k[x] ||| u	count=3
function	and the name of ||| get mod	count=1
class	tuple ||| basic	count=2
class	the window ||| managed window	count=1
function_arg	[function_1] from intqubit ||| [function_1] qubit [arg_2]	count=2
class	distribution ||| single continuous distribution	count=1
arg	[arg_1] such ||| [arg_2] [arg_1]	count=1
function_arg	return the covariant [function_1] [arg_2] ||| diffgeom covariant [function_1] [arg_2]	count=2
function	[function_1] in ||| [function_1] [function_2]	count=1
function_arg	[function_1] given annihilator ||| [arg_2] [function_1]	count=1
arg	if [arg] on the ||| [arg]	count=1
arg	[arg] = ||| [arg] x	count=1
arg	[arg_1] beta distribution ||| [arg_1] [arg_2]	count=1
function	components ||| free dum	count=1
function	[function_1] gate with ||| [function_2] [function_1]	count=1
class	to ||| python integer ring	count=1
arg	f if ||| f symbol	count=1
function	the transposed sparsematrix ||| transpose	count=1
function_arg	force to [arg_2] ||| [function_1] [arg_2]	count=4
module	return ||| elementary	count=1
arg	f in k[x], useful ||| f u k	count=1
function_arg	down a [arg_2] ||| [function_1] rule [arg_2]	count=2
function	a sympy matrix/complex ||| sympy	count=1
function	list ||| dmp list	count=1
arg	[arg] (if ||| [arg] do key2	count=2
function	returns the transposed sparsematrix ||| transpose	count=1
arg	instance ||| cls poly func	count=1
class	that take on ||| series base	count=1
module	that ||| series	count=1
function	lmq upper bound for ||| upper bound	count=1
function	new [function] has ||| spread [function]	count=1
arg	rhs but treats arguments ||| rhs	count=1
function	operators corresponding ||| operators	count=1
function	roots in linear quadratic ||| roots	count=1
arg	p of k[t ||| p t	count=1
function	extended euclidean algorithm ||| gcdex	count=3
arg	n and either a ||| n	count=1
arg	for normal_order look through ||| recursive_limit _recursive_depth	count=1
arg	returns true if a ||| a	count=1
function	useful signature ||| signature	count=1
arg	a model or not ||| model deep	count=1
function	space rotation ||| space	count=1
function_arg	[function_1] in p ||| [function_1] [arg_2]	count=3
arg	compute the gcd ||| f	count=3
function	if possible ||| pretty try	count=1
function	as a finite ||| as finite	count=3
function_arg	transform of [arg_2] ||| [arg_2] [function_1]	count=13
arg	j see ||| j	count=1
function	domain of ||| in	count=1
function	gets the gray code ||| unrank gray	count=1
arg	unit in term ||| unit	count=1
module	matrix multiplication ||| matrices	count=1
function	return ||| eval cond	count=2
function	to a dict ||| to dict	count=4
arg	expr ||| expr	count=30
function	new rational function field ||| field	count=1
class	of a single basis ||| var bosonic basis	count=1
function	elements from a list ||| list	count=1
module	polynomial with ||| polys	count=1
module	rectangles ||| polys	count=1
module	return true if self ||| polys agca	count=8
function	sorted numerically according to ||| ordered	count=1
function	column matrix containing all ||| dynamic	count=1
function	f + g*h ||| add mul	count=3
class	basis in ||| module poly ring	count=1
arg	of a morphism is ||| morphism	count=1
function	phrase and ||| check and	count=1
arg	[arg] if ||| [arg] subcircuit replace	count=1
function	evaluate [function_2] ||| [function_1] [function_2]	count=3
arg	f and g which ||| f g exps x	count=1
function	zeros matrix for a ||| matrix zeros	count=1
function	self ||| contains	count=1
arg	orientation or [arg] wrt ||| [arg]	count=1
arg	function to [arg_2] ||| [arg_2] [arg_1]	count=2
arg	polynomial in x_j ||| j	count=1
function	[function_1] order a ||| [function_1] [function_2]	count=1
function	[function_1] line ||| [function_1] [function_2]	count=3
function	the nth ||| nth	count=1
function	[function] self == ||| [function]	count=2
class	the integration using any ||| integral	count=1
function	s, and return ||| indent	count=1
function	terms of ||| hyper as	count=1
arg	input k \in ||| k	count=1
function	solvable ||| solvable	count=1
arg	f x the ||| f x	count=2
arg	of ||| polys	count=1
function	in ||| not empty in	count=2
function_arg	of functions [arg_2] ||| [arg_2] [function_1]	count=3
class	currently ||| symbol factory	count=1
function	ternary diophantine equation ax^2 ||| diop ternary	count=1
arg	lagrangian : ||| lagrangian	count=1
module	return the truth value ||| functions elementary	count=1
arg	converts ||| assign_to	count=3
module	factor matrices ||| matrices expressions	count=1
function	function with name and ||| function	count=1
function	[function] transformation ||| [function] rational	count=1
class	object excluding those ||| series	count=1
arg	of a telescopic sum [arg_1] [arg_2] ||| [arg_1] [arg_2]	count=8
function_arg	[function_1] polynomials ||| [function_1] mul f [arg_2]	count=1
function	[function_1] [function_2] matrixbase arguments ||| [function_1] [function_2]	count=2
function	inverse [function_2] ||| [function_2] [function_1]	count=17
class	adds up the ||| add	count=1
function	one ||| one	count=2
class	polar numbers is ||| polar lift	count=1
function	the altitudes ||| altitudes	count=1
function_arg	[function_1] of orig_vec ||| [function_1] [arg_2]	count=2
arg	[arg_1] j_3 ||| [arg_2] [arg_1]	count=5
function	potential [function_2] ||| [function_2] [function_1]	count=6
arg	f ||| f ring	count=2
function	expression in terms of ||| in terms of	count=1
function_arg	reorder [arg_2] ||| [function_1] rep [arg_2]	count=1
arg	[arg] belongs ||| [arg]	count=3
function	returns the order of ||| order	count=3
function_arg	[function_1] or an ||| [arg_2] [function_1]	count=4
function	recursive helper function ||| rec degree	count=1
function	and cofactors ||| inner	count=2
function	[function_1] from ||| [function_2] [function_1]	count=14
arg	sols ||| sols	count=1
module	piecewise [module] ||| [module]	count=3
arg	are ||| tolerance	count=1
arg	a polynomial at x_j ||| j	count=1
function	an ideal of ||| ideal	count=1
function	the asin of ||| rs asin	count=1
class	given dummy variables with ||| expr	count=1
module	two [module] expressions ||| [module]	count=2
arg	term [arg] ||| [arg]	count=1
class	standard ||| sub module poly ring	count=2
function_arg	functions [arg_2] ||| [function_1] [arg_2]	count=4
arg	t ||| t	count=9
arg	[arg] are ||| a [arg]	count=1
function	[function_1] zero ||| [function_2] [function_1]	count=7
function	can be written as ||| can	count=1
arg	2 ; -1 if [arg_1] [arg_2] ||| [arg_1] [arg_2]	count=7
function	coefficient of [function_2] ||| [function_1] [function_2]	count=4
function_arg	[function_1] for computation ||| [function_1] [arg_2]	count=2
module	of [module] self ||| [module]	count=1
arg	infinitesimals of the ||| infinitesimals	count=1
function	morse code ||| decode morse	count=1
function	[function_1] free space ||| [function_2] [function_1]	count=6
function_arg	c(x_2 x_u)*x_0**i [arg_2] ||| [function_1] [arg_2]	count=2
function	the lu [function_2] ||| [function_1] [function_2]	count=1
function	to a fully ||| from	count=1
arg	+ sign*s ||| sign	count=1
class	rectangles of ||| root	count=1
function	register a ||| register handler	count=1
function	write the code by ||| code	count=1
function	isolation positive [function] given ||| [function]	count=1
function	unifies the base ||| unify	count=1
function	no ||| refine	count=1
arg	of this type of ||| x y	count=3
function	the ||| get statement	count=1
arg	c[n]*p**n modulo o(x**prec) ||| p c x prec	count=1
arg	rewrite [arg] ||| [arg]	count=3
function	[function_1] semicircle distribution ||| [function_1] [function_2]	count=2
function	group ||| group	count=3
function	instance ||| as	count=1
arg	to quantum number ||| m r	count=1
function	pollard's p-1 ||| pollard pm1	count=1
arg	variable with ||| name mean std	count=1
arg	compute partial fraction decomposition ||| f	count=1
function	evaluate a polynomial ||| eval in	count=1
arg	j_3 m_1 m_2 ||| j_3 m_1	count=2
class	polynomial p [class_2] ||| [class_1] [class_2]	count=2
class	exploiting the sparsity ||| sparse matrix	count=1
function_arg	order [arg_2] ||| [arg_2] [function_1]	count=4
arg	helper for _match_div_rewrite ||| expr f g rexp	count=1
module_class	polynomial [class_2] ||| [module_1] [class_2]	count=2
arg	canonical order the purpose ||| verbose	count=1
arg	to two ||| g ring	count=1
arg	variable with a ||| name	count=14
function	rational ||| as rational	count=2
arg	a polynomial f ||| f minpoly p	count=2
function	rewrites a ||| rewrite	count=1
arg	to f ||| f c	count=3
module	return ||| utilities	count=8
function	line ||| get statement	count=1
function	the name ||| get mod	count=1
arg	if all args ||| cond	count=1
module	a specific ||| series	count=1
function_arg	in gf [arg_2] ||| [function_1] exquo f [arg_2]	count=1
module_class	implies something ||| polys domains domain	count=4
class	update the kb with ||| fact kb	count=1
module	of self ||| polys agca	count=18
function	in the form ||| form	count=1
arg	see sample_iter uses ||| condition numsamples	count=2
module_class	[module_1] medium ||| [module_1] [class_2]	count=18
function	utility for gf_edf_shoup ||| gf trace map	count=1
function	force [function_2] ||| [function_2] [function_1]	count=4
arg	for op ex1 ||| op ex1	count=2
function	[function_1] constant coefficients ||| [function_2] [function_1]	count=2
arg	of this system of ||| x y z t	count=1
function_arg	[function_1] an expression ||| [function_1] path [arg_2]	count=1
function	[function_1] conditions to ||| [function_2] [function_1]	count=1
arg	[arg] less than ||| [arg]	count=1
function_arg	homogeneous partial [arg_2] ||| [arg_2] [function_1]	count=3
arg	[arg] are the ||| [arg]	count=1
arg	given an expression f ||| f	count=1
function	is available and ||| use	count=1
class	the sequence ||| seq	count=2
function	represents the slope ||| slope	count=1
arg	codestring with the ||| codestring	count=1
class	polynomials or ||| poly ring	count=1
class	tensor [class_2] ||| [class_2] [class_1]	count=1
arg	g and order o ||| g o	count=1
arg	a ||| a p	count=1
arg	[arg_1] with p ||| [arg_1] [arg_2]	count=1
arg	f in ||| f symbol	count=1
function	rectangles of ||| refine	count=1
function	it if ||| pretty	count=1
arg	with symbols -> objects ||| objects	count=1
arg	x_0 = a ||| a u	count=1
function	polynomial from ||| from	count=1
class	for [class] cartan ||| [class]	count=1
function_arg	[function_1] expr in ||| [arg_2] [function_1]	count=1
module	is the inverse of ||| physics quantum	count=1
arg	f into a ||| f	count=1
class	the matrix ||| dense matrix	count=1
function_arg	denominator of a ||| denom a	count=6
module_class	[module_1] curve ||| [module_1] [class_2]	count=4
function	transposed sparsematrix of this ||| eval transpose	count=1
function	[function_1] group method ||| [function_1] [function_2]	count=4
class	method of coset enumeration ||| coset table	count=1
function	[function_1] entity parallel ||| [function_1] [function_2]	count=1
function	a system ||| system	count=1
function_arg	rewrite f ||| rewrite single f	count=1
function_arg	each element [arg_2] ||| [arg_2] [function_1]	count=1
module_class	[module_1] [class_2] called complete if it ||| [module_1] [class_2] is complete	count=1
function	compute f * ||| mul	count=1
function	refine a positive root ||| dup outer refine real root	count=1
function	rotation about lambda a ||| orient	count=1
function	of the functions in ||| not	count=1
function	potential energy of ||| potential energy	count=2
arg	other is either a ||| other	count=1
arg	given expression ||| expr	count=4
arg	no ||| no	count=1
module	system augmented by the ||| physics mechanics	count=1
class	this method returns ||| series	count=1
arg	selected [arg_2] ||| [arg_2] expr [arg_1]	count=1
function	of ||| cond	count=1
arg	objects and the ||| objects merged_morphisms	count=1
function_arg	[function_1] p [x] ||| [function_1] gcdex f g [arg_2]	count=2
arg	of orig_vec [arg_2] ||| [arg_2] [arg_1]	count=1
module	and the name ||| utilities	count=1
function	in ||| opt cse	count=2
function	[function_1] a distributed ||| [function_2] [function_1]	count=4
arg	a dmf ||| a	count=1
function	term in the ||| term	count=1
arg	a single g function ||| x a b	count=1
function	outer indices ||| get indices	count=1
arg	[arg_1] p for ||| div [arg_1] [arg_2]	count=2
function	[function] of ||| as real [function]	count=1
function	[function_1] norm ||| [function_2] [function_1]	count=14
arg	a polynomial in k[x] ||| u	count=1
function_arg	set the [arg_2] ||| categories diagram [function_1] dict union [arg_2] value	count=1
arg	by = c ||| c a b t	count=1
function	[function_1] paths into ||| [function_1] [function_2] lst	count=1
arg	of f given a ||| f m	count=1
function	norm of a ||| norm	count=2
module	the polyhedra we ||| combinatorics	count=1
function	[function_1] terms ||| [function_2] [function_1]	count=7
function	content ||| as content	count=2
function_arg	[function_1] a ||| [function_1] expr [arg_2]	count=4
function	which ||| named	count=1
arg	arrowstringdescription describing [arg_2] ||| [arg_2] [arg_1]	count=16
function	[function_1] there is ||| [function_2] [function_1]	count=2
function	k ||| k	count=1
function	the size of the ||| degree	count=1
arg	origin ||| origin z	count=1
function	of undetermined [function_2] ||| [function_2] [function_1]	count=1
class	coset ||| coset	count=4
function	dyadicmul ||| measure number	count=1
arg	height ||| height	count=1
function	focal distance ||| focus distance	count=1
function	translate substrings ||| translate	count=1
function	[function_1] in gf ||| [function_2] [function_1]	count=10
arg	k ||| p k	count=1
arg	bits to the ||| bits str	count=1
function	[function_1] parameters ||| [function_1] [function_2]	count=2
function	atan of p, about ||| atan	count=1
function	in finite_set ||| not empty in	count=1
module	underlying dimension ||| units	count=1
function_arg	[function_1] two permutation ||| [arg_2] [function_1]	count=2
class	basis ||| module poly	count=1
arg	of terms of ||| x m n	count=1
module_class	[module_1] matrix ||| [module_1] [class_2]	count=8
function	find [function_1] [function_2] ||| find [function_2] [function_1]	count=4
function	computes the gray code ||| gray	count=1
arg	of e z at ||| e z	count=1
module	of equation is used ||| solvers	count=1
arg	of the factors has ||| factors x	count=1
class	string representing the interval ||| interval	count=1
function	[function_1] cyclotomic polnomial ||| [function_1] [function_2]	count=1
class	d_n" ||| type d	count=1
function	energy of a multibody ||| energy	count=1
function	javascript code ||| jscode	count=1
module	the line ||| physics	count=1
arg	numerical approximations of ||| n maxsteps cleanup	count=2
function	generate all the positive ||| positive	count=2
function	a class ||| get mod	count=1
function	[function] for ||| orbit [function]	count=2
function	dimension of the ||| dimension	count=4
function	converts an add/mul of ||| to	count=1
function	[function_1] of free ||| [function_1] [function_2]	count=2
arg	to eliminate x_0 ||| u k	count=1
function	routine for finding powers ||| af pow	count=1
arg	arbitrary constants [arg] have ||| [arg] symbolname startnumber	count=1
class	modulo a groebner basis ||| groebner basis	count=1
function	returns the bodies in ||| bodies	count=1
function_arg	distance between [arg_2] ||| [arg_2] [function_1]	count=4
function	the third heuristic assumes ||| lie heuristic	count=1
function	force to ||| apply force	count=2
function	[function_1] superset of ||| [function_1] [function_2]	count=2
module	lie algebra is ||| liealgebras	count=3
class	that are generated automatically ||| differential	count=1
arg	if a field ||| field	count=3
function	available and ||| pretty try	count=1
module	for vector ||| vector	count=1
class	map initial complex ||| complex	count=1
arg	a ||| i a	count=1
arg	[arg_1] if ||| [arg_2] [arg_1]	count=8
function	[function_1] of transitivity ||| [function_2] [function_1]	count=6
arg	of a ||| f	count=2
arg	digits of [arg] in base ||| [arg]	count=1
arg	transform of [arg_2] ||| [arg_2] [arg_1]	count=2
arg	p == 1 and ||| p	count=1
function	a transversal [function_2] ||| [function_2] [function_1]	count=4
module	of a [module] expectation of ||| [module]	count=1
function	the trailing coefficient of ||| gf tc	count=1
arg	sin ||| rv first	count=1
class	or ||| poly	count=1
function	the content [function_2] ||| [function_1] [function_2]	count=1
function	moment of ||| moment	count=1
function	gets the size ||| size	count=1
class	a root ||| root system	count=1
function_arg	[function_1] [arg_2] ||| [function_1] mul [arg_2]	count=2
arg	in sop [arg] pos ||| [arg] form	count=1
function_arg	interval [arg_2] ||| [function_1] [arg_2]	count=8
function	a gate identity is ||| is	count=1
arg	of f in f[x] ||| f k	count=1
arg	:func _factor ||| expr opt method	count=1
function	pendulum on a sliding ||| n link pendulum on	count=1
function_arg	lcm of [arg_2] ||| [function_1] f [arg_2]	count=1
function_arg	solve [arg_2] ||| [function_1] biquadratic f [arg_2]	count=1
function	version of eye and ||| matrix eye	count=1
class	[class_1] power ||| [class_2] [class_1]	count=1
arg	gcd a [arg_2] ||| [arg_2] [arg_1]	count=4
module	this function is the ||| physics quantum	count=1
function	[function_1] perpendicular to ||| [function_2] [function_1]	count=4
function	scalar return larger ||| scalar	count=1
arg	for two ||| g	count=1
arg	of a base and ||| group base gens	count=1
class	returns a standard ||| ring	count=1
function	determining ||| delete doubles	count=1
arg	passes through [arg] ||| [arg]	count=1
function	above fermi? ||| only above fermi	count=2
module	and ||| integrals	count=1
function	minimal [function_2] ||| [function_1] [function_2]	count=3
module	self by ||| agca	count=2
arg	an interval s ||| s	count=1
module	matrix containing [module_2] ||| [module_1] [module_2]	count=1
module	if 'self' ||| sets	count=1
function	to ||| from indices	count=1
function	add ||| dmp add	count=2
class	subgroup ||| permutation group	count=1
class	partition is listed from ||| partition	count=1
arg	changes ||| lenics	count=1
arg	construct ||| cls rep	count=3
function	linear differential equation ||| linear	count=2
module	the qdot's to ||| physics	count=1
function	a parametric ||| param	count=1
module	a string with mathml ||| mathml	count=1
arg	view expression or ||| expr	count=1
function	finite_set in which ||| not empty	count=1
arg	continuous ||| mu b	count=1
class	real interval ||| real interval	count=2
function	the matrix to rotate ||| rotate	count=1
function	generating ||| guess generating	count=1
function	integer ||| integer to	count=1
function	returns the total ||| total	count=1
function	[x], computes ||| ddf shoup	count=1
function	specific integer ||| integer	count=1
module	is available and leverage ||| printing	count=1
arg	infinitesimals ||| infinitesimals	count=1
arg	b [arg_2] ||| [arg_2] a [arg_1]	count=3
function	apoapsis ||| apoapsis	count=1
arg	[arg_1] , defined ||| [arg_1] [arg_2]	count=3
module	without the added ||| physics	count=1
arg	get ||| radicals	count=1
function	group method of solving ||| group	count=1
function	returns the z ||| z	count=1
arg	ask system key ||| key	count=1
arg	phrase is [arg_2] ||| [arg_2] [arg_1]	count=2
function	functions in finite_set ||| not	count=1
class	are generated automatically ||| extension	count=1
arg	, rs\_sin p ||| p	count=1
function	if a ||| is	count=1
class	composite [class_2] ||| [class_1] [class_2]	count=2
module_class	[module_1] [class_2] ||| [module_1] string [class_2]	count=1
arg	a small'' matrix ||| deg_f deg_g	count=1
arg	a small'' ||| deg_f deg_g	count=1
class	those ||| series base	count=2
function	numpy matrix or scalar ||| numpy	count=1
function	a zeros [function_2] ||| [function_2] [function_1]	count=6
class	[class_1] table ||| [class_1] [class_2]	count=2
arg	a in ||| i a	count=1
module	kinetic ||| physics mechanics	count=1
function	tangent to the ||| tangent	count=1
class	values to ||| code	count=1
arg	type of [arg_2] ||| [arg_2] [arg_1]	count=2
class	in the object excluding ||| series	count=1
arg	given plane? ||| l	count=1
arg	stringpict and [arg_2] ||| [arg_2] [arg_1]	count=2
arg	n ||| n a b	count=1
arg	actual infinitesimals ||| infinitesimals func	count=2
class	this fermionicoperator allow ||| fermionic operator	count=1
module	[module_1] [module_2] ||| [module_1] [module_2]	count=52
arg	[arg_1] j ||| physics epsilon [arg_1] [arg_2]	count=1
function	into a string ||| get mod	count=1
arg	expansion of the ||| x prec	count=5
arg	modulus of ||| modulus	count=1
module_class	of polynomial [class_2] ||| [module_1] [class_2]	count=2
arg	morphism and ||| morphism	count=1
function	magnitude of ||| magnitude	count=1
arg	p ||| f p	count=4
arg	a function to ||| func	count=1
module	adds up the ||| physics	count=1
function	maximum possible value ||| max	count=1
arg	distinct characters of symbols ||| symbols filter	count=1
arg	[arg] n ||| n [arg]	count=1
class	integration using ||| integral	count=1
arg	factors has ||| factors	count=1
function_arg	[function_1] [arg_2] ||| [function_1] sympy [arg_2]	count=16
module	perform ||| quantum	count=1
class	a point of all ||| point	count=1
arg	y [arg_2] ||| [arg_1] [arg_2]	count=4
function_arg	new copy [arg_2] ||| [arg_2] [function_1]	count=1
function	[function_1] evaluate a ||| [function_1] [function_2]	count=1
module	the list of ||| physics	count=1
function	field associated with self ||| get field	count=1
function	using subresultants over ||| dup rr prs	count=2
function	[function_1] products ||| [function_2] [function_1]	count=1
function	lower [function_2] ||| [function_2] [function_1]	count=2
function	a morse code with ||| decode morse	count=1
module	random variable ||| stats	count=1
function	operator classes to ||| operators to state	count=1
module	return true ||| core	count=1
function	value ||| eval cond	count=2
arg	value of n ||| n	count=2
class	homomorphism ||| module homomorphism	count=1
function	an immutable version of ||| as immutable	count=2
arg	a [arg_2] ||| core n2 [arg_1] [arg_2]	count=1
arg	returns true if a ||| a p	count=1
arg	creates a small'' ||| deg_f deg_g row1	count=1
arg	index2 row ||| index2	count=1
function	coefficient ||| coeff monomial	count=1
function_arg	expression [arg_2] ||| [arg_2] [function_1]	count=3
module	create a finite random ||| stats	count=1
arg	suitability ||| t ct a	count=1
class	ray and ||| ray	count=1
function	[function] number ||| [function]	count=2
arg	polynomial f in ||| f minpoly p	count=2
class	that no bounding rectangles ||| of	count=1
arg	f given an ||| f	count=1
arg	the root if it ||| root radicals	count=1
function	to a fully contravariant ||| data tensorhead from tensmul	count=1
module_class	[module_1] gate ||| [module_1] [class_2]	count=4
function	a mul ||| mul	count=4
arg	function for :func _symbolic_factor ||| opt method	count=1
class	standard basis ||| poly ring	count=1
function	the gauss-lobatto ||| lobatto	count=1
function	classes to their associated ||| to state	count=1
class	get ||| complex root of	count=1
arg	[arg] simple ||| [arg]	count=3
module	finite_set in which the ||| calculus	count=1
arg	x_j of [arg_2] ||| [arg_1] [arg_2]	count=1
arg	of expression ||| expr var evaluate	count=2
class	returns the xy-pic representation ||| diagram drawer	count=1
function	half extended gcd ||| half gcdex	count=2
arg	other ||| other num	count=1
function_arg	[function_1] process ||| [function_1] name p succ [arg_2]	count=2
function_arg	part [arg_2] ||| [arg_2] [function_1]	count=7
function	parametric line plot ||| parametric line	count=1
function	of polynomial generators ||| gens	count=1
function	polynomial lcm over ||| dmp ff lcm	count=2
function	shift the function ||| shift	count=1
function	the asin of p, ||| rs asin	count=1
class	[class] words is ||| [class]	count=3
function	a dict representation ||| as dict	count=1
function	system ||| linear system	count=1
class	dyadic in ||| dyadic	count=1
arg	[arg_1] order ||| [arg_1] [arg_2]	count=2
function	and ||| get mod func	count=1
module_class	and [module_1] [class_2] ||| [module_1] vector [class_2]	count=2
arg	of fpgroup h a ||| h	count=1
arg	only func remains ||| func hint	count=1
function	solve the equation using ||| solve as	count=1
function	an inverse gamma ||| gamma inverse	count=1
function	to a dict representation ||| dict	count=1
function	direction cosine ||| direction cosine	count=2
arg	[arg_1] interval ||| [arg_1] [arg_2]	count=9
function	square-free factors ||| sqf list include	count=1
arg	f at a in ||| f i a	count=1
function	gets the binary ordered ||| unrank binary	count=1
arg	find optimization opportunities ||| exprs order	count=1
arg	g functions ||| g	count=1
function	finds the domain of ||| in	count=1
class	counterparts ||| with limits	count=1
arg	function f applied ||| f	count=1
function	the bitlist corresponding ||| bitlist	count=1
function	point of a ||| point	count=1
arg	new key value ||| key value	count=2
function	couple ||| couple	count=1
function	of the functions ||| in	count=1
arg	[arg_1] [arg_2] is a plaintext message ||| [arg_2] [arg_1]	count=2
function	and is thus ||| is singleton	count=2
function	floating point number ||| float	count=1
arg	in ||| exprs	count=1
function_arg	in gf [arg_2] ||| [function_1] irreducible n [arg_2]	count=2
arg	[arg_1] the variable ||| [arg_2] [arg_1]	count=3
function_arg	[function_1] point center ||| [function_1] [arg_2]	count=3
class	adaptively ||| line over1drange series	count=1
arg	k of the first ||| k	count=1
arg	complexes such that ||| complexes	count=1
function	path to ||| get	count=2
arg	and n is prime ||| n	count=1
function	of a differential equation ||| ode	count=1
function	the content ||| as content	count=1
function	to find 'executable' ||| find	count=1
function	sort ||| sort	count=4
arg	z of ||| z	count=1
class	object ||| series	count=1
arg	polynomials g ||| g	count=1
class	with the ||| code	count=1
class	and complex ||| complex	count=1
arg	f and for ||| a d de	count=1
function	coefficient of a ||| coeff	count=7
function	list of native ||| from list	count=1
function	a common [function_2] ||| [function_2] [function_1]	count=8
class	quaternion orientation orients ||| quaternion	count=1
arg	z_p for i ||| p	count=1
arg	f and ||| a d de	count=1
class	returns the ||| seq base	count=1
arg	system's origin ||| variable_names	count=1
function	rationalize num/den by ||| rad rationalize	count=2
function	indices [function_2] ||| [function_2] from [function_1]	count=2
function	subtract c(x_2 x_u)*x_0**i from ||| sub term	count=1
function	[function] roots ||| [function]	count=9
function	a to ||| to	count=10
arg	calculates ||| iszerofunc	count=1
function	module of ||| module	count=1
function	constant coefficients using the ||| constant	count=1
function	simplified ||| simplified	count=1
arg	\; j_2 ||| j_2	count=1
function	list of operators ||| operators	count=1
arg	b modulo [arg_2] ||| [arg_2] a [arg_1]	count=3
arg	s [arg_2] ||| [arg_1] [arg_2]	count=4
arg	[arg_1] fringe ||| [arg_2] [arg_1]	count=1
function	an fisher's z ||| fisher z	count=2
class	space rotation is ||| space	count=1
function	an sdm from a ||| sdm from	count=1
function	[function] the ||| [function]	count=2
function	conjugate of a ||| conjugate	count=1
class	a ||| set	count=1
function	best solution ||| coeff best	count=1
arg	subcircuit [arg] another ||| circuit subcircuit [arg]	count=1
function_arg	[function_1] g in ||| [arg_2] [function_1]	count=3
class	space rotation is ||| space orienter	count=1
arg	of terms of f ||| f m n	count=4
function	commutator of self and ||| commutator	count=1
function	lcm over a field ||| ff lcm	count=2
function	returns a 3-tuple a ||| three	count=1
arg	j_4 j_5 j_6) ||| j_4	count=1
class	of this module ||| module	count=2
class	the object excluding ||| series	count=1
function	adjacency distance between ||| get adjacency distance	count=2
class	the bessel-type ||| bessel base	count=1
module	space characters to ||| utilities	count=1
function	the primitive form of ||| primitive	count=2
function	the square root in ||| sqrt	count=1
function_arg	[function_1] p [x] ||| [function_1] sub f g [arg_2]	count=1
function	and ||| cse	count=1
function	potential difference ||| potential difference	count=2
module	returns true if the ||| physics	count=1
function	dispatch a method to ||| dispatch method	count=1
arg	objects ||| objects	count=2
function	a is of type ||| of type	count=1
function_arg	[function_1] multiplication element-wise ||| [arg_2] [function_1]	count=3
function	is zero-dimensional ||| is zero dimensional	count=4
module	the index ||| physics	count=3
function	helper for _solve ||| tsolve	count=1
function	create function with name ||| create function	count=1
function	the lexicographic ranking ||| rank lexicographic	count=1
module	in terms ||| sets	count=1
arg	k0 ||| u k0	count=1
function	convert an algebraic number ||| algebraic field	count=1
arg	integral fac*g where g ||| g	count=1
function	it if ||| pretty try	count=1
function	find [function_1] [function_2] ||| [function_2] [function_1]	count=4
arg	[arg_1] d with ||| [arg_2] [arg_1]	count=2
function_arg	gcd [arg_2] ||| [arg_2] [function_1]	count=22
class	subset of the ||| subset	count=1
arg	base b modulo ||| b	count=3
function	[function_1] a zero ||| [function_2] [function_1]	count=6
arg	of polynomials g ||| g	count=1
arg	a k[x] ||| u k zero	count=1
arg	expression e x ||| e x	count=2
module	expected to ||| logic algorithms	count=3
module	see if ||| printing pretty	count=1
arg	that ||| expr exp	count=1
arg	f x ||| x	count=1
module_class	[module_1] of stringpicts ||| [module_1] string [class_2]	count=1
arg	for fast calculation of ||| args expr modules printer	count=1
function	the level ||| level	count=1
function	unit ||| print unit base	count=1
function	negate a ||| neg	count=2
function	[function_1] trivial ||| [function_1] [function_2]	count=1
arg	return complexes such ||| complexes	count=1
function	of symbolic ||| param dict	count=1
arg	or multiplicative separation ||| fun sep strategy	count=1
function_arg	this function [arg_2] ||| [arg_2] [function_1]	count=1
function	subset defined ||| get subset from	count=1
arg	expression ||| expr deep combine	count=1
function	[function_1] transversals from ||| [function_1] [function_2]	count=1
function	eye ||| matrix eye	count=2
arg	mul sorted ||| mul	count=1
function	of zeros square ||| zeros	count=2
arg	g in ||| g	count=1
class	this sparsematrix ||| matrix	count=1
function	the leading term of ||| sdm lt	count=1
function	concatenates ||| join	count=2
function	to a sympy ||| to sympy	count=8
arg	of f ||| f n k	count=1
arg	differential equations in eq ||| eq funcs	count=1
module	in ||| physics	count=1
function_arg	negate [arg_2] ||| [arg_2] [function_1]	count=2
arg	[arg_1] j_2 m_2 ||| [arg_2] [arg_1]	count=1
arg	and g which are ||| g	count=1
module	object ||| series	count=1
arg	dum ||| dum	count=1
class	standard basis ||| sub module poly	count=1
function	name of the class ||| func	count=1
function_arg	irreducible [arg_2] ||| [arg_2] [function_1]	count=2
arg	k0 and k1 ||| k0 k1	count=1
function	of singularity [function_2] ||| [function_1] [function_2]	count=1
arg	the base-2 digits ||| n_bits	count=1
function_arg	generates [function_1] [arg_2] as a permutation group ||| [function_1] [arg_2]	count=1
function	the bottom ||| bottom	count=1
class	total number of ||| g	count=1
function	solves the quadratic ||| quadratic	count=1
function	classes to ||| operators to	count=1
function	lower central series for ||| lower central series	count=1
function	circumcenter is the center ||| circumcenter	count=1
function	system using lusolve ||| linear system lu	count=1
function	module and the ||| mod func	count=1
function	indices replaced by indices ||| call	count=1
function	positive [function] ||| [function]	count=2
function	[function_1] line plot ||| [function_2] [function_1]	count=1
arg	disjoint and sort ||| complexes	count=1
arg	addition expression and ||| expr	count=1
function	a list representation ||| as list	count=1
class	a ||| base	count=1
arg	[arg_1] z of ||| [arg_1] [arg_2]	count=2
arg	optimization ||| exprs order	count=1
function	[function_1] fermi? ||| [function_2] [function_1]	count=8
function	ode are ||| linear 2eq order1 type4	count=1
function	next to ||| next	count=1
function	replaced by indices examples ||| call	count=1
function	classes to their associated ||| to	count=1
module_class	[module_1] coordinate system ||| [module_1] [class_2]	count=6
function	ring i ||| ring	count=2
function	memoized version of ||| memoize	count=1
arg	[arg_1] d ||| [arg_1] [arg_2]	count=2
function	angular [function_2] ||| [function_1] [function_2]	count=1
arg	isolating interval of a ||| eps	count=2
function	prints ||| print	count=2
function	generates the [function] group ||| [function]	count=1
function	the degree ||| find degree	count=1
arg	nonhomogeneous euler eq ||| eq	count=1
function	euclidean ||| euclidean algorithm	count=1
arg	varying t from 0 ||| t	count=1
class	of coset ||| coset	count=3
function	[function_1] a list ||| [function_1] [function_2]	count=5
arg	\eta to be ||| match comp	count=1
function	letter representation of a ||| letter form	count=1
function_arg	[function_1] no = ||| [arg_2] [function_1]	count=2
function	series of [function_2] ||| [function_2] [function_1]	count=2
arg	real inverse_mellin_transform function ||| s x_ strip	count=1
function	scan ||| scan	count=4
arg	backend ||| backend	count=1
function	the proper ||| get	count=1
function	the axis [function_2] ||| [function_2] [function_1]	count=1
module	of the polyhedra ||| combinatorics	count=1
arg	in k[x] ||| f m u k	count=1
class	point of ||| point	count=1
arg	mul sorted in ||| mul	count=1
arg	a diagram and the ||| diagram grid	count=1
arg	running it on the ||| fns	count=2
function_arg	[function_1] [arg_2] ||| [function_1] list include [arg_2]	count=12
function	and the name ||| func	count=1
function	the series expansion ||| intcurve series	count=1
function_arg	in gf [arg_2] ||| [function_1] gcdex f g [arg_2]	count=2
arg	[arg_1] on ||| [arg_1] [arg_2]	count=4
module_class	if 'self' is ||| sets interval	count=1
class	basis in ||| sub module poly	count=1
function	simplified set ||| simplified pairs	count=2
arg	return the root if ||| cls root	count=1
function	a rational ||| rational	count=4
module	number [module] ||| physics [module]	count=1
module	units ||| units	count=2
function	evalf ||| eval evalf	count=2
function	the product of ||| mul	count=1
class	exploiting the ||| sparse matrix	count=1
function	set attributes that are ||| attrs	count=1
function	class into a string ||| get mod	count=1
arg	[arg_1] with ||| [arg_1] [arg_2]	count=1
function	[function_1] generators in ||| [function_2] [function_1]	count=1
function	[function_1] sentinel of ||| [function_1] [function_2]	count=1
function	above ||| only above	count=1
class	a root it ||| root system	count=1
arg	x_0 from ||| u k	count=1
module_class	the [class_2] ||| [module_1] [class_2] arbitrary point	count=1
class	[class] at ||| [class]	count=3
class	rectangular form or ||| region	count=1
function	coefficients [function_2] ||| [function_2] [function_1]	count=2
function	polynomial ring i e ||| old poly ring	count=1
arg	constructing the string representation ||| morphisms_str_info	count=1
function	is available and leverage ||| pretty try	count=1
function_arg	their [arg_2] ||| [function_1] subs expr [arg_2]	count=1
arg	morphism and its attributes ||| morphism props add_identities	count=1
arg	f from ||| f	count=2
arg	a polynomial in k[x] ||| u k	count=2
function	with zero elements examples ||| empty	count=1
function	sorting key such that ||| sort key	count=1
arg	of f and ||| a	count=1
function	if a matrix is ||| is	count=1
arg	p [x] ||| f p k	count=6
function	the series ||| series	count=2
function	try to recognise a ||| try	count=1
arg	domain for which ||| domain	count=1
function	[function] coordsyscartesian with ||| orient [function]	count=3
function	extracted [function] y - ||| [function]	count=1
function	[function_1] of k ||| [function_1] [function_2]	count=2
function	real ||| count real	count=2
function	polynomial exact pseudo-quotient of ||| pexquo	count=1
arg	quantum number n ||| n m r	count=1
arg	indices are ||| indices free	count=1
function	[function_1] lagrange's ||| [function_2] [function_1]	count=1
class	that no bounding rectangles ||| complex root	count=1
function	make all coefficients positive ||| abs	count=1
class	where p[i] > p[i+1] ||| permutation	count=1
arg	[arg_1] to k[x][y] ||| [arg_1] [arg_2]	count=1
function	a pivot ||| reasonable pivot	count=1
arg	in the index ||| index	count=1
function_arg	[function_1] [arg_2] ||| [function_1] quo f g [arg_2]	count=4
arg	solves a transcendental equation ||| eq sym	count=1
class	complex root to ||| complex root of	count=2
function	[function_1] open ||| [function_1] [function_2]	count=1
arg	old -> new ||| old new	count=2
arg	g and [arg_2] ||| [arg_1] [arg_2]	count=1
arg	a model or ||| expr model	count=1
function	of native ||| native	count=1
function	formats a ||| get	count=1
function	domain where ||| where	count=1
function	x start ||| process	count=1
function	of a gf ||| gf	count=1
function	line [function_2] ||| [function_2] [function_1]	count=2
arg	of gen in ||| gen	count=1
function_arg	normalize a [arg_2] ||| [function_1] [arg_2]	count=1
function	transformation matrix ||| transformation	count=1
function_arg	[function_1] alpha ||| [arg_2] [function_1]	count=13
function	for the taylor ||| taylor	count=1
function	identity [function_2] ||| [function_2] [function_1]	count=1
class	a sequence ||| poly	count=1
function	outputargument inoutargument and result ||| result	count=1
function	momentum ||| momentum	count=1
function	be triangularized ||| create ma	count=1
class	convert a poly ||| poly	count=1
function	always create ||| is only	count=2
arg	subgroup [arg] using the ||| [arg]	count=1
class	a poly ||| poly	count=1
function_arg	a transversal of the [function_1] [arg_2] second method described in ||| [function_1] [arg_2]	count=2
function	assuming [function] >>> x ||| [function]	count=1
module_class	[module_1] [class_2] it has no undefined ||| [module_1] [class_2]	count=2
arg	of a base and ||| base	count=1
module	block matrices ||| matrices	count=1
module	in ||| simplify	count=1
arg	construct a ||| cls rep	count=3
arg	of length n ||| cls n	count=1
arg	with respect to x ||| x	count=2
arg	levels in ||| k	count=1
arg	two permutation groups ||| other	count=1
arg	of length n ||| n	count=1
arg	a rule ||| rule	count=4
function	apply the [function_2] ||| [function_2] [function_1]	count=1
class	affine [class] containing all ||| [class]	count=1
function	[function_1] [function_2] ||| polys [function_2] [function_1]	count=4
arg	indices are covariant or ||| indices	count=1
arg	smaller than limit or ||| limit	count=1
arg	through [arg] ||| [arg]	count=1
function	polynomials from ||| parallel poly from	count=2
module	of the ||| functions	count=1
module	the faces ||| combinatorics	count=1
function	heuristic uses the following ||| heuristic function	count=1
function	a sequence in the ||| sequence	count=1
arg	a in the ||| a	count=2
function	the given ||| indent	count=1
function	find ||| opt cse	count=2
class	mapping of symbolic ||| llvmjit	count=1
function	returns a standard basis ||| groebner	count=1
function	a minimal groebner basis ||| minimal	count=1
function	refine a positive root ||| dup inner refine real root	count=1
arg	same as find_pure_symbol ||| symbols unknown_clauses	count=1
function	sdm from ||| sdm from	count=2
module	of block matrices ||| matrices	count=1
function	roots in ||| roots	count=1
arg	first order [arg_2] ||| [arg_2] [arg_1]	count=1
function	taylor [function_2] ||| [function_1] [function_2]	count=1
function	distance between ||| distance	count=2
function	it if possible ||| pretty try use	count=1
function_arg	[function_1] p ||| [function_1] ddf shoup f [arg_2]	count=2
module	below the fermi ||| physics	count=3
function_arg	[function_1] of expr ||| [function_1] min pow [arg_2]	count=3
module	and leverage it ||| printing	count=1
function	domain quotient ||| quotient domain	count=1
arg	domain of ||| domain	count=1
arg	model ||| model	count=3
function	the series ||| rs	count=1
function	an ideal ||| ideal	count=1
function	copy ||| copy	count=2
arg	[arg_1] a beta ||| [arg_2] [arg_1]	count=1
class	the generated ||| octave code gen	count=1
function_arg	gf [arg_2] ||| [function_1] irreducible n [arg_2]	count=2
function	intersection of ||| intersection	count=3
arg	x of degree ||| x	count=2
module	functions ||| calculus	count=1
arg	symbol with ||| symbol	count=1
function	cholesky decomposition l ||| cholesky	count=1
function	coding to [function_2] ||| [function_2] [function_1]	count=1
function	subset defined by the ||| get subset	count=1
arg	morphisms of a ||| morphisms	count=1
module	in ||| polys agca	count=2
function	square-free factorization ||| sqf	count=2
function	a common header for ||| header	count=2
class	faces of the polyhedra ||| polyhedron	count=1
function	relative accuracy [function] number with ||| [function]	count=1
class	the proper ||| code	count=1
arg	the mapping in rules ||| rules x	count=1
function	if possible ||| pretty try use	count=1
arg	[arg] as a ||| [arg]	count=2
class	of this matrix ||| matrix	count=2
function	closing ||| ending	count=1
function_arg	[function_1] prec ||| [arg_2] [function_1]	count=1
class	identity ||| quotient module	count=1
function_arg	[function_1] p ||| [function_1] f g [arg_2]	count=2
function	[function_1] gate with ||| [function_1] [function_2]	count=1
arg	n data ||| n	count=1
arg	mul ||| mul	count=1
class	root system ||| root system	count=3
function	returns the best ||| coeff best	count=1
function	of degrees ||| degree	count=1
arg	a/d ||| d de z	count=1
arg	of an expression ||| expr a	count=1
function	the [function] of ||| [function]	count=1
class	a dense matrix with ||| matrix	count=1
class	basis ||| sub module poly ring	count=2
function	code parameters ||| code	count=1
function	[function] which ||| killable [function]	count=2
arg	stringpict and ||| unicode	count=1
function	[function] in ||| [function] hex	count=3
function	symbolic values ||| create param	count=1
function	[function] of ||| continued fraction [function]	count=3
arg	the property prop ||| prop	count=1
function	the cartan ||| cartan	count=1
function	minimal polynomial ||| minpoly op algebraic	count=1
function	the best ||| homogeneous coeff best	count=1
function	this method ||| free	count=1
arg	[arg_1] using _dcm_dict ||| [arg_2] [arg_1]	count=1
function	the finite ||| finite	count=1
function	multivariate series ||| rs	count=2
arg	p x ||| p x	count=4
module	return iterator ||| utilities	count=1
function	direct product of ||| mul	count=1
function	function function ||| function	count=1
arg	an expression ||| cls expr x	count=1
arg	alpha ||| alpha pairs	count=1
class	latex knows ||| latex	count=1
module	specific value ||| series	count=1
module_class	[module_1] wave ||| [module_1] optics [class_2]	count=5
arg	variable with ||| name k	count=5
class	bounding ||| root	count=1
arg	[arg] that it ||| [arg]	count=1
function_arg	[function_1] p with ||| [arg_2] [function_1]	count=5
function	and ||| and	count=5
function	ground n-th coefficient of ||| dmp ground nth	count=1
arg	[arg_1] z at ||| [arg_2] [arg_1]	count=4
arg	to to_j, where ||| from_i to_j	count=1
function	them [function] its ||| drop [function]	count=1
function	symbolic values to ||| param dict	count=1
function	- g*h ||| sub mul	count=5
module_class	the default [class_2] ||| [module_1] [class_2]	count=2
function	real element ||| real field	count=1
arg	set of points ||| func points	count=1
function	objects by distributing ||| tensors from	count=1
function	heuristic uses the ||| heuristic	count=1
function	body ||| body	count=1
function	differentiate and evaluate a ||| diff eval in	count=1
function	match' [function] of ||| kmp [function]	count=1
function	polynomial to [function_2] ||| [function_2] [function_1]	count=1
function	a rational number \frac ||| integer rational	count=1
arg	take a ||| m	count=1
function_arg	[function_1] [arg_2] ||| [function_1] factor sqf f [arg_2]	count=4
module	containing the ||| physics mechanics	count=2
class	inverse ||| discrete distribution	count=1
arg	x note that it ||| x	count=1
module	product [module] x ||| [module]	count=1
module	the tree ||| combinatorics	count=1
function_arg	cos [arg_2] ||| [function_1] [arg_2]	count=3
function	normal order a multiplication ||| normal order	count=1
function	of the nth root ||| nth root	count=1
arg	a field in a ||| field	count=1
class	parameter ||| ray transfer	count=4
function_arg	the inverse [arg_2] ||| [function_1] [arg_2]	count=3
function	lie ||| lie	count=1
arg	[arg_1] polynomial ||| [arg_2] [arg_1]	count=6
arg	function f x ||| f x	count=2
arg	if n ||| x n	count=1
arg	levels in [arg_2] ||| [arg_2] [arg_1]	count=4
function	loop morphism ||| loop morphism	count=1
function	generator for ||| gen	count=1
function	is available and ||| pretty try use	count=1
arg	[x] and ||| k	count=1
function	sort of graph's ||| sort	count=1
function	at ||| at	count=1
arg	radial wavefunction r_{nl} for ||| nu r	count=1
function	returns whether each coordinate [function_1] [function_2] ||| geometry point [function_1] [function_2]	count=4
arg	[arg_1] z )[x] ||| [arg_2] [arg_1]	count=8
function	ground domain ||| dmp	count=2
function_arg	sequence [arg_2] ||| [arg_2] [function_1]	count=1
arg	one of the factors ||| factors x	count=1
function	a [function] ||| as [function]	count=3
arg	is_simple self x ||| x	count=1
function	of undetermined ||| coeff undetermined	count=1
arg	lexical closure to ||| name latexname	count=1
function	tuple ||| as real	count=1
function	returns electric permittivity ||| permittivity	count=1
function	direction vector of ||| direction	count=1
arg	factors has ||| factors x	count=1
arg	function for ||| expression	count=1
function	subset defined by the ||| get subset from	count=1
function	which gives ||| 1st	count=1
class	side of the relation ||| relational	count=2
arg	a mobius transform or ||| eps	count=1
class	ending ||| code	count=1
function	[function_1] z[x] ||| [function_2] [function_1]	count=5
arg	indices on the components ||| components	count=1
arg	the given order order ||| order	count=1
function_arg	[function_1] [arg_2] ||| [function_1] sub [arg_2]	count=2
class	return a ||| frac field	count=1
function	[function_1] potential function ||| [function_1] [function_2]	count=6
arg	of ||| x y	count=5
arg	a circuit ||| circuit	count=1
function	part of a mul ||| mul	count=1
arg	dx using g functions ||| g	count=1
module	where p[i] > ||| combinatorics	count=1
arg	and e ||| e	count=1
function	return transpose ||| transpose	count=1
module	new symbol [module] ||| [module]	count=3
arg	coefficient ||| exprs	count=1
arg	the g function g ||| g	count=1
arg	f in k[x], ||| f u	count=1
function	be ||| process	count=1
function	heuristic ||| qq heu	count=1
function	whether there is free ||| check free	count=2
function	telescopic property ||| telescopic	count=1
arg	a ||| a b w	count=1
function	[function] closure ||| [function]	count=2
arg	diagram and the object ||| diagram grid	count=1
arg	alpha beta x ||| x	count=1
class	used ||| base	count=1
function	is redundant ||| is	count=1
function_arg	check [arg_2] ||| [function_1] [arg_2]	count=2
function	method ||| free	count=1
module	leverage it if ||| pretty	count=1
module	of ||| functions	count=2
arg	[arg] are comparable ||| a [arg]	count=1
function_arg	gcd self other ||| gcd other	count=1
arg	d with key ||| d key	count=2
function_arg	form [arg_2] ||| physics quantum normal ordered [function_1] [arg_2]	count=2
class	ideal ||| ideal	count=6
arg	operator in a ||| op	count=1
function_arg	square-free polynomial [arg_2] ||| [function_1] [arg_2]	count=2
arg	operator [arg_2] ||| [arg_2] [arg_1]	count=1
arg	of f with respect ||| f	count=2
arg	series expansion of ||| prec	count=1
class	coordinate ||| point3d	count=2
function_arg	interval for the ||| interval parameter	count=2
function	lcm over a ||| dmp ff lcm	count=2
arg	orbits of indices in ||| indices	count=1
arg	[arg_1] scipy ||| [arg_2] [arg_1]	count=8
function	replace ||| simplify	count=1
function	all monomials from a ||| all monoms	count=1
module	self with oth, ||| polys agca	count=1
function	solves the quadratic ||| quadratic normal	count=1
arg	z is ||| z tol	count=1
arg	the list of ||| expr x	count=1
arg	p for ||| p	count=1
function_arg	module [arg_2] ||| [function_1] [arg_2]	count=2
arg	polynomial in [arg_2] ||| [arg_2] [arg_1]	count=5
function	[function_1] monomial order ||| [function_2] [function_1]	count=1
function	computes the gauss-lobatto ||| lobatto	count=1
function	matrix ||| matrix	count=29
function	[function_1] their coefficient ||| [function_2] [function_1]	count=1
arg	indices in ||| indices	count=1
arg	system wrt a given ||| coord_sys	count=1
class	to ||| code	count=1
function	of indices ||| indices	count=1
arg	passed ||| ops	count=1
arg	[arg] for ||| eqs [arg]	count=2
function	equations of motion ||| comb	count=1
function	[function_1] moment of ||| [function_1] [function_2]	count=1
class	of non-conjugate ||| of	count=1
function	the substitution ||| subs	count=1
function	system using ||| linear system lu	count=1
arg	field ||| field coord_sys	count=1
arg	< d and d ||| d	count=1
arg	of cls given a ||| cls rep lev dom	count=2
module	start stop ||| series	count=1
function_arg	[function_1] condition ||| [arg_2] [function_1]	count=1
function	transform of f, defined ||| transform	count=3
function	next lexicographically ordered ||| next lexicographic	count=2
class	of this ||| sparse matrix	count=1
class	this ||| linear	count=1
arg	a small'' matrix ||| deg_f deg_g row1 row2	count=1
arg	terms using qm method ||| terms	count=1
class	returns a standard basis ||| sub	count=1
function	a common absolute value ||| process common	count=1
arg	of [arg_2] ||| [arg_2] [arg_1]	count=9
class	dmension ||| type d	count=1
function	code by ||| code	count=1
module	order form the ||| physics	count=1
module	method returns the ||| series	count=1
arg	[arg_1] | j_3 ||| [arg_2] [arg_1]	count=2
class	if the function ||| function	count=1
function	log ||| log	count=2
arg	prec , rs\_sin p ||| p	count=1
function	for meijer g functions ||| meijer	count=1
arg	of i by ||| i	count=1
function_arg	orbit [arg_2] ||| [function_1] transversal [arg_2]	count=3
function	best solution to an ||| homogeneous coeff best	count=1
function	real roots of ||| real roots	count=10
function	[function_1] matrices ||| [function_2] [function_1]	count=2
function_arg	[function_1] for ||| [arg_2] [function_1]	count=9
function	reduce the ||| reduce	count=1
function	of fn -n x ||| dup spherical bessel fn minus	count=1
function	bounding rectangles of ||| complexes	count=1
function	same ||| find unit	count=1
function	common ||| common	count=3
function	echelon form given ||| rref	count=1
function_arg	[function_1] of alpha ||| [function_1] [arg_2]	count=6
function	convex [function_2] ||| [function_1] [function_2]	count=3
function	using ||| modgcd	count=1
function	redirect an [function_2] ||| [function_2] [function_1]	count=2
function_arg	concatenates two ||| col join other	count=1
function	init ||| init	count=1
arg	g are polynomials ||| g	count=1
function	the bending [function_2] ||| [function_1] [function_2]	count=2
arg	of self and b ||| b	count=1
arg	z is correct ||| z	count=1
arg	f ||| f all	count=2
module	interactive session ||| interactive	count=1
function	[function_1] fraction to ||| [function_2] [function_1]	count=4
function	coincidence routine ||| coincidence c	count=1
class	domain that contains elements ||| domain	count=1
function	the cartan [function_2] ||| [function_1] [function_2]	count=4
arg	[arg_1] on input ||| [arg_1] [arg_2]	count=2
arg	model or ||| model	count=1
function	[function_1] symbols ||| [function_1] [function_2]	count=5
class	in ||| poly ring	count=2
function	bottom nodes first ||| bottom	count=1
function	compute f - a ||| sub	count=1
function	leverage ||| use	count=1
module_class	number of [class_2] ||| [module_1] [class_2]	count=2
function	= [function] ||| [function]	count=2
function	constant ||| get constant	count=1
function	minimal polynomial for ||| minimal polynomial	count=2
class	elements of the matrix ||| sparse matrix	count=1
arg	with h ||| h base	count=1
function	inversion 1/p ||| inversion	count=1
function	using lu decomposition ||| lu	count=2
function	-> a/b -> ||| as numer denom	count=1
arg	j parameters ||| j	count=1
class	a ||| code	count=2
function	[function_1] superset ||| [function_2] [function_1]	count=2
class	standard basis in ||| sub module poly ring	count=1
arg	helper to tell whether [arg_1] [arg_2] ||| [arg_1] [arg_2]	count=3
function	polynomial lcm over ||| ff lcm	count=1
class	return the ||| matrix base	count=1
function	be extracted [function] y - ||| [function]	count=1
class	those that take on ||| series base	count=1
arg	f in ||| f u k	count=3
arg	a condition [arg_2] ||| [arg_2] [arg_1]	count=1
function	[function_1] product ||| [function_1] [function_2]	count=12
module	corresponding to the ||| physics	count=2
function	expression ||| order terms	count=1
arg	infinitesimals of [arg_2] ||| [arg_2] [arg_1]	count=1
class	for f ||| rep	count=1
function	inverse ~a of a ||| af invert	count=1
function	substitution [function_2] ||| [function_1] [function_2] eq func	count=1
class	accumulationbounds object is ||| accumulation bounds	count=2
function	a property where the ||| memoize property	count=1
function	maxwell ||| maxwell	count=1
class	value (i ||| base	count=1
function	of a mul ||| mul	count=2
class	of g_2 ||| type g	count=1
function	the string path ||| get	count=1
arg	deg_g ||| deg_g	count=1
function	a laplace ||| laplace	count=1
function_arg	domain where [arg_2] ||| [function_1] [arg_2]	count=1
arg	mod(p** s + ||| s p	count=1
class	standard ||| module	count=1
function	in gf p [x] ||| gf	count=3
arg	g is the ordering ||| g	count=1
arg	[arg] for ||| [arg]	count=2
function	addends of ||| addends	count=1
class	of the linearentity ||| linear entity	count=1
function	switch to another ||| to	count=1
arg	the grid ||| grid	count=1
class	the ||| linear	count=2
arg	[arg_1] key ||| [arg_2] [arg_1]	count=3
module	the phase ||| physics	count=1
module	c > 0 and ||| solvers	count=1
class	matrix ||| matrix	count=22
function	cz^2 + ||| to normal	count=1
function	which comes under this ||| linear 2eq order2 type11	count=1
class	no bounding ||| root of	count=1
arg	a ||| a prec	count=1
function	[function_1] [function_2] objects from sequences returns ||| [function_1] [function_2] inds	count=1
function	anp object ||| algebraic field	count=3
function	function is monotonic ||| is monotonic	count=1
function	symbol for undefined ||| symbol	count=1
function	which comes under ||| linear 2eq order2 type11	count=1
arg	polynomials in [arg_2] ||| [arg_2] [arg_1]	count=3
module	object excluding ||| series	count=1
arg	in adds muls pows ||| order verbose	count=1
arg	a single ||| a b w	count=1
class	polyhedra we ||| polyhedron	count=1
arg	of factors [arg_2] ||| [arg_2] [arg_1]	count=2
arg	whether indices are covariant ||| indices free dum	count=1
arg	with respect to t ||| t	count=1
function	refractive [function_2] ||| [function_1] [function_2]	count=1
module	sympy ||| physics quantum	count=3
function	potential difference between two ||| potential difference	count=1
function	indices of ||| indices	count=1
function	element which ||| element	count=1
arg	if gcd a p ||| a p	count=1
module	to perform [module_2] ||| [module_1] [module_2]	count=1
function_arg	leading term [arg_2] ||| [function_1] [arg_2]	count=1
function	minimal degree for each ||| min	count=1
class	default from which docstrings ||| doc tests	count=1
arg	[arg_1] after subtracting ||| [arg_1] [arg_2]	count=2
function	evaluate ||| eval in	count=2
function_arg	to rotate [arg_2] ||| [arg_2] [function_1]	count=1
function	with the proper ||| get statement	count=1
function	this method returns the ||| free	count=1
function	[function_1] all tests ||| [function_1] [function_2]	count=1
class	c code ||| code	count=1
function	[function_1] [function_2] ||| [function_2] q [function_1]	count=4
arg	an expression to optimize ||| expr	count=1
module	polynomial ||| holonomic	count=1
function	compute ||| modgcd multivariate p	count=1
arg	f to all ||| f atoms nonbasic	count=1
class	the polynomial p by ||| poly	count=1
class	hole ||| annihilate fermion	count=3
module	the basis ||| physics	count=1
function	full ||| apart list full	count=1
function	domain of the ||| in	count=1
function_arg	[function_1] alpha as ||| [arg_2] [function_1]	count=7
function	helper function of pdsolve ||| helper simplify	count=1
arg	binary representation of n ||| n	count=1
function	atanh ||| rs atanh	count=2
function	test for ||| test	count=1
arg	selected by ||| func args	count=2
module	calculates the ||| physics	count=2
function_arg	[function_1] expression ||| [arg_2] [function_1]	count=2
function	2d n-link pendulum on ||| link pendulum on	count=1
arg	splits ||| callback	count=1
function	domain ||| not empty	count=1
function	differentiate and evaluate ||| dmp diff eval in	count=1
arg	p where t = ||| p t	count=1
class	of coset enumeration described ||| coset	count=2
function	codomain replaced ||| quotient codomain	count=1
function_arg	[function_1] [arg_2] ||| [function_1] edf zassenhaus f [arg_2]	count=6
function	horizontal morphism [function_2] ||| [function_2] free space [function_1]	count=1
function	canonical [function] storing them ||| process [function]	count=1
function	refine ||| outer refine real	count=1
class	[class_1] the lagrange ||| [class_2] [class_1]	count=2
function	unicode output is available ||| try use unicode	count=1
function	into a sparse ||| to	count=1
function_arg	[function_1] two ||| [function_1] [arg_2]	count=14
module	p[i] ||| combinatorics	count=2
function	codomain replaced by ||| quotient codomain	count=1
function	true ||| literal	count=1
function_arg	interval for ||| interval parameter	count=2
module	optimization ||| simplify	count=1
arg	of order n in ||| n	count=1
module	first order form the ||| physics	count=1
function	and return the result ||| indent	count=1
function	velocity ||| velocity	count=1
function	adds ||| add morphism	count=1
arg	running it on ||| brule fns	count=1
function	scalar potential [function_2] ||| [function_1] [function_2]	count=4
module_class	[module_1] gray code ||| [module_1] [class_2]	count=2
function	run [function_2] ||| [function_1] [function_2]	count=2
function	always ||| is only q	count=1
function	is consistent ||| is consistent	count=2
function	product of [function_2] ||| [function_1] [function_2]	count=1
function	foci ||| foci	count=1
function	find the minimum ||| min	count=1
arg	system key must be ||| key	count=1
function	[function_1] multiple ||| [function_2] [function_1]	count=5
arg	for computation ||| expr	count=2
arg	of two polynomials ||| g	count=7
arg	the root if it ||| root	count=1
function_arg	[function_1] gcd a ||| [function_1] [arg_2]	count=5
arg	and y after subtracting ||| y z	count=1
arg	multiplicities of factors using ||| f factors	count=1
class	of ||| code	count=1
arg	private key [arg_2] ||| [arg_2] [arg_1]	count=2
function	a hypergeometric ||| hyper	count=1
function_arg	a_j [arg_2] ||| [function_1] [arg_2]	count=2
function	evaluate a ||| eval	count=2
function	[function_1] denominator ||| [function_2] [function_1]	count=2
function	given metric ||| metric to	count=2
class	no bounding ||| root	count=1
function	is ||| in	count=1
function	apply ||| apply	count=7
module	faces ||| combinatorics	count=1
function_arg	[function_1] p [x] ||| [function_1] [arg_2]	count=4
function	classes to their associated ||| operators to	count=1
function_arg	[function_1] m ||| [arg_2] [function_1]	count=2
arg	f x ||| cls x	count=1
arg	[arg_1] = a ||| [arg_2] [arg_1]	count=17
arg	the series expansion of ||| prec	count=1
function	a list of transpositions ||| transpositions	count=1
function	is that dummies ||| get ordered dummies	count=1
arg	and \eta ||| match comp	count=4
function_arg	[function_1] a in ||| [function_1] expr [arg_2]	count=4
function_arg	[function_1] x_j ||| [function_1] f m a [arg_2]	count=2
module	lower triangular matrix ||| matrices	count=1
function	conjugate of ||| conjugate	count=1
function	a string path to ||| func	count=1
function	compute roots in ||| roots	count=1
arg	from intqubit to ||| qubits	count=1
function	heuristic ||| heuristic bivariate	count=1
function	given ||| dict from expr if	count=2
function_arg	autonomous system [arg_2] ||| [arg_2] [function_1]	count=3
arg	k == 2 and ||| k	count=1
function	new rootsystem object ||| new	count=1
class	this ||| sparse	count=1
arg	a scalar [arg_2] ||| [arg_1] [arg_2]	count=3
function	bitlist of length ||| bitstring	count=1
class	specific ||| series	count=1
class	whose elements have ||| partition traverser	count=1
function	content ||| content	count=2
arg	required for constructing the ||| j grid morphisms_str_info	count=1
module	a [module] that ||| [module]	count=1
function	computes eigenvalues ||| eigenvals	count=1
arg	whether u v ||| u v	count=2
function_arg	remainder [arg_2] ||| [function_1] [arg_2]	count=9
function	expt ||| eval power	count=1
module	position of this ||| vector	count=1
arg	mixed types [arg] integer and ||| [arg]	count=1
function	coefficients ||| coefficients	count=4
arg	[arg_1] and n ||| [arg_2] [arg_1]	count=4
function_arg	according [arg_2] ||| [arg_2] [function_1]	count=1
arg	[arg_1] in c ||| [arg_1] [arg_2]	count=3
function	content [function_2] ||| [function_1] [function_2]	count=1
function	excluding ||| free	count=1
function	[function_1] nilpotent ||| [function_1] [function_2]	count=1
function	finds the domain ||| in	count=1
function	the subset defined by ||| get subset	count=1
function	[function] of the ||| get free [function]	count=1
class	a sparse ||| sparse	count=2
arg	[arg_1] [arg_2] turn is multiplied by ||| [arg_1] [arg_2]	count=6
function	try to ||| try	count=1
module	returns a standard ||| polys agca	count=1
arg	coefficient muls ||| exprs order	count=1
arg	expansion of the ||| p x prec	count=4
function	functions ||| not empty in	count=1
function	is a scalar multiple ||| is scalar multiple	count=1
arg	separated by sep ||| msg sep	count=1
arg	[arg_1] and y ||| [arg_2] [arg_1]	count=4
arg	other lies ||| other	count=1
function	k t ||| k t	count=2
function	the class ||| get	count=1
arg	series expansion of the ||| p x prec	count=4
function_arg	of cos [arg_2] ||| [function_1] [arg_2]	count=1
function	[function_1] well defined ||| [function_1] [function_2]	count=1
function	gray code ||| gray	count=3
function	roots up ||| roots	count=1
function	and return a vector ||| vector	count=1
class	polynomial modulo a groebner ||| groebner	count=1
function	traditional rules ||| traditional	count=1
function	half [function_2] ||| [function_1] [function_2]	count=6
arg	r [arg] ||| r [arg]	count=1
function	given generators ||| expr if gens	count=2
class	of ||| basic	count=1
function	lower central [function_2] ||| [function_1] [function_2]	count=1
function	of the ||| empty	count=1
function	indices [function_2] ||| [function_1] [function_2]	count=2
arg	:func rsolve_hypergeometric for details ||| x re	count=1
arg	required for constructing the ||| grid morphisms_str_info	count=1
class	are generated ||| extension	count=1
function_arg	parameters [arg_2] ||| [function_1] [arg_2]	count=1
arg	i j ||| i j	count=4
arg	supply the ||| qs coneqs forcelist	count=1
function	the adjacency [function_2] ||| [function_2] [function_1]	count=2
module_class	implies [class_2] ||| [module_1] [class_2]	count=26
arg	to t ||| t	count=2
function	ordinary decimal [function_2] ||| [function_1] [function_2]	count=3
function	returns f + ||| dmp add	count=1
arg	object obj, substituting ||| obj	count=1
function	clear denominators in ||| rat clear denoms	count=1
class	the faces ||| polyhedron	count=1
arg	the given plane? ||| l	count=1
function	[function] in hex ||| [function] hex	count=3
arg	helper for _match_div_rewrite ||| f g rexp	count=1
function	of distinct real roots ||| count real roots	count=1
arg	the series expansion of ||| a prec	count=1
function	the logarithm ||| log	count=1
function	coset factorization of ||| coset	count=1
function	construct field [function_2] ||| [function_1] [function_2]	count=2
arg	variable with ||| name alpha	count=1
arg	[arg_1] [arg_2] creates a new ||| stats given [arg_2] [arg_1]	count=2
function	an ordinary ||| ordinary	count=1
arg	internal use by ||| s n	count=1
arg	order [arg_2] ||| [arg_2] infinitesimals func [arg_1]	count=1
class	[class_1] system ||| [class_1] [class_2] dynkin	count=1
function_arg	lcm over [arg_2] ||| [function_1] [arg_2]	count=1
function	the symbol ||| symbol	count=3
arg	[arg_1] base b ||| [arg_1] [arg_2]	count=3
function	the minimal polynomial ||| minpoly	count=3
arg	of square-free ||| polys k eps inf	count=1
function_arg	treats xor [arg_2] ||| [function_1] [arg_2]	count=1
function_arg	[function_1] p ||| [function_1] gcdex f g [arg_2]	count=2
function	whether ||| is expr	count=1
function	dmf object ||| fraction field	count=1
class	partition of ||| partition	count=1
arg	[arg_1] [arg_2] ||| curl [arg_1] [arg_2]	count=2
arg	morphism ||| morphism	count=2
function_arg	centralizer of [arg_2] ||| [function_1] group [arg_2]	count=1
arg	polynomial by index ||| poly index	count=1
function	or create particle if ||| is	count=1
function	return encryption of ||| encipher	count=1
arg	[arg_1] center of ||| [arg_2] [arg_1]	count=4
module	[module] |a|*u_{1}*v_{1} ||| [module]	count=3
function	[function_1] edge the ||| [function_1] [function_2]	count=2
function	return whether [function_1] [function_2] ||| [function_1] [function_2]	count=2
class	return the ||| matrix	count=1
arg	switch to a ||| native zero	count=1
arg	the specified [arg_2] ||| [arg_2] [arg_1]	count=4
arg	g and [arg_2] ||| [arg_2] [arg_1]	count=1
function_arg	[function_1] of expression ||| [arg_2] [function_1]	count=2
class	for the generated ||| octave code	count=1
function	in tensor_can ||| indices canon args	count=1
arg	ode ||| ode	count=1
arg	[arg] \in ||| [arg]	count=6
class	the partition ||| integer partition	count=1
arg	function for the ||| func order	count=2
class	the series ||| series	count=1
function	function to expand ||| expand func	count=1
function	what counter is ||| counter	count=1
function	return the ||| eval	count=1
function	meijer g functions ||| meijer	count=1
module	calculates the clebsch-gordan coefficient ||| physics	count=1
function	n-link pendulum on a ||| pendulum on	count=1
arg	at a in k[x] ||| a	count=1
function	cartan matrix matrix for ||| cartan matrix	count=2
module	polar ||| functions elementary	count=1
function	[function_1] scalar multiple ||| geometry point [function_1] [function_2]	count=1
arg	splits the string path ||| callback	count=1
function	symbol for ||| symbol	count=1
module	said ||| ntheory	count=1
arg	compute the gcd of ||| f	count=3
class	complex [class_2] ||| [class_1] [class_2]	count=5
arg	length n ||| n	count=1
module	a ||| polys	count=5
function	integers moved by ||| length	count=1
function	the generating reflections of ||| generators	count=1
module	a sequence ||| polys	count=1
module	string with mathml ||| utilities mathml	count=1
function	[function_1] primitive ||| [function_2] [function_1]	count=1
function	a root ||| indexed root	count=1
function_arg	degree of [arg_2] ||| [arg_2] [function_1]	count=1
function	applied on it ||| apply on	count=1
arg	a parametric representation ||| a t	count=1
function_arg	gray [arg_2] ||| [arg_2] [function_1]	count=1
function	there is [function_2] ||| [function_1] [function_2]	count=4
function	for the convergence ||| convergent	count=1
arg	of f defined as ||| f k r nu	count=1
arg	an expression to a ||| cls expr x	count=1
arg	constants ||| matlist variable constant k	count=3
arg	of general form ||| x y	count=1
function	version of eye ||| matrix eye	count=1
class	this linear entity ||| linear entity	count=2
function_arg	[function_1] sympy sense ||| [arg_2] [function_1]	count=3
arg	to g and order ||| g	count=1
function	of ode are ||| linear 2eq order1	count=1
arg	1 or 3 1 [arg_1] [arg_2] 1 3 2 3 ||| [arg_1] [arg_2]	count=2
arg	item in col ||| col	count=1
function	a non-central [function_2] ||| [function_2] [function_1]	count=2
arg	is less than other ||| other	count=1
function	of the ||| mod	count=1
function	start ||| process limits	count=2
function	terms to [function_2] ||| [function_2] [function_1]	count=1
function	mpq object [function_2] ||| [function_2] [function_1]	count=2
function	at module [function] time is ||| [function]	count=1
arg	given the universe ||| universe	count=1
function	the leading degree of ||| degree	count=1
arg	items taken k at ||| k replacement	count=2
arg	f given a ||| f m	count=1
function	always ||| is only	count=3
arg	length ||| cls	count=1
arg	compute ||| f n	count=2
function	circle ||| circle	count=1
function	the lower ||| lower	count=1
arg	the mul sorted ||| mul	count=1
function	string path to a ||| get mod	count=1
function	[function_1] test ||| [function_1] [function_2]	count=1
arg	< b ||| cls a b	count=1
class	creating new ||| index structure	count=1
function	class ||| get mod func	count=2
arg	from triangles could be ||| triangles fringe	count=1
function	particle if so would ||| is	count=2
arg	an euler-maclaurin approximation of ||| eps eval_integral	count=1
function	the string path to ||| get mod func	count=1
class	of ||| entity	count=1
function	use ||| use	count=1
class	qubits this gate ||| cnot gate	count=1
arg	if n ||| n candidates big factor	count=1
function_arg	[function_1] and \eta ||| [arg_2] [function_1]	count=1
function_arg	[function_1] x_j at ||| [function_1] f m a [arg_2]	count=2
arg	binary value of n ||| n	count=1
arg	b m ||| a b a b	count=1
class	linear ||| linear	count=6
module	time in the ||| physics vector	count=1
function	[function_1] of syllables ||| [function_1] [function_2]	count=3
function_arg	[function_1] polynomials ||| [function_1] f [arg_2]	count=4
arg	a constant p in ||| f p	count=1
function	multiple of the ||| multiple	count=1
function_arg	free space [arg_2] ||| [arg_2] [function_1]	count=2
function	homomorphism on ||| hom	count=3
function_arg	[function_1] [arg_2] ||| [function_1] ground [arg_2]	count=29
function	as g* ||| as	count=1
class	generate ||| free module poly ring	count=1
arg	a sympy expression expressions ||| expr	count=1
arg	[arg_1] q[x] ||| [arg_1] [arg_2]	count=1
function	sets to the self ||| sets	count=1
function_arg	roots of f ||| roots f	count=2
function	to a ||| get	count=1
function	finding powers ||| af pow	count=1
function	the atanh of p, ||| rs atanh	count=1
function	nine-point [function_2] ||| [function_1] [function_2]	count=1
class	until it is ||| real	count=1
module	are polynomials [module] z[x] ||| [module]	count=3
module	'k', 'lamda' being the ||| combinatorics	count=1
function	polynomial quotient ||| quo	count=1
class	a ||| free module	count=2
function	list of sympy coefficients ||| from sympy list	count=1
class	of the complex ||| complex	count=3
function_arg	[function_1] [arg_2] the special case ||| [function_1] [arg_2]	count=2
function	list of square-free ||| sqf list	count=3
class	checks if the function ||| holonomic function	count=1
class	to evaluate the transform ||| integral transform	count=1
arg	l is the ||| l r n limits	count=1
arg	the grid adds an ||| grid	count=1
module_class	number [module_1] [class_2] on ||| [module_1] [class_2]	count=2
function_arg	polynomial pseudo-quotient [arg_2] ||| [function_1] [arg_2]	count=2
function	laguerre [function_2] ||| [function_1] [function_2]	count=1
function_arg	division of [arg_2] ||| [arg_2] [function_1]	count=8
function	representing ||| real imag	count=2
function	higher in ||| add	count=1
class	files ||| code	count=1
module	entity or ||| geometry	count=1
arg	= a in k[x] ||| f a	count=1
class	polynomials or containers ||| poly	count=1
arg	[arg_1] gens ||| [arg_2] [arg_1]	count=1
arg	of the key matrix ||| key	count=1
function	[function_1] k ||| [function_2] [function_1]	count=2
module	a sparse matrix ||| matrices	count=1
function	the frobenius map parameters ||| gf frobenius map	count=1
function	iterator over the convergents ||| convergents	count=1
function	the square-free normal ||| sqf normal	count=2
arg	with value ||| value	count=1
function	function monotonicity ||| monotonicity	count=1
function	unknown function ||| function	count=1
arg	triangle and an ||| triangle	count=1
function	that ||| refine	count=1
arg	in p with respect ||| p	count=1
class	entity ||| entity	count=2
function	of k [function_2] ||| [function_1] [function_2]	count=4
module	get the version ||| physics quantum	count=1
function_arg	[function_1] [arg_2] ||| [function_1] exact [arg_2]	count=1
arg	number of space characters ||| s	count=1
module	stop ||| series	count=1
function	[function_1] distance between ||| [function_1] [function_2]	count=6
class	number ||| number	count=1
function_arg	gf [arg_2] ||| [arg_2] [function_1]	count=42
function	maximum ||| max	count=3
function	of roots of g_2" ||| roots	count=1
arg	mixed types [arg] ||| [arg]	count=1
arg	of a composite polynomial ||| cls poly	count=3
function	z i ] == ||| zgate	count=1
function	heuristic ||| heuristic function sum	count=1
function	sturm sequence of ||| dup sturm	count=1
function	a string path to ||| get mod func	count=1
function	and ||| opt cse	count=2
class	no more than ||| partition	count=1
arg	at the given position ||| position	count=1
arg	on gens ||| gens	count=1
arg	and for each ||| a d de z	count=1
arg	var occurs in ||| var	count=1
function_arg	expression in [arg_2] ||| [arg_2] [function_1]	count=1
module	the clebsch-gordan ||| physics	count=1
function	functions ||| function	count=3
module	an interpolating [module] for the ||| [module]	count=1
function	the best ||| coeff best	count=1
function_arg	[function_1] modulo ||| [arg_2] [function_1]	count=2
function	wigner semicircle distribution ||| wigner semicircle	count=2
function	square-free norm ||| dup sqf norm	count=2
function	insert a ||| random insert	count=1
module	series ||| series	count=3
arg	coefficients in [inf sup] ||| inf sup	count=1
class	polynomial p [class_2] ||| [class_2] [class_1]	count=2
function	above this ||| above	count=1
function	up ||| up	count=1
arg	[arg_1] lex order ||| [arg_2] [arg_1]	count=3
module	which ||| calculus	count=1
module	all [module] numbers in ||| [module]	count=1
function	its structure [function] *dummy* ||| [function] contraction	count=1
class	only ||| fermion state	count=1
arg	divides p - ||| p	count=1
class	convex? a polygon ||| polygon	count=1
arg	b m + b, ||| a b	count=1
function	upper degree bounds for ||| degree bound	count=1
arg	[arg_1] z0 using ||| [arg_1] [arg_2]	count=5
function_arg	rewrite [arg_2] ||| [function_1] single [arg_2]	count=4
class	module ||| module	count=4
function	python int ||| zz python	count=7
function	returns square-free ||| dmp sqf	count=2
module	linearentity ||| geometry	count=1
function	tests [function_1] [function_2] ||| [function_1] [function_2] func_class f symbol	count=4
arg	a second order ||| order match	count=1
function	the letter representation of ||| letter form	count=1
function	string path to the ||| get	count=1
function	characters of phrase and ||| and	count=1
function	a root to the ||| root	count=2
function	for meijer g ||| meijer	count=1
function	wrt the following ||| numer denom	count=1
class	returns the ||| base	count=4
arg	indices in group ||| indices	count=1
function	an ||| operator	count=1
function	get a root of ||| root	count=1
function	solveset to return a ||| solveset	count=1
function	has [function_2] ||| [function_2] [function_1]	count=4
arg	suitable for a ||| iszerofunc simpfunc	count=1
function	the conjugate ||| conjugate	count=1
module	order form the ||| physics mechanics	count=1
arg	a fraction field element ||| a	count=1
function	f/a ||| quo ground	count=1
function	linear differential ||| linear	count=2
arg	= ||| a b t	count=1
class	files ||| code gen	count=2
function	negative coefficient muls ||| opt cse	count=1
arg	is true ||| brule	count=1
function	a symbol [function_2] ||| [function_2] [function_1]	count=4
function	down ||| top down	count=1
function	the periapsis ||| periapsis	count=1
arg	[arg_1] f in ||| [arg_2] [arg_1]	count=8
class	method ||| base	count=1
arg	morphisms of [arg_2] ||| [arg_2] grid [arg_1]	count=1
function	n ||| divisor count	count=1
class	along self's ||| matrix	count=2
arg	and ||| msg	count=1
function	orbits [function_2] ||| [function_2] [function_1]	count=2
function	the inverse ||| inverse	count=9
function	string path ||| get mod func	count=2
function	non-zero diagonal entries ||| diagonal	count=1
arg	[arg] less ||| [arg]	count=1
class	row ||| dense matrix	count=1
arg	of f given ||| f m k	count=1
function	returns whether [function_1] [function_2] ||| [function_1] [function_2]	count=8
arg	transversals and result in ||| orbits transversals	count=1
arg	two permutation groups as ||| other	count=1
function	get a root ||| indexed root	count=1
class	of coset [class_2] ||| [class_2] [class_1]	count=1
function_arg	[function_1] root1 ||| [arg_2] [function_1]	count=1
arg	p is not ||| p c	count=1
function	converts ||| to expr	count=1
function	sorted numerically according ||| ordered	count=1
function	involving absolute value ||| abs	count=1
function	removes [function_2] ||| [function_2] [function_1]	count=1
class	the atoms of self ||| basic	count=1
function	the position ||| position	count=1
function	[function_1] map ||| [function_1] [function_2]	count=3
class	a line and ||| line	count=1
function	writes a common header ||| get header	count=2
function	discrete ||| discrete	count=3
module	all units ||| units	count=1
function_arg	multiply dense [arg_2] ||| [function_1] [arg_2]	count=2
function	the derivative of each ||| diff	count=1
function	parallel to ||| parallel	count=1
arg	beta ||| alpha beta	count=1
module	standard ||| agca	count=1
arg	of the condition ||| cls cond	count=1
function	tangent of [function_2] ||| [function_2] [function_1]	count=2
function	[function_1] fermi? ||| [function_1] [function_2]	count=8
function	the trivial ||| trivial	count=1
function	[function_1] homogeneous ||| [function_2] [function_1]	count=1
arg	n data points ||| n x	count=1
function	reconstruct a rational number ||| integer rational reconstruction	count=1
module	returns the positions ||| combinatorics	count=2
function	a mutable ||| mutable	count=1
function	o(x**n) at x=0 from ||| eval nseries	count=1
arg	[arg_1] morphisms ||| [arg_2] [arg_1]	count=4
class	roots ||| complex root	count=1
function_arg	according to [arg_2] ||| [function_1] data [arg_2]	count=2
function_arg	graph [arg_2] ||| [arg_2] [function_1]	count=3
function	coeff is the number ||| coeff	count=1
function	x**2 ||| iter	count=1
function	to a fully contravariant ||| from	count=1
class	is return the homomorphism ||| module homomorphism	count=1
class	number of ||| type	count=1
function	the inverse laplace ||| inverse laplace	count=2
class	generate a ||| module poly ring	count=1
arg	sum [arg] ||| [arg]	count=3
function	a diagonal morphism checks ||| diagonal	count=1
function	path to the module ||| get mod func	count=1
function	returns the matrix corresponding ||| matrix	count=1
function	to find a ||| to	count=1
function	the finite difference ||| apply finite	count=1
function	ordinary decimal [function_2] ||| [function_2] [function_1]	count=3
function	resultant of ||| resultant	count=3
function	of a single ||| single	count=1
class	states ||| state	count=1
function	the puiseux series for ||| rs puiseux2	count=1
function	loads a boolean ||| load	count=1
function_arg	to [function_1] [arg_2] ||| polys dmp apply [function_1] [arg_2]	count=8
function	partial ||| partial	count=4
function_arg	triangle tri to ||| weld triangle tri	count=1
function	convergence of ||| convergent	count=1
arg	x and y to ||| x y	count=1
function	[function_1] tests ||| [function_1] [function_2]	count=2
function	pendulum on a ||| link pendulum on	count=1
function	the hankel ||| hankel	count=1
function	the puiseux [function_2] ||| [function_2] [function_1]	count=4
arg	edge ||| edge	count=1
function	to the module and ||| get mod func	count=1
class	this method returns the ||| series base	count=1
function	factor polynomials ||| factor	count=1
function	function [function_2] ||| [function_1] [function_2]	count=1
function	lower central [function_2] ||| [function_2] [function_1]	count=1
arg	as a single ||| a b	count=1
function	heuristic uses the ||| heuristic function	count=1
function_arg	[function_1] key ||| [arg_2] [function_1]	count=1
function	"guess" a rational generating ||| guess generating	count=1
function	top part on the ||| top part	count=1
function	mapping of symbolic values ||| param dict	count=1
arg	morphisms ||| morphisms	count=2
function	edges of the given ||| to	count=1
arg	l is the term ||| l r n	count=1
function_arg	a sympy [arg_2] ||| [arg_2] [function_1]	count=1
function	ordering is that dummies ||| get ordered dummies	count=1
function	variables ||| variables	count=2
class	[class_1] group ||| [class_1] [class_2]	count=1
class	a sequence of polynomials ||| poly	count=1
function_arg	a to [arg_2] ||| [arg_2] [function_1]	count=8
function_arg	[function_1] of f ||| [function_1] numerically [arg_2]	count=1
class	in [class] ||| matrix [class]	count=1
arg	input t ||| t	count=1
function	basis ||| groebner	count=1
module_class	[module_1] state ||| [module_1] quantum qubit [class_2]	count=1
class	a ||| subs set	count=1
function	normal part of the ||| normal	count=1
function	a copy ||| copy	count=1
arg	f ||| f k irreducible	count=1
class	returns the column matrix ||| symbolic	count=1
arg	in a term ||| term	count=1
function	+ by^2 + cz^2 ||| to normal	count=1
module	or below the ||| physics	count=3
function	is nonzero ||| is	count=1
module	this ||| physics quantum	count=2
arg	simple [arg] 1 2 ||| [arg]	count=1
function	direction [function_2] ||| [function_2] [function_1]	count=12
function	implements the lie ||| lie	count=1
class	[class_1] morphism ||| [class_2] [class_1]	count=2
function	postprocess an ||| postprocess for cse	count=1
class	a sequence of ||| ring	count=1
function	and a mutable ||| set	count=1
class	all the sequences ||| seq mul	count=1
function	element to another fraction ||| fraction	count=1
class	latex knows about ||| latex printer	count=1
function	returns ||| dmp	count=3
function	into a [function_2] ||| [function_2] [function_1]	count=2
module	the form obj ||| physics	count=1
class	that no bounding rectangles ||| root of	count=1
arg	function f [arg_2] ||| [arg_1] [arg_2]	count=1
function	isolation interval from ||| interval	count=1
function	cauchy-euler equidimensional ordinary ||| euler	count=1
class	wrappers ||| wrapper	count=2
module	in a permutation ||| combinatorics	count=2
function	convert an ordinary decimal ||| decimal	count=1
function	see if ||| pretty	count=1
class	isolation ||| interval	count=1
function	simplified set of ||| simplified pairs	count=2
function	push a ||| push solid	count=1
module	rows [module] ||| [module]	count=3
function	returns the transformation matrix ||| transformation	count=1
function	random ||| random stab	count=1
class	total ||| type g	count=1
function	kinetic energy of ||| kinetic energy	count=1
function	there is [function_2] ||| [function_2] [function_1]	count=4
arg	[arg_1] y z ||| holzer [arg_1] [arg_2]	count=1
arg	[arg_1] q ||| [arg_2] [arg_1]	count=12
function	[function_1] c(x_2 x_u)*x_0**i ||| [function_1] [function_2]	count=1
arg	adds muls pows and ||| verbose	count=1
class	kb ||| kb	count=2
function	is the trivial ||| is trivial	count=3
class	returns ||| sub module poly ring	count=2
function	offset ||| offset	count=1
arg	t from 0 to ||| t	count=1
arg	characters to the ||| s	count=1
module	domain ||| calculus	count=1
class	self ||| extension	count=1
function_arg	[function_1] [arg_2] ||| [function_1] irreducible [arg_2]	count=2
class	an element of ||| generalized	count=1
function	direction cosine between 2 ||| direction cosine	count=1
function	of arguments of 'self' ||| args	count=1
function	available ||| try use	count=1
function	from positions ||| sub	count=1
class	series ||| type	count=1
arg	new ||| new	count=2
function_arg	check a condition ||| check condition	count=2
arg	differential equation either by ||| eq	count=1
arg	[arg_1] p ||| div f [arg_1] [arg_2]	count=1
function	symbol and its value ||| pure symbol	count=1
function	with constant coefficients ||| constant coeff	count=7
function	right [function] by ||| [function]	count=1
function	in which the ||| not empty in	count=1
arg	name and token same ||| name token	count=1
class	c series ||| type c	count=1
arg	function ||| func order	count=2
function	is that dummies can ||| get ordered dummies	count=1
function	xreplace tracks ||| xreplace	count=1
function	groebner basis ||| groebner	count=1
function	computes the resultant ||| resultant	count=1
function	match(a ||| match	count=1
arg	variable ||| name sides	count=1
function	reverse the ||| reverse	count=1
module	characters to ||| utilities	count=1
arg	z at the point ||| z	count=1
function	semi-latus [function_2] ||| [function_1] [function_2]	count=1
function	differentiate and [function_2] ||| [function_2] [function_1]	count=4
arg	order [arg_2] ||| [arg_2] [arg_1]	count=1
class	in a permutation ie ||| permutation	count=2
module	first order form the ||| physics mechanics	count=1
function	finite ||| as finite	count=1
function	integer partition ||| integer partition	count=2
arg	the routines in ||| routines f prefix	count=3
arg	each [arg] ordered ||| expr [arg]	count=1
function	[function_1] a unit ||| [function_1] [function_2]	count=2
arg	n ||| n b	count=1
arg	operations in ||| visual	count=1
arg	the terms using ||| terms	count=1
module	the ||| calculus	count=3
function	[function_1] is a ||| [function_2] rational [function_1]	count=3
function	a shallow copy ||| copy	count=1
arg	test if f ||| f k	count=1
arg	a to ||| a	count=3
function	map x_i**m_i to y_i ||| multi deflate	count=1
class	bessel-type ||| bessel base	count=1
function_arg	scaler-row [arg_2] ||| [function_1] [arg_2]	count=1
arg	for op ||| op	count=1
function	symbols that will exist ||| free symbols	count=1
arg	x by ||| x	count=1
function	number times pi ||| pi	count=1
module	does the actual work ||| physics	count=1
function_arg	[function_1] [arg_2] ||| [function_1] from dict [arg_2]	count=9
function_arg	[function_1] routine ||| [function_1] [arg_2]	count=3
arg	a group/set/element inside another ||| arg centr	count=1
module	of ||| core	count=1
module	the [module] n ||| [module]	count=1
function	to a dict representation ||| as dict	count=1
function	helper ||| helper	count=2
function	returns the minimal ||| minimal	count=1
function	functions in ||| not empty in	count=1
function_arg	solve a [arg_2] ||| [arg_2] [function_1]	count=1
class	modulo a groebner ||| groebner	count=1
class	dtype ||| gmpyrational field	count=4
function	of ||| complexes	count=1
module	a permutation ie ||| combinatorics	count=2
arg	tuple x representing ||| x	count=1
arg	[arg_1] [arg_2] ||| [arg_2] knots [arg_1]	count=8
function	computes the order of ||| order	count=2
function_arg	order on [arg_2] ||| [arg_2] [function_1]	count=1
arg	alpha as ||| degree generators alpha pairs	count=1
class	tests if free ||| free	count=1
function	isolate [function_2] ||| [function_1] [function_2]	count=15
module	apply ||| diffgeom	count=1
arg	switch ||| f native zero	count=1
function	cyclotomic polynomial of order ||| cyclotomic poly	count=1
function	sparse matrix ||| sparse	count=1
arg	in self where other ||| other	count=1
function	values ||| create param dict	count=1
class	returns ||| module	count=1
arg	[arg_1] z of ||| [arg_2] [arg_1]	count=3
module	random expression about ||| stats	count=1
arg	of ||| x y z	count=1
function	axis of symmetry of ||| axis of symmetry	count=1
function	with constant coefficients using ||| constant coeff	count=1
function	string path to the ||| mod func	count=1
arg	returns the energy [arg_1] [arg_2] ||| [arg_2] [arg_1]	count=1
function	diophantine equations ||| diophantine	count=1
module	of two [module] expressions also ||| [module]	count=1
function	that dummies ||| get ordered dummies	count=1
class	p[i] < p[i+1] ||| permutation	count=1
arg	h a ||| fp_grp h	count=1
arg	k[ x_j ||| j	count=1
function_arg	[function_1] f with ||| [function_1] [arg_2]	count=1
function	[function_1] for ||| [function_1] [function_2]	count=1
function	values below fermi? ||| only below fermi	count=2
arg	p ||| p t	count=1
function_arg	the input [arg_2] ||| polys modified subresultants [function_1] [arg_2]	count=4
function	the argument of the ||| argument	count=1
arg	f ||| f u k	count=1
function	code ||| code	count=5
arg	b**e if n ||| n candidates big	count=1
module	truth value of the ||| elementary	count=1
function	tanh ||| tanh	count=1
function	python subprocess with ||| in subprocess with	count=2
module	plot ||| plotting pygletplot	count=1
arg	the routines in ||| routines f	count=2
function	to a dict ||| as dict	count=1
module_class	the dyadic ||| physics vector dyadic	count=3
function	cond ||| cond	count=1
class	tensor ||| tensor	count=2
module	each of [module] ||| [module]	count=1
module	the ||| liealgebras	count=1
function_arg	[function_1] [arg_2] a ||| [function_1] [arg_2]	count=10
function	f + [function_2] ||| [function_1] [function_2]	count=5
arg	matching_symbol if [arg_2] ||| symbol [arg_2] [arg_1]	count=1
arg	selected ||| func args	count=2
function	root edge the ||| root edge	count=2
module	of ||| matrices	count=3
function	tuple representation ||| as tuple	count=2
arg	endnumber ||| endnumber	count=1
function	around expand ||| expand power exp	count=2
module	return ||| matrices	count=1
function	whether each coordinate of [function_1] [function_2] ||| geometry point [function_1] [function_2]	count=4
function	algorithm [function] whose entries ||| eval berkowitz [function]	count=1
function	line ending ||| get	count=1
module	the truth value ||| functions	count=1
function_arg	hash randomization [arg_2] ||| [arg_2] [function_1]	count=1
function	square-free part ||| sqf part	count=8
function	[function_1] impedance ||| [function_1] [function_2]	count=2
class	printer ||| py printer	count=1
arg	< [arg_2] ||| [arg_2] [arg_1]	count=1
function_arg	sum [arg_2] ||| [arg_2] [function_1]	count=1
function	negative ||| cse	count=1
arg	small'' matrix m ||| deg_f	count=1
class	conveting mutabledensendimarray to ||| ndim	count=1
function	nth [function_2] ||| [function_2] [function_1]	count=2
function	returns minimal degree ||| min	count=1
class	generated ||| octave code	count=1
module	state instance corresponding ||| quantum	count=1
module	equation of ||| solvers	count=2
module_class	[module_1] complex isolating ||| [module_1] [class_2]	count=2
function	returns the lexicographic rank ||| rank	count=1
function	'partial match' [function] of ||| kmp [function]	count=1
function	the module and the ||| mod func	count=1
arg	apply func to ||| func	count=1
arg	of every non-blank line ||| s indent	count=1
arg	t = i ||| t	count=1
function_arg	[function_1] n examples ||| [function_1] [arg_2]	count=1
function	heuristic polynomial [function_2] ||| [function_2] [function_1]	count=3
arg	h as ||| h	count=1
function_arg	[function_1] [arg_2] construct it and returns ||| [function_1] [arg_2] increment	count=1
class	that ||| complex	count=1
arg	p in ||| p	count=1
arg	gcd a ||| a	count=1
arg	[arg_1] the components ||| [arg_2] free [arg_1]	count=2
function	a ||| get mod	count=2
function	[function_1] strictly increasing ||| [function_2] [function_1]	count=4
arg	takes clauses ||| clauses symbols	count=1
arg	appropriate for this ||| name expr argument_sequence global_vars	count=1
function	permutation matrices pq and ||| permutation matrices	count=1
function	[function_1] series ||| 2nd [function_1] [function_2]	count=2
arg	in col [arg_2] ||| [arg_2] [arg_1]	count=2
function	of sympy ||| from sympy	count=1
function	young's [function_2] ||| [function_1] [function_2]	count=1
arg	= [arg] ||| d [arg]	count=1
function	[function_1] monomials from ||| [function_2] [function_1]	count=3
function_arg	root of f ||| root f	count=2
function	strictly decreasing in the ||| strictly decreasing	count=1
arg	ub parts ||| multiplicities ub	count=1
function_arg	[function_1] n ||| [function_1] d [arg_2]	count=1
function_arg	[function_1] an ||| [function_1] expr [arg_2]	count=1
function	inverse mellin ||| inverse mellin	count=2
arg	^, as exponentiation ** ||| tokens local_dict global_dict	count=1
function_arg	deltaintegrate [arg_2] ||| [arg_2] [function_1]	count=5
module	truth value of ||| elementary	count=1
arg	through the point p ||| p	count=1
function	matrix [function_2] ||| [function_2] [function_1]	count=3
function	coset table self ||| coset table	count=1
module	is the inverse of ||| physics	count=1
class	should appear [class] but ||| [class]	count=1
arg	of points in the ||| points	count=1
module	converts a sparse matrix ||| matrices	count=1
arg	of the base-2 digits ||| n_bits	count=1
arg	a unit in term ||| unit	count=1
function	[function] of a ||| dup [function]	count=5
module	return the ||| functions elementary	count=1
module	multiplies the ||| physics vector	count=1
function	generates jacobi [function_2] ||| [function_1] [function_2]	count=1
function	matrix line inside ||| line	count=1
function	the form of singularity ||| rewrite as singularity	count=1
arg	to ||| modulus power_base	count=1
arg	product expression ||| expr	count=1
function	a zeros matrix ||| matrix zeros	count=1
class	rewrite a finiteset ||| finite set	count=1
function_arg	[function_1] factors n ||| [arg_2] [function_1]	count=1
function	return whether [function_1] [function_2] ||| [function_1] [function_2] expression interval symbol	count=2
function	beta ||| beta	count=1
function_arg	[function_1] grid adds ||| [arg_2] [function_1]	count=1
function_arg	in gf [arg_2] ||| [function_1] quo f g [arg_2]	count=2
class	sequence of ||| ring	count=1
arg	terms of ||| x	count=3
class	a string of ||| string	count=1
arg	checks if g ||| g ring	count=1
function	module ||| mod	count=1
function	a zero ||| zero	count=8
arg	compute basic ||| strong_gens_distr transversals_only	count=1
function	converts an add/mul ||| to	count=1
function	hyperexponential polynomials ||| hyperexponential	count=1
class	a ||| free module poly ring	count=1
function	string ||| func	count=2
function	the functions in ||| not empty	count=1
arg	certain ||| point1 point2	count=1
function	dispatch a ||| dispatch	count=1
function	subresultant prs ||| subresultants	count=1
function	the sinh ||| sinh	count=1
function_arg	fraction [arg_2] ||| [arg_2] [function_1]	count=1
function	the given function ||| function	count=1
function	solves a 1st ||| 1st	count=1
function_arg	table of [arg_2] ||| [function_1] [arg_2]	count=2
arg	partial model ||| model	count=2
arg	g ||| g dummies sym	count=1
class	from 'lagranges_equations' [class_2] ||| [class_1] [class_2]	count=1
function	diagonal morphism [function_2] ||| [function_2] space [function_1]	count=1
function	write the code ||| code	count=1
arg	appears first if directed ||| directed	count=1
arg	divisors of n ||| n	count=1
arg	expression over ||| expr var	count=2
module	the inverse of ||| physics	count=1
function	circuit ||| find subcircuit	count=1
arg	g ||| g ring	count=2
module	of other functions ||| core	count=1
arg	f ||| f args	count=1
module	the kinematic ||| physics mechanics	count=1
arg	to the ||| s	count=1
arg	1 2 ; -1 [arg_1] [arg_2] ||| physics epsilon [arg_1] [arg_2]	count=3
function_arg	cofactors of f ||| inner gcd f	count=4
arg	cos and sin ||| rv first	count=1
function	routine to generate necklaces ||| necklaces	count=1
function_arg	function [arg_2] ||| [arg_2] [function_1]	count=3
function	form lagrange's [function_2] ||| [function_1] [function_2]	count=3
function	integrate ||| integrate	count=2
function	of eye and tensor_product ||| matrix eye	count=1
function	[function_1] whole ring ||| [function_2] [function_1]	count=1
function_arg	nth root [arg_2] ||| [function_1] [arg_2]	count=2
arg	be of the ||| func	count=1
function	returns symmetric ||| symmetric	count=1
function	equations [1]_ for ||| equations	count=1
class	of ||| matrix	count=3
module	truth value ||| functions	count=1
arg	dmp out ||| kill	count=1
arg	denominator of f and ||| a d	count=1
function	ring i e ||| ring	count=2
function	number of real roots ||| count real roots	count=1
module	vector ||| physics vector	count=2
function	[function_1] distributed module ||| [function_1] [function_2]	count=1
arg	in ||| u k	count=1
function	using subresultants over a ||| dup rr prs	count=1
arg	general ||| delimiter	count=1
function	a symbol and ||| pure symbol	count=1
class	element in the ||| element	count=1
function	postprocess an ||| postprocess	count=1
class	by self accumulationbounds object ||| accumulation bounds	count=3
arg	== a ||| a n p	count=1
function	if unicode output is ||| try use unicode	count=1
module_class	the [class_2] ||| [module_1] quantum [class_2] operators	count=1
arg	bronstein's ||| p q dummygen	count=1
function	the leading degree of ||| gf degree	count=1
arg	tuple m representing ||| m	count=1
arg	of points ||| func points	count=1
function	gcd of coefficients of ||| ground content	count=1
arg	copy of d with ||| d	count=1
function	non-zero ||| row	count=1
class	given ||| polyhedron	count=1
class	to ||| llvmjit code	count=2
function	function to correct ||| correct	count=1
function	the best solution ||| homogeneous coeff best	count=1
module	[module] operating ||| [module]	count=3
function	in finite_set in which ||| not empty	count=1
function	permutation [function_2] ||| [function_2] [function_1]	count=7
function_arg	[function_1] composite polynomial ||| [function_1] [arg_2]	count=4
function	representation ||| repr	count=4
arg	for [arg] terms of ||| [arg]	count=1
function	ground [function_2] ||| [function_1] [function_2]	count=2
function	for a pivot ||| reasonable pivot	count=1
arg	a list of numbers ||| numbers	count=1
function	an fisher's ||| fisher	count=1
function	converts a term ||| convert to	count=1
function	the binary ordered ||| unrank binary	count=1
arg	and ||| exprs	count=1
function	space rotation is similar ||| space	count=1
function_arg	a finite [arg_2] ||| [arg_2] [function_1]	count=1
arg	[arg] belongs to ||| [arg]	count=3
class	domain ||| composite domain	count=1
function	roots up ||| inner isolate real roots	count=1
arg	a function in a ||| function	count=1
function	generating reflections ||| generators	count=1
arg	[arg_1] cheap to ||| [arg_1] [arg_2]	count=3
function	[function_1] thus the ||| [function_2] [function_1]	count=4
arg	target_units, whenever ||| target_units	count=1
class	coordinate system with respect ||| coord sys	count=2
function	translate ||| translate	count=2
arg	composite polynomial by index ||| cls poly index	count=1
function	string representation of a ||| str	count=1
function	perform a partial ||| measure partial	count=1
function	perform a rr ||| rr	count=1
arg	[arg_1] o(x**prec) ||| [arg_1] [arg_2]	count=1
module	the canonical base dimensions ||| physics	count=1
module	following for the initialization ||| physics	count=1
arg	p of k[t 1/t] ||| p t	count=1
arg	of alpha as a ||| alpha pairs	count=1
function	autonomous system ||| nonlinear 2eq order1 type3	count=1
arg	f and g ||| f g auto	count=2
arg	[arg_1] group ||| [arg_2] [arg_1]	count=4
class	self to an initial ||| differential extension	count=1
arg	p in k ||| f p k	count=2
function	which holds ||| small	count=1
function_arg	[function_1] equation eq ||| [function_1] [arg_2]	count=1
class	with free indices ||| tens	count=1
arg	p [x] and ||| n p k	count=2
function	normal ordering ||| normal order	count=1
function	an ||| as	count=2
function	class of objects ||| objects	count=1
arg	function with [arg] algebraic ||| [arg]	count=1
function	of crt [function_2] ||| [function_2] [function_1]	count=2
function	roots ||| count roots	count=2
class	a quasi-particle? annihilate hole ||| create fermion	count=1
module	apply rule ||| strategies	count=1
arg	the given interval ||| expression interval	count=3
arg	z )[x] ||| minpoly	count=2
function	the symbols ||| symbols	count=3
class	adds and returns a ||| add	count=1
arg	if a < ||| cls a	count=2
module	returns a ||| polys agca	count=1
module_class	qubits this [class_2] ||| [module_1] [class_2]	count=5
arg	two univariate [arg_2] ||| [arg_1] [arg_2]	count=3
function	-> meijerg lookup ||| create lookup	count=1
function	[function_1] and ||| [function_2] [function_1]	count=4
module	return ||| core	count=35
class	[class_1] gate ||| [class_2] [class_1]	count=1
arg	expr using ||| expr	count=1
function	gcd of ||| gf gcd	count=1
function	dmp ||| polynomial ring	count=1
module_class	[module_1] integer ||| [module_1] [class_2] partition	count=1
module	apply on ||| diffgeom	count=1
class	a standard basis ||| sub	count=1
function	orbits and [function_2] ||| [function_2] [function_1]	count=2
arg	transversals and result in ||| base orbits transversals	count=1
class	non-zero ||| sparse matrix	count=1
function	form the sides ||| sides	count=1
class	given dummy ||| expr	count=1
class	swap ||| swap	count=1
function	condition ||| cond	count=2
class	the matrix ||| sparse matrix	count=3
arg	z_p for i = ||| p	count=1
arg	solve [arg] n non ||| [arg]	count=1
function	cosine between ||| cosine	count=1
function	multinomial coefficient [function_2] ||| [function_1] [function_2]	count=1
function	refine a positive root ||| inner refine real root	count=1
function	leading degree of ||| gf degree	count=1
arg	group ||| group	count=1
function	multivariate series [function_2] ||| [function_2] [function_1]	count=1
function	f -x which holds ||| small minus	count=1
function	representation the coset ||| coset	count=1
function_arg	[function_1] if c ||| [function_1] cls r [arg_2]	count=4
arg	a factor ||| factor	count=1
function_arg	sum to [arg_2] ||| [arg_2] [function_1]	count=1
arg	sets and l ||| sets	count=1
arg	c from ||| c	count=1
function	terms ||| as terms	count=1
arg	a [arg_2] ||| [arg_1] p [arg_2]	count=1
class	tests whether a set ||| set	count=1
arg	self x tells ||| x	count=1
function	[function_1] derivative ||| [function_2] [function_1]	count=4
function	the truth value of ||| eval cond	count=1
arg	a given ||| eps	count=1
function_arg	new instance of ||| new cls	count=1
arg	simplify the solution [arg_1] [arg_2] ||| holzer [arg_1] [arg_2]	count=9
function_arg	[function_1] p ||| [function_1] eval f a [arg_2]	count=1
function	[function_1] modularinteger ||| [function_2] [function_1]	count=2
function	of the ||| limits	count=1
arg	in x_0 in k[x] ||| u k	count=1
arg	by stringify_expr ||| local_dict global_dict	count=1
arg	of order [arg] sn ||| [arg]	count=1
arg	using the writer function ||| clear_globs	count=1
function	for solveset to ||| solveset	count=1
function	convert a sympy matrix/complex ||| sympy	count=1
arg	of factors using ||| f factors k	count=1
arg	[arg_1] true ||| [arg_1] [arg_2]	count=3
function	[function_1] submodule ||| [function_2] [function_1]	count=4
function	quaternion [function] coordsyscartesian with ||| orient [function]	count=1
function	[function_1] entire free ||| [function_2] [function_1]	count=2
function	singularity ||| eval rewrite as singularity	count=1
function	return the identity ||| identity	count=3
function_arg	rational numbers [arg_2] ||| [function_1] [arg_2]	count=1
function	[function_1] constant coefficients ||| [function_1] [function_2]	count=2
function	return the quotient homomorphism ||| quotient hom	count=1
module	being the two ||| combinatorics	count=1
module	excluding those that take ||| series	count=1
function	the minimum power of ||| min pow	count=1
arg	convert f ||| f zero	count=1
module_class	[module_1] system ||| [module_1] [class_2]	count=24
arg	apply f to ||| f	count=1
function	class into ||| get mod	count=1
function	argument of ||| argument	count=3
function	of degrees of ||| degree	count=1
class	mapping ||| llvmjit	count=1
function	recursive helper function for ||| rec	count=1
function	format ||| format	count=1
arg	a polynomial f at ||| f	count=1
function_arg	length of [arg_2] ||| [arg_2] [function_1]	count=2
arg	on [arg] elements ||| [arg]	count=1
function	[function_1] degree of ||| [function_2] [function_1]	count=3
module	is available ||| pretty	count=1
function_arg	multivariate series [arg_2] ||| [function_1] nth root p [arg_2]	count=3
class	returns ||| regular	count=1
arg	a cached matrix by [arg_1] [arg_2] ||| [arg_1] [arg_2]	count=1
function	morse ||| morse	count=1
function	restricted to values above ||| above	count=1
arg	equation eq ||| eq param	count=1
arg	new key ||| key	count=1
module	block matrices ||| matrices expressions	count=1
arg	return denested [arg] after ||| [arg]	count=1
function	all ||| deduce all	count=1
arg	d ||| d t	count=1
function_arg	generators in [arg_2] ||| [function_1] [arg_2]	count=1
function_arg	gf [arg_2] ||| [function_1] sub f g [arg_2]	count=2
function	direction vector of the ||| direction	count=1
function	the transposed sparsematrix ||| eval transpose	count=1
class	take on a specific ||| series base	count=1
arg	function f applied ||| f args	count=1
arg	[arg_1] h are ||| [arg_2] [arg_1]	count=12
function	of the symbols ||| constant symbols	count=1
function	method converts a ||| to	count=1
function	positive definite ||| positive definite	count=2
arg	% [arg] ||| a [arg]	count=3
arg	g dx using g ||| g	count=1
function	[function] some trig ||| manual [function]	count=1
function	precedence matrix this ||| precedence matrix	count=1
arg	y z of ||| y z a	count=2
function_arg	denominator of [arg_2] ||| [arg_2] [function_1]	count=3
arg	of e ||| e	count=2
function_arg	decreasing [arg_2] ||| [function_1] [arg_2]	count=4
class	of a density ||| density	count=1
class	series for multivariate functions ||| function	count=1
function	adjacency ||| get adjacency	count=2
module_class	[module_1] sides ||| [module_1] [class_2]	count=2
module	a [module] row-wise ||| [module]	count=2
function	identity ||| random identity search	count=1
arg	modulus [arg_2] ||| [arg_2] [arg_1]	count=2
function_arg	[function_1] f given ||| [function_1] [arg_2]	count=8
module	dyadic ||| physics vector	count=1
class	x c matrix of ||| sparse matrix	count=1
function_arg	tree [arg_2] ||| [arg_2] [function_1]	count=1
function	integer elements ||| integer elements	count=2
function	log hint [function_2] ||| [function_2] [function_1]	count=2
function	[function_1] product of ||| [function_1] [function_2]	count=4
class	the kb examples ||| prop kb	count=1
arg	an accuracy [arg_2] ||| [arg_2] [arg_1]	count=4
arg	[arg_1] k is ||| [arg_1] [arg_2]	count=3
class	on ||| base	count=1
function	ratio of ||| ratio	count=1
function	isolate ||| dup isolate	count=3
module	in ||| vector	count=1
module	two [module] expressions two ||| [module]	count=1
module	process on the input ||| combinatorics	count=1
function	of real roots ||| count real roots	count=2
arg	and o ||| o	count=2
arg	takes clauses ||| clauses	count=1
function	sum that ||| sum	count=1
arg	expansion of expr ||| expr	count=1
arg	a given ||| coord_sys	count=1
function	matrix line inside a ||| line	count=1
function_arg	[function_1] p [x] ||| [function_1] to dict [arg_2]	count=3
class	over distribution ||| continuous distribution	count=1
module	function in the ||| physics	count=1
arg	of an ||| x	count=7
function	[function_1] quadratic in ||| [function_2] [function_1]	count=1
arg	by ||| c	count=3
function	atanh of ||| atanh	count=1
arg	two algebraic ||| g	count=1
arg	z of the ||| z	count=1
module_class	self by [class_2] ||| [module_1] [class_2]	count=1
function	heuristic is ||| heuristic	count=1
function_arg	d^2 = [arg_2] ||| [arg_2] [function_1]	count=1
function	and leverage ||| pretty try	count=1
function	expression in [function_2] ||| [function_2] [function_1]	count=2
arg	of self and other ||| other	count=1
function	[function_1] partial ||| [function_2] [function_1]	count=5
class	space rotation ||| space orienter	count=1
module	the inverse ||| physics	count=1
function	test evaluation [function_2] ||| [function_2] [function_1]	count=2
module	basis state instance ||| quantum	count=1
arg	domain [arg_2] ||| [arg_2] [arg_1]	count=2
function	mpq object to dtype ||| from qq	count=1
module	self with ||| agca	count=2
class	morphisms [class] their ||| [class]	count=1
arg	p ||| p u k	count=1
arg	[arg] mul ||| [arg]	count=1
function	values below [function_2] ||| [function_1] [function_2]	count=4
module_class	[module_1] dyadic in ||| [class_2] [module_1]	count=2
function	[function_1] symbols of ||| [function_2] [function_1]	count=1
function	a factory ||| factory	count=1
module_class	and [module_1] [class_2] ||| [module_1] [class_2]	count=2
arg	[arg] radians about ||| [arg]	count=9
arg	alpha beta x ||| b x	count=1
function	an ode from the ||| ode 1st homogeneous	count=1
function	a product of ||| mul	count=1
arg	scalar [arg_2] ||| [arg_1] [arg_2]	count=3
module	where ||| combinatorics	count=2
function	[function_1] partition summing ||| [function_2] [function_1]	count=4
function	legendre ||| legendre	count=1
function	hypergeometric ||| hyperexpand	count=2
function	try ||| try	count=1
function	vectors ||| vectors	count=1
module	names and values that ||| solvers	count=1
function	[function_1] [function_2] ||| [function_2] zz mignotte [function_1]	count=2
class	the xy-pic representation ||| drawer	count=1
module	the added ||| physics vector	count=1
arg	representation of [arg] as a ||| [arg]	count=1
module	of this domain ||| polys	count=4
class	self domain ||| ring	count=1
module	implementation ||| agca	count=3
arg	a field in ||| field coord_sys	count=1
class	this geometrical entity ||| geometry entity	count=1
arg	[arg_1] j ||| [arg_1] [arg_2]	count=1
module	given symbols syms ||| core	count=1
module	in a list the ||| combinatorics	count=1
module	but ||| core	count=1
arg	= b ||| a b	count=1
arg	axis ||| axis	count=1
function_arg	gcd of [arg_2] ||| [function_1] [arg_2]	count=18
function_arg	[function_1] for ||| [function_1] [arg_2]	count=4
class	d) [class] a, ||| [class]	count=1
function	poly last inserted in ||| final touches	count=1
module	through the point ||| geometry	count=1
function	same ||| unit	count=2
function	test [function_2] ||| [function_2] [function_1]	count=2
function	trace [function_2] ||| hep [function_1] [function_2]	count=5
function	expression which ||| expr	count=1
function	[function_1] gray ||| [function_2] [function_1]	count=4
class	of ||| ring	count=2
class	[class] every ||| [class]	count=2
function	map x_i**m_i to y_i ||| dmp multi deflate	count=1
function_arg	solve the [arg_2] ||| [function_1] poly [arg_2]	count=1
arg	j_3 j_4 j_5 j_6 ||| j_3 j_4	count=1
function	[function_1] polynomial ||| [function_2] [function_1]	count=14
arg	d and d ||| d	count=1
function	take ||| free	count=1
arg	if [arg] ||| [arg]	count=4
function	normalized [function] given line ||| [function]	count=1
arg	message [arg] ||| [arg]	count=1
arg	f in gf ||| f	count=3
function	method which gives the ||| 1st	count=1
function	remainder in [function_2] ||| [function_2] [function_1]	count=2
arg	field in k[x] ||| f g u k	count=1
function_arg	[function_1] polynomials ||| [arg_2] [function_1]	count=6
function	make a dictionary ||| to dict	count=3
function_arg	[function_1] two ||| [arg_2] [function_1]	count=20
function	to the ||| mod	count=1
arg	line in ||| k	count=1
arg	terms of f ||| f	count=5
function	the delta coefficient ||| delta coeff	count=1
module	block ||| assumptions handlers	count=1
function	a groebner basis ||| groebner	count=1
arg	name [arg_2] ||| [arg_1] [arg_2]	count=3
module	bu_{2})(w*v_{1} + bv_{2}) + ||| solvers	count=1
function	pendulum [function_2] ||| [function_2] [function_1]	count=5
module	string ||| utilities	count=2
function	the domain of the ||| empty	count=1
class	the polyhedra we can ||| polyhedron	count=1
function	whether [function] ||| [function] function class	count=1
class	no bounding rectangles of ||| root of	count=1
arg	operations ||| visual	count=1
function	[function_1] equations of ||| [function_2] [function_1]	count=2
function_arg	[function_1] of general ||| [arg_2] [function_1]	count=1
function	generator that is ||| generator	count=1
arg	replaced by ||| kwargs n	count=1
module	leverage it if ||| printing pretty	count=1
function	always destroy ||| is only	count=1
function	beyond the ||| next	count=1
function	[function_1] int ||| [function_2] [function_1]	count=2
function	in which ||| in	count=1
function	hermite reduction - mack's ||| hermite reduce	count=1
function	form base exponent ||| as base exp	count=1
class	py ||| py	count=2
function	as [function] ||| needs [function]	count=1
arg	is the term ||| r n	count=1
module	containing ||| mechanics	count=1
function	class into a ||| func	count=1
class	sort roots ||| root of	count=2
function	annihilate particle if ||| is q annihilator	count=1
arg	by sep ||| sep	count=1
arg	the base ||| base	count=2
arg	in terms of ||| x	count=1
function	berkowitz algorithm ||| eval berkowitz	count=1
function	default files ||| files	count=1
arg	the fundamental strip given ||| strip	count=1
class	return a list ||| frac	count=1
function	of mpf tuple ||| as mpf	count=2
function	replace [function_2] ||| [function_1] [function_2]	count=4
arg	and p in ||| p	count=1
function	square-free ||| sqf	count=18
arg	= 1 computes ceiling ||| options return_ints	count=1
arg	[arg_1] a ||| integrals simplifyconds [arg_1] [arg_2]	count=2
arg	equation eq ||| eq	count=2
module	the ||| physics units	count=14
function	zeros square ||| zeros	count=2
function	is available ||| try	count=1
module	[module] expectation ||| [module]	count=1
arg	real inverse_mellin_transform function this ||| f s x_ strip	count=1
arg	i in ||| i	count=1
function_arg	quantity to [arg_2] ||| [arg_2] [function_1]	count=1
arg	index in a ||| index	count=2
class	on ||| series base	count=2
arg	condition [arg] given a ||| condition [arg]	count=1
function	as [function_2] ||| [function_1] coeff [function_2]	count=1
function	finds ||| in	count=1
function	minimum ||| imin	count=1
function	or [function_2] ||| [function_2] [function_1]	count=1
function	see if ||| pretty try use	count=1
function_arg	a function to ||| function func	count=1
class	the proper line ending ||| code printer	count=1
arg	a ||| a t	count=1
class	polynomials or ||| poly	count=1
function	exp ||| exp	count=1
function	[function_1] cyclotomic polnomial ||| [function_2] [function_1]	count=3
arg	v ||| x v	count=1
function	available ||| pretty	count=1
arg	irreducibility test ||| p k	count=1
class	returns a ||| sub module poly	count=1
function	generates symmetric [function_2] ||| [function_1] [function_2]	count=3
function	closes ||| close	count=1
arg	univariate series expansion ||| x prec	count=1
function	to the same ||| convert to	count=1
class	code block ||| code block	count=2
function	terms ||| as	count=4
arg	two polynomials [arg_2] ||| [arg_1] [arg_2]	count=2
class	of a partition ||| partition	count=1
arg	as exponentiation ** ||| tokens local_dict global_dict	count=1
class	implement [class] ||| [class]	count=3
function_arg	[function_1] of p ||| [function_1] depth [arg_2]	count=1
module_class	the [class_2] ||| [module_1] [class_2] new cls	count=1
module	the simplified ||| physics quantum	count=1
function_arg	[function_1] p0 ||| [function_1] dumx [arg_2]	count=1
function_arg	[function_1] i ||| [function_1] op [arg_2]	count=4
function_arg	[function_1] two ||| [function_1] biquadratic f [arg_2]	count=1
function	leading term as ||| leading term	count=1
arg	the characters of msg ||| msg	count=1
function	an arbitrary expression to ||| sympify	count=1
arg	n ||| n a	count=2
function	is not zero ||| is zero	count=2
arg	directed ||| seq directed	count=1
function	of cos or ||| tr9	count=1
arg	[arg] with int ||| [arg]	count=3
arg	return the residual mod [arg_1] [arg_2] that it is within ||| [arg_2] [arg_1]	count=1
class	of this fermionicoperator ||| fermionic operator	count=3
arg	to name [arg_2] ||| [arg_2] [arg_1]	count=3
module	the added integration ||| physics	count=1
function	the intersection of 'self' ||| intersection	count=1
class	a standard ||| module poly	count=1
function	the affine [function] ||| affine [function]	count=3
class	to ||| finite field	count=1
arg	[arg_1] in symbols ||| [arg_1] [arg_2]	count=2
arg	an integer n ||| n k	count=1
arg	inverse of the key ||| key symbols	count=1
function	get the corners ||| corners	count=1
class	range ||| range	count=1
module	of the quantity as [module_1] [module_2] ||| [module_1] [module_2] quantity scale factor	count=1
function	it ||| pretty try use	count=1
function_arg	[function_1] p [x] ||| [function_1] gcd f g [arg_2]	count=2
function	scalar multiple of ||| scalar multiple	count=2
function	\ldots x_{k-1}] from ||| interpolate multivariate	count=2
module	a [module] number ||| [module]	count=1
module	of equation is ||| solvers	count=1
function	non-integer [function] ||| has [function]	count=3
module	method returns ||| series	count=1
function	rational function field ||| field	count=1
module	curl [module] ||| physics [module]	count=1
arg	[arg] m_3 ||| j_1 j_2 [arg]	count=2
function_arg	the [function_1] [arg_2] ||| [function_1] [arg_2]	count=28
arg	ternary quadratic equation eq ||| eq	count=1
module_class	[module_1] [class_2] act on ||| [module_1] [class_2]	count=4
module_class	of the sides ||| geometry regular polygon	count=1
function_arg	[function_1] [arg_2] to construct it and ||| [function_1] [arg_2] increment	count=1
arg	of n digits ||| n	count=1
arg	of the terms ||| x x0 dir logx	count=1
function	here ||| kid rsa	count=1
module	location where p[i] ||| combinatorics	count=2
arg	the tests returning ||| sort timeout slow enhance_asserts	count=1
arg	of ||| x x0	count=1
function	ben-or's ||| ben or	count=1
arg	product f [arg] ||| f [arg] a	count=3
arg	model or ||| model deep	count=1
function	quadratic ||| quadratic	count=5
function	symbol and its ||| find pure symbol	count=1
arg	[arg_1] [arg_2] ||| [arg_2] func args [arg_1]	count=3
function	the non-zero [function_2] ||| [function_1] [function_2]	count=3
module_class	the [class_2] ||| [module_1] [class_2]	count=212
arg	[arg_1] expression ||| [arg_2] [arg_1]	count=8
function	the best ||| 1st homogeneous coeff best	count=1
function_arg	a square-free [arg_2] ||| [arg_2] [function_1]	count=3
arg	the operations [arg_2] ||| [arg_2] [arg_1]	count=2
function	of a loop morphism ||| loop morphism	count=1
function_arg	[function_1] [arg_2] a permutation group ||| combinatorics [function_1] group [arg_2]	count=1
function	find [function] ||| find pure [function]	count=1
arg	gcd a p == ||| a p	count=1
module	characters to the ||| utilities	count=1
module	muls ||| simplify	count=1
function	heuristic polynomial ||| heu	count=3
module	said to be ||| ntheory	count=1
arg	to [arg] ||| func [arg]	count=3
arg	in an addition expression ||| expr	count=1
function	multivariate ||| dmp gf	count=1
module	and values that ||| solvers	count=1
function	phrase and if ||| check and	count=1
class	simple root [class_1] [class_2] ||| [class_2] [class_1] simple root	count=2
function	form of products ||| form	count=1
function	unicode output is ||| try use unicode	count=1
arg	using g functions assuming ||| g x	count=1
class	[class] uses ||| [class]	count=1
arg	i ||| i f	count=2
function_arg	mod [arg_2] ||| [arg_2] [function_1]	count=3
module	following for the ||| physics	count=1
function	find 'executable' in ||| find	count=1
class	entity which passes ||| entity	count=1
module	and pdsolve ||| solvers	count=1
arg	p_i ||| gj p_i	count=1
arg	subtracting [arg_2] ||| [arg_2] [arg_1]	count=4
function_arg	minimal polynomial [arg_2] ||| [function_1] [arg_2]	count=3
function	bsgs ||| bsgs	count=1
class	point in a referenceframe ||| point	count=3
function	into a string ||| get	count=1
module	truth ||| elementary	count=1
class	of ||| permutation	count=2
module	[module_1] units ||| [module_1] [module_2]	count=2
function	of single g ||| single	count=1
function	lower ||| root lower	count=1
class	check whether a set ||| set	count=1
function	[function_1] beta ||| [function_2] [function_1]	count=1
function	the top nodes first ||| top	count=2
function	property where the lookup ||| property	count=1
module	prime ||| ntheory	count=5
arg	x_0 of ||| u	count=1
function	[function_1] the cdf ||| [function_1] [function_2]	count=2
function	ode are ||| 2eq order1 type6	count=1
arg	a in the i-th ||| i a	count=1
function_arg	[function_1] h ||| [arg_2] [function_1]	count=4
class	system ||| system	count=12
arg	and k1 ||| k1 symbols	count=1
function	[function_1] [function_2] ||| [function_1] [function_2] of generators	count=2
function	is an upper triangular ||| is upper	count=1
function	contained ||| contains	count=1
class	a polynomial element ||| poly element	count=4
arg	[arg_1] x prec ||| [arg_2] [arg_1]	count=8
function	add [function_2] ||| [function_1] [function_2]	count=2
module	a ||| combinatorics	count=2
arg	true if f ||| f	count=13
function	previous lexicographically ordered ||| prev lexicographic	count=2
function	tensor ||| tensor printing	count=1
function	entire free [function_2] ||| [function_1] [function_2]	count=2
function	[function] a b ||| [function]	count=3
arg	b**e if n ||| n	count=1
function	form lagrange's [function_2] ||| [function_2] [function_1]	count=3
arg	about c i ||| c	count=1
arg	of diagram ||| diagram	count=1
function	lower ||| dup root lower	count=1
arg	series expansion ||| p x prec	count=4
arg	x_j of a ||| j	count=1
function	[function_1] mises distribution ||| [function_2] [function_1]	count=2
class	of self ||| matrix	count=1
function_arg	[function_1] [arg_2] ||| [function_1] exquo f [arg_2]	count=2
class	of polar numbers ||| polar	count=1
function	quadratic [function_2] ||| [function_2] [function_1]	count=6
function	* a where ||| mul ground	count=3
function	values attained by other, ||| ge	count=1
function	transversal [function_2] ||| [function_2] [function_1]	count=4
function	+ by^2 + cz^2 ||| normal	count=1
class	interval ||| interval	count=14
arg	token same effect ||| token	count=1
arg	reduce degree of f ||| f	count=1
class	value ||| series base	count=2
arg	the point z0 using ||| z0 dir	count=1
module	and ||| printing pretty	count=2
class	interior angle ||| regular	count=1
arg	of factors ||| factors u k	count=1
function_arg	polynomial pseudo-remainder [arg_2] ||| [function_1] [arg_2]	count=2
arg	true if f ||| f k	count=1
function_arg	gate with controls ||| zbasis controls	count=1
arg	is stored in storage ||| storage	count=1
function	a multivariate [function_2] ||| [function_2] [function_1]	count=1
function	converts a list of ||| convert to	count=1
arg	subtract [arg] make all ||| [arg]	count=1
function	rewrites a ||| eval rewrite as	count=1
function	load [function_2] ||| [function_2] [function_1]	count=1
function	canonical form of the ||| canonical	count=1
class	specific value (i ||| series base	count=1
module_class	sparse [class_2] ||| [module_1] [class_2]	count=3
function	all the ||| deduce all	count=1
function	wrapper to _eval_nseries ||| nseries	count=1
function	lie group ||| ode lie group	count=2
function	to a class into ||| mod	count=1
function	the bottom ||| bottom up	count=1
class	[class] in ||| [class]	count=3
function	calculate the limit ||| limit	count=1
class	from 'lagranges_equations' ||| lagranges	count=1
arg	and g ||| g auto	count=1
arg	convert f into a ||| f	count=1
rep	the schreier [function_arg_2] ||| [module_class_1] schreier [function_arg_2]	count=1
arg	return the truth ||| cls	count=1
arg	new instance [arg_2] ||| [arg_2] [arg_1]	count=2
class	those that take ||| series base	count=1
function	generates jacobi [function_2] ||| [function_2] [function_1]	count=1
function	the positions of ascents ||| ascents	count=1
module	finite_set in which ||| calculus	count=1
function	a string path ||| mod func	count=1
arg	of e z ||| e z	count=2
function	series expansion of ||| series	count=1
function	computes the discriminant of ||| discriminant	count=1
function	of real sets ||| as set	count=1
function	to a class ||| get mod func	count=1
function_arg	[function_1] f ||| [function_1] list include [arg_2]	count=4
arg	expression ||| expr index	count=1
arg	adds muls pows and ||| exprs order verbose	count=1
function	a morphism the length ||| morphism length	count=1
function	of phrase and if ||| and	count=1
class	gray ||| gray	count=3
function	pendulum on [function_2] ||| [function_2] [function_1]	count=2
arg	[arg_1] k ||| functions elementary root arg [arg_1] [arg_2]	count=1
function	[function_1] ground domain ||| [function_2] [function_1]	count=2
module	the kinematic ||| physics	count=1
function	solve the equation ||| solve	count=1
module	the given number of ||| utilities	count=1
function	symbols ||| free symbols	count=1
class	roots ||| root of	count=5
module	in mathml ||| utilities mathml	count=2
class	a point of ||| point	count=1
function	unifies the base polynomial ||| unify	count=1
function	[function_1] hash randomization ||| [function_1] [function_2]	count=5
arg	creates a small'' matrix ||| deg_f deg_g row1	count=1
arg	prints a text ||| text color align	count=1
module	form [module] + by^2 ||| [module]	count=1
class	value ||| piecewise	count=1
function	[function_1] part of ||| [function_2] [function_1]	count=8
function	reduced representation ||| trunc	count=1
arg	if other is ||| other	count=1
arg	that contain nested ||| nested	count=1
arg	false [arg] < ||| [arg]	count=1
function	substitution u_2 = \frac{\text{<independent ||| subs indep div dep	count=1
arg	point x0 to b ||| b	count=1
function	or [function_2] ||| [function_1] [function_2]	count=1
function	gets segments ||| get segments	count=1
arg	a string containing prec ||| prec	count=1
function	sum of k squares ||| do sum of squares	count=1
class	of this segment ||| segment	count=1
class	ending ||| code printer	count=2
arg	limit or cheap to ||| limit use_trial use_rho use_pm1	count=1
arg	expression ||| expression exclude	count=1
arg	b ||| a b	count=1
function	heuristic assumes the infinitesimals ||| lie heuristic bivariate	count=1
function_arg	linearizer [arg_2] ||| [function_1] [arg_2]	count=3
arg	[arg_1] g p ||| [arg_1] [arg_2]	count=3
module	the ||| combinatorics	count=54
function	[function_1] annihilate particle ||| [function_2] [function_1]	count=1
class	update the kb ||| fact kb	count=1
arg	[arg] a ||| [arg]	count=2
function	always destroy a ||| only q	count=1
function	apply [function_2] ||| [function_2] [function_1]	count=1
function	the atan of p, ||| atan	count=1
arg	transform of g ||| g x helper	count=2
class	along self's last and ||| matrix	count=2
module_class	sum [class_2] ||| [module_1] [class_2]	count=4
function	[function_1] fraction decomposition ||| [function_2] [function_1]	count=1
arg	computes ||| f	count=3
function	[function_1] strong ||| [function_1] [function_2]	count=1
function	[function_1] a multivariate ||| [function_1] [function_2]	count=1
function_arg	[function_1] for ||| plot [function_1] [arg_2]	count=1
function	half extended euclidean algorithm ||| half gcdex	count=2
function	positive [function_2] ||| [function_2] [function_1]	count=3
module_class	[module_1] current system ||| [module_1] units dimension [class_2]	count=1
class	until ||| real	count=2
function	the euclidean distance from ||| distance	count=1
function	string representation ||| repr	count=2
function	to switch to another ||| to	count=1
arg	[arg] of ||| matlist [arg]	count=3
function	the normalized [function] given ||| [function]	count=1
function	[function_1] edge ||| [function_2] [function_1]	count=2
arg	an ||| expr	count=9
function	to a class into ||| get	count=1
function	[function_1] sort ||| [function_1] [function_2]	count=1
function	name ||| mod func	count=1
function	[function_1] cofactors ||| [function_2] [function_1]	count=8
class	wave ||| twave	count=5
function	generated ||| auto	count=1
class	sequence ||| ring	count=1
function	denest ||| sqrt biquadratic denest	count=1
class	f_4 the ||| type f	count=1
function	opening statements of the ||| routine opening	count=2
function	taylor [function_2] ||| [function_2] [function_1]	count=1
class	isolating ||| complex	count=1
arg	this function ||| argindex	count=30
arg	[arg_1] fringe ||| [arg_1] welding_edge [arg_2]	count=1
function	[function_1] unicode ||| [function_1] [function_2]	count=1
function	trial [function_2] ||| [function_2] [function_1]	count=2
function	returns the number ||| number	count=1
arg	into each [arg] ||| [arg] sols	count=3
class	real and complex ||| complex	count=1
module	clause l ||| algorithms	count=1
arg	of expression ||| expr	count=2
function	presentation is to ||| reidemeister presentation	count=1
module	all [module] numbers ||| [module]	count=1
arg	intervals in [arg_2] ||| [arg_1] [arg_2]	count=5
function	return true if ||| equals	count=1
arg	if c ||| c	count=3
arg	a point [arg_2] ||| [arg_2] [arg_1]	count=8
module	the inner product ||| physics	count=1
function	sparse matrix [function_2] ||| [function_1] [function_2]	count=4
module	the domain of the ||| calculus	count=1
arg	polynomial in ||| f p u	count=1
class	of polynomials or ||| ring	count=1
function	from generators of ||| gens from	count=2
module_class	of the [class_2] ||| [module_1] [class_2]	count=22
arg	of k0 [arg_2] ||| [arg_2] [arg_1]	count=1
function	[function_1] to a ||| [function_1] [function_2]	count=9
arg	modify parts of ||| kwargs	count=1
arg	elements of k0 ||| k0	count=1
module	[module_1] this ||| [module_1] [module_2] point	count=1
class	of ||| linear	count=1
function	add two simple roots ||| add simple roots	count=1
arg	rational [arg] ||| [arg]	count=1
function	q assuming [function] >>> x ||| [function]	count=1
function	self is written ||| coeff	count=1
arg	an expression to ||| expr	count=1
arg	mapping in rules ||| rules x	count=1
arg	given interval ||| expression interval	count=3
function	cz^2 + dxy + ||| normal	count=1
function	the gcd of ||| gf gcd	count=1
arg	the objects ||| objects	count=1
function_arg	this is a linear [function_1] [arg_2] [3] ||| [function_1] nonlex [arg_2]	count=1
module	integration ||| integrals	count=2
arg	the base argument can ||| base	count=1
function	find optimization opportunities in ||| opt	count=1
arg	polynomial irreducibility ||| f p k	count=2
class	domain ||| simple domain	count=1
function	matrix matrix ||| matrix	count=2
arg	the index1 ||| index1	count=1
function	equations which comes under ||| 2eq order2 type11	count=1
function	-x ||| minus	count=1
function	the function is continuous ||| continuous	count=1
function	the ||| process limits	count=2
function	quotient homomorphism ||| quotient hom	count=1
function	to a ||| dmp to	count=1
function	time ||| time	count=1
class	to ||| llvmjit	count=1
arg	f from k[x y] ||| f	count=1
function	[function_1] cart ||| [function_1] [function_2]	count=5
arg	elem ||| elem m	count=1
function	function field ||| field	count=1
function	indefinite integral ||| dmp integrate	count=2
arg	apply f to ||| f atoms	count=1
function	[function_1] cosine ||| [function_2] [function_1]	count=3
function_arg	[function_1] expression over ||| [function_1] [arg_2]	count=2
function	is monotonic ||| is monotonic	count=1
arg	an indexed root of ||| x index radicals	count=1
function	gcd and cofactors ||| inner gcd	count=6
function	find optimization opportunities in ||| cse	count=1
module	symbolic values to ||| printing	count=1
function	a single gamma matrix ||| single	count=1
function	g's (self's) [function] ||| [function]	count=3
function	vertical radius ||| vradius	count=1
arg	new key [arg_2] ||| [arg_2] [arg_1]	count=1
arg	using operations on ||| dom	count=1
arg	in [arg_2] ||| [arg_1] g [arg_2]	count=6
arg	determine the outer ||| expr return_dummies	count=1
function	binary coding to ||| to	count=1
class	this fermionicoperator allow values ||| fermionic operator	count=1
function	l1 norm of ||| l1 norm	count=4
arg	optimized _strip with h ||| h base orbits	count=1
arg	variable [arg_2] ||| [arg_2] [arg_1]	count=2
function	lmq lower bound ||| root lower bound	count=1
function	the orbit of ||| orbit	count=2
function_arg	refine an [arg_2] ||| [function_1] root [arg_2]	count=8
function	subset defined by ||| get subset from	count=1
arg	steps specified in y ||| y	count=1
module_class	[module_1] line ||| [module_1] [class_2]	count=2
function	this catagory ||| 2eq order2 type10	count=1
function_arg	[function_1] with another ||| [function_1] [arg_2]	count=2
function	truth value of ||| cond	count=1
arg	it is ||| x	count=1
arg	g functions assuming ||| g x	count=1
module_class	of this [class_2] ||| [class_2] [module_1]	count=7
arg	f p g p ||| f g b p	count=1
class	returns the positions ||| permutation	count=2
arg	of a [arg_2] ||| core prod [arg_1] [arg_2]	count=1
function	general ||| general	count=1
function	true/false if a ||| is	count=1
function	load ||| load	count=1
function	a new ||| orient new	count=1
arg	h transversals and result ||| h base orbits transversals	count=1
function	jordan elimination ||| jordan	count=1
function	finite_set in ||| in	count=1
function	[function_1] strictly decreasing ||| [function_1] [function_2]	count=4
arg	if expr ||| expr	count=3
arg	compute partial fraction decomposition ||| f x dummies	count=1
module_class	[module_1] lagrange multipliers ||| [module_1] [class_2]	count=2
function_arg	the bifid [arg_2] ||| [arg_2] [function_1]	count=1
arg	/ inequalities ||| expr x_var y_var	count=1
class	in ||| sub module poly	count=1
function_arg	space [arg_2] ||| [function_1] horizontal [arg_2]	count=1
function	to a scalar ||| scalar	count=1
function	the nth root ||| nth root1	count=1
arg	[arg_1] defined ||| [arg_1] [arg_2]	count=2
function	is thus the ||| is singleton	count=2
arg	apply f ||| f atoms nonbasic	count=1
arg	digits of [arg] in ||| [arg]	count=1
arg	in rules ||| p rules	count=1
function	of christoffel symbols for ||| to christoffel 2nd	count=1
function_arg	evaluation points [arg_2] ||| [arg_2] [function_1]	count=1
class	sparse n-dim array ||| sparse ndim array	count=1
function	the power series expansion ||| series	count=1
function	and if symbols is ||| check and	count=1
arg	use ||| s n	count=1
function	"x" ||| calculate	count=1
function	stop ||| process	count=1
module	kroneckerdelta ||| concrete	count=5
arg	compute polynomial ||| f	count=2
function	of the form x ||| process limits	count=1
function	the delta [function_2] ||| [function_1] [function_2]	count=1
arg	routines [arg_2] ||| [arg_2] [arg_1]	count=3
function	[function_1] linear ||| [function_1] [function_2]	count=1
arg	[arg_1] target_matrix ||| [arg_2] [arg_1]	count=2
class	annihilate hole ||| fermion	count=1
function	num/den ||| rad	count=1
function	tensor [function_2] ||| [function_1] [function_2]	count=8
function_arg	[function_1] by its ||| [function_1] name [arg_2]	count=2
arg	specified by the user ||| weylelt	count=1
function	* a [function_2] ||| [function_1] [function_2]	count=1
arg	[arg_1] x note ||| [arg_2] [arg_1]	count=1
arg	partial model ||| symbols model	count=2
arg	factors has root v ||| factors x v dom	count=1
function	number to ||| to	count=1
arg	following -- ||| density set	count=1
function	as log ||| as log	count=2
function_arg	[function_1] p [x] ||| [function_1] sqf part [arg_2]	count=3
function	gray code ranking ||| rank gray	count=1
class	of the polyhedra we ||| polyhedron	count=1
arg	solves ||| eq sym	count=1
function	convex hull surrounding the ||| convex hull	count=1
function	truth value ||| cond	count=1
function_arg	number [arg_2] ||| [arg_2] [function_1]	count=1
arg	and b, implies ||| b	count=1
function_arg	reduced representation [arg_2] ||| [function_1] [arg_2]	count=2
function	a tuple ||| tuple	count=2
arg	to a tensmul ||| tensmul	count=1
class	in ||| ring	count=1
arg	[arg] 1 3 ||| i j [arg]	count=1
arg	and g ||| g exps x	count=1
function	the gray code ||| unrank gray	count=1
function	mul ||| mul	count=5
arg	po ||| po	count=1
function	different types ||| naive	count=1
function	ring i e k[x] ||| ring	count=3
module_class	and assumptions ||| core symbol	count=1
class	the symmetric/alternating group ||| permutation group	count=1
class	x c matrix ||| matrix	count=2
arg	polynomial ||| minpoly p	count=1
arg	sympy expression expressions are ||| expr	count=1
function	sparse zero [function_2] ||| [function_1] [function_2]	count=2
function	[function_1] a sequence ||| [function_2] [function_1]	count=1
module	that take ||| series	count=1
class	returns the ||| type	count=1
function	start stop ||| process	count=1
function_arg	factors [arg_2] ||| [arg_2] [function_1]	count=1
module	returns a standard basis ||| agca	count=1
arg	in expr ||| expr x	count=1
arg	value of n ||| factors n	count=1
function	hash ||| hashable content	count=1
function	the name of ||| get	count=1
function	pow ||| pow	count=1
function_arg	[function_1] is used ||| [arg_2] [function_1]	count=1
function	[function_1] [function_2] ||| [function_2] rational [function_1]	count=12
function	rectangles of ||| refine complexes	count=1
function	[function_1] the expand ||| [function_2] [function_1]	count=8
function	root of ||| indexed root	count=1
function	equation - [function] ||| prde [function]	count=1
function	the base ||| base	count=1
arg	old -> [arg_2] ||| [arg_2] [arg_1]	count=1
function	return generators ||| gens	count=1
function	construct field isomorphism ||| field isomorphism	count=2
function	function for ||| simplify	count=1
function	rational function ||| rational function	count=2
function	[function_1] sympy ||| [function_2] [function_1]	count=10
arg	target [arg_2] ||| [arg_2] [arg_1]	count=1
arg	a small'' matrix m ||| deg_f deg_g row1 row2	count=1
function	classes to ||| operators to state	count=1
class	that no bounding rectangles ||| complex	count=1
function	is in ||| is	count=2
class	return the homomorphism ||| module homomorphism	count=1
arg	a scalar field ||| scalar_field	count=1
arg	encrypt message [arg] is ||| [arg]	count=1
module	using any hints ||| integrals	count=1
function	[function] form ||| to [function]	count=2
function	always destroy a ||| is only q	count=1
function	matrix line ||| line	count=1
function	is ||| zero	count=1
arg	root if it ||| root radicals	count=1
arg	the modulus [arg_2] ||| [arg_2] [arg_1]	count=2
class	with ||| indexed	count=2
class	of the patterns ||| matrix	count=1
function	values below fermi? ||| below fermi	count=1
function	and a ||| set	count=1
function_arg	gf [arg_2] ||| [function_1] sqf part [arg_2]	count=3
class	__div__ ||| field	count=2
module	positive literal ||| logic algorithms	count=1
arg	given number of ||| s	count=1
arg	u ||| reverse	count=1
arg	rectangles of ||| cls	count=1
arg	generate [arg] list ||| [arg]	count=1
function	of phrase and ||| and	count=1
function	concatenates ||| row join	count=1
class	the generated ||| code gen	count=1
arg	base gens ||| base gens	count=2
arg	for suitability ||| f t ct a	count=1
function	the form of singularity ||| eval rewrite as singularity	count=1
class	that are generated ||| differential extension	count=1
function	level associated ||| level	count=1
function	is even ||| is even	count=2
function	values above fermi? ||| above fermi	count=1
module	negative coefficient muls ||| simplify	count=1
function	for pos ||| vars pos	count=2
module	for ||| utilities	count=2
function	whose presentation is ||| reidemeister presentation	count=1
arg	provided p is not ||| p	count=1
function	the direct [function] several groups ||| direct [function]	count=1
arg	cong 0 mod(p** s ||| s p	count=1
function	refractive [function_2] ||| [function_2] [function_1]	count=1
arg	d = b m ||| b	count=1
module	with mathml code ||| mathml	count=1
function	atanh of p, ||| atanh	count=1
function	[function_1] key such ||| [function_2] [function_1]	count=1
class	that are generated automatically ||| differential extension	count=1
arg	replaced ||| kwargs	count=1
arg	ith prime ||| i	count=1
function	of distinct real ||| real	count=1
arg	constants ||| variable constant	count=3
function	in gf p ||| gf	count=3
function	multivariate [function_2] ||| [function_1] [function_2]	count=4
function	factors ||| factors	count=3
function	is a common ending ||| common suffix	count=1
function	unit ||| unit base	count=1
arg	numbers v ||| v x	count=1
function	of free indices ||| free indices	count=4
arg	algorithm ||| f x extension handle_first	count=1
arg	to func ||| func	count=1
function	form lagrange's equations of ||| form lagranges equations	count=1
function	product replacement algorithm ||| pr	count=1
arg	in a certain ||| point1 point2	count=1
function_arg	decreasing in [arg_2] ||| [arg_2] [function_1]	count=4
arg	[arg_1] [arg_2] 1 3 2 3 ||| [arg_1] [arg_2]	count=2
function	by^2 + cz^2 + ||| normal	count=1
class	given ||| expr	count=3
arg	polynomial f ||| f i	count=1
function	an fisher's z distribution ||| fisher z	count=1
arg	specified [arg] ||| [arg]	count=1
function	consists of syllables ||| syllables	count=1
function	result ||| result variables	count=1
function	the commutator ||| commutator	count=1
module_class	the plane and ||| geometry plane	count=1
function	with constant [function_2] ||| [function_2] [function_1]	count=3
function_arg	hankel transform [arg_2] ||| [function_1] [arg_2]	count=3
arg	if ||| cond	count=2
arg	appears first if directed ||| seq directed	count=1
function	row echelon form given ||| rref	count=1
class	submodule ||| sub	count=2
module_class	this [class_2] ||| [module_1] [class_2]	count=31
function	(i ||| free	count=1
function	the symbols in the ||| free symbols	count=1
arg	element ||| element	count=2
arg	set of points ||| points	count=2
function	rotation about ||| orient	count=1
function_arg	order of a ||| order at a	count=2
function	true/false if a solution ||| is	count=1
function	with all the implications ||| deduce all	count=1
arg	y z of ||| y z	count=1
function	set ||| set modulus	count=1
module	the number ||| combinatorics	count=1
module	the ||| physics mechanics	count=31
function	import ||| import	count=1
function	multiply ||| mul term	count=1
arg	functions of ||| function	count=1
arg	element to ||| element base	count=1
arg	the ||| cls	count=2
function	term has a non-integer [function_1] [function_2] ||| solvers has [function_1] [function_2]	count=4
function_arg	degrees [arg_2] ||| [arg_2] [function_1]	count=1
function	a raw dict ||| raw dict	count=2
arg	polynomial f ||| f	count=10
function	are generated ||| auto	count=1
module	of [module] knuth-morris-pratt ||| [module]	count=1
function	domain of the functions ||| empty in	count=1
module	with the ||| printing	count=1
function	build a monomial order ||| build product order	count=1
function	formats a ||| get statement	count=1
function	[function_1] form ||| [function_2] [function_1]	count=6
arg	a small'' ||| deg_f	count=1
function	[function_1] fermi? >>> ||| [function_2] [function_1]	count=8
arg	f ||| f symbol	count=1
arg	a model or not ||| expr model deep	count=1
arg	a, d = b ||| a b a b	count=1
arg	n ||| n x	count=1
arg	intervals in ||| f	count=1
module_class	underlying dimension [class_2] ||| [class_2] [module_1]	count=1
arg	set of points ||| points incremental	count=1
arg	of f and for ||| a	count=1
function	are contained ||| similar	count=1
arg	\langle [arg_1] [arg_2] ||| clebsch gordan [arg_1] j_2 j_3 [arg_2]	count=2
class	is ||| implemented ideal	count=1
function	polynomial quotient ||| exquo	count=2
function_arg	this is a [function_1] [arg_2] order [3] ||| [function_1] [arg_2]	count=1
arg	evaluate [arg_1] [arg_2] ||| [arg_1] [arg_2]	count=3
module	the coordinates which the ||| physics	count=1
function	the right [function] ||| [function]	count=1
class	that no bounding ||| root of	count=1
function	the number of roots ||| count roots	count=2
arg	the root if it ||| cls root	count=1
function_arg	mellin transform [arg_2] ||| [arg_2] [function_1]	count=5
arg	[arg_1] dum indices ||| [arg_1] [arg_2]	count=1
arg	n ||| n z	count=1
arg	expression old -> new ||| old new	count=1
arg	limits should ||| func limits	count=1
function	sentinel ||| sentinel	count=1
function	non-zero structure of the ||| row structure	count=1
function	of ||| get mod	count=1
arg	[arg_1] [arg_2] with int 1 so ||| [arg_1] [arg_2]	count=4
function	to a class ||| mod func	count=1
function	the leading term ||| sdm lt	count=1
function	function that helps find ||| search function	count=1
arg	the [arg] points ||| [arg]	count=1
module	divergence [module] field computed ||| physics [module]	count=1
function	helper function for ||| solve	count=1
module	the line and return ||| physics	count=1
arg	for n data points ||| n x x y	count=1
function	jordan ||| jordan	count=2
arg	which the finite_set ||| finset_intersection	count=1
arg	model ||| symbols model	count=2
function	which when printed ||| uniquely named	count=1
function	boolean [function] simplified version ||| [function]	count=1
function	morse code ||| morse	count=1
arg	terms of ||| x n	count=1
class	crootof ||| complex root of	count=2
function	[function] of a ||| continued fraction [function]	count=3
function	exact quotient of ||| exquo	count=6
class	basis in ||| module	count=1
function	python [function_2] ||| [function_2] [function_1]	count=26
module	is currently ||| physics	count=1
arg	in x ||| n x	count=1
function	a morse code ||| decode morse	count=1
function	to ||| to state	count=1
class	for ||| octave code	count=1
arg	g modulo p for ||| g p	count=1
function	out generators ||| parallel dict from expr no gens	count=1
class	standard basis in ||| sub module	count=1
arg	writer function out ||| out clear_globs	count=1
module	hints ||| integrals	count=1
arg	t and ||| t	count=1
function	of the ||| in	count=1
arg	[arg_1] [x] polynomial ||| [arg_2] [arg_1]	count=3
function	f + ||| add	count=3
arg	a polynomial f at ||| f i	count=1
function	to [function] ||| dmp apply [function]	count=3
function	polynomial pseudo-division ||| pdiv	count=1
arg	mod [arg] ||| [arg]	count=1
function	upper degree bounds ||| degree bound	count=1
function	lmq upper bound ||| root upper bound	count=1
arg	converts [arg_2] ||| [arg_2] [arg_1]	count=16
function	root edge ||| root edge	count=2
arg	non-zero elements of t ||| t	count=1
function	is the [function_2] ||| [function_1] [function_2]	count=16
arg	f with [arg_2] ||| [arg_1] z [arg_2]	count=1
arg	also ||| root1 root2	count=1
function_arg	[function_1] polynomial ||| [function_1] [arg_2]	count=8
function	set attributes that are ||| auto attrs	count=1
function	the content [function_2] ||| [function_2] [function_1]	count=1
function	return a rational ||| eval rational	count=1
class	returns ||| dmp	count=3
class	the ||| permutation	count=4
function	all [function_2] ||| [function_1] [function_2]	count=7
function	to a list ||| as list	count=1
function	exists ||| check antecedents 1	count=1
function_arg	element [arg_2] ||| [arg_2] [function_1]	count=6
function	generated by the union ||| union	count=1
arg	p prime with p ||| p	count=1
function	when ||| coeff mul	count=1
arg	false [arg] ||| [arg]	count=1
class	to ||| algebraic number	count=1
function	[function_1] iterable ||| [function_1] [function_2]	count=1
function	unicode output is ||| use unicode	count=1
function_arg	rank [arg_2] ||| [arg_2] [function_1]	count=3
function	x_i**k_i in ||| inflate	count=1
arg	function for functions checking ||| expression predicate interval symbol	count=1
class	of the patterns ||| matrix properties	count=1
class	algebraic ||| anp	count=1
arg	of general ||| x	count=1
class	of ||| polyhedron	count=1
arg	of a start ||| a start	count=1
class	this matrix ||| matrix	count=2
function	a class ||| get	count=1
class	on which the sequence ||| seq base	count=1
arg	for a ||| a	count=1
function	system [function_2] ||| [function_2] [function_1]	count=8
module	of [module] otherframe ||| [module]	count=1
module	the simplified list ||| physics	count=1
function	run [function_2] ||| [function_2] [function_1]	count=2
function	the logarithm of ||| log	count=1
function	power ||| power	count=5
arg	the solutions of f ||| p f	count=1
class	a 2-tuple ||| exp	count=1
function	for gf_edf_shoup ||| gf trace map	count=1
function	relative accuracy [function] number ||| [function]	count=1
function	returns a row-sorted list ||| row list	count=1
function	commutator of self ||| commutator	count=1
module	returns true if self ||| polys agca	count=2
arg	g modulo [arg_2] ||| div f [arg_1] [arg_2]	count=4
function	series expansion ||| series	count=2
function	the scalar [function_2] ||| [function_2] [function_1]	count=11
function	state of ||| state	count=1
arg	a given ||| expr	count=1
class	correct ||| tensor data lazy evaluator	count=1
arg	subcircuit [arg] ||| [arg] subcircuit replace	count=1
function	focal [function_2] ||| [function_2] [function_1]	count=2
function	be in integer representation ||| find pure symbol int repr	count=1
function	bitlist corresponding ||| bitlist	count=1
function	root ||| indexed root	count=2
module	read the ||| physics	count=1
function	computes the gauss-lobatto ||| gauss lobatto	count=1
arg	that oth is a ||| oth	count=1
function	2d n-link pendulum ||| pendulum	count=1
arg	[arg] n ||| [arg]	count=2
class	scalar ||| base covar derivative	count=1
function	general sine or cosine-type ||| sine	count=1
function_arg	[function_1] that oth ||| [function_1] hom [arg_2]	count=2
function	a raw [function_2] ||| [function_2] [function_1]	count=1
function_arg	reduced [arg_2] ||| [function_1] f [arg_2]	count=1
function_arg	solve the [arg_2] ||| [arg_2] [function_1]	count=2
function	is of type ||| of type	count=2
function	symmetric [function_2] ||| [function_1] [function_2]	count=3
class	as the ||| cartesian	count=1
function	kinetic energy of a ||| kinetic energy	count=1
function	and [function_2] ||| [function_2] [function_1]	count=8
function	[function_1] [function_2] ||| [function_2] to [function_1]	count=6
function	helper function for sum ||| sum	count=1
arg	if expr is bounded ||| expr assumptions	count=1
function	returns the symbols ||| free symbols	count=1
arg	n shifted ||| n	count=1
function	was successfully decremented ||| decrement part small	count=1
function	boolean [function] simplified ||| [function]	count=1
function_arg	rank of [arg_2] ||| [function_1] [arg_2]	count=4
function	a scalar [function_2] ||| [function_2] [function_1]	count=4
arg	factors [arg_2] ||| [arg_2] [arg_1]	count=3
function_arg	partition summing [arg_2] ||| [function_1] [arg_2]	count=1
function	square ||| sqrt	count=1
function	linear homogeneous differential equations ||| linear	count=1
function	as part [function] ||| needs [function]	count=1
function	common absolute value ||| common	count=1
arg	where g ||| g	count=1
module	[module_1] the three ||| [module_1] [module_2]	count=2
function	matrix to a ||| to	count=1
arg	solves a first order ||| func order	count=2
class	rectangles of ||| of	count=1
function	hilbert [function_2] ||| [function_2] [function_1]	count=1
arg	[arg_1] suitable for ||| [arg_2] [arg_1]	count=2
function	object from components and ||| from components and	count=1
arg	[arg_1] k ||| [arg_1] p [arg_2]	count=1
function	the derived ||| derived	count=1
arg	operators a global ||| operators	count=1
arg	if other ||| other	count=4
class	[class_1] with ordered ||| [class_2] [class_1]	count=2
module	the ground domain of ||| polys	count=1
function	square polynomials ||| sqr	count=1
function	as ||| as numer denom	count=1
function	in ||| opt	count=1
function	convex ||| convex	count=1
function	all non-zero terms from ||| terms	count=1
arg	compute the ||| f x k	count=3
class	computes the ||| dmp	count=1
arg	by k ||| k	count=1
class	real root ||| root of	count=1
module	is available and leverage ||| pretty	count=1
module	polynomials or containers ||| polys	count=1
arg	number [arg_2] ||| physics energy [arg_2] [arg_1]	count=1
function	assumed ||| subresultants rem	count=1
function	[function_1] laplace transform ||| [function_2] [function_1]	count=3
function	linearizer ||| to linearizer	count=1
function	reflections ||| generators	count=1
function	[function_1] into irreducibles ||| [function_1] [function_2]	count=1
arg	in k[x] ||| c i u	count=2
function	[function_1] equations ||| [function_2] [function_1]	count=2
function	[function_1] set of ||| [function_1] [function_2]	count=4
class	of the polygon and ||| polygon	count=1
function	quotient ||| exquo	count=2
arg	in grid ||| grid	count=1
arg	f in ||| f	count=28
module	printing ||| printing	count=4
function	form of singularity ||| rewrite as singularity	count=1
function	argument [function] false otherwise ||| needs [function]	count=1
arg	[x] for medium p ||| p	count=1
class	c [class_2] ||| [class_2] [class_1] simple root	count=2
function	the gcd of coefficients ||| dmp ground content	count=1
module	if ||| core	count=2
class	converts mutabledensendimarray to matrix ||| ndim	count=1
arg	to x**n = a ||| a n	count=1
function	the series of ||| series	count=1
function	symbolic ||| dict	count=1
arg	influence of ||| n cart_force joint_torques	count=1
class	and d) [class] ||| [class]	count=1
function	generating set from ||| from	count=1
function	number of distinct real ||| count real	count=1
function	[function_1] gf ||| [function_2] [function_1]	count=15
arg	origin ||| origin	count=1
module	where p[i] ||| combinatorics	count=2
function	defined [function] starting from ||| assoc [function]	count=1
arg	[arg] repeated squaring ||| f n [arg]	count=1
function	of type ||| of type	count=2
function	[function_1] pos ||| [function_1] [function_2]	count=1
function	called the external ||| ext	count=1
module	lists [module] which successive ||| [module]	count=1
function	components the ||| components	count=1
function	the degree of the ||| find degree	count=1
function	module and the name ||| func	count=1
class	factors of ||| factors	count=3
class	from the kb examples ||| prop kb	count=1
module	handles the default printing ||| physics	count=1
class	run ||| sym py doc test runner	count=1
function_arg	encryption [arg_2] ||| [function_1] rsa [arg_2]	count=2
module	entity ||| geometry	count=1
arg	e and all ||| e	count=1
arg	in a ||| f g include	count=1
function	alpha and ||| alpha	count=1
arg	instance of roots ||| cls expr	count=1
function	annihilate particle [function_2] ||| [function_2] q [function_1]	count=4
arg	x**n == a ||| a n	count=1
arg	f in x_j ||| f gen	count=1
function	basis specified ||| get basis	count=1
arg	pt1 ||| pt1	count=1
function	recursive helper function for ||| rec degree in	count=1
function	f - ||| dmp sub	count=1
arg	[arg_1] number ||| [arg_2] [arg_1]	count=4
function_arg	addends of rv ||| addends rv	count=2
arg	m_{\alpha} [arg_2] ||| [arg_2] [arg_1]	count=6
arg	f p q x ||| f p q x	count=1
function_arg	[function_1] ex ||| [function_1] [arg_2]	count=1
arg	literals return an equivalent ||| expr	count=2
arg	* p1 with p2 ||| p2	count=1
arg	in z_p for i ||| p k	count=1
module	ground domain of ||| polys	count=1
function	[function_1] instance to ||| [function_2] [function_1]	count=4
function	into a ||| get mod func	count=1
arg	mapping in rules ||| p rules	count=1
function	scalar potential function ||| scalar potential	count=4
arg	f k ||| f k	count=1
class	bounding rectangles of ||| root	count=1
arg	of f and g ||| f g	count=19
arg	labeled polynomial f ||| f	count=1
function	column of the ||| col	count=1
arg	[arg] op: ||| seq [arg]	count=3
arg	fp_group a finitely presented ||| elm_rounds simp_rounds	count=1
arg	x ||| x	count=47
module	basis ||| polys agca	count=2
arg	in the list of ||| expr x	count=1
class	of qubits this gate ||| cnot gate	count=1
function_arg	part of [arg_2] ||| [arg_2] [function_1]	count=7
function	returns ||| free	count=1
module	every lie algebra has ||| liealgebras	count=1
class	object ||| base	count=1
function	lagrangian of ||| lagrangian	count=1
arg	of f [arg_2] ||| [arg_1] z [arg_2]	count=1
function_arg	degree [arg_2] ||| [arg_2] [function_1]	count=1
arg	constants [arg] have ||| [arg] symbolname startnumber	count=1
function	x_i**k_i in a polynomial ||| inflate	count=1
function	[function_1] nthroot ||| [function_2] [function_1]	count=2
function	variation of coincidence routine ||| coincidence	count=1
function	[function_1] list ||| [function_1] [function_2]	count=8
function	tensor product ||| combined tensor printing	count=1
module	rewrite logic operators and ||| logic	count=1
class	the column matrix ||| symbolic system	count=2
function_arg	an apply [arg_2] ||| [arg_2] [function_1]	count=2
function_arg	[function_1] of g ||| [arg_2] [function_1]	count=5
function	[function_1] evaluate a ||| [function_2] [function_1]	count=1
class	of ||| matrix base	count=1
arg	switch to a ||| native	count=2
function	the direction [function_2] ||| [function_2] [function_1]	count=12
module	polyhedra ||| combinatorics	count=1
function	finds the degree of ||| find degree	count=1
arg	an expression into a ||| expr	count=1
arg	in ||| f prefix	count=2
arg	field in a ||| field	count=1
function	module and ||| mod func	count=1
arg	y are ||| y	count=1
function	a multivariate series ||| rs	count=1
class	a set ||| product set	count=1
arg	= [arg] ||| [arg]	count=3
arg	q x ||| q x	count=2
function	heuristic polynomial ||| qq heu	count=1
arg	two polynomials [arg_2] ||| [arg_2] [arg_1]	count=2
arg	key associated to val ||| key val	count=1
function	group of ||| group	count=1
arg	return [arg_1] [arg_2] ||| [arg_2] [arg_1]	count=3
function	system using lusolve and ||| linear system lu	count=1
function	the string ||| func	count=1
module_class	[module_1] product ||| [module_1] [class_2]	count=1
function	[function] simplified ||| [function]	count=1
function	converts a list ||| convert to	count=1
module	from the ||| physics	count=2
function	return function [function] of ||| func [function]	count=1
arg	the objects ||| objects merged_morphisms	count=1
function	correct the ||| correct	count=1
class	bounding ||| root of	count=2
function	return constant term ||| constant term	count=1
module	the point ||| geometry	count=1
function	no bounding rectangles ||| refine complexes	count=1
function	tensor_can ||| indices canon args	count=1
function	unify generators in a ||| unify gens	count=1
function	from ||| interpolate	count=1
arg	matrix ||| matrix	count=2
arg	convert a k[x] ||| u k zero	count=1
function	returns angular [function_2] ||| [function_2] [function_1]	count=1
module	for [module] ||| [module]	count=1
function_arg	[function_1] tri ||| [function_1] [arg_2]	count=2
arg	domain for ||| domain	count=1
function	bool1 ||| bool map	count=1
function	[function_1] order of ||| [function_2] [function_1]	count=1
class	the generated files ||| code gen	count=1
module	generated automatically ||| integrals	count=1
arg	f with [arg_2] ||| [arg_2] [arg_1]	count=5
class	root [class] every ||| [class]	count=2
function	compute polynomial trace ||| trace	count=1
arg	in [inf sup] ||| k inf sup	count=1
arg	p q are in ||| p q	count=2
function	the string path ||| get mod	count=1
function	of a series ||| rs	count=1
function	i ||| get comm	count=1
function_arg	at [arg_2] ||| [arg_2] [function_1]	count=5
function_arg	normal [function_1] [arg_2] ||| [function_1] [arg_2]	count=2
function	impedance ||| impedance	count=1
arg	and ||| e	count=1
function	the sum ||| sum	count=1
arg	the terms ||| terms	count=1
function_arg	[function_1] order ||| [function_1] exact [arg_2]	count=1
arg	scalar ||| scalar_field	count=1
module	returns a vector distance ||| vector	count=1
function	the domain of ||| empty in	count=1
function	to the module and ||| mod func	count=1
function	magnetic permeability ||| permeability	count=1
function	[function_1] degree ||| [function_2] [function_1]	count=3
arg	infinitesimals \xi and \eta ||| match comp	count=1
function	always [function_2] ||| [function_2] [function_1]	count=2
class	a ||| fcode gen	count=2
function	[function_1] with ||| [function_2] [function_1]	count=5
function	[function_1] field ||| [function_1] [function_2]	count=3
arg	[arg] positive span ||| [arg]	count=1
arg	a multivariate polynomial f ||| f	count=2
class	currently ||| factory	count=1
function	for the orbit of ||| orbit	count=1
module	step of ||| polys	count=1
arg	gr adjacency ||| gr	count=1
function	always destroy a ||| only	count=1
arg	p x [arg_2] ||| [arg_1] [arg_2]	count=1
function	[function] given line ||| [function]	count=1
function	algorithm [function] ||| eval berkowitz [function]	count=1
arg	each item in args ||| args	count=1
function	laguerre polynomial of degree ||| laguerre poly	count=1
arg	in a basis ||| basis	count=1
function	a string path to ||| get	count=1
function	processes the deductions ||| deductions	count=1
module_class	the current [class_2] ||| [module_1] [class_2]	count=4
function	label is the unique ||| label	count=1
function	parse and ||| parse order	count=1
arg	sets and ||| sets	count=1
arg	f and for ||| a d de z	count=1
arg	[arg_1] and y ||| scale [arg_1] [arg_2]	count=1
function	generates symmetric polynomial of ||| symmetric poly	count=1
function	a list of ||| from list	count=1
function	two simple ||| simple	count=1
class	corresponding to a group ||| free group element	count=1
function	create a shallow copy ||| copy	count=1
function	the total degree of ||| total degree	count=1
function	rectangles ||| refine	count=1
function	leading monomial ||| lm	count=1
function	combined numerator ||| ap	count=1
function	direct [function] ||| direct [function]	count=1
function	sequence ||| sequence	count=1
function	principal ||| principal	count=1
class	c matrix ||| matrix	count=2
arg	[arg_1] , ||| [arg_1] [arg_2]	count=3
class	of the hypergeometric ||| hyper	count=2
class	generate a ||| module poly	count=1
function	ordering is that dummies ||| dummies	count=1
function	it's matrix ||| matrix	count=1
function	make the ||| to	count=3
function	to ||| get	count=2
arg	by the function f ||| f args	count=1
function_arg	[function_1] ex ||| [arg_2] [function_1]	count=1
function	cosets of self ||| coset	count=1
class	exploiting ||| sparse	count=2
class	writes ||| octave	count=1
class	mutabledensendimarray to matrix ||| dense ndim	count=1
function	basis is [function_2] ||| [function_2] [function_1]	count=1
function	converts a ||| form to	count=1
class	[class_1] basis ||| [class_1] [class_2]	count=11
arg	symbols with those ||| symbols filter	count=1
arg	a point center ||| vec point	count=2
arg	in z_p for ||| p k	count=2
arg	[arg_1] not in ||| [arg_2] [arg_1]	count=3
function_arg	sin [arg_2] ||| [arg_2] [function_1]	count=1
function	total number of roots ||| roots	count=4
arg	given the following -- ||| density set	count=1
function_arg	[function_1] of key ||| categories diagram [function_1] dict union dictionary [arg_2] value	count=1
arg	[arg_1] [arg_2] used to construct it ||| [arg_1] [arg_2]	count=8
function	the loads ||| loads	count=1
function	coefficient of a summation ||| coeff	count=3
arg	of the factors has ||| factors	count=1
function	normalized version ||| normalized	count=1
function_arg	strictly decreasing [arg_2] ||| [function_1] [arg_2]	count=2
arg	given ||| coord_sys	count=1
function	linear in ||| linear	count=2
arg	in the terms ||| terms	count=1
arg	replaced by the function ||| kwargs	count=1
arg	p [x]/ ||| n g p	count=1
class	g_2" ||| type	count=1
function	ket on the ||| ket	count=1
function	over a field ||| ff	count=3
class	a standard basis in ||| module poly	count=1
function	a transversal ||| transversal	count=2
function	dynkin [function] of ||| dynkin [function]	count=1
arg	source into ||| source	count=1
class	determinant ||| matrix determinant	count=3
function	type ||| 2eq	count=1
arg	n in [arg_2] ||| [arg_2] [arg_1]	count=6
function	to a ||| get mod func	count=1
function_arg	adds [arg_2] ||| [function_1] [arg_2]	count=1
class	an element in the ||| element	count=1
module	integer -- return number ||| core	count=1
function	the atanh ||| atanh	count=1
arg	state corresponding [arg] ||| n m [arg]	count=1
module	in ||| sets	count=2
function	[function_1] [function_2] ||| [function_1] as [function_2]	count=4
function	trace of a ||| trace	count=2
function	direction ratio ||| direction cosine	count=1
function	values ||| param	count=1
arg	[arg] then it ||| [arg]	count=3
function	symmetric polynomial of order ||| symmetric poly	count=1
class	state of this ||| state	count=1
function	is a ratio of ||| is	count=1
arg	type of ||| x y t r	count=3
function	wigner [function_2] ||| [function_2] [function_1]	count=2
arg	writer function out ||| compileflags out clear_globs	count=1
arg	of indices in group ||| indices	count=1
function_arg	gf [arg_2] ||| [function_1] quo f g [arg_2]	count=2
arg	of [arg] in ||| [arg]	count=1
function_arg	[function_1] alpha as ||| [function_1] transversal [arg_2]	count=4
arg	and negative coefficient muls ||| exprs order	count=1
arg	l is the ||| l r	count=1
arg	coordsyscartesian with its ||| vector_names	count=1
arg	[arg_1] k ||| [arg_1] [arg_2]	count=14
function	fullrank ||| fullrank	count=1
function_arg	[function_1] p ||| [function_1] to dict [arg_2]	count=3
module	prime factors of r ||| ntheory	count=1
function	[function_1] cancellation ||| [function_2] [function_1]	count=1
arg	d = b m ||| a b	count=1
module	name of the class ||| utilities	count=1
class	for ||| satsolver	count=1
function	with homogeneous [function_2] ||| [function_1] [function_2]	count=5
function	ring ||| ring	count=7
module_class	[module_1] freegroup ||| [module_1] [class_2] element	count=2
function	available and leverage ||| pretty	count=1
function	the lu decomposition itself ||| lu decomposition	count=1
arg	a morphism [arg_2] ||| [arg_1] [arg_2]	count=2
class	a grid laid out ||| diagram grid	count=1
arg	mod(p** s ||| s	count=1
function	euclidean polynomial [function_2] ||| [function_1] [function_2]	count=1
arg	l is the ||| l r n	count=1
function	of sign ||| as sign	count=1
function	* a [function_2] ||| [function_2] [function_1]	count=1
function_arg	square the [arg_2] ||| [function_1] [arg_2]	count=1
function	[function_1] raw dict ||| [function_1] [function_2]	count=1
function_arg	square root [arg_2] ||| [function_1] [arg_2]	count=4
arg	[arg_1] d ||| [arg_2] [arg_1]	count=4
function_arg	the posform [arg_2] ||| [arg_2] [function_1]	count=1
arg	symbol [arg_2] ||| [arg_1] [arg_2]	count=1
function	+ a ||| add	count=1
class	operator s [class] this ||| state [class]	count=1
function_arg	[function_1] f ||| [function_1] single [arg_2]	count=1
function	gcd of two ||| gcd	count=1
function	returns a key ||| key	count=1
module	leverage it if possible ||| printing	count=1
module_class	the [class_2] ||| [module_1] dimension [class_2]	count=1
function	basic expression ||| to basic	count=1
arg	the actual infinitesimals of ||| infinitesimals func	count=1
function	sparse ||| sparse	count=4
function	returns this function [function_1] [function_2] ||| [function_1] [function_2]	count=2
function_arg	[function_1] on gens ||| [function_1] [arg_2]	count=4
arg	s, and return the ||| s	count=1
function	not zero and none ||| zero	count=1
arg	[arg] describe ||| [arg]	count=3
arg	dum indices on the ||| dum	count=1
function	is a set with ||| is	count=1
function	the second defining ||| p2	count=1
class	this [class] ||| [class]	count=8
class	real ||| real	count=6
class	of polar numbers is ||| polar	count=1
arg	expression and call ||| expr	count=1
module	return [module] operator s ||| [module]	count=1
module	indices and [module] ||| [module]	count=2
module	rewrite logic ||| logic	count=1
arg	b m ||| b	count=1
function	finds the domain of ||| not empty in	count=1
function	polynomial to a dict ||| to dict	count=1
arg	basis of g ||| g	count=1
arg	helper function for _invert ||| g_ys symbol	count=2
arg	element using operations on ||| dom	count=1
class	those that take on ||| series	count=1
arg	d = b m ||| b a b	count=1
arg	is independent [arg] ||| f [arg]	count=1
arg	morphisms of ||| morphisms	count=1
function	equation [function_2] ||| [function_2] class [function_1] func_class f symbol	count=1
function	bending moment curve ||| bending moment	count=1
arg	letters of s ||| s	count=1
function_arg	xor [arg_2] ||| [arg_2] [function_1]	count=1
function	distinct real roots ||| dup count real roots	count=1
arg	the mul sorted in ||| mul	count=1
arg	if a [arg_2] ||| [arg_2] [arg_1]	count=5
function	decide how to render ||| hprint	count=1
function	add c(x_2 x_u)*x_0**i ||| dmp add term	count=2
arg	col that [arg_2] ||| [arg_1] [arg_2]	count=3
function	around [function_2] ||| [function_2] [function_1]	count=4
function	half extended gcd of ||| half gcdex	count=1
arg	in y ||| y	count=1
class	returns the xy-pic representation ||| drawer	count=1
function_arg	[function_1] [arg_2] ||| [function_1] rem f [arg_2]	count=4
arg	equation eq ||| eq param syms	count=1
class	rectangles of non-conjugate ||| complex root of	count=1
function	to correct the values ||| correct signature	count=1
function	get [function_2] ||| [function_1] [function_2]	count=6
function	unicode ||| unicode	count=1
module	optical setup conjugating the ||| physics optics	count=1
function	of the ||| not empty	count=1
function	coding to gray ||| bin to gray	count=2
function	return the derived ||| derived	count=1
function	python's fraction to ||| qq python	count=3
function_arg	the order [arg_2] ||| [function_1] [arg_2]	count=1
arg	p [arg_2] ||| [arg_2] g [arg_1]	count=1
function	tan ||| tan	count=1
function_arg	integrate [arg_2] ||| [arg_2] [function_1]	count=5
function_arg	indefinite integral [arg_2] ||| [function_1] in [arg_2]	count=1
function	direction ratio of ||| direction cosine	count=1
arg	g function g ||| g a	count=1
function	general [function] ternary ||| diop ternary [function]	count=1
function_arg	sum [arg_2] ||| [function_1] of squares [arg_2]	count=1
function	dagger of ||| eval adjoint	count=1
function	a rational number ||| rational	count=1
class	the given dummy ||| expr	count=1
function	sdm [function_2] ||| [function_2] [function_1]	count=3
arg	[arg_1] by index ||| [arg_2] [arg_1]	count=4
class	of a point object ||| point	count=1
module	into multiple tokens ||| parsing	count=1
function	unranking ||| unrank	count=3
function_arg	[function_1] matrix ||| [arg_2] [function_1]	count=6
arg	objects and the relevant ||| objects	count=1
arg	an expression with bosonic ||| expr	count=1
function	routine creation ||| routine	count=2
arg	a coordsyscartesian with ||| vector_names	count=1
function	a literal else false ||| literal	count=1
arg	expression over ||| expr var evaluate	count=2
function	symmetric [function_2] ||| [function_2] [function_1]	count=3
arg	[arg_1] if all ||| eapply func [arg_1] [arg_2]	count=1
function	with the ||| statement	count=1
arg	space characters ||| s	count=1
module	where p[i] < p[i+1] ||| combinatorics	count=1
function_arg	lcm [arg_2] ||| [function_1] [arg_2]	count=8
function	values to ||| param dict	count=1
function	of this catagory ||| 2eq order2 type10	count=1
arg	small'' matrix m ||| deg_f deg_g	count=1
class	pstack ||| multiset partition traverser	count=1
function	gf_edf_shoup ||| gf trace map	count=2
class	sort roots ||| root	count=2
class	grid ||| growable grid	count=3
class	product with ordered ||| tens mul	count=2
class	updating ||| complex root of	count=1
function	a list of ||| list	count=7
function	[function_1] operators ||| [function_2] [function_1]	count=1
function	x start ||| process limits	count=1
function	and a primitive form ||| primitive	count=1
arg	of a [arg_2] ||| [arg_2] [arg_1]	count=36
function	p ||| p	count=2
module_class	on the [class_2] ||| [module_1] [class_2]	count=2
module	handles the ||| physics	count=1
class	[class_1] element ||| [class_1] [class_2]	count=5
arg	cheap to ||| use_trial use_rho use_pm1	count=1
arg	[arg_1] x for ||| [arg_2] [arg_1]	count=1
function	nthroot ||| nthroot	count=1
module	given ||| utilities	count=1
arg	variable with a ||| name a b	count=1
function	[function] between ||| [function]	count=2
function	permute the ||| permute	count=1
function	this heuristic finds if ||| lie heuristic	count=1
arg	or as a single ||| x a	count=1
class	of this frame in ||| frame	count=1
module	the module and the ||| utilities	count=1
arg	alpha ||| generators alpha	count=1
function	[function_1] [function_2] ||| [function_1] [function_2] func_class f symbol	count=8
function	use unicode ||| pretty use unicode	count=2
function	using subresultants over a ||| rr prs	count=1
function	finite_set in which the ||| not empty in	count=1
function	sdm ||| sdm	count=1
arg	replaced by the function ||| kwargs n	count=1
function	heuristic finds ||| heuristic	count=1
module	passes [module] ||| [module]	count=1
arg	the k-tuples of nonnegative ||| k zeros	count=1
function	single gamma matrix ||| single	count=1
function_arg	[function_1] s2 ||| [arg_2] [function_1]	count=1
function	in the object ||| free	count=1
class	for ||| fcode	count=1
function_arg	resultant [arg_2] ||| [arg_2] [function_1]	count=4
function	outer indices of a ||| indices	count=1
arg	function ||| func x0 evalf	count=1
arg	[arg_1] to z ||| [arg_1] [arg_2]	count=2
arg	if ||| min max	count=1
module	the system ||| physics mechanics	count=2
function	try to find 'executable' ||| find	count=1
arg	if it [arg] ||| [arg]	count=1
arg	multiplicities of factors using ||| f factors u	count=1
function	method returns the ||| free	count=1
module_class	[module_1] [class_2] this ||| [module_1] quantum state [class_2] operators	count=1
module	result ||| utilities	count=1
function	is monotonic in ||| is monotonic	count=1
class	in the object excluding ||| series base	count=1
function_arg	convert element ||| convert element base	count=1
function	attained by other, where ||| ge	count=1
function	properly normalized ||| normalized	count=1
function	to tensmul's argument number ||| indices to args pos	count=1
class	the relational ||| relational	count=1
function	direct [function_2] ||| [function_2] [function_1]	count=1
arg	f in f[x] ||| f	count=1
function	to values below ||| only below	count=1
arg	of a field ||| field coord_sys	count=1
arg	of subgroup [arg_2] ||| [arg_2] [arg_1]	count=2
function	the truth ||| eval cond	count=1
arg	required for constructing the ||| i j grid morphisms_str_info	count=1
function	of descents in ||| descents	count=1
arg	constants ||| matlist variable constant	count=3
function	pohlig-hellman algorithm [function_2] ||| [function_2] [function_1]	count=1
function	not-empty ||| not empty in	count=1
class	clauses from the kb ||| prop kb	count=1
arg	i in the function ||| i	count=1
function	no bounding rectangles ||| refine	count=1
function	apply the ||| apply	count=1
function	self[k j]) ||| zip	count=2
function	to power ||| pow	count=1
arg	switch to a ||| f native	count=2
arg	the given [arg_2] ||| [arg_1] [arg_2]	count=7
function	the normalized version ||| normalized	count=1
class	object excluding ||| series	count=1
function	root ||| inner	count=1
function	truncation according ||| rs	count=1
arg	rules ||| p rules x prec	count=1
arg	the index1 row ||| matlist index1	count=1
arg	0 mod(p** s ||| s p	count=1
arg	for a polynomial ||| poly	count=1
arg	g functions assuming the ||| g x	count=1
class	proper line ||| printer	count=1
arg	a given in array ||| a	count=1
arg	constant p ||| p	count=4
function	returns the opening statements ||| routine opening	count=2
function	[function_1] of degrees ||| [function_2] [function_1]	count=6
function	\mathbb q(t_1 \ldots t_k)[z]/(m_{\alpha} ||| func field modgcd m	count=1
function	[function_1] simple ||| [function_2] [function_1]	count=1
class	a standard basis in ||| sub	count=1
function_arg	associated with [arg_2] ||| [arg_2] [function_1]	count=1
function	this ||| free	count=1
function	x start stop ||| limits	count=1
function	inverse hankel [function_2] ||| [function_1] [function_2]	count=2
arg	to f ||| f c u	count=1
class	the transform in ||| transform	count=1
arg	and ||| a d	count=1
arg	dummies ||| dummies sym b_s	count=1
function	the given function class ||| function class	count=1
function	which holds for |x| ||| small	count=1
class	the polyhedra we ||| polyhedron	count=1
function	increment the [function_2] ||| [function_2] [function_1]	count=3
arg	j [arg_2] ||| [arg_2] [arg_1]	count=4
arg	d ||| d	count=6
function	product of two terms ||| mul as two	count=1
function	a partial ||| measure partial	count=1
module	matrix sum ||| matrices expressions	count=1
arg	expansion of ||| p x prec	count=4
function	the coefficient from ||| coeff	count=1
class	finiteset in ||| finite set	count=1
class	in a permutation ||| permutation	count=2
function_arg	test [arg_2] ||| [arg_2] [function_1]	count=2
arg	target to ||| target	count=1
function	letter representation ||| letter form	count=2
module	is ||| printing pretty	count=2
function_arg	expr with [arg_2] ||| [function_1] expr [arg_2]	count=4
function	path to the ||| func	count=1
function_arg	apply a [arg_2] ||| [function_1] f [arg_2]	count=3
function	wang/eez solve multivariate ||| dmp	count=1
arg	polynomial f ||| f minpoly p	count=2
arg	[arg_1] x ||| [arg_2] s [arg_1]	count=4
module	and c ||| matrices	count=1
function	around ||| power base	count=2
arg	1 2 ; -1 [arg_1] [arg_2] 1 3 2 3 ||| physics epsilon [arg_1] [arg_2]	count=1
function	ending ||| get	count=1
function_arg	dense [arg_2] ||| [function_1] sub f [arg_2]	count=1
arg	factor ||| cls factor	count=1
arg	in the given interval ||| expression interval	count=3
arg	if k == ||| k	count=1
arg	[arg_1] = a ||| [arg_1] [arg_2]	count=1
function	always create a ||| only	count=2
function_arg	x_i**k_i in [arg_2] ||| [function_1] [arg_2]	count=1
arg	token same ||| token	count=1
arg	[arg] is ||| [arg] is_set	count=3
module	calculates the angle ||| physics	count=1
arg	f a ||| f a	count=1
module	>>> from sympy core ||| core	count=1
arg	rank [arg] less ||| [arg]	count=1
function	[function_1] the substitution ||| [function_2] [function_1]	count=3
function	strictly [function_2] ||| [function_2] [function_1]	count=6
module	without the added integration ||| physics	count=1
arg	not self and s2 ||| s2	count=1
function	expressions generated ||| vprint	count=1
class	of non-conjugate ||| root of	count=1
function_arg	field [arg_2] ||| [arg_2] [function_1]	count=1
arg	q divides p ||| q p all_roots	count=3
class	no bounding rectangles ||| complex root of	count=1
arg	true if other ||| other	count=4
class	inverse ||| single continuous distribution	count=1
function	string path ||| mod func	count=2
arg	is delta ||| delta	count=1
function	to values below fermi? ||| only below fermi	count=1
function	sopform ||| sopform	count=1
module	indicate if the ||| physics	count=1
arg	indices are ||| indices free dum	count=1
arg	a to [arg_2] ||| [arg_2] [arg_1]	count=6
function_arg	[function_1] a morphism ||| [arg_2] [function_1]	count=4
function	is a set ||| is	count=1
function	equation is ||| is	count=1
module	to make a polynomial ||| polys domains	count=1
module	select a [module] ||| [module]	count=3
function	module and the ||| get	count=1
function_arg	continuous subsequence [arg_2] ||| [function_1] in [arg_2]	count=1
function	rewrite the integral ||| rewrite	count=2
function_arg	[function_1] expansion of ||| [function_1] nth root p [arg_2]	count=1
function	returns a 3-tuple ||| three	count=1
function	a floating point number ||| float	count=1
function_arg	tree [arg_2] ||| [function_1] cse [arg_2]	count=1
class	generate a ||| free module	count=2
function	always destroy ||| only q annihilator	count=1
class	take on ||| series base	count=1
function	intervals the expr cond ||| expr cond	count=1
module	equation or with ||| solvers	count=1
arg	key if the key ||| key	count=1
module	standard basis in ||| polys agca	count=1
function	is written ||| coeff	count=1
function	set from [function_2] ||| [function_2] [function_1]	count=8
class	orbit ||| permutation group	count=2
arg	[arg_1] modulo o(x**prec) ||| [arg_2] [arg_1]	count=2
function	gcd using subresultants over ||| ff prs gcd	count=1
function	sliding cart under ||| cart	count=1
function	symbol ||| symbol	count=6
function	computes polynomial gcd of ||| gcd	count=1
arg	[arg_1] and dum ||| [arg_2] [arg_1]	count=1
function	lower in rank than ||| sub	count=1
class	layout ||| grid	count=1
arg	key ||| key new	count=1
arg	whether indices are covariant ||| indices	count=1
function	which when printed will ||| named	count=1
class	components [class_2] ||| [class_2] [class_1]	count=2
function	of ||| get mod func	count=1
module	tensor with an ||| tensor	count=1
arg	[arg_1] k1 ||| [arg_1] [arg_2]	count=3
function	a property where ||| property	count=1
function	to a [function_1] [function_2] ||| [function_1] [function_2]	count=1
module	in a quantum ||| physics quantum	count=1
module	of a [module] examples ||| [module]	count=2
arg	of an interval ||| x	count=7
function	take on a ||| free	count=1
function	quadratic ternary diophantine ||| diop ternary quadratic normal	count=1
function	the rank of a ||| rank	count=1
arg	with h ||| h	count=1
function	g = [function] a1 ||| split [function]	count=1
class	schreier ||| permutation group	count=1
function	of non-conjugate ||| complexes	count=1
class	of symbolic values to ||| llvmjit code	count=1
function	series ||| intcurve series	count=1
function_arg	[function_1] [arg_2] ||| [function_1] list [arg_2]	count=8
arg	vector of constants ||| variable constant k	count=3
function	continuous ||| continuous	count=2
function	[function_1] [function_2] ||| [function_1] [function_2] expression interval symbol	count=6
function_arg	parameters [arg_2] ||| [arg_2] [function_1]	count=1
arg	is replaced by the ||| kwargs	count=1
arg	in ||| k	count=6
arg	a field [arg_2] ||| [arg_1] [arg_2]	count=1
arg	infinitesimals of [arg_2] ||| [arg_1] func [arg_2]	count=1
module_class	this dyadic ||| vector dyadic	count=1
module	using the dual ||| physics	count=1
function	tensor product of ||| tensor printing	count=1
arg	f from k0 ||| f u k0	count=1
function	generates the previous ||| prev	count=2
function	inverse mellin transform ||| inverse mellin transform	count=3
arg	with length l2 on ||| l2	count=1
function	of ode [function_2] ||| [function_2] [function_1]	count=2
function	horizontal morphism [function_2] ||| [function_2] [function_1]	count=4
class	return a simplified intersection ||| intersection	count=1
arg	the function f ||| f args	count=1
function	a [function] ||| minpoly [function]	count=1
function	complex ||| complex	count=2
module_class	[module_1] assumptions ||| [module_1] [class_2]	count=2
function	objects by distributing ||| tensors from components free	count=1
function	the traditional rules of ||| traditional	count=1
function	[function_1] distributed ||| [function_2] [function_1]	count=4
module_class	[module_1] regularpolygon ||| [module_1] [class_2]	count=4
function	be in integer ||| pure symbol int	count=1
arg	to name and token ||| name token	count=1
arg	that no bounding rectangles ||| cls	count=1
class	multiply ||| poly ring	count=1
function	[function_1] matrix of ||| [function_1] [function_2]	count=2
arg	z [arg_2] ||| [arg_1] [arg_2]	count=1
arg	f and for each ||| a d	count=1
arg	a field in ||| field	count=1
module	return number ||| core	count=1
arg	root [arg] ||| cls complexes [arg]	count=1
function	real ||| real	count=15
function	k[x] ||| dup	count=8
function	the hilbert space ||| eval hilbert space	count=2
function_arg	the length [arg_2] ||| [arg_2] [function_1]	count=2
function	product [function_2] ||| [function_2] [function_1]	count=2
function	[function_1] cond ||| [function_1] [function_2]	count=4
function	topological sort of ||| topological sort	count=2
module	of all units ||| units	count=1
function	at module [function] time ||| [function]	count=1
arg	integrate f ||| f	count=2
arg	in \mathbb{z}_p[z]/(\check m_{\alpha} ||| p	count=1
arg	k l ||| l k	count=2
function	function prototype ||| get prototype	count=2
function_arg	coefficient [arg_2] ||| [arg_2] [function_1]	count=1
function	primitive ||| dmp primitive	count=1
function	the third heuristic ||| lie heuristic bivariate	count=1
arg	matrix ||| m	count=1
module	rayleigh range from the ||| physics	count=1
function	superset of 'other' ||| superset	count=1
function	adds ||| add	count=4
function_arg	generates [function_1] [arg_2] permutation group ||| combinatorics [function_1] group [arg_2]	count=1
arg	n x n ||| n	count=2
module	given lie algebra ||| liealgebras	count=1
function_arg	[function_1] cf ||| [arg_2] [function_1]	count=1
class	the kb ||| fact kb	count=1
arg	c[n]*p**n modulo o(x**prec) ||| x prec	count=1
module_class	[module_1] this fermionicoperator ||| [module_1] [class_2]	count=8
function_arg	1st [arg_2] ||| [function_1] linear eq func [arg_2]	count=1
arg	of f [arg_2] ||| [arg_2] s [arg_1]	count=1
function_arg	index of [arg_2] ||| [function_1] [arg_2]	count=4
function_arg	[function_1] bits ||| [arg_2] [function_1]	count=1
arg	n a real ||| n	count=1
function	[function_1] expression in ||| [function_1] [function_2]	count=2
function	cyclotomic [function_2] ||| [function_2] [function_1]	count=3
arg	a field ||| field coord_sys	count=1
arg	in a rational ||| f g include	count=1
function	reduce the [function_2] ||| [function_2] [function_1]	count=1
arg	f in ||| f gen	count=1
function	bounding rectangles ||| refine	count=1
module	the qdot's ||| physics	count=1
arg	an expression with ||| expr	count=1
arg	[arg_1] q[x] ||| [arg_2] [arg_1]	count=1
arg	group [arg] as a ||| [arg]	count=1
function	homomorphism with same domain/codomain ||| hom	count=1
function	continuous subsequence ||| slice	count=5
function	to another fraction ||| from fraction	count=1
function_arg	is [arg_2] ||| [function_1] tangent [arg_2]	count=1
arg	a morphism and ||| morphism	count=1
class	of polynomials or containers ||| ring	count=1
function	add c(x_2 x_u)*x_0**i to ||| dmp add term	count=1
function	returns speed ||| speed	count=1
function	in which ||| not empty in	count=1
function	the tree as a ||| tree	count=1
function	[function_1] [function_2] matrixbase arguments ||| [function_1] [function_2] matadd	count=1
function_arg	inverse [arg_2] ||| [function_1] [arg_2]	count=3
class	on a specific ||| series	count=1
arg	field in k[x] ||| u k	count=1
function	sequence in [function_2] ||| [function_2] sin [function_1]	count=1
function	proper subset ||| proper subset	count=2
function	a rule [function] ||| top [function]	count=1
function	line plot ||| line	count=1
function	evaluate [function_2] ||| [function_2] [function_1]	count=3
arg	characters of symbols ||| symbols	count=1
arg	gen ||| gen	count=1
function	rotate a ||| rotate	count=1
arg	polynomials in \mathbb{z}_p[z]/(\check m_{\alpha} ||| p	count=1
function	[function_1] transversals from ||| [function_2] [function_1]	count=1
function	trace of a single ||| trace single	count=1
module	assuming that ||| solvers	count=1
function	the generator ||| generator	count=1
function_arg	[function_1] given annihilator ||| [function_1] [arg_2]	count=1
function	a polynomial ||| poly	count=9
arg	level ||| level	count=1
function_arg	the posform function ||| posform variables	count=1
arg	of symbols ||| symbols	count=1
function	delta ||| delta	count=1
class	computes polynomial ||| poly	count=2
function	the name of the ||| get mod	count=1
function	proper line ending ||| get statement	count=1
function	sympy coefficients ||| sympy	count=3
arg	sum c[n]*p**n modulo o(x**prec) ||| p c x prec	count=1
class	d) [class] a, such ||| [class]	count=1
function	to replace [function_2] ||| [function_1] [function_2]	count=4
class	roots ||| type g	count=1
function_arg	separable 1st [arg_2] ||| [arg_2] [function_1]	count=1
arg	fringe [arg_2] ||| [arg_1] [arg_2]	count=3
function	+ cz^2 + dxy ||| to normal	count=1
class	a specific ||| series	count=1
function_arg	function prototype [arg_2] ||| [function_1] [arg_2]	count=2
arg	a and b by ||| a b	count=1
function	returns all ||| all	count=1
arg	an interval s t ||| s t k	count=1
module_class	the constructor for [module_1] [class_2] object ||| [module_1] [class_2] new cls	count=1
arg	[arg_1] suitable ||| [arg_1] [arg_2]	count=2
class	space rotation is similar ||| space orienter	count=1
module	returns gcd of ||| polys	count=2
function	find_substitutions sympy's [function] some ||| manual [function]	count=1
function	over a ring ||| dup rr	count=3
function	a wrapper [function_2] ||| [function_2] [function_1]	count=2
function	groups ||| comm	count=1
arg	numbers v ||| v	count=1
function	[function_1] the derivative ||| [function_1] [function_2]	count=2
arg	the mapping in rules ||| p rules x	count=1
arg	given [arg_2] ||| [arg_2] [arg_1]	count=13
arg	where m ||| m	count=1
arg	intervals in the ||| f	count=1
function	cart under ||| cart	count=1
function	string path to ||| get mod func	count=2
function	gray [function_2] ||| [function_1] [function_2]	count=1
arg	p [x] ||| p	count=3
function_arg	[function_1] f given ||| [arg_2] [function_1]	count=8
function	[function_1] functions ||| [function_2] [function_1]	count=4
arg	[arg_1] in the ||| [arg_1] [arg_2]	count=1
module	value of ||| elementary	count=1
module	identities from the ||| physics quantum	count=1
arg	for suitability ||| t ct	count=1
module	compared to [module] canonical ||| [module]	count=1
arg	[arg_1] target_matrix ||| [arg_1] [arg_2]	count=2
class	formats a ||| code printer	count=1
module_class	of real ||| polys real	count=3
arg	b [arg_2] ||| [arg_2] [arg_1]	count=6
function	[function_1] [function_2] given interval ||| [function_1] [function_2] expression interval symbol	count=3
function	dmp_validate ||| validate	count=1
function	returns the intersection ||| intersect	count=2
function	unicode output is available ||| pretty try use unicode	count=1
function	raised l-levels ||| raise	count=1
arg	length l1 [arg_2] ||| [arg_1] [arg_2]	count=1
function	quaternion [function] coordsyscartesian ||| orient [function]	count=1
arg	c if c ||| c min	count=1
arg	[arg] radians ||| [arg]	count=9
arg	f x the idea ||| f x	count=1
function	an immutable version ||| as immutable	count=2
arg	rule to args ||| rule fns	count=1
function	return the series expansion ||| series	count=1
arg	returns the expected value ||| condition numsamples evaluate	count=1
function	a simplified [function_2] ||| [function_2] [function_1]	count=4
class	or containers of polynomials ||| poly ring	count=1
function	single g functions ||| single	count=1
arg	using _dcm_dict ||| num	count=1
module	see ||| printing pretty	count=2
class	sequences ||| seq	count=2
function	space ||| indent	count=1
arg	a mobius transform or ||| k eps	count=1
function	outer indices ||| indices	count=1
class	from the kb examples ||| kb	count=1
arg	variable with a ||| name mean std	count=1
arg	an equivalent sentence ||| expr	count=2
arg	[arg_1] its attributes ||| [arg_2] [arg_1]	count=2
arg	of symbols with ||| symbols filter	count=1
function	[function_1] extension ||| [function_1] ipython [function_2]	count=1
arg	l [arg_2] ||| [arg_1] [arg_2]	count=4
function	a new copy ||| copy	count=1
function	form x start ||| process limits	count=1
function	[function_1] matrix to ||| [function_1] [function_2]	count=2
arg	has already been sympify'ed ||| domain _check	count=1
arg	the curl ||| vect	count=1
arg	string s ||| s	count=1
arg	[arg_1] a diagram ||| [arg_2] grid [arg_1]	count=5
function	heuristic uses the following ||| heuristic	count=1
function	to simplify the theory ||| simplify	count=1
module	the functions in ||| calculus	count=1
module	if the underlying dimension ||| physics units	count=1
function_arg	irreducible factors [arg_2] ||| [function_1] list [arg_2]	count=1
function	[function] starting ||| assoc [function]	count=1
class	fockstateket else multiply ||| annihilate boson	count=1
arg	g using ||| g	count=1
arg	in the given ||| f symbol	count=3
function	the module and the ||| get mod func	count=1
module_class	[module_1] [class_2] ||| [module_1] sparse [class_2]	count=3
class	that take on a ||| series base	count=1
module_class	polynomial generators ||| polys frac field	count=1
function	of type immutabledensematrix ||| as explicit	count=1
arg	opportunities ||| exprs	count=1
function	dmp_eval_tail ||| eval tail	count=1
arg	[arg_1] [arg_2] ||| divergence [arg_1] [arg_2]	count=2
function	[function_1] that ||| [function_2] [function_1]	count=6
arg	an uncoupled tensor product ||| expr jcoupling_list	count=1
arg	[arg_1] m_1 ||| clebsch gordan [arg_1] j_2 j_3 [arg_2]	count=1
module	the following for the ||| physics	count=1
function	sets ||| set	count=3
class	limits ||| expr with int limits	count=1
arg	with public key i ||| i key	count=1
function	string representation of ||| str	count=2
class	single ||| var	count=1
module	ll ||| physics quantum	count=1
arg	the diagram ||| diagram	count=1
class	partition ||| integer partition	count=2
function	undetermined coefficients ||| undetermined coefficients	count=3
function	loop ||| process loop	count=1
function	returns the variables with ||| variables	count=1
module_class	underlying dimension [class_2] ||| [module_1] [class_2]	count=1
arg	the factors ||| factors	count=1
function	an ode ||| ode	count=2
function	square-free factorization ||| splitfactor sqf	count=1
function	a constant [function_2] ||| [function_1] [function_2]	count=2
function	asin of p, ||| rs asin	count=1
class	rectangles ||| of	count=1
arg	of rv ||| rv	count=1
class	over distribution ||| distribution	count=2
module	a matrix containing ||| mechanics	count=1
function	an integer ||| to integer	count=1
function	name of the class ||| get mod func	count=1
module	containing the [module] n ||| [module]	count=1
function	single [function_2] ||| [function_1] [function_2]	count=2
arg	stabilizer ||| schreier_vector _random_prec	count=1
function_arg	[function_1] order ||| [function_1] linear eq func [arg_2]	count=1
function	coefficient ||| cse	count=1
function	of the non-zero structure ||| row structure	count=1
arg	element elem of self ||| elem	count=1
arg	degree d with ||| d	count=2
arg	create ||| dom	count=1
class	gate needs to ||| gate	count=2
class	a list ||| frac field	count=1
arg	polynomial f in ||| f	count=3
function	version of scan routine ||| scan	count=2
arg	form x start stop ||| func	count=1
function_arg	of rational [arg_2] ||| [function_1] [arg_2]	count=1
function	reconstruct a rational ||| integer rational reconstruction	count=3
function	flatten a ||| flatten	count=1
function	+ cz^2 + ||| to normal	count=1
function_arg	function field [arg_2] ||| [function_1] [arg_2]	count=1
arg	ith prime number ||| i	count=1
class	standard ||| sub module	count=1
function	increasing ||| increasing	count=1
arg	given expression ||| expr ratio	count=2
arg	n data points ||| n x x	count=1
function	isomorphism [function_2] ||| [function_2] [function_1]	count=1
class	operator s [class_1] [class_2] of ||| quantum [class_2] [class_1] operators	count=1
function	the logarithmic derivative of ||| log deriv	count=1
function_arg	core [arg_2] ||| [function_1] [arg_2]	count=3
arg	where each [arg] ||| expr [arg]	count=1
function_arg	inversion 1/p modulo ||| inversion p	count=1
function	a common header ||| get header	count=2
function	given ||| from expr if	count=2
function_arg	[function_1] gen in ||| [arg_2] [function_1]	count=1
function	the discriminant of ||| discriminant	count=1
function	to a class into ||| get mod	count=1
arg	triangle and an edge ||| triangle	count=1
arg	of terms of ||| x	count=1
arg	by a an ||| c	count=2
module	if k in ||| core	count=1
function	the leading monomial ||| lm	count=1
arg	of n and either ||| factors n	count=1
arg	\xi and \eta to ||| match comp	count=1
function	hyperexponential functions ||| hyperexponential	count=1
class	any ||| integral	count=1
arg	term s containing x**n ||| right	count=1
arg	using vincent-akritas-strzebonski vas ||| f k	count=1
function	to an ode from ||| ode 1st	count=1
function	opening statements of ||| routine opening	count=2
arg	qubit labels from ||| labels	count=1
function	assuming [function] >>> ||| [function]	count=1
arg	input k \in [0 ||| k	count=1
function	inverse using cholesky or ||| eval inverse	count=1
arg	changes the [arg_2] ||| [arg_2] [arg_1]	count=2
module	element from the ||| combinatorics	count=1
function	this sparsematrix ||| eval	count=1
module	product [module] x dyadic ||| [module]	count=1
function	[function_1] strictly increasing ||| [function_1] [function_2]	count=4
function	an apply ||| apply operator	count=1
function	+ a [function_2] ||| [function_1] [function_2]	count=1
class	list of tuples index ||| index structure	count=1
function	magnitude ||| magnitude	count=1
function_arg	term [arg_2] ||| [function_1] p [arg_2]	count=2
module	state instance ||| quantum	count=1
module	return numerator factor of ||| core	count=1
class	returns a standard basis ||| module	count=1
function	indices of a ||| get indices	count=1
arg	checks if a given ||| eps	count=1
module	set the ||| physics	count=1
class	reduce ||| sub module poly ring	count=1
arg	g and order o ||| g o k	count=1
function	is treated as an ||| as	count=1
function	to solve ||| solve	count=1
arg	of fpgroup h a ||| fp_grp h	count=1
class	of a diagram ||| diagram grid	count=1
function_arg	if key is in [function_1] [arg_2] to ||| categories diagram [function_1] union dictionary [arg_2] value	count=3
module	this returns the ||| physics	count=4
function	in ||| empty in	count=2
arg	to name and ||| name	count=1
function	string of [function] ||| [function]	count=8
function_arg	monomials from [arg_2] ||| [arg_2] [function_1]	count=1
function	heuristic assumes the ||| lie heuristic bivariate	count=1
arg	defined as ||| k r nu	count=1
class	generated ||| extension	count=1
function	a matrix ||| matrix	count=3
arg	components ||| components	count=1
function	[function] method ||| [function]	count=1
arg	of indices in ||| indices	count=1
arg	the key ||| key	count=2
module_class	find the [class_2] ||| [module_1] quantum [class_2]	count=1
arg	trig over [arg] >>> from ||| f [arg]	count=1
arg	for this language ||| expr	count=1
function	and negative coefficient ||| opt cse	count=1
function	x**q = ||| nthroot mod1	count=1
arg	mod(p** s + 1 ||| s	count=1
class	representation of ||| table form	count=1
arg	find optimization opportunities in ||| exprs order	count=1
function	computes the derivation of ||| derivation	count=1
module	return a ||| polys agca	count=1
module	polynomials in ||| polys	count=1
function	decimal ||| decimal	count=1
arg	p [x] polynomial ||| p symmetric	count=1
class	the total ||| g	count=1
arg	the ith ||| i	count=9
function_arg	[function_1] [arg_2] ||| [function_1] certificate [arg_2]	count=3
function_arg	each element [arg_2] ||| [function_1] [arg_2]	count=1
function	sympy's [function] some trig ||| manual [function]	count=1
function	into a string ||| get mod func	count=1
module	that take on ||| series	count=1
function	new coordsyscartesian ||| init	count=1
function	with hash [function_2] ||| [function_2] [function_1]	count=1
arg	x representing ||| x	count=1
function	returns the rank ||| rank	count=1
arg	is a model ||| expr model	count=1
function	[function] function ||| add simple [function]	count=1
function	the string ||| mod	count=1
class	this [class] and another ||| [class]	count=1
arg	in [arg_2] ||| [arg_1] a [arg_2]	count=1
function	[function_1] scalar ||| geometry point [function_1] [function_2]	count=1
function	returns maximal degree for ||| max	count=1
class	and sort roots ||| complex root	count=1
function	test [function_2] ||| [function_1] [function_2]	count=2
function	returns true if ||| is	count=5
function_arg	prints expr ||| print expr	count=1
function	order of gate ||| gate	count=1
module	sum that ||| simplify	count=1
class	code [class_2] ||| [class_1] [class_2]	count=2
class	product [class_2] ||| tensor [class_2] [class_1]	count=1
arg	in circuit ||| circuit	count=2
function	hypertangent polynomials ||| hypertangent	count=1
module	number ||| liealgebras	count=1
arg	quadratic equation eq ||| eq	count=1
function	real roots of ||| dup count real roots	count=1
arg	p in ||| f p u k	count=1
arg	[arg_1] [arg_2] is a string and ||| symbol [arg_2] [arg_1]	count=3
module	the list ||| physics	count=1
arg	using g functions ||| g x	count=1
function	[function_1] using ||| [function_2] [function_1]	count=7
arg	a readable object for ||| pkgname	count=1
function	[function_1] an algebraic ||| [function_1] [function_2]	count=2
function	terms to [function_2] ||| [function_1] [function_2]	count=1
arg	tuple x ||| x	count=1
class	arguments for the function ||| function	count=1
function	initialize a ||| init	count=1
function	[function] number with ||| [function]	count=2
arg	of f in ||| f k	count=5
function	christoffel symbols for the ||| to christoffel 2nd	count=1
function	a general hankel ||| hankel	count=1
arg	of the terms of ||| x x0	count=1
arg	in k[x] ||| polys u k	count=2
function	unicode output ||| pretty try use unicode	count=1
function	right [function] by its ||| [function]	count=1
arg	p modulo o(x**prec) ||| p x prec	count=2
function	over a ||| dup rr	count=3
class	sequence of polynomials or ||| poly ring	count=1
arg	or as a single ||| a b	count=1
class	explicitly returns an object ||| expr	count=1
arg	the series expansion of ||| p x prec	count=4
function	roots of a ||| roots	count=4
function	flatten a 1x1 ||| flatten	count=1
arg	[arg] to ||| dictionary [arg]	count=3
class	sequence ||| seq	count=4
module_class	[module_1] atoms ||| [module_1] [class_2]	count=2
module	that converts a general ||| solvers	count=1
function	the ||| cond	count=2
arg	returns true if other ||| other	count=3
module	available and ||| printing pretty	count=1
module	a simple kroneckerdelta ||| concrete	count=1
arg	terms of ||| x n logx	count=1
arg	bring expr ||| expr	count=1
function	cyclically reduced or not ||| cyclically reduced	count=1
arg	apply f ||| f	count=1
class	formats ||| code printer	count=2
function	add two simple ||| add simple	count=2
function_arg	key [arg_2] ||| [function_1] [arg_2] triangle_sizes	count=1
class	of current ||| base	count=2
arg	[arg] terms ||| [arg]	count=1
class	for ||| octave	count=1
function_arg	[function_1] symbols ||| [function_1] subs expr [arg_2]	count=1
function	of conjunctions and disjunctions ||| distribute or over and	count=1
function	squares of which sum ||| sum of squares	count=1
arg	in terms of ||| x n	count=1
arg	running it ||| fns	count=1
arg	(i ||| dom_i cod_i dom_j cod_j	count=1
function	imaginary ||| imaginary	count=1
function_arg	[function_1] p q ||| [arg_2] [function_1]	count=2
function	digamma function is ||| digamma	count=1
function	to a numpy ||| to	count=1
function	the normalized [function] given line ||| [function]	count=1
module	given vector in ||| vector	count=1
arg	given level ||| level args	count=1
function_arg	[function_1] in h ||| [arg_2] [function_1]	count=5
function	those ||| free	count=1
function	a gate identity ||| identity	count=1
function	ode from the two ||| ode 1st	count=1
function	exact quotient ||| dmp exquo	count=1
function	transposed sparsematrix of this ||| transpose	count=1
class	generated files ||| octave	count=1
class	return the truth ||| piecewise	count=1
function	adds a ||| add morphism closure	count=1
module	this ||| series	count=1
arg	k -> returns ||| k	count=1
function	plots a 3d [function_1] [function_2] ||| [function_1] [function_2]	count=4
module	of ||| geometry	count=1
function	the minimal polynomial ||| minpoly op algebraic element	count=1
module	a given vector in ||| vector	count=1
module	the fermi surface? ||| physics	count=3
function	build a ||| build product	count=1
arg	to ||| modulus power_base power_exp	count=1
function	label is the ||| label	count=1
class	returns a standard ||| module poly	count=1
function	tensor ||| combined tensor printing	count=1
arg	function which ||| function	count=2
module	the function in the ||| physics	count=1
module	polynomial with a ||| polys	count=1
arg	j_3 j_4 j_5 ||| j_3 j_4	count=4
class	permutation ie the location ||| permutation	count=2
function	method of variation of ||| variation of	count=1
function	dot product of ||| dot	count=1
arg	to ||| tol a	count=1
class	or containers of polynomials ||| poly	count=1
function	addition of 'self' and ||| add	count=1
function	fraction ||| from qq	count=2
arg	[arg_1] to k1 ||| [arg_2] [arg_1]	count=3
function	and ||| pretty	count=1
function	system of ||| system	count=1
module	in [module_2] ||| [module_1] [module_2]	count=3
function	maximum of a list ||| imax	count=1
arg	given scalar field ||| scalar_field	count=1
function	path ||| mod	count=2
function	when ||| coeff	count=1
module	returns the positions of ||| combinatorics	count=2
arg	the base b ||| b order	count=3
function	[function_1] generators ||| [function_1] [function_2]	count=3
module	the [module_2] ||| [module_1] [module_2] differential operator function	count=1
module	[module_1] units ||| [module_1] [module_2] quantity scale factor	count=2
function	symmetric ||| symmetric	count=5
class	that no ||| complex root of	count=1
class	[class_1] root to ||| [class_1] [class_2]	count=1
function	the width of the ||| width	count=1
function_arg	affine [arg_2] ||| [arg_2] [function_1]	count=2
module	permutation using a possibly ||| combinatorics	count=1
function	dictionary from [function_2] ||| [function_2] [function_1]	count=1
function	are ||| 2eq	count=4
function	subprocess with ||| subprocess with	count=1
function	minimal polynomial for the ||| minimal polynomial	count=1
arg	rs\_sin p x ||| p x	count=2
function	returns [function_2] ||| [function_1] [function_2]	count=15
arg	the polynomial f ||| f	count=1
module_class	[module_1] controlled gate ||| [module_1] [class_2]	count=2
function	of single g functions ||| single	count=1
module_class	the parabola ||| geometry parabola	count=2
arg	value of the ||| cls	count=1
function	polynomial ring ||| poly ring	count=3
function	[function_1] the trivial ||| [function_1] [function_2]	count=1
function	ternary diophantine ||| diop ternary	count=1
function	[function] derivative symbol ||| requires [function]	count=3
class	non-conjugate ||| root	count=1
function_arg	negate a [arg_2] ||| [function_1] [arg_2]	count=2
function	x**q ||| nthroot mod1	count=1
arg	e ||| e	count=9
function	coherent states of ||| coherent state	count=1
module	the dictionary mapping ||| physics quantum	count=1
arg	in expr, given that [arg_1] [arg_2] ||| integrals simplifyconds [arg_1] [arg_2]	count=1
function	transposed sparsematrix of ||| transpose	count=1
arg	as a single ||| a	count=1
arg	p q are polynomials ||| p q x	count=5
module	given the faces of ||| combinatorics	count=1
class	sought after ||| oracle gate	count=1
arg	optimization ||| order	count=1
function	maximal degree ||| max	count=1
class	in ||| expr	count=4
function_arg	power [arg_2] ||| [function_1] [arg_2]	count=2
arg	algorithm ||| f x	count=1
function	to the ||| convert to	count=1
module	line ||| printing	count=1
arg	constant p in k ||| f p k	count=1
function	a raw [function_2] ||| [function_1] [function_2]	count=1
class	list ||| field	count=1
arg	implementation of ||| sm	count=1
function	expand the first add ||| expand	count=1
arg	h a subgroup ||| h	count=1
arg	[arg] to a ||| [arg]	count=9
function	[function_1] [function_2] ||| [function_1] sympy [function_2]	count=4
arg	b m ||| b a b	count=1
function	a constant ||| constant	count=1
arg	a polynomial f ||| f i	count=1
function	[function_1] the extension ||| [function_2] [function_1]	count=1
arg	compute the ||| f g	count=1
function	refine ||| dup outer refine real	count=1
arg	y] to k[x][y] ||| u k front	count=1
function	optimization opportunities in ||| opt cse	count=1
function	is redundant by ||| is	count=1
function	gives the direction ||| direction	count=2
function	class for specific integer ||| integer	count=1
arg	f into a ||| f u	count=1
arg	implementation ||| sm	count=1
function	in x_0 ||| in x0	count=1
function	[function_1] polynomial for ||| [function_1] [function_2]	count=4
arg	p q x ||| p q x	count=3
function	[function_1] points ||| [function_1] [function_2]	count=2
arg	\xi and \eta ||| match comp	count=4
arg	expr >>> from sympy ||| expr	count=1
class	subrange of pstack ||| multiset partition traverser	count=1
class	the transform in ||| integral transform	count=1
class	the location where ||| permutation	count=2
function	3-axis ||| axis3	count=1
arg	rank k this method ||| rank	count=1
function	always ||| only	count=3
function	tests for independence between ||| pspace independent	count=1
class	representation with ||| anp	count=2
class	matrix ||| sparse	count=1
arg	wrt a given ||| coord_sys	count=1
function	add two roots together ||| add	count=1
module	mathml code ||| utilities mathml	count=1
arg	of msg ||| msg key	count=1
function	returns the index ||| index	count=2
class	no bounding rectangles ||| of	count=1
function	equations of ||| equations	count=1
class	a ||| free module poly	count=1
function	the fourth [function] ||| lie [function]	count=3
function	[function_1] consistent ||| [function_2] [function_1]	count=1
arg	of alpha as ||| degree generators alpha pairs	count=1
module	and the ||| utilities	count=1
function	a comment ||| get comment	count=1
function	previous [function_2] ||| [function_1] [function_2]	count=2
class	homomorphism obtained ||| homomorphism	count=1
function	and leverage ||| pretty	count=1
module	value ||| elementary	count=1
function	the sum of k ||| do sum of	count=1
function	opening statements of the ||| opening	count=2
function_arg	encryption of [arg_2] ||| [function_1] rsa [arg_2]	count=2
arg	with p == ||| p	count=1
arg	input from the user ||| weylelt	count=1
function	\mathbb{z}[x_0 \ldots x_{k-1}] ||| multivariate	count=1
function	direct products ||| af direct product	count=1
function	finds ||| empty in	count=1
function	a continuous subsequence ||| slice	count=5
function	state ||| state	count=2
arg	f defined ||| f k r nu	count=1
function	primitive_element() ||| coeffs generator	count=1
function	is linear in all ||| is linear	count=1
function	sides ||| sides	count=1
class	finiteset ||| finite set	count=1
class	a fraction ||| fraction	count=1
function	the indefinite integral of ||| integrate	count=3
function_arg	pseudo-quotient of [arg_2] ||| [function_1] [arg_2]	count=2
module	the given ||| utilities	count=1
function	p-1 ||| pollard pm1	count=1
arg	[arg] integer and ||| [arg]	count=1
function	ode ||| ode 1st homogeneous	count=1
function	create a new copy ||| copy	count=1
class	generated ||| differential extension	count=2
function	of space ||| indent	count=1
function_arg	[function_1] component ||| [arg_2] [function_1]	count=3
arg	in ||| f p	count=2
function	for a diagonal morphism ||| diagonal	count=1
function	[function_1] polynomial gcd ||| [function_2] [function_1]	count=3
arg	p of ||| p t z	count=1
arg	an element of g ||| g	count=1
function	[function_1] derivative of ||| [function_2] [function_1]	count=4
arg	f in ||| f k	count=5
function	anp object to ||| algebraic field	count=3
function	rewrites ||| rewrite as heaviside	count=1
class	internal one step complex ||| complex	count=1
module	the gcd of ||| polys	count=2
module	available and leverage it ||| printing pretty	count=1
arg	influence ||| n cart_force joint_torques	count=1
function	into ||| func	count=1
function	value (i ||| free	count=1
function	return true if ||| p	count=1
arg	lagrangian : sympifyable ||| lagrangian	count=1
arg	for f p q ||| f p q	count=1
function	over a ring ||| rr	count=5
class	a group ||| group	count=2
function	of spherical harmonics ||| ynm	count=1
class	entity which passes through ||| entity	count=1
arg	of f by ||| f g auto	count=3
function	dummies can ||| ordered dummies	count=1
arg	bounding rectangles ||| cls	count=1
arg	if it ||| symbol	count=1
function	a blockmatrix of blockmatrices ||| deblock	count=1
arg	add numerical implementation ||| implementation	count=1
function	mpq object to ||| qq	count=6
arg	constants [arg] ||| [arg] symbolname startnumber	count=2
function_arg	power or [arg_2] ||| [arg_2] [function_1]	count=2
function	uses the mul hint ||| mul	count=1
arg	irreducibility test ||| p	count=1
module	vector in ||| vector	count=3
function	the generators ||| generators	count=1
arg	f [arg_2] ||| hypersimp [arg_1] [arg_2]	count=1
arg	efficiently test if f ||| f k irreducible	count=1
arg	a rational [arg] modulo the ||| [arg]	count=1
class	string of [class_2] ||| [class_2] [class_1]	count=1
class	permutations in the group ||| permutation group	count=1
function_arg	lcm of [arg_2] ||| [arg_2] [function_1]	count=9
function	a class into ||| get mod func	count=1
function	symbols in the ||| free symbols	count=1
function	and primitive ||| primitive	count=1
class	[class_1] group ||| [class_2] [class_1]	count=1
function	sparse [function_2] ||| [function_2] [function_1]	count=2
function	[function_1] even ||| [function_2] [function_1]	count=1
arg	polynomial p in ||| f p	count=1
arg	constants ||| variable constant k	count=3
function	scale ||| scale	count=1
module	string path to ||| utilities	count=2
arg	sym ||| sym	count=1
function	subprocess with hash ||| in subprocess with hash	count=1
class	mapping of ||| llvmjit code	count=1
function	returns the directional ||| directional	count=1
arg	and ||| s	count=1
function	a principal ||| principal	count=1
module	generate ||| polys	count=2
arg	eq ||| eq	count=7
arg	column ||| column k	count=1
arg	check whether u v ||| u v	count=1
function	[function_1] conditions to ||| [function_1] beta [function_2]	count=1
function	a functional decomposition ||| decompose	count=1
function_arg	[function_1] function to ||| [function_1] f [arg_2]	count=1
function	commutator of ||| commutator	count=1
arg	compute the [arg_2] ||| [arg_2] [arg_1]	count=5
class	a cython file ||| cython	count=1
function	the 3-axis ||| axis3	count=1
function	return the minimal polynomial ||| minpoly op	count=1
function	construct c*b1 + ||| add	count=1
class	derivative ||| derivative	count=1
function	return the minimal polynomial ||| minpoly op algebraic	count=1
function	the argument of ||| argument	count=1
arg	create a continuous ||| mu k	count=1
arg	by multiplying by [arg_1] [arg_2] ||| [arg_1] [arg_2]	count=17
function	return the ||| cond	count=1
arg	no = ||| no	count=1
class	expansion of the function ||| function	count=1
arg	[arg] piecewise ||| [arg]	count=3
function	domain of the functions ||| not empty	count=1
module	module ||| utilities	count=1
function	returns the coefficient ||| coeff	count=3
arg	first order ||| func order	count=2
class	matrix for [class] cartan ||| [class]	count=1
function	to ||| param	count=1
arg	[arg_1] a symbol ||| [arg_2] [arg_1]	count=6
module	permutation using ||| combinatorics	count=1
function	[function_1] method to ||| [function_1] [function_2]	count=1
function	alpha [function_2] ||| [function_2] [function_1]	count=1
module	travelling in the ||| physics optics	count=1
function_arg	zero [arg_2] ||| [function_1] [arg_2]	count=2
class	a specific value ||| series	count=1
function	[function] velocities ||| [function]	count=3
function	inverse of [function_2] ||| [function_2] [function_1]	count=2
function	order of a limit ||| order	count=1
function	of ode are ||| linear 2eq order1 type6	count=1
function	coefficient ||| coeff	count=12
module	unit ||| units	count=1
function_arg	[function_1] multiplication element-wise ||| [function_1] [arg_2]	count=3
function	minimal groebner basis ||| minimal	count=1
function	two simple roots ||| simple roots	count=2
function	figure out generators ||| no gens	count=1
class	factor where the root ||| root of	count=1
function	square-free factorization given a ||| sqf	count=1
function_arg	gcd [arg_2] ||| [function_1] [arg_2]	count=21
function	minimum of a ||| imin	count=1
arg	and g modulo ||| g	count=1
function	the label is ||| label	count=1
class	wigner ||| rotation	count=1
function	compute the gcd ||| gf gcd	count=1
arg	term is normally ||| independent recursive_limit _recursive_depth	count=1
arg	[arg_1] in k[x] ||| [arg_1] [arg_2]	count=22
function	a polynomial in gf ||| gf	count=1
class	gcd of the coefficients ||| dmp	count=1
function_arg	associated with key ||| get key	count=1
arg	of n [arg_2] ||| [arg_1] [arg_2]	count=5
function	returns the leading term ||| sdm lt	count=1
function	a variation of scan ||| scan	count=1
arg	a cached matrix by [arg_1] [arg_2] ||| matrix [arg_1] [arg_2]	count=1
class	quasi-particle? annihilate hole ||| fermion	count=1
module	those that take on ||| series	count=1
class	dtype ||| expression domain	count=4
function	from a ||| interpolate	count=1
function	[function_1] sequence ||| [function_2] [function_1]	count=1
function	[function_1] matrices ||| [function_1] [function_2]	count=2
function_arg	[function_1] [arg_2] ||| [function_1] group [arg_2]	count=2
module_class	the intersection of [module_1] [class_2] and another geometrical entity ||| [module_1] [class_2] intersection o	count=1
function	and ||| prefix	count=1
function_arg	[function_1] exponentiation ** ||| [arg_2] [function_1]	count=2
arg	plane varying t ||| t	count=1
class	block ||| block	count=1
function_arg	this function [arg_2] ||| [function_1] [arg_2]	count=1
class	specific value ||| series	count=1
arg	sets given by sets ||| sets	count=1
module	rule based ||| strategies	count=1
function	xor ^, as ||| xor	count=1
arg	alpha as a set ||| degree generators alpha pairs	count=1
module	symbolically at [module] specified ||| [module]	count=1
function	of x ||| x	count=1
arg	f from [arg_2] ||| [arg_2] [arg_1]	count=1
function	converts ||| letter form to	count=1
arg	message with private key ||| key	count=1
function	returns the number of ||| number	count=1
class	of a sequence ||| seq	count=1
module_class	multiplies the [class_2] ||| [module_1] [class_2]	count=2
function	ratio between 2 ||| ratio	count=1
arg	of expression over ||| expr var evaluate	count=2
arg	s over the ||| s	count=1
arg	[arg_1] [x] and ||| [arg_1] [arg_2]	count=1
function	symbols in ||| free symbols	count=1
function	ode from ||| ode	count=1
module	for ||| vector	count=2
function	3d [function] ||| plot3d [function]	count=4
module	hints given ||| integrals	count=1
function	of ||| refine complexes	count=2
function	and the name ||| get mod	count=1
function	finite difference ||| finite	count=1
function	[function_1] random generators ||| [function_2] [function_1]	count=1
function	set of points ||| points	count=2
function	[function_1] of indices ||| [function_2] [function_1]	count=1
function	if possible ||| try use	count=1
function	compute roots in linear ||| roots	count=1
arg	function for :func _factor ||| expr opt method	count=1
function	create random ||| rand	count=1
arg	of alpha ||| degree generators alpha pairs	count=1
class	a univariate polynomial ||| poly	count=1
function	restricted [function_2] ||| [function_2] [function_1]	count=1
function	a group of ||| group	count=1
class	python's int ||| python integer ring	count=3
function	an add ||| add	count=1
class	[class_1] block ||| [class_2] [class_1]	count=4
arg	apply rule if ||| cond rule	count=2
function	using [function_2] ||| [function_2] [function_1]	count=1
arg	negative ||| exprs order	count=1
arg	a model ||| model	count=1
function	orbits and [function_2] ||| [function_1] [function_2]	count=2
function	proper ||| get statement	count=1
module	[module] a ||| [module]	count=3
arg	operators a ||| operators	count=1
function_arg	list [arg_2] ||| [arg_2] [function_1]	count=4
module	class into a string ||| utilities	count=1
function	string representation of this ||| str	count=1
arg	x and y ||| x y pt	count=2
function_arg	[function_1] [arg_2] ||| [function_1] scalar [arg_2]	count=2
arg	[arg] would ||| expr [arg]	count=2
arg	prec ||| prec	count=4
function	with homogeneous coefficients ||| homogeneous coeff	count=2
function	type of ode are ||| linear 2eq order1	count=1
function	corresponding to ||| implicit mat	count=1
function	method returns the order ||| order	count=2
function	in \mathbb{z}_p[x_0 \ldots x_{k-1}] ||| multivariate	count=1
function_arg	root of [arg_2] ||| [arg_2] [function_1]	count=17
function	coset table self and ||| coset table	count=1
function	dmf object to ||| global polynomial	count=1
function	quaternions defined [function] ||| [function] new	count=1
arg	find optimization ||| exprs order	count=1
module	the sympy ||| physics vector	count=2
arg	two labeled ||| g ring	count=1
function	[function_1] every rational ||| [function_2] [function_1]	count=2
function	subset defined by ||| subset	count=1
function_arg	[function_1] class initiated ||| [function_1] [arg_2]	count=4
function	z i ] ||| eval commutator zgate	count=1
arg	form of cls ||| cls	count=1
function	returns a tuple ||| as	count=2
function	[function_1] [function_2] function takes as input ||| [function_1] [function_2]	count=8
class	rectangular form or the ||| complex region	count=1
class	turn an iterable ||| generalized polynomial	count=1
function	the basic ||| basic	count=1
function	linearizer ||| linearizer	count=1
function	helper function of ||| helper simplify	count=2
class	and ||| diagram grid	count=1
arg	depending on the environment ||| pretty_print order use_unicode use_latex	count=1
arg	left by k ||| k	count=1
arg	in [inf sup] interval ||| inf sup	count=2
function	path to a class ||| get	count=1
module	apply on a ||| diffgeom	count=1
function	[function_1] [function_2] ||| [function_2] space [function_1]	count=12
function	treats xor ^, as ||| convert xor	count=1
function	+ a [function_2] ||| [function_2] [function_1]	count=1
class	grid ||| grid	count=4
function	of symbolic values to ||| param dict	count=1
arg	list x by the ||| x	count=1
function	a class into ||| get mod	count=1
class	[class_1] [class_2] is called complete if ||| [class_1] [class_2] is complete	count=1
function	[function_1] a dict ||| [function_1] [function_2]	count=7
function	[function_1] the discrete ||| [function_2] [function_1]	count=1
arg	the backend function ||| f t s_ simplify	count=1
function	the code ||| code	count=1
class	of self domain ||| quotient ring	count=1
arg	p where [arg_2] ||| [arg_2] [arg_1]	count=3
function_arg	lcm [arg_2] ||| [arg_2] [function_1]	count=9
function_arg	a root [arg_2] ||| [function_1] [arg_2]	count=2
function	symbol ||| literal symbol	count=1
arg	[arg] ordered ||| expr [arg]	count=2
class	the ring and ||| ring	count=1
arg	mml a ||| mml	count=1
function	equation is singular at ||| is singular	count=1
function	each element ||| applyfunc	count=1
function_arg	evaluate a [arg_2] ||| [function_1] tail f [arg_2]	count=1
arg	s + 1 from ||| s	count=1
arg	in the [arg] s ||| [arg]	count=1
function_arg	[function_1] f ||| [function_1] in [arg_2]	count=2
function	all qubits ||| measure all	count=1
arg	key n e ||| key	count=1
function	content [function_2] ||| [function_2] [function_1]	count=1
module_class	[module_1] [class_2] this ||| [module_1] [class_2]	count=1
class	rotation ||| axis orienter	count=1
function	a power or ||| pow	count=1
module	convert the ||| physics units	count=1
function_arg	evaluate a [arg_2] ||| [function_1] [arg_2]	count=3
arg	of ||| x y t eq	count=1
function_arg	[function_1] [arg_2] ||| [function_1] poly f symbol [arg_2]	count=3
function	monomials from ||| monoms	count=2
class	module ||| quotient module	count=1
function	class into a ||| get mod	count=1
arg	[arg_1] subtracting pt ||| [arg_1] [arg_2]	count=2
arg	trigonometric ||| rv	count=1
function	) ||| rs cos sin	count=1
arg	center of mass ||| vec	count=1
module	expressions as ||| integrals	count=1
arg	expressions that contain nested ||| nested	count=1
function	number and is thus ||| is singleton	count=1
function	to ||| to surface	count=2
function	square-free norm of ||| dmp sqf norm	count=2
arg	convert a k[x] polynomial ||| f u k	count=1
function	print the symbol ||| symbol	count=1
function	factor multivariate polynomials ||| dmp gf factor	count=1
arg	alpha as a set ||| alpha	count=1
class	writes ||| octave code	count=1
function	it's matrix representation this ||| matrix	count=1
function_arg	[function_1] alpha ||| [function_1] [arg_2]	count=9
function	to latex handling functions ||| function	count=1
function	directional derivative ||| directional derivative	count=2
function	by other, where ||| gt	count=1
arg	== a ||| a n	count=1
arg	on a scalar field ||| scalar_field	count=1
class	polar ||| polar lift	count=2
function	parse and configure the ||| parse order	count=1
function	a distributed module element ||| sdm	count=1
function	convert the [function_2] ||| [function_2] [function_1]	count=2
arg	on [arg] ||| [arg]	count=1
arg	n a real number ||| n	count=1
module_class	[module_1] matrix ||| [module_1] ray transfer [class_2]	count=4
function	[function_1] a rational ||| [function_2] [function_1]	count=8
class	of the vector space ||| f	count=1
function	converts ||| form to	count=1
function	by^2 + cz^2 ||| to normal	count=1
module_class	return factors ||| core factors	count=2
class	dtype ||| finite field	count=5
module	attempt [module] ||| [module]	count=3
arg	algorithm ||| g	count=1
arg	partions of n ||| n	count=1
arg	adds muls pows and ||| order verbose	count=1
arg	x , \xi ||| match comp	count=1
function	this method converts a ||| form to	count=1
arg	basic ||| strong_gens_distr	count=1
module	look [module] pure ||| [module]	count=1
function	line inside a ||| line	count=1
function	partition summing to ||| partition	count=1
function	scalar multiplication ||| mul scalar	count=2
module	that are ||| integrals	count=1
function	the ideal ||| ideal	count=2
function	set the commutation parameter ||| set	count=1
function	the bifid cipher decryption ||| decipher	count=1
arg	square-free polynomial f in ||| f n	count=1
class	line ||| code printer	count=2
function	hermite [function_2] ||| [function_1] [function_2]	count=1
function_arg	to another ||| to other	count=1
function	the string path ||| get mod func	count=1
function	factor having root v ||| choose factor	count=1
function	the given number ||| indent	count=1
arg	sequence ||| seq	count=3
arg	for the real inverse_mellin_transform ||| f s x_ strip	count=1
module	add ||| utilities	count=1
arg	a function to all ||| func	count=1
module	qubits in the ||| physics	count=1
arg	[arg_1] of alpha ||| [arg_2] [arg_1]	count=2
function	[function_1] parameters ||| [function_2] [function_1]	count=2
class	a tensor [class] ||| [class]	count=1
arg	d = b m ||| a b a b	count=1
class	a [class] ||| [class]	count=4
arg	runs [arg] true ||| [arg]	count=1
function	normal part [function_2] ||| [function_1] [function_2]	count=1
function	decimal instance [function_2] ||| [function_1] [function_2]	count=3
function_arg	discriminant [arg_2] ||| [function_1] [arg_2]	count=1
class	[class_1] of stringpicts ||| [class_1] [class_2]	count=2
function_arg	quotient of f ||| quo f	count=2
module	that only ||| core	count=2
arg	k -> ||| k	count=1
function	class used to ||| class	count=1
arg	free [arg_2] ||| [arg_2] [arg_1]	count=3
function_arg	[function_1] p ||| [function_1] irreducible n [arg_2]	count=2
arg	vector of constants ||| matlist variable constant	count=3
function	topological [function_2] ||| [function_1] [function_2]	count=4
module	given number of space ||| utilities	count=1
arg	integers [arg] ||| [arg]	count=1
arg	strategy ||| strategy	count=1
class	of tuples index ||| index	count=1
function	constant coefficients using ||| constant	count=1
function	unify a ||| unify	count=1
function_arg	polynomial in [arg_2] ||| [arg_2] [function_1]	count=1
class	of this fermionicoperator restricted ||| fermionic operator	count=2
function	unifies ||| unify	count=1
arg	of f ||| f symbol	count=1
arg	f 3 tests will ||| f	count=1
function	sturm sequence ||| sturm	count=3
function	the scalar [function_2] ||| [function_1] [function_2]	count=11
function_arg	from [arg_2] ||| [function_1] expr [arg_2]	count=1
arg	expr ||| expr evaluate	count=1
function	of ||| in	count=1
function_arg	[function_1] f by ||| [function_1] [arg_2]	count=3
function	with hash randomization ||| with hash randomization	count=3
function_arg	[function_1] symbols ||| [arg_2] [function_1]	count=1
arg	f and for each ||| a d de z	count=1
arg	x_0 = a in ||| f a u k	count=1
arg	or 1 if k ||| k	count=1
function	[function_1] two terms ||| [function_2] [function_1]	count=2
arg	writer function out ||| test compileflags out clear_globs	count=1
function	a polynomial ring i ||| poly ring	count=2
function	- a ||| sub	count=1
function	class used ||| class	count=1
function_arg	ideal [arg_2] ||| [function_1] [arg_2]	count=2
function	morse ||| decode morse	count=2
module_class	apply a permutation to [module_1] [class_2] ||| [module_1] [class_2]	count=2
arg	two polynomials in ||| g	count=3
module	find optimization ||| simplify	count=1
function	a cyclotomic polnomial ||| dup cyclotomic	count=1
function	the puiseux ||| puiseux2	count=1
arg	of k0 ||| k0	count=1
function	from gray ||| gray	count=1
arg	and handler ||| handler	count=1
arg	[arg_1] k[x] ||| [arg_1] a [arg_2]	count=1
function_arg	[function_1] [arg_2] key1=true) share at least ||| [function_1] [arg_2] key1	count=4
function	opening statements ||| routine opening	count=2
module	root of ||| polys	count=1
function	'/' separated [function_1] [function_2] ||| [function_2] [function_1] lst	count=3
function	p, about 0 ||| rs	count=3
function	the third heuristic ||| heuristic bivariate	count=1
function	[function_1] a list ||| [function_1] sympy [function_2]	count=1
function	speed ||| speed	count=1
module_class	string [class_2] ||| [module_1] [class_2]	count=1
function	and ||| components and	count=1
arg	in rules ||| p rules x prec	count=1
function	manipulate parts ||| epath	count=1
function	by ||| mul	count=1
arg	\; j_2 [arg_2] ||| [arg_2] [arg_1]	count=1
function	next [function_2] ||| [function_1] [function_2]	count=2
function	direct ||| perm af direct	count=1
class	compute the determinant ||| determinant	count=1
class	that no bounding rectangles ||| complex root of	count=1
arg	group/set/element inside another group ||| group arg centr	count=1
module	if the ||| combinatorics	count=1
function	make all coefficients positive ||| dmp abs	count=1
function	factors of [function_2] ||| [function_2] [function_1]	count=2
function	beyond the current one ||| next	count=1
module	acceleration of this ||| vector	count=1
function	the adjacency distance between ||| get adjacency distance	count=1
function	true/false if ||| is	count=1
function	out generators ||| no gens	count=1
module	tensor ||| tensor	count=9
function	inverse laplace transform of ||| inverse laplace transform	count=1
function	perform the integration using ||| doit	count=1
function	nice order of classes ||| class key	count=1
function_arg	[function_1] of an ||| [function_1] add [arg_2]	count=1
function_arg	[function_1] [arg_2] ||| [function_1] in [arg_2]	count=11
arg	function ||| expression predicate interval	count=1
function	implements the lie ||| ode lie	count=1
module	for the ||| physics quantum	count=1
function	treats xor ^, ||| xor	count=1
function	the time ||| time	count=1
module	the equations of motion ||| physics	count=3
class	polynomial monomials ||| poly	count=1
module	if self ||| polys agca	count=10
function	inverse laplace [function_2] ||| [function_1] [function_2]	count=2
function	which the ||| not empty	count=1
function	to ||| indent	count=1
class	gate needs to ||| cnot gate	count=1
function	line inside ||| line	count=1
function	returns a sympy ||| sympy	count=1
function	[function_1] indices corresponding ||| [function_2] [function_1]	count=6
function	[function_1] small ||| [function_2] [function_1]	count=2
arg	n k -> returns ||| n k	count=1
arg	expr in ||| expr	count=3
arg	in x ||| x	count=12
arg	defined as ||| k	count=1
function_arg	cos [arg_2] ||| [arg_2] [function_1]	count=3
function	in f[x] ||| dup	count=1
function	generate necklaces ||| necklaces	count=1
function_arg	[function_1] [arg_2] permutation group ||| combinatorics [function_1] group [arg_2]	count=1
arg	k = a int_0^oo ||| k a	count=1
function_arg	[function_1] x ||| [function_1] [arg_2]	count=6
function_arg	the inverse [arg_2] ||| [arg_2] [function_1]	count=3
function	of domain ||| domain	count=2
function	a set of points ||| points	count=2
module_class	the lagrange ||| physics mechanics lagranges	count=1
arg	[arg_1] are in ||| [arg_2] [arg_1]	count=1
arg	using vincent-akritas-strzebonski ||| f k eps inf	count=1
function	cancel common factors in ||| cancel	count=1
function	returns the bodies ||| bodies	count=1
arg	m representing a ||| m	count=1
arg	is replaced by the ||| args kwargs n	count=1
module	domains ||| polys domains	count=10
module	any ||| simplify	count=1
arg	access the ||| ct	count=1
arg	functions or as a ||| a b	count=1
function_arg	[function_1] base and ||| [arg_2] [function_1]	count=4
arg	phrase ||| phrase	count=1
arg	[arg_1] + sign*s ||| [arg_1] [arg_2]	count=2
function	right-angled ||| right	count=1
function	crt ||| crt	count=1
function	of x**q ||| nthroot mod1	count=1
function	[function_1] table of ||| [function_2] [function_1]	count=3
function	the input ||| bezout	count=2
function	truncation according to the ||| rs	count=1
function	matrix to ||| to	count=1
function	[function_1] part ||| [function_1] [function_2]	count=8
arg	j_4 j_5 ||| j_4	count=2
module	-- return number of ||| core	count=1
arg	about c i e ||| c condition	count=1
function_arg	set [arg_2] ||| [arg_2] [function_1]	count=5
function	momentum of ||| momentum	count=1
arg	two algebraic numbers ||| g	count=1
function	a matrix if ||| matrix	count=1
function	compute buckets for ||| compute buckets	count=1
arg	cipher encryption ||| msg key symbols _inverse	count=1
function	wrapper around [function_2] ||| [function_2] [function_1]	count=6
function	young's modulus of ||| elastic modulus	count=1
class	[class_1] until it ||| [class_2] [class_1]	count=4
function	convergence ||| convergent	count=2
arg	z ||| z tol	count=1
module	sum that can be ||| simplify	count=1
class	root [class_2] ||| [class_1] [class_2]	count=2
function	primitive form of ||| primitive	count=3
class	of self domain ||| polynomial ring	count=1
module_class	list of [class_2] ||| [module_1] [class_2]	count=2
arg	of f in ||| f u k	count=1
function	that are ||| auto	count=1
function	set attributes ||| attrs	count=1
module	of an ||| polys	count=1
function	is a multivariate ||| is multivariate	count=3
function	generic ||| generic	count=1
arg	[arg_1] k ||| hypersimp [arg_1] [arg_2]	count=1
arg	gr adjacency list ||| gr	count=1
function_arg	square polynomials in ||| sqr f	count=1
function	the cot ||| cot	count=1
function	a sum of single ||| single	count=1
function	the ||| get mod func	count=4
function	bisection ||| bisection	count=1
class	polynomial ||| frac field	count=1
arg	nested square roots ||| nested	count=1
arg	index in a factor ||| index	count=2
arg	pt1 and pt2, ||| pt1	count=1
function	string path to ||| get mod	count=2
function	random element ||| random	count=1
arg	of d with ||| d	count=1
arg	[arg_1] to fringe ||| [arg_1] welding_edge [arg_2]	count=1
arg	in p ||| p	count=1
function	polynomial ||| old poly	count=1
function_arg	the coefficient [arg_2] ||| [function_1] [arg_2]	count=2
function	op ||| algebraic element	count=1
function	part [function_2] ||| [function_2] [function_1]	count=1
function	coefficient of ||| coeff add	count=3
function	to x_i**k_i in ||| dmp inflate	count=1
arg	encrypt message [arg] ||| [arg]	count=1
arg	d = b ||| a b	count=1
function_arg	[function_1] a point ||| [function_1] vec [arg_2]	count=3
function	return the leading degree ||| gf degree	count=1
function	beyond the current ||| next	count=1
arg	expression old -> ||| old	count=1
arg	using vincent-akritas-strzebonski ||| f k eps	count=1
arg	expression and the variable ||| expression variable	count=1
arg	dummy indices of expr ||| expr	count=1
arg	indices are covariant ||| indices free	count=1
function	functions in finite_set ||| empty	count=1
function_arg	order of [arg_2] ||| [function_1] at [arg_2]	count=1
arg	given number of space ||| s	count=1
function	zero-dimensional ||| zero dimensional	count=3
function	proper [function_2] ||| [function_1] [function_2]	count=6
class	method returns ||| base	count=1
function	be extracted [function] y ||| [function]	count=1
arg	, defined ||| t plane	count=1
function	[function] if a ||| is [function]	count=3
function	chebyshev ||| chebyshevt	count=2
function	pendulum on ||| pendulum on	count=1
arg	sdm form ||| extended	count=1
arg	addition expression ||| expr	count=1
module_class	[module_1] fractions ||| [module_1] [class_2]	count=6
function_arg	terms from [arg_2] ||| [arg_2] [function_1]	count=1
arg	f given ||| f m	count=1
function	see if unicode output ||| use unicode	count=1
module	is one else none ||| core	count=1
module	polynomial sequences ||| holonomic	count=1
function	outer indices of ||| get indices	count=1
function	polynomial trace [function_2] ||| [function_2] [function_1]	count=1
function	leading term as a ||| leading term	count=1
function	reset ||| reset	count=1
function	functions in ||| empty in	count=1
function	is the largest subset ||| pairwise most common	count=1
function	[function_1] [function_2] ||| [function_1] rr [function_2]	count=1
module	qexpr objects handles the ||| physics	count=1
function	in a python subprocess ||| in subprocess	count=1
module	from self ||| core	count=1
function	other, where ||| ge	count=1
class	partition is ||| partition	count=1
arg	the modulus of f ||| f modulus	count=1
function_arg	col [arg_2] ||| [arg_2] [function_1]	count=1
module	returns the ||| functions	count=1
arg	of square-free polynomial using ||| polys	count=1
function	part of ||| part	count=6
arg	and b if v ||| v	count=1
function_arg	[function_1] condition ||| [function_1] [arg_2]	count=1
function_arg	with [arg_2] ||| [function_1] expr [arg_2]	count=4
function	third heuristic assumes ||| heuristic	count=1
class	for the generated files ||| fcode gen	count=1
arg	target to yield origin ||| target origin	count=1
class	or ||| expr with int	count=1
function	load the [function_2] ||| [function_2] [function_1]	count=1
function	careful! any evalf ||| eval evalf	count=1
function	returns the coefficient of ||| coeff monomial	count=1
function	value of ||| eval	count=1
function	a list of sympy ||| from sympy list	count=1
arg	suitable for ||| iszerofunc simpfunc	count=1
function	which is preferred ||| preferred	count=1
function	distinct real roots of ||| count real roots	count=1
function	lower central ||| lower central	count=2
function	dispatch [function_2] ||| [function_2] [function_1]	count=1
module	cross product [module] ||| [module]	count=1
arg	a codestring with ||| codestring	count=1
module	ie ||| combinatorics	count=2
arg	isolating ||| s t eps	count=2
module	return the ||| elementary	count=1
function	[function_1] lagrange's ||| [function_1] [function_2]	count=1
module	for the initialization of ||| physics mechanics	count=1
function	a wrapper around ||| wrapper	count=1
function_arg	according to [arg_2] ||| [arg_2] [function_1]	count=3
function_arg	[function_1] p q ||| polys [function_1] [arg_2]	count=2
function	[function_1] logarithmic derivative ||| [function_2] [function_1]	count=1
function	hilbert [function_2] ||| [function_1] [function_2]	count=1
function	n ||| n t	count=1
function	[function_1] normal form ||| [function_2] [function_1]	count=4
function	negate a polynomial ||| neg	count=2
function	group method ||| group	count=1
function	the zero module element ||| sdm zero	count=1
arg	[x] and a in ||| a	count=4
function	available and leverage ||| try	count=1
arg	d1 ||| d1	count=1
function_arg	pseudo-quotient of f ||| pquo f	count=2
function	cos ||| minpoly cos	count=1
function	the symbol corresponding to ||| i2symbol	count=1
function	quadrants from a ||| quadrants	count=1
function_arg	strictly increasing [arg_2] ||| [arg_2] [function_1]	count=2
module	for ||| series	count=1
function	use the berkowitz algorithm ||| det berkowitz	count=1
arg	an addition expression ||| expr	count=1
function	lmq upper bound for ||| root upper bound	count=1
function	extra strong lucas ||| extra strong lucas	count=3
arg	creates a small'' matrix ||| deg_f	count=1
module	expected to be in ||| logic algorithms	count=3
arg	[arg] wrt ||| [arg]	count=2
arg	given by sets ||| sets	count=1
arg	of t and ||| t	count=1
function	edges ||| edges	count=1
function	z i ] ||| commutator zgate	count=1
function	the size of ||| degree	count=1
function	to simplify the ||| simplify	count=1
class	the polynomial p ||| poly	count=1
function_arg	diagram [arg_2] ||| [function_1] diagram [arg_2]	count=4
module	that should be ||| core	count=1
arg	a p ||| a p	count=2
function_arg	transform [arg_2] ||| [arg_2] [function_1]	count=14
function_arg	square-free factors [arg_2] ||| [function_1] [arg_2]	count=1
function	unify generators ||| unify gens	count=2
function	digit of pi ||| pi	count=1
module	said to ||| ntheory	count=1
function	isolation interval ||| interval	count=1
module	to symbols ||| core	count=1
function	used to couple ||| couple	count=1
function	solve ||| solve	count=5
class	where p[i] < p[i+1] ||| permutation	count=1
function_arg	series [arg_2] ||| [function_1] puiseux2 [arg_2]	count=5
function	wigner ||| wigner	count=4
arg	corresponding sols ||| sols func	count=1
function_arg	hankel transform [arg_2] ||| [arg_2] [function_1]	count=3
function	intended or ||| vv 2	count=1
module	domain of ||| calculus	count=1
function	the cholesky decomposition l ||| cholesky	count=1
arg	initialization of lagrangesmethod lagrangian ||| lagrangian	count=1
function	to another fraction field ||| from fraction field	count=1
arg	of a transformation ||| to_sys coords	count=1
arg	value to or ||| value	count=1
function	the domain ||| not empty	count=1
arg	variable with ||| name d1 d2	count=1
function	mapping of symbolic values ||| create param dict	count=1
function	calculate the derivative of ||| diff	count=1
arg	passed by ||| cls arg k	count=1
arg	base ||| base gens	count=1
function	finds the ||| empty in	count=1
class	segment ||| segment	count=1
function	has a ||| has	count=1
arg	return true if expr ||| expr assumptions	count=1
arg	x_j [arg_2] ||| [arg_1] [arg_2]	count=1
function	below [function_2] ||| [function_1] [function_2]	count=4
class	a grid laid ||| grid	count=1
function	the focal ||| focus	count=1
function	sentinel of a given ||| sentinel	count=1
function	standard ||| groebner	count=1
arg	a column ||| column k	count=1
arg	bounding rectangles of non-conjugate ||| cls	count=1
function	to their ||| operators to state	count=1
arg	the finite_set is not-empty ||| finset_intersection	count=1
arg	of numbers ||| numbers	count=1
function_arg	[function_1] c ||| [function_1] [arg_2]	count=1
class	elements of a matrix ||| matrix	count=1
function	finite difference [function_2] ||| [function_2] [function_1]	count=1
class	basis ||| module	count=1
class	returns a standard ||| sub module poly	count=1
function_arg	[function_1] [arg_2] squaring ||| [function_1] [arg_2]	count=1
arg	of ||| s	count=2
arg	two labeled polynomials ||| g ring	count=1
arg	y ||| y	count=4
arg	root if ||| root	count=1
arg	p - ||| p all_roots	count=1
arg	of a rule ||| rule	count=1
function	return the series ||| intcurve series	count=1
class	the column matrix f ||| symbolic	count=1
function	on ||| free	count=1
function	property where ||| memoize property	count=1
arg	in ||| f g	count=6
function	greatest factorial factorization ||| gff	count=1
arg	x_j of a polynomial ||| m j	count=1
arg	a second order ||| eq func order	count=1
function	is nonzero for ||| is	count=1
function	maximum norm of ||| max norm	count=4
function	returns true/false if a ||| is	count=1
class	for free ||| free	count=1
arg	of k0 and k1 ||| k0 k1	count=1
arg	given domain for which ||| symbol domain	count=1
function	product of multiple arguments ||| product	count=2
function	substituion on ||| subs	count=1
function	cse on expression ||| cse	count=1
class	a permutation ||| permutation	count=2
arg	find optimization opportunities in ||| order	count=1
function	[function_1] zero-dimensional ||| [function_2] [function_1]	count=5
class	generated files ||| code	count=1
function	s-polynomial ||| s poly	count=1
function	factor square-free ||| factor sqf	count=2
module	of the ||| physics optics	count=32
function	add efficiently otherwise ||| add	count=1
function	expression as ||| as	count=1
function_arg	of operators [arg_2] ||| [function_1] [arg_2]	count=5
arg	is replaced by the ||| args kwargs	count=1
arg	triangles to ||| triangles	count=1
module	the form obj force ||| physics mechanics	count=1
function	table of self ||| table	count=1
arg	appropriate for ||| name expr argument_sequence global_vars	count=1
function	the lie [function_2] ||| [function_2] [function_1]	count=4
arg	actual [arg_2] ||| [arg_2] [arg_1]	count=8
arg	of a polynomial ||| minpoly p	count=1
function	intrinsic ||| intrinsic	count=1
module	of the state ||| physics quantum	count=4
class	density ||| density	count=1
function	on the specified axes ||| tensorcontraction	count=1
arg	n ||| x n	count=1
function	as a finite rotation ||| orient	count=1
class	or product ||| expr with int	count=1
function	into irreducibles ||| list include	count=2
arg	beta x gives ||| b x	count=1
arg	in s2 ||| s2	count=1
function_arg	exact quotient [arg_2] ||| [arg_2] [function_1]	count=12
function	denominators but keep ||| denoms	count=1
class	faces of ||| polyhedron	count=1
arg	[arg_1] g ||| [arg_2] [arg_1]	count=26
function	heuristic polynomial gcd ||| dmp qq heu gcd	count=1
arg	the routines in c ||| routines f	count=1
arg	d = b ||| b	count=1
arg	return [arg_1] [arg_2] with int 1 so ||| [arg_1] [arg_2]	count=1
class	index pos 0 ||| index structure	count=1
arg	g ||| g dummies	count=1
function	and result ||| result variables	count=1
arg	of eq ||| eq	count=1
class	for the values of ||| method	count=1
function_arg	irreducible [arg_2] ||| [function_1] list include [arg_2]	count=2
arg	= a int_0^oo b*sin(x*k) ||| a	count=1
function	an ode from ||| ode	count=1
class	dmf ||| dmf	count=1
function	-> a/b -> a ||| numer denom	count=1
function_arg	[function_1] other is ||| [arg_2] [function_1]	count=1
function	of cos ||| minpoly cos	count=1
module	g_2" ||| liealgebras	count=1
function	computes principal minors ||| minors	count=1
arg	h as a ||| h	count=1
function	the measure ||| measure	count=1
function	of partitions ||| partitions	count=1
function	[function_1] coefficient ||| [function_1] [function_2]	count=4
function_arg	converts an [arg_2] ||| [function_1] matrix [arg_2] format	count=2
arg	k of ||| k d	count=1
function_arg	[function_1] [arg_2] ||| [function_1] resultant f g [arg_2]	count=3
function	the axis ||| axis	count=1
function	procedure ||| inner	count=1
function	a common ||| common	count=3
function	polynomial for ||| polynomial	count=1
function_arg	[function_1] a base ||| [arg_2] [function_1]	count=4
function	apply the [function_2] ||| [function_1] [function_2]	count=1
function	[function_1] [function_2] of a polynomial ||| [function_1] [function_2]	count=8
function	laplace transform ||| laplace transform	count=2
class	object excluding those that ||| base	count=1
arg	model ||| model deep	count=1
arg	this type of ||| x y	count=3
class	mapping of symbolic values ||| code	count=1
function_arg	[function_1] gcd a ||| [arg_2] [function_1]	count=5
class	rectangles ||| root of	count=2
class	root ||| root system	count=1
function	k x ||| frac	count=1
module_class	[module_1] n-dim array ||| [module_1] [class_2]	count=1
arg	and b ||| b	count=27
function	bodies ||| bodies	count=1
arg	\int_{c+i\infty}^{c-i\infty} f [arg_2] ||| [arg_1] [arg_2]	count=1
function	a class into ||| get	count=1
function	variables with ||| variables	count=1
arg	it appears only as ||| symbols unknown_clauses	count=1
function_arg	[function_1] p [x] ||| [arg_2] [function_1]	count=44
function	whether [function] ||| [function]	count=2
arg	for :func _symbolic_factor ||| opt method	count=1
arg	sep ||| sep	count=2
function	matrix ||| eval matrix	count=1
module	coefficient muls ||| simplify	count=1
function	a copy of the ||| structure copy	count=1
function	property where ||| property	count=1
arg	complexes such ||| cls complexes	count=1
module	the position [module_2] ||| [module_1] [module_2] point	count=1
arg	x_0 [arg_2] ||| [arg_2] [arg_1]	count=10
function	a root of a ||| root	count=1
function	monomial order ||| order	count=1
class	the linearentity ||| entity	count=1
class	[class_1] code of ||| [class_2] [class_1]	count=1
arg	[arg_1] number n ||| [arg_2] [arg_1]	count=2
arg	of implications ||| implications	count=1
arg	f 3 tests ||| f	count=1
arg	a base and ||| group base	count=1
function	d^2 = ||| four squares	count=1
function	diff ||| diff	count=1
function	the bottom nodes first ||| bottom up	count=1
arg	a diagram [arg_2] ||| [arg_2] [arg_1]	count=4
class	the series ||| fourier series	count=1
class	return an interval ||| interval	count=3
arg	to i i ||| i	count=1
function_arg	remainder [arg_2] ||| [arg_2] [function_1]	count=9
function	the n-th coefficient of ||| nth	count=3
function	element to another fraction ||| from fraction	count=1
function	path ||| mod func	count=2
arg	target to yield origin ||| target origin z	count=1
function	and transversals from ||| transversals from bsgs	count=1
function	partial ||| pde 1st	count=2
arg	f into ||| f	count=1
function	definition of this dyadicmul ||| measure number	count=1
function_arg	numerator of [arg_2] ||| [function_1] [arg_2]	count=1
arg	exponentiation ** ||| tokens local_dict global_dict	count=1
function	functions in finite_set ||| not empty	count=1
function	string path to a ||| mod func	count=1
class	row ||| mutable dense matrix	count=1
function	value nested l-levels ||| nest	count=1
arg	x y z of ||| x y z a	count=1
function	take a continuous subsequence ||| dmp slice	count=2
arg	of f ||| f x m n	count=1
function	rectangles of non-conjugate ||| refine	count=1
function	render a function ||| function	count=1
function	real ||| dup count real	count=1
arg	field in a ||| field coord_sys	count=1
function	basis ||| basis	count=3
arg	dummies ||| dummies	count=1
function	permutation matrices ||| permutation matrices	count=2
arg	details ||| f x re	count=1
module	to be replaced with [module_1] [module_2] examples ||| [module_1] [module_2]	count=1
arg	symbols ||| symbols	count=3
arg	rank k this ||| rank	count=1
class	the generated files ||| octave	count=1
arg	[x]/ [arg_2] ||| [arg_2] [arg_1]	count=1
function_arg	[function_1] x_j ||| [function_1] [arg_2]	count=2
arg	a triangle and ||| triangle	count=1
function	earth rotation ||| type3	count=1
function	roots up ||| dup inner isolate real roots	count=1
function	[function_1] modulus ||| [function_2] [function_1]	count=1
function	system for the constant ||| constant system	count=1
function_arg	in [arg_2] ||| [function_1] f [arg_2]	count=6
arg	are ||| x y	count=1
class	tuples index pos 0 ||| index structure	count=1
function	an error ||| error	count=1
function	two assumptions on ||| product	count=1
function	label ||| label	count=3
function_arg	a bernoulli [arg_2] ||| [arg_2] [function_1]	count=1
function	the next [function_2] ||| [function_2] [function_1]	count=2
function	[function_1] monotonic in ||| [function_1] [function_2] expression interval symbol	count=5
function_arg	[function_1] in options=s ||| [arg_2] [function_1]	count=1
class	pair ||| expr cond pair	count=2
function	muls ||| opt cse	count=2
arg	for two univariate polynomials ||| g	count=1
function_arg	concatenates two ||| row join other	count=1
function	the euclidean ||| euclidean algorithm	count=1
function_arg	gate with [arg_2] ||| [function_1] [arg_2]	count=4
function	the directional derivative ||| directional derivative	count=2
function_arg	a matrix [arg_2] ||| [function_1] name [arg_2]	count=1
function	can be written as ||| as f	count=1
function_arg	of degrees [arg_2] ||| [function_1] list [arg_2]	count=1
arg	expansion ||| prec	count=1
arg	the tuple m ||| m	count=1
module	common factors [module] a rational ||| [module]	count=1
function	distributed module ||| sdm	count=1
function	exact quotient by a ||| dmp exquo	count=1
arg	at a in the ||| a	count=1
function	the general [function] ternary ||| diop ternary [function]	count=1
arg	n ||| n	count=84
module_class	the other [class_2] ||| [module_1] vector [class_2]	count=1
arg	s t ||| s t k	count=2
module	plotting ||| plotting	count=1
module	to make a polynomial ||| domains	count=1
function_arg	order of [arg_2] ||| [arg_2] [function_1]	count=3
function	be in integer representation ||| int repr	count=1
arg	subgroup of gr ||| gr strict	count=1
function	delta [function_2] ||| [function_2] [function_1]	count=1
arg	a second order ||| func order match	count=1
arg	only apply rule if ||| cond rule	count=1
function	is decreasing in ||| is decreasing	count=2
function	quadrants from a list ||| quadrants	count=1
function	'/' separated [function_1] [function_2] ||| [function_2] [function_1]	count=3
arg	in k[x] ||| u	count=9
function_arg	[function_1] [arg_2] whose squares are rationals ||| [function_1] [arg_2]	count=1
function	the centroid ||| centroid	count=1
function	group method of ||| group	count=1
function	square ||| square	count=4
function_arg	the logarithm [arg_2] ||| [arg_2] [function_1]	count=2
function	functional decomposition of ||| decompose	count=2
function_arg	a square-free factor ||| sqf cls factor	count=1
function	line ||| get	count=1
arg	f defined ||| f k	count=1
class	domain that ||| domain	count=1
function	negate a polynomial ||| dmp neg	count=1
arg	return complexes such that ||| cls complexes	count=1
arg	efficiently extract ||| rational	count=7
function	leading monomial as ||| leading monom	count=1
arg	is ||| r n limits	count=1
class	returns a standard basis ||| poly ring	count=1
arg	k == ||| k	count=1
arg	infinitesimals of the given ||| infinitesimals	count=1
function	is ||| pretty try	count=1
function	and if symbols ||| check and join	count=1
arg	series expansion ||| prec	count=1
function	coefficient muls ||| opt cse	count=1
arg	k -> returns the ||| k	count=1
arg	p ||| p n	count=2
class	the patterns ||| matrix properties	count=1
class	this geometrical entity similar ||| geometry entity	count=1
function	the opening statements ||| routine opening	count=2
arg	x [arg] ||| x [arg]	count=1
class	the ground domain a ||| dmp	count=2
module	multiple tokens ||| parsing	count=1
function	utility function to correct ||| correct	count=1
function	the subset ||| subset	count=1
module	and leverage it if ||| pretty	count=1
module	[module_1] of this ||| [module_1] [module_2] point	count=1
function	replace constants by ||| simplify variable	count=2
function_arg	gray [arg_2] ||| [function_1] [arg_2]	count=1
arg	characteristic 0 and a ||| a	count=1
function	of the sinh ||| sinh	count=1
module	should be defined ||| core	count=1
class	univariate polynomial ||| poly	count=1
function	[function_1] transform of ||| [function_2] [function_1]	count=12
arg	f s over ||| f s x	count=2
function	zero matrix ||| matrix	count=3
arg	a<b "=" for a ||| a	count=1
function	leading degree ||| dmp degree	count=1
function	the commutator of self ||| commutator	count=1
class	polygon and ||| polygon	count=2
arg	in [arg_2] ||| [arg_1] c [arg_2]	count=2
function	transformation matrix ||| transformation to	count=1
function	[function_1] on a ||| [function_1] [function_2]	count=4
function	above fermi? >>> ||| above fermi	count=1
class	a tuple ||| basic	count=1
function	young's ||| elastic	count=1
function	basis specified ||| basis	count=1
function	solve the ||| solve	count=1
arg	and dum indices on ||| dum	count=1
arg	of points in ||| func points	count=1
function	[function_1] distance ||| [function_1] [function_2]	count=2
arg	literal ||| lit cls	count=1
function_arg	in gf [arg_2] ||| [function_1] rem f [arg_2]	count=2
arg	a given ||| a	count=1
module_class	in the dyadic ||| physics vector dyadic	count=1
module	on the ||| physics quantum	count=1
arg	if g ||| g	count=2
function	generate a free module ||| free module	count=1
arg	function ||| expression predicate	count=1
function	[function_1] constants by ||| [function_1] [function_2]	count=4
function	square ||| rs square	count=1
arg	p - 1 references ||| p all_roots	count=1
function	is a common start ||| common prefix	count=1
arg	subset are [arg] ||| subset [arg]	count=1
module	the string ||| utilities	count=1
function	to qubit ||| qubit	count=1
function	a factor [function_2] ||| [function_2] [function_1]	count=6
arg	also a ||| root1 root2	count=1
function	sqrt otherwise false ||| sqrt	count=1
function	dummy having the ||| dummy	count=1
class	integer ||| factors	count=1
arg	a field in a ||| field coord_sys	count=1
class	functions ||| basic	count=1
arg	creates a small'' ||| deg_f deg_g row1 row2	count=1
function	berkowitz algorithm to ||| eval det berkowitz	count=1
function	x direction ||| x	count=1
module	the total ||| physics	count=1
arg	in expr to estimate ||| expr x	count=1
function	matrix if components ||| matrix	count=1
function	evaluate a ||| eval in	count=1
function	[function] of ||| dup [function]	count=5
function_arg	[function_1] of p ||| [arg_2] [function_1]	count=10
function	function [function_2] ||| [function_2] rational [function_1]	count=4
function	sympy [function_2] ||| [function_1] [function_2]	count=1
function	equations [1]_ ||| equations	count=1
function	a polynomial [function_2] ||| [function_2] [function_1]	count=11
module	implies ||| domains	count=17
arg	returns l and u ||| reverse	count=1
module	the total number ||| physics	count=1
function	number of real roots ||| real roots	count=1
function	reconstruct ||| reconstruction func	count=1
arg	modify parts ||| kwargs	count=1
function	domain a ring ||| ring	count=1
class	bounding rectangles of non-conjugate ||| of	count=1
arg	\ldots ||| p	count=1
function	of expressions generated ||| vprint	count=1
arg	a and b one ||| a b	count=1
function	tensor ||| tensor	count=3
function	[function_1] explicit ||| [function_1] [function_2] matadd	count=1
arg	f from k[x ||| f	count=1
arg	p ||| p all_roots	count=1
arg	value of n and ||| n	count=1
module	is available and leverage ||| printing pretty	count=1
function	in finite_set in ||| not empty	count=1
module	implies ||| polys domains	count=17
module	pairs [module] ||| [module]	count=2
module_class	partition of [module_1] [class_2] ||| [module_1] [class_2]	count=4
function	a common absolute value ||| common	count=1
function	python subprocess with hash ||| subprocess with hash	count=1
arg	in phrase ||| phrase	count=1
arg	value in k[x] ||| u k	count=1
function	function to solve ||| solve	count=1
arg	that stands next ||| element	count=1
function	represent a [function_2] ||| [function_2] [function_1]	count=1
function	adds a ||| add morphism	count=1
function	this dyadicmul ||| measure number	count=1
arg	d is ||| d	count=1
arg	other lies in ||| other	count=1
function	\mathbb{z}_p[x_0 \ldots x_{k-1}] from ||| interpolate multivariate	count=1
function_arg	multiplication [arg_2] ||| [arg_2] [function_1]	count=4
function	it ||| use	count=1
function	cross product between this ||| cross	count=1
function	into free, dum for ||| dum	count=1
module	measure of [module] examples ||| [module]	count=1
function	matrix for a given ||| matrix	count=1
arg	[arg_1] z_p for ||| [arg_2] [arg_1]	count=2
function	polynomial of cos ||| cos	count=1
module	the list is empty ||| combinatorics	count=1
function	list representation ||| list	count=1
function	lexicographic ||| lex	count=1
class	of ||| of	count=1
function	[function] of ||| [function]	count=133
function	function ||| function	count=12
arg	:func rsolve_hypergeometric for details ||| f x re g	count=1
class	for the ||| octave	count=1
class	with ||| ray	count=1
function	find ||| find	count=3
function	gf ||| gf	count=29
function	best ||| coeff best	count=2
function	to find 'executable' in ||| find	count=1
arg	a morphism is ||| morphism	count=1
function	solves the general ||| general	count=1
function	right coset ||| coset	count=1
function	for collins's resultant algorithm ||| collins	count=1
arg	computes the m ||| m	count=1
function_arg	expressions generated [arg_2] ||| [arg_2] [function_1]	count=2
function	quadratic ternary diophantine ||| ternary quadratic	count=1
module_class	computes the schreier ||| combinatorics permutation group	count=1
function	[function_1] puiseux ||| [function_2] [function_1]	count=1
module_class	implies __floordiv__ ||| polys domains ring	count=2
class	the module ||| sub module	count=1
function	bounding rectangles of ||| refine complexes	count=1
arg	expression and the ||| expression	count=1
class	used in the ||| table	count=1
function	possible ||| use	count=1
arg	function g ||| g	count=1
function	trigamma function ||| trigamma	count=1
class	excluding those that ||| base	count=1
arg	of f defined ||| f k	count=1
arg	[arg_1] of two ||| [arg_1] [arg_2]	count=1
arg	order n in ||| n	count=1
function	strictly increasing in ||| strictly increasing	count=2
module	> ||| combinatorics	count=1
class	itself ||| sq	count=1
class	the grid ||| growable grid	count=3
module	[module] z^2 \geq ||| [module]	count=3
function	using cholesky ||| eval	count=1
function	relational ||| relational	count=1
function	acceleration ||| acc in	count=1
arg	equation eq by converting ||| eq param syms	count=1
arg	length n raise an ||| n	count=1
function	pre-determination of the non-zero ||| row	count=1
arg	x + a ||| x	count=1
function	decimal [function_2] ||| [function_1] [function_2]	count=3
function	on success ||| once	count=1
arg	[arg_1] to b ||| [arg_2] [arg_1]	count=2
class	that no bounding ||| complex root	count=1
class	of the [class] the ||| [class]	count=1
function	[function_1] semicircle ||| [function_2] [function_1]	count=2
function	direction ratio between 2 ||| direction ratio	count=1
arg	of f and for ||| a d de	count=1
class	point in a ||| point	count=4
class	coset [class_2] ||| [class_1] [class_2]	count=1
function	the coefficient ||| coeff add	count=3
arg	anti-derivative to ||| meijerg risch	count=1
arg	compute partial ||| f x	count=1
module	mathml ||| utilities mathml	count=1
function	the opening statements of ||| get routine opening	count=2
function	a continuous subsequence of ||| slice	count=5
arg	every non-blank line ||| s indent	count=1
arg	[arg] true if ||| [arg]	count=2
function	number and is ||| is	count=1
function	moment ||| moment	count=2
function	the functions ||| not empty in	count=1
arg	certain coordinate system wrt ||| point1 point2	count=1
function	column ||| column	count=1
function	recursive helper ||| rec	count=1
function	as a [function_2] ||| [function_1] coeff [function_2]	count=1
function_arg	[function_1] modulus ||| [arg_2] [function_1]	count=1
arg	p with [arg_2] ||| [arg_1] [arg_2]	count=4
function	over ||| dmp rr	count=1
function	add a ||| simple add	count=1
arg	bound n ||| b cq n de	count=1
arg	equation eq (ax^2 + ||| eq	count=1
arg	[arg_1] a basis ||| [arg_2] [arg_1]	count=1
class	element of self domain ||| quotient ring	count=1
arg	the index index ||| index	count=1
function	coxeter diagram corresponding to ||| coxeter diagram	count=1
function	string path ||| get mod	count=2
function	dispatch a [function_2] ||| [function_2] [function_1]	count=1
module	in [module_2] ||| [module_2] [module_1]	count=1
function	equations in ||| implicit mat	count=1
function	bending [function_2] ||| [function_2] [function_1]	count=2
function	symbolic values to ||| create	count=1
function	roots ||| inner isolate real roots	count=2
module	return [module_2] ||| [module_1] [module_2]	count=1
function_arg	other, where other ||| ge other	count=2
arg	stop ||| func	count=1
function	(the lazy series ||| series	count=1
function	name of the ||| get	count=1
function	polynomial [function] ||| [function] sqf	count=1
arg	x_j ||| j	count=7
function	[function_1] morphism ||| [function_2] [function_1]	count=4
function	quadratic ternary diophantine equation ||| diop ternary quadratic	count=1
arg	in it into an ||| expr	count=1
class	the diagram ||| diagram grid	count=1
function	the components ||| components	count=3
function	all qubits ||| all	count=1
class	sequence of ||| poly	count=1
arg	j_2 [arg_2] ||| [arg_2] [arg_1]	count=11
function	is thus ||| is singleton	count=2
function	create function ||| create function	count=1
arg	for the partial differential ||| eq hint func order	count=1
module	module and the ||| utilities	count=1
class	matrix ||| block matrix	count=1
function	finite rotation about lambda ||| orient	count=1
function_arg	calculate core [arg_2] ||| [arg_2] [function_1]	count=3
arg	of an ||| expr	count=1
function	tests [function_1] [function_2] ||| [function_1] [function_2]	count=4
module	of symbolic values ||| printing	count=1
function	sorted ||| sorted	count=1
function	form x ||| process	count=1
function	is strictly [function_2] ||| [function_2] [function_1]	count=6
class	returns ||| sparse matrix	count=2
function	order of the ||| order	count=2
function	well defined ||| consistent	count=1
function	the focus ||| focus	count=1
arg	and a vector constants ||| variable constant k	count=1
function_arg	series for [arg_2] ||| [arg_2] [function_1]	count=5
function	[function_1] element ||| [function_1] [function_2]	count=1
arg	i i ||| i	count=1
function	returns the size of ||| degree	count=1
arg	compute the ||| f x	count=3
function	and cofactors of ||| inner	count=2
arg	to fringe and ||| fringe grid	count=2
function	and the primitive form ||| primitive	count=2
function	potential function ||| potential	count=2
class	create ||| llvmjit code	count=1
function_arg	preprocess [arg_2] ||| [arg_2] [function_1]	count=4
function	is ||| is only	count=2
class	ring and ||| ring	count=1
module	a [module] of ||| [module]	count=6
arg	point other lies in ||| other	count=1
arg	[arg_1] curve ||| [arg_1] [arg_2]	count=1
function	set attributes ||| auto attrs	count=1
function	make ||| to	count=4
arg	q ||| q x method	count=3
module	augments qdots to the ||| physics mechanics	count=1
arg	[arg] the ||| [arg]	count=1
arg	d [arg_2] ||| [arg_2] [arg_1]	count=2
function	compute upper degree bounds ||| degree bound	count=1
arg	using the writer ||| clear_globs	count=1
function	domain of ||| domain	count=1
arg	or slashed ||| slashed	count=1
class	exponential ||| exp	count=1
module	a list the ||| combinatorics	count=1
arg	op ex1 ex2 parameters ||| op ex1 ex2 x	count=1
arg	given level ||| level	count=1
function	subset ||| get subset from	count=1
function	hensel lifting in z[x] ||| dup zz hensel	count=2
module_class	the wavefunction ||| physics quantum wavefunction	count=1
function	reverse the [function_2] ||| [function_2] [function_1]	count=4
function	circumcircle ||| circumradius	count=1
arg	g for ||| g	count=1
module	return ||| functions	count=1
function	and the primitive form ||| dmp ground primitive	count=1
class	an element of ||| generalized polynomial	count=1
function	values above [function_2] ||| [function_2] [function_1]	count=4
function_arg	a sympy [arg_2] ||| [function_1] [arg_2]	count=1
arg	composite polynomial ||| poly	count=3
function	values above fermi? ||| only above fermi	count=2
function	operator classes to their ||| to state	count=1
function	transform ||| tuple transform	count=1
arg	h ||| h args	count=2
arg	the input t ||| t	count=1
module	to ||| polys domains	count=1
class	accumulationbounds object ||| accumulation bounds	count=3
function	find the lowest ||| find reasonable	count=1
arg	in c ||| f prefix	count=1
function	have initial [function_2] ||| [function_2] [function_1]	count=1
arg	range n shifted to ||| n	count=1
function_arg	[function_1] f x ||| [function_1] [arg_2]	count=1
function	subprocess ||| in subprocess	count=1
function	lmq upper bound ||| dup root upper bound	count=1
class	of occupation numbers ||| fock state	count=1
class	generate a ||| free module quotient	count=1
arg	z of the equation ||| z a	count=1
function	[function_1] representation ||| [function_1] [function_2]	count=7
function	puiseux ||| puiseux2	count=1
arg	and g [arg_2] ||| [arg_2] [arg_1]	count=2
module	on ||| diffgeom	count=1
function	coherent states ||| coherent	count=1
function	to a simplified ||| simplified	count=1
function	rectangles of ||| complexes	count=1
class	returns a ||| sub module	count=1
arg	switch ||| native zero	count=1
function	finds the power series ||| series	count=1
class	of non-conjugate ||| complex root	count=1
class	that ||| series base	count=2
function	bifid ||| bifid5	count=1
arg	and negative ||| order	count=1
arg	second default kind ||| d kind	count=1
module	standard basis ||| polys	count=1
function	m ||| euler maclaurin	count=1
function	values below ||| below	count=2
module	of two ||| polys	count=1
module	the object excluding ||| series	count=1
module	to simplify expression ||| simplify	count=1
module	in ||| polys	count=17
arg	indices are covariant or ||| indices free dum	count=1
arg	group on [arg] elements as ||| [arg]	count=1
arg	adds the index1 row ||| matlist index1	count=1
function	terms of ||| terms	count=1
function	a boolean [function] ||| [function]	count=1
class	files ||| octave code gen	count=2
function_arg	encryption [arg_2] ||| [arg_2] [function_1]	count=2
function	comment ||| comment	count=1
function	[function_1] a dictionary ||| [function_2] [function_1]	count=5
function_arg	normalize [arg_2] ||| [arg_2] [function_1]	count=1
function	on a sliding cart ||| on cart	count=1
function	taylor ||| taylor	count=1
class	cycle ||| cycle	count=1
arg	, defined as ||| t plane	count=1
arg	[arg_1] start ||| [arg_2] [arg_1]	count=6
class	x c matrix ||| sparse matrix	count=1
function	the ket on ||| ket	count=1
module	_normal_order_factor to perform the ||| physics quantum	count=1
module	and leverage ||| printing	count=1
arg	[arg_1] beta ||| [arg_2] [arg_1]	count=1
module_class	of [module_1] [class_2] ||| [module_1] dimension [class_2]	count=1
class	hole or ||| fermion	count=3
function	the form ||| limits	count=1
arg	a, d = b ||| a b	count=1
arg	degree d ||| d	count=2
function	the ||| process	count=1
arg	equation eq by ||| eq param	count=1
function	the form x ||| limits	count=1
class	a polynomial expression ||| poly	count=1
arg	class with hilbert_space ||| hilbert_space	count=1
function	ode are ||| linear 2eq order1 type6	count=1
arg	m by coefficient d ||| m d	count=2
function	plots a 3d [function_1] [function_2] ||| plotting plot3d [function_1] [function_2]	count=4
function_arg	add [arg_2] ||| [function_1] [arg_2]	count=1
function	pairs of coefficients ||| pairs	count=1
module	to a ||| utilities	count=1
function_arg	[function_1] g is ||| [arg_2] [function_1]	count=5
module	function is the inverse ||| physics quantum	count=1
function	gf p [x]/ f ||| gf	count=1
function	compute lcm ||| lcm	count=3
function	[function_1] in k[x] ||| [function_2] [function_1]	count=20
module_class	[module_1] with submodule ||| [class_2] [module_1]	count=1
class	of the fortran ||| fcode	count=2
function_arg	evaluate [arg_2] ||| [function_1] [arg_2]	count=3
function_arg	and evaluate [arg_2] ||| [arg_2] [function_1]	count=4
function	[function_1] dict ||| [function_1] sympy [function_2]	count=1
function_arg	basis for [arg_2] ||| [arg_2] [function_1]	count=1
function	rational generating function for ||| generating function	count=1
arg	where t = i ||| t	count=1
arg	eq ||| eq y x n	count=1
class	computes the polynomial ||| poly	count=1
function_arg	remainder of [arg_2] ||| [arg_2] [function_1]	count=13
arg	if ||| symbol	count=1
function	to whether ||| signature from	count=1
function	[function_1] circle ||| [function_1] [function_2]	count=2
function	with ||| zbasis	count=1
function_arg	+ g*h [arg_2] ||| [function_1] [arg_2]	count=7
function	[function_1] having root ||| [function_2] [function_1]	count=6
class	permutation ie the ||| permutation	count=2
function	to correct ||| correct signature	count=1
function	the total [function_2] ||| [function_2] [function_1]	count=2
arg	gcd a p ||| a p	count=2
function	linear homogeneous ||| linear	count=1
function	basis is [function_2] ||| [function_1] [function_2]	count=1
module	*-2 [module] 1 ||| [module]	count=1
function	rewrites ||| rewrite as	count=1
arg	f [arg_2] ||| [arg_1] [arg_2]	count=101
module	the canonical base ||| physics	count=1
arg	and ||| a d de z	count=1
arg	multiplication element-wise ||| row scaler k	count=1
function	is in [function_2] ||| [function_2] [function_1]	count=1
class	automatically ||| differential extension	count=2
arg	its attributes ||| props add_identities	count=1
arg	alpha beta x gives ||| x	count=1
function	surface plot ||| surface	count=1
function_arg	g*h where [arg_2] ||| [function_1] [arg_2]	count=14
class	roots ||| complex root of	count=3
function	for the vsids heuristic ||| vsids	count=2
class	the function ||| function	count=5
arg	the ith prime ||| i	count=1
arg	convenience if reduction ||| cls ai bj	count=1
function	[function_1] triangular ||| [function_1] [function_2]	count=1
arg	[arg_1] [arg_2] ||| [arg_2] a [arg_1]	count=18
module	abs() ||| functions elementary	count=1
function	a logarithmic ||| log	count=1
arg	s + 1 ||| s p	count=1
function	as input ||| as	count=1
function_arg	scaler-row [arg_2] ||| [arg_2] [function_1]	count=2
function	ode ||| classify ode	count=1
class	of the lagrange ||| lagranges	count=1
function_arg	the multiplication [arg_2] ||| [function_1] [arg_2]	count=2
function	the inverse ||| inv	count=1
class	to ||| real field	count=1
class	g_2" ||| type g	count=1
function	components of the ||| components	count=1
function	heuristic uses ||| heuristic function sum	count=1
class	of ||| llvmjit	count=1
module	a standard basis in ||| polys agca	count=1
function	an [function_2] ||| [function_2] [function_1]	count=2
class	partition of itself ||| partition	count=1
function	of the square-free ||| sqf	count=1
arg	function for :func _symbolic_factor ||| expr opt method	count=1
arg	of a transformation ||| to_sys	count=1
function	name of ||| mod	count=1
arg	dimensions r [arg] is ||| r [arg]	count=1
module	twave ||| physics optics	count=1
function_arg	a dummy [arg_2] ||| [arg_2] [function_1]	count=6
function	equation ||| equation	count=1
class	state ||| state	count=3
module	new tensor ||| tensor	count=1
function	sympy ||| sympy	count=24
function	n-link pendulum ||| link pendulum	count=1
arg	the writer [arg_2] ||| [arg_2] [arg_1]	count=2
module	in the specified ||| physics	count=1
function	[function_1] l1 norm ||| [function_2] [function_1]	count=1
module_class	[module_1] pair ||| [module_1] [class_2]	count=4
class	or product ||| expr	count=1
function	trace of [function_2] ||| [function_2] [function_1]	count=6
module	is available ||| printing pretty	count=1
function	both integers then ||| check param	count=1
module	a ||| polys agca	count=6
arg	_factor ||| expr opt method	count=1
function	distributed ||| sdm	count=1
arg	series modulo o(x**prec) examples ||| p x prec	count=1
arg	n k of the ||| n k	count=1
function	homogeneous ||| homogenize	count=1
function	class ||| mod	count=2
arg	the terms using qm ||| terms	count=1
module	of ||| combinatorics	count=3
function	standard basis ||| groebner	count=1
function	[function_1] ratio ||| [function_2] [function_1]	count=5
function	redirect an apply ||| apply operator	count=1
function	the outer indices ||| get indices	count=1
arg	can be used ||| k zeros	count=1
function	polynomial remainder sequence prs ||| prs	count=3
function	gcd and ||| gcd	count=2
arg	f [arg_2] ||| [arg_1] z [arg_2]	count=1
arg	polynomial [arg] ||| [arg]	count=1
arg	of an expression ||| expr	count=5
function	another fraction [function_2] ||| [function_1] [function_2]	count=1
function	by a sympifyable expression ||| mul	count=1
module	of coefficients of ||| polys	count=1
module	the truth ||| elementary	count=1
function	return ||| complexes	count=1
arg	as a single g ||| a b	count=1
function	equations ||| equations	count=3
arg	the truth ||| cls	count=1
function	m corresponding to ||| implicit mat	count=1
class	returns a standard basis ||| module poly ring	count=1
function	name of ||| get mod func	count=1
function_arg	ideal i ||| ideal i	count=1
class	of polar numbers ||| polar lift	count=1
function	refine ||| dup inner refine real	count=1
arg	displaying [arg] representation's with ||| [arg]	count=1
arg	name and ||| name	count=1
arg	q divides p - ||| q p	count=1
class	symbolic ||| llvmjit	count=1
module	to simplify expression by ||| simplify	count=1
function_arg	negate a [arg_2] ||| [arg_2] [function_1]	count=2
arg	isolating interval of ||| t eps	count=2
function	subs ||| iter subs	count=1
function	and ||| pretty try use	count=1
function	[function_1] element ||| [function_2] [function_1]	count=1
function_arg	tensors with [arg_2] ||| physics hep extract type [function_1] [arg_2]	count=1
function	is a permutation of ||| is	count=1
function	symbolic ||| create param	count=1
function	strictly decreasing ||| strictly decreasing	count=2
arg	the series expansion ||| p x prec	count=4
arg	= b ||| a b a b	count=1
arg	base scalars of ||| coord_sys	count=2
function_arg	opening statements [arg_2] ||| [arg_2] [function_1]	count=1
module	symbols of [module] given ||| [module]	count=2
function	return the index ||| index	count=1
arg	primes and e is ||| e	count=1
arg	no = -1 ||| no	count=1
arg	[arg_1] number n ||| [arg_1] [arg_2]	count=2
arg	of p modulo o(x**prec) ||| p x prec	count=1
function	translate [function_2] ||| [function_2] [function_1]	count=1
class	whether a set ||| product set	count=1
function	into ||| get	count=1
function	functions in finite_set in ||| empty	count=1
arg	string and handler ||| handler	count=1
module	the proper line ||| printing	count=1
function	on a ||| free	count=1
function	calculates the delta coefficient ||| big delta coeff	count=1
function_arg	[function_1] [arg_2] ||| [function_1] comm [arg_2]	count=3
function	multivariate polynomials over finite ||| dmp gf	count=1
function	return basic ||| basic	count=1
arg	generates ||| n	count=1
class	of ||| g	count=2
function	[function] for ||| graph [function]	count=2
module	data in the ||| physics	count=2
function_arg	bifid [arg_2] ||| [function_1] [arg_2]	count=1
arg	expression to canonical sympy ||| expr	count=1
function	roots up to ||| real roots	count=1
arg	cls given ||| cls rep lev dom	count=2
function	with a term ||| term	count=1
function_arg	[function_1] [arg_2] of ||| [function_1] [arg_2]	count=7
function	general [function] ternary form ||| diop ternary [function]	count=1
function	the outer indices of ||| get indices	count=1
module_class	shorter axis of [module_1] [class_2] if it can be ||| [module_1] [class_2]	count=1
function	return transpose of ||| transpose	count=1
function	tuple ||| tuple	count=2
arg	of t and the ||| t	count=1
function_arg	multiply [arg_2] ||| [arg_2] [function_1]	count=11
function_arg	deltaintegrate [arg_2] ||| [function_1] [arg_2]	count=5
function	transposed sparsematrix ||| eval transpose	count=1
function	data as a matrix ||| matrix	count=1
function	root to the given ||| root	count=2
function	set of triangles ||| list triangles	count=1
class	for the c series ||| type c	count=1
function	ground domain ||| ground	count=4
function	is a gate identity ||| identity search	count=1
function	whether ||| is	count=1
arg	f g [arg_2] ||| [arg_1] [arg_2]	count=6
function	a random ||| random	count=5
arg	terms of f ||| f m	count=4
arg	of terms of f ||| f x	count=1
class	to ||| global polynomial ring	count=1
function	the functions in ||| not	count=1
module	tensor indices ||| tensor	count=2
function	of symbolic values to ||| param	count=1
module	ending the [module] if present ||| [module]	count=1
function	a proper subset ||| proper subset	count=2
function	reduce a system ||| reduce	count=2
function	apply state ||| apply operator	count=2
function	berkowitz algorithm to compute ||| eval det berkowitz	count=1
arg	names and ||| func_name argtree	count=1
function	nine-point ||| nine point	count=1
function	components ||| components	count=6
function	roots of ||| count roots	count=2
module	of block matrices ||| matrices expressions	count=1
function	path to a class ||| func	count=1
class	complex root ||| complex root of	count=2
arg	b the ||| b	count=1
arg	the expected value ||| condition numsamples evaluate	count=1
module	of f ||| polys	count=1
function	the log hint ||| log	count=1
function	given metric ||| metric	count=2
function	a rational generating ||| generating	count=1
function_arg	table of [arg_2] ||| [arg_2] [function_1]	count=2
function	[function_1] multiple of ||| [function_2] [function_1]	count=5
function	lagrangian ||| lagrangian	count=1
class	the object excluding those ||| series base	count=1
arg	[arg_1] g using ||| [arg_2] [arg_1]	count=1
arg	a readable object ||| pkgname	count=1
function	a factory [function_2] ||| [function_2] [function_1]	count=2
function	always create a quasi-particle? ||| only q creator	count=1
function	of roots of ||| count roots	count=2
arg	factors [arg_2] ||| [arg_1] [arg_2]	count=1
arg	[arg] which for ||| [arg]	count=3
arg	an expression ||| expr syms	count=1
function_arg	irreducible factors [arg_2] ||| [arg_2] [function_1]	count=3
module	to make a ||| domains	count=1
function	to tell whether ||| is expr	count=1
function	set ||| set domain	count=1
function_arg	[function_1] of key ||| [arg_2] [function_1]	count=3
function	finite_set in which the ||| in	count=1
function	is available and ||| pretty try	count=1
arg	encryption ||| symbols _inverse	count=1
arg	i == j ||| i j	count=2
arg	operations on ||| dom	count=1
arg	polynomials in ||| f g	count=12
function	according to whether ||| from	count=1
arg	in ||| exprs order	count=1
arg	muls ||| exprs	count=1
function	lambdify ||| lambdify	count=1
arg	[arg_1] [arg_2] ||| [arg_2] morphism [arg_1]	count=3
arg	[arg] root2 ||| [arg]	count=1
function	[function_1] into irreducibles ||| [function_2] [function_1]	count=1
module	generates the ||| physics	count=1
arg	inverse of the key ||| key	count=1
function	sturm sequence of ||| sturm	count=2
module	[module] unique root ||| [module]	count=3
arg	a polynomial p ||| p u k	count=1
function_arg	true if [arg_2] ||| [arg_2] [function_1]	count=5
function	a class ||| func	count=1
arg	gens ||| arg gens	count=1
function	removes particle/fills ||| remove	count=1
function	the gauss-chebyshev ||| chebyshev t	count=1
function	higher in rank ||| add	count=1
arg	two ||| other	count=14
arg	of g is ||| g	count=1
function	gcd of coefficients of ||| content	count=2
function	set attributes that ||| auto attrs	count=1
class	the ||| matrix base	count=1
function_arg	key is in dictionary, [function_1] [arg_2] ||| [function_1] [arg_2]	count=3
arg	[arg_1] value ||| [arg_1] [arg_2]	count=4
function	it ||| pretty try	count=1
function	condition is ||| condition	count=1
function	isolation positive [function] given precision ||| [function]	count=1
module	leading coefficient of ||| polys	count=1
function_arg	polynomial in [arg_2] ||| [function_1] [arg_2]	count=1
arg	return true if expr ||| expr	count=1
function	puiseux ||| puiseux	count=1
function	a ||| a	count=1
function	beta-rules and conditions to ||| to	count=1
function	mpf [function_2] ||| [function_2] [function_1]	count=2
module	return true if the ||| core	count=1
function	euclidean [function_2] ||| [function_1] [function_2]	count=1
class	frame in terms ||| frame	count=1
arg	of ||| expr x	count=1
arg	[arg_1] m_1 m_2 ||| [arg_1] [arg_2]	count=2
arg	the given position ||| position	count=1
function_arg	[function_1] f ||| [function_1] puiseux2 [arg_2]	count=1
function_arg	[function_1] if n ||| [function_1] [arg_2]	count=4
arg	rank k ||| rank	count=1
arg	yields the k-tuples ||| k zeros	count=1
arg	value to ||| value	count=1
function	real element object ||| real field	count=1
function	list ||| from list	count=1
function_arg	[function_1] [arg_2] ordered ||| physics quantum [function_1] expr [arg_2]	count=1
function	in which ||| empty	count=1
class	to this linear ||| linear	count=1
function	multiply a sequence of ||| mul	count=1
function	a piecewise ||| piecewise	count=1
function	no ||| refine complexes	count=2
function	sparse zero matrix ||| sparse matrix	count=3
class	bounding ||| complex root of	count=2
function	a polynomial ||| as poly	count=1
arg	to it's variable form ||| maxterm variables	count=1
arg	g [arg] parameters ||| [arg]	count=1
function	system using ||| system lu	count=1
module	permutation representing the tensor ||| combinatorics	count=1
function	generators in ||| gens	count=1
class	factors ||| factors	count=3
module_class	[module_1] real ||| [module_1] [class_2]	count=12
function	of motion in explicit ||| explicit rhs	count=1
function_arg	to [arg_2] ||| [function_1] [arg_2]	count=2
arg	grid adds ||| grid	count=1
arg	polynomial in ||| f	count=6
function	to their associated ||| operators to state	count=1
function	the ||| free	count=2
function_arg	the reduced [arg_2] ||| [arg_2] [function_1]	count=3
function_arg	normal [function_1] [arg_2] ordered ||| physics quantum [function_1] expr [arg_2]	count=1
function	function is ||| is	count=4
arg	h a ||| h	count=1
arg	the factors has root ||| factors	count=1
class	for the ||| octave code	count=1
class	this linear entity which ||| linear entity	count=1
module	above or below the ||| physics	count=3
function	in integer representation ||| pure symbol int repr	count=1
class	on a specific value ||| series base	count=1
arg	find an ||| func	count=1
class	complex interval ||| complex interval	count=2
function_arg	a transversal of the [function_1] [arg_2] the second method described ||| [function_1] [arg_2]	count=2
function_arg	substitution examples ||| subs d	count=1
function	[function_1] heurisch ||| [function_2] [function_1]	count=4
function	equivalent ||| generate equivalent	count=1
function	deltaintegrate ||| deltaintegrate	count=1
function	lower [function_2] ||| [function_1] [function_2]	count=2
arg	two polynomials in k[x] ||| g u k	count=1
function_arg	this function simplifies [function_1] [arg_2] ||| [function_1] logic [arg_2] deep	count=1
module	is ||| physics	count=1
function	[function_1] simple roots ||| [function_1] [function_2]	count=1
function	in integer ||| int	count=1
function_arg	function field [arg_2] ||| [arg_2] [function_1]	count=1
arg	[arg_1] morphisms of ||| [arg_2] [arg_1]	count=4
function	rotational gradients of ||| rot grad	count=1
function	expand hypergeometric ||| hyperexpand	count=1
function_arg	from [arg_2] ||| [function_1] bsgs [arg_2]	count=3
arg	this literal without the ||| literal	count=1
arg	of a field in ||| field coord_sys	count=1
arg	**2 ||| max pow	count=2
arg	f and for ||| a d	count=1
function	construct polynomials from ||| parallel poly from	count=1
function	sorting [function_2] ||| [function_2] [function_1]	count=4
function	that dummies can be ||| dummies	count=1
arg	and token same effect ||| token	count=1
arg	disjoint and ||| complexes	count=1
function	of the asin ||| asin	count=1
arg	element elem of ||| elem	count=1
function	phrase and ||| and	count=1
module	where p[i] < ||| combinatorics	count=1
module_class	[module_1] [class_2] ||| [module_1] vector [class_2]	count=2
function	recursively strip it ||| dmp validate	count=1
arg	coefficient ||| coeff	count=1
module	function does the actual ||| physics	count=1
function_arg	multiplication c is ||| mul scalar c	count=1
function	partial ||| measure partial	count=1
function	rotates left by ||| rotate	count=1
function	tensor product of multiple ||| tensor product	count=2
function	distributed module element ||| sdm	count=1
arg	q ||| q	count=11
function	solveset to return ||| solveset	count=1
function	[function_1] square-free part ||| [function_1] [function_2]	count=1
function	available and ||| use	count=1
function	a dummy ||| dummy	count=1
function	laplace transform of ||| laplace transform	count=2
arg	name ||| name	count=4
function	compute the inverse hankel ||| inverse hankel	count=1
arg	c ||| n c condition	count=1
function	allows functions to be ||| function	count=1
function	addition of ||| add	count=1
arg	for displaying [arg] representation's with ||| [arg]	count=1
class	compatible with crootof ||| complex root of	count=1
function	g ||| sdm groebner	count=1
function	a class into a ||| get mod	count=1
arg	actual infinitesimals of the ||| infinitesimals func	count=1
class	for the generated ||| code gen	count=1
class	space rotation is similar ||| space	count=1
arg	fpgroup h ||| h	count=1
function	domain of the ||| not empty in	count=1
arg	[arg] default ||| n [arg]	count=3
function	[function_1] linear in ||| [function_1] [function_2]	count=1
function	prime ||| dmp zz modular	count=1
class	adds up ||| add	count=1
function_arg	[function_1] the routine ||| [function_1] [arg_2]	count=6
function_arg	[function_1] order n ||| [arg_2] [function_1]	count=6
class	of the given ||| expr	count=1
module	of the loggamma function ||| functions special	count=2
class	intersection ||| accumulation bounds	count=1
class	this gate needs ||| gate	count=1
module	and negative ||| simplify	count=1
arg	a small'' matrix m ||| deg_f deg_g row1	count=1
function	potential function of a ||| potential	count=2
arg	c columns if c ||| c	count=1
arg	return the truth value ||| cls	count=1
function	it takes as input ||| as	count=1
arg	radial wavefunction r_{nl} ||| l nu r	count=1
function	[function_1] ring i ||| [function_2] [function_1]	count=4
arg	[arg_1] [arg_2] with ||| [arg_2] [arg_1]	count=3
arg	a function in ||| function	count=1
function	[function_1] parallel to ||| [function_2] [function_1]	count=6
function	applied on it ||| on	count=1
module	if the underlying ||| physics	count=1
function	directional derivative of ||| directional derivative	count=2
function	opportunities in ||| opt cse	count=1
class	this gate needs to ||| cnot gate	count=1
arg	[arg] access ||| [arg]	count=6
function	is not-empty ||| in	count=1
arg	to ||| method af	count=1
function	von [function_2] ||| [function_1] [function_2]	count=2
function	piecewise ||| piecewise	count=1
function	leading monomial as a ||| leading monom	count=1
function_arg	the intersection [arg_2] ||| [arg_2] [function_1]	count=1
module	matrix and returns l ||| matrices	count=2
arg	quantum ||| r	count=1
function	fraction to ||| from qq	count=1
module	ie the location where ||| combinatorics	count=2
arg	phrase is not ||| phrase	count=1
function	proper ||| proper	count=2
function	of the ||| empty in	count=1
function	quadratic ||| quadratic normal	count=2
function	space rotation is ||| space	count=1
function	[function_1] function class ||| [function_2] [function_1] func_class f symbol	count=1
function	strategic all - ||| sall	count=1
function	[function_1] definite ||| [function_1] [function_2]	count=1
arg	b r] for p ||| p	count=1
function	- a [function_2] ||| [function_1] [function_2]	count=1
arg	domain ||| domain	count=2
arg	this literal without ||| literal	count=1
function	solve a [function_2] ||| [function_1] [function_2]	count=1
function	rank ||| rank	count=7
function_arg	adds a [arg_2] ||| [function_1] morphisms [arg_2]	count=5
arg	compute \frac f [arg_1] [arg_2] ||| [arg_1] [arg_2]	count=7
function	[function_1] derivative of ||| [function_1] [function_2]	count=4
function	minimum power of ||| min pow	count=2
function_arg	decreasing [arg_2] ||| [arg_2] [function_1]	count=4
function	space characters ||| indent	count=1
function	leverage it if possible ||| try	count=1
arg	not in ||| filter	count=1
module	which passes [module] ||| [module]	count=1
arg	that is suitable for ||| iszerofunc simpfunc	count=1
function	finds ||| not	count=1
function	christoffel symbols for the ||| christoffel 1st	count=1
arg	constructing the ||| grid morphisms_str_info	count=1
class	generate a ||| ring	count=2
class	frame in terms ||| reference frame	count=1
function	[function_1] t ||| [function_1] [function_2]	count=6
arg	and _hastypes to expr ||| expr attrs types	count=1
arg	is also ||| root1 root2	count=1
function	of the form ||| limits	count=1
function	[function_1] g*h where ||| [function_1] [function_2]	count=12
module	apply branching rule ||| strategies branch	count=1
function	[function_1] function ||| [function_2] [function_1]	count=9
function	refine a positive root ||| refine real root	count=1
arg	a given inequality or ||| f symbol domain	count=1
function	computes the rank ||| rank	count=1
module	value of the ||| elementary	count=1
class	a ||| octave code gen	count=2
function	square root of ||| sqrt	count=2
arg	[arg_1] **2 ||| [arg_1] [arg_2]	count=1
arg	function target to yield ||| target	count=1
module	generate ||| agca	count=2
arg	coords ||| coords	count=1
function	dmf object ||| global polynomial	count=1
module	lie algebra ||| liealgebras	count=17
function	[function] triangle of ||| [function]	count=1
function_arg	[function_1] cipher ||| [function_1] [arg_2]	count=6
module_class	takes this [class_2] ||| [module_1] [class_2]	count=4
function	[function_1] iterator ||| [function_2] [function_1]	count=2
function	[function_1] power and ||| [function_2] [function_1]	count=1
module	domain of ||| polys	count=1
function	isolation positive [function] ||| [function]	count=2
function	of symmetry of ||| of symmetry	count=1
class	to a group ||| group element	count=1
arg	function for functions checking ||| expression	count=1
class	prufer sequence that ||| prufer	count=2
module_class	[module_1] data ||| [module_1] module [class_2]	count=2
arg	p - 1 ||| p all_roots	count=1
function	product of [function_2] ||| [function_2] [function_1]	count=2
module	standard basis ||| agca	count=1
function	[function] of ||| number [function]	count=1
function	generates ordered ||| ordered	count=1
function_arg	[function_1] f ||| [function_1] [arg_2]	count=227
function_arg	d^2 = [arg_2] ||| [function_1] [arg_2]	count=1
class	in ||| base	count=1
arg	the root if ||| cls root	count=1
function	the number ||| number	count=1
function	bottom nodes ||| bottom up	count=1
arg	whose rank [arg] less than ||| [arg]	count=1
class	of this sparsematrix ||| matrix	count=1
function	return basic [function_2] ||| [function_2] [function_1]	count=3
function	the whole ring ||| whole ring	count=2
class	containers of polynomials ||| ring	count=1
function	matrix if components data ||| matrix	count=1
arg	, ||| t plane	count=1
arg	use ||| s	count=1
function	polynomials from ||| from	count=2
function	add ||| dup add	count=1
module	no bounding ||| polys	count=1
arg	system of ||| system	count=2
function	matrices ||| matrices	count=2
class	[class_1] entity which ||| [class_1] [class_2]	count=3
function_arg	cyclic [arg_2] ||| combinatorics [function_1] group [arg_2]	count=3
function	[function_1] to ||| [function_1] [function_2]	count=21
function	to whether ||| from	count=1
function	lagrange's equations of motion ||| lagranges equations	count=1
arg	the modulus of ||| modulus	count=1
arg	opportunities in ||| exprs	count=1
arg	and return the ||| s	count=1
function	[function_1] rectum ||| [function_2] [function_1]	count=3
function	modularinteger [function_2] ||| [function_1] [function_2]	count=1
arg	[arg_1] , ||| [arg_2] [arg_1]	count=3
function	homogeneous coefficients [function_2] ||| [function_2] [function_1]	count=2
function	square-free ||| splitfactor sqf	count=1
function	[function_1] increasing in ||| [function_2] [function_1]	count=5
class	the group ||| permutation group	count=5
module	python ||| parsing	count=1
arg	p q are in ||| p q x	count=2
function	is a permutation ||| is	count=1
function	is defined ||| interval	count=1
function	[function_1] substitution ||| [function_2] [function_1]	count=3
function	out generators ||| expr no gens	count=1
function	using subresultants over a ||| ff prs	count=1
arg	is replaced by ||| kwargs	count=1
function	a sequence in ||| sequence	count=1
function	linearize the ||| linearize	count=1
function	cyclic notation from the ||| cyclic	count=1
function	negate a [function_2] ||| [function_2] [function_1]	count=2
function	domain of ||| not empty in	count=1
function	a python subprocess with ||| in subprocess with	count=1
arg	[arg_1] symbols ||| [arg_2] [arg_1]	count=6
function	return the iterable ||| iterable	count=1
function	monotonic in ||| monotonic	count=1
arg	[arg_1] base b ||| [arg_2] [arg_1]	count=3
arg	contains elements of k0 ||| k0	count=1
function	eject selected generators into ||| eject	count=2
arg	polynomials f and g ||| f g	count=4
function	a field ||| field	count=4
module_class	implies __div__ ||| polys domains field	count=2
function	[function_1] sentinel ||| [function_2] [function_1]	count=1
function	list of non-zero ||| list	count=1
module_class	and [class_2] ||| [module_1] [class_2]	count=2
arg	a small'' matrix m ||| deg_f deg_g	count=1
module	instance for the ||| physics quantum	count=1
function	python ||| python	count=6
function	computing i^e (mod ||| rsa	count=1
function_arg	[function_1] [arg_2] ||| [function_1] [arg_2]	count=6795
module	the get_unit ||| physics	count=1
function	heuristic ||| heu	count=4
function	square-free part [function_2] ||| [function_2] [function_1]	count=2
class	the ||| entity	count=2
function	[function_1] plan consisting ||| [function_2] [function_1]	count=1
function	the series expansion ||| series	count=1
arg	switch to ||| f native zero	count=1
function	best solution to an ||| 1st homogeneous coeff best	count=1
class	line ending ||| code printer	count=1
function	expression as a ||| as	count=1
function	optimization opportunities in ||| opt	count=1
function	algorithm [function] whose ||| eval berkowitz [function]	count=1
class	single [class_2] ||| [class_2] [class_1]	count=1
function	exponentiation of a ||| exp	count=1
arg	[arg_1] a path ||| [arg_2] [arg_1]	count=5
arg	vector constants ||| variable constant k	count=1
arg	environment ||| pretty_print order use_unicode use_latex	count=1
function	[function_1] constants ||| [function_2] [function_1]	count=4
function_arg	the inverse function ||| inverse argindex	count=1
arg	strip ||| x strip	count=1
module	that converts a ||| solvers	count=1
function	create function with name ||| create function base	count=1
arg	characters of msg to ||| msg	count=1
arg	the curl ||| vect doit	count=1
function	dx ||| differential	count=1
function	morse code with letters ||| morse	count=1
function	a minimal ||| minimal	count=1
function	set from generators ||| gens from	count=2
function	[function_1] partition ||| [function_1] [function_2]	count=4
arg	transversals and result in ||| transversals	count=1
function	sequences defined [function] starting from ||| assoc [function]	count=1
module	[module_1] generalized ||| [module_1] [module_2]	count=2
arg	[arg_1] z0 ||| [arg_2] [arg_1]	count=5
function	of a product ||| mul	count=4
function_arg	[function_1] for the ||| [arg_2] [function_1]	count=3
arg	ensemble ||| qubit format	count=1
arg	[arg_1] [arg_2] squaring ||| [arg_2] [arg_1]	count=1
arg	[arg_1] [arg_2] with ||| matrices rowadd [arg_2] [arg_1]	count=3
function	block [function_2] ||| [function_2] [function_1]	count=2
arg	details ||| re	count=1
arg	of two ||| other	count=3
function	a set of equivalent ||| generate equivalent	count=1
function	tell whether ||| is	count=1
arg	kind ||| d kind	count=1
function	:func _dup_decompose ||| dup right decompose	count=1
module_class	[module_1] schreier ||| [module_1] [class_2]	count=4
arg	a morphism ||| morphism	count=2
class	series ||| series	count=2
function	matrix corresponding to ||| matrix	count=1
class	complex isolating [class_2] ||| [class_1] [class_2]	count=1
function	at least [function] ||| [function]	count=3
function	symbol and its ||| pure symbol	count=1
function_arg	[function_1] of general ||| [function_1] [arg_2]	count=1
function	dictionary [function_2] ||| [function_2] to [function_1]	count=1
arg	[arg_1] on input ||| [arg_2] [arg_1]	count=2
function	computes a transversal for ||| transversal	count=1
arg	taken k at a ||| k replacement	count=2
function	with sorted [function_2] ||| [function_1] [function_2]	count=4
arg	of morphisms between objects [arg_1] [arg_2] of morphisms listed as ||| [arg_1] [arg_2]	count=1
function	formats ||| get	count=1
function	returns the leading coeffcient ||| sdm lc	count=1
arg	m by coefficient ||| m	count=2
function	circuit ||| replace subcircuit	count=1
arg	function for ||| expression predicate	count=1
module	to indicate if the ||| physics	count=1
class	returns a ||| module poly	count=1
arg	the anti-derivative [arg_2] ||| [arg_2] x [arg_1]	count=1
arg	in old with the ||| old	count=1
module	[module] field computed ||| physics [module]	count=4
module	of expressions as ||| integrals	count=1
class	submodule ||| poly ring	count=1
arg	length [arg_2] ||| [arg_2] [arg_1]	count=1
arg	[arg_1] o ||| [arg_2] [arg_1]	count=4
function	to [function_2] ||| [function_1] sympy [function_2]	count=2
class	a new code ||| code	count=1
function	of rotational gradients of ||| rot grad	count=1
function	is a primary ||| is primary	count=3
arg	and return the result ||| s	count=1
class	line and a ||| line	count=1
arg	the given first order ||| order	count=1
class	is ||| kronecker delta	count=1
arg	return an [arg_2] ||| [arg_1] [arg_2]	count=2
arg	[arg] mul instance ||| [arg]	count=1
module	proper ||| printing	count=1
class	ordered subset ||| subset	count=1
arg	b ||| b a b	count=1
function	pollard's rho ||| pollard rho	count=1
function_arg	square polynomials [arg_2] ||| [function_1] [arg_2]	count=1
function	is of [function_2] ||| [function_1] [function_2]	count=1
module	each [module] ||| [module]	count=1
module	finds the ||| combinatorics	count=1
module	and leverage it ||| pretty	count=1
class	are ||| differential	count=1
arg	2 ; -1 if [arg_1] [arg_2] 1 3 2 3 ||| physics epsilon [arg_1] [arg_2]	count=1
module	return from the ||| core	count=1
function_arg	quantity to [arg_2] ||| [function_1] [arg_2]	count=1
function_arg	input [arg_2] ||| polys subresultants [function_1] [arg_2]	count=4
function	is iterable ||| is iterable	count=2
function	d ||| d	count=1
arg	a numpy array ||| m dtype	count=1
class	total number ||| type	count=1
function	-> meijerg lookup ||| lookup	count=1
function	by other, ||| gt	count=1
class	a ||| octave	count=1
class	will exist when ||| integral	count=1
function	files default ||| test files	count=1
function_arg	by recurrence [arg_2] ||| [arg_2] [function_1]	count=1
arg	bases and exponents ||| combine force	count=1
arg	codestring with ||| codestring	count=1
function	of arguments of ||| args	count=1
function	[function_1] functions ||| [function_1] [function_2]	count=4
function	a labeled ||| lbp	count=1
function	leading term of ||| sdm lt	count=1
arg	an integer n ||| n	count=1
class	returns a ||| module poly ring	count=1
arg	[arg_1] modulo p ||| div f [arg_1] [arg_2]	count=1
function	lexicographically ordered ||| lexicographic	count=2
arg	[arg] is ||| [arg]	count=5
module	core ||| core	count=1
function	order of the group ||| order	count=1
function	class into a ||| get mod func	count=1
function	the directional derivative of ||| directional derivative	count=1
function	see ||| try use	count=1
arg	given position ||| position	count=1
arg	in x_0 of ||| f m u k	count=1
module_class	if the wavefunction ||| physics quantum wavefunction	count=1
arg	selected by [arg_2] ||| [arg_2] [arg_1]	count=1
function	iterator ||| iterator	count=1
function	expression ||| finite diff	count=1
function	return the puiseux ||| puiseux2	count=1
arg	a in the ||| i a	count=1
arg	scalar field computed ||| scalar vect	count=2
class	qubits this gate ||| gate	count=1
arg	expression f 3 tests ||| f	count=1
arg	[arg_1] [arg_2] \rangle ||| clebsch gordan [arg_2] [arg_1]	count=1
function	coefficient of ||| coeff	count=8
function	and is ||| is	count=1
function	with hash ||| with hash	count=2
class	the coordinate ||| coord	count=1
module	to return ||| core	count=1
arg	index1 [arg_2] ||| [arg_2] [arg_1]	count=1
function_arg	[function_1] p ||| [function_1] s _lambda [arg_2]	count=1
arg	path ||| path	count=1
arg	= b m ||| a b a b	count=1
arg	respect to z ||| z tol a	count=1
function	gets segments for ||| get segments	count=1
function	specific value ||| free	count=1
arg	a k[x] polynomial ||| f u k	count=1
function	[function_1] cond ||| [function_2] [function_1]	count=4
arg	is a model or ||| expr model deep	count=1
function	[function_1] [function_2] given interval ||| [function_1] [function_2]	count=3
class	a ||| subs	count=1
arg	f given ||| f m k	count=1
function	convert self to ||| to	count=1
function	splits a list into ||| list	count=1
function	whether each coordinate of [function_1] [function_2] ||| [function_1] [function_2]	count=4
class	[class_1] product ||| [class_2] [class_1]	count=3
arg	than limit or ||| limit	count=1
function_arg	normal [arg_2] ||| [arg_2] [function_1]	count=1
function	a square-free ||| sqf	count=5
arg	respect to ||| a	count=1
function_arg	manipulate parts [arg_2] ||| [function_1] [arg_2]	count=1
module	integration using ||| integrals	count=1
function	of phrase and ||| and join	count=1
function	mapping of symbolic ||| dict	count=1
class	curve ||| curve	count=3
function	quotient of ||| quo	count=7
function	the new coordsyscartesian ||| init	count=1
arg	m is ||| m	count=1
module	the canonical ordering ||| physics	count=1
function_arg	[function_1] f at ||| [function_1] ground [arg_2]	count=1
function	values ||| create	count=1
function	that no bounding rectangles ||| refine complexes	count=1
arg	by sets and ||| sets	count=1
function	fourth [function] ||| lie [function]	count=3
function	[function_1] monomial order ||| [function_1] [function_2]	count=1
arg	m by ||| m	count=2
arg	b m + ||| a b a b	count=1
arg	and a vector constants ||| variable constant	count=1
class	a sparse [class_2] ||| [class_1] [class_2]	count=3
class	of the linearentity ||| entity	count=1
arg	[arg_1] cheap to ||| [arg_2] [arg_1]	count=3
function	paths into [function_2] ||| [function_2] [function_1] lst	count=2
arg	\mathbb{z}_p[x] ||| fp gp p	count=1
arg	of divisors of n ||| n	count=1
module	rule based on ||| strategies	count=1
function	the periodic ||| periodic	count=1
arg	[arg_1] [arg_2] ||| [arg_1] minpoly [arg_2]	count=8
function	treats xor ||| xor	count=1
function	[function] n ||| [function]	count=2
arg	isolating interval of ||| eps	count=2
class	submodule ||| sub module	count=1
arg	by multiplying by [arg_1] [arg_2] ||| scale [arg_1] [arg_2]	count=17
arg	f p g ||| f g b	count=3
function	return the ground ||| dmp ground	count=1
function	rewrites a ||| eval rewrite as heaviside	count=1
function	continuous subsequence of terms ||| slice	count=5
function	whole ||| whole	count=1
class	outer ||| outer	count=2
module	objects handles the default ||| physics quantum	count=1
function	free indices replaced by ||| call	count=1
function	terms of ||| terms of	count=2
arg	has root v ||| v dom	count=1
function	if possible ||| pretty	count=1
module	a standard ||| agca	count=1
module	special case [module] cf ||| [module]	count=1
class	a standard basis ||| module poly	count=1
function	type of ode are ||| 2eq order1	count=1
function	factor a square-free ||| factor sqf	count=3
function	[function_1] edge the ||| [function_2] [function_1]	count=2
arg	[arg_1] [arg_2] ||| physics energy [arg_2] [arg_1]	count=2
function	square root ||| sqrt	count=5
arg	= b m + ||| a b a b	count=1
arg	of f in x_j ||| f m j	count=1
arg	p q [arg_2] ||| [arg_2] [arg_1]	count=2
function_arg	is decreasing [arg_2] ||| [function_1] [arg_2]	count=2
function	to their associated ||| to state	count=1
arg	re ||| re	count=1
class	function in sympy ||| expr	count=1
arg	[arg_1] < ||| [arg_2] [arg_1]	count=6
function	rational [function_2] ||| solvers has [function_1] [function_2]	count=4
function	new rootsystem ||| new	count=1
module_class	self [class_2] ||| [module_1] [class_2]	count=7
function	a subgroup whose presentation ||| reidemeister presentation	count=1
function	coherent states of 1d ||| coherent	count=1
function	over a ||| dmp ff	count=1
class	of polar numbers is ||| polar lift	count=1
class	[class_1] power ||| [class_1] [class_2]	count=1
function	decodes a morse code ||| morse	count=1
module	of ||| utilities	count=3
module_class	values the [class_2] ||| [module_1] [class_2]	count=2
class	polynomial with self's ||| poly	count=3
arg	controls [arg_2] ||| [arg_2] [arg_1]	count=3
function	a row-sorted ||| row	count=1
function	we create a quasi-particle? ||| q creator	count=1
function	wrapper around expand ||| expand power exp	count=2
function	differentiate and evaluate a ||| dmp diff eval	count=1
module_class	[module_1] system ||| [module_1] mechanics symbolic [class_2]	count=2
function	multinomial coefficient iterator ||| multinomial coefficients iterator	count=3
function	n ||| n c	count=1
arg	[arg_1] x_0 of ||| [arg_2] [arg_1]	count=2
class	the ||| g	count=1
function	another fraction [function_2] ||| [function_2] [function_1]	count=1
class	[class] of ||| tensor [class]	count=3
function	refine a ||| refine real	count=1
function	gauss-chebyshev ||| gauss chebyshev t	count=1
function	alpha ||| alpha	count=2
class	morphisms of a diagram ||| diagram grid	count=1
arg	in col ||| col	count=1
arg	p - 1 ||| p	count=1
arg	internal use by the ||| s n	count=1
function	correct ||| correct	count=1
function	enumeration ||| enumeration	count=1
function	symbol and ||| pure symbol	count=1
function	to [function] ||| set dict [function]	count=1
module	[module] x dyadic ||| [module]	count=1
function	name ||| get mod func	count=1
function	convert from gray ||| gray	count=1
function	in integer ||| pure symbol int	count=1
function	linear equation ||| linear	count=1
function	slope ||| slope	count=1
function	calculates the finite ||| finite	count=1
arg	old with ||| old	count=1
function	distinct real roots ||| real roots	count=1
class	proper ||| code printer	count=2
arg	[arg_1] b ||| [arg_2] [arg_1]	count=11
arg	:func _symbolic_factor ||| expr opt method	count=1
class	printer ||| num py printer	count=1
arg	[arg_1] op ||| [arg_1] [arg_2]	count=1
function	the symbols in ||| constant symbols	count=1
module	the faces of the ||| combinatorics	count=1
function	initialize ||| initialize	count=1
function	cross product convenience ||| cross	count=1
function	rewrite the integral fac*po*g1*g2 ||| rewrite	count=1
function_arg	solve [arg_2] ||| [arg_2] [function_1]	count=1
arg	of ||| x m n	count=1
arg	generate [arg] list of ||| [arg]	count=1
function	expand ||| eval expand	count=1
function_arg	[function_1] f by ||| [function_1] term [arg_2]	count=1
function	polynomial division with remainder ||| div	count=1
function	the module and the ||| get	count=1
function	returns all possible subsets ||| subsets	count=1
function	returns polynomial quotient ||| exquo	count=1
function	the norm of the ||| norm	count=1
function	object from ||| from components	count=1
arg	x_j at a in ||| m a j	count=1
arg	[arg] as ||| [arg]	count=2
class	this matrix ||| sparse matrix	count=1
class	a sequence ||| ring	count=1
arg	x [arg] ||| arg [arg]	count=3
function	density ||| density	count=2
function_arg	the series [arg_2] ||| [function_1] min pow [arg_2]	count=1
function	below fermi? >>> from ||| below fermi	count=1
module	and ||| simplify	count=1
function_arg	variations of [arg_2] ||| [arg_2] [function_1]	count=1
function	decimal instance ||| decimal	count=1
function	1-axis ||| axis1	count=1
function	determinant ||| det	count=1
function_arg	[function_1] by k ||| [arg_2] [function_1]	count=1
function	normal part [function_2] ||| [function_2] [function_1]	count=1
module	the given ||| physics	count=4
arg	series expansion of the ||| n x prec	count=1
arg	convert a k[x] ||| u k	count=1
function	cholesky decomposition given ||| cholesky	count=1
function	gives [function] ||| ode 2nd [function] series	count=1
arg	l is ||| l r n	count=1
arg	base and strong ||| group base	count=1
function	m-th order derivative in ||| dmp diff in	count=1
arg	nested square ||| nested	count=1
class	which the entries outside ||| properties	count=1
function	mapping ||| param	count=1
module_class	return factors of ||| core factors	count=2
module	following for the ||| physics mechanics	count=1
function	root of a ||| indexed root	count=1
module	return solution ||| solvers	count=1
arg	the partion of seq ||| seq	count=1
function	[function_1] free ||| [function_2] [function_1]	count=8
function	opening statements of ||| opening	count=2
arg	math expression ||| expr	count=1
function	the posform ||| posform	count=1
arg	representation of [arg] as ||| [arg]	count=1
function	of the asin of ||| asin	count=1
function_arg	operators [arg_2] ||| [arg_2] [function_1]	count=7
function	matrices pq ||| matrices	count=1
arg	r ||| r algorithm	count=1
function_arg	domain of [arg_2] ||| [arg_2] [function_1]	count=1
function	[function_1] z distribution ||| [function_2] [function_1]	count=1
arg	q are ||| q x method	count=2
module	with the proper ||| printing	count=1
function	form of products of ||| form	count=1
function	leverage it if ||| pretty try	count=1
function_arg	[function_1] rv that ||| [arg_2] [function_1]	count=2
class	operator s [class_1] [class_2] eigenstate of ||| quantum [class_2] [class_1] operators	count=1
function	available and leverage it ||| use	count=1
function	equations of motion ||| equations	count=1
function	down a tree - ||| down	count=1
function	subprocess with hash randomization ||| subprocess with hash randomization	count=1
class	wavefunction ||| wavefunction	count=1
function_arg	tan [arg_2] ||| [arg_2] [function_1]	count=2
function	derivative ||| diff	count=3
function_arg	split [arg_2] ||| [function_1] surds [arg_2]	count=3
function	generate a submodule ||| submodule	count=2
arg	base [arg_2] ||| [arg_2] [arg_1]	count=1
arg	element to self dtype ||| element base	count=1
function_arg	[function_1] [arg_2] ||| [function_1] mul term [arg_2]	count=2
function	python fraction ||| qq python	count=8
function	to complete dummy indices ||| indices	count=2
module	dimension ||| units	count=1
function	[function_1] parameters and ||| [function_1] [function_2]	count=1
arg	x_j at a in ||| f m a j	count=1
module	any ||| integrals	count=1
arg	p parameters ||| p domain	count=1
function	f + ||| dmp add	count=1
function	[function_1] a gf ||| [function_2] sqf [function_1]	count=1
function	bodies in ||| bodies	count=1
function	computes the resultant of ||| resultant	count=1
function	refine a positive ||| dup outer refine real	count=1
arg	return the ||| cls	count=1
arg	[arg_1] new ||| [arg_2] [arg_1]	count=3
arg	[arg_1] m_1 m_2 ||| [arg_2] [arg_1]	count=2
function_arg	constant term [arg_2] ||| [function_1] [arg_2]	count=6
function_arg	decryption [arg_2] ||| [function_1] [arg_2]	count=1
function	below ||| only below	count=1
arg	not in [arg_2] ||| [arg_2] [arg_1]	count=2
function_arg	element [arg_2] ||| [function_1] f [arg_2]	count=3
function	[function_1] series ||| [function_2] is [function_1]	count=1
module_class	qubits this [class_2] ||| [class_2] [module_1]	count=5
function	a single [function_2] ||| [function_1] [function_2]	count=2
module	the group ||| combinatorics	count=2
function	string ||| mod func	count=2
function_arg	[function_1] of key ||| categories diagram [function_1] union dictionary [arg_2] value	count=2
class	no bounding ||| complex root	count=1
module	of self with ||| polys agca	count=2
module	this class ||| physics quantum	count=1
function	a sliding cart ||| cart	count=1
function	for independence between ||| independent	count=1
module	the functions in finite_set ||| calculus	count=1
arg	if modulus is ||| modulus	count=1
function	is a [function_2] ||| [function_2] [function_1]	count=35
function	convert modularinteger ||| from ff	count=5
arg	by the user in ||| weylelt	count=1
module	functions ||| core	count=1
class	be used ||| base	count=1
function_arg	expressions generated in ||| vprint expr	count=1
function	[function_1] where ||| [function_2] [function_1]	count=9
arg	rectangles ||| cls	count=1
arg	and g via prs ||| g includeprs	count=1
function	[function] in ||| reverse [function]	count=1
class	quotient ||| module homomorphism	count=1
class	self ||| matrix base	count=1
function	run all tests ||| run all tests	count=3
function	the symbols in ||| free symbols	count=1
function	generates legendre [function_2] ||| [function_2] [function_1]	count=1
function	a gate identity ||| random identity search	count=1
function	division ||| div	count=10
function	polynomial lcm over a ||| dmp ff lcm	count=1
class	matrix for [class] ||| [class]	count=1
function	[function_1] the heurisch ||| [function_2] [function_1]	count=4
function	functions ||| print function	count=1
arg	modulus of [arg_2] ||| [arg_2] [arg_1]	count=2
arg	[arg_1] [arg_2] creates a new ||| [arg_2] [arg_1]	count=2
arg	points in the ||| func points	count=1
function_arg	coefficients of f ||| content f k	count=2
module	symbolic base and rational ||| core	count=1
function	a copy of ||| structure copy	count=1
function	to dtype ||| from	count=10
arg	modulo a polynomial p ||| p u k	count=1
function	complete dummy indices ||| indices	count=2
function	square-free part of ||| sqf part	count=8
function_arg	[function_1] x ||| [function_1] m [arg_2]	count=1
function	heuristic assumes the ||| heuristic bivariate	count=1
arg	and \eta to be ||| match comp	count=1
function	subset defined by the ||| subset	count=1
arg	of factors ||| factors u	count=1
module	setup conjugating the ||| physics optics	count=1
arg	of length l1 ||| l1	count=1
module	lists [module] which ||| [module]	count=1
module	string as a ||| printing	count=1
arg	first order differential ||| order match	count=1
function	function to correct ||| correct signature	count=1
function_arg	from a tensexpr all [function_1] [arg_2] ||| physics hep extract type [function_1] [arg_2]	count=1
arg	a string and handler ||| handler	count=1
function_arg	[function_1] the given ||| [arg_2] [function_1]	count=17
function	switch to another ||| connect to	count=1
arg	one of the factors ||| factors	count=1
function_arg	is [arg_2] ||| [arg_2] [function_1]	count=1
function_arg	[function_1] modulo o(x**prec) ||| [function_1] [arg_2]	count=3
arg	the given number of ||| s	count=1
function	the puiseux series ||| rs puiseux2	count=2
function	given [function_2] ||| [function_2] [function_1]	count=2
function	the string ||| get mod	count=1
class	[class_1] root ||| [class_1] [class_2]	count=1
arg	access ||| ct	count=1
function	integer representation ||| symbol int repr	count=1
module	computes quotient of ||| polys	count=1
module_class	a, implies __abs__ ||| polys domains domain	count=1
arg	of the routines in ||| routines f prefix funcname	count=1
arg	rule to args ||| rule	count=1
arg	g ||| g b	count=1
module	for assumptions ||| assumptions	count=1
function	second set of numerator ||| aother	count=1
arg	[arg_1] [arg_2] m_3 \rangle ||| [arg_2] [arg_1]	count=2
module	are generated ||| integrals	count=1
function	from a sympy ||| sympy	count=1
function	values above ||| above	count=1
function	the specified axes ||| tensorcontraction	count=1
function	writes ||| get	count=2
function	numerator parameters of the ||| ap	count=1
arg	of points in ||| points	count=1
class	of polynomials ||| poly ring	count=2
function	it takes as ||| as	count=1
arg	[arg] to a ||| [arg] assign_to	count=1
arg	subcircuit [arg] another subcircuit ||| circuit subcircuit [arg]	count=1
function	inject them [function] its ||| drop [function]	count=1
module_class	[module_1] given plane ||| [module_1] [class_2]	count=2
function	rewrite ||| rewrite	count=3
function	reduced representation of a ||| trunc	count=1
arg	and g in k[x] ||| g u k	count=1
module	function in the ||| physics quantum	count=1
function	[function_1] dictionary ||| [function_2] [function_1]	count=5
arg	of terms of f ||| f m	count=4
arg	override geometryentity rotate ||| pt	count=1
function	restricted [function_2] ||| [function_1] [function_2]	count=1
function	[function_1] indices corresponding ||| [function_1] [function_2]	count=6
function	polynomial [function] ||| [function]	count=2
function	subprocess [function_2] ||| [function_2] [function_1]	count=3
arg	given by sets and ||| sets	count=1
function	helper function of dsolve ||| helper	count=1
arg	[arg_1] to k1 ||| [arg_1] [arg_2]	count=3
function	returns a tuple ||| as real	count=1
arg	constructing the string ||| morphisms_str_info	count=1
arg	using strategy ||| strategy	count=1
arg	sum c[n]*p**n modulo o(x**prec) ||| x prec	count=1
function	the domain of ||| not empty in	count=1
function	[function_1] constants by ||| [function_2] [function_1]	count=4
function	[function] generators ||| in [function] of	count=1
function	to ||| signature from indices	count=1
arg	of sufficiently small ||| dx	count=1
function	symbols that will ||| symbols	count=1
function	to _eval_nseries ||| nseries	count=1
function	this method converts ||| letter form to	count=1
function	indices replaced by ||| call	count=1
arg	is the term with ||| r	count=1
function	of [function] ||| integrate [function]	count=3
function_arg	cofactors [arg_2] ||| [arg_2] [function_1]	count=5
function	the coefficient of ||| as coeff	count=7
function	object has ||| has	count=1
function	symbols that ||| free symbols	count=2
function_arg	[function_1] p ||| [function_1] from dict [arg_2]	count=3
function	scan performs ||| scan	count=1
class	total ||| type	count=1
class	homomorphism ||| homomorphism	count=1
function	name ||| func	count=1
arg	of [arg_1] [arg_2] ||| [arg_1] [arg_2]	count=38
function_arg	graph gr adjacency ||| graph certificate gr	count=1
function	multivariate series inversion 1/p ||| rs series inversion	count=1
function_arg	[function_1] p ||| [arg_2] [function_1]	count=68
function	which returns a sympy ||| sympy	count=1
function	common ||| process common	count=1
function	the number of syllables ||| number syllables	count=1
function	coefficient ||| as coeff add	count=3
arg	between objects [arg] ||| [arg]	count=2
arg	if all args are ||| cond	count=1
class	linear [class_2] ||| [class_2] [class_1]	count=5
function	[function_1] explicit ||| [function_2] [function_1]	count=2
function	non-central ||| noncentral	count=1
function	nested tuple ||| dmp to tuple	count=1
arg	point z0 using the ||| z0 dir	count=1
function	[function] roots of ||| [function]	count=9
function	solve a parametric ||| param	count=1
module	it ||| printing	count=1
function_arg	[function_1] [arg_2] have numbers 1 through ||| [function_1] [arg_2]	count=2
function	to decide how to ||| hprint	count=1
function	+ cz^2 + ||| normal	count=1
class	the differential ||| differential operator	count=1
arg	respect to t ||| t	count=1
arg	if self [arg] are the ||| [arg]	count=1
arg	[arg_1] and token ||| [arg_2] [arg_1]	count=3
arg	real inverse_mellin_transform ||| s x_ strip	count=1
function	list of free ||| free	count=3
arg	converts a tree ||| tree	count=2
function_arg	op [arg_2] ||| [arg_2] [function_1]	count=2
function	mpmath's mpf ||| real field	count=3
arg	polynomial p ||| p	count=2
function	the functions in finite_set ||| in	count=1
function	recursive helper function ||| rec degree in	count=1
arg	x = a ||| a k	count=1
function	to ||| create param dict	count=1
function	is non-negative ||| is nonnegative	count=5
arg	arg into two ||| arg	count=1
arg	m ||| m	count=9
function_arg	lift the [arg_2] ||| [function_1] [arg_2]	count=3
module	the underlying ||| physics	count=1
arg	of a composite polynomial ||| poly	count=3
function	dummies ||| ordered dummies	count=1
arg	x_j in ||| m n j	count=1
arg	with already-processed [arg_2] ||| [arg_2] [arg_1]	count=2
arg	rule to ||| rule fns	count=1
arg	calculate the anti-derivative to ||| meijerg risch	count=1
module	and the name of ||| utilities	count=1
module	of the functions in ||| calculus	count=1
function	[function_1] [function_2] ||| [function_1] beta [function_2]	count=3
function	clause ||| clause	count=1
function_arg	symbol [arg_2] ||| [arg_2] [function_1]	count=1
function	restricted with respect to ||| restricted	count=1
arg	n with coefficients in ||| n	count=1
arg	x_j of ||| m j	count=1
function	free list of ||| free	count=1
arg	simplified version eq' ||| subs exponents_only	count=1
function	axis ||| axis	count=1
module	convert the ||| physics	count=1
function	decide how [function_2] ||| [function_2] [function_1]	count=1
module_class	[module_1] along self's ||| [module_1] [class_2]	count=4
function	modulo a prime ||| modular	count=1
function	returns a mutable ||| mutable	count=1
class	of ||| complex root of	count=2
function	numbers c for symbols ||| comms	count=1
function	the symbol corresponding ||| i2symbol	count=1
arg	rational [arg] modulo the ||| [arg]	count=1
function	the functions in finite_set ||| not	count=1
function	values above fermi? >>> ||| only above fermi	count=1
function_arg	[function_1] [arg_2] ||| [function_1] morphisms [arg_2]	count=10
module	which [module_2] ||| [module_2] [module_1]	count=1
function_arg	[function_1] point ||| [arg_2] [function_1]	count=4
arg	i j [arg_2] ||| [arg_2] [arg_1]	count=4
function	atan ||| atan	count=1
class	the fortran ||| fcode	count=2
arg	expr >>> from ||| expr	count=1
function	the types of functions ||| functions	count=1
arg	containing prec ||| prec	count=1
function	of polynomial ||| poly	count=1
function	the level of ||| level	count=1
arg	the given [arg_2] ||| [arg_2] [arg_1]	count=9
function	factor polynomials into irreducibles ||| factor list include	count=1
function_arg	pairs of [arg_2] ||| [arg_2] [function_1]	count=2
module_class	[module_1] system into ||| [module_1] [class_2]	count=1
function	a transversal for ||| transversal	count=1
function	equation is [function_2] ||| [function_1] [function_2]	count=2
arg	of rank ||| rank	count=1
function	the potential energy ||| potential energy	count=2
class	where p[i] ||| permutation	count=2
function	the digamma function ||| digamma	count=1
function	rational function ||| fraction field	count=2
function	the indefinite integral of ||| dmp integrate	count=2
function	trial multiplication algorithm for ||| trial mul	count=1
module	return true if self ||| agca	count=8
function	scaler-row ||| mulrowscaler	count=1
function_arg	posform function ||| posform variables	count=1
arg	expansion ||| x prec	count=5
function	the positions of descents ||| descents	count=1
module	the beginning ||| utilities	count=1
function	register a ||| register	count=1
arg	of length l1 on ||| l1 l2	count=1
arg	[arg_1] the morphisms ||| [arg_2] [arg_1]	count=6
arg	to a tensmul object ||| tensmul	count=1
function	is a unit ||| is one	count=6
arg	[arg] is ||| r [arg]	count=5
function	be in integer representation ||| symbol int repr	count=1
function	is the ||| is	count=10
function	[function_1] is nonzero ||| [function_2] [function_1]	count=2
function_arg	[function_1] terms of ||| [arg_2] [function_1]	count=2
class	lagrange ||| lagranges	count=2
function	the resultant ||| resultant	count=1
module	for the ||| physics	count=3
arg	\cdot v [arg] (wu_{1} ||| u w [arg]	count=1
arg	by its name ||| name m	count=2
function_arg	with controls targets ||| zbasis controls targets	count=1
arg	fundamental strip given by ||| strip	count=1
arg	alpha as ||| alpha	count=1
function	find ||| cse	count=1
arg	possible welds ||| welding_edge	count=1
class	a ||| quotient ring	count=2
class	subrange of pstack if ||| multiset partition traverser	count=2
function	cancellation deg ||| cancel	count=1
arg	the series expansion ||| a prec	count=1
function	return the puiseux series ||| rs puiseux2	count=1
arg	x -> x + ||| x	count=1
arg	to x note that ||| x	count=1
arg	or [arg] wrt ||| [arg]	count=1
function	[function_1] symbols of ||| [function_1] [function_2]	count=1
function	linear ||| linear	count=20
function_arg	monomial order [arg_2] ||| [arg_2] [function_1]	count=1
class	no ||| of	count=1
function_arg	[function_1] in expr ||| [function_1] [arg_2]	count=4
function_arg	the affine [arg_2] ||| [function_1] [arg_2]	count=2
function	is open ||| is open	count=2
arg	in the given ||| expression	count=3
function	[function_1] sympy coefficients ||| [function_2] [function_1]	count=4
function_arg	order [arg_2] ||| diffgeom covariant [function_1] [arg_2]	count=1
function	minimal polynomial for ||| minpoly op	count=1
arg	on a scalar ||| scalar_field	count=1
arg	than other ||| other	count=1
module_class	[module_1] __div__ ||| [module_1] [class_2]	count=4
class	this method and ||| linear	count=1
function	recalculate the ground domain ||| retract	count=1
function	the tree as ||| tree	count=1
function	refine a positive ||| outer refine real	count=1
function	a list into part ||| split list	count=1
class	interval until ||| real interval	count=4
function	an error ||| var count error	count=1
module_class	[module_1] coset table ||| [module_1] [class_2] is complete	count=1
function	cholesky decomposition ||| cholesky	count=2
arg	of the routines ||| routines	count=2
class	coset enumeration ||| coset	count=2
module	return ||| agca	count=1
function	generating set from generators ||| gens from	count=1
function_arg	printing in ||| printing ip	count=1
module	generate a ||| polys	count=2
module	a given lie algebra ||| liealgebras	count=1
arg	to f if ||| f symbol gens	count=1
class	groebner [class_2] ||| [class_2] [class_1]	count=2
function	[function] partition of ||| [function]	count=2
module	rotation [module] for ||| [module]	count=3
function	heuristic is to ||| heuristic	count=1
function	event [function_2] ||| [function_1] [function_2]	count=1
arg	given ||| expression	count=3
arg	returning (field x1 xn) ||| symbols domain order	count=1
module	optical setup conjugating the ||| physics	count=1
class	writes a ||| code	count=1
function	a list of free ||| free	count=2
function_arg	[function_1] [arg_2] ||| [function_1] sqf part [arg_2]	count=9
arg	function ||| function	count=3
arg	p [x] polynomial ||| p k	count=2
function	written as ||| as	count=1
arg	n in x ||| n x alpha	count=3
function	table ||| table	count=4
arg	apply a rule ||| rule fns	count=1
class	for the ||| fcode gen	count=1
class	matrix of ||| sparse matrix	count=1
class	run ||| py doc test runner	count=1
function	[function_1] the order ||| [function_1] [function_2]	count=1
arg	bring expr nearer ||| expr	count=1
module	a permutation ||| combinatorics	count=3
class	coset ||| permutation group	count=2
module	self with ||| polys agca	count=1
function_arg	logarithm of [arg_2] ||| [arg_2] [function_1]	count=2
function	[function_1] randomization ||| [function_1] [function_2]	count=6
module	the two ||| combinatorics	count=1
function	[function_1] module ||| [function_1] [function_2]	count=8
class	generators ||| frac field	count=1
function	as a matrix ||| matrix	count=1
function	down a tree - ||| top down	count=1
function	see if ||| use	count=1
function	refine [function_2] ||| [function_2] [function_1]	count=4
function	roots up ||| real roots	count=1
function	mod ||| mod	count=2
function	module and the name ||| get mod func	count=1
module	(real=true) with the ||| geometry	count=1
function	fn -n x ||| dup spherical bessel fn minus	count=1
function	[function_1] gcd ||| [function_2] [function_1]	count=5
function	the line ||| line	count=1
function	largest subset of ||| pairwise most common	count=1
function	t [function] value ||| tuple [function]	count=1
class	representing the interval ||| interval	count=1
arg	fp_group a finitely ||| elm_rounds simp_rounds	count=1
function	homogeneous coefficients using the ||| homogeneous coeff	count=1
arg	s [arg_2] ||| [arg_2] [arg_1]	count=5
function_arg	quantity to another ||| to other	count=1
arg	new instance [arg_2] ||| [arg_1] args [arg_2]	count=1
function	inradius ||| apothem	count=1
arg	corresponding [arg] ||| [arg]	count=1
function	basic element ||| element	count=1
class	generate ||| module quotient	count=1
function	norm of a polynomial ||| norm	count=2
function_arg	subtract polynomials in ||| sub f g	count=1
arg	of a unit ||| unit	count=1
function	the [function] group ||| [function]	count=1
function_arg	[function_1] two permutations ||| [arg_2] [function_1]	count=8
arg	r are linear combinations ||| r	count=1
arg	[arg] turn ||| matlist index1 [arg]	count=1
function	positive root ||| root	count=2
function	the directional ||| directional	count=1
function	inverse laplace transform ||| inverse laplace transform	count=3
class	along self's last ||| matrix shaping	count=2
function	derivative of each ||| diff	count=1
function	polynomial for the ||| polynomial	count=1
module	return the truth ||| elementary	count=1
arg	elements of t ||| t	count=1
function	apply state to ||| apply	count=2
function	expression which is to ||| expr	count=1
function	n-link pendulum on a ||| link pendulum on	count=1
function_arg	square-free [arg_2] ||| [arg_2] [function_1]	count=3
function	position ||| position wrt	count=2
class	the grid ||| grid	count=3
class	get ||| polyhedron	count=1
function_arg	of roots [arg_2] ||| [arg_2] [function_1]	count=6
function	of p a is ||| is	count=1
arg	kind ||| kind	count=1
function	function ||| func	count=1
function	adds ||| add morphism closure	count=1
arg	for op [arg_2] ||| [arg_1] [arg_2]	count=2
function	use pollard's p-1 ||| pm1	count=1
function	leading coeffcient ||| sdm lc	count=1
function	bitlist corresponding to ||| bitlist from	count=2
arg	sympy import lex ||| order	count=1
arg	determine multiplicities of factors ||| factors u k	count=1
arg	determine ||| expr return_dummies	count=1
class	test if the group ||| group	count=3
function	list into part a ||| list	count=1
module	handles the default ||| physics quantum	count=1
class	formal power series ||| formal power series	count=3
class	of the picture ||| string pict	count=1
function	of rational numbers ||| rational	count=1
arg	convenience if reduction is ||| ai bj	count=1
arg	to the function f ||| f	count=1
module	list of polynomial ||| polys	count=1
function	the ||| func	count=4
function	subs ||| sample iter subs	count=1
function	an isomorphism ||| isomorphism	count=1
class	__divmod__ ||| ring	count=1
arg	free and [arg_2] ||| [arg_2] [arg_1]	count=4
arg	a polynomial p in ||| f p u k	count=1
function	the berkowitz algorithm ||| eval berkowitz	count=1
class	rectangles of non-conjugate ||| root	count=1
arg	msg to the left ||| msg	count=1
function	gcd of coefficients of ||| dmp ground content	count=1
function	is a ratio ||| is	count=1
function	a class ||| mod	count=1
function	which are free symbols ||| free symbols	count=1
function	opening statements of ||| get routine opening	count=2
arg	f to all expressions ||| f atoms nonbasic	count=1
class	instances of the given ||| expr	count=1
class	that ||| root of	count=2
function_arg	here [arg_2] ||| [arg_2] [function_1]	count=1
function	nth digit of pi ||| pi	count=1
arg	optimization opportunities ||| exprs	count=1
class	helper function ||| dense	count=1
module	the angle ||| physics	count=1
module_class	[module_1] state ||| [module_1] [class_2]	count=1
function	dv/v where f a ||| recognize log derivative	count=1
function	derivative of a ||| derivative	count=1
arg	function for functions ||| expression predicate interval symbol	count=1
arg	and k1 ||| k1	count=1
arg	[arg_1] its attributes ||| [arg_1] [arg_2]	count=2
function	returns the product of ||| mul	count=1
arg	first order differential ||| eq func order match	count=1
arg	matrix matrix ||| matrix	count=2
function	for ||| for	count=1
function	the module and ||| get mod func	count=1
function	[function_1] sliding cart ||| [function_2] [function_1]	count=5
function_arg	derivative [arg_2] ||| [arg_2] [function_1]	count=11
function	see if unicode output ||| pretty try use unicode	count=1
arg	p g ||| g	count=1
class	excluding ||| series base	count=2
function	a product [function_2] ||| [function_1] [function_2]	count=1
module	is ||| physics quantum	count=3
function	substitution with truncation according ||| rs subs	count=1
function	mpmath's mpf [function_2] ||| [function_2] [function_1]	count=2
function	sum [function_2] ||| [function_1] [function_2]	count=6
function	singularity functions ||| as singularity function	count=1
class	dyadic and ||| dyadic	count=1
function	quotient by a ||| quo	count=2
module	interpolating [module] for ||| [module]	count=1
function	part ||| part multiplicity	count=1
function_arg	normalize [arg_2] ||| [function_1] [arg_2]	count=1
function_arg	the plot [function_1] [arg_2] ||| plot [function_1] [arg_2]	count=4
arg	n [arg] ||| n [arg]	count=1
function	update ||| update	count=1
function	values ||| dict	count=1
arg	algorithm ||| g n y	count=1
function	of quadratic ||| quadratic	count=1
arg	of a given two ||| other	count=1
function_arg	[function_1] j ||| [function_1] op [arg_2]	count=1
function	the name ||| mod func	count=1
function	the name of the ||| get mod func	count=1
arg	of qubit ||| qubit	count=1
arg	[arg_1] suitable ||| [arg_2] [arg_1]	count=2
function	return the leading degree ||| dmp degree	count=1
module	represent ||| physics quantum	count=1
class	on a specific ||| base	count=1
arg	the beginning ||| s	count=1
arg	[arg] true ||| [arg]	count=2
module	the annihilation ||| physics	count=1
function	a generic ||| generic	count=1
arg	get real ||| radicals	count=1
function	mapping operator classes to ||| operators to	count=1
class	the ring and ||| poly ring	count=1
function_arg	[function_1] [arg_2] ||| [function_1] f g [arg_2]	count=4
module	other functions ||| core	count=1
function	division of ||| div	count=4
function_arg	element x of ||| element x	count=1
arg	exponents ||| deep combine force	count=1
function	berkowitz algorithm to ||| det berkowitz	count=1
function	proper ||| get	count=1
class	returns ||| base	count=1
arg	= b m + ||| b	count=1
arg	an equivalent ||| expr	count=2
arg	equal to the curl ||| vect	count=1
module	containing the [module] ||| [module]	count=2
function	evaluate ||| doit	count=1
function_arg	the affine cipher ||| affine msg key	count=1
arg	ground domain ||| f	count=1
module	the generated ||| utilities	count=2
arg	key2 ||| key2	count=1
function	devise [function_2] ||| [function_1] [function_2]	count=2
function	simplified [function_2] ||| [function_2] [function_1]	count=4
module	of the quantity as [module_1] [module_2] ||| [module_1] [module_2]	count=1
function_arg	total degree [arg_2] ||| [arg_2] [function_1]	count=1
function	decomposition algorithm ||| decomposition	count=1
function	set the ||| set modulus	count=1
function	domain of the ||| not empty	count=1
arg	and _hastypes [arg_2] ||| [arg_2] [arg_1]	count=2
arg	return complexes such that ||| complexes	count=1
arg	if k == 2 ||| k	count=1
function	power of ||| pow	count=1
module	the equations ||| physics mechanics	count=4
function	there is ||| check	count=2
module_class	the given plane ||| geometry plane	count=1
module_class	[module_1] [class_2] ||| [module_1] module [class_2]	count=2
class	the polyhedra ||| polyhedron	count=1
class	indices creating new ||| tids	count=1
function_arg	[function_1] a ||| [arg_2] [function_1]	count=68
function	domain of the ||| empty in	count=1
function	these ||| order2	count=1
module	of [module_1] [module_2] ||| [module_1] [module_2]	count=14
function_arg	[function_1] p ||| [function_1] factor sqf f [arg_2]	count=2
function	sparsity of the matrix ||| eval matrix	count=1
function	which the ||| in	count=1
arg	the list of ||| x	count=1
function	is available ||| pretty	count=1
module	subsset ||| series	count=1
arg	[arg_1] d ||| [arg_2] knots [arg_1]	count=2
module	the algorithm starts ||| physics	count=1
arg	p q are polynomials ||| p q	count=5
module	the fermi ||| physics	count=3
class	of non-conjugate ||| root	count=1
arg	simple [arg] 1 ||| [arg]	count=1
function	syllables [function_2] ||| [function_2] [function_1]	count=6
arg	of f in k[x], ||| f	count=2
function	of factors ||| factors	count=1
function	the index position to ||| to	count=1
module	see if ||| printing	count=1
function	square-free normal form ||| sqf normal	count=2
function	returns angular velocity ||| angular velocity	count=2
class	lower-triangular system [class] ||| [class]	count=3
function_arg	[function_1] of gen ||| [function_1] [arg_2]	count=1
arg	gf_pow_mod f [arg_2] ||| [arg_1] [arg_2]	count=3
arg	compute gf_pow_mod f p ||| f	count=1
arg	sin x ||| rv	count=1
function	from a ||| from	count=10
function	register a handler in ||| register handler	count=1
arg	z is correct ||| z tol	count=1
arg	i ||| i k f	count=2
function	the cartan matrix of ||| cartan matrix	count=1
function_arg	[function_1] [arg_2] ||| [function_1] at [arg_2]	count=6
arg	find optimization ||| order	count=1
class	intersection ||| intersection	count=1
module	[module] to ||| physics [module]	count=2
function	roots up to ||| inner isolate real roots	count=1
arg	expression about c ||| n c	count=1
class	of the series ||| fourier series	count=1
function	over a ||| rr	count=4
arg	of cls given ||| cls rep lev dom	count=2
arg	in rules ||| rules x	count=1
arg	and dum ||| dum	count=1
function	a power ||| pow	count=1
function	to ||| func	count=2
arg	of f ||| f coeff	count=2
function	sequence in ||| sequence	count=1
arg	_match_div_rewrite ||| f g rexp	count=1
function	[function_1] col ||| [function_2] [function_1]	count=4
arg	tree running it on ||| fns	count=2
class	of the ||| linear	count=1
module	**2 [module] csc ||| [module]	count=1
function	vector ||| vector	count=3
function	constant coefficients using ||| constant coeff	count=1
function	and is nonzero for ||| is simple	count=1
arg	and ||| order	count=1
function	files ||| files	count=2
arg	given backend ||| backend	count=1
module	with matrices ||| matrices	count=1
function	terms of real sets ||| as set	count=1
arg	the solutions of f ||| f	count=1
function_arg	key is in dictionary, [function_1] [arg_2] ||| categories diagram [function_1] dict union [arg_2] value	count=3
function_arg	[function_1] [arg_2] ||| [function_1] zassenhaus f [arg_2]	count=5
function	field isomorphism [function_2] ||| [function_1] [function_2]	count=1
class	grid laid out ||| grid	count=1
arg	expression expressions are evaluated ||| expr	count=1
class	ground ||| dmp	count=2
function	which returns the interior ||| interior	count=1
arg	[arg_1] m_1 \; ||| clebsch gordan [arg_1] j_2 j_3 [arg_2]	count=1
function	least common integral multiple ||| lcim	count=1
function	a gate identity ||| identity search	count=1
function_arg	quotient of [arg_2] ||| [function_1] ground [arg_2]	count=6
function	is a linear ||| is simple	count=1
arg	of general ||| x y	count=1
module	path to a ||| utilities	count=1
class	of the ||| linear entity	count=1
function	a submodule ||| submodule	count=6
arg	algorithm i e ||| g n y	count=1
function	[function_1] representation of ||| [function_1] [function_2]	count=4
function	hensel lifting [function_2] ||| [function_2] [function_1]	count=6
arg	no bounding rectangles ||| cls	count=1
function	= [function] a1 ||| split [function]	count=1
arg	hypergeometric function target ||| target	count=1
arg	make poly compatible ||| poly	count=1
module	returns ||| domains	count=29
function	the given metric ||| metric	count=2
class	space rotation ||| space	count=1
module	the version of ||| physics quantum	count=1
arg	modulo o(x**prec) ||| x prec	count=2
function	to couple ||| couple	count=1
arg	[arg_1] of two ||| [arg_2] [arg_1]	count=1
function	the integer ||| integer to	count=1
function	instance to ||| to	count=1
arg	function ||| func x x0 y0	count=1
arg	z0 ||| z0 dir	count=1
function	of symbolic ||| create param	count=1
class	a group ||| free group	count=1
function	the name ||| get mod func	count=1
arg	d and d is ||| d	count=1
arg	to the curl ||| vect	count=1
arg	curl ||| vect	count=1
function_arg	[function_1] rule ||| [function_1] [arg_2]	count=1
module	basis in ||| polys agca	count=1
function	the identity homomorphism on ||| identity hom	count=3
function	compute f + a ||| add	count=1
arg	of the specified rank ||| rank superset	count=2
class	ray gives ||| ray	count=1
module	does the ||| physics	count=2
class	returns a tuple ||| basic	count=1
arg	and n is ||| n	count=1
function	orbit of ||| orbit	count=4
class	a ||| sub module poly ring	count=2
module	add the given number ||| utilities	count=1
arg	out ||| compileflags out	count=1
function	full ||| list full	count=1
function	is a groebner basis ||| is groebner	count=1
class	tuples index pos ||| index structure	count=1
function	another fraction ||| from fraction	count=1
arg	canonical form of cls ||| cls	count=1
function	form base ||| as base	count=1
function	a rational [function_2] ||| [function_2] [function_1]	count=1
function	key appearing first omitting ||| padded	count=1
class	[class_1] interval ||| [class_2] [class_1]	count=4
function	rationalize num/den ||| rad rationalize	count=2
function	the gcd of two ||| gf gcd	count=1
arg	dummies ||| dummies sym b_s sgens	count=1
arg	side with length l ||| l	count=1
arg	_factor ||| opt method	count=1
arg	location ||| name location	count=1
function	intersection of 'self' and ||| intersection	count=1
module	self ||| matrices	count=1
function	tensexpr all [function] ||| extract type [function]	count=1
class	keyword 'ch' or 'ldl', ||| sparse	count=1
function_arg	[function_1] [arg_2] ||| physics quantum matrix cache [function_1] [arg_2]	count=1
function	build [function_2] ||| [function_2] [function_1]	count=2
function	wrap ||| wrap	count=1
arg	cheap ||| use_trial use_rho use_pm1	count=1
class	[class] an eigenstate ||| [class]	count=1
module	mechanics ||| mechanics	count=1
function	factor polynomials into irreducibles ||| dmp factor list include	count=1
function	contains the unit ||| unit	count=1
class	input ||| region	count=1
function	all [function] ||| extract type [function]	count=1
function	the real imaginary part ||| real imag	count=1
function	of the cot ||| cot	count=1
function	right coset [function_2] ||| [function_1] [function_2]	count=4
function	new coordsyscartesian with quaternions ||| init	count=1
module_class	gcd of [class_2] ||| [module_1] [class_2]	count=2
function	width of the ||| width	count=1
arg	f if ||| f symbol gens	count=1
function	try to find ||| find	count=1
function_arg	g*h [arg_2] ||| [function_1] [arg_2]	count=14
function	[function_1] list of ||| [function_2] [function_1]	count=3
module	coefficient of ||| polys	count=1
function	of the class ||| mod func	count=1
arg	expr ||| expr series_rs	count=1
arg	compute [arg_1] [arg_2] ||| [arg_1] [arg_2]	count=4
function	the denominator ||| denom	count=1
arg	helper function for ||| method	count=1
function	have initial condition ||| have init cond	count=2
function	with the proper line ||| statement	count=1
arg	and ||| msg key	count=1
arg	add ||| s	count=1
function	a ||| mod	count=2
module	domains ||| domains	count=6
arg	use by ||| s	count=1
function	a copy ||| structure copy	count=1
function	table of self in ||| table	count=1
function	return the class ||| class	count=1
arg	of x ||| x	count=3
function	direct ||| af direct	count=1
class	motion ||| symbolic system	count=1
module	a continuous random ||| stats	count=4
function	terms of ||| as	count=1
arg	the routines ||| routines	count=2
arg	routines in ||| routines f	count=2
arg	actual ||| func	count=1
function	if so would ||| is	count=3
class	this method ||| linear	count=1
arg	a codestring with the ||| codestring	count=1
function_arg	[function_1] f as ||| [function_1] single [arg_2]	count=1
class	quaternion orientation orients ||| quaternion orienter	count=1
arg	of i ||| i	count=1
function	to a scalar return ||| scalar	count=1
function_arg	[function_1] o ||| [function_1] tangent [arg_2]	count=1
function	phrase and if ||| and join	count=1
arg	a text ||| text color align width	count=1
function	mpmath mpf object to ||| real field	count=5
function	the berkowitz algorithm to ||| eval det berkowitz	count=1
module	for ||| logic algorithms	count=1
class	does the same ||| mixin	count=1
function	rational generating function ||| guess generating function	count=2
function	best solution ||| 1st homogeneous coeff best	count=1
function	h ||| strip af	count=1
class	[class_1] transform ||| [class_2] [class_1]	count=1
arg	f in k[x] ||| f	count=2
function	and a ||| and	count=1
module	return the ||| physics quantum	count=2
arg	reasonably intelligent way ||| f_gens g_gens	count=1
class	[class] iteration is ||| [class]	count=3
function	python's fraction to ||| from qq python	count=2
class	code of ||| code	count=1
module	[module_1] [module_2] point ||| [module_1] [module_2] point	count=3
class	initial complex ||| complex	count=1
function	the rank ||| rank	count=2
function	minimal polynomial ||| minpoly op	count=1
class	proper line ||| code printer	count=1
function	gf p [x] ||| dmp gf	count=1
function	undetermined [function_2] ||| [function_1] [function_2]	count=2
function	symbolic values ||| param dict	count=1
module	from the list of ||| physics quantum	count=1
arg	divides p ||| p all_roots	count=1
function	dictionary which expresses ||| map	count=1
arg	of g ||| g	count=3
function	in ||| groebner	count=1
function	[function] for ||| [function]	count=1
class	this sparsematrix ||| sparse	count=1
function	in finite_set in which ||| not empty in	count=1
class	n-dim ||| ndim	count=1
function	power and ||| power	count=1
function	clause to the ||| clause	count=1
function	hyperexponential polynomials ||| hyperexponential polynomial	count=1
arg	(e g 3*pi/2) then ||| cycles	count=1
function_arg	[function_1] [arg_2] ||| [function_1] f m a [arg_2]	count=19
function	cartan matrix of ||| cartan matrix	count=3
class	a standard basis in ||| sub module poly	count=1
arg	or [arg] wrt another ||| [arg]	count=1
function	a row-sorted [function_2] ||| [function_1] [function_2]	count=4
function_arg	[function_1] morphism and ||| [function_1] morphisms [arg_2]	count=1
function_arg	[function_1] n in ||| [arg_2] [function_1]	count=18
function	computes the positional ||| get positional	count=1
arg	the backend function ||| s_ simplify	count=1
module	as subgroup ||| combinatorics	count=1
function	generators of basic stabilizers ||| gens	count=1
function	closed form ||| doit	count=1
function	reconstruct every rational ||| rational reconstruction int	count=3
function	mapping ||| create	count=1
function	tests for independence between ||| independent	count=1
function	one ||| monic	count=1
function	parametric line ||| parametric line	count=1
function	returns maximum norm ||| max norm	count=3
function	dimension of ||| dimension	count=4
class	no bounding ||| of	count=1
function_arg	[function_1] examples ||| [function_1] [arg_2]	count=1
function	[function_1] odd ||| [function_2] [function_1]	count=1
function_arg	sin [arg_2] ||| [function_1] [arg_2]	count=1
arg	controls [arg_2] ||| [arg_1] [arg_2]	count=3
class	frame in ||| reference frame	count=1
class	polynomial expression ||| poly	count=1
module_class	[module_1] [class_2] ||| [module_1] [class_2] element	count=1
function_arg	resultant of [arg_2] ||| [arg_2] [function_1]	count=4
function	the ||| eval cond	count=4
function	parametric [function_2] ||| [function_2] [function_1]	count=4
function	for a pivot ||| pivot	count=1
function	to format an error ||| var count error	count=1
arg	first order differential equations ||| eq func order match	count=1
arg	[arg_1] [arg_2] ||| dup apply pairs [arg_1] [arg_2]	count=3
class	body orientation ||| body	count=1
function	binary coding to gray ||| bin to gray	count=1
function	run ||| run	count=3
function	it is assumed ||| sturm pg	count=1
function	random [function_2] ||| [function_2] [function_1]	count=5
arg	equal to the divergence ||| vect	count=1
class	enumerate the ||| traverser	count=1
arg	variable with a ||| name alpha	count=1
function	diophantine equations ||| zz diophantine	count=1
arg	polynomial p in ||| f p u k	count=1
arg	for medium p ||| p	count=1
function	functional composition ||| compose	count=1
class	the object ||| base	count=1
class	outer [class_2] ||| [class_1] [class_2]	count=2
function	[function_1] raw ||| [function_1] [function_2]	count=1
module_class	of [class_2] ||| [module_1] [class_2]	count=26
arg	k of the ||| k d	count=1
function	[function_1] solvable ||| [function_2] [function_1]	count=1
module_class	of this category ||| categories category	count=1
module	[module] operating point ||| [module]	count=3
function	that is a common ||| common	count=2
function	quadratic ternary diophantine equation ||| ternary quadratic	count=1
arg	u ||| u	count=2
module	path to the module ||| utilities	count=1
function	the logarithm ||| rs log	count=1
class	sequence of polynomials ||| poly	count=1
arg	diagram and ||| diagram grid	count=1
function_arg	[function_1] in k[x] ||| [function_1] [arg_2]	count=30
class	take on a ||| series	count=1
function	num/den by ||| rad	count=1
module	of the ||| calculus	count=1
function_arg	inverse of [arg_2] ||| [arg_2] [function_1]	count=2
function	syms ||| rational	count=1
module	with ||| printing	count=1
arg	a polynomial p ||| p u	count=1
function	power series ||| power series	count=1
class	the linearentity ||| linear	count=1
function	and ||| use	count=1
arg	or equal to n ||| n	count=1
module_class	sparse [class_2] ||| [module_1] sparse [class_2]	count=3
function	negate ||| dmp neg	count=1
class	for ||| function class	count=1
function	[function_1] isomorphism ||| [function_1] [function_2]	count=2
function	lucas compositeness test returns ||| lucas prp	count=1
function	common absolute value of ||| process common	count=1
arg	satisfying the property prop ||| prop base	count=1
function	compute the mellin ||| mellin	count=1
arg	point z0 using ||| z0 dir	count=1
arg	two ||| g	count=11
arg	of this system of ||| x	count=1
class	returns ||| sparse	count=1
module	the initialization of ||| physics	count=1
function_arg	[function_1] a f ||| [arg_2] [function_1]	count=2
function_arg	[function_1] [arg_2] ||| [function_1] l l [arg_2]	count=3
function	cz^2 + dxy + ||| to normal	count=1
function	k[x] [function_2] ||| [function_1] [function_2]	count=1
arg	number ||| m	count=1
function	object excluding ||| free	count=1
class	the proper line ||| printer	count=1
function_arg	x_i**k_i in [arg_2] ||| [arg_2] [function_1]	count=1
function	no ||| complexes	count=1
function_arg	field [arg_2] ||| [function_1] [arg_2]	count=1
arg	f in lex ||| f	count=2
function	2d n-link pendulum on ||| pendulum on	count=1
function_arg	[function_1] in a ||| [function_1] [arg_2]	count=1
arg	a polynomial f in ||| f minpoly	count=1
arg	the base b ||| b	count=3
function	[function_1] of k ||| [function_2] [function_1]	count=2
class	current system into a ||| system	count=1
arg	with [arg] ||| matlist index1 [arg]	count=3
function	state of a ||| state	count=1
function	which ||| empty	count=1
arg	and negative coefficient ||| exprs order	count=1
function_arg	basis specified [arg_2] ||| [function_1] [arg_2]	count=1
class	containers ||| poly ring	count=1
arg	n this is ||| n	count=1
class	the homomorphism ||| homomorphism	count=1
module	polynomials [module] z[x] or ||| [module]	count=1
function	dict representation ||| as dict	count=1
function	bound on polynomial solutions ||| bound	count=1
function_arg	[function_1] enabled ||| [arg_2] [function_1]	count=7
function	take on a specific ||| free	count=1
class	column matrix ||| symbolic	count=1
function	the measure of ||| measure	count=1
module_class	[module_1] medium ||| [module_1] optics [class_2]	count=4
class	until it ||| real	count=1
function	the positional [function_2] ||| [function_1] [function_2]	count=1
function	the underlying undirected ||| undirected	count=1
function	a constant term in ||| constant term	count=1
arg	terms of f ||| f x m n	count=1
module	this method returns ||| series	count=1
function	scan routine used ||| scan	count=1
arg	model or not ||| model deep	count=1
function_arg	[function_1] on gens ||| [arg_2] [function_1]	count=4
arg	[x]/ ||| n	count=1
function_arg	constant term [arg_2] ||| [function_1] p [arg_2]	count=2
function	the hash ||| hashable content	count=1
arg	of operators a global ||| operators	count=1
arg	constructing the ||| j grid morphisms_str_info	count=1
arg	order ||| eq func order	count=9
module_class	[module_1] a qexpr ||| [module_1] [class_2]	count=2
module	those args [module] *are* ||| [module]	count=1
arg	between neighbouring objects come ||| object_coords	count=1
function	which is preferred ||| get preferred	count=1
function	normal ||| normal order	count=1
function	[function_1] lexicographically ordered ||| [function_2] [function_1]	count=6
class	elements ||| permutation	count=1
arg	a polynomial in x_j ||| j	count=1
function_arg	[function_1] in x_j ||| [arg_2] [function_1]	count=3
module	the computational ||| physics quantum	count=2
function	triangle it should be ||| triangle	count=1
function	to generate necklaces that ||| necklaces	count=1
module	the given symbols syms ||| core	count=1
arg	[arg_1] targets and ||| [arg_2] [arg_1]	count=1
function	fourier ||| fourier	count=1
arg	universe ||| universe	count=1
module	to ||| strategies	count=1
function	a dummy associated to ||| dummy	count=1
function	which represents the slope ||| slope	count=1
arg	g function g ||| g	count=1
function	proper ||| statement	count=1
function	the semi-latus [function_2] ||| [function_1] [function_2]	count=1
function	sympy matrix ||| sympy	count=2
function	given geometric entity parallel ||| parallel	count=1
function	converts ||| to	count=5
function	convert [function_2] ||| [function_1] [function_2]	count=3
arg	for internal use by ||| s n	count=1
function	leading degree ||| gf degree	count=1
module_class	[module_1] __abs__ ||| [module_1] [class_2]	count=6
function	central ||| central	count=1
module	is available and ||| printing pretty	count=1
arg	for ||| n x	count=1
function	run ||| run in	count=1
arg	tri to fringe ||| tri welding_edge fringe	count=2
function	the domain ||| empty in	count=1
module	wave travelling in the ||| physics optics	count=1
function	return the class used ||| class	count=1
arg	eq ||| eq y	count=1
function	take [function] wrt ||| [function]	count=1
function	distinct real [function_2] ||| [function_1] [function_2]	count=2
function	loads given to a ||| load	count=1
function_arg	the order [arg_2] ||| [arg_2] [function_1]	count=2
arg	of a ||| a prec	count=1
arg	rs\_sin p [arg_2] ||| [arg_2] [arg_1]	count=2
function	differentiate and evaluate ||| dmp diff eval	count=1
function	the derivation of ||| derivation	count=1
function	convert a to ||| to	count=10
arg	x dx ||| x	count=1
function	integers (n_{1}, n_{2}, ||| power representation	count=1
function	k (so the list ||| list	count=1
arg	model or not ||| expr model deep	count=1
class	of non-conjugate ||| complex root of	count=1
class	by a groebner basis ||| groebner basis	count=1
module	this method ||| series	count=1
class	single [class_2] ||| [class_1] [class_2]	count=1
function	decimal instance to a ||| decimal to	count=1
function	return the leading monomial ||| lm	count=1
function	of a power or ||| pow	count=1
function	[function_1] [function_2] two integers ||| [function_1] [function_2]	count=2
function	heuristic uses the ||| heuristic function sum	count=1
class	composite [class_2] ||| [class_2] [class_1]	count=2
module	without the ||| physics vector	count=1
function_arg	[function_1] f in ||| [function_1] [arg_2]	count=47
function	is linear in ||| is linear	count=2
function	k[x] [function_2] ||| [function_2] [function_1]	count=1
arg	test if ||| randomized	count=1
function	and the ||| mod	count=1
arg	the mul ||| mul	count=1
function	normalized [function] given ||| [function]	count=1
arg	telescopic sum [arg] ||| [arg]	count=3
function	of the atan of ||| rs atan	count=1
class	writes ||| octave code gen	count=2
arg	f 3 ||| f	count=1
arg	a + sign*s ||| a sign	count=2
function_arg	[function_1] by k ||| [function_1] l l [arg_2]	count=1
module	loads ||| logic utilities	count=1
arg	log-normal distribution ||| mean std	count=1
class	ground ||| poly	count=4
function	mapping ||| dict	count=1
arg	return product [arg] ||| [arg]	count=1
class	appear [class] but which ||| [class]	count=1
arg	in ||| expr	count=2
function	[function_1] using ||| [function_1] [function_2]	count=1
module	-> integer -- return ||| core	count=1
arg	encrypt message [arg_1] [arg_2] is a plaintext message ||| [arg_2] [arg_1]	count=1
function	of [function_2] ||| [function_2] [function_1]	count=4
arg	cipher ||| msg key	count=3
arg	additive or multiplicative separation ||| fun sep strategy	count=1
arg	about c i ||| n c	count=1
function	no bounding rectangles ||| complexes	count=1
class	linear entity ||| linear entity	count=3
arg	and sin ||| rv	count=1
function_arg	[function_1] for f ||| [arg_2] [function_1]	count=5
function	for xreplace tracks ||| xreplace	count=1
function	sort generators in ||| sort	count=1
module	vector of this ||| vector	count=3
module	polynomial ||| polys	count=21
function	a loop ||| loop	count=1
function	to x_i**k_i in a ||| dmp inflate	count=1
function	appearing first omitting ||| padded	count=1
arg	a [arg_2] ||| [arg_2] [arg_1]	count=59
function_arg	pseudo-division of [arg_2] ||| [arg_2] [function_1]	count=2
function_arg	square-free norm [arg_2] ||| [function_1] [arg_2]	count=6
arg	[arg_1] true ||| [arg_2] [arg_1]	count=3
arg	[arg_1] and g ||| dup apply pairs [arg_1] [arg_2]	count=3
class	printing of a qexpr ||| qexpr	count=1
function	functions checking function monotonicity ||| monotonicity	count=1
function	with all the implications ||| all	count=1
class	field ||| base vector field	count=2
function	[function_1] dmp_validate ||| [function_1] [function_2]	count=1
arg	of a base and ||| base gens	count=1
arg	f and g ||| f g exps	count=1
arg	t ||| d t	count=1
function	imaginary ||| imag	count=1
module	the bifid cipher ||| crypto	count=1
function_arg	gf [arg_2] ||| [function_1] from dict [arg_2]	count=3
function	part of a ||| part	count=2
function	[function_1] distance between ||| [function_2] [function_1]	count=6
arg	key [arg_2] ||| [arg_1] [arg_2]	count=2
function	one number and is ||| is	count=1
class	permutations in the group ||| group	count=1
module	the truth ||| functions elementary	count=1
function_arg	a_j in ||| tail f	count=1
function	a sign of an ||| sign	count=1
arg	coefficients of f ||| f	count=2
class	gray [class_2] ||| [class_2] [class_1]	count=4
function_arg	true if [arg_2] ||| [function_1] irreducible [arg_2]	count=1
module	a quantum expression ||| quantum	count=1
function_arg	[function_1] if modulus ||| [arg_2] [function_1]	count=1
function	the variables with which ||| variables	count=1
function	third heuristic ||| lie heuristic	count=1
function	mul [function_2] ||| [function_2] [function_1]	count=2
arg	x_0 from ||| u	count=1
arg	x_j of a ||| f m j	count=1
class	no ||| root of	count=2
arg	a [arg_2] ||| core prod [arg_1] [arg_2]	count=1
function_arg	[function_1] [arg_2] squaring ||| [function_1] pow mod [arg_2]	count=1
arg	small'' matrix m ||| deg_f deg_g row1 row2	count=1
function	young's [function_2] ||| [function_2] [function_1]	count=1
function	unicode output is ||| unicode	count=1
function	square the series ||| square	count=1
function	the direction cosine between ||| direction cosine	count=1
class	wrap ||| fcode printer	count=1
function	cosh ||| cosh	count=1
function	[function_1] homomorphism on ||| [function_1] [function_2]	count=7
function	a specific value (i ||| free	count=1
function	form of a finite ||| as finite	count=1
function_arg	leading degree [arg_2] ||| [arg_2] [function_1]	count=3
function	energy ||| energy	count=6
function_arg	number to ||| field k1 a	count=1
function	the index [function_2] ||| [function_2] [function_1]	count=4
function_arg	[function_1] [arg_2] ||| [function_1] sub f g [arg_2]	count=2
function	equation of [function_2] ||| [function_2] [function_1]	count=2
function_arg	[function_1] [arg_2] ||| [function_1] biquadratic f [arg_2]	count=4
arg	second order ||| eq func order	count=1
module	a [module] in ||| [module]	count=1
arg	instance with already-processed args ||| cls args is_commutative	count=1
class	positions of ||| permutation	count=2
function	prime ||| modular	count=1
module	solvers ||| solvers	count=1
arg	convert a fraction ||| k1 a k0	count=1
function	the smallest primitive root ||| primitive root	count=1
function	a zero matrix ||| matrix	count=1
function_arg	multiply tuple [arg_2] ||| [function_1] m [arg_2]	count=4
function	returns the components ||| components	count=2
function	line ending ||| statement	count=1
function	the string path to ||| get mod	count=1
arg	m_{\alpha} z )[x] ||| minpoly p	count=2
function	the transposed sparsematrix of ||| eval transpose	count=1
function_arg	[function_1] [arg_2] ||| [function_1] row [arg_2]	count=3
arg	m_1 ||| m_1	count=1
function_arg	generates the [function_1] [arg_2] a permutation group ||| [function_1] [arg_2]	count=1
function	[function] whose entries ||| eval berkowitz [function]	count=3
function	[function_1] terms ||| [function_1] [function_2] of generators	count=1
function	sparse [function_2] ||| [function_1] [function_2]	count=2
function	reconstruct every ||| reconstruction	count=1
function_arg	whether [arg_2] ||| [function_1] [arg_2]	count=4
function	to ||| sympify	count=1
arg	and y to ||| y	count=1
function	left-open ||| left open	count=1
class	tensor ||| symmetric tensor	count=1
function	symbol corresponding ||| i2symbol	count=1
function	line perpendicular to ||| perpendicular line	count=2
arg	[arg_1] binding power ||| [arg_2] [arg_1]	count=4
class	a specific value (i ||| base	count=1
module	the get_dim method ||| physics	count=1
function	multivariate polynomials ||| dmp gf	count=1
arg	function for the method ||| func order match	count=1
class	piecewise ||| piecewise	count=1
arg	[arg_1] [arg_2] ||| [arg_1] symbols [arg_2]	count=9
arg	compute \frac [arg_1] [arg_2] ||| div [arg_1] [arg_2]	count=4
function	the function is continuous ||| continuous domain	count=1
arg	details ||| f x re g	count=1
arg	for the default geometric ||| parameter	count=3
arg	an accuracy of n ||| n subs maxn chop	count=1
function	ordinary if possible ||| ord	count=1
arg	a polynomial in ||| f p u k	count=1
function	the ground domain ||| dmp	count=2
function	symmetric polynomial of ||| symmetric poly	count=2
arg	[arg_1] s ||| [arg_1] [arg_2]	count=5
arg	[arg_1] > a ||| integrals simplifyconds expr [arg_1] [arg_2]	count=1
function	+ cz^2 ||| normal	count=1
class	helper ||| dense	count=1
function	[function_1] derivative ||| [function_1] [function_2]	count=4
arg	= b m + ||| b a b	count=1
module_class	of the polygon ||| geometry polygon	count=4
class	writes ||| fcode	count=1
arg	[arg_1] point z0 ||| [arg_1] [arg_2]	count=5
function	with the proper line ||| get	count=1
class	tids ||| tids	count=1
function_arg	positive root [arg_2] ||| [arg_2] [function_1]	count=8
module_class	tensor [class_2] ||| [module_1] [class_2]	count=4
function	map y to x**m ||| inflate	count=1
function_arg	a matrix [arg_2] ||| [function_1] [arg_2]	count=1
arg	of a ||| series_rs a	count=1
arg	interval ||| interval symbol	count=3
function	of singularity functions ||| singularity function	count=1
function	inverse mellin [function_2] ||| [function_2] [function_1]	count=2
function	and its value ||| pure	count=1
function	polynomial in ||| poly	count=1
arg	construct ||| rep opt	count=1
function	leverage it if possible ||| try use	count=1
module	returns the energy ||| physics	count=1
arg	x the idea ||| x	count=1
class	a standard ||| sub module poly	count=1
function_arg	vector for [arg_2] ||| [function_1] [arg_2]	count=1
arg	passed by ||| arg k	count=1
module_class	of polynomial generators ||| polys frac field	count=1
arg	solves a first order ||| eq func order	count=2
function	common ending of ||| common suffix	count=2
function	[function_1] a rational ||| [function_1] [function_2]	count=6
function	the domain where a ||| where	count=1
function_arg	different types [arg_2] ||| [arg_2] [function_1]	count=1
function	string path to the ||| func	count=1
function	differential ||| eq	count=2
function	is available and leverage ||| pretty	count=1
class	[class] cartan matrix ||| [class]	count=1
arg	the expression ||| expr	count=3
function	number of ||| count	count=1
arg	[arg_1] j_4 j_5 ||| [arg_1] [arg_2]	count=4
class	the positions of ||| permutation	count=2
function	intrinsic [function_2] ||| [function_1] [function_2]	count=1
arg	g h are ||| g h k	count=4
function	indices corresponding ||| indices	count=2
function	on [function_2] ||| [function_2] [function_1]	count=2
function	partition summing ||| partition	count=1
function	the power series ||| series	count=1
function	real roots of ||| count real roots	count=3
module	a [module] ||| [module]	count=30
function	this function ||| vector	count=1
arg	if e is ||| e	count=1
arg	[arg_1] msg ||| [arg_2] [arg_1]	count=8
function	truth value of ||| eval	count=1
function	return basic [function_2] ||| [function_1] [function_2]	count=3
function	the proper line ||| get statement	count=1
function_arg	[function_1] a ||| [function_1] at [arg_2]	count=3
module	into a string ||| utilities	count=1
function_arg	[function_1] of f ||| polys [function_1] [arg_2]	count=1
function	is of [function_2] ||| [function_2] [function_1]	count=1
function	computes the lexicographic ranking ||| rank lexicographic	count=1
function	loads ||| load	count=2
module	find the ||| combinatorics	count=1
class	isolating interval ||| interval	count=1
function_arg	scalar multiplication [arg_2] ||| [function_1] [arg_2]	count=2
function	indefinite integral ||| integrate	count=3
function	[function_1] ratio ||| [function_1] [function_2]	count=5
function_arg	fraction cf ||| fraction convergents cf	count=1
class	list of ||| frac	count=1
arg	[arg_1] [arg_2] of ||| [arg_1] [arg_2]	count=6
function	module [function] time ||| [function]	count=1
function	rational ||| rational prec	count=2
function	from a dict ||| from dict	count=9
module	satisfiability ||| logic algorithms	count=2
function	delta coefficient ||| big delta coeff	count=1
function	and if symbols ||| and join	count=1
function_arg	a hypergeometric [arg_2] ||| [arg_2] [function_1]	count=1
function_arg	[function_1] other ||| [arg_2] [function_1]	count=9
class	evaluate ||| assoc op	count=1
arg	an expression f ||| f	count=1
class	is ||| expression domain	count=3
arg	of ||| cls	count=2
arg	j_2 m_2 [arg_2] ||| [arg_1] [arg_2]	count=1
function	differential equation with ||| ode	count=1
function	degree ||| find degree	count=1
module	the location where p[i] ||| combinatorics	count=2
function	euclidean distance from ||| distance	count=1
function	operator classes to their ||| to	count=1
function	bivariate integer ||| bivariate	count=1
function	of symbolic values ||| dict	count=1
function	f + [function_2] ||| [function_2] [function_1]	count=5
function_arg	cyclic [arg_2] ||| [arg_2] [function_1]	count=3
arg	switch to ||| native	count=2
function	linear in all ||| linear	count=2
module_class	[module_1] regularpolygon is ||| [module_1] [class_2]	count=8
function	[function_1] mul ||| [function_2] [function_1]	count=3
function_arg	times pi [arg_2] ||| [function_1] coeff arg [arg_2]	count=1
function	a primitive form of ||| primitive	count=1
function_arg	sopform function ||| sopform variables	count=1
function	eigenvalues ||| eigenvals	count=1
function	[function] velocities with ||| [function]	count=3
function	reversion [function_2] ||| [function_2] [function_1]	count=2
module	the position of ||| physics	count=1
function	generators ||| no gens	count=1
function	solution to an ode ||| ode 1st homogeneous	count=1
function	probability ||| probability	count=1
function	anp object to dtype ||| from algebraic	count=2
arg	p k using the ||| p	count=1
class	of representation of associative ||| free group element	count=1
function	lcm over ||| dmp ff lcm	count=2
function	of tensors ||| tensor	count=1
function	the number n ||| n	count=1
function_arg	xor [arg_2] ||| [function_1] [arg_2]	count=1
function	[function_1] bound for ||| [function_1] [function_2]	count=1
function	construct a polynomial ||| poly	count=1
arg	of a ||| a	count=59
module	in pretty ||| printing pretty	count=1
function	objects by distributing ||| tensors from components free dum	count=1
function_arg	[function_1] [arg_2] ||| [function_1] iter a [arg_2]	count=2
arg	given scalar field ||| scalar_field doit	count=1
function	returns refractive [function_2] ||| [function_2] [function_1]	count=1
function	returns the union ||| union	count=1
function	language ||| language	count=1
function	the method of undetermined ||| undetermined	count=1
function	reconstruct a ||| reconstruction	count=1
arg	return the root if ||| root	count=1
arg	of f and g ||| f g k	count=3
function	or ||| q	count=1
arg	the given domain for ||| symbol domain	count=1
function	steps for the ||| steps	count=1
module	none if the ||| core	count=1
function	n ||| n	count=1
class	adds up the coefficients ||| add	count=1
function	[function] of ||| get [function]	count=1
arg	p q ||| p q x method	count=3
function	function for nthroot ||| nthroot	count=1
class	to this linear entity ||| linear entity	count=1
class	of all the sequences ||| seq	count=2
class	generate a ||| free module quotient ring	count=1
function	[function_1] labeled ||| [function_2] [function_1]	count=2
function	transversals relative to ||| transversals	count=1
class	of the matrix ||| matrix	count=2
function	standard ||| standard	count=1
class	grid laid out according ||| grid	count=1
arg	class with hilbert_space and ||| hilbert_space	count=1
function	size of the permutations ||| degree	count=1
function	imaginary part ||| imag	count=2
arg	of msg to the ||| msg	count=1
arg	tensmul object it converts ||| tensmul	count=1
function	convert modularinteger [function_2] ||| [function_2] [function_1]	count=1
arg	a single g ||| x a	count=1
class	the partition is listed ||| partition	count=1
class	on a specific value ||| base	count=1
arg	if modulus is not ||| modulus	count=1
function	the truth ||| eval	count=1
class	standard basis in ||| module poly	count=1
function	is a gate identity ||| identity	count=1
arg	where m is ||| m	count=1
module	string ||| printing	count=7
arg	expression f ||| f	count=1
arg	of non-conjugate ||| cls	count=1
function	[function_1] points for ||| [function_1] [function_2]	count=2
function_arg	[function_1] free ||| [arg_2] [function_1]	count=1
function_arg	[function_1] numbers v ||| [function_1] [arg_2]	count=9
function	morphism the length of ||| length	count=1
module	returns ||| polys domains	count=51
class	represents ||| del	count=1
function	transform of ||| transform	count=6
function	extra ||| extra	count=1
arg	j [arg_2] ||| [arg_1] [arg_2]	count=4
arg	transform of g ||| g x	count=1
arg	solve [arg] n ||| [arg]	count=2
function	cipher decryption ||| decipher	count=1
class	in the ||| series base	count=1
function	adds a force to ||| apply force	count=1
class	location ||| permutation	count=2
function_arg	function prototype [arg_2] ||| [arg_2] [function_1]	count=2
module	this returns the ||| physics quantum	count=4
arg	return the expression to ||| expr	count=1
function	dimensions of each index ||| shape	count=1
function	generators of basic ||| gens	count=1
function	the interior of a ||| interior	count=1
function	wang/eez solve multivariate ||| dmp zz	count=1
module	of the [module] ||| [module]	count=4
function	expansion of the atanh ||| rs atanh	count=1
arg	a parametric representation ||| a	count=1
function	calculates the semi-latus rectum ||| semilatus rectum	count=1
class	generate a ||| free module poly ring	count=1
arg	x_j ||| m j	count=3
module	in a permutation ie ||| combinatorics	count=2
function	performs the affine ||| affine	count=1
function	a constant [function_2] ||| [function_2] [function_1]	count=2
function	first derivative of ||| fdiff	count=1
function	the coefficient of a ||| coeff add	count=3
function	list of indices corresponding ||| indices	count=1
function	primitive polynomial [function_2] ||| [function_1] [function_2]	count=2
function	paths ||| paths	count=1
arg	n ||| n g	count=1
function	uses the mul ||| mul	count=1
function_arg	[function_1] is replaced ||| [function_1] f [arg_2]	count=4
module	a [module] examples ||| [module]	count=2
module	the line and ||| physics	count=1
class	hints ||| integral	count=1
function_arg	series for [arg_2] ||| [function_1] puiseux2 [arg_2]	count=5
arg	p with ||| p	count=3
function	polynomial trace map ||| trace map	count=2
class	values ||| llvmjit	count=1
function	mod ||| sqrt mod	count=2
function	real element object to ||| real field	count=1
function	extended gcd of ||| gcdex	count=5
function	dmf ||| fraction field	count=1
class	if the group ||| group	count=3
class	this segment ||| segment	count=1
arg	get an indexed ||| f index radicals	count=1
function	the substitution [function_2] ||| [function_2] [function_1]	count=1
class	returns the module ||| sub module	count=1
class	related ||| sq	count=1
class	subsset ||| subs	count=1
class	complex ||| complex	count=11
function_arg	of x [arg_2] ||| [function_1] [arg_2]	count=1
arg	and negative coefficient ||| order	count=1
function	hash ||| hash	count=1
function	basic transversals relative to ||| basic transversals	count=1
arg	base [arg_2] ||| [arg_1] [arg_2]	count=1
arg	univariate series expansion of ||| n x prec	count=1
function	in the ||| free	count=1
function	\mathbb{z}_p[x_0 \ldots x_{k-1}] ||| multivariate	count=1
module	pde \frac{d\chi}{dx} + ||| solvers	count=1
function	square-free part of a ||| sqf part	count=2
function_arg	adds [arg_2] ||| [arg_2] [function_1]	count=6
function	- [function] ||| prde [function]	count=1
function	lowering ||| tr7	count=1
function	heuristic ||| dmp qq heu	count=1
arg	of a in ||| a	count=1
function_arg	[function_1] multiplicities ||| [arg_2] [function_1]	count=1
function	rotate ||| rotate	count=2
function	which when printed ||| named	count=1
function_arg	a bernoulli [arg_2] ||| [function_1] name p succ [arg_2]	count=1
function	puiseux [function_2] ||| [function_2] is [function_1]	count=1
function	inequality ||| inequality	count=1
class	the point in ||| point	count=1
module_class	the ray ||| geometry ray	count=2
module_class	[module_1] polyhedron ||| [module_1] [class_2]	count=6
function	a dictionary [function_2] ||| [function_2] [function_1]	count=1
module	bv_{2}) + ||| solvers	count=1
function_arg	[function_1] [arg_2] ||| [function_1] code [arg_2]	count=1
module	which the ||| physics	count=1
function	euclidean [function_2] ||| [function_2] [function_1]	count=1
function	splitting square-free factorization given ||| splitfactor sqf	count=1
function	from gray [function_2] ||| [function_2] [function_1]	count=1
class	series every ||| type	count=1
arg	g parameters ||| g	count=1
function	number ||| field	count=1
arg	private key msg ||| msg key	count=2
function	this method converts ||| to	count=1
arg	multiplicities of factors ||| factors u k	count=1
module	ie the ||| combinatorics	count=2
arg	b r are linear ||| b r	count=1
function	[function] several groups ||| direct [function]	count=1
arg	for simple [arg] 1 2 ||| [arg]	count=1
function	cyclotomic polynomial ||| cyclotomic poly	count=2
function	singularity [function_2] ||| [function_2] [function_1]	count=1
arg	to k[x][y] ||| u k front	count=1
function	clear denominators but keep ||| clear denoms	count=1
function	quaternion [function] ||| orient [function]	count=1
arg	modulus of f ||| f modulus	count=3
function	returns l1 [function_2] ||| [function_2] [function_1]	count=7
arg	return true if a ||| a	count=1
function	in the [function] ||| [function]	count=2
function_arg	inverse cos [arg_2] ||| [arg_2] [function_1]	count=2
arg	factors ||| factors x	count=1
class	the given dummy variables ||| expr	count=1
arg	runs [arg] true if ||| [arg]	count=1
arg	f s [arg_2] ||| [arg_1] [arg_2]	count=3
arg	scalar [arg_2] ||| [arg_2] [arg_1]	count=3
arg	to fringe [arg_2] ||| [arg_2] [arg_1]	count=3
function	a k ||| k	count=1
function	best ||| 1st homogeneous coeff best	count=2
arg	return true if other ||| other	count=1
function	returns the expression as ||| as	count=1
class	given the faces of ||| polyhedron	count=1
module	(real=true) ||| geometry	count=1
function	returns the best ||| best	count=1
function	returns the best ||| homogeneous coeff best	count=1
class	groebner basis ||| groebner basis	count=4
module	get the version ||| physics	count=1
arg	l is ||| l r n limits	count=1
function	a is ||| is	count=1
function	ending of sequences in ||| suffix	count=1
arg	-1 computes floor expr ||| expr	count=1
arg	only func remains ||| func	count=1
function	as [function_2] ||| [function_1] [function_2]	count=3
function	[function_1] and cofactors ||| [function_2] [function_1]	count=8
function	get a root ||| root	count=1
function_arg	the extension [arg_2] ||| [function_1] [arg_2]	count=1
arg	the function f ||| f	count=2
function	z i ] ||| zgate	count=1
function	to simplify ||| simplify	count=1
arg	occuring in expr, given [arg_1] [arg_2] ||| integrals simplifyconds [arg_1] [arg_2]	count=1
arg	f p ||| f	count=1
function	the coefficient ||| coeff monomial	count=1
arg	following -- [arg_2] ||| [arg_2] [arg_1]	count=2
arg	[arg_1] g are ||| [arg_2] [arg_1]	count=1
arg	expression [arg_2] ||| [arg_2] [arg_1]	count=2
function_arg	[function_1] [arg_2] the special case ||| special diop [function_1] [arg_2]	count=1
function_arg	polynomials [arg_2] ||| [arg_2] [function_1]	count=1
function	anp object to ||| algebraic	count=3
function	a wigner semicircle distribution ||| wigner semicircle	count=1
class	tuple of information ||| basic	count=1
module_class	the regularpolygon ||| geometry regular polygon	count=1
class	prufer ||| prufer	count=2
arg	level ||| level args	count=1
function	from binary coding to ||| bin to	count=1
function	python fraction object ||| qq python	count=8
module	particle the ||| physics	count=1
class	scheme ||| scheme	count=1
function_arg	[function_1] function to ||| [arg_2] [function_1]	count=1
function	to values above fermi? ||| above fermi	count=1
function	a finite ||| finite	count=3
arg	f with ||| f	count=2
function	is a unit ||| is	count=1
function	unify a multivariate ||| unify	count=1
module	for a rotation ||| vector	count=1
function_arg	[function_1] dsolve ||| [arg_2] [function_1]	count=1
function_arg	[function_1] a f ||| [function_1] [arg_2]	count=2
function	to have [function] coefficients ||| to [function]	count=1
class	a list of ||| frac	count=1
module	the form ||| series	count=1
arg	s over ||| s x	count=1
class	matrix with elements ||| matrix	count=1
function	and ||| indent	count=1
arg	morphisms [arg_2] ||| [arg_2] [arg_1]	count=9
function	[function_1] superset ||| [function_1] [function_2]	count=2
arg	univariate series expansion of ||| x prec	count=1
function_arg	symbol in [arg_2] ||| [arg_2] [function_1]	count=2
module_class	of the triangle ||| geometry triangle	count=4
function	generator ||| generator	count=1
function	[function_1] lower-hessenberg form ||| [function_1] [function_2]	count=1
function	the trailing coefficient ||| gf tc	count=1
function	in s, ||| indent	count=1
function	[function_1] k[x] ||| [function_2] [function_1]	count=2
function	heuristic uses the following ||| heuristic function sum	count=1
function	add object ||| add	count=1
function	orthogonal ||| orthogonal	count=1
module	form [module] + ||| [module]	count=1
class	dimension ||| type a	count=1
arg	c i e e( ||| n c condition	count=1
function	[function_1] monomials from ||| [function_1] [function_2]	count=3
function	coefficient of a product ||| as coeff mul	count=4
class	of the given dummy ||| expr	count=1
module	return number of ||| core	count=1
function	computes the adjacency ||| get adjacency	count=2
function	function is strictly increasing ||| is strictly increasing	count=1
function	operation on ||| op	count=6
class	exponent ||| exp base	count=1
arg	a in ||| series_rs a	count=1
class	the partition ||| partition	count=1
module	the location ||| combinatorics	count=2
function	leading number is negative ||| coeff isneg	count=1
arg	isolating ||| t eps	count=2
arg	prints a text ||| text color align width	count=1
function_arg	independence between [arg_2] ||| [function_1] [arg_2]	count=4
function	splitting square-free ||| sqf	count=1
function	[function_1] from ||| [function_1] [function_2]	count=8
class	this geometrical entity similar ||| entity	count=1
arg	two polynomials ||| g	count=7
function	the ||| eval	count=4
function	available and ||| pretty try use	count=1
function	presentation ||| presentation	count=1
module	that take on a ||| series	count=1
module	of ||| optics	count=16
arg	if a literal ||| lit cls	count=1
function	existing structure on ||| grow pseudopod	count=1
class	when [class] ||| [class]	count=3
arg	indices are covariant ||| indices	count=1
module	the underlying dimension ||| physics units	count=3
arg	write an expression ||| expr	count=1
function	self [function] ||| [function] scalar	count=1
function	gray code ||| unrank gray	count=1
function	sympy object ||| sympy	count=11
arg	p k using ||| p	count=1
arg	polynomials p q ||| p q x	count=2
class	location where ||| permutation	count=2
arg	a to [arg_2] ||| [arg_1] [arg_2]	count=6
function	no bounding rectangles of ||| refine	count=1
function	point is ||| point	count=1
function	integration of [function] polynomials ||| integrate [function]	count=1
module	(i ||| series	count=1
function	a k [function_2] ||| [function_1] [function_2]	count=1
function	cz^2 + dxy ||| normal	count=1
module	matrix sum of the ||| matrices	count=1
function	pendulum on ||| link pendulum on	count=1
function	polynomial gcd and cofactors ||| inner gcd	count=1
arg	of a polynomial in ||| f	count=4
class	[class_1] series ||| [class_2] [class_1] simple root	count=3
class	other ||| basic	count=1
class	values to ||| llvmjit code	count=1
arg	constructing ||| j grid morphisms_str_info	count=1
function	functions in terms of ||| hyper as	count=1
function	limit of ||| limit	count=1
arg	\mathbb{z}_p[z]/(\check m_{\alpha} ||| p	count=1
function	best solution ||| homogeneous coeff best	count=1
function	n linear ||| linear	count=1
function	slope the elastic ||| slope	count=1
function	a list of indices ||| indices	count=1
class	of the vector ||| type f	count=1
function	a square-free polynomial ||| sqf	count=3
arg	where g ||| g x	count=1
function	be written as g* ||| as	count=1
arg	another ||| other	count=1
arg	uncoupled tensor product of ||| jcoupling_list	count=1
function	minimum power ||| min pow	count=2
module_class	[module_1] data ||| [module_1] [class_2]	count=2
arg	[arg_1] k1 ||| [arg_2] [arg_1]	count=3
arg	[arg_1] beta ||| [arg_1] [arg_2]	count=1
class	location where p[i] > ||| permutation	count=1
arg	start stop ||| func	count=1
function	it if ||| try use	count=1
arg	point center of ||| vec point	count=2
module	and leverage ||| pretty	count=1
module	random variable given ||| stats	count=1
module	polynomials [module] z[x] ||| [module]	count=3
class	printer for ||| tensorflow printer	count=1
arg	in ||| s	count=1
arg	[arg] with terms ||| [arg]	count=1
function_arg	gf [arg_2] ||| [function_1] sqr f [arg_2]	count=2
function	isolate real roots ||| dup isolate real roots	count=3
function	set of equivalent ||| generate equivalent	count=1
arg	multiply [arg] randomly selected ||| [arg]	count=1
function	new ||| init	count=2
module	in ||| series	count=1
function	top nodes first ||| top	count=2
function	and the ||| get mod	count=1
function_arg	functional decomposition [arg_2] ||| [function_1] [arg_2]	count=2
function	helper ||| solve	count=1
function	to format an error ||| count error	count=1
module	full simultaneous exact ||| strategies	count=1
function	about [function] ||| rot [function]	count=3
arg	p x prec ||| p x prec	count=3
class	test if the group ||| permutation group	count=3
function	to its principal branch ||| my principal branch	count=1
function	take [function] wrt to ||| [function]	count=1
arg	x y z ||| x y z a	count=1
arg	small'' ||| deg_f	count=1
arg	create a continuous ||| mu b	count=1
function	c ||| c	count=2
arg	readable object ||| pkgname	count=1
function	logarithmic derivative of ||| log deriv	count=1
class	a ||| field	count=1
arg	[arg_1] could be ||| [arg_1] [arg_2]	count=4
function	with all the ||| deduce all	count=1
arg	modulo p ||| p	count=1
function_arg	key is in dictionary, [function_1] [arg_2] to ||| [function_1] [arg_2]	count=3
class	of symbolic values to ||| llvmjit	count=1
function	get a root of ||| indexed root	count=1
function	gf p ||| gf	count=4
function	finite ||| finite rv	count=1
function	[function_1] decomposition itself ||| [function_1] [function_2]	count=4
function	with the proper ||| get	count=1
arg	changes the point x0 ||| lenics	count=1
arg	func remains in unevaluated ||| func	count=1
function	a [function] ||| [function]	count=8
class	for ||| fcode gen	count=2
arg	d = b ||| b a b	count=1
function	properly normalized examples ||| normalized	count=1
function	_eval_nseries ||| nseries	count=1
arg	i is ||| i	count=2
function	matrix is ||| is	count=1
function	in which the ||| in	count=1
function	the reduced representation ||| trunc	count=1
module	equation ||| solvers	count=11
function	negative coefficient ||| cse	count=1
arg	letters separated by sep ||| sep	count=1
function	rationalize [function_2] ||| [function_2] [function_1]	count=8
class	get the ||| polyhedron	count=1
function_arg	[function_1] in h ||| [function_1] [arg_2]	count=5
class	block with ||| block	count=1
arg	algorithm i ||| g	count=1
arg	always in terms of ||| x	count=1
function	method of undetermined ||| coeff undetermined	count=1
function	test evaluation points ||| test points	count=3
class	rectangular form or the ||| region	count=1
function	these type of ||| linear 2eq order2	count=2
function	is negative ||| is negative	count=2
arg	keys are ||| keys	count=1
arg	add the given number ||| s	count=1
arg	for internal use by ||| s	count=1
function	root [function_2] ||| [function_1] [function_2]	count=2
function	nth root ||| nth root	count=2
module	the list of ||| physics quantum	count=1
class	to this [class] entity ||| [class]	count=1
arg	internal use by ||| s	count=1
arg	2 and n ||| n	count=1
arg	[arg] of a ||| matlist [arg]	count=3
arg	all [arg] ||| expr [arg]	count=2
function	schreier vector for ||| schreier vector	count=1
arg	a column ||| column	count=1
function_arg	the input [arg_2] ||| polys subresultants [function_1] [arg_2]	count=4
function	[function_1] rational ||| [function_2] [function_1]	count=10
function	sum of single g ||| single	count=1
function	the string ||| get	count=1
function	discrete fourier transform as ||| mdft	count=1
function	of the form ||| process	count=1
arg	its attributes to the ||| props add_identities	count=1
function	always destroy a quasi-particle? ||| only	count=1
module	x start stop ||| series	count=1
function_arg	square-free part [arg_2] ||| [function_1] [arg_2]	count=5
arg	x for ||| x	count=1
function	the first defining ||| p1	count=1
module	simultaneous exact ||| strategies	count=1
function_arg	square root [arg_2] ||| [arg_2] [function_1]	count=5
function	generates gegenbauer ||| gegenbauer	count=1
class	a list of polynomial ||| frac field	count=1
function	return the center ||| center	count=1
arg	grid and ||| grid fringe	count=1
arg	not false [arg] < 2^64 ||| [arg]	count=1
function	commutative ||| commutative	count=2
class	standard basis in ||| ring	count=1
class	the object ||| series base	count=1
arg	at the point z0 ||| z0 dir	count=1
arg	\eta to be bi-variate ||| match comp	count=1
arg	and d is not ||| d	count=1
arg	[arg] repeated ||| f n [arg]	count=1
module	tensor with ||| tensor	count=1
function	distinct real roots of ||| real roots	count=1
function	opening statements ||| opening	count=2
function	sorting [function_2] ||| [function_1] [function_2]	count=4
function	from positions from_to to ||| sub	count=1
arg	return an equivalent ||| expr	count=2
class	dyadic in a ||| dyadic	count=1
class	raising shapeerror if ||| matrix arithmetic	count=1
function	the dagger ||| eval adjoint	count=1
function	univariate polynomials in k[x] ||| dup	count=1
function	multivariate series [function_2] ||| [function_1] [function_2]	count=1
arg	expression ||| expr deep	count=1
function	[function_1] code ||| [function_2] [function_1]	count=4
function	positive [function_2] ||| [function_1] [function_2]	count=3
arg	a to the base ||| a	count=3
arg	[arg_1] s over ||| [arg_1] [arg_2]	count=2
function	negate ||| neg	count=4
arg	in ||| f g k	count=2
arg	a in the ||| series_rs a	count=1
function	[function] of ||| get free [function]	count=1
class	helper method for equality ||| immutable dense matrix	count=1
function	get a dict ||| get	count=1
class	integer n in ||| integer	count=1
arg	[arg_1] [arg_2] ||| [arg_1] [arg_2]	count=2612
function	product of ||| product	count=3
function	to a [function_2] ||| [function_1] [function_2]	count=12
arg	pt -- default is ||| pt	count=1
function	parameters and nonhomogeneous euler ||| parameters	count=1
function	truth ||| cond	count=1
class	to evaluate the transform ||| transform	count=1
function	positions of ascents ||| ascents	count=1
module	shift the ||| geometry	count=1
function	of ||| create	count=1
function	for division ||| div	count=2
function	function is [function_2] ||| [function_1] [function_2]	count=11
function	functions ||| empty	count=1
function	from a distributed ||| sdm	count=1
class	the generated ||| octave code	count=1
function	n-link pendulum on ||| link pendulum on	count=1
function	number of space characters ||| indent	count=1
function	merge [function_2] ||| [function_1] [function_2] matmul	count=1
function_arg	order [arg_2] ||| [function_1] [arg_2]	count=2
function	wang/eez [function_2] ||| [function_2] [function_1]	count=4
function	basic orbits relative to ||| basic orbits	count=1
function	[function_1] coefficients using ||| [function_1] [function_2]	count=2
function	see if ||| try use	count=1
function	[function_1] [function_2] ||| [function_1] [function_2]	count=4130
arg	[arg_1] p - ||| [arg_1] [arg_2]	count=1
function	product ||| product mul	count=1
function	of ode ||| order1	count=1
class	system ||| symbolic system	count=1
function	polynomial from [function_2] ||| [function_1] [function_2]	count=1
class	a sparse n-dim array ||| sparse ndim array	count=1
function_arg	index [arg_2] ||| [arg_2] [function_1]	count=3
module	string with mathml code ||| utilities mathml	count=1
function	zero elements examples ||| empty	count=1
function	to a ||| data tensorhead from	count=1
function	functions in ||| not empty	count=1
arg	gen in self ||| gen	count=1
function_arg	[function_1] a transformation ||| [arg_2] [function_1]	count=2
function	a sympy ||| sympy	count=7
arg	e if all args ||| e cond	count=1
function	is negative infinity ||| is	count=1
function	apply the list ||| apply	count=1
class	a ||| permutation	count=2
arg	dummies in the mul ||| mul	count=1
function	[function_1] unit ||| [function_1] [function_2]	count=2
arg	e is a ||| e	count=1
module	the given ||| physics quantum	count=2
function	the string representation ||| str	count=1
function	start of ||| prefix	count=1
function	finite rotation about ||| orient	count=1
function_arg	discriminant of f ||| discriminant f	count=2
class	domain ||| domain	count=5
class	multivariate ||| dmp	count=4
function	assumed ||| sturm amv	count=1
class	p[i] < ||| permutation	count=1
module	of the three parameters ||| physics optics	count=2
function	the function is strictly ||| is strictly	count=2
function	using the gruntz algorithm ||| gruntz	count=1
class	returns a standard basis ||| sub module	count=1
module_class	returns tensor [class_2] ||| [module_1] [class_2]	count=11
arg	fringe and ||| fringe grid	count=2
module_class	of the medium ||| physics optics medium	count=4
arg	about c ||| c	count=1
function	reduced row echelon form ||| rref	count=1
arg	and for ||| a d de	count=1
function_arg	concatenates [arg_2] ||| [function_1] [arg_2]	count=2
function	to an algebraic ||| to algebraic	count=1
function	convert from gray coding ||| gray	count=1
arg	[arg_1] infinitesimals of ||| [arg_2] [arg_1]	count=8
module	along a given vector ||| vector	count=1
class	gmpy's mpz ||| gmpyinteger ring	count=2
arg	displaying [arg] representation's ||| [arg]	count=1
function	is positive infinity ||| is	count=1
function	available and leverage ||| pretty try use	count=1
arg	of polynomials in k[x] ||| u k	count=1
module	optimization opportunities in ||| simplify	count=1
arg	lagrangesmethod lagrangian ||| lagrangian	count=1
function	expression returned by residue_reduce() ||| residue reduce	count=1
module	the quantity as compared [module_1] [module_2] ||| [module_1] [module_2] quantity scale factor	count=1
class	returns the total number ||| type	count=1
class	the ||| octave	count=1
function	for sum ||| sum	count=1
function	second [function_2] ||| [function_1] [function_2]	count=3
function_arg	[function_1] root1 and ||| [arg_2] [function_1]	count=1
function	expand the first ||| expand delta	count=1
function	is that dummies ||| dummies	count=1
function	multinomial coefficient ||| multinomial coefficients	count=2
arg	the point other lies ||| other	count=1
arg	variable with a ||| name k theta	count=1
function_arg	tell whether [arg_2] ||| [function_1] [arg_2]	count=4
arg	irreducibility ||| p k	count=1
function	solve [function_2] ||| [function_1] [function_2]	count=1
class	the polygon ||| polygon	count=1
function	represent this qubits in ||| represent	count=1
function	thus the only ||| singleton	count=1
function	manipulate parts of ||| epath	count=1
class	currently ||| symbol	count=1
function	symbol corresponding to ||| i2symbol	count=1
function	on the top nodes ||| top	count=2
function	is a scalar ||| is scalar	count=3
class	rewrite a finiteset in ||| finite set	count=1
arg	to subtract [arg] make all ||| [arg]	count=1
function	q assuming [function] >>> ||| [function]	count=1
module	from the ||| physics quantum	count=1
function	value ||| eval	count=1
arg	evalf 2 if it [arg_1] [arg_2] are comparable else none ||| core n2 [arg_1] [arg_2]	count=1
function	a prime ||| zz modular	count=1
module_class	[module_1] [class_2] is called complete if ||| [module_1] [class_2]	count=1
module_class	implies __pow__ ||| polys domains domain	count=1
arg	the anti-derivative ||| meijerg risch	count=1
arg	polynomials f g ||| f g	count=1
arg	index1 [arg_2] ||| matrices rowadd [arg_2] [arg_1]	count=1
arg	s , defined ||| s t plane	count=2
function	multiply ||| mul	count=14
module	to perform the ||| physics quantum	count=2
arg	use by the ||| s n	count=1
function	was ||| small	count=1
arg	writer function ||| clear_globs	count=1
function	to a set ||| to surface	count=1
function	with homogeneous [function_2] ||| [function_2] [function_1]	count=5
class	the [class] ||| fact [class]	count=1
arg	1 if k == ||| k	count=1
arg	representation of a polynomial ||| minpoly p	count=1
function	[function_1] if ||| [function_2] [function_1]	count=3
arg	field in a given ||| field coord_sys	count=1
arg	j_3 ||| j_3	count=4
class	composite morphism ||| composite morphism	count=4
class	with ordered free indices ||| tens	count=2
function_arg	first derivative [arg_2] ||| [function_1] [arg_2]	count=1
arg	function ||| func	count=5
function	[function_1] root or ||| [function_2] [function_1]	count=3
arg	as find_pure_symbol but ||| symbols unknown_clauses	count=1
function	the underlying undirected ||| undirected graph	count=1
function	is assumed ||| sturm amv	count=1
function	evaluate the given ||| evalf	count=1
arg	of a polynomial f ||| f	count=1
function_arg	table [arg_2] ||| [function_1] [arg_2]	count=1
arg	triangles to ||| triangles edges	count=1
function	value of ||| cond	count=1
function_arg	[function_1] [arg_2] ||| [function_1] nth root p [arg_2]	count=3
module	the equations ||| physics	count=4
arg	t from ||| t	count=1
function	f - a ||| sub	count=1
function	lexicographic ranking ||| rank lexicographic	count=1
arg	n a ||| n	count=1
function	a row-sorted [function_2] ||| [function_2] [function_1]	count=4
function	leverage it ||| try	count=1
class	generated automatically ||| differential	count=1
function_arg	set [arg_2] ||| [function_1] f [arg_2]	count=2
function	[function_1] matrices pq ||| [function_1] [function_2]	count=1
class	in rectangular form or ||| complex region	count=1
module	the [module] the indices ||| [module]	count=1
class	returns a tensor [class_1] [class_2] ||| [class_2] [class_1]	count=1
class	rational ||| rational	count=2
arg	p q x prec ||| p q x	count=1
function	solve multivariate diophantine equations ||| dmp zz diophantine	count=1
arg	of ||| f x	count=3
arg	x_j = ||| a	count=1
function	gcd and [function_2] ||| [function_2] [function_1]	count=8
function	functional decomposition ||| decompose	count=2
class	for ||| octave code gen	count=2
arg	[arg_1] line in ||| [arg_2] [arg_1]	count=1
arg	are in z[x] ||| x method	count=1
arg	apply f to ||| f atoms nonbasic	count=1
function	the string path to ||| mod func	count=1
function_arg	[function_1] the modulus ||| [arg_2] [function_1]	count=1
module	simple kroneckerdelta ||| concrete	count=1
function	flatten a 1x1 matrix ||| flatten	count=1
function_arg	[function_1] x examples ||| [function_1] p [arg_2]	count=4
arg	convert f ||| f	count=7
arg	[arg] is omitted ||| r [arg]	count=5
function	associated with ||| get	count=4
function	root of x**q = ||| nthroot mod1	count=1
function	helper function ||| solve	count=1
arg	func to ||| func	count=2
class	operator s [class_1] [class_2] of ||| [class_2] [class_1]	count=1
function	path to a ||| get	count=1
function	loop [function_2] ||| [function_2] [function_1]	count=1
function	return square-free ||| sqf	count=4
module	the ||| functions elementary	count=4
arg	tuple derived from f ||| symbols exclude	count=1
function_arg	[function_1] [arg_2] ||| [function_1] f m u [arg_2]	count=1
arg	a composite polynomial ||| cls poly	count=3
arg	is also a ||| root1 root2	count=1
arg	[arg] given ||| condition [arg]	count=1
arg	construct ||| opt	count=2
function	into ||| mod func	count=1
function	the square-free [function_2] ||| [function_1] [function_2]	count=4
function	of code ||| code	count=1
class	and ||| and	count=1
arg	[arg_1] by ||| [arg_1] g [arg_2]	count=6
function	the previous lexicographically ordered ||| prev lexicographic	count=1
function	of two ||| two	count=1
module_class	[module_1] that ||| [module_1] [class_2]	count=1
arg	create a continuous ||| mu	count=2
function	positions of ascents in ||| ascents	count=1
function_arg	convert [arg_2] ||| [arg_2] [function_1]	count=4
module	cipher ||| crypto	count=1
arg	a list of the [arg_1] [arg_2] ||| ntheory digits [arg_1] [arg_2]	count=4
function	x start stop ||| process	count=1
function	[function_1] over ||| [function_2] [function_1]	count=24
function_arg	[function_1] p [x] ||| [function_1] edf zassenhaus f [arg_2]	count=2
arg	in x_0 of ||| m u k	count=1
function	midpoint between self and ||| midpoint	count=1
function	the leading degree ||| dmp degree	count=1
module	the quantity ||| physics	count=1
function_arg	apply a [function_1] [arg_2] ||| [function_1] [arg_2]	count=6
arg	[arg_1] k[x] ||| [arg_2] [arg_1]	count=40
class	[class_1] entity ||| [class_2] [class_1]	count=4
module	in finite_set in ||| calculus	count=1
function	of the ||| get	count=1
function	degree of the ||| degree	count=1
function	always [function_2] ||| [function_1] [function_2]	count=2
function_arg	the triangle [arg_2] ||| [arg_2] [function_1]	count=6
arg	of square-free ||| polys	count=1
function	string path to ||| func	count=2
function	of a single gamma ||| single	count=1
arg	sufficiently small ||| dx	count=1
class	the homomorphism obtained by ||| module homomorphism	count=1
function_arg	[function_1] to two ||| [function_1] f [arg_2]	count=2
module	functions in finite_set ||| calculus	count=1
arg	a base and ||| base	count=3
function	converts a list ||| to	count=2
function	f + g*h where ||| dmp add mul	count=1
function	the minimum power ||| min pow	count=2
arg	base [arg] ||| n [arg]	count=3
arg	return the result ||| s	count=1
function	a common absolute ||| common	count=1
module_class	[module_1] [class_2] ||| [module_1] tens [class_2]	count=1
class	returns a dense matrix ||| matrix	count=1
function	rational generating function for ||| guess generating function	count=1
function	gf p [x] ||| gf	count=5
arg	morphism [arg_2] ||| [arg_2] [arg_1]	count=2
function	[function_1] integer ||| [function_2] [function_1]	count=7
function	arbitrary expression to ||| sympify	count=1
function_arg	multiply dense [arg_2] ||| [arg_2] [function_1]	count=3
module	the inner ||| physics	count=1
function	path to a class ||| get mod func	count=1
arg	[arg_1] in x ||| [arg_2] [arg_1]	count=8
function	of ode are ||| 2eq order1	count=1
arg	specifed ||| bits	count=1
function	and is nonzero ||| is simple	count=2
function_arg	[function_1] [arg_2] ||| [function_1] n [arg_2]	count=12
arg	of an expression ||| expr syms func	count=1
arg	n with coefficients ||| n	count=1
function	the degree of ||| degree	count=2
arg	[arg] of ||| [arg]	count=10
function	superset of ||| superset	count=1
function	number of ||| indent	count=1
function	heuristic ||| heuristic function	count=1
function	cartan matrix for ||| cartan matrix	count=3
function	math ||| math	count=1
function	is a ||| is simple	count=1
function	files default ||| get test files	count=1
function_arg	initialize from [arg_2] ||| [function_1] [arg_2]	count=1
function	x ||| process limits	count=2
function_arg	[function_1] rv ||| [function_1] [arg_2]	count=2
module	return self ||| core	count=2
function	[function_1] all ||| [function_1] [function_2]	count=1
function_arg	extended gcd [arg_2] ||| [arg_2] [function_1]	count=10
function	new coordsyscartesian with ||| init	count=1
class	swap [class_2] ||| [class_2] [class_1]	count=1
function	bottom nodes ||| bottom	count=1
module_class	[module_1] [class_2] ||| [module_1] quantum [class_2]	count=3
arg	and handler a ||| handler	count=1
arg	small'' matrix ||| deg_f	count=1
arg	b + sign*s and ||| b	count=1
arg	and identifier ||| identifier	count=1
function	product of ||| mul	count=3
function_arg	list [arg_2] ||| [function_1] [arg_2]	count=4
arg	in which the finite_set ||| finset_intersection	count=1
function	the set of triangles ||| triangles	count=1
function	the binary ordered ||| binary	count=1
function	z ||| eval commutator zgate	count=2
function	[function_1] maximum ||| [function_2] [function_1]	count=1
function	convert indices [function_2] ||| [function_2] [function_1]	count=4
function	sliding cart ||| cart	count=1
function_arg	symmetric polynomial [arg_2] ||| [arg_2] [function_1]	count=1
arg	with respect to ||| tol a	count=1
arg	out ||| out	count=1
function	zeros matrix for ||| matrix zeros	count=2
function_arg	[function_1] by stringify_expr ||| [arg_2] [function_1]	count=1
function	not-empty ||| empty in	count=1
function_arg	real roots [arg_2] ||| [function_1] [arg_2]	count=11
function	add two ||| add	count=5
arg	beginning of ||| s	count=1
arg	:func rsolve_hypergeometric for details ||| re g	count=1
module	a specific lie algebra ||| liealgebras	count=1
function	set of minterms with ||| pairs	count=1
arg	-1 if [arg] ||| [arg]	count=3
class	a standard ||| sub module	count=1
class	of polar ||| polar lift	count=1
function	power and den ||| power	count=1
function	of irreducible ||| factor	count=2
function	even ||| even	count=2
function	rational generating ||| generating	count=1
function	constants by ||| variable	count=1
function	'self' ||| sympystr	count=1
function_arg	the ideal [arg_2] ||| [function_1] [arg_2]	count=2
arg	range n ||| n	count=1
arg	encrypt message [arg] is a ||| [arg]	count=1
arg	their sum is also ||| root1 root2	count=1
arg	for constructing the string ||| i j grid morphisms_str_info	count=1
function_arg	rotates left [arg_2] ||| [arg_2] [function_1]	count=1
function	roots up to ||| isolate real roots	count=1
function	the third heuristic assumes ||| heuristic	count=1
class	of polynomials or ||| poly ring	count=1
arg	j_3 [arg_2] ||| [arg_1] [arg_2]	count=7
function	or ||| or	count=1
arg	in a rational ||| f g	count=1
class	mutabledensendimarray ||| sparse ndim array	count=1
class	[class_1] [class_2] ||| series [class_2] [class_1] eval	count=1
function	nested tuple ||| to tuple	count=1
function_arg	[function_1] [arg_2] ||| [function_1] cls args [arg_2]	count=1
arg	fundamental strip ||| strip	count=1
arg	are ||| x	count=1
function	subset defined by the ||| subset from	count=1
function	a string path to ||| mod	count=1
function	return function [function] of x ||| func [function]	count=1
arg	if the key ||| key	count=1
function_arg	[function_1] [arg_2] ||| [function_1] coeff arg [arg_2]	count=3
arg	a vector of constants ||| matlist variable constant	count=3
module	[module_1] self by ||| [module_1] [module_2]	count=4
arg	it ||| x	count=1
module	[module_1] computational ||| [module_1] [module_2]	count=2
function	points used to define ||| points	count=1
module	return the ||| combinatorics	count=1
function	returns maximum [function_2] ||| [function_1] [function_2]	count=7
arg	rank [arg] less than ||| [arg]	count=1
function_arg	evaluate a [arg_2] ||| [function_1] ground [arg_2]	count=3
arg	where each [arg] ordered ||| expr [arg]	count=1
class	of this matrix ||| sparse matrix	count=1
arg	fringe and returns false ||| fringe grid	count=1
arg	x**n == a ||| a	count=1
module	[module_1] qubits this ||| [module_1] [module_2]	count=2
function	define the system ||| classify sysode	count=1
function	speed of the ||| speed	count=1
function	function is continuous ||| continuous	count=1
function	coefficient of a ||| as coeff	count=7
function	in "x" ||| calculate	count=1
function	x ||| limits	count=1
function	the derivative of ||| derivative	count=1
arg	polynomial [arg_2] ||| [arg_1] [arg_2]	count=5
function	primitive ||| primitive polynomial	count=2
function	and its ||| pure	count=1
module	rearrange the order ||| physics	count=1
function	from generators of basic ||| gens from	count=1
arg	at x_0 ||| u k	count=1
function_arg	[function_1] a polynomial ||| [function_1] f [arg_2]	count=2
function	to a set ||| to	count=1
function	[function_1] line inside ||| [function_1] [function_2]	count=3
function_arg	core [arg_2] ||| [arg_2] [function_1]	count=3
arg	check if a literal ||| lit cls	count=1
arg	x [arg_2] ||| scale [arg_1] [arg_2]	count=7
function	a monomial order ||| order	count=1
function	return the lower ||| lower	count=1
arg	in k[x] ||| f	count=2
class	the generated ||| fcode gen	count=1
arg	self other ||| other	count=2
function	number ||| count	count=3
function	[function_1] terms of ||| [function_1] [function_2] of generators	count=1
function	in finite_set ||| empty in	count=1
arg	a ||| a	count=185
function	to values below fermi? ||| below fermi	count=1
function	a 2d n-link pendulum ||| n link pendulum	count=1
arg	variable with [arg_2] ||| [arg_1] [arg_2]	count=8
function	positive roots of ||| positive roots	count=2
function	common header for the ||| header	count=2
function	polynomial to dtype ||| from polynomial	count=2
arg	multiplicities of factors ||| factors u	count=1
function	of symbolic ||| dict	count=1
function	the best ||| best	count=1
module	in finite_set ||| calculus	count=1
arg	second order ||| order match	count=1
function	[function_1] hull surrounding ||| [function_2] [function_1]	count=1
module	every [module] ||| [module]	count=6
function_arg	discriminant of [arg_2] ||| [function_1] [arg_2]	count=1
arg	base-2 digits ||| n_bits	count=1
class	point of the sequence ||| seq	count=1
function	be the primitive root ||| primitive root	count=1
function_arg	[function_1] [arg_2] using horner scheme ||| [function_1] [arg_2]	count=1
module	in ||| logic	count=2
class	a standard ||| poly ring	count=1
arg	square-free polynomial f ||| f n	count=1
arg	converts ||| assign_to standard	count=1
function	helper for xreplace tracks ||| xreplace	count=1
module	an expression ||| core	count=1
class	the coordinate variables ||| coord	count=1
module_class	[module_1] [class_2] ||| [module_1] quantum qubit [class_2]	count=1
module	the string path ||| utilities	count=1
arg	in this literal without ||| literal	count=1
function	coefficients of the square-free ||| sqf	count=1
module_class	of this point ||| vector point	count=2
module	interpolating [module] for the ||| [module]	count=1
function	right coset [function_2] ||| [function_2] [function_1]	count=4
function	the leading term ||| lt	count=1
class	is currently at ||| symbol	count=1
arg	func remains ||| func	count=1
module	random expression square ||| stats	count=1
function	polynomial trace [function_2] ||| [function_1] [function_2]	count=1
function	class ||| func	count=2
arg	[arg_1] z of ||| holzer [arg_1] [arg_2]	count=1
arg	opportunities in ||| exprs order	count=1
function	positional ||| get positional	count=1
class	[class] k=v to ||| [class]	count=1
function	generators for ||| gens	count=1
function_arg	quotient of [arg_2] ||| [arg_2] [function_1]	count=17
function_arg	[function_1] modulus of ||| [arg_2] [function_1]	count=1
module	see ||| printing	count=1
module	default on the ||| physics	count=1
module	[module_1] [module_2] point ||| [module_1] [module_2]	count=3
arg	n [arg_2] ||| [arg_1] [arg_2]	count=10
function_arg	[function_1] of i ||| [arg_2] [function_1]	count=2
arg	the value of n ||| n	count=1
function_arg	[function_1] rank rank ||| [function_1] [arg_2]	count=4
function	a 3-tuple a ||| three	count=1
function_arg	from a base ||| from bsgs base	count=2
arg	using vincent-akritas-strzebonski vas continued ||| f k eps inf	count=1
arg	a small'' ||| deg_f deg_g row1 row2	count=1
function	and the ||| mod func	count=1
function	returns wavenumber ||| wavenumber	count=1
module	method ||| series	count=1
arg	divisors which [arg] the divisors ||| [arg]	count=1
function	rational power ||| rational power	count=1
arg	by sep ||| msg sep	count=1
function	transversals relative ||| transversals	count=1
arg	[arg] would hopefully ||| expr [arg]	count=2
arg	the truth value ||| cls	count=1
function	factors ||| include	count=1
module	the position [module_2] ||| [module_1] [module_2]	count=1
function	to a dict ||| dmp to dict	count=3
function	blockmatrix of blockmatrices ||| deblock	count=1
arg	_hastypes to ||| attrs types	count=1
class	make complex isolating intervals ||| complex	count=1
function	superset ||| superset	count=1
function_arg	minimum power [arg_2] ||| [function_1] expr [arg_2]	count=3
function	positions of descents ||| descents	count=1
function	return ||| refine complexes	count=2
arg	x = a in ||| f a	count=1
function	the square-free normal form ||| sqf normal	count=1
function	at an ordinary ||| ordinary	count=1
function	of singularity ||| as singularity	count=1
arg	variable with ||| name mean	count=1
class	[class_1] [class_2] ||| [class_1] [class_2]	count=210
arg	x_j at [arg_2] ||| [arg_2] [arg_1]	count=6
function_arg	[function_1] f by ||| [arg_2] [function_1]	count=6
arg	an expression selected ||| expr func args	count=4
function	path to the module ||| get	count=1
function	maximal degree for ||| max	count=1
function	always ||| is only q annihilator	count=1
function	of gate ||| gate	count=1
function	and leverage ||| use	count=1
function	a common start of ||| common prefix	count=1
function	splitting square-free factorization ||| sqf	count=1
function	shallow copy of ||| copy	count=1
arg	replaced by the function ||| args kwargs	count=1
arg	with respect to n ||| n	count=1
arg	f given a ||| f	count=1
function	coefficient muls ||| opt	count=1
arg	== b**e if n ||| n candidates	count=1
function	leverage ||| pretty	count=1
function	the coefficient of ||| coeff	count=8
arg	z0 using the ||| z0 dir	count=1
function	subset of 'other' ||| subset	count=1
arg	the element elem of ||| elem	count=1
arg	of a diagram ||| diagram	count=1
function	which the ||| empty	count=1
module	proper line ending ||| printing	count=1
function	linear [function_2] ||| [function_1] [function_2]	count=4
function	potential ||| potential	count=3
arg	gf_pow_mod f p g ||| f g	count=1
arg	with respect to z ||| z tol a	count=1
class	[class_1] block ||| [class_1] [class_2]	count=4
function	squares false if it ||| squares	count=1
function	which when ||| uniquely named	count=1
function	matrix to ||| matrix	count=1
function	deductions ||| deductions	count=1
class	of expression ||| expr	count=1
function	generates cyclotomic [function_2] ||| [function_1] [function_2]	count=3
arg	solving first order differential ||| func order match	count=1
function_arg	[function_1] [arg_2] '|') and words by ||| [function_1] [arg_2] mapping	count=3
arg	coding ||| bin_list	count=1
arg	does not [arg] lexicographic order ||| [arg]	count=1
arg	can be used to ||| k zeros	count=1
function_arg	translate function [arg_2] ||| [function_1] [arg_2]	count=2
module	expression ||| polys domains	count=1
class	[class_1] array of ||| [class_1] [class_2]	count=3
function	returns the dual ||| dual	count=1
module	opportunities ||| simplify	count=1
function	of the functions ||| empty in	count=1
arg	a coordsyscartesian ||| vector_names	count=1
function	traversal of a ||| traversal	count=1
arg	[arg_1] op for ||| [arg_1] ops [arg_2]	count=2
function_arg	function to ||| function func	count=1
function	direct [function_2] ||| [function_1] [function_2]	count=1
class	linearentity ||| linear	count=1
class	assumptions ||| symbol	count=2
class	a ||| sub	count=1
function	entities are similar ||| similar	count=1
function	the best solution to ||| coeff best	count=1
class	generated ||| differential	count=1
module	curl [module] field computed ||| physics [module]	count=1
function	it if possible ||| try use	count=1
function	to values above ||| only above	count=1
function_arg	[function_1] polynomial irreducibility ||| [function_1] [arg_2]	count=1
class	number ||| type	count=1
function	series of "e" in ||| series	count=1
class	evaluate the transform ||| integral transform	count=1
class	of a linear ||| linear	count=2
function	rational generating [function_2] ||| [function_1] [function_2]	count=6
function_arg	finding powers [arg_2] ||| [function_1] [arg_2]	count=1
function	+ [function_2] ||| [function_1] [function_2]	count=6
function	the best solution ||| 1st homogeneous coeff best	count=1
function	instance to a rational ||| to rational prec	count=1
arg	if v ||| v	count=1
arg	a to the ||| a	count=3
function	basis is ||| is	count=1
function	with ||| get statement	count=1
function	condition is true ||| condition	count=1
arg	argument passed by ||| cls arg k	count=1
module_class	[module_1] outer ||| [module_1] [class_2]	count=4
arg	function with [arg] algebraic function ||| [arg]	count=1
arg	sin ||| rv	count=1
module	required for [module] this requires ||| [module]	count=1
module_class	qubits this gate ||| quantum gate	count=1
arg	controls targets [arg_2] ||| [arg_1] [arg_2]	count=1
function	the domain ||| domain	count=2
function	quotient ||| dmp quo	count=2
function	apply ||| apply xsl	count=1
function	increment ||| increment	count=1
class	value ||| base	count=1
arg	[arg_1] line in ||| [arg_1] y z [arg_2]	count=1
function	[function_1] base exponent ||| [function_2] [function_1]	count=1
function	the third heuristic assumes ||| heuristic bivariate	count=1
function_arg	[function_1] base and ||| [function_1] [arg_2]	count=3
function	compute [function] where ||| gf [function]	count=1
function_arg	unify representations [arg_2] ||| [function_1] [arg_2]	count=3
function	returns the intersection of ||| intersection	count=1
function_arg	get [arg_2] ||| [arg_2] [function_1]	count=3
arg	old with the ||| old	count=1
module	of symbolic ||| printing	count=1
function	is available ||| use	count=1
function	and the name ||| mod	count=1
module	m, assuming that ||| solvers	count=1
arg	form x start ||| func	count=1
arg	for convenience if reduction ||| cls ai bj	count=1
arg	[arg_1] of f ||| [arg_2] [arg_1]	count=12
function	classes to their ||| operators to state	count=1
function	a partial ||| partial	count=3
function_arg	extension [arg_2] ||| [arg_2] [function_1]	count=1
function_arg	[function_1] p ||| polys [function_1] [arg_2]	count=2
function	gate identity is a ||| is	count=1
function	[function_1] polynomials in ||| [function_2] zz [function_1]	count=1
arg	sin x [arg_2] ||| [arg_1] [arg_2]	count=1
function	permutations ||| permutations	count=1
arg	of a in the ||| series_rs a	count=1
function_arg	[function_1] [arg_2] for ||| [function_1] comm i j [arg_2]	count=4
function	piecewise form examples ||| as piecewise	count=2
function	the right [function] by its ||| [function]	count=1
module	a ||| polys domains	count=1
arg	point other ||| other	count=1
arg	in q[x] ||| f g u k0	count=1
function	of roots ||| roots	count=6
module	the equations of ||| physics	count=4
class	of the sequence ||| seq	count=1
class	return a sparse ||| sparse	count=1
module	unit name ||| units	count=1
function	field associated with ||| get field	count=2
module_class	[module_1] value ||| [module_1] [class_2]	count=2
arg	polynomials in k[x] ||| u k	count=2
function	rewrites a ||| rewrite as heaviside	count=1
function	dummies can be ||| dummies	count=1
arg	n items [arg_2] ||| [arg_2] [arg_1]	count=4
module	tensor indices to ||| tensor	count=2
class	location where p[i] ||| permutation	count=2
function	next binary ordered ||| next binary	count=2
module	entity or infinity if ||| geometry	count=1
function	[function_1] hull surrounding ||| [function_1] [function_2]	count=1
function_arg	inverse sine [arg_2] ||| [function_1] [arg_2]	count=2
function	string ||| str	count=1
function	a transversal for the ||| transversal	count=1
function	list of ||| list	count=9
module	vector [module_2] ||| [module_2] [module_1]	count=1
function	fraction to a rational ||| fraction	count=1
arg	self and b ||| b	count=1
arg	using [arg] ||| expr [arg]	count=1
class	self to an ||| extension	count=1
function	sympy's expression ||| sympy	count=6
module	form the ||| physics	count=1
class	< ||| permutation	count=1
class	of polynomials ||| poly	count=2
arg	and g which are ||| g exps x	count=1
function	returns the number ||| count	count=1
function	two assumptions ||| product	count=1
function	[function_1] [function_2] ||| 2nd [function_1] [function_2]	count=1
function	renumber ||| constant renumber	count=1
function_arg	pseudo-division of f ||| pdiv f	count=2
class	transform ||| root sum	count=1
function	the opening statements of ||| routine opening	count=2
module	in a quantum expression ||| physics quantum	count=1
function	singularity [function_2] ||| [function_1] [function_2]	count=1
function	returns the minimal polynomial ||| minimal polynomial	count=1
function	right coset table of ||| coset table	count=1
function	the multiplication ||| mul	count=1
function	cart ||| cart	count=1
function	heuristic finds if infinitesimals ||| heuristic	count=1
function	sin ||| sin	count=1
function	the closing ||| routine ending	count=1
module	lie algebra examples ||| liealgebras	count=7
arg	variable with ||| name d1	count=1
function	equations which comes under ||| linear 2eq order2 type11	count=1
function_arg	reduced representation [arg_2] ||| [function_1] f [arg_2]	count=1
function	a dummy associated ||| dummy	count=1
function	of a loop ||| loop	count=1
arg	that no ||| cls	count=1
function	returns the exponent ||| exponent	count=1
function	pow of ||| pow	count=1
module_class	[module_1] coordinate ||| [module_1] [class_2]	count=8
function	the function prototype of ||| get prototype	count=2
module	identities from the list ||| physics	count=1
module_class	[module_1] current system ||| [module_1] [class_2]	count=1
function	mapping ||| param dict	count=1
arg	[arg_1] [x] and ||| [arg_2] [arg_1]	count=1
module	it if ||| printing pretty	count=1
function	no bounding ||| refine	count=1
function	returns the conjugate of ||| conjugate	count=1
function	negation normal form ||| nnf	count=1
function_arg	normal [function_1] [arg_2] ordered ||| [function_1] [arg_2]	count=2
arg	the grid adds an ||| grid skeleton	count=1
function	hankel transform ||| hankel transform	count=2
function_arg	[function_1] p ||| [function_1] sub f g [arg_2]	count=1
function	[function_1] univariate ||| [function_1] [function_2]	count=1
function	[function_1] homogeneous ||| [function_1] constant coeff [function_2]	count=1
function	path ||| get mod func	count=2
arg	calculates the ||| iszerofunc	count=1
function	zero morphism ||| zero	count=1
arg	check if g ||| g ring	count=1
class	[class_1] power series ||| [class_1] [class_2]	count=1
function	in integer representation ||| symbol int repr	count=1
function	method converts ||| form to	count=1
class	rectangles of ||| complex	count=1
function	a proper [function_2] ||| [function_1] [function_2]	count=6
function_arg	[function_1] another ||| [function_1] [arg_2]	count=2
function	returns polynomial quotient ||| dmp exquo	count=1
arg	i [arg_2] ||| [arg_2] [arg_1]	count=8
class	mathml ||| math mlprinter	count=1
function	time [function] algorithm that ||| [function]	count=2
class	multivariate polynomials ||| dmp	count=1
arg	two polynomials ||| g k includeprs	count=1
arg	[arg_1] after subtracting ||| scale [arg_1] [arg_2]	count=1
function	supplied [function] ||| [function]	count=3
class	are generated ||| differential	count=1
function	[function_1] list ||| [function_2] [function_1]	count=9
arg	at x_j ||| j	count=1
arg	the writer ||| clear_globs	count=1
function	their ||| rv	count=1
class	a standard ||| poly	count=1
arg	[arg_1] modulo n ||| [arg_2] [arg_1]	count=15
function	the exponent of the ||| exponent	count=1
function	is thus the only ||| is singleton	count=1
arg	in k[x] ||| g u k	count=1
function	create a new line ||| line	count=1
arg	the actual infinitesimals ||| infinitesimals func	count=2
arg	| j_3 ||| j_3	count=1
function	the shape dimensions ||| shape	count=1
arg	possible welds the ||| welding_edge	count=1
arg	denests ||| av0 h max_depth_level	count=1
module_class	[module_1] [class_2] ||| [module_1] ray transfer [class_2]	count=4
function	quadrants from a ||| to quadrants	count=1
arg	sets ||| sets	count=2
function_arg	[function_1] controls targets ||| [arg_2] [function_1]	count=4
arg	a and b, ||| a b	count=32
arg	j_2 ||| j_2	count=4
function_arg	generates [function_1] [arg_2] a permutation group ||| combinatorics [function_1] group [arg_2]	count=1
arg	qubit labels from the ||| target labels	count=1
function_arg	square-free factors [arg_2] ||| [arg_2] [function_1]	count=1
function_arg	subtract dense [arg_2] ||| [function_1] [arg_2]	count=2
function	converts ||| qubit to	count=1
class	j) ||| sparse	count=1
function	operators corresponding [function_2] ||| [function_2] [function_1]	count=2
function	an identity function ||| identity	count=1
function	reduce ||| reduce	count=4
arg	of rank rank over ||| rank	count=1
function	leverage it if possible ||| pretty	count=1
function	codomain replaced by codomain/sm ||| codomain	count=1
class	of matrix ||| block matrix	count=1
function_arg	key is in dictionary, [function_1] [arg_2] to ||| categories diagram [function_1] dict union dictionary [arg_2] value	count=3
function_arg	this is a linear [function_1] [arg_2] order [3] ||| [function_1] nonlex [arg_2]	count=1
arg	algorithm i e ||| g	count=1
class	free group ||| free group	count=2
function	to a fully ||| data tensorhead from tensmul	count=1
function	n-th coefficient ||| dmp nth	count=1
function_arg	when other is ||| coeff mul other	count=1
function_arg	x**(i*p) mod [arg_2] ||| [arg_2] [function_1]	count=6
class	helper method for equality ||| immutable dense	count=1
class	standard ||| sub	count=1
function	an ode is ||| ode	count=1
function	symbolic ||| create param dict	count=1
arg	t , ||| t	count=1
arg	x the ||| x	count=1
arg	[arg_1] of n ||| [arg_2] [arg_1]	count=6
arg	create a continuous ||| mu s	count=1
function	[function_1] over a ||| [function_2] [function_1]	count=24
class	of a matrix ||| mutable dense matrix	count=1
class	and a ||| a	count=1
function	the hilbert ||| eval hilbert	count=1
module	the get_unit method ||| physics units	count=1
function	to an ode from ||| ode 1st homogeneous coeff	count=1
module	this qubits in the ||| physics	count=1
arg	purpose ||| verbose	count=1
function	of distinct real roots ||| dup count real roots	count=1
arg	square-free polynomial f ||| f	count=2
arg	every non-blank line in ||| indent	count=1
arg	transversals and result ||| base orbits transversals	count=1
function	eye and tensor_product ||| matrix eye	count=1
arg	[arg_1] could be ||| [arg_2] [arg_1]	count=4
function	discriminant of ||| discriminant	count=1
function	is ||| debug	count=1
arg	n ||| n m sort	count=1
arg	expression to canonical ||| expr	count=1
function	[function_1] and evaluate ||| [function_2] [function_1]	count=1
function	their coefficient ||| coefficients	count=1
arg	indices of expr and ||| expr	count=1
arg	after subtracting ||| z	count=1
module	that can ||| simplify	count=1
function	[function_1] space ||| [function_1] [function_2]	count=11
function	returns f - g*h ||| sub mul	count=2
arg	in expr ||| expr	count=5
class	a string ||| string	count=1
module	in which the ||| calculus	count=1
function	that ||| auto	count=1
function_arg	[function_1] of two ||| [function_1] biquadratic f [arg_2]	count=1
module	for a rotation type ||| vector	count=1
function	evaluate a polynomial ||| dmp eval	count=1
function	generates symmetric polynomial ||| symmetric poly	count=2
arg	solves ||| eq	count=1
function	a string ||| get mod	count=1
function	disjoint negative root isolation ||| dup inner isolate negative	count=1
function	coset factorization of g ||| coset	count=1
arg	given backend return the ||| backend	count=1
class	of ||| base	count=1
arg	x_j of ||| j	count=1
function	wrapper around ||| power	count=2
arg	q divides p - ||| q p all_roots	count=1
function	according to ||| from indices	count=1
function_arg	[function_1] c ||| [arg_2] [function_1]	count=5
arg	the expression in ||| expr	count=1
function	a square ||| square	count=1
class	default from which docstrings ||| doc	count=1
arg	mixed types [arg] integer ||| [arg]	count=1
module	symbol [module] ||| [module]	count=3
function	using cholesky or ||| eval	count=1
function	compute the dagger of ||| eval adjoint	count=1
class	b_n ||| type b	count=1
function	real univariate inequality ||| univariate inequality	count=1
function	[function_1] orbit of ||| [function_2] [function_1]	count=4
function	morphism the length of ||| morphism length	count=1
arg	encrypt message [arg_1] [arg_2] is a plaintext message ||| crypto encipher elgamal [arg_2] [arg_1]	count=1
function	the "least common multiple" ||| sdm monomial lcm	count=1
arg	sin x [arg_2] ||| [arg_2] [arg_1]	count=1
function	the number of roots ||| roots	count=2
function	to ||| tensorhead from	count=1
class	a sequence ||| poly ring	count=1
function	negative [function_2] ||| [function_2] [function_1]	count=1
module	basis ||| agca	count=1
class	sequence ||| seq expr	count=1
arg	dummies ||| dummies sym	count=1
function_arg	exact quotient [arg_2] ||| [function_1] [arg_2]	count=11
arg	numerical approximations ||| n maxsteps cleanup	count=2
function	solves [function_2] ||| [function_1] [function_2]	count=1
function	polynomial of degree ||| poly	count=5
arg	separated by sep ||| sep	count=1
arg	[arg_1] [arg_2] ||| [arg_2] expr [arg_1]	count=3
module	should be defined by ||| core	count=1
function	from a list ||| list	count=1
class	or ||| expr with	count=1
function	by computing i^e (mod ||| rsa	count=1
function	ode from ||| ode 1st homogeneous	count=1
function_arg	dummy associated [arg_2] ||| [arg_2] [function_1]	count=6
function	all coefficients from ||| all coeffs	count=1
function	the domain of ||| in	count=1
function	expr [function_2] ||| [function_2] [function_1]	count=1
function	represent this qubits ||| represent	count=1
function	generates hermite [function_2] ||| [function_2] [function_1]	count=1
class	sequences ||| seq mul	count=1
arg	quantum number [arg_2] ||| [arg_2] [arg_1]	count=1
class	clauses from the kb ||| kb	count=1
arg	name and format ||| name format	count=1
arg	[arg_1] v ||| [arg_1] [arg_2]	count=3
function	and leverage ||| try	count=1
arg	at x_0 = a ||| a u	count=1
arg	[arg_1] function f ||| [arg_2] x [arg_1]	count=2
function	all terms from ||| all terms	count=2
function	[function_1] semicircle ||| [function_1] [function_2]	count=2
function_arg	[function_1] seq ||| [function_1] [arg_2]	count=1
function	gauss-chebyshev ||| chebyshev t	count=1
arg	triangle and ||| triangle	count=1
class	if the group ||| permutation group	count=3
function	the expand ||| expand	count=2
arg	with already-processed args ||| args is_commutative	count=2
class	of the ||| piecewise	count=1
function	polynomial from a dict ||| from dict	count=1
arg	and o for use ||| o	count=1
function	gate identity ||| random identity search	count=1
function_arg	check a [arg_2] ||| [function_1] [arg_2]	count=2
function_arg	this [arg_2] ||| [arg_2] [function_1]	count=1
class	tail ||| poly element	count=1
function	normal order ||| normal order	count=2
arg	are ||| x method	count=1
class	polygon and values ||| polygon	count=1
function_arg	the multiplication of ||| mul f	count=1
function	merge ||| merge	count=2
arg	p for two ||| p	count=1
arg	2-d point about the ||| th	count=1
function_arg	[function_1] [arg_2] ||| [function_1] depth [arg_2]	count=2
function_arg	vector for alpha ||| vector alpha	count=1
function_arg	[function_1] i ||| [function_1] rsa [arg_2]	count=2
module	a specific value ||| series	count=1
function	[function_1] ending ||| [function_2] [function_1]	count=4
arg	rule to ||| rule	count=1
function	of singularity ||| eval rewrite as singularity	count=1
module	optimization opportunities ||| simplify	count=1
function	quotient by a ||| dmp quo	count=1
arg	a certain coordinate ||| point1 point2	count=1
module	the quantity as compared [module_1] [module_2] ||| [module_1] [module_2]	count=1
function	are disjoint examples ||| disjoint	count=1
arg	no bounding rectangles of ||| cls	count=1
function	[function_1] a function ||| [function_1] [function_2]	count=1
function	apply ||| call	count=1
class	a ||| sub module	count=1
arg	ax = ||| freevar	count=1
arg	[arg_1] log-normal distribution ||| [arg_1] [arg_2]	count=1
class	inverse ||| single discrete distribution	count=1
arg	_hastypes to expr ||| expr attrs types	count=3
arg	[arg_1] [x] ||| [arg_1] [arg_2]	count=16
arg	given position ||| name position	count=1
arg	for x**n == a ||| a n p	count=1
class	gray [class_2] ||| [class_1] [class_2]	count=4
function	[function_1] are ||| [function_2] [function_1]	count=14
function_arg	[function_1] of two ||| [function_1] f [arg_2]	count=1
arg	function ||| func x	count=1
arg	e if all ||| e cond	count=1
arg	to a base and ||| base gens	count=1
arg	model or not ||| model	count=1
function	identifier ||| get resource	count=1
module	the type ||| physics	count=1
function	always destroy a quasi-particle? ||| is only q annihilator	count=1
function	split a symbol ||| split	count=1
function	two ||| mul	count=1
function	of operators corresponding to ||| state to operators	count=1
function	an ode from the ||| ode	count=1
class	a sequence of polynomials ||| poly ring	count=1
arg	partion of seq ||| seq	count=1
arg	subgroup ||| strategy	count=1
function	devise a ||| devise	count=1
class	morphisms [class] their properties ||| [class]	count=1
arg	as a single ||| x a	count=1
function	attained by other, where ||| gt	count=1
function	log hint see the ||| log	count=1
arg	of f in k[x] ||| f u k	count=2
class	returns a ||| sub module poly ring	count=1
function	matrix representation this function ||| matrix	count=1
function	function [function] of ||| func [function]	count=1
function	over algebraic number fields ||| ext	count=1
function	the form x ||| process limits	count=1
function_arg	[function_1] field in ||| [function_1] [arg_2]	count=4
function	is a linear ||| is	count=1
arg	of f in k[x], ||| f u k	count=1
function	the atan ||| rs atan	count=1
class	containers of ||| ring	count=1
function_arg	[function_1] [arg_2] the ||| [function_1] [arg_2]	count=20
arg	continuous ||| mu k	count=1
arg	dum [arg_2] ||| [arg_2] [arg_1]	count=1
function	an ode from the ||| ode 1st homogeneous coeff	count=1
arg	morphisms of [arg_2] ||| [arg_2] [arg_1]	count=9
function_arg	other, where other ||| gt other	count=2
function	return the order of ||| order	count=1
arg	directed ||| directed	count=1
function	[function_1] condition ||| [function_2] [function_1]	count=1
arg	expression e [arg_2] ||| [arg_2] [arg_1]	count=3
arg	in x_0 ||| m u k	count=1
function	[function] indices of ||| get [function]	count=3
function	[function_1] function ||| [function_1] [function_2]	count=8
function_arg	sequence in [arg_2] ||| [function_1] i [arg_2]	count=1
function	the minimum [function_2] ||| [function_1] [function_2]	count=2
arg	[arg_1] j parameters ||| [arg_2] [arg_1]	count=1
arg	not in superset ||| superset	count=1
arg	alpha ||| alpha	count=6
function	degree of the poly ||| degree	count=1
function_arg	inverse function ||| inverse argindex	count=1
class	self accumulationbounds object is ||| accumulation bounds	count=2
function_arg	gate with [arg_2] ||| [arg_2] [function_1]	count=4
function	returns the condition ||| cond	count=1
module	the inverse of matrix_to_qubit ||| physics	count=1
function	generating [function_2] ||| [function_2] [function_1]	count=6
function	parse ||| parse	count=1
arg	the purpose ||| verbose	count=1
function	of undetermined [function_2] ||| [function_1] [function_2]	count=1
function	of this dyadicmul ||| measure number	count=1
function	bessel-type functions ||| besselsimp	count=1
function	indices ||| indices	count=8
arg	cond ||| cond	count=1
class	standard basis ||| sub	count=1
function	of a loop ||| process loop	count=1
function_arg	[function_1] lhs - ||| [function_1] [arg_2]	count=1
function	returns a row-sorted ||| row	count=1
function	is primitive ||| is primitive	count=2
arg	[arg_1] log-normal ||| [arg_1] [arg_2]	count=1
arg	[arg_1] by g ||| [arg_1] [arg_2]	count=6
class	dyadic ||| dyadic	count=6
class	turn an iterable ||| generalized polynomial ring	count=1
arg	sympy expression ||| expr callback_type	count=1
function	of symbolic values ||| create	count=1
function	roots of a list ||| roots list	count=1
module	return the truth value ||| elementary	count=1
function	is not-empty ||| not	count=1
function	build ||| build product	count=1
function	initialize ||| init	count=6
function	isomorphism using pslq algorithm ||| isomorphism pslq	count=1
module	value ||| functions elementary	count=2
function	function [function] of x ||| func [function]	count=1
arg	tests returning ||| sort timeout slow enhance_asserts	count=1
arg	f s [arg_2] ||| [arg_2] [arg_1]	count=3
arg	subcircuit [arg] if ||| [arg] subcircuit replace	count=1
function	an erlang ||| erlang	count=1
function_arg	the logarithm [arg_2] ||| [function_1] [arg_2]	count=2
function	[function_1] quasi-particle? ||| [function_2] [function_1]	count=1
arg	coefficient dictionary ||| coeff	count=1
arg	of f given ||| f m	count=1
function	square dense polynomials ||| dmp sqr	count=1
class	fortran ||| fcode	count=2
arg	m_1 \; [arg_2] ||| [arg_2] j_3 [arg_1]	count=3
function	[function_1] the denominator ||| [function_1] [function_2]	count=1
arg	[arg_1] n is ||| [arg_2] [arg_1]	count=2
function	to values above fermi? ||| only above fermi	count=1
function	of real ||| count real	count=1
function	sum of k ||| do sum of	count=2
function	bottom nodes first ||| bottom up	count=1
arg	a polynomial p ||| p	count=1
arg	polynomial in k[x] ||| f m u k	count=1
function_arg	matrix [arg_2] ||| [arg_2] [function_1]	count=2
arg	new value of key ||| key	count=1
arg	at point pt ||| pt	count=1
function	in which ||| not empty	count=1
function	gmpy [function_2] ||| [function_2] [function_1]	count=38
arg	two integers [arg] ||| [arg]	count=1
module	sequence of polynomials or ||| polys	count=1
function_arg	[function_1] expansion ||| [function_1] nth root p [arg_2]	count=1
arg	is the other ||| other	count=1
function	sdm from [function_2] ||| [function_2] [function_1]	count=1
class	basis ||| module poly ring	count=2
function	[function_1] energy ||| [function_2] [function_1]	count=4
function	bubble [function] ||| gate [function]	count=2
arg	g ||| g	count=38
function	l1 [function_2] ||| [function_2] [function_1]	count=7
function	the next [function] taylor series ||| taylor [function]	count=1
class	expansion of the function ||| holonomic function	count=1
arg	a single g function ||| a b	count=1
arg	[arg_1] b ||| [arg_1] a [arg_2]	count=1
class	roots ||| root	count=2
function	defined [function] starting ||| assoc [function]	count=1
function	is the zero ||| is zero	count=6
class	kb examples ||| prop kb	count=1
class	sequence of polynomials ||| ring	count=1
arg	of [arg] in base ||| [arg]	count=1
arg	and the object ||| grid	count=1
function	domain of the ||| empty	count=1
class	no ||| complex	count=1
function	measure on ||| measure	count=1
function	a bernoulli ||| bernoulli	count=1
function_arg	extract from a tensexpr [function_1] [arg_2] ||| [function_1] [arg_2]	count=1
arg	limit or cheap ||| limit use_trial use_rho use_pm1	count=1
function	[function_1] if so ||| [function_2] [function_1]	count=3
class	group ||| free group	count=1
arg	degree d [arg_2] ||| [arg_1] [arg_2]	count=2
class	values of the lagrange ||| lagranges	count=1
function	and ||| opt	count=1
function	[function_1] whole ring ||| [function_1] [function_2]	count=1
function	matrix/complex number to a ||| to	count=1
function	factors of ||| include	count=1
module	component tensor ||| tensor	count=1
arg	[arg_1] [arg_2] squaring ||| pow mod [arg_2] [arg_1]	count=1
function	unit_propagate but arguments ||| propagate	count=1
arg	p2 )/lm p2 ||| p2	count=1
module	special case [module] cf algorithm ||| [module]	count=1
arg	[arg] are ||| [arg]	count=4
function	of ||| mod func	count=1
arg	ex1 [arg_2] ||| [arg_2] [arg_1]	count=1
module	the dual ||| physics	count=1
function	constant term in ||| get constant term	count=2
arg	polynomial irreducibility test over ||| f p k	count=1
function	interior ||| interior	count=1
function_arg	multiply f ||| mul term f	count=1
function	transposed sparsematrix of ||| eval transpose	count=1
class	returns a ||| ring	count=1
class	converts mutabledensendimarray to matrix ||| dense ndim	count=1
function	rational number ||| integer rational	count=1
module_class	of the subset ||| combinatorics subset	count=3
function	property where the ||| property	count=1
module	multiplies the ||| physics	count=1
function	undetermined ||| coeff undetermined	count=1
function_arg	coset rank [arg_2] ||| [arg_2] [function_1]	count=3
function	list ||| list include	count=2
class	are ||| extension	count=1
arg	base and strong generating ||| group base gens	count=1
function	norm ||| norm	count=11
function	returns minimal degree for ||| min	count=1
function	this heuristic uses ||| lie heuristic	count=1
function	basis for ||| basis	count=1
module_class	[module_1] point in ||| [class_2] [module_1]	count=3
module	[module_1] state ||| [module_1] [module_2]	count=10
arg	permutations of n items ||| n	count=1
arg	f [arg_2] ||| [arg_1] g [arg_2]	count=3
function	[function_1] a k ||| [function_2] [function_1]	count=3
module_class	[module_1] fraction ||| [module_1] [class_2]	count=2
arg	an indexed root of ||| f x index radicals	count=1
module	-- return ||| core	count=1
arg	key ||| key	count=17
function_arg	[function_1] [arg_2] a permutation group ||| [function_1] [arg_2]	count=1
class	linear entity which passes ||| linear entity	count=1
arg	a single symbol ||| a b w	count=1
class	coefficients ||| dmp	count=2
function	expression ||| for cse	count=1
arg	satisfying the property prop ||| prop base strong_gens	count=1
function	incircle ||| incircle	count=1
function_arg	dense [arg_2] ||| [function_1] mul [arg_2]	count=2
arg	is a model or ||| model deep	count=1
function	small ||| small	count=1
arg	a condition is true ||| condition given_condition	count=1
function_arg	[function_1] of p ||| [function_1] [arg_2]	count=9
arg	replaced by the ||| args kwargs	count=1
function_arg	[function_1] [arg_2] is the plaintext ||| crypto encipher [function_1] [arg_2]	count=1
function	above fermi? ||| above fermi	count=1
class	excluding those that take ||| base	count=1
function	in ||| indent	count=1
function	any evalf of ||| eval evalf	count=1
function	latex ||| latex	count=1
function	polynomial gcd [function_2] ||| [function_2] [function_1]	count=12
function_arg	[function_1] [arg_2] ||| [function_1] p [arg_2]	count=16
function	scale the function by ||| scale	count=1
function	free ||| free	count=10
function	optimization opportunities ||| opt	count=1
function_arg	remove [arg_2] ||| [function_1] dumx [arg_2]	count=1
function	implementation of domain ||| domain	count=1
function	of n linear ||| linear	count=1
function_arg	[function_1] [arg_2] ||| [function_1] op [arg_2]	count=2
function_arg	[function_1] instance from ||| [arg_2] [function_1]	count=4
arg	bound [arg_2] ||| [arg_1] [arg_2]	count=1
arg	the string s ||| s	count=1
function	the next [function] ||| taylor [function]	count=2
function	[function_1] and beta ||| [function_2] [function_1]	count=1
class	with ||| homomorphism	count=1
function_arg	[function_1] [arg_2] whose squares are rationals ||| [function_1] surds [arg_2]	count=1
arg	for the real inverse_mellin_transform ||| s x_ strip	count=1
arg	rank rank over ||| rank	count=1
function_arg	[function_1] in q[x] ||| [arg_2] [function_1]	count=3
module	tokens ||| parsing	count=1
class	is ||| sub quotient module	count=1
function	of e ||| e	count=1
class	a ||| fcode	count=1
function	to the module and ||| mod	count=1
function_arg	test [arg_2] ||| geometry linear entity span [function_1] [arg_2]	count=2
arg	f ||| f c i	count=1
arg	point ||| point	count=1
arg	bound [arg_2] ||| [arg_2] [arg_1]	count=1
function	a proper [function_2] ||| [function_2] [function_1]	count=6
function	the gcd of two ||| gcd	count=1
class	a standard basis in ||| sub module poly ring	count=1
function	returns the number of ||| count	count=1
arg	true if two ||| other	count=6
arg	= a [arg_2] ||| [arg_2] [arg_1]	count=8
function	negative coefficient muls ||| cse	count=1
function	a von [function_2] ||| [function_2] [function_1]	count=2
function	[function_1] zero matrix ||| [function_2] [function_1]	count=1
function_arg	operators ops ||| operators obj ops	count=1
arg	g ||| g x	count=4
function	orients the new coordsyscartesian ||| init	count=1
function	[function_1] t ||| [function_2] [function_1]	count=6
arg	a first order ||| eq func order	count=2
function	[function_1] index ||| [function_1] [function_2]	count=2
arg	target_matrix ||| target_matrix nqubits	count=1
arg	old -> ||| old	count=1
function	string path to a ||| func	count=1
function_arg	by other, [arg_2] ||| [function_1] [arg_2]	count=2
class	code and ||| code	count=1
arg	[arg_1] z ||| [arg_2] [arg_1]	count=7
arg	beta x gives the ||| x	count=1
function	to whether ||| signature from indices	count=1
function	factors of self that ||| factors	count=1
arg	f defined as ||| f k r nu	count=1
class	sparsematrix ||| matrix	count=1
function_arg	[function_1] polynomial f ||| [function_1] [arg_2]	count=5
function	extra strong [function_2] ||| [function_1] [function_2]	count=3
function	intersection of a collection ||| intersection	count=1
function	list of ||| from list	count=1
module	generate a ||| agca	count=2
function	computes the sturm sequence ||| sturm	count=2
class	knowledge base ||| kb	count=1
arg	system of ||| x	count=1
module	to the beginning ||| utilities	count=1
function	orbits of ||| orbits	count=1
function	function for [function_2] ||| [function_2] [function_1]	count=1
module	arguments are expected to ||| logic algorithms	count=3
arg	in otherframe ||| otherframe	count=1
function	thus ||| singleton	count=1
arg	common subexpression elimination to ||| optimizations	count=1
function	recursively strip it ||| validate	count=1
function	object from ||| from	count=1
arg	and apply func to ||| func	count=1
arg	in base [arg] ||| n [arg]	count=3
function	[function_1] given function ||| [function_2] [function_1]	count=1
function	of real ||| real	count=1
arg	= a int_0^oo ||| a	count=1
function_arg	[function_1] where other ||| [arg_2] [function_1]	count=8
function	used to switch to ||| to	count=1
arg	[arg] of the ||| [arg]	count=8
function	the triangle ||| weld triangle	count=1
arg	polynomial in k[x] ||| u	count=1
arg	in superset ||| superset	count=1
function	exact quotient by a ||| exquo	count=2
class	of ||| root of	count=2
module	finds the ||| calculus	count=1
function_arg	[function_1] indices are ||| [arg_2] [function_1]	count=2
arg	[arg_1] ex1 ||| [arg_1] [arg_2]	count=1
module	of the ||| series	count=1
arg	split arg into ||| arg	count=1
arg	where f ||| f	count=4
class	the c series ||| type c	count=1
class	the patterns ||| matrix	count=1
arg	meijer g [arg] parameters ||| [arg]	count=1
class	atoms ||| basic	count=1
function	[function_1] multiplication ||| [function_2] [function_1]	count=2
function	the derivative ||| diff	count=2
function	[function_1] heuristic finds ||| [function_2] [function_1]	count=1
module	for printing ||| printing	count=1
function	[function_1] order of ||| [function_1] [function_2]	count=1
function	python's [function_2] ||| [function_2] [function_1]	count=8
arg	base and strong ||| base gens	count=1
arg	tell whether [arg] ||| [arg]	count=2
function_arg	[function_1] euler eq ||| [function_1] [arg_2]	count=2
function	format them accordingly ||| format	count=1
module	being the two class ||| combinatorics	count=1
function	that form the sides ||| sides	count=1
function	atanh of p, ||| rs atanh	count=1
function	tangent ||| tangent	count=1
class	mapping of symbolic values ||| llvmjit	count=1
function	multivariate [function_2] ||| [function_2] [function_1]	count=5
arg	function for ||| method	count=1
function_arg	[function_1] v ||| [arg_2] [function_1]	count=8
arg	tensmul object ||| tensmul	count=1
function	ode are ||| 2eq order1 type5	count=1
module	equation that ||| solvers	count=1
function	generates cyclotomic ||| cyclotomic	count=1
function	to x_i**k_i ||| inflate	count=1
function	ternary diophantine equation ||| ternary	count=1
function	to the module and ||| get	count=1
arg	m_1 m_2 m_3) ||| m_1	count=1
function	the sturm sequence ||| dup sturm	count=1
arg	[arg_1] in symbols ||| [arg_2] [arg_1]	count=2
arg	ring provided p is ||| p	count=1
function	from [function_2] ||| [function_1] [function_2]	count=7
arg	of this system of ||| x y	count=1
module	characters to the beginning ||| utilities	count=1
function	[function_1] primitive ||| [function_1] [function_2]	count=1
function	into free, dum ||| dum	count=1
function	focus ||| focus	count=1
function_arg	the element x ||| element x	count=1
function	correct the ||| correct signature	count=1
function	[function_1] hash ||| [function_1] [function_2]	count=5
function	tensor product ||| tensor product	count=4
function_arg	[function_1] of square-free ||| [function_1] [arg_2]	count=6
class	the total ||| type g	count=1
arg	if expr is ||| expr assumptions	count=1
arg	n ||| n l	count=1
class	return the ||| piecewise	count=1
function	error ||| error	count=1
arg	zero to infinity g1*g2 ||| g1 g2	count=1
function	the series expansion of ||| rs	count=1
arg	to x note ||| x	count=1
function	letter representation of ||| letter form	count=2
arg	try to integrate f ||| f	count=1
function	iterable ||| iterable	count=2
function	[function_1] rational ||| [function_1] [function_2]	count=6
arg	to a second order ||| func order	count=1
function	[function_1] sympy expression ||| [function_1] [function_2]	count=1
function	split ||| split	count=4
arg	is simple [arg] ||| expr [arg]	count=1
class	self to an initial ||| extension	count=1
arg	a lexical closure to ||| name latexname	count=1
function	[function_1] increasing ||| [function_2] [function_1]	count=5
function	octave or matlab code ||| octave code	count=1
class	coordinate variables ||| coord	count=1
arg	n ||| factors n	count=1
class	[class_1] method ||| [class_2] [class_1]	count=1
function	the domain of the ||| not empty	count=1
function	to [function] between the ||| set dict [function]	count=1
function	polynomial from ||| poly from	count=4
arg	compute \frac [arg_1] [arg_2] ||| [arg_1] [arg_2]	count=4
function	a continuous ||| continuous rv	count=1
function_arg	generated [arg_2] ||| [arg_2] [function_1]	count=1
function	a dict ||| dict	count=8
function	push ||| push	count=2
function	[function_1] repeated ||| [function_1] [function_2] inds	count=1
function	always destroy a quasi-particle? ||| is only	count=1
arg	[arg_1] token same ||| [arg_1] [arg_2]	count=3
function	initialize [function_2] ||| [function_2] pr [function_1]	count=1
function	[function_1] the whole ||| [function_2] [function_1]	count=1
module	finds the ||| physics	count=1
function_arg	[function_1] field ||| [arg_2] [function_1]	count=8
function	[function_1] root ||| [function_1] [function_2]	count=13
function	a free [function_2] ||| [function_1] [function_2]	count=2
function_arg	[function_1] and ||| [function_1] diagram [arg_2]	count=1
function	find ||| find reasonable	count=1
class	this method returns ||| series base	count=1
function	cartan matrix of a ||| cartan matrix	count=1
arg	[arg] make ||| [arg]	count=1
function	solves [function_2] ||| [function_2] [function_1]	count=1
function_arg	[function_1] expr ||| [arg_2] [function_1]	count=4
module	the loggamma function ||| functions special	count=2
module	the variables ||| physics	count=1
class	creation for octave ||| octave	count=1
module	the get_dim method ||| physics units	count=1
function	generates gegenbauer [function_2] ||| [function_2] [function_1]	count=1
class	a single ||| var	count=1
function	real univariate [function_2] ||| [function_2] [function_1]	count=1
arg	lex ||| order	count=1
function	below [function_2] ||| [function_2] [function_1]	count=4
class	for the generated ||| octave	count=1
function	[function_1] fraction decomposition ||| [function_1] [function_2]	count=1
module	check if the ||| physics units	count=1
function	[function_1] one ||| [function_1] [function_2]	count=2
function	name of the ||| mod func	count=1
function_arg	whether e and ||| is expr e	count=1
arg	growing the grid and ||| grid fringe	count=1
module_class	[module_1] n-dim ||| [module_1] sparse [class_2]	count=1
function	row-sorted list of ||| row list	count=2
arg	[arg] default 14 ||| n [arg]	count=3
arg	and nonhomogeneous euler eq ||| eq	count=1
function	constant ||| constant coeff	count=1
function	base of the ||| base	count=1
module	[module_1] mathml ||| [module_1] [module_2]	count=2
module	the given operator or ||| physics quantum	count=1
arg	the list range n ||| n	count=1
arg	condition ||| cond	count=1
arg	of alpha as a ||| degree generators alpha	count=1
function	of square-free [function_2] ||| [function_2] [function_1]	count=2
function	to find ||| to	count=1
function	polynomial of ||| polynomial	count=1
function	factor polynomials [function_2] ||| [function_2] [function_1]	count=1
function	[function_1] a dict ||| [function_2] [function_1]	count=8
arg	stored in storage ||| storage	count=1
function	partial fraction decomposition algorithm ||| decomposition	count=1
module_class	[module_1] [class_2] ||| [module_1] [class_2]	count=610
function	the exponent of ||| exponent	count=1
function_arg	space [arg_2] ||| [arg_2] [function_1]	count=3
function	register a handler ||| register handler	count=1
class	of g_2" ||| type	count=1
function_arg	maximum norm [arg_2] ||| [arg_2] [function_1]	count=3
function	a finite [function_2] ||| [function_2] [function_1]	count=1
function	new copy of ||| copy	count=1
module	whether the ||| combinatorics	count=1
arg	s as a ||| s	count=1
module	to an ||| core	count=1
function_arg	to [function_1] [arg_2] ||| [function_1] [arg_2]	count=8
arg	from ||| result	count=1
module	the annihilation operators ||| physics	count=1
arg	subtracting pt -- default ||| z pt	count=1
function_arg	gf [arg_2] ||| [function_1] factor sqf f [arg_2]	count=2
function	name of ||| func	count=1
class	a new referenceframe ||| reference	count=1
function_arg	[function_1] qubit ||| [function_1] matrix [arg_2] format	count=1
function	focal length of ||| focal length	count=1
module	to ||| simplify	count=3
function	forcing vector above ||| forcing full	count=1
function	the bra on the ||| bra	count=1
function	specific value (i ||| free	count=1
arg	\mathbb{z}_p ||| evalpoints hpeval ring i	count=1
arg	x = a in ||| f a k	count=1
class	raise polynomial ||| poly element	count=2
function	is continuous ||| continuous	count=1
class	[class_1] transform is ||| [class_2] [class_1]	count=1
class	push ||| mode base	count=2
function	rewrite the integral fac*po*g ||| rewrite	count=1
function	the corners ||| corners	count=1
arg	a continuous ||| mu	count=2
arg	k is ||| k	count=1
class	[class_1] root to ||| [class_2] [class_1]	count=1
function	ordinary ||| ord	count=1
class	dense matrix with elements ||| matrix	count=1
module_class	[module_1] [class_2] complete if it has ||| [module_1] [class_2]	count=1
function	the domain of ||| not empty	count=1
class	coset [class_2] ||| [class_1] [class_2] is complete	count=1
class	exp ||| exp base	count=1
arg	variable with ||| name alpha beta	count=1
arg	of expr ||| expr series_rs	count=1
function	vector for ||| vector	count=1
module	bounding rectangles of ||| polys	count=1
class	a standard basis ||| sub module poly ring	count=1
function	reduce a ||| reduce	count=2
function	translate ||| translate str	count=1
function_arg	derivative [arg_2] ||| [function_1] numerically [arg_2]	count=7
function_arg	[function_1] f with ||| [function_1] numerically [arg_2]	count=1
function	form x start ||| process	count=1
arg	check if a ||| a	count=1
function	the gcd ||| gf gcd	count=1
arg	the base scalars ||| coord_sys	count=2
function_arg	+ g*h [arg_2] ||| [arg_2] [function_1]	count=8
function	derivative ||| derivative	count=4
arg	_strip with h ||| h	count=1
class	two or more linear ||| linear	count=1
function_arg	according to x ||| bool x	count=2
class	an object ||| expr	count=1
class	point with ||| point	count=2
arg	user ||| weylelt	count=2
function	- [function_2] ||| [function_2] [function_1]	count=6
arg	i j [arg_2] ||| physics epsilon [arg_1] [arg_2]	count=4
arg	range n shifted ||| n	count=1
function	the positive [function_2] ||| [function_2] [function_1]	count=2
function	[function_1] of sympy ||| [function_2] [function_1]	count=4
function_arg	[function_1] to_j, where ||| [function_1] [arg_2]	count=4
arg	of ||| x m	count=1
arg	e z [arg_2] ||| [arg_2] [arg_1]	count=1
function	sparse zero ||| sparse	count=1
arg	same as find_pure_symbol but ||| symbols unknown_clauses	count=1
function	of symbolic values to ||| create param dict	count=1
arg	multiply [arg] randomly ||| [arg]	count=1
function	[function] cholesky ||| [function] symbolic	count=1
arg	m == 1 ||| m	count=1
arg	[arg_1] domain for ||| [arg_1] [arg_2]	count=6
class	a list of ||| field	count=1
arg	integer n ||| n k	count=1
function_arg	[function_1] [arg_2] ordered ||| [function_1] [arg_2]	count=2
class	sparsematrix ||| sparse matrix	count=2
arg	into another quantum ||| choices	count=1
arg	morphism and [arg_2] ||| [arg_2] [arg_1]	count=3
function	an argument [function] false otherwise ||| needs [function]	count=1
function	[function_1] roots together ||| [function_2] [function_1]	count=3
function	pos ||| pos	count=1
arg	e and all its ||| e	count=1
function	quadrants from ||| intervals to quadrants	count=1
module	[module_1] this ||| [module_1] [module_2]	count=1
arg	[arg_1] a ||| [arg_1] p [arg_2]	count=1
arg	x_j at a in ||| a j	count=1
function	indices of a mul ||| get indices mul	count=1
arg	j_2 j_3 [arg_2] ||| [arg_2] [arg_1]	count=7
class	on ||| op	count=1
module	to ||| utilities	count=3
module	lie algebra determines ||| liealgebras	count=1
arg	returns the intervals in ||| f	count=1
function	of coefficients of ||| dmp ground content	count=1
function	converts an ||| qubit to	count=1
arg	point [arg] ||| [arg]	count=1
arg	p in ||| f p	count=3
arg	varying t from ||| t	count=1
function	is a [function_2] ||| [function_1] [function_2]	count=28
function_arg	increasing [arg_2] ||| [arg_2] [function_1]	count=2
class	any hints ||| integral	count=1
function	[function_1] instance to ||| [function_1] [function_2]	count=4
arg	line ||| line	count=1
function	smallest primitive [function_2] ||| [function_2] [function_1]	count=4
class	a root it takes ||| root system	count=1
module_class	[module_1] gate needs ||| [class_2] [module_1]	count=2
function	differential equation with constant ||| constant coeff	count=1
arg	op for ||| op	count=1
function	roots [function_2] ||| [function_1] [function_2]	count=3
function	refine a ||| outer refine real	count=1
function	to the beginning of ||| indent	count=1
function	atan of ||| rs atan	count=1
function	python subprocess [function_2] ||| [function_2] [function_1]	count=3
function	roots together ||| roots	count=1
module	on a specific ||| series	count=1
function	cz^2 + dxy ||| to normal	count=1
module	[module_1] dimension ||| [module_1] [module_2]	count=6
function	decimal [function_2] ||| [function_2] [function_1]	count=3
function	with bsgs ||| get	count=1
class	returns ||| sub	count=1
class	no bounding rectangles ||| complex	count=1
arg	the matching_symbol if s ||| s matching_symbol	count=1
function	the delta coefficient ||| big delta coeff	count=1
function	a sequence of rational ||| rational	count=1
function	calculate the limit of ||| limit	count=1
function	coefficient of ||| as coeff add	count=3
function	next [function] ||| taylor [function]	count=2
function	to ||| operators to state	count=1
function	modified version of scan ||| scan	count=2
arg	product expression ||| expr x	count=1
function	symbolic values ||| create param dict	count=1
class	new ||| root system	count=1
function	is redundant by checking ||| is	count=1
function	on a [function_2] ||| [function_1] [function_2]	count=2
module_class	module [class_2] ||| [module_1] [class_2]	count=2
function_arg	true if [arg_2] ||| [function_1] disjoint [arg_2]	count=2
arg	value of key ||| key	count=1
arg	_hastypes ||| attrs types	count=1
arg	a parametric ||| a	count=1
function	native ||| native	count=2
function	a sympy expression in ||| parse expr	count=1
function	of this vectormul ||| measure number	count=1
arg	[arg_1] with knots ||| [arg_2] [arg_1]	count=4
function	as [function_2] ||| [function_2] [function_1]	count=4
function	of transpositions ||| transpositions	count=1
arg	add numerical implementation to ||| implementation	count=1
function	the symbols that ||| free symbols	count=2
arg	var occurs ||| var x	count=1
function_arg	[function_1] [arg_2] ||| [function_1] monic f [arg_2]	count=6
arg	for an integral curve ||| vector_field param start_point	count=1
function	disjoint intervals ||| disjoint	count=1
function	standard basis in ||| groebner	count=1
arg	[arg] = mul ||| [arg] x	count=1
arg	eq such that ||| eq	count=1
arg	convert the given expression ||| expr	count=1
module	integral ||| integrals	count=1
function_arg	opening statements [arg_2] ||| [function_1] [arg_2]	count=1
function	property where the ||| memoize property	count=1
function_arg	dummy [arg_2] ||| [arg_2] [function_1]	count=6
module	generates [module] dihedral group ||| [module]	count=1
arg	n is ||| n	count=1
function	of k [function_2] ||| [function_2] [function_1]	count=4
function	variations of ||| variations	count=1
module	+ parenthesisgroup into ||| parsing	count=1
class	a polynomial [class_2] ||| [class_1] [class_2]	count=2
arg	not in symbols ||| symbols filter	count=2
arg	public key n ||| key	count=1
function	contribution of f ||| laurent series	count=1
function	the lmq lower bound ||| lower bound	count=1
arg	by ||| auto	count=3
arg	of f s ||| f s	count=3
class	which docstrings ||| doc tests	count=1
module	location where ||| combinatorics	count=2
class	of the series ||| series	count=1
module	parenthesisgroup into ||| parsing	count=1
arg	takes clauses in ||| clauses symbols	count=1
function_arg	degrees of [arg_2] ||| [function_1] list [arg_2]	count=1
function	number of independent generators ||| basis	count=5
arg	[arg_1] rhs but ||| [arg_1] [arg_2]	count=1
module	for [module] this requires ||| [module]	count=1
function	substitution with truncation ||| rs subs	count=2
function	if unicode output is ||| pretty try use unicode	count=1
function	the module and ||| get mod	count=1
function	the smallest primitive ||| primitive	count=1
arg	a in k[x] ||| a	count=1
module	a standard basis ||| polys	count=1
function	unify ||| unify	count=2
class	a sequence of ||| poly	count=1
class	also known [class] ||| coord [class]	count=1
function_arg	scaler-row multiplication ||| mulrowscaler row scaler	count=1
function_arg	[function_1] this function ||| [arg_2] [function_1]	count=8
arg	beta x gives the ||| b x	count=1
class	free [class_2] ||| [class_1] [class_2]	count=1
function	set of basis ||| basis	count=1
function	add a ||| add	count=2
class	subset of ||| subset	count=1
class	tensor [class_2] ||| [class_1] [class_2]	count=1
function	the potential [function_2] ||| [function_2] [function_1]	count=2
function	rho ||| pollard rho	count=1
module	possible ||| pretty	count=1
function	the list of free ||| free	count=1
class	list of polynomial ||| frac field	count=1
arg	n k of the ||| n k d	count=1
function	to ||| get mod func	count=2
function	having root v ||| choose	count=1
function	size ||| size	count=3
arg	a tensmul ||| tensmul	count=1
class	polar numbers is ||| polar	count=1
arg	n data ||| n x	count=1
function	have [function] coefficients try ||| to [function]	count=1
function	morphism ||| morphism	count=1
arg	mobius transform or an ||| k eps	count=1
arg	g p k using ||| g b p	count=1
arg	bases and exponents ||| force	count=1
function_arg	[function_1] [arg_2] a positive integer n ||| [function_1] [arg_2]	count=6
arg	expression to a ||| expr	count=1
module_class	[module_1] composite ||| [module_1] [class_2]	count=4
class	else false ||| expr with	count=1
module_class	[module_1] nothing ||| [module_1] [class_2]	count=2
class	exploiting the sparsity ||| sparse	count=2
function	a scalar [function_2] ||| [function_1] [function_2]	count=4
arg	j k is ||| j k	count=2
function	coset rank ||| coset rank	count=1
function	to a fully ||| data tensorhead from	count=1
function	[function_1] matrix for ||| [function_2] [function_1]	count=6
function	format an error ||| error	count=1
arg	list of numbers ||| numbers	count=1
function	to the module ||| mod	count=1
function	the lie group ||| lie group	count=1
arg	tree [arg_2] ||| [arg_2] [arg_1]	count=1
arg	b**e if n ||| n candidates	count=1
function	hermite ||| hermite	count=1
function	letter ||| letter	count=1
function	the positive roots ||| positive roots	count=2
class	[class_1] the transform ||| [class_2] [class_1]	count=1
function	[function_1] z ||| [function_1] [function_2]	count=1
function	berkowitz algorithm to compute ||| berkowitz	count=1
function	available ||| try	count=1
function_arg	exponentiation of [arg_2] ||| [function_1] [arg_2]	count=1
function	product of two ||| mul as two	count=2
arg	an ||| rep	count=1
class	ring ||| poly ring	count=2
function	compute roots ||| roots	count=1
function	that helps ||| search	count=1
arg	polynomial p in ||| f p u	count=1
function	represent a gate with ||| represent zbasis	count=1
function_arg	to addends [arg_2] ||| [arg_2] [function_1]	count=4
arg	return a polynomial in ||| f p	count=1
function	wrapper around the heurisch ||| heurisch wrapper	count=1
arg	polynomial ||| f	count=7
arg	levels in f and ||| f k	count=1
function_arg	[function_1] an ||| [arg_2] [function_1]	count=11
function	semi-latus rectum ||| semilatus rectum	count=1
function_arg	[function_1] [arg_2] ||| [function_1] h [arg_2]	count=2
class	with crootof ||| complex root of	count=1
function	tensors with ||| tens	count=1
function_arg	other, where [arg_2] ||| [function_1] [arg_2]	count=2
arg	converts expr ||| expr assign_to	count=1
class	with ||| poly	count=1
class	take ||| base	count=1
function	xor ^, ||| xor	count=1
class	hole or create ||| annihilate fermion	count=2
function	a gate with ||| zbasis	count=1
arg	g is the ||| g	count=1
arg	j_2 m_2 ||| j_2	count=1
function	a continuous subsequence of ||| dmp slice	count=2
function	[function_1] order ||| [function_2] [function_1]	count=3
arg	and b one ||| b	count=1
arg	where f g ||| f g	count=8
function_arg	return a transversal of [function_1] [arg_2] second method described in ||| [function_1] [arg_2]	count=2
arg	grid and ||| grid	count=1
function_arg	increasing in [arg_2] ||| [function_1] [arg_2]	count=2
class	a sequence ||| seq	count=1
arg	expression ||| expr length sign	count=1
module	returns the total number ||| liealgebras	count=1
function	of sign ||| sign	count=1
function	scale the ||| scale	count=1
class	the picture in characters ||| string pict	count=1
function	values to ||| create param	count=1
function_arg	[function_1] morphism is ||| [function_1] [arg_2]	count=2
function_arg	[function_1] (i ||| [function_1] horizontal [arg_2]	count=5
function	negative ||| negative	count=5
function	sign ||| sign	count=1
module	in a quantum ||| quantum	count=1
module	loggamma ||| special	count=2
module_class	the polygon ||| geometry polygon	count=1
class	a standard ||| module poly ring	count=1
function_arg	[function_1] i j ||| [function_1] [arg_2]	count=1
arg	diagram ||| diagram merged_morphisms	count=1
function	expression to ||| sympify	count=1
function_arg	true if [arg_2] ||| [function_1] [arg_2]	count=1
function	parameters and ||| parameters	count=1
function	to their associated ||| operators to	count=1
arg	can be used ||| zeros	count=1
class	truth value of ||| piecewise	count=1
module	name of the ||| utilities	count=1
arg	f in [arg_2] ||| [arg_1] [arg_2]	count=7
module	of self ||| matrices	count=1
function	the zero ||| zero	count=2
function_arg	to a ||| sympify a	count=1
function	representation of a freegroupelement ||| form	count=1
module_class	[module_1] parabola ||| [module_1] [class_2]	count=11
function	bounding rectangles ||| refine complexes	count=1
function	of undetermined coefficients ||| undetermined coefficients	count=1
function	returns the precedence ||| precedence	count=1
function	numerator parameters of ||| ap	count=1
arg	instance ||| cls expr	count=1
function	of a multivariate series ||| rs	count=1
function_arg	[function_1] o ||| [arg_2] [function_1]	count=1
function_arg	derivative of [arg_2] ||| [arg_2] [function_1]	count=11
class	[class] in place ||| [class]	count=3
function	only uses the log ||| log	count=1
function	one ||| primitive	count=1
function	version of eye ||| eye	count=1
function	value of the ||| cond	count=1
arg	j_2 j_3 j_4 j_5 ||| j_2 j_3 j_4	count=2
function	of crt for ||| crt	count=1
function	expansion of the atan ||| atan	count=1
function	arguments of ||| args	count=1
arg	of combinations of n ||| n	count=1
function_arg	expression to [arg_2] ||| [arg_2] [function_1]	count=1
module	those that take ||| series	count=1
module	in which ||| calculus	count=1
function	clear ||| clear	count=6
function	the positional ||| get positional	count=1
module	the wavefunction ||| physics quantum	count=1
function_arg	error [arg_2] ||| [function_1] [arg_2]	count=1
arg	that ||| cls	count=1
function	the norm of ||| norm	count=1
function	returns a list of ||| list	count=5
arg	a scalar ||| scalar_field	count=1
arg	to other ||| other num	count=1
arg	or an ||| expr	count=1
function_arg	[function_1] f defined ||| [arg_2] [function_1]	count=5
arg	== b**e if n ||| n candidates big	count=1
arg	to eliminate x_0 from ||| u	count=1
module	and c columns if ||| matrices	count=1
class	returns the column matrix ||| symbolic system	count=2
function	[function_1] and primitive ||| [function_1] [function_2]	count=2
function	as ||| as	count=11
function	the subset ||| get subset	count=1
arg	[arg_1] the variable ||| [arg_1] [arg_2] increment	count=3
module	the [module_2] ||| [module_1] [module_2]	count=26
function	evaluate the [function_2] ||| [function_2] [function_1]	count=4
function	[function_1] increasing ||| [function_1] [function_2]	count=5
module	of the function ||| functions elementary	count=1
arg	[arg_1] eq such ||| [arg_2] [arg_1]	count=2
class	self to an ||| differential extension	count=1
function	complex number ||| complex number	count=2
arg	namespace dict with ||| namespace	count=1
arg	the key matrix ||| key symbols	count=1
arg	required for constructing ||| morphisms_str_info	count=1
arg	x_j ||| f m j	count=1
function	of indices corresponding to ||| indices	count=1
function	a multinomial form into ||| from dict	count=1
arg	k of the first ||| k d	count=1
arg	for internal use ||| s	count=1
module	returns true if ||| polys domains	count=4
function	the subset defined by ||| get subset from	count=1
function	coefficients ||| content	count=2
function	nested tuple of tuples ||| to tuple	count=1
class	ring and ||| poly ring	count=1
module	belonging to [module] same ||| [module]	count=1
module	below the fermi surface? ||| physics	count=3
function_arg	[function_1] = n ||| [function_1] [arg_2]	count=1
arg	number of ||| s	count=1
function_arg	[function_1] in x_j ||| [function_1] f m a [arg_2]	count=3
class	should appear [class] ||| [class]	count=1
arg	list of implications ||| implications	count=1
function	field isomorphism ||| field isomorphism	count=2
function	jacobi [function_2] ||| [function_1] [function_2]	count=1
arg	to f ||| f coeff	count=1
class	ordered subset of ||| subset	count=1
arg	a ||| a k0	count=46
arg	for convenience if reduction ||| ai bj	count=1
module	specific lie algebra ||| liealgebras	count=1
function	to switch to ||| to	count=1
function_arg	[function_1] given ||| [function_1] [arg_2]	count=19
function	and negative coefficient muls ||| opt	count=1
function_arg	[function_1] [arg_2] n of a positive ||| [function_1] n [arg_2]	count=1
module	to ||| printing	count=2
arg	f in k[x] ||| f n	count=1
class	identity ||| free module	count=1
arg	checks if expr ||| expr	count=1
arg	from gate_list and ||| gate_list	count=1
arg	limits should be ||| func limits	count=1
arg	of an integer n ||| n	count=1
arg	strip given by strip= ||| x strip	count=1
module	sum that can ||| simplify	count=1
module	a specific value (i ||| series	count=1
arg	similar bases and exponents ||| force	count=1
function	real element ||| real	count=1
function	primitive form of ||| ground primitive	count=1
function	orbit is only ||| only	count=1
arg	expr and ||| expr	count=1
module	get the ||| physics	count=1
class	take on ||| base	count=1
arg	the divergence ||| vect	count=1
arg	g are ||| g	count=1
function	[function_1] on ||| [function_2] [function_1]	count=4
function	evaluation points for ||| points	count=1
module	helps find the ||| physics	count=1
function	multiply a ||| mul	count=3
arg	inequality ||| domain	count=1
arg	z is ||| z	count=1
function	generates chebyshev ||| chebyshevu	count=1
arg	[arg_1] center ||| [arg_2] [arg_1]	count=4
class	lcm ||| polynomial ring base	count=1
function_arg	gcd of f ||| gcd f	count=4
function	[function_1] velocity ||| [function_2] [function_1]	count=2
arg	x y are ||| x y	count=2
class	whose ||| partition traverser	count=1
function	if unicode output ||| try use unicode	count=1
arg	implications ||| implications	count=1
class	simple root [class] ||| [class]	count=2
arg	return ||| s	count=1
arg	replaced by ||| args kwargs	count=1
function	positive root of ||| root	count=2
function	[function_1] transform ||| [function_2] [function_1]	count=12
function	leading term ||| lt	count=1
function	linear time [function] algorithm that ||| [function]	count=2
function_arg	[function_1] dsolve ||| [function_1] [arg_2]	count=1
function	[function] partitions ||| [function]	count=1
function	and is thus the ||| is singleton	count=1
class	that no ||| root of	count=1
arg	a ||| a k	count=1
arg	optimization opportunities ||| order	count=1
arg	series expansion ||| n x prec	count=1
arg	bound n ||| b cq n	count=1
function	a symbol [function] ||| [function]	count=3
module	the order ||| physics quantum	count=1
function	x_i**k_i in ||| dmp inflate	count=1
arg	self in h ||| h	count=1
arg	expansion of expr ||| expr series_rs	count=1
function_arg	a transversal of the [function_1] [arg_2] the second method described ||| [function_1] transversal [arg_2]	count=2
function	[function_1] mpq to ||| [function_2] [function_1]	count=2
class	and a -1 ||| type a	count=1
function	the form ||| process	count=1
module	generated ||| utilities	count=2
function	sort generators ||| sort	count=1
function	allows functions ||| function	count=1
function	to tell whether ||| is	count=1
function	[function_1] unit ||| [function_2] [function_1]	count=4
class	no bounding rectangles of ||| complex root of	count=1
function	bending [function_2] ||| [function_1] [function_2]	count=2
class	fact ||| fact	count=1
function	the coset rank ||| coset rank	count=2
function	available and leverage it ||| pretty	count=1
function	length of ||| morphism length	count=1
arg	center ||| vec	count=1
arg	:class arrowstringdescription describing the ||| morphisms_str_info	count=1
arg	given set of points ||| func points	count=1
arg	q are in ||| q x	count=2
function	list into ||| split list	count=1
function_arg	add polynomials in ||| add f g	count=1
function	the cartan [function_2] ||| [function_2] [function_1]	count=4
class	the window ||| window	count=1
class	raising shapeerror if shapes ||| matrix arithmetic	count=1
arg	f ||| f x recursive	count=1
arg	[arg_1] k[x] ||| [arg_1] [arg_2]	count=31
arg	[arg_1] variable ||| [arg_2] [arg_1]	count=2
function_arg	a to a ||| to sympy a	count=8
function	functions in terms of ||| as	count=1
class	this fermionicoperator restricted to ||| fermionic operator	count=2
function	all the positive roots ||| positive roots	count=2
module	available ||| printing	count=1
function_arg	homogeneous partial [arg_2] ||| [function_1] eq func order [arg_2]	count=3
function	remainder in ||| rem	count=1
function	values to ||| param	count=1
module	leverage it ||| pretty	count=1
module	handles the ||| physics quantum	count=1
function	christoffel symbols for ||| to christoffel 1st	count=1
class	a sequence of ||| poly ring	count=1
arg	if k [arg_2] ||| [arg_2] [arg_1]	count=2
class	[class_1] an element ||| [class_1] [class_2]	count=2
arg	g [arg_2] ||| [arg_1] p [arg_2]	count=1
arg	given combinatorial term [arg_1] [arg_2] ||| [arg_1] [arg_2]	count=1
function_arg	[function_1] in p ||| [arg_2] [function_1]	count=3
function	ordered ||| ordered	count=1
function	[function] several ||| direct [function]	count=1
arg	in k[x] ||| i u	count=2
function	a factory for threaded ||| threaded factory	count=1
arg	l is the term ||| l r	count=1
function_arg	a power [arg_2] ||| [arg_2] [function_1]	count=2
arg	condition [arg] ||| condition [arg]	count=1
function_arg	transform of [arg_2] ||| [function_1] [arg_2]	count=13
function	returns l1 norm ||| l1 norm	count=3
function	inverse of [function_2] ||| [function_1] [function_2]	count=2
class	a singularity function expression ||| singularity function	count=1
arg	the transformation used to ||| to_sys	count=1
function_arg	i [arg_2] ||| [arg_2] [function_1]	count=3
arg	series expansion ||| x prec	count=5
function	of the matrix ||| matrix	count=1
function_arg	[function_1] cipher ||| [arg_2] [function_1]	count=6
module	function in the specified ||| physics	count=1
class	coefficient ||| poly element	count=1
arg	the property prop ||| prop base	count=1
module	returns the energy of ||| physics	count=1
module	'lamda' being the two ||| combinatorics	count=1
arg	[arg_1] log-normal distribution ||| [arg_2] [arg_1]	count=1
function	isolate real ||| dup isolate real	count=6
function	[function_1] g*h ||| [function_1] [function_2]	count=14
function	and leverage it if ||| pretty try use	count=1
function	[function_1] partitions ||| [function_1] [function_2]	count=3
function	quotient homomorphism to ||| quotient hom	count=1
function_arg	reduced [arg_2] ||| [function_1] [arg_2]	count=2
function_arg	trailing coefficient [arg_2] ||| [arg_2] [function_1]	count=1
arg	f s over the ||| f s	count=1
function	solution to an ode ||| ode 1st homogeneous coeff	count=1
class	column matrix f ||| symbolic	count=1
class	lc ||| global polynomial ring	count=3
function_arg	[function_1] gens ||| [function_1] [arg_2]	count=4
class	stringpicts ||| pict	count=1
function_arg	[function_1] [arg_2] ||| [function_1] eq func [arg_2]	count=1
arg	domain for which the ||| domain	count=1
class	return ||| matrix	count=1
class	can get ||| polyhedron	count=1
arg	x of ||| x	count=3
arg	a field in k[x] ||| f g u k	count=1
function	n-th coefficient ||| nth	count=4
class	rectangles ||| root	count=1
function	[function_1] decomposition ||| [function_1] [function_2]	count=1
function_arg	generates the [function_1] [arg_2] permutation group ||| [function_1] [arg_2]	count=1
class	coset enumeration described on ||| coset table	count=2
function_arg	[function_1] (i ||| [arg_2] [function_1]	count=16
arg	b**e if n ||| n candidates big factor	count=1
arg	\mathbb{z}_p[x0 \ldots x{k-1}] ||| p degbound	count=1
arg	[x]/ [arg_2] ||| [arg_1] [arg_2]	count=1
arg	n in ||| n a b	count=1
function	[function_1] sort ||| [function_2] [function_1]	count=1
function	is ||| pretty	count=1
function	the sum [function_2] ||| [function_1] [function_2]	count=6
class	dense matrix ||| matrix	count=1
function	the generator that ||| generator	count=1
arg	expression ||| expr x	count=1
arg	bits ||| bits str	count=1
module	the [module_2] ||| [module_1] [module_2] point	count=1
function	vertex ||| vertex	count=1
function	the quadratic ternary diophantine ||| ternary quadratic normal	count=1
function_arg	of functions [arg_2] ||| [function_1] [arg_2]	count=3
class	fractions ||| frac element	count=1
function	the lie group ||| ode lie group	count=2
function_arg	deltaintegrate f x ||| deltaintegrate f x	count=1
function	asin of p, about ||| asin	count=1
class	this ||| series	count=1
arg	[arg_1] [arg_2] are polynomials ||| [arg_1] [arg_2]	count=4
module	if a labeled polynomial ||| polys	count=1
class	the differential ||| differential	count=1
class	a ||| module poly ring	count=3
arg	of points in the ||| func points	count=1
function_arg	[function_1] of orig_vec ||| [arg_2] [function_1]	count=2
module	computational ||| quantum	count=1
arg	l and u ||| reverse	count=1
class	inverse ||| matrix base	count=2
function	the lower-hessenberg form ||| lower hessenberg	count=1
module	[module_1] self ||| [module_1] [module_2]	count=18
module	from the list of ||| physics	count=1
arg	the anti-derivative to ||| meijerg risch	count=1
function	the cross product between ||| cross	count=1
function_arg	[function_1] differential ||| [arg_2] [function_1]	count=2
function	tangent of a ||| tan	count=1
function	an ideal of our ||| ideal	count=1
function	primary ||| primary	count=1
function	x start ||| limits	count=1
arg	defined ||| k r	count=1
module	of [module] triangle ||| [module]	count=1
function_arg	set [arg_2] ||| [function_1] comm [arg_2]	count=1
arg	difference formula ||| points x0 wrt	count=1
function	the intersection ||| intersect	count=2
function_arg	[function_1] [arg_2] is '|') and words ||| [function_1] [arg_2] mapping	count=3
arg	in c ||| f	count=1
function	a is of ||| of	count=1
function_arg	functions [arg_2] ||| [arg_2] [function_1]	count=4
function	return a group ||| group	count=1
function	the adjacency matrix ||| get adjacency matrix	count=1
function	homomorphism to ||| hom	count=1
class	basis ||| sub module	count=1
function	a symbol [function_2] ||| find [function_2] [function_1]	count=4
arg	in p [arg_2] ||| [arg_2] [arg_1]	count=1
function	[function_1] g*h where ||| [function_2] [function_1]	count=12
arg	i ||| i k	count=2
function	difference between ||| difference	count=1
function_arg	potential function [arg_2] ||| [function_1] [arg_2]	count=4
arg	of \* ||| dir pat init_only	count=1
arg	to the beginning of ||| s	count=1
arg	return [arg_1] [arg_2] ||| [arg_2] n [arg_1]	count=3
arg	coordsyscartesian with its origin ||| vector_names	count=1
module	in the form vector ||| physics vector	count=1
module	system augmented by the ||| physics	count=1
function	[function_1] and its ||| find [function_2] [function_1]	count=2
arg	isolating interval of a ||| s t eps	count=2
function	form of singularity ||| eval rewrite as singularity	count=1
function	minimal polynomial ||| minimal polynomial	count=2
module	return the result ||| utilities	count=1
function	mul hint see the ||| mul	count=1
function	the primitive [function_2] ||| [function_2] [function_1]	count=4
function	on it ||| apply on	count=1
arg	n k of ||| n k	count=1
arg	the actual ||| func	count=1
arg	with ||| name	count=1
function	product [function_2] ||| [function_1] [function_2]	count=1
class	values ||| llvmjit code	count=2
function	[function_1] degrees of ||| [function_2] [function_1]	count=6
arg	k of ||| k	count=1
class	reduce ||| module poly ring	count=1
module	distribution ||| stats	count=1
module	no bounding rectangles ||| polys	count=1
arg	k is equal to ||| k	count=1
class	[class_1] array ||| [class_1] [class_2]	count=3
function	to a fully ||| from tensmul	count=1
function	about 0 ||| rs	count=1
function_arg	[function_1] for the ||| [function_1] [arg_2]	count=2
function_arg	[function_1] a point ||| [function_1] force vec [arg_2]	count=1
class	and ||| base	count=1
arg	a ||| a n	count=2
function	[function_1] ternary diophantine ||| [function_2] [function_1]	count=6
function	heuristic polynomial [function_2] ||| [function_1] [function_2]	count=3
class	of the function ||| function	count=1
function	maximum [function_2] ||| [function_2] [function_1]	count=7
class	over distribution ||| single discrete distribution	count=1
function	strong [function_2] ||| [function_2] [function_1]	count=3
arg	ub parts ||| ub	count=1
arg	a dmp out ||| kill	count=1
function	the direction cosine ||| direction cosine	count=2
module	the [module] if present ||| [module]	count=1
function	return the leading term ||| lt	count=1
module_class	[module_1] gray ||| [module_1] [class_2]	count=2
arg	f at ||| f	count=1
class	a sympy sets set ||| set	count=1
function	lcm over a field ||| dmp ff lcm	count=1
function	undetermined ||| undetermined	count=2
module	matrix ||| matrices expressions	count=2
arg	point z0 ||| z0 dir	count=1
function_arg	power or an ||| pow expr	count=2
class	hole or create particle ||| annihilate fermion	count=2
module	if self ||| agca	count=10
arg	compute ||| f g	count=3
function	correct ||| correct signature	count=1
function	the horner scheme ||| eval	count=2
class	is ||| quotient module	count=2
function_arg	[function_1] [arg_2] ||| [function_1] root [arg_2]	count=8
function	stop on success ||| once	count=1
function	a groebner basis is ||| is	count=1
function	if the lu ||| lu	count=1
function	tensor product ||| tensor printing	count=1
module_class	the triangle ||| geometry triangle	count=1
function_arg	list from [arg_2] ||| [arg_2] [function_1]	count=2
arg	[arg_1] fringe and ||| [arg_2] [arg_1]	count=1
module	number of qubits this ||| quantum	count=1
class	hints given ||| integral	count=1
function	solve a generic system ||| solve generic	count=1
function	normal form of ||| normal	count=1
function	morphism the length ||| morphism length	count=1
arg	namespace dict with function ||| namespace	count=1
arg	u [arg_2] ||| [arg_1] [arg_2]	count=1
class	over distribution ||| discrete distribution	count=1
arg	coefficient muls ||| exprs	count=1
function	common header for ||| header	count=2
arg	codestring with the proper ||| codestring	count=1
function_arg	to couple an ||| couple expr	count=1
function_arg	square polynomials [arg_2] ||| [arg_2] [function_1]	count=1
module	the name of ||| utilities	count=1
function	to a ||| mod func	count=1
function	remainder [function_2] ||| [function_2] [function_1]	count=2
function	functions in terms ||| as	count=1
function	full partial fraction ||| apart list full	count=1
function_arg	triangle [arg_2] ||| [arg_2] [function_1]	count=6
function	accuracy [function] number ||| [function]	count=1
function	[function] method assigns ||| [function]	count=1
class	of symbolic values ||| llvmjit code	count=1
function	python subprocess [function_2] ||| [function_1] [function_2]	count=3
arg	a k[x] ||| u k	count=1
function_arg	[function_1] qubit ||| [arg_2] [function_1]	count=1
function	top ||| top	count=2
function	to _eval_nseries if assumptions ||| nseries	count=1
function	function for [function_2] ||| [function_1] [function_2]	count=1
module_class	[module_1] triangle ||| [module_1] [class_2]	count=10
function	coefficient [function_2] ||| [function_2] [function_1]	count=5
module_class	[module_1] plane ||| [module_1] [class_2]	count=17
class	of this matrix ||| dense matrix	count=1
function	[function_1] a dictionary ||| [function_1] [function_2]	count=5
function	the name of ||| mod	count=1
function	is one ||| is monic	count=2
function	lcm over a ||| ff lcm	count=1
arg	a small'' matrix ||| deg_f	count=1
function	[function_1] cancellation deg ||| [function_1] [function_2]	count=1
function	affine [function] ||| affine [function]	count=3
arg	of n ||| n b	count=1
arg	lexical closure to make ||| name latexname	count=1
arg	simplifies the ||| measure fu	count=1
function	function to ||| function	count=1
function_arg	gf [arg_2] ||| [function_1] neg [arg_2]	count=2
function	the generated files ||| get	count=2
function	rotational gradients [function_2] ||| [function_2] [function_1]	count=1
class	string ||| string	count=2
function	subtract [function_2] ||| [function_2] [function_1]	count=2
function	square-free normal form of ||| sqf normal	count=1
function	to ||| dict	count=1
function	[function_1] parameters and ||| [function_2] [function_1]	count=1
function	of singularity functions ||| eval rewrite as singularity function	count=1
class	generator for free ||| free	count=1
arg	n [arg] - ||| expr symbolname startnumber [arg]	count=1
arg	to k[ x_j ||| j	count=1
function	the circumcircle ||| circumcircle	count=1
class	linearentity ||| linear entity	count=1
function_arg	transform [arg_2] ||| [function_1] to to_sys [arg_2]	count=1
function	combined denominator ||| bq	count=1
function_arg	hilbert space [arg_2] ||| [arg_2] [function_1]	count=1
function	a sequence ||| sequence	count=1
function	the degree ||| degree	count=3
arg	knots ||| knots n	count=1
function	entity parallel to ||| parallel	count=1
class	xy-pic representation ||| diagram drawer	count=1
class	dense matrix with ||| matrix	count=1
arg	in x_j at a ||| a j	count=1
arg	morphism and [arg_2] ||| [arg_1] [arg_2]	count=3
module	permutation ie ||| combinatorics	count=2
arg	the index1 [arg_2] ||| matrices rowadd [arg_2] [arg_1]	count=1
arg	returns a ||| w a b	count=1
arg	defined as ||| k r	count=1
function	that no ||| complexes	count=1
arg	text ||| text color	count=1
function	number of ||| number	count=1
function	ground n-th coefficient ||| dmp ground nth	count=2
function_arg	when [arg_2] ||| [arg_2] [function_1]	count=4
function	the same ambient dimension ||| origin	count=1
class	from which docstrings ||| doc	count=1
arg	residual mod [arg] that it ||| [arg]	count=1
module	returns ||| matrices	count=1
arg	of [arg] with respect ||| [arg]	count=1
arg	running it on ||| fns	count=2
function	momentum of a ||| momentum	count=1
function_arg	manipulate parts [arg_2] ||| [arg_2] [function_1]	count=5
arg	with ||| replace	count=1
class	a finiteset ||| finite set	count=1
function	generates laguerre [function_2] ||| [function_1] [function_2]	count=1
function	the domain of the ||| empty in	count=1
function	return leading coefficient ||| poly lc	count=1
arg	transversals and result ||| orbits transversals	count=1
function	and negative coefficient muls ||| opt cse	count=1
function	[function_1] form examples ||| [function_2] [function_1]	count=6
function	returns the frequency ||| frequency	count=1
function	[function_1] velocity ||| [function_1] [function_2]	count=2
function	this type of ode ||| order1 type6	count=1
function	be roots ||| roots	count=1
arg	basic ||| strong_gens_distr transversals_only	count=1
function	d^2 ||| four squares	count=1
function	string ||| get	count=2
function	a power [function_2] ||| [function_2] [function_1]	count=1
arg	length l ||| l d2	count=1
arg	phrase [arg_2] ||| [arg_2] [arg_1]	count=2
arg	the g function g ||| g a	count=1
function	[function_1] a finite ||| [function_1] [function_2]	count=1
function	return a dummy associated ||| dummy	count=1
arg	split arg into two ||| arg	count=1
arg	of the ||| func	count=1
function	multivariate [function_2] ||| [function_1] rr [function_2]	count=1
function	[function_1] triangular ||| [function_2] [function_1]	count=1
function	make [function_2] ||| [function_2] [function_1]	count=3
function	[function] m computed ||| [function]	count=2
function_arg	[function_1] to f ||| [function_1] [arg_2]	count=2
arg	f applied ||| f	count=1
function	supremum ||| sup	count=1
module	take the ||| physics	count=1
function	[function] self to ||| [function]	count=2
function	the forcing vector ||| forcing full	count=1
arg	log-normal ||| mean std	count=1
module	factorint which return ||| core	count=1
function	out generators ||| gens	count=1
function	of real roots ||| real roots	count=1
function	return leading coefficient of ||| poly lc	count=1
function	power [function_2] ||| [function_2] [function_1]	count=1
arg	by state ||| state	count=2
class	[class_1] [class_2] examples ||| [class_1] [class_2] dynkin	count=1
class	of self ||| base	count=1
function	according to ||| bool	count=1
function	possible ||| pretty	count=1
function	q[x] it is assumed ||| euclid pg	count=1
arg	1 2 ; -1 [arg_1] [arg_2] ||| [arg_1] [arg_2]	count=3
function_arg	[function_1] given interval ||| [function_1] [arg_2]	count=17
arg	small'' matrix m ||| deg_f deg_g row1	count=1
class	basis ||| basis	count=2
arg	point p ||| p	count=2
arg	the form ||| func	count=1
class	rectangular form or ||| complex region	count=1
class	a grid laid ||| diagram grid	count=1
function	inverse hankel [function_2] ||| [function_2] [function_1]	count=2
function	expr cond ||| sort expr cond	count=2
function	parameters and nonhomogeneous ||| parameters	count=1
function_arg	[function_1] ex1 ||| [function_1] op [arg_2]	count=1
function_arg	is decreasing [arg_2] ||| [arg_2] [function_1]	count=2
module	by the ||| physics	count=1
function	denest ||| biquadratic denest	count=1
function	see ||| pretty	count=1
function	all the implications ||| deduce all	count=1
arg	[arg_1] are ||| [arg_1] [arg_2]	count=5
arg	var ||| var	count=2
function	outputargument inoutargument and result ||| result variables	count=1
function	* [function_2] ||| [function_1] [function_2]	count=1
function	the number of real ||| count real	count=1
class	dimension ||| dimension	count=1
function	called the external representation ||| ext rep	count=1
class	or product ||| expr with int limits	count=1
arg	returns all ||| f	count=1
arg	the given scalar field ||| scalar_field doit	count=1
arg	constant p [arg_2] ||| [arg_2] [arg_1]	count=2
class	an interval ||| interval	count=3
function	multiple of ||| multiple	count=1
function	of the ||| not empty in	count=1
function	least [function] ||| [function]	count=3
arg	polynomial f ||| f n	count=1
function	with ||| get integer	count=1
function	[function_1] lagrange's equations ||| [function_1] [function_2]	count=1
arg	appears in old ||| old	count=1
function	label is ||| label	count=1
arg	q divides p ||| q p	count=1
function	returns the coefficient ||| coeff monomial	count=1
function	clauses ||| clauses	count=1
module	as ||| combinatorics	count=1
module	of non-conjugate ||| polys	count=1
module_class	to allow [class_2] ||| [module_1] [class_2]	count=6
function	gauss-lobatto ||| gauss lobatto	count=1
function	base [function_2] ||| [function_2] [function_1]	count=3
function	randomization ||| randomization	count=1
function	normal [function_2] ||| [function_2] [function_1]	count=5
arg	alpha as a set ||| alpha pairs	count=1
arg	for f ||| f	count=1
arg	dum indices [arg_2] ||| [arg_2] free [arg_1]	count=1
function	with the euclidean ||| euclidean algorithm	count=1
module_class	implies nothing ||| polys domains field	count=1
function	parameters ||| params	count=1
function	for the laplace inversion ||| inversion	count=1
class	finiteset in terms of ||| finite set	count=1
module	given ||| integrals	count=1
function	a standard basis ||| groebner	count=1
module_class	[module_1] ray ||| [module_1] [class_2]	count=12
function	technique ||| technique 2	count=2
function	object excluding those that ||| free	count=1
function	the condition ||| cond	count=1
function	a new [function] has ||| spread [function]	count=1
class	of polygon and ||| polygon	count=1
arg	i [arg_2] ||| physics epsilon [arg_1] [arg_2]	count=5
arg	key msg ||| msg key	count=2
class	that are generated automatically ||| extension	count=1
function_arg	[function_1] and the ||| [function_1] diagram [arg_2]	count=1
arg	3 angular momenta ||| aa bb cc prec	count=1
function	pivot ||| pivot	count=1
module_class	[module_1] gate needs ||| [module_1] [class_2]	count=4
arg	n ||| n candidates big	count=1
module	of [module_2] ||| [module_2] [module_1]	count=22
arg	p [x] ||| n p k	count=2
arg	[arg_1] irreducibility test ||| [arg_2] [arg_1]	count=1
arg	f at a ||| f i a	count=1
function	get the ||| get	count=1
function	a ||| get	count=5
module	to the module ||| utilities	count=1
module	of a, implies ||| domains	count=1
function	this heuristic uses ||| lie heuristic function	count=1
arg	arguments without changing ||| radical clear fraction	count=1
function	the delta ||| big delta	count=1
function	polynomial ring ||| old poly ring	count=2
function	name of the ||| mod	count=1
function	b using [function] ||| [function]	count=1
function	create a new rootsystem ||| new	count=1
function	proper subset of 'other' ||| proper subset	count=1
function	normalized [function] ||| [function]	count=3
module	in a quantum expression ||| quantum	count=1
function_arg	part of f ||| part f	count=8
class	returns a standard basis ||| module poly	count=1
function	the composed [function] prod(p2 ||| rs compose [function]	count=1
function	converts an add/mul ||| qubit to	count=1
function	domain of ||| not empty	count=1
function	f - [function_2] ||| [function_1] [function_2]	count=5
function	number of roots of ||| count roots	count=2
arg	2 ; -1 if [arg_1] [arg_2] 2 1 or 2 ||| physics epsilon [arg_1] [arg_2]	count=1
module_class	[module_1] __divmod__ ||| [module_1] [class_2]	count=2
class	returns the ||| matrix	count=1
arg	f g h are ||| f g h	count=4
arg	the index1 [arg_2] ||| [arg_2] [arg_1]	count=1
function_arg	[function_1] stringpict and ||| [function_1] s baseline binding [arg_2]	count=1
function	all the implications ||| all	count=1
function	returns ||| inverse	count=1
function	a force ||| force	count=1
class	simplified intersection ||| intersection	count=1
function	[function_1] cofactors of ||| [function_2] [function_1]	count=8
function	positions of descents in ||| descents	count=1
module_class	[module_1] point ||| [class_2] [module_1]	count=11
function	ket ||| ket	count=1
function	return a certificate ||| certificate	count=1
module	triangle of [module] triangle ||| [module]	count=1
function	rl ||| rl	count=1
function	object excluding those ||| free	count=1
function	c^2 ||| sum of	count=1
arg	subgroup h ||| h strategy	count=2
arg	is the term ||| r	count=1
function	ode from the ||| ode 1st	count=1
function	is the whole ring ||| is whole ring	count=1
arg	m by [arg_2] ||| [arg_1] [arg_2]	count=2
module	the ||| physics continuum_mechanics	count=2
module	the get_unit method using ||| physics	count=1
arg	matching_symbol if ||| matching_symbol	count=1
arg	f ||| f m n	count=4
class	group of g2 ||| group	count=1
function	over a field ||| dmp ff	count=1
class	those that take ||| base	count=1
function	the atanh ||| rs atanh	count=1
module	if the ||| physics	count=5
arg	and b, ||| b	count=16
arg	g when possible ||| g	count=1
arg	constructing the ||| morphisms_str_info	count=1
function	dispatch [function_2] ||| [function_1] [function_2]	count=1
function_arg	[function_1] [arg_2] terms whose squares are ||| [function_1] [arg_2]	count=1
arg	g are polynomials ||| g x	count=1
arg	expression [arg_2] ||| [arg_1] condition [arg_2]	count=1
function_arg	[function_1] rv that ||| [function_1] [arg_2]	count=2
arg	for f [arg_2] ||| [arg_2] [arg_1]	count=4
arg	to g and ||| g	count=1
function	return a rational ||| rational	count=1
function_arg	[function_1] f g ||| [arg_2] [function_1]	count=16
function_arg	new copy [arg_2] ||| [function_1] [arg_2]	count=1
class	with the proper ||| code	count=1
function	zeros matrix ||| matrix zeros	count=1
module	the number of ||| combinatorics	count=1
class	listed ||| tens mul	count=2
module	on the ||| physics	count=2
function	power series ||| 2nd power series	count=1
arg	element elem ||| elem	count=1
function	a product [function_2] ||| [function_2] [function_1]	count=2
function	3-tuple ||| three	count=1
class	in the object ||| series base	count=1
function	returns ||| get	count=1
function	translate substrings of ||| translate	count=1
function_arg	[function_1] levels using ||| [arg_2] [function_1]	count=1
module	if ||| printing	count=2
function_arg	roots [arg_2] ||| [arg_2] [function_1]	count=17
arg	transformation used to switch ||| to_sys	count=1
module	quantum ||| quantum	count=2
function	[function_1] [function_2] ||| [function_2] is [function_1]	count=1
function	to a ||| get mod	count=1
module	ternary form [module] + by^2 ||| [module]	count=1
module	compute the ||| physics quantum	count=1
function	of ||| not	count=1
class	power series ||| power series	count=2
function	normal ordering ||| normal	count=1
class	patterns ||| matrix properties	count=1
arg	[arg_1] encryption ||| [arg_2] [arg_1]	count=1
arg	with length l ||| l	count=1
arg	a key ||| key new	count=1
function_arg	rewrite f as ||| rewrite single f	count=1
function	use unicode ||| use unicode	count=1
function	v ||| pure complex	count=1
function	[function_1] distance ||| [function_2] [function_1]	count=2
function	string path to a ||| get	count=1
function	lower-hessenberg form ||| lower hessenberg	count=1
arg	zero to infinity g1*g2 ||| g1 g2 x	count=1
class	given ||| integral	count=1
arg	x ||| cls x	count=1
function	a ||| groebner	count=1
class	closest rational ||| rational	count=1
module	flatten ||| physics quantum	count=1
function	creates a list ||| list	count=1
function	puiseux series for ||| rs puiseux2	count=2
arg	elements of t and ||| t	count=1
arg	of f ||| f m n	count=4
function	outer indices [function_2] ||| [function_2] [function_1]	count=2
function_arg	if key is [function_1] [arg_2] ||| categories diagram [function_1] union [arg_2] value	count=3
function_arg	[function_1] an expression ||| [function_1] surds [arg_2]	count=1
module_class	if self [class_2] ||| [module_1] [class_2]	count=4
function	fraction object to ||| qq	count=4
function	precedence ||| precedence	count=1
arg	truth value of ||| cls	count=1
function	[function_1] orbits relative ||| [function_2] [function_1]	count=2
function	constant term ||| constant term	count=3
function	print output ||| print python	count=1
module_class	[module_1] subgroup ||| [module_1] [class_2]	count=4
function	using subresultants ||| prs	count=3
arg	[arg] that ||| [arg]	count=1
function	a common [function_2] ||| [function_1] [function_2]	count=8
class	window ||| managed window	count=1
function	gray coding ||| gray	count=1
arg	two labeled ||| g	count=1
arg	for x**n == a ||| a n p k	count=1
function_arg	[function_1] no = ||| [function_1] expr [arg_2]	count=2
arg	modify ||| kwargs	count=1
arg	a [arg_2] ||| categories diagram hom [arg_1] [arg_2]	count=3
arg	convert ||| k1 a	count=4
function	[function_1] using subresultants ||| [function_2] [function_1]	count=10
arg	an expression ||| expr syms func	count=1
function	square-free norm ||| sqf norm	count=2
function_arg	generates the [function_1] [arg_2] as a permutation group ||| combinatorics [function_1] group [arg_2]	count=1
arg	[arg_1] and k1 ||| [arg_2] [arg_1]	count=4
function	hessian ||| hessian	count=1
arg	of a polynomial f ||| f minpoly p	count=1
arg	return a polynomial in ||| f	count=1
function	the atanh of ||| rs atanh	count=1
function	gray ||| gray	count=2
arg	p0 [arg_2] ||| [arg_2] [arg_1]	count=2
function	single ||| single	count=2
function	return the degree ||| degree	count=1
function	string representation ||| str	count=3
arg	function for the ||| func order match	count=2
function	[function_1] surface plot ||| plotting plot3d [function_1] [function_2]	count=1
arg	adds the index1 ||| index1	count=1
arg	expr is ||| expr assumptions	count=1
function	subresultant prs sequence of ||| subresultants	count=1
module	by the kinematic ||| physics	count=1
arg	[arg] integer ||| [arg]	count=1
arg	return namespace dict ||| namespace	count=1
function	1 instead of a ||| combine inverse	count=1
function	[function_1] power of ||| [function_1] [function_2]	count=3
arg	[arg_1] z0 ||| [arg_1] [arg_2]	count=5
arg	polynomial techniques [arg_2] ||| [arg_2] [arg_1]	count=2
arg	key matrix ||| key symbols	count=1
arg	instance ||| cls poly	count=1
arg	[arg_1] op ||| [arg_1] ops [arg_2]	count=2
function	leverage ||| try use	count=1
function	minimum of a list ||| imin	count=1
function	event loop ||| event loop	count=2
function_arg	set the [arg_2] ||| [function_1] [arg_2]	count=1
function	partition [function] ||| next [function]	count=1
arg	1 or 3 1 [arg_1] [arg_2] ||| [arg_1] [arg_2]	count=6
function	exponentiation of a series ||| exp	count=1
function	of singularity [function_2] ||| [function_2] [function_1]	count=1
function	tangent of a series ||| rs tan	count=1
function	steps for ||| steps	count=1
function	domain of the functions ||| not empty in	count=1
function	string path to the ||| get mod	count=1
function	be of the ||| process	count=1
function_arg	inverse [arg_2] ||| [arg_2] [function_1]	count=3
arg	function for ||| func order	count=2
function	given generators ||| dict from expr if gens	count=2
function_arg	[function_1] g in ||| [function_1] [arg_2]	count=3
function	deviation ||| deviation	count=1
function	of distinct real ||| count real	count=1
function	a common ending of ||| common suffix	count=1
function	ith ||| basic root	count=2
arg	floor expr ||| expr	count=1
arg	[arg_1] differential equation ||| [arg_2] infinitesimals func [arg_1]	count=4
arg	mapping in rules ||| p rules x prec	count=1
arg	by ||| arg k	count=1
class	are generated automatically ||| differential	count=1
function	orbits ||| orbits	count=2
function	coset rank of ||| coset rank	count=1
module	[module_1] self with ||| [module_1] [module_2]	count=2
function_arg	[function_1] of seq ||| [arg_2] [function_1]	count=1
function	the letter [function_2] ||| [function_2] [function_1]	count=4
class	index ||| index structure	count=1
function	the nth [function_2] ||| [function_2] [function_1]	count=2
arg	helper for _match_div_rewrite ||| g rexp	count=1
class	by an element ||| element	count=1
arg	op for the ||| op	count=1
function	norm of the vector ||| norm	count=1
arg	var occurs ||| var	count=1
module	identities from the list ||| physics quantum	count=1
function	x ||| x	count=1
function	given generators ||| if gens	count=2
function	to the traditional rules ||| traditional	count=1
function	and evaluate a ||| eval in	count=1
arg	routines in c ||| routines f prefix	count=2
function	[function] an ||| [function] function class	count=2
function	minimal polynomial of sin ||| minpoly sin	count=1
function	whose presentation ||| reidemeister presentation	count=1
class	returns a standard ||| sub module poly ring	count=1
function	of 'self' ||| sympystr	count=1
function	can be a ||| symbols2i	count=1
arg	[arg_1] p g ||| [arg_1] [arg_2]	count=3
function	a symbol and its ||| pure symbol	count=1
function	print output of ||| print	count=1
function	ode is ||| ode	count=1
arg	respect to n ||| n	count=1
arg	of the key matrix ||| key symbols	count=1
function	evaluate functional composition ||| compose	count=1
function	degree of [function_2] ||| [function_2] [function_1]	count=2
function	using pslq algorithm ||| pslq	count=1
arg	anti-derivative to [arg_2] ||| [arg_2] [arg_1]	count=3
function	solve a ||| solve	count=2
function	function is decreasing in ||| is decreasing	count=1
function	path to the ||| get mod	count=1
function	argument ||| argument	count=3
function	returns the opening statements ||| opening	count=2
function	find the ||| find	count=1
arg	finite_set is not-empty ||| finset_intersection	count=1
class	to this [class] which passes ||| [class]	count=1
function	field ||| field	count=7
arg	m ||| m size	count=1
function	coefficients using the substitution ||| coeff subs	count=1
function	transversal for [function_2] ||| [function_2] [function_1]	count=4
function	weak normal form of ||| sdm nf mora	count=1
function_arg	[function_1] modulus of ||| [function_1] f [arg_2]	count=1
arg	mobius transform or ||| k eps	count=1
function	[function] starting from ||| assoc [function]	count=1
function	returns refractive ||| refractive	count=1
function	linear ||| linear euler	count=2
arg	variable [arg_2] ||| [arg_1] [arg_2]	count=2
arg	the transformation ||| to_sys	count=1
arg	summing to n ||| n	count=1
function	return the tree as ||| tree	count=1
function_arg	[function_1] [arg_2] ||| [function_1] rsa [arg_2]	count=8
function	roots together the ||| roots	count=1
function	the number of ||| count	count=1
function_arg	lift the [arg_2] ||| [arg_2] [function_1]	count=3
function	[function_1] bound for ||| [function_2] [function_1]	count=1
class	mass ||| kanes method	count=1
function	[function] some ||| manual [function]	count=1
arg	func remains in ||| func	count=1
class	true if ||| fraction	count=2
arg	from stringpict and ||| unicode	count=1
arg	a m ||| m	count=1
function_arg	if key is in [function_1] [arg_2] to ||| [function_1] [arg_2]	count=3
class	return the homomorphism obtained ||| module homomorphism	count=1
arg	value ||| cls	count=1
function	[function_1] group method ||| [function_2] [function_1]	count=4
class	that no ||| complex root	count=1
function_arg	from positions [arg_2] ||| [function_1] syllables [arg_2]	count=1
function	the gruntz algorithm ||| gruntz	count=1
class	an ||| real	count=1
function	strictly ||| strictly	count=2
function	available ||| pretty try	count=1
arg	is [arg] default then ||| seq directed is_set [arg]	count=1
arg	when n=none), else ||| n dir	count=1
function	whether [function] an ||| [function] function class	count=1
arg	other is either ||| other	count=1
arg	is the ||| r n limits	count=1
function_arg	exp ex ||| exp ex x	count=1
function	continuous subsequence of terms ||| dmp slice	count=2
function_arg	a normal [arg_2] ||| [arg_2] [function_1]	count=1
arg	p1 with p2 in ||| p2	count=1
class	excluding those that take ||| series base	count=1
function	[function_1] index ||| [function_2] [function_1]	count=2
function	finite [function_2] ||| [function_1] [function_2]	count=1
function	series [function_2] ||| [function_2] [function_1]	count=2
function	trial division ||| dup trial division	count=2
function	compute the degree ||| degree	count=1
arg	p ||| p k	count=8
arg	of the ||| x x0 dir logx	count=1
arg	real inverse_mellin_transform ||| f s x_ strip	count=1
arg	solves a transcendental ||| eq	count=1
function	leading term ||| sdm lt	count=1
arg	supply ||| qs coneqs forcelist	count=1
arg	n ||| n t	count=1
arg	routines [arg_2] ||| [arg_1] [arg_2]	count=3
arg	to ||| modulus	count=1
function	returns polynomial gcd of ||| gcd	count=1
function	symbolic roots ||| roots	count=1
arg	i j parameters ||| i j	count=2
function	to find ||| find	count=1
class	return a sparse n-dim ||| sparse ndim	count=1
function	rotates left ||| rotate	count=1
arg	transformation used ||| to_sys	count=1
module_class	of the wave ||| physics optics twave	count=5
function	optimization ||| cse	count=1
function	this ||| lie	count=2
module	the curl [module] field computed ||| physics [module]	count=1
arg	of [arg_2] ||| [arg_1] y z [arg_2]	count=1
function	[function_1] exponent ||| [function_2] [function_1]	count=5
function	test evaluation ||| test	count=1
arg	x_j at a ||| f m a j	count=1
function	and leverage it if ||| pretty	count=1
function	ode ||| order1 type6	count=2
arg	of rank k this ||| rank	count=1
function	ratio between 2 points ||| ratio	count=1
class	of ||| type g	count=2
module	form ||| series	count=1
module	truth value ||| functions elementary	count=1
function	real univariate [function_2] ||| [function_1] [function_2]	count=1
function	the focal length ||| focal length	count=1
arg	m_1 \; [arg_2] ||| [arg_2] [arg_1]	count=8
arg	any character in phrase ||| phrase	count=1
arg	and g ||| g exps	count=1
arg	s > ||| s	count=1
function	the best solution to ||| 1st homogeneous coeff best	count=1
arg	to a numpy array ||| m dtype	count=1
module_class	the swap ||| physics quantum swap	count=1
function	the lu ||| lu	count=1
class	coset enumeration ||| coset table	count=2
module	from the ||| combinatorics	count=1
function	in finite_set in ||| in	count=1
arg	integrate [arg] over the ||| [arg] a	count=1
arg	p q [arg_2] ||| [arg_1] [arg_2]	count=2
module	function is the ||| physics quantum	count=1
arg	x by the number ||| x	count=1
arg	p where [arg_2] ||| [arg_1] [arg_2]	count=3
arg	[arg_1] representing a ||| [arg_2] [arg_1]	count=1
class	take on a ||| base	count=1
function	pendulum ||| pendulum	count=1
function	not zero and ||| zero	count=1
class	coset enumeration described ||| coset	count=2
arg	and token same ||| token	count=1
function	to ||| data tensorhead from tensmul	count=1
class	grid laid ||| diagram grid	count=1
class	should appear [class] but which ||| [class]	count=1
arg	create annihilators using ||| generator	count=1
module	tests ||| physics	count=1
module_class	implies __divmod__ ||| polys domains ring	count=1
function	return the truth value ||| eval cond	count=1
module	required for [module] this ||| [module]	count=1
function	g*h where ||| mul	count=4
arg	ith column ||| i	count=1
function	[function_1] squares ||| [function_1] [function_2]	count=3
function	that take on a ||| free	count=1
function_arg	[function_1] p ||| [function_1] edf zassenhaus f [arg_2]	count=2
function	[function] whose ||| eval berkowitz [function]	count=3
class	representation ||| table form	count=1
class	a dense matrix ||| matrix	count=1
class	the proper line ending ||| code	count=1
arg	ask system key must ||| key	count=1
function	gamma ||| gamma	count=1
arg	a point center of ||| vec point	count=1
class	linear [class_2] ||| [class_1] [class_2] perpendicular line	count=1
function	[function_1] chi ||| [function_2] [function_1]	count=4
module_class	[module_1] matrix ||| [module_1] optics ray transfer [class_2]	count=4
function	used for ||| default	count=1
function	module ||| get	count=1
function	two [function_2] ||| [function_2] [function_1]	count=2
function	dictionary from ||| dict	count=1
function	and the name of ||| mod	count=1
function	[function_1] the zero ||| [function_2] [function_1]	count=2
arg	strip given ||| strip	count=1
function	square-free factors of ||| sqf list include	count=1
arg	replaced by ||| kwargs	count=1
function_arg	addition [arg_2] ||| [function_1] [arg_2]	count=1
arg	and returns false ||| grid	count=1
arg	f g ||| f g x	count=2
function	old ||| old	count=1
arg	so that only func ||| func	count=1
class	computes ||| dmp	count=5
class	list of occupation numbers ||| fock state	count=1
function	python's fraction ||| from qq python	count=2
class	submodule ||| module quotient ring	count=1
class	n-dim array of ||| ndim array	count=2
arg	list x ||| x	count=1
arg	e and ||| e	count=1
arg	use by the ||| s	count=1
function	this [function_2] ||| [function_1] [function_2]	count=8
function	monomial ||| monomial	count=1
arg	m ||| m size g	count=1
function	with homogeneous ||| homogeneous	count=1
arg	dimensions r [arg] ||| r [arg]	count=1
class	[class_1] polynomial ||| [class_2] [class_1]	count=2
arg	selected by a path ||| func args	count=1
function	and if symbols is ||| check and join	count=1
function	evaluation of mpf tuple ||| as mpf	count=1
function_arg	normalize a [arg_2] ||| [arg_2] [function_1]	count=1
function	an expression ||| expr	count=5
class	returns the xy-pic representation ||| xypic diagram drawer	count=1
arg	[arg_1] n ||| [arg_2] a [arg_1]	count=9
function	[function_1] level ||| [function_2] [function_1]	count=1
function	coeff is the ||| coeff	count=1
module	returns the ||| physics mechanics	count=4
function	q[x] it is assumed ||| sturm pg	count=1
arg	[arg_1] j k ||| [arg_2] [arg_1]	count=1
function_arg	expression to a ||| sympify a	count=1
function	lcm of ||| lcm	count=5
class	returns ||| type g	count=1
function	[function_1] scalar ||| [function_2] [function_1]	count=2
module_class	[module_1] system ||| [module_1] dimension [class_2]	count=1
function	a new line ||| line	count=1
arg	a polynomial ||| poly	count=3
arg	register [arg_2] ||| [arg_2] [arg_1]	count=6
arg	k0 and k1 ||| k0 k1 symbols	count=3
function	the direct product of ||| mul	count=1
arg	are the actual infinitesimals ||| infinitesimals func	count=1
function	[function_1] of native ||| [function_2] [function_1] lst	count=1
arg	in a rational function ||| f	count=1
arg	[arg_1] with knots ||| [arg_1] [arg_2]	count=4
arg	in ||| f g include	count=1
class	to define this linear ||| linear	count=1
function_arg	[function_1] [arg_2] ||| [function_1] exquo f g [arg_2]	count=2
arg	import lex ||| order	count=1
function	in which the ||| empty	count=1
function_arg	this is a linear [function_1] [arg_2] order [3] ||| [function_1] [arg_2]	count=1
function	return transversals ||| transversals	count=1
arg	[arg_1] k ||| [arg_2] [arg_1]	count=12
arg	l and u ||| k reverse	count=1
class	standard basis ||| module	count=1
function	gcd of two ||| gf gcd	count=1
arg	[arg_1] o ||| [arg_1] [arg_2]	count=4
arg	\mathbb{z}_p and a list ||| evalpoints hpeval ring i	count=1
function	[function_1] of polynomial ||| [function_2] [function_1]	count=4
function	a sympy matrix ||| sympy	count=2
arg	of the form x ||| func	count=1
function	[function_1] mellin transform ||| [function_1] [function_2]	count=3
arg	[arg_1] knots ||| [arg_2] [arg_1]	count=4
function	representation of a loop ||| process loop	count=1
arg	apply rule ||| rule	count=1
function	switch to ||| connect to	count=1
module	default on the ||| physics mechanics	count=1
arg	[arg_1] i ||| [arg_2] [arg_1]	count=3
function	start ||| prefix	count=1
function	considered ||| super sub	count=1
function	jacobian matrix of a ||| jacobian	count=1
arg	as a single g ||| a	count=1
arg	:math \int_{c+i\infty}^{c-i\infty} f x ||| f x	count=1
module	returns ||| polys	count=2
function	real roots ||| count real roots	count=3
function	check if matrix is ||| is	count=1
arg	and y are ||| y	count=1
function_arg	of roots [arg_2] ||| [function_1] [arg_2]	count=6
function	returns the homogeneous ||| homogenize	count=1
function	[function_1] with ||| [function_1] [function_2]	count=5
function	matrices for ||| matrices	count=1
function	returns intrinsic impedance ||| intrinsic impedance	count=2
arg	n with [arg_2] ||| [arg_1] [arg_2]	count=1
arg	polynomial at x_0 ||| u	count=1
function	common absolute ||| common	count=1
function	solve the ||| solve as	count=1
arg	storage ||| storage	count=1
arg	or as a single ||| x a b	count=1
module	to be replaced with [module_1] [module_2] examples ||| [module_1] [module_2] differential operator function	count=1
function_arg	term [arg_2] ||| [function_1] [arg_2]	count=7
class	bounding rectangles ||| complex root of	count=1
module_class	the [class_2] ||| [module_1] [class_2] is complete	count=3
module_class	of the outer ||| physics quantum outer	count=2
function	arranged in a square ||| bifid square	count=1
arg	f by g ||| f g auto	count=6
arg	class initiated from the ||| q_ind qd_ind q_dep qd_dep	count=1
function	of eye and tensor_product ||| eye	count=1
function	symbolic values to ||| create param dict	count=1
function_arg	[function_1] [arg_2] using two-arg functor whose ||| [function_1] [arg_2]	count=29
function_arg	[function_1] of f ||| [function_1] [arg_2]	count=198
arg	a parametric ||| a t	count=1
function	the form x start ||| process	count=1
function	inverse hankel ||| inverse hankel	count=2
function	and if symbols ||| and	count=1
module	leverage ||| printing pretty	count=2
class	the ||| sparse matrix	count=2
arg	[arg_1] transformation ||| [arg_2] [arg_1]	count=2
function_arg	to [arg_2] ||| [function_1] data [arg_2]	count=2
module	returns a generator that ||| solvers	count=1
module	the generalized ||| physics mechanics	count=1
arg	and b are ||| b tolerance	count=2
arg	[arg] using a ||| [arg]	count=3
function	the object ||| free	count=1
function	x**m ||| inflate	count=1
function	quotient in gf ||| gf exquo	count=3
arg	n ||| n l hw	count=1
arg	change order of orig_vec ||| orig_vec	count=1
function	generator that is involved ||| generator	count=1
function	a finite rotation about ||| orient	count=1
arg	expression f 3 ||| f	count=1
arg	create annihilators using ||| base generator	count=1
function	radians about [function] ||| rot [function]	count=3
function_arg	[function_1] c is ||| [function_1] scalar [arg_2]	count=1
function	add efficiently ||| add	count=1
arg	limit of e ||| e	count=1
function	matrix of a specific ||| matrix	count=1
function	removes repeated ||| remove repeated	count=1
arg	terms of f ||| f m n j	count=1
function	in finite_set in ||| empty	count=1
function_arg	[function_1] p ||| [function_1] gcd f g [arg_2]	count=2
function	class ||| get	count=2
arg	[arg_1] p q ||| [arg_2] [arg_1]	count=2
function_arg	derivative [arg_2] ||| [function_1] [arg_2]	count=4
function	formal power ||| compute fps	count=1
class	push ||| plot mode base	count=2
function	[function_1] imaginary part ||| [function_1] [function_2]	count=2
class	this [class] which passes ||| [class]	count=1
function_arg	[function_1] a condition ||| [function_1] [arg_2]	count=1
arg	of a base and ||| group base	count=1
arg	g [arg_2] ||| div f [arg_1] [arg_2]	count=3
function_arg	[function_1] p with ||| [function_1] [arg_2]	count=4
function	function that helps ||| search function	count=2
function	tangent to ||| tangent	count=1
arg	[arg_1] [arg_2] repeated squaring ||| [arg_2] [arg_1]	count=2
function	dx ||| differential operators	count=2
arg	n and a b ||| n	count=1
function_arg	normal [function_1] [arg_2] ordered ||| physics quantum [function_1] [arg_2]	count=1
function_arg	[function_1] from intqubit ||| [function_1] operator int qubit [arg_2]	count=1
arg	in lex order ||| order	count=3
function	with small ||| ibin	count=1
function	at ||| call	count=1
function	derivation of an ||| derivation	count=1
function	a list into part ||| list	count=1
function	[function_1] hankel ||| [function_2] [function_1]	count=3
function	the gcd ||| gcd	count=2
class	ordered subset of the ||| subset	count=1
function_arg	sympy [arg_2] ||| [function_1] [arg_2]	count=1
module	is the ||| physics quantum	count=1
arg	string and handler a ||| handler	count=1
arg	second order ||| order	count=1
function	expr with ||| get	count=1
arg	k[x] ||| g u k	count=2
function	scalar potential [function_2] ||| [function_2] [function_1]	count=4
function	intelligently adds ||| add	count=1
module_class	[module_1] other point ||| [module_1] [class_2]	count=1
function	to values above ||| above	count=1
class	this ||| base	count=1
class	root [class_2] ||| [class_2] [class_1]	count=3
function	is monotonic in the ||| is monotonic	count=1
function	[function_1] spherical harmonics ||| [function_1] [function_2]	count=3
module	the inverse of matrix_to_qubit ||| physics quantum	count=1
arg	root if it is ||| cls root	count=1
class	dmp ||| global polynomial ring	count=2
module_class	of fractions ||| polys frac element	count=1
class	an [class] ||| [class]	count=1
module	the module ||| utilities	count=1
function_arg	[function_1] a polynomial ||| [arg_2] [function_1]	count=5
module	and ||| utilities	count=2
function	of non-zero elements in ||| nnz	count=1
module	and ||| matrices	count=1
arg	f from [arg_2] ||| [arg_1] [arg_2]	count=1
class	generate ||| quotient	count=1
arg	of orig_vec ||| orig_vec	count=1
function_arg	variations [arg_2] ||| [function_1] [arg_2]	count=1
function	[function] from the ||| [function]	count=5
module	faces of the ||| combinatorics	count=1
arg	return [arg] ||| m n [arg]	count=2
function	which when ||| named	count=1
function	use lu ||| det lu	count=2
function	default files ||| get test files	count=1
function	to a class ||| get	count=1
function	[function_1] the zero ||| [function_1] [function_2]	count=2
function	polynomial remainder in ||| rem	count=1
arg	this system of ||| x y z t	count=1
function	are structurally ||| aresame	count=1
function	length ||| morphism length	count=1
class	formats a ||| printer	count=1
function	and is ||| is simple	count=2
function	[function_1] dense ||| [function_2] [function_1]	count=4
arg	form x ||| func	count=1
function	a rational [function_2] ||| [function_1] [function_2]	count=1
function	[function_1] part ||| [function_2] [function_1]	count=8
function	new line parallel ||| parallel line	count=2
module	to self ||| agca	count=2
arg	where m is the ||| m	count=1
function	is ||| try use	count=1
function_arg	[function_1] a ||| [function_1] [arg_2]	count=45
function	of scan routine ||| scan	count=3
function	to a numpy matrix ||| to	count=1
function	* a ||| mul	count=1
function	[function_1] division ||| [function_1] [function_2]	count=2
arg	summation of [arg] with ||| [arg]	count=1
function	differentiate and evaluate ||| diff eval	count=1
function	[function_1] function with ||| [function_2] [function_1]	count=1
module	space ||| utilities	count=1
function	quadratic ternary diophantine ||| ternary quadratic normal	count=1
function_arg	lcm [arg_2] ||| [function_1] f [arg_2]	count=1
function	returns the direct ||| direct	count=1
class	a ||| poly	count=3
function	coset factorization ||| coset	count=1
function	[function_1] coefficients ||| [function_2] [function_1]	count=19
arg	if it ||| symbol gens	count=1
function	string path ||| func	count=2
arg	of a ||| a n	count=1
arg	[arg_1] in ||| [arg_2] [arg_1]	count=66
function_arg	[function_1] [arg_2] ||| [function_1] m [arg_2]	count=7
function_arg	[function_1] of gen ||| [arg_2] [function_1]	count=1
arg	n in [arg_2] ||| [arg_1] [arg_2]	count=6
arg	the given interval ||| expression interval symbol	count=6
function	column ||| col	count=1
function	z i ] == ||| commutator zgate	count=1
class	even ||| even	count=1
class	self domain ||| polynomial ring	count=1
class	qubits this gate needs ||| gate	count=1
function_arg	square-free polynomial [arg_2] ||| [arg_2] [function_1]	count=2
arg	of a diagram and ||| diagram grid	count=1
arg	of expr ||| expr	count=4
class	coordinate ||| coord	count=5
function	line ||| statement	count=1
function	the adjacency [function_2] ||| [function_1] [function_2]	count=2
function	the interval ||| interval	count=1
arg	of gen ||| gen	count=1
arg	:func _factor ||| opt method	count=1
arg	z )[x] with ||| minpoly	count=1
module	form the ||| physics mechanics	count=1
arg	g and ||| g	count=1
function	differential equation with polynomial ||| ode	count=1
arg	fpgroup h a ||| h	count=1
arg	m [arg_2] ||| ntheory symmetric residue [arg_2] [arg_1]	count=1
arg	t = i j ||| t	count=1
function	isomorphism ||| isomorphism	count=1
arg	x_j at a ||| a j	count=1
arg	a base and strong ||| group base	count=1
arg	domain of f ||| f domain	count=3
function	copy of ||| structure copy	count=1
function	form [function_2] ||| [function_2] [function_1]	count=6
function	a comment ||| comment	count=1
arg	f in the ||| f u k	count=2
arg	gr ||| gr	count=1
arg	respect to z is ||| z tol a	count=1
function	into a string path ||| mod	count=1
class	correct ||| lazy evaluator	count=1
arg	base b modulo ||| b order	count=3
class	g_2" ||| g	count=1
function_arg	[function_1] to two ||| [arg_2] [function_1]	count=2
arg	of morphisms between objects [arg_1] [arg_2] ||| [arg_1] [arg_2]	count=2
module_class	the medium ||| physics optics medium	count=4
arg	compute partial ||| f x dummies	count=1
arg	key i ||| i key	count=1
class	returns a standard ||| module poly ring	count=1
function	splitting square-free factorization given ||| sqf	count=1
function_arg	the element [arg_2] ||| [function_1] [arg_2]	count=3
class	the dimension ||| dimension	count=1
function	the frequency ||| frequency	count=1
function	monotonic in the ||| monotonic	count=1
function	only uses the mul ||| mul	count=1
module	returns the ||| series	count=1
class	isolating interval until ||| real interval	count=2
function	right [function] ||| [function]	count=1
module	equation is ||| solvers	count=2
function	quadratic ternary diophantine equation ||| ternary quadratic normal	count=1
function	asin of ||| asin	count=1
function	[function_1] strong lucas ||| [function_2] [function_1]	count=1
function	[function_1] dictionary from ||| [function_1] [function_2]	count=1
module	ranks the ||| combinatorics	count=1
function_arg	sequence in [arg_2] ||| [arg_2] [function_1]	count=1
function	the subset defined ||| subset from	count=1
function	polynomial to ||| global polynomial	count=1
function_arg	[function_1] that oth ||| [arg_2] [function_1]	count=2
function	[function_1] algebraic ||| [function_1] [function_2]	count=1
function	with ||| div	count=1
module	in the ||| physics mechanics	count=1
function_arg	square-free polynomial f ||| sqf f	count=2
function	[function_1] single ||| [function_2] [function_1]	count=1
function	a mul object ||| mul	count=1
arg	a for ||| a	count=1
module	available and ||| printing	count=1
function	order a ||| order	count=1
function	k [function_2] ||| [function_2] [function_1]	count=1
class	proper line ||| code	count=1
function	a loop [function_2] ||| [function_2] [function_1]	count=1
module	is the inverse ||| physics	count=1
arg	by a key ||| key new	count=1
function_arg	[function_1] rule ||| [arg_2] [function_1]	count=1
function_arg	prints [arg_2] ||| [function_1] [arg_2]	count=4
function	and ||| add	count=1
module	currently at ||| physics	count=1
arg	at a in k[x] ||| f m a	count=1
class	a polynomial ||| poly	count=15
class	basis ||| fixed bosonic basis	count=1
function_arg	[function_1] gens ||| [arg_2] [function_1]	count=4
arg	root v ||| v dom	count=1
module_class	of polynomial monomials ||| polys poly	count=1
function	minimal polynomial for ||| minpoly	count=1
module	the ||| geometry	count=58
class	that ||| extension	count=1
arg	checks if expr ||| expr simplified	count=1
arg	variable with ||| name sigma	count=1
class	given the ||| polyhedron	count=1
function	the angle ||| angle	count=1
function	otherwise ||| force mutable	count=1
function	of the ||| process limits	count=1
arg	composite polynomial by index ||| poly index	count=1
function	derivation of an expression ||| derivation	count=1
function	directional derivative of a ||| directional derivative	count=1
class	helper ||| dense matrix	count=2
function	euclidean polynomial [function_2] ||| [function_2] [function_1]	count=1
arg	a in ||| f m a	count=1
module	basis in ||| agca	count=1
function	add two [function_2] ||| [function_2] [function_1]	count=5
function	and ||| check and join	count=1
function	[function] in ||| dup [function]	count=3
function	a morse code ||| morse	count=1
class	integer n ||| integer	count=1
function	direction cosine between ||| direction cosine	count=2
arg	x gives the ||| b x	count=1
function	a horizontal morphism checks ||| horizontal	count=1
function	to canonical [function] storing them ||| process [function]	count=1
arg	pt1 and pt2, and ||| pt1	count=1
module	the total number of ||| liealgebras	count=1
function	reblock a ||| reblock	count=1
module	a stub to allow ||| core	count=1
function	in ||| in	count=7
function	hull surrounding ||| hull	count=1
arg	to f ||| f c i	count=1
module	solution ||| solvers	count=4
module	the beginning of ||| utilities	count=1
function	third heuristic assumes ||| lie heuristic bivariate	count=1
function	domain ||| not empty in	count=1
function	fraction object [function_2] ||| [function_2] [function_1]	count=2
arg	about :math x_0 ||| coefficient order _recur	count=1
function_arg	n [arg_2] ||| [function_1] n [arg_2]	count=5
function	each basic element is ||| element	count=1
module_class	[module_1] lcm ||| [module_1] [class_2]	count=4
function	the proper line ending ||| get statement	count=1
function	from z[x] ||| from int	count=2
arg	out ||| test compileflags out	count=1
function_arg	[function_1] a rule ||| [arg_2] [function_1]	count=1
function	if ||| pretty try use	count=2
module	form x ||| series	count=1
function	gray coding to ||| gray to	count=3
arg	of an integer n ||| n k	count=1
arg	equation eq by converting ||| eq	count=1
function	q[x] it is assumed ||| subresultants rem	count=1
function	zero polynomial ||| zero	count=1
function	second moment of ||| second moment	count=2
function	the name of ||| func	count=1
function	form x start stop ||| process	count=1
function	e^x, the inverse ||| inverse	count=1
arg	of n and ||| factors n	count=1
function	[function_1] inversion 1/p ||| [function_1] [function_2]	count=1
module	a ||| utilities	count=4
function	phrase and if symbols ||| check and join	count=1
function	gives the direction ratio ||| direction ratio	count=1
function	defined [function] ||| assoc [function]	count=1
function_arg	[function_1] free ||| [function_1] components [arg_2]	count=1
function	the input ||| sylvester	count=1
arg	returns minpoly(add(*a), dom x) ||| x dom	count=1
function	gegenbauer [function_2] ||| [function_1] [function_2]	count=1
arg	parts of an expression ||| expr	count=1
class	isolating interval [class_2] ||| [class_2] [class_1]	count=8
class	[class] not ||| [class]	count=3
module	by which the ||| geometry	count=1
arg	base and strong ||| group base gens	count=1
function	unit_propagate but ||| propagate	count=1
class	of free ||| free	count=1
arg	expression with ||| expr	count=1
class	wrappers this ||| wrapper	count=2
arg	qubit labels from the ||| labels	count=1
function_arg	d^2 [arg_2] ||| [arg_2] [function_1]	count=1
function	of crt ||| crt	count=1
arg	add the given ||| s	count=1
function	values ||| values	count=1
module	function and ||| functions elementary	count=1
function_arg	where f in ||| ground f	count=3
function	convex [function_2] ||| [function_2] [function_1]	count=3
class	with the proper line ||| printer	count=1
function	non-conjugate ||| complexes	count=1
arg	f ||| f k	count=18
function	uses the log hint ||| log	count=1
function	quadrants ||| quadrants	count=1
arg	the result of key ||| key	count=1
arg	of the line ||| x	count=1
function_arg	the coefficient [arg_2] ||| [arg_2] [function_1]	count=2
arg	divergence ||| vect	count=1
function	module and ||| get mod	count=1
function	set of operators corresponding ||| operators	count=1
arg	k-tuples of nonnegative ||| k zeros	count=1
arg	try ||| z ops0 z0	count=1
arg	keys ||| keys	count=2
arg	[arg_1] [arg_2] ||| [arg_1] p [arg_2]	count=5
arg	f and g which ||| f g exps	count=1
function_arg	leading term [arg_2] ||| [arg_2] [function_1]	count=1
function_arg	[function_1] p ||| [function_1] resultant f g [arg_2]	count=3
module_class	the [class_2] ||| [module_1] optics [class_2]	count=9
arg	modify parts [arg_2] ||| [arg_2] func args [arg_1]	count=1
function	the name of ||| get mod	count=1
function	pendulum [function_2] ||| [function_1] [function_2]	count=5
module	rectangles of ||| polys	count=1
arg	[arg_1] interval s ||| [arg_1] [arg_2]	count=2
function_arg	to rotate [arg_2] ||| [function_1] [arg_2]	count=1
module	that ||| integrals	count=2
function	above fermi? >>> ||| only above fermi	count=2
function	a list of ||| list include	count=2
function	the reduced ||| trunc	count=1
function	to a sympy expression ||| expr	count=1
function	restricted to [function_2] ||| [function_1] [function_2]	count=1
arg	returns the expression in ||| expr	count=1
function_arg	- g*h [arg_2] ||| [arg_2] [function_1]	count=8
function_arg	[function_1] of ||| [arg_2] [function_1]	count=22
function	root of x**q ||| nthroot mod1	count=1
arg	f ||| f x	count=3
function	a primary ||| primary	count=1
function	return the normalized version ||| normalized	count=1
module	the name ||| utilities	count=1
function	type of ode ||| order1	count=1
function	[function_1] number ||| [function_2] [function_1]	count=3
function	as a finite difference ||| as finite difference	count=1
function	the list of quadratic ||| quadratic	count=1
arg	m by [arg_2] ||| [arg_2] [arg_1]	count=2
arg	simplified version eq' of ||| subs exponents_only	count=1
function	logistic ||| logistic	count=1
class	the string [class] ||| [class]	count=1
function	dummy indices ||| indices	count=2
arg	in k[x] ||| f u k	count=18
function	force ||| force	count=1
function	is called the external ||| ext	count=1
arg	func remains ||| func hint	count=1
function	[function_1] odd ||| [function_1] [function_2]	count=1
class	get ||| index structure	count=1
function_arg	in gf [arg_2] ||| [arg_2] [function_1]	count=22
class	bounding rectangles ||| root of	count=1
arg	and negative ||| exprs	count=1
arg	optimization opportunities in ||| exprs order	count=1
function	see if ||| pretty try	count=1
function	polynomial quotient ||| dmp exquo	count=1
function	of distinct real ||| dup count real	count=1
function_arg	resultant of [arg_2] ||| [function_1] [arg_2]	count=3
function	objects [function] ||| qubit to [function]	count=2
arg	converts an expr ||| expr	count=1
function_arg	a where [arg_2] ||| [function_1] [arg_2]	count=18
arg	list of factors ||| factors	count=1
function	the basic [function_2] ||| [function_2] [function_1]	count=3
function	fermi? ||| fermi	count=2
function_arg	multiply tuple [arg_2] ||| [arg_2] [function_1]	count=4
arg	f by a an ||| f c	count=2
class	line ||| printer	count=1
function	loop [function_2] ||| [function_1] [function_2]	count=1
module	true if 'self' ||| sets	count=1
arg	ex1 ex2 parameters ||| ex1 ex2 x	count=2
function	primitive form of ||| dmp ground primitive	count=1
function	expression ||| expr	count=11
arg	the function f applied ||| f	count=1
function	factor a square-free ||| zassenhaus	count=1
arg	using g ||| g	count=1
function	down a tree ||| down	count=3
function	transversals relative to a ||| transversals	count=1
function	that dummies can ||| get ordered dummies	count=1
module_class	of self [class_2] ||| [module_1] [class_2]	count=2
arg	lhs - rhs but ||| lhs rhs	count=1
function	unit [function_2] ||| [function_1] [function_2]	count=1
arg	efficiently extract the ||| rational	count=7
module	function calculates the ||| physics	count=1
arg	[arg] i ||| [arg]	count=3
function	of fn -n x ||| spherical bessel fn minus	count=1
function_arg	transform of f ||| transform f	count=6
function	extended gcd ||| gcdex	count=5
function_arg	inverse of [arg_2] ||| [function_1] [arg_2]	count=2
arg	fac*g where g ||| g	count=1
function_arg	a_j [arg_2] ||| [arg_2] [function_1]	count=2
class	returns the total ||| type g	count=1
function	the generating reflections ||| generators	count=1
arg	if g ||| g ring	count=2
function	inverse using cholesky ||| eval inverse	count=2
class	group self ||| fp group	count=1
module	[module] p1) ||| [module]	count=3
module	with the proper line ||| printing	count=1
arg	by the function f ||| f	count=1
function	the minimal ||| minimal	count=1
arg	d = b ||| a b a b	count=1
function_arg	sturm sequence [arg_2] ||| [arg_2] [function_1]	count=4
function	pauli ||| pauli	count=1
function	[function] tensexpr ||| trace single [function]	count=2
arg	combinations of n items ||| n	count=1
arg	space characters to the ||| s	count=1
class	the plot ||| plot	count=2
function	run the examples ||| run	count=1
module_class	of polynomial ||| polys poly ring	count=1
arg	[arg_1] gens ||| [arg_1] [arg_2]	count=1
function	direction ||| direction	count=3
function	wrapper around ||| power exp	count=1
function	the bending [function_2] ||| [function_2] [function_1]	count=2
module	decision ||| logic algorithms	count=1
arg	the fundamental strip given ||| x strip	count=1
function	wang/eez compute ||| dmp zz wang	count=1
function	[function_1] ending of ||| [function_1] [function_2]	count=4
function	real functions ||| real	count=1
arg	x [arg_2] ||| [arg_2] [arg_1]	count=22
class	integral ||| integral	count=1
function	with sorted components ||| sorted components	count=2
function	[function_1] their coefficient ||| [function_1] [function_2]	count=1
class	[class_1] series ||| [class_1] [class_2]	count=2
function	renumber ||| renumber	count=1
arg	target [arg_2] ||| [arg_1] [arg_2]	count=1
arg	the morphisms of a ||| morphisms	count=1
module	on the input ||| combinatorics	count=1
function	polynomials in ||| dup	count=1
function	product of [function_2] ||| [function_1] as [function_2]	count=1
function_arg	basis specified [arg_2] ||| [arg_2] [function_1]	count=1
class	array ||| array	count=6
arg	the objects and the ||| objects	count=1
module	of all [module] numbers ||| [module]	count=1
module	integer ||| polys domains	count=1
function	specific ||| free	count=1
function	part of [function_2] ||| [function_2] sqf [function_1]	count=1
function	[function_1] lucas ||| [function_1] [function_2]	count=2
function_arg	according [arg_2] ||| [function_1] [arg_2]	count=1
function	closing ||| routine ending	count=1
arg	f g are ||| f g x	count=2
function	the entire free module ||| full module	count=2
arg	point center ||| vec point	count=2
arg	[arg_1] and y ||| [arg_1] [arg_2]	count=3
class	for [class] cartan matrix ||| [class]	count=1
function	returns the magnitude of ||| magnitude	count=1
module	computes the ||| combinatorics	count=2
arg	operators a global function ||| operators	count=1
module	the truth value ||| functions elementary	count=1
function	increment the ||| increment	count=1
class	bounding ||| complex root	count=1
arg	x y z ||| x y z	count=1
class	column matrix f corresponding ||| symbolic system	count=1
function	[function] of a ||| [function]	count=22
module	[module] \langle ||| [module]	count=2
arg	equation using polynomial techniques ||| domain	count=1
function	this heuristic ||| lie heuristic function sum	count=1
module	into lists [module] which successive ||| [module]	count=1
function	a homomorphism with ||| hom	count=1
function	root of a composite ||| indexed root	count=1
arg	a vector of constants ||| variable constant	count=3
function_arg	order on [arg_2] ||| [function_1] [arg_2]	count=1
arg	morphism [arg_2] ||| [arg_1] [arg_2]	count=2
function	converts a list ||| form to	count=1
function_arg	[function_1] if modulus ||| [function_1] n [arg_2]	count=1
class	list of ||| frac field	count=1
function	[function_1] surface plot ||| [function_2] [function_1]	count=1
arg	p2 in the ||| p2	count=1
function	into a string path ||| get mod func	count=1
arg	a list of the [arg_1] [arg_2] ||| [arg_1] [arg_2]	count=4
function	[function] cholesky factororization ||| row [function] symbolic	count=1
function_arg	[function_1] j ||| [function_1] [arg_2]	count=4
arg	compute f ||| f	count=1
function	a force [function_2] ||| [function_2] [function_1]	count=4
function_arg	[function_1] element ||| [function_1] [arg_2]	count=1
function_arg	in gf [arg_2] ||| [function_1] monic f [arg_2]	count=2
arg	[arg_1] i ||| crypto encipher elgamal [arg_2] [arg_1]	count=3
function	multivariate polynomials over finite ||| dmp	count=1
function	a random [function_2] ||| [function_2] [function_1]	count=5
module	the default printing ||| physics	count=1
arg	a polynomial f ||| f	count=3
arg	about c i e ||| n c condition	count=1
function	the inverse [function_2] ||| [function_1] [function_2]	count=10
arg	stringpict and binding power ||| s baseline binding unicode	count=1
class	from 'lagranges_equations' [class_2] ||| [class_2] [class_1]	count=1
arg	free and [arg_2] ||| [arg_1] [arg_2]	count=4
class	for ||| gen	count=2
module	sequence ||| polys	count=1
arg	whether u [arg_2] ||| [arg_1] [arg_2]	count=1
class	the generated files ||| fcode gen	count=1
function	of space characters ||| indent	count=1
module	x *-2 [module] 1 ||| [module]	count=1
arg	get real and ||| radicals	count=1
arg	a tensmul object ||| tensmul	count=1
function_arg	with small [arg_2] ||| [arg_2] [function_1]	count=4
class	of polynomials or containers ||| poly	count=1
class	in ||| sub	count=1
class	generate ||| quotient ring	count=1
arg	public key i ||| i key seed	count=1
class	curve is not ||| curve	count=1
arg	\int_{c+i\infty}^{c-i\infty} f x ||| f x	count=2
function	construct lagrange interpolating polynomial ||| interpolating poly	count=1
function	to replace ||| simplify	count=1
function_arg	rotate a [arg_2] ||| [function_1] [arg_2]	count=2
arg	formula ||| x0	count=1
class	of a matrix ||| matrix	count=1
function_arg	[function_1] no ||| [function_1] expr [arg_2]	count=2
function	[function_1] strong lucas ||| [function_1] [function_2]	count=1
arg	p ||| b p	count=1
class	that take ||| base	count=1
function_arg	lcm over [arg_2] ||| [arg_2] [function_1]	count=1
arg	that ||| expr	count=1
function_arg	[function_1] [arg_2] the supplied ||| [function_1] [arg_2]	count=3
arg	selected by a ||| func args	count=2
arg	x the idea for ||| x	count=1
module	printing ||| printing pretty	count=2
arg	is suitable for ||| iszerofunc simpfunc	count=1
arg	tree running it ||| fns	count=1
function	direct ||| direct	count=2
class	this matrix ||| dense matrix	count=1
arg	expression e ||| e	count=1
function	of objects ||| objects	count=1
function	total ||| total	count=1
class	data ||| element	count=3
function_arg	polynomial quotient [arg_2] ||| [arg_2] [function_1]	count=4
function	gmpy's mpq to ||| qq gmpy	count=2
function	a standard basis in ||| groebner	count=1
arg	num and ||| num	count=1
function	total degree of ||| total degree	count=2
function	possible ||| try	count=1
function	the third heuristic ||| lie heuristic	count=1
function	inverse ||| inv	count=1
function	to be the primitive ||| primitive	count=1
function	all the ||| all	count=1
function_arg	[function_1] morphism ||| [arg_2] [function_1]	count=3
function	whole [function_2] ||| [function_2] [function_1]	count=1
function_arg	when other ||| coeff mul other	count=1
function	simplified ||| simplify	count=1
arg	[arg_1] in ||| [arg_1] y z [arg_2]	count=1
function	quotient ||| quo	count=11
function	determine outer indices ||| get indices	count=2
function	common start of ||| common prefix	count=2
arg	model or not ||| expr model	count=1
module	writes a ||| utilities	count=2
module_class	[module_1] polynomial monomials ||| [module_1] [class_2]	count=2
class	limits in a ||| with int limits	count=1
arg	selected by [arg_2] ||| [arg_2] expr [arg_1]	count=1
arg	the series expansion ||| prec	count=1
module	return ||| polys agca	count=1
function_arg	degree of [arg_2] ||| [function_1] [arg_2]	count=1
function	finite_set in which ||| in	count=1
arg	convert f ||| f u	count=1
arg	of ||| f	count=7
function	number of distinct real ||| dup count real	count=1
function	central series for ||| central series	count=2
function	a class into ||| mod func	count=1
module	is ||| calculus	count=1
function	the number of partitions ||| count partitions	count=1
arg	b + sign*s and ||| cls b	count=1
function_arg	[function_1] for f ||| [function_1] [arg_2]	count=4
arg	respect to order ||| nf	count=1
function	polynomial from a polynomial ||| from poly	count=2
function	[function_1] coefficient iterator ||| [function_1] [function_2]	count=1
function	class into ||| get	count=1
function_arg	square-free norm [arg_2] ||| [arg_2] [function_1]	count=6
function	have singular initial condition ||| singularics	count=1
module	polynomial sequences of ||| holonomic	count=1
function	symbols in the ||| symbols	count=1
function	jacobi [function_2] ||| [function_2] [function_1]	count=1
function	entire free [function_2] ||| [function_2] [function_1]	count=2
function	an upper triangular ||| upper	count=1
function_arg	polynomial pseudo-division [arg_2] ||| [function_1] [arg_2]	count=2
module	quotient of ||| polys	count=1
function	normalized version of ||| normalized	count=1
class	mapping ||| mul	count=1
module	the expressions given ||| geometry	count=1
class	to a group ||| free group element	count=1
function	rotates ||| rotate	count=1
function	[function_1] homomorphism ||| [function_1] [function_2]	count=2
function	generates n-th swinnerton-dyer ||| swinnerton dyer	count=1
function	decryption ||| decipher	count=1
function	matrix of ||| matrix	count=1
function	find optimization opportunities in ||| opt cse	count=1
function	linear differential [function_2] ||| [function_1] [function_2]	count=4
arg	disjoint ||| cls complexes	count=1
function	best ||| best	count=1
function	finite_set in which the ||| not empty	count=1
function	dictionary ||| dict	count=4
class	to ||| fraction field	count=1
function	[function_1] gcd ||| [function_1] [function_2]	count=3
function	trace [function_2] ||| [function_1] [function_2]	count=1
function	compute the discrete ||| discrete	count=1
class	each entry ||| operations	count=1
function_arg	[function_1] [arg_2] omitted ||| [function_1] [arg_2]	count=8
arg	an addition expression and ||| expr	count=1
function	finds the domain ||| empty	count=1
function	compute the hankel ||| hankel	count=1
function	dynkin [function] of the ||| dynkin [function]	count=1
function	of k squares false ||| of squares	count=1
function_arg	[function_1] replaced ||| [function_1] f [arg_2]	count=3
function_arg	[function_1] and \eta ||| [function_1] [arg_2]	count=1
arg	to yield origin ||| origin	count=1
arg	canonical form if a ||| a	count=1
module_class	[module_1] an ||| [module_1] [class_2]	count=2
function	the power ||| power	count=1
arg	strip given ||| x strip	count=1
class	those morphisms [class] their ||| [class]	count=1
arg	quadratic equation eq (ax^2 ||| eq	count=1
function	a prime ||| dmp zz modular	count=1
function	new line [function_2] ||| [function_2] [function_1]	count=6
module	returns true if self ||| agca	count=2
function	[function_1] positive root ||| [function_2] [function_1]	count=2
arg	n alpha beta ||| n	count=1
function	helper function to replace ||| simplify	count=1
arg	[arg_1] targets ||| [arg_1] [arg_2]	count=1
arg	variable ||| variable	count=1
function_arg	apply a [arg_2] ||| [function_1] [arg_2]	count=1
arg	of f [arg_2] ||| [arg_1] [arg_2]	count=47
arg	[arg_1] the transformation ||| [arg_2] [arg_1]	count=2
function	of the ||| not	count=1
function	perform [function_2] ||| [function_2] [function_1]	count=2
function_arg	pseudo-quotient [arg_2] ||| [arg_2] [function_1]	count=2
arg	pairs affect ||| sym a b targetcond	count=1
arg	representation of n ||| n	count=1
arg	types [arg] integer ||| [arg]	count=1
arg	given [arg_2] ||| [arg_1] [arg_2]	count=7
class	ground domain ||| poly	count=2
function	not-empty ||| empty	count=1
class	quot ||| free	count=1
module_class	the [class_2] ||| [module_1] [class_2] tree	count=1
arg	p [x] ||| f p symmetric	count=2
function	the precedence matrix this ||| precedence matrix	count=1
module	perform the ||| physics quantum	count=2
function	indefinite integral of ||| integrate	count=3
function	raw [function_2] ||| [function_2] [function_1]	count=1
function	series ||| rs	count=4
function_arg	potential function [arg_2] ||| [arg_2] [function_1]	count=4
function_arg	polynomial pseudo-quotient [arg_2] ||| [arg_2] [function_1]	count=2
arg	convert a fraction field ||| k1 a k0	count=1
function	the mul hint ||| mul	count=1
function	of the functions ||| not	count=1
class	rectangles of non-conjugate ||| root of	count=1
function	the jacobian ||| jacobian	count=1
class	momentum ||| px bra	count=1
class	mutabledensendimarray ||| mutable dense ndim array	count=1
class	or containers ||| ring	count=1
function	[function_1] z[x] ||| [function_1] [function_2]	count=5
function	sympy matrix/complex [function_2] ||| [function_2] [function_1]	count=3
module	vector distance ||| vector	count=1
class	the module ||| module quotient ring	count=1
function	function to [function_2] ||| [function_2] [function_1]	count=2
function	of the functions in ||| not empty	count=1
function	function to expand ||| eval expand func	count=2
arg	prop ||| prop	count=1
arg	polynomials in \mathbb{z}_p[x] ||| fp gp p	count=1
arg	convert [arg_2] ||| [arg_2] [arg_1]	count=24
arg	n k -> ||| n k	count=1
function	is only ||| only	count=1
arg	of p [arg_2] ||| [arg_1] [arg_2]	count=1
class	element in the coefficient ||| element	count=1
function	a single ||| single	count=1
arg	to a second order ||| eq func order	count=1
arg	true if p ||| p	count=3
function_arg	a matrix [arg_2] ||| [arg_2] [function_1]	count=2
arg	polynomial f ||| f minpoly	count=1
function	and if ||| check and	count=1
function	module and the name ||| get	count=1
arg	an [arg_2] ||| [arg_1] [arg_2]	count=4
class	a dmf ||| dmf	count=1
function	load [function_2] ||| [function_1] ipython [function_2]	count=1
function	removes ||| remove	count=1
module	cross product [module] x ||| [module]	count=1
module	form x start stop ||| series	count=1
function_arg	[function_1] in x ||| [arg_2] [function_1]	count=6
function	gcd using subresultants over ||| rr prs gcd	count=1
class	checks ||| properties	count=2
function_arg	here [arg_2] ||| crypto encipher [function_1] [arg_2]	count=1
function	the nth jacobi polynomial ||| jacobi	count=1
arg	[inf sup] interval ||| inf sup	count=2
function	the unique [function] of multiset ||| multiset [function]	count=1
function_arg	vector for [arg_2] ||| [arg_2] [function_1]	count=1
module	the given operator ||| physics quantum	count=1
module	domain of the functions ||| calculus	count=1
function	[function_1] two ||| [function_1] as [function_2]	count=2
function	all the positive ||| positive	count=5
arg	f ||| f zero	count=1
function_arg	different types [arg_2] ||| [function_1] [arg_2]	count=1
function	of tensor product of ||| tensor product	count=2
arg	= b m ||| b	count=1
arg	small'' matrix ||| deg_f deg_g row1 row2	count=1
function	available and leverage it ||| try	count=1
arg	function which performs ||| function	count=2
function	of the denominator ||| denom	count=1
function	polynomial to [function_2] ||| [function_1] [function_2]	count=1
function	functions in ||| empty	count=1
function	operators ||| operators to state	count=1
class	of ||| sparse	count=1
class	a ||| module quotient ring	count=1
module_class	[module_1] [class_2] ||| [module_1] mechanics symbolic [class_2]	count=2
class	value ||| result	count=1
class	root it ||| root	count=1
function	increment the level of ||| increment level	count=1
class	a ||| module quotient	count=1
function_arg	[function_1] [arg_2] is '|') and words ||| [function_1] [arg_2]	count=3
arg	a function which performs ||| function	count=2
function	mul hint ||| mul	count=1
arg	and exponents ||| deep combine force	count=1
arg	in expr to estimate ||| expr	count=1
function	sequence [function_2] ||| [function_2] [function_1]	count=1
function	takes as input ||| as	count=1
arg	[arg_1] selected by ||| [arg_2] [arg_1]	count=5
class	if free ||| free	count=1
arg	a parametric representation for ||| a t	count=1
function	rotated returns ||| rotation	count=1
arg	a triangle from triangles ||| triangles	count=1
arg	a given backend return ||| backend	count=1
class	rectangles ||| complex	count=1
function	numpy/scipy sparse matrix to ||| to	count=1
arg	factors using ||| f factors k	count=1
arg	function in a ||| function	count=1
class	the point in a ||| point	count=1
function	returns [function_1] [function_2] ||| [function_1] [function_2]	count=2
function	rank of a set ||| rank	count=1
function	the functions in ||| empty	count=1
arg	constructing the string representation ||| j grid morphisms_str_info	count=1
class	grid laid out ||| diagram grid	count=1
function_arg	gcd of [arg_2] ||| [function_1] f [arg_2]	count=1
function	absolute value ||| abs	count=1
class	this method ||| series base	count=1
function	of ||| process limits	count=2
function	returns maximum norm of ||| dmp max norm	count=1
class	a list of polynomial ||| frac	count=1
function_arg	[function_1] f s ||| [function_1] [arg_2]	count=10
arg	points in the complex ||| func points	count=1
arg	function ||| variables	count=2
function_arg	pairs of [arg_2] ||| polys dmp apply [function_1] [arg_2]	count=2
function	common header for the ||| get header	count=2
arg	returns the ith column ||| i	count=1
function	index ||| index	count=8
function	sparse zero [function_2] ||| [function_2] [function_1]	count=2
function	corners ||| corners	count=1
arg	infinitesimals of ||| infinitesimals	count=1
class	[class] is ||| [class]	count=7
class	given plane ||| plane	count=1
module	in a [module] in ||| [module]	count=1
function	[function] formed by ||| [function]	count=3
function_arg	a hypergeometric [arg_2] ||| [function_1] [arg_2]	count=1
class	of subsset ||| set	count=1
function	rewrites a ||| rewrite as	count=1
function	of coefficients ||| dmp ground content	count=1
function	base exponent ||| base exp	count=2
module_class	[module_1] factors ||| [module_1] [class_2]	count=4
arg	certain coordinate [arg_2] ||| [arg_2] [arg_1]	count=4
arg	a and b, implies ||| a b	count=1
class	basis ||| sub module poly	count=1
arg	[arg_1] token same ||| [arg_2] [arg_1]	count=3
function	[function_1] finite difference ||| [function_2] [function_1]	count=1
arg	to k1 ||| k1	count=1
function	[function_1] of two ||| [function_1] as [function_2]	count=2
arg	points [arg] ||| [arg] pt2 edge	count=3
class	index pos ||| index structure	count=1
function	of phrase and if ||| and join	count=1
arg	t are ||| t	count=1
arg	[arg_1] domain ||| [arg_2] [arg_1]	count=6
module	a given vector ||| vector	count=1
module	<n|alpha> for the ||| physics	count=1
function	formats ||| get statement	count=1
function	[function_1] module of ||| [function_1] [function_2]	count=2
function	a random [function_2] ||| [function_1] [function_2]	count=5
arg	a value to or ||| value	count=1
function	of x**(i*p) mod ||| gf frobenius monomial base	count=1
arg	small'' matrix ||| deg_f deg_g	count=1
class	we can get ||| polyhedron	count=1
function	returns f + g*h ||| dmp add mul	count=1
function_arg	[function_1] names and ||| [function_1] [arg_2]	count=2
module	in the specified arbitrary ||| physics	count=1
function_arg	[function_1] [arg_2] ||| [function_1] [arg_2] r	count=3
function	conjunctions and disjunctions ||| distribute and over or	count=1
arg	isolating interval ||| s t eps	count=2
function	of ||| tensor	count=1
class	atoms of self ||| basic	count=1
function	conjunctions and disjunctions of ||| distribute or over and	count=1
function_arg	inversion 1/p [arg_2] ||| [function_1] [arg_2]	count=2
function_arg	gf [arg_2] ||| [function_1] pow mod f [arg_2]	count=3
class	this frame in ||| frame	count=1
function	polynomial gcd using subresultants ||| prs gcd	count=1
function	the resultant of ||| resultant	count=1
function	[function_1] square-free polynomial ||| [function_2] [function_1]	count=4
function	an ode ||| ode 1st homogeneous coeff	count=1
function	literal for the vsids ||| vsids	count=1
class	from ||| group element	count=1
function_arg	normal ordered [function_1] [arg_2] ||| [function_1] [arg_2]	count=1
module	total number of ||| liealgebras	count=1
function	get a dict mapping ||| get	count=1
function	arranged in a ||| bifid	count=1
arg	[arg_1] [x]/ ||| [arg_2] g [arg_1]	count=1
function	f + a ||| add	count=1
function	and if ||| check and join	count=1
arg	factors ||| factors	count=5
arg	[arg_1] floor expr ||| [arg_2] [arg_1]	count=2
class	group self ||| group	count=1
arg	z [arg_2] ||| [arg_2] [arg_1]	count=1
function	system using lusolve and ||| solve linear system lu	count=1
function_arg	intersection [arg_2] ||| [function_1] [arg_2]	count=1
arg	f ||| f gen	count=2
module	files ||| utilities	count=2
function	x**(i*p) mod ||| gf frobenius monomial base	count=1
arg	of a in ||| series_rs a	count=1
class	diagram ||| diagram grid	count=3
function	loop ||| loop	count=2
function	continuous ||| continuous domain	count=1
class	c matrix of ||| sparse matrix	count=1
function_arg	jacobian matrix [arg_2] ||| [arg_2] [function_1]	count=1
class	gcd removed from each ||| factors	count=1
class	of ||| frac field	count=1
arg	x_0 of a polynomial ||| u	count=1
function_arg	[function_1] f by ||| [function_1] ground [arg_2]	count=2
class	a specific ||| base	count=1
function	[function_1] to y_i ||| [function_1] [function_2]	count=1
arg	factors using ||| f factors	count=1
function	extra [function_2] ||| [function_1] [function_2]	count=4
function_arg	[function_1] base ||| [arg_2] [function_1]	count=5
arg	f in k[x] ||| f n u k	count=2
function	subset defined ||| subset from	count=1
module	a class into ||| utilities	count=1
function	from a list ||| interpolate	count=1
arg	[arg_1] a ||| integrals simplifyconds expr [arg_1] [arg_2]	count=1
function	[function_1] a primary ||| [function_1] [function_2]	count=1
module	field ||| diffgeom	count=2
arg	to t ||| d t	count=1
class	[class] of ||| [class]	count=6
function	computing i^e (mod n), ||| rsa	count=1
function	at an ordinary point ||| ordinary	count=1
arg	denests a list of ||| av0 h max_depth_level	count=1
function	and recursively strip it ||| dmp validate	count=1
module	are expected to ||| logic algorithms	count=3
function	constant [function_2] ||| [function_1] [function_2]	count=7
arg	base and strong generating ||| base gens	count=1
arg	polynomial irreducibility ||| f p	count=1
arg	for the default ||| parameter	count=3
class	of this ||| matrix	count=1
arg	creates a small'' ||| deg_f	count=1
function	list from ||| list	count=1
class	integer n in lexical ||| integer	count=1
function	[function] partition ||| [function]	count=2
function	fraction to ||| fraction	count=1
function	constant ||| constant	count=7
function	finite_set in ||| not	count=1
arg	field computed along a ||| vect	count=1
arg	[arg_1] dum ||| [arg_2] [arg_1]	count=1
module	integration algorithm ||| integrals	count=1
arg	e z [arg_2] ||| [arg_1] [arg_2]	count=1
arg	convert ||| k1	count=28
function	centralizer of ||| centralizer	count=1
arg	a, d = b ||| b a b	count=1
function	inverse ~a of ||| af invert	count=1
function	[function_1] group ||| [function_2] [function_1]	count=4
function	the asin ||| asin	count=1
function	class ||| mod func	count=2
arg	algorithm ||| f	count=1
arg	of alpha ||| alpha pairs	count=1
arg	the expression to canonical ||| expr	count=1
function_arg	[function_1] running it ||| [function_1] [arg_2]	count=3
arg	other ||| other	count=16
arg	each other ||| other	count=1
class	bounding rectangles ||| complex	count=1
module	system about the ||| physics	count=1
arg	arg into ||| arg	count=1
function	for ||| check cg simp	count=1
function	function class ||| function class	count=2
function	[function_1] groebner basis ||| [function_2] [function_1]	count=1
arg	scalar field computed along ||| scalar vect	count=1
function	test ||| test	count=4
arg	of f s over ||| f s	count=1
class	those that ||| series	count=1
arg	the limit of e ||| e	count=1
function	number of syllables ||| number syllables	count=1
function_arg	[function_1] x ||| [function_1] p [arg_2]	count=4
function	in which the ||| empty in	count=1
module_class	of the ellipse ||| geometry ellipse	count=1
function	the inverse [function_2] ||| [function_2] [function_1]	count=10
function	to a [function_2] ||| [function_2] [function_1]	count=14
arg	terms of f ||| f m n k	count=1
arg	[arg_1] in ||| [arg_1] p [arg_2]	count=3
function	sum of [function_2] ||| [function_1] [function_2]	count=3
class	returns ||| module poly ring	count=2
function	best solution to ||| coeff best	count=1
class	generators ||| implemented ideal	count=1
function	left ||| left	count=2
function	the square-free [function_2] ||| [function_2] [function_1]	count=4
function_arg	[function_1] [arg_2] ||| [function_1] similar [arg_2]	count=2
function	in a piecewise ||| piecewise	count=1
module	are generated automatically ||| integrals	count=1
class	an element ||| generalized polynomial	count=1
function	matrix is [function_2] ||| [function_2] [function_1]	count=1
function	computes a transversal ||| transversal	count=2
function	transversal ||| transversal	count=2
arg	[arg_1] a log-normal ||| [arg_2] [arg_1]	count=1
function	sum ||| do sum	count=1
function	rewrites a ||| eval rewrite	count=1
function	[function_1] list ||| [function_1] sympy [function_2]	count=1
function	with sorted ||| sorted	count=1
function_arg	modularinteger int [arg_2] ||| [function_1] [arg_2]	count=1
arg	[arg_1] defined as ||| [arg_2] [arg_1]	count=2
arg	and for each di ||| a d de	count=1
module	is the inverse ||| physics quantum	count=1
arg	[arg_1] == j ||| [arg_2] [arg_1]	count=1
function	[function_1] in "x" ||| [function_2] [function_1]	count=4
function	sympy ||| get sympy	count=1
function	it if possible ||| try	count=1
function	wrapper of crt ||| crt	count=1
arg	a condition [arg] given a ||| condition [arg]	count=1
function	to correct ||| correct	count=1
class	vertices of the polygon ||| polygon	count=1
function	integer representation ||| pure symbol int repr	count=1
arg	source ||| source	count=1
arg	_match_div_rewrite ||| g rexp	count=1
function	symbol [function_2] ||| [function_2] [function_1]	count=4
function	as [function] false ||| needs [function]	count=1
arg	(i ||| dom_i dom_j cod_j grid	count=1
arg	is suitable for a ||| iszerofunc simpfunc	count=1
function	leverage it if possible ||| pretty try use	count=1
arg	a frame ||| frame	count=1
arg	model ||| expr model deep	count=1
function_arg	[function_1] in x_0 ||| [function_1] [arg_2]	count=1
class	tensor [class] ||| [class]	count=1
arg	return the series expansion ||| p x prec	count=4
class	for the ||| code gen	count=1
arg	of alpha as a ||| degree generators alpha pairs	count=1
class	this method returns ||| base	count=1
function_arg	inverse cos [arg_2] ||| [function_1] [arg_2]	count=2
function_arg	[function_1] for ||| [function_1] f [arg_2]	count=1
function_arg	minimal [arg_2] ||| [function_1] bsgs [arg_2]	count=1
arg	n and either ||| n	count=1
function	perform a rl ||| rl	count=1
arg	a field in k[x] ||| g u k	count=1
function	return the lower central ||| lower central	count=1
function	convert from a sympy ||| sympy	count=1
function	heuristic finds if ||| heuristic	count=1
class	on a ||| base	count=1
arg	the seq ||| seq	count=1
arg	and y [arg_2] ||| [arg_2] [arg_1]	count=5
function	matrix multiplication ||| mat mul	count=1
class	the object excluding ||| series base	count=1
arg	supply the following for ||| qs coneqs forcelist	count=1
function_arg	denest [arg_2] ||| [function_1] [arg_2]	count=1
arg	[arg_1] rhs but ||| [arg_2] [arg_1]	count=1
function	[function_1] lu the ||| [function_2] [function_1]	count=1
module_class	[module_1] [class_2] on ||| [module_1] [class_2]	count=4
arg	b m + b, ||| b	count=1
function	fermi? >>> from ||| fermi	count=2
arg	series expansion ||| a prec	count=1
function	to ||| from tensmul	count=1
module	of space ||| utilities	count=1
function_arg	the extension [arg_2] ||| [arg_2] [function_1]	count=1
function	sympy number ||| sympy	count=2
arg	f given ||| f	count=2
arg	p parameters ||| p	count=1
arg	k [arg_2] ||| [arg_1] [arg_2]	count=3
arg	to value ||| value	count=1
class	to gmpy's ||| gmpyinteger ring	count=1
class	coset enumeration described ||| coset table	count=2
function	lucas [function_2] ||| [function_1] [function_2]	count=2
function	non-negative ||| nonnegative	count=5
function	asin of p, ||| asin	count=1
arg	new instance ||| cls	count=1
function_arg	length [arg_2] ||| [arg_2] [function_1]	count=2
arg	checks if a field ||| field	count=3
function	the nth root of ||| nth root1	count=1
function_arg	[function_1] 'other' ||| [function_1] [arg_2]	count=1
function	components the sorting ||| components	count=1
arg	mathml representation [arg] ||| [arg]	count=1
function	of coefficients ||| content	count=2
module	symbolic ||| core	count=1
arg	[arg_1] to k[x][y] ||| [arg_2] [arg_1]	count=1
function_arg	[function_1] a in ||| [arg_2] [function_1]	count=4
module	vector distance between ||| vector	count=1
arg	a mod [arg] to an ||| a [arg]	count=1
function	[function_1] non-negative ||| [function_1] [function_2]	count=2
function	values below ||| is below	count=1
function	[function_1] there is ||| [function_2] free space [function_1]	count=2
arg	subtracting [arg_2] ||| [arg_1] [arg_2]	count=4
function	checks whether there is ||| check	count=2
class	[class_1] stringpicts ||| [class_1] [class_2]	count=3
arg	irreducibility ||| p	count=1
module	a standard ||| polys agca	count=1
module	beginning ||| utilities	count=1
function	equation with constant ||| constant coeff	count=1
function_arg	push a function ||| push solid function	count=1
arg	are independent [arg] knowledge of ||| [arg]	count=1
function	to ||| mod func	count=2
function	list into ||| list	count=1
function	the first derivative ||| fdiff	count=1
arg	the commutation parameter c ||| c	count=1
function	[function_1] [function_2] of the ||| [function_1] [function_2]	count=12
function	exact quotient by ||| dmp exquo	count=1
arg	b split should be ||| l split	count=1
function	classes to ||| to state	count=1
function	a functional decomposition of ||| decompose	count=1
arg	[arg_1] y are ||| [arg_2] [arg_1]	count=1
function	merge [function_2] ||| [function_1] [function_2] matadd	count=1
function	available ||| use	count=1
function	compute polynomial trace map ||| trace map	count=1
function	unify representations of ||| unify	count=1
arg	replaced ||| args kwargs n	count=1
arg	infinity g1*g2 ||| g1 g2	count=1
function	sympy ||| parse	count=1
class	to ||| generalized polynomial ring	count=1
arg	using vincent-akritas-strzebonski vas ||| f k eps inf	count=1
arg	+ sign*s this ||| sign	count=1
function	a scalar multiple ||| scalar multiple	count=2
arg	adds muls pows ||| order verbose	count=1
function	test evaluation [function_2] ||| [function_1] [function_2]	count=2
class	something ||| domain	count=4
arg	given a triangle and ||| triangle	count=1
function	root of p if ||| root	count=1
function	path to the module ||| func	count=1
arg	replaced by the ||| args kwargs n	count=1
module	mapping of symbolic ||| printing	count=1
function	intended ||| vv	count=1
class	the c [class_2] ||| [class_2] [class_1] simple root	count=2
module	of ||| liealgebras	count=2
function	[function] by ||| [function]	count=1
function	mathematica [function] examples ||| mathematica [function]	count=1
function	[function_1] [function_2] ||| [function_2] free space [function_1]	count=12
arg	the factors has ||| factors x	count=1
arg	a dmp out of ||| kill	count=1
function_arg	sine [arg_2] ||| [arg_2] [function_1]	count=2
function	unicode output is available ||| unicode	count=1
function	homogeneous coefficients ||| homogeneous coeff	count=2
module	to a class ||| utilities	count=1
function	and evaluate a polynomial ||| eval in	count=1
arg	solve for the partial ||| hint	count=1
function	solve ||| solve as	count=1
function	the delta ||| delta	count=1
arg	at x = a ||| a	count=1
arg	in x ||| b x	count=1
function_arg	puiseux series [arg_2] ||| [arg_2] [function_1]	count=5
module	return the ||| functions	count=1
arg	try to eliminate x_0 ||| u k	count=1
class	proper ||| printer	count=1
arg	[arg_1] point z0 ||| [arg_2] [arg_1]	count=5
function	self to [function_2] ||| [function_2] [function_1]	count=2
module	integration using any ||| integrals	count=1
function_arg	[function_1] a scalar ||| [function_1] [arg_2]	count=4
function	path to the module ||| mod	count=1
function	above fermi? >>> from ||| above fermi	count=1
arg	the following -- a ||| density set	count=1
arg	p [x] polynomial ||| f p symmetric	count=2
function	returns the symbols ||| symbols	count=1
arg	width ||| width	count=1
function	into a ||| get mod	count=1
function	components and ||| and	count=1
module	the get_dim ||| physics	count=1
arg	expressions into ||| exprs	count=1
arg	be ||| func	count=1
arg	instance ||| cls poly func auto	count=1
arg	construct ||| cls rep opt	count=3
arg	always in terms of ||| x n logx	count=1
class	wrappers this file ||| wrapper	count=2
function	switch to ||| to	count=1
arg	node count of e ||| e	count=1
arg	is appropriate for this ||| name expr argument_sequence global_vars	count=1
module	logic ||| logic	count=1
module	any hints ||| integrals	count=1
function_arg	linear [arg_2] ||| [arg_2] [function_1]	count=1
arg	apply f ||| f atoms	count=1
function_arg	orbit of [arg_2] ||| [function_1] transversal [arg_2]	count=8
function	the velocity ||| vel	count=1
class	the polynomial [class_2] ||| [class_2] [class_1]	count=1
function	and the name of ||| get	count=1
module	bifid cipher ||| crypto	count=1
function	primitive form ||| primitive	count=3
function	of motion ||| comb	count=1
function	number [function_2] ||| [function_2] [function_1]	count=2
function_arg	groups [arg_2] ||| [arg_2] [function_1]	count=3
arg	expression or latex markup ||| expr	count=1
class	the object excluding ||| base	count=1
function	digamma function is the ||| digamma	count=1
module	the added integration constant ||| physics vector	count=1
function_arg	bivariate integer [arg_2] ||| [function_1] [arg_2]	count=1
function	[function_1] power ||| [function_2] [function_1]	count=4
module	returns the ||| physics	count=12
function_arg	gcd of a ||| gcd a	count=13
arg	k0 and [arg_2] ||| [arg_1] [arg_2]	count=1
class	get ||| of	count=1
arg	first order differential equations ||| order match	count=1
function	the expression ||| expr	count=2
function	apply additional [function_2] ||| [function_2] [function_1]	count=1
module_class	[module_1] integer n ||| [module_1] [class_2] partition	count=1
function	returns the coefficient from ||| coeff	count=1
function	return square-free [function_2] ||| [function_2] [function_1]	count=3
function	part ||| part	count=8
function	gauss-chebyshev ||| chebyshev u	count=1
class	whose elements ||| partition	count=1
function	differential equation with constant ||| constant	count=2
arg	and ||| a	count=1
function	that ||| search	count=1
function	is a ||| is	count=31
function	the best solution to ||| best	count=1
arg	of f ||| f k	count=10
function	into it's matrix ||| matrix	count=1
class	data ||| data	count=2
function_arg	[function_1] bits ||| [function_1] n [arg_2]	count=1
class	set the components data ||| data lazy	count=1
function	computes polynomial lcm over ||| ff lcm	count=1
function	ode are ||| linear 2eq order1 type3	count=1
function	dot product [function_2] ||| [function_1] [function_2]	count=3
arg	using formula ||| iv	count=1
function_arg	in [arg_2] ||| [arg_2] [function_1]	count=11
class	symbolic ||| code	count=1
class	method to ||| kanes method	count=1
arg	of the factors ||| factors x	count=1
class	also known [class] 'rotation ||| coord [class]	count=1
function_arg	coefficients of [arg_2] ||| [arg_2] [function_1]	count=3
class	single basis ||| var bosonic basis	count=2
class	swap gate ||| swap gate	count=2
class	returns a ||| sub	count=1
class	system ||| unit system	count=2
arg	writer function [arg_2] ||| [arg_2] [arg_1]	count=2
function	b ||| b	count=1
function	a nested tuple of ||| to tuple	count=1
function	of the class ||| get mod	count=1
arg	[arg_1] [arg_2] ||| [arg_2] free [arg_1]	count=6
module	return a list of ||| polys	count=3
class	from 'lagranges_equations' method ||| lagranges method	count=2
function	raw ||| raw	count=1
function	instance of the linearizer ||| to linearizer	count=1
function	[function_1] root of ||| [function_2] [function_1]	count=9
function	[function_1] as ||| [function_2] [function_1]	count=6
function_arg	[function_1] e ||| [function_1] [arg_2]	count=4
arg	expression or ||| expr	count=1
arg	j_2 m_2 [arg_2] ||| [arg_2] [arg_1]	count=1
function	[function_1] potential difference ||| [function_1] [function_2]	count=3
arg	returns true if f ||| f k	count=1
function	this heuristic finds ||| lie heuristic	count=2
function	method of undetermined coefficients ||| coeff undetermined coefficients	count=1
arg	a ||| a b	count=8
function	[function_1] lu ||| [function_1] [function_2]	count=1
function	in a fourier ||| fourier	count=1
function	the ||| mod func	count=4
function	redirect an ||| operator	count=1
class	no bounding rectangles of ||| of	count=1
class	of the linearentity ||| linear	count=1
function_arg	[function_1] equation eq ||| [arg_2] [function_1]	count=1
function	reduce a k[x] ||| dup trunc	count=3
module	the simplified list of ||| physics quantum	count=1
function	point of ||| point	count=1
function	reduced to ||| reduced	count=1
module	for the initialization ||| physics mechanics	count=1
class	generate a ||| poly	count=1
function	coefficient of [function_2] ||| [function_2] [function_1]	count=4
arg	at x = a ||| a k	count=1
function	inoutargument and result ||| result	count=1
function	terms ||| hyper as	count=1
class	transform in ||| integral transform	count=1
class	the ||| sparse	count=1
arg	\frac f [arg] ||| f [arg]	count=3
function	a string path to ||| get mod	count=1
function	the direction ratio of ||| direction ratio	count=1
arg	x prec ||| x prec	count=2
function	subset defined by ||| subset from	count=1
module	values that ||| solvers	count=1
function	[function_1] real ||| [function_2] [function_1]	count=3
arg	a rule ||| rule fns	count=1
class	to the [class] ||| fact [class]	count=1
class	[class_1] n-dim array ||| [class_2] [class_1]	count=2
function_arg	gf [arg_2] ||| [function_1] edf zassenhaus f [arg_2]	count=3
function	matrix to change order ||| matrix	count=1
function	is available ||| pretty try use	count=1
function	use the berkowitz algorithm ||| berkowitz	count=1
function	equations ||| implicit mat	count=1
function	what intervals the expr ||| sort expr	count=1
function	polynomial ||| as poly	count=2
arg	a [arg] ||| [arg]	count=5
arg	corresponding to i i ||| i	count=1
arg	mod [arg] that ||| [arg]	count=1
function	monomials ||| monomial	count=2
class	value of the ||| piecewise	count=1
function	treated as an ||| as	count=1
function	quadratic ternary diophantine ||| diop ternary quadratic	count=1
arg	meijer g [arg] parameters func, ||| [arg]	count=1
arg	and y ||| y pt	count=2
module	this function calculates the ||| physics	count=1
class	element from a sparse ||| sparse	count=1
function	[function] self ||| [function]	count=4
module	self ||| agca	count=26
arg	with another ||| other	count=1
function_arg	return a transversal of [function_1] [arg_2] the second method described ||| [function_1] [arg_2]	count=2
arg	2-d point about ||| th	count=1
arg	provided p is ||| p	count=1
arg	given the objects ||| objects	count=1
module_class	of a [module_1] [class_2] ||| [module_1] [class_2]	count=4
class	return ||| complex	count=1
function	hint see the expand ||| expand	count=2
function	the sturm sequence of ||| sturm	count=2
arg	an euler-maclaurin approximation ||| eps eval_integral	count=1
arg	variable with a beta ||| name alpha beta	count=1
arg	switch to ||| native zero	count=1
function	a series ||| rs series	count=1
function	of symbolic values ||| create param	count=1
arg	and d ||| d	count=1
class	in a ||| permutation	count=2
arg	limit of e z ||| e z	count=1
function	returns the first derivative ||| fdiff	count=1
class	an ||| expr	count=2
function	polynomial to ||| to	count=1
module_class	[module_1] free group ||| [module_1] [class_2]	count=2
module	split ||| physics quantum	count=2
arg	limits should be ||| limits	count=1
function	independent generators ||| basis	count=5
function	constants ||| variable	count=1
class	a standard basis ||| poly ring	count=1
module	the positions ||| combinatorics	count=2
function	bounding rectangles of ||| refine	count=1
arg	in storage ||| storage	count=1
function	real roots [function_2] ||| [function_1] [function_2]	count=3
function_arg	rational numbers [arg_2] ||| [arg_2] [function_1]	count=1
class	to ||| python rational field	count=1
class	return ||| root	count=1
arg	f and g ||| f g k	count=6
class	truth ||| piecewise	count=1
function	each coordinate of self [function_1] [function_2] ||| geometry point [function_1] [function_2]	count=14
arg	d with [arg_2] ||| [arg_2] [arg_1]	count=4
arg	a given two ||| other	count=1
arg	given an interval s ||| s	count=1
module	into a ||| utilities	count=1
arg	points in the complex ||| points	count=1
function	linear equation ax + ||| linear	count=1
arg	x_j at a ||| m a j	count=1
function	wang/eez test [function_2] ||| [function_1] [function_2]	count=2
function	coefficients [function_2] ||| [function_1] [function_2]	count=2
function	coefficients using [function_2] ||| [function_2] [function_1]	count=2
function	which is preferred to ||| preferred	count=1
arg	with value ||| query value	count=1
function	maximal degree for each ||| max	count=1
function_arg	[function_1] self other ||| [arg_2] [function_1]	count=2
arg	representing ||| n p succ	count=1
module	in ||| calculus	count=2
function	in finite_set in which ||| empty in	count=1
module	permutation ||| combinatorics	count=6
function	always destroy a ||| is only q annihilator	count=1
function	symbols of ||| symbols	count=1
module	a, implies ||| polys domains	count=1
function	[function_1] [function_2] ||| [function_2] log [function_1]	count=5
function	heuristic assumes the ||| heuristic	count=1
function	always destroy a ||| only q annihilator	count=1
class	linearentity ||| entity	count=1
class	of the meijer g-function ||| meijerg	count=1
function_arg	generators in [arg_2] ||| [arg_2] [function_1]	count=1
module	helper function for ||| series	count=1
function_arg	[function_1] [arg_2] ||| [function_1] vec [arg_2]	count=6
class	polynomials or containers of ||| poly	count=1
function	dict representation ||| dict	count=1
arg	a model or ||| model deep	count=1
function	orbits relative ||| orbits	count=1
function	free [function_2] ||| [function_2] [function_1]	count=11
function	[function_1] a raw ||| [function_2] [function_1]	count=1
function	direct products ||| direct product	count=1
function	cyclotomic polnomial ||| cyclotomic	count=1
arg	the point z0 ||| z0 dir	count=1
arg	of factors using ||| f factors	count=1
function	of a series ||| rs series	count=1
function	element is ||| element	count=1
function	the module ||| func	count=1
class	algebraic number ||| anp	count=1
function	permuted indices ||| permuted	count=1
function	reconstruct [function_2] ||| [function_2] [function_1]	count=8
function	[function_1] finite ||| [function_1] [function_2]	count=1
function	best solution to an ||| best	count=1
function	full [function_2] ||| [function_1] [function_2]	count=2
function	homogeneous [function_2] ||| [function_1] [function_2]	count=5
arg	namespace dict with ||| expr namespace	count=1
function	term has a non-integer [function_1] [function_2] ||| [function_1] [function_2]	count=4
function	the truth value ||| eval	count=1
function	of the symbols in ||| constant symbols	count=1
arg	is replaced ||| args kwargs	count=1
function_arg	concatenates [arg_2] ||| [arg_2] [function_1]	count=2
function	[function_1] real roots ||| [function_2] [function_1]	count=3
arg	m [arg_2] ||| [arg_2] [arg_1]	count=1
function	returns the scalar potential ||| scalar potential	count=1
module_class	[module_1] along ||| [module_1] [class_2]	count=4
class	given dummy variables ||| expr	count=1
function	matches ||| nth	count=1
function	which gives the taylor ||| 1st	count=1
function	bound for univariate ||| bound	count=1
function_arg	[function_1] [arg_2] ||| [function_1] terms [arg_2]	count=4
function	generates gegenbauer [function_2] ||| [function_1] [function_2]	count=1
arg	x_j ||| n j	count=1
function_arg	handling functions [arg_2] ||| [arg_2] [function_1]	count=1
class	those that ||| base	count=1
module	are expected to be ||| logic algorithms	count=3
function	coefficients using [function_2] ||| [function_1] [function_2]	count=2
function	a set of equivalent ||| equivalent	count=1
function_arg	generates [function_1] [arg_2] as a permutation group ||| combinatorics [function_1] group [arg_2]	count=1
arg	[arg_1] representing a ||| [arg_1] [arg_2]	count=1
function	add two roots ||| add	count=1
class	in ||| permutation	count=2
class	affine [class] containing ||| [class]	count=1
arg	power ||| power	count=1
function	of classes ||| class key	count=1
arg	token ||| token	count=1
arg	a key ||| key	count=1
function	construct a minimal ||| unify	count=1
function_arg	[function_1] [arg_2] ||| [function_1] cse [arg_2]	count=1
function	the index of a ||| index	count=1
function_arg	a polynomial f ||| poly f ring	count=1
module	excluding ||| series	count=1
class	[class_1] system examples ||| [class_2] [class_1]	count=1
module	find optimization opportunities in ||| simplify	count=1
function	as a matrix if ||| matrix	count=1
function	eye ||| eye	count=1
function	precedence of ||| precedence	count=1
arg	self where m is ||| m	count=1
function	the ||| in	count=3
function	with ||| statement	count=1
function_arg	bernoulli [arg_2] ||| [arg_2] [function_1]	count=1
module	return [module_2] ||| [module_2] [module_1]	count=1
function	number ||| indent	count=1
module	those args [module] *are* exprs ||| [module]	count=1
function	constant coefficients using the ||| constant coeff	count=1
arg	base and ||| base gens	count=2
function_arg	of gcd [arg_2] ||| [function_1] [arg_2]	count=3
arg	[arg_1] pt ||| [arg_1] [arg_2]	count=4
function	new line ||| line	count=1
module	that [module] ||| [module]	count=1
function	of real [function_2] ||| [function_1] [function_2]	count=2
function	of symbolic values ||| create param dict	count=1
arg	string containing prec ||| prec	count=1
class	appear [class] ||| [class]	count=1
function_arg	[function_1] [arg_2] ||| [function_1] transversal [arg_2]	count=25
function	devise a [function_2] ||| [function_1] [function_2]	count=3
class	fraction ||| fraction	count=1
class	compute ||| poly ring	count=1
arg	or set of operators ||| operators	count=1
function	convert a zero matrix ||| matrix	count=1
class	c matrix ||| sparse matrix	count=1
class	[class_1] of expression ||| [class_2] [class_1]	count=2
function	that dummies can be ||| get ordered dummies	count=1
arg	checks if df ||| df	count=1
function	represent ||| represent	count=2
arg	for constructing the string ||| morphisms_str_info	count=1
function_arg	to couple [arg_2] ||| [function_1] [arg_2]	count=3
function_arg	pairs [arg_2] ||| [arg_2] [function_1]	count=2
arg	x y [arg_2] ||| [arg_2] [arg_1]	count=4
function	of bit vectors in ||| selections	count=1
arg	in s, ||| s	count=1
function	return a multivariate ||| dmp	count=2
function	nested tuple of ||| dmp to tuple	count=1
function	row-sorted ||| row	count=1
arg	[arg_1] first order ||| [arg_1] [arg_2]	count=4
arg	true if [arg] ||| [arg]	count=1
function	dictionary, [function] ||| [function] dict	count=3
function	[function_1] using lusolve ||| [function_2] [function_1]	count=1
arg	where other ||| other	count=3
arg	n [arg_2] ||| [arg_1] a [arg_2]	count=2
class	root it ||| root system	count=1
function	positional [function_2] ||| [function_2] [function_1]	count=1
function	a continuous ||| continuous	count=1
function	[function_1] products ||| [function_1] [function_2]	count=1
arg	apply do to ||| do	count=1
function	find_unit_clause ||| clause	count=1
arg	[arg_1] row ||| matrices rowadd [arg_2] [arg_1]	count=3
module	bounding rectangles of non-conjugate ||| polys	count=1
function_arg	norm [arg_2] ||| [function_1] [arg_2]	count=14
function	coding to ||| to	count=2
function	[function_1] the derivative ||| [function_2] [function_1]	count=2
arg	gf_pow_mod f p g ||| f g b	count=1
function	in terms ||| hyper as	count=1
arg	welds ||| welding_edge	count=1
function	n-link pendulum on a ||| n link pendulum on	count=1
function_arg	[function_1] parameter c ||| [function_1] comm i j [arg_2]	count=1
class	for the ||| method	count=1
function	symbols in ||| constant symbols	count=1
function	[function_1] sort of ||| [function_1] [function_2]	count=1
function	from dmp to ||| from	count=1
function	a polynomial ||| old poly	count=1
arg	x_j in k[x] ||| j	count=1
function	numbers c ||| comms	count=1
module	matrix sum of ||| matrices	count=1
function	[function_1] impedance ||| [function_2] [function_1]	count=2
arg	[arg_1] in ||| [arg_1] symbols [arg_2]	count=2
function	given function [function_2] ||| [function_1] [function_2]	count=1
arg	function target to ||| target	count=1
module	symbolic ||| printing	count=1
arg	can be used to ||| zeros	count=1
arg	q**n * f(p/q) ||| p q	count=1
arg	in ||| f p u	count=1
function_arg	[function_1] [arg_2] ||| [function_1] name p succ [arg_2]	count=2
arg	result of key ||| key	count=1
function	of rotational gradients ||| rot grad	count=1
function	of the ground domain ||| ground	count=3
arg	mod(p** s + 1 ||| s p	count=1
function	where \gcd ||| cornacchia	count=1
arg	a [arg_2] ||| [arg_1] [arg_2]	count=50
module	module and the name ||| utilities	count=1
arg	k[x][y] ||| u k front	count=1
class	c matrix of ||| matrix	count=2
function	in terms of ||| in terms	count=1
function	dummies ||| get ordered dummies	count=1
function	the log ||| log	count=1
arg	expression ||| expr condition evaluate	count=1
arg	if it is ||| symbol gens	count=1
arg	returns an ||| expr	count=2
arg	s, ||| s	count=1
arg	q are polynomials ||| q x method	count=2
arg	on [arg] elements as ||| [arg]	count=1
class	a ||| printer	count=1
module	return terms of ||| core	count=1
class	the integration using ||| integral	count=1
arg	model ||| expr model	count=1
class	gcd removed from ||| factors	count=1
class	standard basis in ||| module poly ring	count=1
function	of the functions ||| empty	count=1
arg	whose rank [arg] ||| [arg]	count=2
module	vector field ||| vector	count=1
function	heuristic polynomial ||| dmp qq heu	count=1
arg	and g ||| g k	count=3
function	directional [function_2] ||| [function_1] [function_2]	count=3
arg	of ||| x y t r	count=3
module	self ||| polys agca	count=33
arg	of [arg] as a ||| [arg]	count=1
arg	k0 [arg_2] ||| [arg_2] [arg_1]	count=2
module_class	of [module_1] [class_2] object ||| [module_1] [class_2] tree	count=1
function	of single ||| single	count=1
function	indices of ||| get indices	count=1
arg	compute [arg_1] [arg_2] ||| div [arg_1] [arg_2]	count=4
arg	which [arg] the ||| [arg]	count=1
function	[function_1] bound ||| [function_2] [function_1]	count=1
class	or ||| expr	count=2
arg	functions or as a ||| x a	count=1
function_arg	at p with ||| at a p	count=1
arg	the transformation used ||| to_sys	count=1
arg	eliminate x_0 ||| u k	count=1
function	and ||| pure	count=1
class	bounding rectangles ||| of	count=1
arg	[arg_1] and token ||| [arg_1] [arg_2]	count=3
function	decreasing in ||| decreasing	count=2
function	in finite_set in ||| not	count=1
class	[class_1] [class_2] at ||| series [class_2] [class_1] eval	count=1
function	path to the module ||| mod func	count=1
arg	l1 [arg_2] ||| [arg_1] [arg_2]	count=1
function_arg	[function_1] [arg_2] ||| [function_1] order [arg_2]	count=1
function	clause to ||| clause	count=1
function	the nine-point [function_2] ||| [function_1] [function_2]	count=1
class	returns a standard ||| module	count=1
function	reversion ||| reversion	count=1
arg	x y are : ||| x y	count=1
arg	construct a ||| cls rep opt	count=3
function	cong 0 mod(p**s) ||| raise mod power	count=1
function	the laplace inversion ||| inversion	count=1
function	horizontal morphism ||| horizontal	count=1
arg	0 and a ||| a	count=1
function	[function_1] factors of ||| [function_1] list [function_2]	count=2
function	the coset [function_2] ||| [function_2] [function_1]	count=2
function	is algebraic ||| is algebraic	count=2
function_arg	prints expr in ||| print expr	count=1
class	the ||| octave code gen	count=2
arg	if it is a ||| symbol	count=1
function	of a square-free polynomial ||| sqf	count=1
module	is available ||| printing	count=1
module	in the ||| physics vector	count=3
function	[function] vector ||| [function]	count=2
arg	around x = x0 ||| x x0	count=1
module	perform one step of ||| polys	count=1
arg	with hilbert_space ||| hilbert_space	count=1
class	for ||| rep	count=4
arg	a polynomial p in ||| f p u	count=1
module_class	of polynomial ||| polys poly	count=3
class	compute ||| gmpyinteger	count=4
function	the degree of ||| find degree	count=1
function	function to each component ||| applyfunc	count=2
function	only [function_2] ||| [function_1] [function_2]	count=1
class	value (i ||| series base	count=1
class	of symbolic ||| code	count=1
arg	frame ||| frame	count=3
function	[function_1] sequence in ||| [function_2] [function_1]	count=1
arg	of the ||| cls	count=1
function	sequence of rational ||| rational	count=1
function	isolation interval from cache ||| interval	count=1
function	to a ||| data tensorhead from tensmul	count=1
function	of k squares ||| of squares	count=3
function	schreier-sims representation the coset ||| coset	count=1
function	part [function_2] ||| [function_2] sqf [function_1]	count=1
function	that dummies ||| ordered dummies	count=1
function_arg	norm of f ||| norm f k	count=2
arg	[arg_1] given domain ||| [arg_2] [arg_1]	count=3
function	a wigner [function_2] ||| [function_2] [function_1]	count=2
function	opening statements ||| get routine opening	count=2
class	a standard basis ||| ring	count=1
class	current ||| base	count=2
arg	[arg_1] and b ||| simplify dotrig [arg_1] [arg_2]	count=1
function_arg	push a function ||| push wireframe function	count=1
class	value of ||| piecewise	count=1
function	the nth root ||| nth root	count=2
arg	expr nearer ||| expr	count=1
function	generates a random ||| random	count=3
function	generators ||| dict from expr no gens	count=1
arg	return the ||| s	count=1
arg	default kind ||| kind	count=1
function	reblock ||| reblock	count=1
function	if unicode output ||| pretty try use unicode	count=1
class	does ||| mixin	count=1
function	symbol for undefined ||| auto symbol	count=1
arg	to a second order ||| order match	count=1
class	with ||| code	count=1
function	finite_set in which ||| empty	count=1
function	for the vsids ||| vsids	count=1
class	generate a ||| quotient	count=1
function	compare two ||| cmp	count=1
function	exponentiation of a ||| rs exp	count=1
function	[function_1] matrices for ||| [function_1] [function_2]	count=1
module	to [module] ||| [module]	count=8
function_arg	a gf [arg_2] ||| [function_1] to dict [arg_2]	count=3
function	risch ||| risch	count=1
arg	and b one set ||| b	count=1
arg	a basis ||| basis	count=1
arg	quantum [arg_2] ||| [arg_2] [arg_1]	count=3
class	the xy-pic representation ||| diagram drawer	count=1
function	the slope the ||| slope	count=1
arg	[arg_1] infinitesimals ||| [arg_2] [arg_1]	count=8
arg	risch differential equation - ||| de	count=1
class	system into a new ||| system	count=1
function	which the ||| not	count=1
function	is nonzero for a ||| is	count=1
arg	polynomials f g are ||| f g x method	count=1
arg	function ||| expression predicate interval symbol	count=1
module	in a ||| combinatorics	count=2
function	wang/eez test [function_2] ||| [function_2] [function_1]	count=2
function_arg	[function_1] [arg_2] ||| [function_1] subs expr [arg_2]	count=1
class	group ||| group element	count=1
class	mutabledensendimarray to matrix can ||| sparse ndim	count=1
module	basis in ||| polys	count=1
arg	quantum [arg_2] ||| [arg_1] [arg_2]	count=1
function	l1 [function_2] ||| [function_1] [function_2]	count=7
arg	var ||| var x	count=1
function	presentation is ||| presentation	count=1
arg	f as ||| f x	count=1
arg	a single g ||| a b	count=1
function	[function_1] [function_2] generators ||| [function_1] [function_2]	count=1
function_arg	polynomial of [arg_2] ||| [arg_2] [function_1]	count=4
module	expression equal to the ||| physics	count=1
arg	v ||| v	count=4
arg	simplifies the given ||| ratio measure fu	count=3
module	is ||| printing	count=1
function	heuristic assumes ||| lie heuristic	count=1
class	generated automatically ||| differential extension	count=1
function	constant term in ||| constant term	count=3
function	figure out generators ||| from expr no gens	count=1
class	and ||| grid	count=1
module_class	radius of [module_1] [class_2] ||| [module_1] [class_2]	count=2
function	gamma matrix line ||| line	count=1
arg	at a in the ||| i a	count=1
function	integer ||| symbol int	count=1
arg	iterator [arg] generate ||| [arg]	count=1
module	polynomial modulo a constant ||| polys	count=1
arg	of an expression ||| expr _strict	count=1
function	functions to be ||| function	count=1
arg	function out ||| out	count=1
function	x**(i*p) mod ||| frobenius monomial base	count=1
module	the default ||| physics	count=1
function	whose presentation ||| presentation	count=1
module	logic operators ||| logic	count=1
arg	of alpha as ||| alpha	count=1
function	[function_1] a distributed ||| [function_2] to [function_1]	count=2
function	value of ||| eval cond	count=1
function	are both integers then ||| check param	count=1
arg	compute ||| f g u k	count=1
function	sparse matrix to ||| to	count=1
arg	value ||| query value	count=1
function	diagram ||| diagram	count=2
module_class	1 about p1 of [module_1] [class_2] ||| [module_1] [class_2] arbitrary point	count=1
arg	order n ||| n	count=3
arg	not [arg] lexicographic ||| [arg]	count=1
function	is a ||| p	count=1
arg	n is prime ||| n	count=1
arg	type of ||| x	count=4
arg	[arg_1] of eq ||| [arg_2] [arg_1]	count=4
class	method for equality with ||| immutable	count=1
function	the derived series for ||| derived series	count=1
function	mpf tuple ||| as mpf	count=2
function	a specific value ||| free	count=1
arg	respect to x ||| x	count=2
arg	if a < b ||| cls a b	count=1
function	symbol and ||| find pure symbol	count=1
function	part [function] false ||| needs [function]	count=1
function	the dual ||| dual	count=1
function	ranking ||| rank	count=2
arg	[arg_1] [arg_2] default then the order ||| [arg_1] [arg_2]	count=6
arg	[arg_1] an expression ||| [arg_2] [arg_1]	count=1
function	formats a ||| statement	count=1
module	in the ||| series	count=1
arg	of this type of ||| x	count=3
arg	[arg_1] subtracting ||| [arg_2] [arg_1]	count=3
function	functions ||| functions	count=1
function	the order of ||| order	count=8
function	no bounding ||| refine complexes	count=1
arg	of state ||| state	count=2
function	of symbolic ||| param	count=1
arg	rule [arg_2] ||| [arg_2] [arg_1]	count=2
function	path ||| func	count=2
function	to generate necklaces ||| necklaces	count=1
function	the minimal polynomial for ||| minimal polynomial	count=1
module	point from which the ||| geometry	count=1
arg	system key ||| key	count=1
function	third heuristic assumes ||| lie heuristic	count=1
function	z[x] ||| zz	count=5
arg	of literals return an ||| expr	count=2
function_arg	an error [arg_2] ||| [arg_2] [function_1]	count=1
function	from ||| from	count=19
module	+ ||| solvers	count=3
function	proper line ending ||| get	count=1
arg	p [arg] i ||| [arg]	count=1
function_arg	to [arg_2] ||| [function_1] force vec [arg_2]	count=1
module	p[i] > p[i+1] ||| combinatorics	count=1
function	push ||| push wireframe	count=1
function	into [function_2] ||| [function_1] [function_2]	count=2
function	python subprocess with ||| subprocess with	count=1
function_arg	quotient of [arg_2] ||| [function_1] [arg_2]	count=11
arg	h as a list ||| h	count=1
function	are free symbols ||| free symbols	count=2
function_arg	[function_1] [arg_2] ||| [function_1] i [arg_2]	count=12
class	specific ||| series base	count=2
arg	z of the ||| z a	count=1
function	random complex values ||| random	count=1
function	is the logarithmic derivative ||| is log deriv	count=1
module	to [module] canonical ||| [module]	count=1
function	gets the subset ||| subset from	count=1
arg	[arg_1] if it ||| [arg_1] [arg_2]	count=1
function	the det ||| det	count=1
arg	self other the ||| other	count=1
arg	prints a text ||| text	count=1
function	half ||| dup half	count=1
arg	n for ||| n	count=1
function	[function_1] type of ||| [function_2] [function_1]	count=2
class	a standard ||| sub module poly ring	count=1
function	neither boundary ||| open	count=1
function	normalize ||| normalize	count=2
function	[function_1] potential difference ||| [function_2] [function_1]	count=3
arg	l2 on ||| l2	count=1
function	\ldots x_{k-1}] ||| multivariate	count=1
function	the apoapsis ||| apoapsis	count=1
function_arg	module [arg_2] ||| [arg_2] [function_1]	count=2
function	is a [function_2] ||| geometry point [function_1] [function_2]	count=5
arg	all [arg] are true ||| [arg]	count=1
class	for the ||| gen	count=2
arg	whether indices are ||| indices free dum	count=1
function	a tuple ||| as real	count=1
function	which should be roots ||| roots	count=1
arg	numerical approximations of roots ||| n maxsteps cleanup	count=2
function	pointwise ||| pointwise	count=1
arg	model or ||| expr model	count=1
class	polar numbers ||| polar	count=1
arg	polynomial f at a ||| f i a	count=1
function	[function_1] from a ||| [function_1] [function_2]	count=3
function	bounding ||| refine	count=1
function	the beginning of ||| indent	count=1
function_arg	space instance from ||| space cls	count=1
arg	in \mathbb{z}_p ||| evalpoints hpeval ring i	count=1
arg	compute the ||| f k	count=2
arg	modulo o(x**prec) ||| p c x prec	count=1
function	the size ||| size	count=2
module	ie the location ||| combinatorics	count=2
function	the scaler-row ||| mulrowscaler	count=1
function	index of the ||| index	count=1
function	[function_1] commutative ||| [function_2] [function_1]	count=1
class	[class] cartan ||| [class]	count=1
function	in [function_2] ||| [function_1] [function_2]	count=5
function	written as g* a ||| as f	count=1
function	solves ||| solve	count=5
function	x_i**k_i in a ||| inflate	count=1
arg	of f given a ||| f	count=1
arg	in h as ||| h	count=1
function_arg	to a [arg_2] ||| [arg_2] [function_1]	count=5
class	the ||| series base	count=4
function	given number ||| indent	count=1
class	the kb examples ||| kb	count=1
arg	another subcircuit [arg] if it ||| [arg] subcircuit replace	count=1
arg	[arg] is ||| cls r [arg]	count=2
arg	the condition ||| cls cond	count=1
arg	[arg_1] domain for ||| [arg_2] [arg_1]	count=6
arg	whether u ||| u	count=1
module	in [module] ||| [module]	count=3
class	returns an object of ||| expr	count=1
function	get ||| get	count=11
function	multiply tuple ||| mul	count=1
module	for beta root of ||| polys	count=1
function	with ||| get	count=2
function	theory ||| theory	count=2
arg	function f [arg_2] ||| [arg_2] [arg_1]	count=1
arg	ith ||| i j	count=1
function	number [function_2] ||| [function_1] [function_2]	count=2
function	of the series of ||| series	count=1
module	the phase front ||| physics	count=1
function	using cholesky or ldl ||| eval	count=1
function	reconstruct a rational number ||| rational reconstruction	count=1
function	the loads in ||| loads	count=1
function	subset ||| get subset	count=1
function	simple roots ||| simple roots	count=2
function	refine a ||| dup inner refine real	count=1
function	topological ||| topological	count=1
class	variables ||| differential operator	count=1
function_arg	[function_1] polynomial irreducibility ||| [arg_2] [function_1]	count=1
function_arg	[function_1] by its ||| [arg_2] [function_1]	count=2
arg	[arg_1] x the ||| [arg_2] [arg_1]	count=1
function	the bottom nodes ||| bottom	count=1
function	xor ^, ||| convert xor	count=1
class	of this [class] and another ||| [class]	count=1
module	along the ||| geometry	count=1
function	computes the gauss-chebyshev ||| chebyshev u	count=1
function	an argument [function] false ||| needs [function]	count=1
function	the size ||| degree	count=1
function	a positive root ||| root	count=2
class	polar numbers ||| polar lift	count=1
class	hypergeometric ||| hyper	count=2
class	if any coordinate ||| point	count=1
function	are structurally the ||| aresame	count=1
function_arg	[function_1] x_j ||| [function_1] f [arg_2]	count=2
module_class	whether the [class_2] ||| [module_1] [class_2]	count=2
function	same ambient dimension ||| origin	count=1
function	[function_1] of syllables ||| [function_2] [function_1]	count=3
class	apply on a ||| commutator	count=1
function	resolve the order ||| order	count=1
function	[function_1] iterable or ||| [function_1] [function_2]	count=1
arg	center of ||| vec	count=1
class	returns ||| series	count=1
class	generators from [class] ||| [class]	count=2
function	proper line ||| statement	count=1
arg	override geometryentity rotate to ||| pt	count=1
function	gets the gray code ||| gray	count=1
function	ending ||| statement	count=1
arg	a base and strong ||| base	count=2
arg	in ||| f	count=43
function	generates cyclotomic polynomial ||| cyclotomic poly	count=2
arg	two univariate [arg_2] ||| [arg_2] [arg_1]	count=4
arg	gcd of two univariate ||| g	count=1
class	of the group ||| group	count=2
arg	cos and sin ||| rv	count=1
function_arg	unify representations [arg_2] ||| [arg_2] [function_1]	count=3
function	distinct real roots ||| count real roots	count=1
function	moment of area ||| moment	count=1
module_class	self by submodule ||| agca sub	count=1
function	ode ||| ode	count=3
function	string path to ||| mod func	count=2
function	can be ||| symbols2i	count=1
function	restricted to ||| only	count=1
function	the position ||| position wrt	count=1
function	rust code ||| rust code	count=1
class	this [class] an ||| [class]	count=1
arg	f a [arg_2] ||| eval [arg_1] p [arg_2]	count=1
function	[function] coordsyscartesian ||| orient [function]	count=3
module	the given number ||| utilities	count=1
function	explicit ||| explicit rhs	count=1
function	[function_1] potential ||| [function_1] [function_2]	count=3
arg	mellin transform of g ||| g x helper	count=1
function	tests whether [function_1] [function_2] ||| [function_1] [function_2]	count=8
function	[function_1] cosine between ||| [function_1] [function_2]	count=3
function	the finite difference approximation ||| finite	count=1
function	to x**m ||| inflate	count=1
arg	element of g ||| g	count=1
function	the expr ||| expr	count=1
function	a chi-squared ||| chi squared	count=1
class	writes a ||| gen	count=2
function	the order of the ||| order	count=2
module	the curl [module] ||| physics [module]	count=1
arg	return the expression ||| expr	count=1
module	a lower triangular matrix ||| matrices	count=1
function_arg	power of [arg_2] ||| [arg_2] [function_1]	count=3
class	of the vector space ||| type f	count=1
function_arg	the bifid cipher ||| bifid5 msg key	count=1
function_arg	into irreducibles [arg_2] ||| [arg_2] [function_1]	count=3
function	heuristic assumes ||| heuristic	count=1
function	only integer powers ||| integer powers	count=1
function	which is preferred to ||| get preferred	count=1
class	along ||| matrix	count=2
class	element ||| element	count=3
class	proper line ending ||| code	count=1
function	the total [function_2] ||| [function_1] [function_2]	count=2
arg	startnumber ||| startnumber	count=1
function	system using lusolve ||| solve linear system lu	count=1
function	return the bra on ||| bra	count=1
arg	stabilizer of alpha ||| alpha schreier_vector _random_prec	count=3
function	derived series for ||| derived series	count=2
arg	grid adds an ||| grid	count=1
arg	symbols ||| symbols filter	count=1
function	class into a string ||| mod	count=1
function_arg	this is a [function_1] [arg_2] [3] ||| [function_1] [arg_2]	count=1
class	a point object ||| point	count=1
arg	rs\_sin p ||| p	count=1
arg	ring ||| ring	count=1
arg	triangles [arg_2] ||| [arg_1] [arg_2]	count=1
module	those that ||| series	count=1
arg	function to all ||| func	count=1
function_arg	[function_1] expression over ||| [arg_2] [function_1]	count=2
arg	partial differential ||| eq hint func order	count=1
function	treats xor ^, as ||| xor	count=1
function	solution to an ode ||| ode 1st	count=1
class	positive exponent ||| base	count=1
function	if ||| pretty	count=2
function	homogeneous coefficients using ||| homogeneous coeff	count=2
function	[function_1] [function_2] ||| [function_1] ff trivial [function_2]	count=2
module	the get_unit method using ||| physics units	count=1
arg	function out ||| compileflags out	count=1
module	shortcut to [module] ||| [module]	count=6
function_arg	tell whether [arg_2] ||| [arg_2] [function_1]	count=4
function	[function] represents ||| [function]	count=2
function	is for meijer g ||| meijer	count=1
arg	prints a text ||| text color	count=1
function	multivariate series ||| rs series	count=1
arg	of n and either ||| n	count=1
arg	of factors ||| factors	count=3
function	these type of ||| 2eq order2	count=1
function	in the series ||| rs	count=1
function	[function_1] sympy ||| [function_1] [function_2]	count=6
arg	routine ||| routine	count=3
function_arg	[function_1] with another ||| [arg_2] [function_1]	count=2
class	the partition is listed ||| integer partition	count=1
function	set the commutation ||| set	count=1
arg	of square-free ||| polys k eps	count=1
function	the identity [function_2] ||| [function_1] [function_2]	count=3
function	upper ||| dup root upper	count=1
arg	of f ||| f x	count=3
function	whose presentation is to ||| presentation	count=1
arg	handler ||| handler	count=1
class	[class_1] transform ||| [class_1] [class_2]	count=1
function	-> a/b -> a ||| as numer denom	count=1
class	generated files ||| code gen	count=1
function	number of space ||| indent	count=1
arg	assign a value to ||| value	count=1
arg	of expression ||| expr var	count=2
arg	[arg_1] in x ||| [arg_1] [arg_2]	count=8
class	basis in ||| poly ring	count=1
function	proper line ending ||| statement	count=1
arg	in k[x] ||| n u k	count=2
arg	for the partial ||| hint	count=1
module	no ||| polys	count=1
function	use pollard's p-1 ||| pollard pm1	count=1
function_arg	addends of [arg_2] ||| [function_1] [arg_2]	count=2
function	of the derivative ||| diff	count=1
function	the logarithmic derivative ||| log deriv	count=1
class	matrix of ||| dense matrix	count=1
function	[function_1] test evaluation ||| [function_2] [function_1]	count=1
class	complement ||| complement	count=1
arg	c if c ||| c min max	count=1
function	matrix to ||| matrix to	count=6
function	linear [function_2] ||| [function_1] constant coeff [function_2]	count=1
function	mises ||| mises	count=1
function	key such ||| key	count=1
arg	on input ||| message	count=1
module	is [module] ||| [module]	count=2
arg	in the given interval ||| expression interval symbol	count=3
function_arg	g*h where [arg_2] ||| [arg_2] [function_1]	count=14
function_arg	space [arg_2] ||| [function_1] diagonal [arg_2]	count=1
arg	v ||| v x	count=1
arg	x_j in k[x] ||| j u	count=1
arg	f p q ||| f p q	count=3
function	to sympy number ||| to sympy	count=2
module_class	[module_1] interior angle ||| [module_1] [class_2]	count=6
function	shape dimensions ||| shape	count=1
arg	the value of key2 ||| key2	count=1
arg	is replaced by the ||| kwargs n	count=1
class	to python's int ||| python integer ring	count=1
function	which ||| uniquely named	count=1
class	matrix for [class] cartan matrix ||| [class]	count=1
arg	is suitable ||| iszerofunc simpfunc	count=1
function	pseudo-remainder of ||| prem	count=1
function	postprocess ||| postprocess for	count=1
function_arg	f [arg_2] ||| [arg_2] [function_1]	count=1
function	the delta [function_2] ||| [function_2] [function_1]	count=1
arg	if [arg] on ||| [arg]	count=1
function	total degree ||| total degree	count=2
arg	to quantum [arg_2] ||| [arg_1] [arg_2]	count=1
arg	by [arg] ||| [arg]	count=1
class	returns a standard basis ||| sub module poly ring	count=1
arg	[arg_1] pt -- ||| [arg_1] [arg_2]	count=4
class	bounding rectangles of non-conjugate ||| complex	count=1
function_arg	if key is [function_1] [arg_2] ||| [function_1] [arg_2]	count=3
arg	self in h as ||| h	count=1
function	a system of polynomial ||| poly system	count=1
class	index pos 0 , ||| index structure	count=1
function_arg	[function_1] by stringify_expr ||| [function_1] code [arg_2]	count=1
function	on a specific ||| free	count=1
arg	make poly compatible with ||| poly	count=1
function	d^2 ||| four	count=1
function	indices of a ||| indices	count=1
function	ket on the left ||| ket	count=1
function	returns a list ||| list include	count=2
arg	welds the ||| welding_edge	count=1
class	bounding rectangles of ||| of	count=1
arg	to eliminate x_0 ||| u	count=1
function_arg	dict [arg_2] ||| [arg_2] [function_1]	count=1
function_arg	subtract dense [arg_2] ||| [arg_2] [function_1]	count=3
class	any coordinate ||| point	count=1
module	pi ||| functions elementary	count=1
function	roots ||| dup inner isolate real roots	count=2
module	'self' ||| sets	count=2
function	convert a gf ||| gf	count=2
function	printing ||| printing	count=1
function_arg	[function_1] is used ||| [function_1] [arg_2]	count=1
function	each basic element ||| element	count=1
function_arg	division of a ||| div a	count=8
function	[function_1] positive ||| [function_2] [function_1]	count=2
class	no ||| root	count=1
class	with submodule ||| sub module	count=1
module	to gtkmathview ||| printing	count=1
function_arg	[function_1] expr in ||| [function_1] [arg_2]	count=1
arg	k[x y] to k[x][y] ||| u k front	count=1
arg	radial wavefunction r_{nl} for ||| l nu r	count=1
class	quasi-particle? annihilate hole ||| create fermion	count=1
arg	for ||| n	count=1
class	the entries outside ||| properties	count=1
function	any evalf of ||| evalf	count=1
arg	index ||| index	count=5
arg	expression over ||| expr	count=2
arg	b if v ||| v	count=1
function	[function_1] raw ||| [function_2] [function_1]	count=1
function	logarithm of ||| log	count=1
function	get a list of ||| get	count=5
function_arg	[function_1] in s2 ||| [arg_2] [function_1]	count=2
function	extra strong ||| extra strong	count=2
function	perform ||| prop	count=1
function	third heuristic assumes the ||| heuristic	count=1
function_arg	i [arg_2] ||| [function_1] i [arg_2]	count=3
arg	a labeled polynomial f ||| f	count=1
function_arg	free module [arg_2] ||| [arg_2] [function_1]	count=2
arg	sum is also ||| root1 root2	count=1
arg	apply [arg] to ||| f g [arg]	count=2
module	'lamda' being the ||| combinatorics	count=1
arg	of tan or ||| rv	count=1
function	returns maximal degree ||| max	count=1
arg	the real inverse_mellin_transform ||| s x_ strip	count=1
function	transitivity ||| transitivity	count=1
function	morse code with letters ||| decode morse	count=1
function	ordinary decimal ||| decimal	count=1
class	generated ||| code	count=1
arg	quantum number ||| m r	count=2
function	sorted components ||| sorted components	count=2
function	[function_1] square-free part ||| [function_2] [function_1]	count=1
function_arg	tensors with [arg_2] ||| [arg_2] [function_1]	count=1
arg	x_j of a ||| m j	count=1
class	multivariate functions ||| function	count=1
module_class	[module_1] product ||| [module_1] tens [class_2]	count=1
function	the lexicographic rank ||| rank	count=1
function_arg	a where f ||| ground f	count=3
function	figure out generators ||| dict from expr no gens	count=1
function	the right ||| right	count=1
function_arg	[function_1] of f ||| [function_1] in [arg_2]	count=4
function	in terms [function_2] ||| [function_1] [function_2]	count=1
function	[function_1] squares false ||| [function_1] [function_2]	count=3
arg	to an index in ||| index	count=2
function	christoffel symbols for ||| christoffel 1st	count=1
function	second ||| second	count=1
function	redirect an ||| operator int	count=1
function	the dot product ||| dot	count=1
function	expr ||| integer part	count=1
module	is ||| pretty	count=1
arg	f to ||| f	count=1
arg	expr is bounded ||| expr assumptions	count=1
module	the unit name ||| physics units	count=2
function	is a sequence in ||| is sequence	count=1
function	plan consisting of ||| plan	count=1
function	square-free norm of ||| dup sqf norm	count=2
function	and negative coefficient ||| cse	count=1
arg	to n ||| n nth	count=1
function	gegenbauer ||| gegenbauer	count=2
function	to a simplified set ||| simplified pairs	count=1
arg	[arg_1] + sign*s ||| [arg_2] [arg_1]	count=2
function	polynomial quotient in ||| exquo	count=1
function_arg	decreasing in [arg_2] ||| [function_1] [arg_2]	count=4
class	finiteset in terms ||| finite set	count=1
class	no bounding rectangles of ||| complex	count=1
function	[function_1] single gamma ||| hep [function_1] [function_2]	count=1
class	asinh ||| asinh	count=1
function	instance ||| from args	count=1
function	a rational function ||| rational function	count=2
function	homogeneous [function_2] ||| [function_2] linear constant coeff [function_1]	count=1
function	clear [function_2] ||| [function_2] [function_1]	count=2
function	possible ||| pretty try	count=1
function	is the given ||| is	count=2
module	polynomial modulo ||| polys	count=1
function	operation on row ||| row op	count=8
function	is [function_2] ||| [function_1] [function_2] expression interval symbol	count=3
arg	in adds muls pows ||| exprs order verbose	count=1
module	polynomial sequences of two ||| holonomic	count=1
arg	an expression ||| expr _strict	count=1
module	a ||| diffgeom	count=1
function	qubit ||| operator qubit	count=2
module	the canonical ||| physics	count=2
arg	from gate_list ||| gate_list	count=1
function	computes polynomial lcm ||| lcm	count=4
function	strong lucas [function_2] ||| [function_1] [function_2]	count=2
arg	are independent [arg] knowledge ||| [arg]	count=1
arg	p q ||| p q	count=11
function_arg	[function_1] the modulus ||| [function_1] f [arg_2]	count=1
class	gate needs ||| cnot gate	count=1
function	_eval_nseries if assumptions allow ||| nseries	count=1
function_arg	return encryption [arg_2] ||| [arg_2] [function_1]	count=2
arg	inserts calls to ||| tokens local_dict global_dict	count=1
arg	independent [arg] ||| f [arg]	count=1
function_arg	continuous subsequence [arg_2] ||| [function_1] [arg_2]	count=4
arg	character in phrase is ||| phrase	count=1
class	coset table ||| coset table	count=3
arg	is the term with ||| r n limits	count=1
arg	eq that ||| eq	count=1
arg	return ||| cls	count=2
function	and if symbols is ||| and join	count=1
function	apply additional beta-rules and ||| apply	count=1
function	the leading degree ||| degree	count=1
function	repeated ||| repeated	count=1
function_arg	[function_1] p ||| [function_1] quo f g [arg_2]	count=2
module	list of all units ||| units	count=1
module	start ||| series	count=1
class	__floordiv__ ||| ring	count=2
function	[function_1] structure ||| [function_2] [function_1]	count=3
function	| ||| or	count=1
function	[function_1] a constant ||| [function_2] [function_1]	count=1
function_arg	over a [arg_2] ||| [arg_2] [function_1]	count=1
function_arg	this [arg_2] ||| [function_1] [arg_2]	count=1
arg	_hasattrs and _hastypes to ||| attrs types	count=1
class	of ||| complex root	count=1
function	terms [function_2] ||| [function_2] [function_1]	count=2
function	true if ||| equals	count=1
class	of the bessel-type ||| bessel base	count=1
function_arg	a prime [arg_2] ||| [function_1] resultant f g [arg_2]	count=1
function	and leverage ||| try use	count=1
arg	to x ||| x	count=4
function_arg	converts [arg_2] ||| [function_1] matrix [arg_2] format	count=2
module	true if self ||| polys agca	count=10
module	a list of polynomial ||| polys	count=1
class	regularpolygon is ||| regular polygon	count=1
function	[function_1] [function_2] objects from sequences returns ||| [function_1] [function_2]	count=1
arg	or product expression ||| expr x y	count=1
arg	of our container modulo ||| nf	count=1
arg	public key i ||| i key	count=1
arg	polynomial f at ||| f	count=1
arg	entity ||| o	count=1
function	and ||| as	count=1
arg	name and [arg_2] ||| [arg_2] [arg_1]	count=4
arg	f s over the ||| f s x	count=1
class	xy-pic representation ||| drawer	count=1
arg	an indexed ||| f x index radicals	count=1
arg	variable with ||| name k l	count=2
function	squares false ||| squares	count=1
arg	controls targets and ||| controls targets	count=2
class	latex ||| latex	count=1
arg	[arg] and ||| [arg]	count=3
function	coset table of self ||| coset table	count=1
module	and return the ||| utilities	count=1
function	helper function of ||| helper	count=2
arg	if self and other ||| other	count=1
function	[function_1] sympy matrix ||| [function_1] [function_2]	count=3
function	base [function_2] ||| [function_1] [function_2]	count=1
class	to compute the determinant ||| determinant	count=1
arg	d with [arg_2] ||| [arg_1] [arg_2]	count=4
class	coordinate system ||| coord	count=3
function	to a string of [function_1] [function_2] ||| [function_1] [function_2]	count=3
function	of sympy coefficients ||| sympy	count=1
function	complement ||| complement	count=1
module	sum ||| concrete	count=2
function_arg	[function_1] p ||| [function_1] rem f [arg_2]	count=2
module_class	self [class_2] ||| [class_2] [module_1]	count=1
arg	an index ||| index	count=2
function	hermite polynomial of degree ||| hermite poly	count=1
function	by^2 + cz^2 + ||| to normal	count=1
function	odes ||| linear 3eq order1 type3	count=1
function	the gauss-chebyshev ||| gauss chebyshev t	count=1
class	true ||| fraction	count=3
arg	c i ||| c condition	count=1
function	which represents the bending ||| bending	count=1
arg	root1 and ||| root1	count=1
module	implementation of ||| polys agca	count=6
function	linear in all its ||| linear	count=2
function	of eye and ||| matrix eye	count=1
function	ordinary decimal instance to ||| decimal to	count=1
function	the precedence matrix this ||| get precedence matrix	count=1
function	the gcd of coefficients ||| content	count=2
function	is in [function_2] ||| [function_1] [function_2]	count=1
arg	curl ||| vect doit	count=1
module	power series ||| series	count=2
function	squares of which ||| of squares	count=1
arg	changes the ||| lenics	count=1
arg	arrowstringdescription describing ||| morphisms_str_info	count=1
function_arg	polynomial in x ||| poly n x	count=2
class	union ||| union	count=1
arg	a model ||| expr model	count=1
arg	subs to ||| subs	count=1
class	mutabledensendimarray ||| ndim array	count=1
class	point in ||| point	count=5
arg	basis ||| basis	count=4
module_class	of this [class_2] ||| [module_1] [class_2]	count=11
function_arg	this is a [function_1] [arg_2] [3] ||| [function_1] nonlex [arg_2]	count=1
arg	= a in ||| f a	count=2
arg	associated to val ||| val	count=1
function	test whether function ||| function	count=1
function	[function_1] set ||| [function_2] [function_1]	count=4
module	[module] x ||| [module]	count=1
arg	to quantum [arg_2] ||| [arg_2] [arg_1]	count=3
arg	is the term with ||| r n	count=1
function_arg	expression [arg_2] ||| [function_1] expression [arg_2] increment	count=1
function	the gauss-chebyshev ||| gauss chebyshev u	count=1
function	the bottom nodes ||| bottom up	count=1
function	polynomial lcm ||| lcm	count=5
class	[class] k=v ||| [class]	count=1
function	functions in finite_set in ||| empty in	count=1
arg	a sympy expression expressions ||| expr callback_type	count=1
function	set of equivalent ||| equivalent	count=1
function	generating reflections of ||| generators	count=1
arg	n alpha [arg_2] ||| [arg_1] a [arg_2]	count=3
function	basic expression ||| basic	count=1
function	following ||| numer denom	count=1
function	cz^2 ||| normal	count=1
arg	a tree ||| tree	count=2
function	of a k ||| k	count=1
function	of coefficients of ||| ground content	count=1
function_arg	[function_1] [arg_2] (if key1=true) share at ||| [function_1] [arg_2]	count=8
function	vsids heuristic ||| vsids	count=1
module	to rearrange the order ||| physics	count=1
function_arg	a polynomial [arg_2] ||| [function_1] [arg_2]	count=1
arg	if k ||| k	count=1
arg	[arg_1] by a ||| [arg_2] [arg_1]	count=3
function	in ||| dmp	count=2
arg	minpoly(add(*a), dom x) ||| x dom	count=1
arg	plane? ||| l	count=1
arg	f in the ||| f	count=1
arg	fpgroup h a ||| fp_grp h	count=1
function	a minimal ||| unify	count=1
function	the adjacency ||| get adjacency	count=2
function_arg	[function_1] to f ||| [arg_2] [function_1]	count=2
arg	[arg_1] [arg_2] string of ||| [arg_2] [arg_1]	count=4
function	of coefficients ||| ground content	count=1
function	available and leverage ||| use	count=1
module_class	self by [class_2] ||| [class_2] [module_1]	count=1
function	block matrices ||| block matrices	count=2
arg	add a new key ||| key	count=1
function	encryption of ||| encipher	count=1
function	f * a where ||| mul ground	count=1
function	perform ||| doit	count=2
arg	the condition ||| cond	count=1
class	group ||| permutation group	count=9
arg	returns true if expr ||| expr	count=1
class	c matrix of ||| dense matrix	count=1
function	of sympy coefficients ||| from sympy	count=1
function	module ||| mod func	count=1
function	n-link pendulum on ||| pendulum on	count=1
arg	[arg_1] j_4 j_5 ||| [arg_2] [arg_1]	count=4
class	module ||| free module	count=1
module	for single component tensor ||| tensor	count=1
function	non-conjugate ||| refine	count=1
arg	vector ||| vector m	count=1
function	return the next ||| next	count=1
class	accumulationbounds object is greater ||| accumulation bounds	count=1
function	[function] used in ||| [function]	count=1
arg	[arg_1] to ||| [arg_2] [arg_1]	count=2
module	creates ||| physics vector	count=1
function_arg	[function_1] of qubit ||| [arg_2] [function_1]	count=1
class	x c matrix ||| dense matrix	count=1
function	a polynomial ring ||| poly ring	count=3
arg	n shifted to the ||| n	count=1
function_arg	matrix [arg_2] ||| [function_1] [arg_2]	count=1
function	adjacency [function_2] ||| [function_1] [function_2]	count=2
function	a loop [function_2] ||| [function_1] [function_2]	count=1
arg	normally ||| independent recursive_limit _recursive_depth	count=1
arg	and its attributes ||| props add_identities	count=1
class	on a specific value ||| series	count=1
arg	a subcircuit [arg] another subcircuit ||| circuit subcircuit [arg]	count=1
function	a finite ||| as finite	count=1
arg	key ||| key symbols	count=2
arg	constructing the string ||| grid morphisms_str_info	count=1
function	root of a composite ||| root	count=1
arg	[arg_1] y ||| holzer [arg_1] [arg_2]	count=1
arg	partial ||| hint	count=1
function	[function_1] upper-hessenberg form ||| [function_2] [function_1]	count=1
function	coherent states ||| coherent state	count=1
function	union ||| union	count=2
function_arg	scaler-row [arg_2] ||| [function_1] row [arg_2]	count=1
class	hole or ||| annihilate fermion	count=2
function_arg	cofactors [arg_2] ||| [function_1] gcd [arg_2]	count=5
arg	[arg_1] o(x**prec) ||| [arg_2] [arg_1]	count=1
arg	of f in k[x] ||| f n u k	count=2
function	permute ||| permute	count=1
module	truth value of ||| functions elementary	count=1
module	of the three ||| physics optics	count=4
arg	two univariate polynomials over ||| g	count=1
arg	for n ||| n x x y	count=1
class	initialize ||| kanes method	count=1
function	generates jacobi ||| jacobi	count=1
function	a polynomial [function] ||| [function] sqf list	count=1
function	extension ||| extension	count=1
function	the function prototype ||| get prototype	count=2
class	a point ||| point	count=1
function	returns the offset ||| offset	count=1
class	[class] but ||| [class]	count=2
function	return the truth value ||| cond	count=1
function	the top nodes ||| top	count=2
function	the taylor [function_2] ||| [function_2] [function_1]	count=1
class	return the matrix ||| matrix	count=1
module	clause ||| algorithms	count=1
function	real imaginary part ||| real imag	count=1
function	[function_1] lexicographically ordered ||| [function_1] [function_2]	count=6
module_class	in the medium ||| physics optics medium	count=1
module	it ||| printing pretty	count=2
class	a ||| poly ring	count=4
function	position to ||| to	count=1
function	subtract two ||| sub	count=2
function	radius of the circumcircle ||| circumradius	count=1
function	an algebraic integer ||| algebraic integer	count=2
arg	of f in ||| f u	count=1
arg	function for the method ||| func	count=1
module	to the module and ||| utilities	count=1
arg	test if f ||| f	count=1
class	for the c ||| c	count=1
function	[function] of ||| [function] tensors from components	count=1
arg	[arg_1] rank ||| [arg_2] [arg_1]	count=12
arg	f with respect ||| f	count=2
arg	x ||| x alpha	count=1
function	computes the derivation ||| derivation	count=1
function	clear denominators ||| rat clear denoms	count=1
function	polynomial of sin ||| sin	count=1
function_arg	element is [arg_2] ||| [function_1] f [arg_2]	count=4
arg	get an ||| index	count=1
function	positive [function] given precision ||| [function]	count=1
function	denominator of ||| denom	count=3
arg	a polynomial f ||| f minpoly	count=1
function	finds the inverse ~a ||| af invert	count=1
arg	in ||| f g u	count=1
function	[function] (os ||| convert to [function]	count=3
function	polynomial quotient in gf ||| gf exquo	count=1
class	of the matrix ||| sparse matrix	count=2
function	true if [function_2] ||| [function_1] [function_2]	count=1
arg	f if it ||| f symbol	count=1
function	below ||| below	count=2
function	two assumptions on \xi ||| product	count=1
function	from the ||| from	count=1
module	the kinematic differential equations ||| physics mechanics	count=1
arg	associated to name and ||| name	count=1
module	in ||| combinatorics	count=2
arg	to ||| method	count=1
function	kinetic ||| kinetic	count=1
function	ipython ||| ipython	count=2
arg	from triangles [arg_2] ||| [arg_1] [arg_2]	count=1
class	whether a replacement ||| basic	count=1
function_arg	[function_1] tuple x ||| [arg_2] [function_1]	count=1
function	best solution to ||| best	count=1
arg	of subgroup h ||| h strategy	count=2
arg	readable object for ||| pkgname	count=1
function_arg	int [arg_2] ||| [function_1] [arg_2]	count=1
arg	add/mul of qubit ||| qubit	count=1
function	is [1 ||| lex	count=1
module	of a permutation ||| combinatorics	count=1
module_class	color [class_2] ||| [module_1] [class_2]	count=1
class	part ||| inner	count=2
arg	text ||| text color align	count=1
class	the homomorphism ||| module homomorphism	count=1
function	solution to an ode ||| ode	count=2
function_arg	quotient of f ||| quo ground f	count=2
function	lmq lower bound for ||| dup root lower bound	count=1
arg	for :func _symbolic_factor ||| expr opt method	count=1
function	rational function to ||| fraction	count=2
function	[function_1] a product ||| [function_1] [function_2]	count=8
class	returns a standard ||| poly ring	count=1
function	of operators corresponding ||| operators	count=1
function	numbers c for ||| comms	count=1
function	have [function] coefficients ||| to [function]	count=1
class	rotation ||| coord sys cartesian	count=1
arg	the grid and ||| grid	count=1
class	[class_1] series ||| [class_2] [class_1]	count=5
function_arg	part of [arg_2] ||| [function_1] [arg_2]	count=7
class	sympy sets set of ||| set	count=1
function	this heuristic uses the ||| lie heuristic function	count=1
arg	points in the ||| points	count=1
arg	root if it ||| cls root	count=1
function	the offset ||| offset	count=1
function	pendulum on a sliding ||| pendulum on	count=1
function	and the name ||| mod func	count=1
function	partial fraction decomposition ||| decomposition	count=1
arg	degree d with knots ||| d knots	count=2
module	domain ||| polys domains	count=3
module	using any ||| integrals	count=1
function	with ||| get integer part	count=1
class	appear [class] but ||| [class]	count=1
module	and negative coefficient muls ||| simplify	count=1
function	[function_1] nilpotent ||| [function_2] [function_1]	count=1
arg	p for two univariate ||| p	count=1
function	domain of the functions ||| not	count=1
class	can get the ||| polyhedron	count=1
function_arg	true if n ||| is square n	count=1
arg	multiplying by [arg] ||| [arg] z	count=2
function	isolate real roots of ||| dup isolate real roots	count=2
function	if ||| use	count=2
function	z_p ||| gf	count=1
module	in the object ||| series	count=1
arg	[arg_1] order o ||| [arg_1] [arg_2]	count=5
arg	medium p ||| p	count=1
module	to pairs [module] ||| [module]	count=2
module	leverage ||| printing	count=1
function	[function_1] a principal ||| [function_2] [function_1]	count=1
function_arg	[function_1] to_j, where ||| [function_1] syllables [arg_2]	count=1
function	returns f + ||| add	count=2
module_class	number [module_1] [class_2] ||| [module_1] [class_2]	count=6
function	as g* ||| as f	count=1
function	single [function_2] ||| [function_2] [function_1]	count=2
function	matrix for ||| matrix	count=1
module	a sequence of ||| polys	count=1
arg	following -- a symbol ||| symbol density set	count=1
arg	indices are ||| indices	count=1
function	function prototype of ||| get prototype	count=2
function_arg	to whether [arg_2] ||| [function_1] data [arg_2]	count=3
function	only [function_2] ||| [function_2] [function_1]	count=1
function	matches a ||| nth	count=1
arg	and a column ||| column k	count=1
arg	== a ||| a	count=1
arg	[arg_1] z_p ||| [arg_2] [arg_1]	count=2
function	mapping of ||| param dict	count=1
module	t2 e [module] t(a b ||| [module]	count=1
class	mutabledensendimarray ||| dense ndim array	count=1
class	simple root [class] every ||| [class]	count=2
function_arg	factors of [arg_2] ||| [function_1] [arg_2]	count=1
function	direction ratio ||| direction	count=1
module	that ||| core	count=2
function	[function] belonging to ||| [function]	count=2
class	coordinate ||| coord sys cartesian	count=5
arg	method using key ||| key	count=2
arg	[arg_1] in the ||| [arg_2] [arg_1]	count=1
function	strong lucas [function_2] ||| [function_2] [function_1]	count=2
function	points used ||| points	count=1
arg	p q are ||| p q x method	count=2
function	square-free ||| dmp sqf	count=2
arg	standard basis of g ||| g	count=1
arg	eq [arg_2] ||| [arg_1] [arg_2]	count=1
class	elements of the group ||| group	count=2
function	get a [function_2] ||| [function_2] [function_1]	count=9
module	common factors [module] a ||| [module]	count=1
class	[class_1] root ||| [class_2] [class_1]	count=1
function	module and ||| get	count=1
function	the class ||| func	count=1
arg	handler a ||| handler	count=1
function	helper to check ||| check	count=1
function_arg	[function_1] where other ||| [function_1] [arg_2]	count=8
function	leverage it ||| use	count=1
arg	p g ||| g b	count=1
arg	expression of a unit ||| unit	count=1
arg	all terms of f ||| f	count=1
function	[function_1] int ||| [function_1] [function_2]	count=2
function	part [function] ||| needs [function]	count=1
function	wrapper [function_2] ||| [function_2] [function_1]	count=2
function_arg	to gray [arg_2] ||| [arg_2] [function_1]	count=1
function	roots of g_2" ||| roots	count=1
arg	solves a ||| eq sym	count=1
arg	yields the k-tuples of ||| k zeros	count=1
module	the added ||| physics	count=1
function	make a ||| to	count=1
class	self ||| matrix	count=1
arg	f by a ||| f c	count=4
function	refine a positive root ||| outer refine real root	count=1
module	the dictionary ||| physics	count=1
function	function or an expression ||| expr	count=1
function	sine ||| sin	count=1
function	the class ||| class	count=1
function	roots of a composite ||| roots	count=1
function_arg	[function_1] grid adds ||| [function_1] triangles fringe [arg_2]	count=1
module	create a continuous random ||| stats	count=4
function	return leading coefficient of ||| lc	count=1
arg	in x_0 of a ||| u k	count=1
arg	a polynomial [arg] ||| [arg]	count=1
function_arg	cyclotomic polynomial [arg_2] ||| [function_1] [arg_2]	count=3
arg	f and for each ||| a d de	count=1
function	of density ||| density	count=1
module_class	[module_1] __pow__ ||| [module_1] [class_2]	count=2
function	hankel [function_2] ||| [function_1] [function_2]	count=2
function_arg	update [arg_2] ||| [arg_2] [function_1]	count=1
class	truth value ||| piecewise	count=1
arg	components data ndarray ||| data	count=1
function	module and ||| get mod func	count=1
function	homogeneous [function] ||| [function] 2nd power series	count=3
arg	representing ||| p succ	count=2
arg	a certain coordinate system ||| point1 point2	count=1
class	same assumptions ||| symbol	count=1
function	cyclotomic polynomial of ||| cyclotomic poly	count=2
class	total number of ||| type	count=1
function	multiplication ||| mul	count=6
function_arg	printing [arg_2] ||| [arg_2] [function_1]	count=1
module	generalized ||| mechanics	count=1
class	polynomial ||| frac	count=1
arg	n in x ||| n a b x	count=1
function_arg	[function_1] k ||| [function_1] f [arg_2]	count=2
module	return the bifid cipher ||| crypto	count=1
arg	k[x] polynomial ||| f u k zero	count=1
function	polynomial exact pseudo-quotient ||| pexquo	count=1
function	direction ratio ||| direction ratio	count=4
arg	optimization opportunities ||| exprs order	count=1
function	of a square-free ||| sqf	count=1
module	the linearentity ||| geometry	count=1
arg	multiplicities ||| f multiple radicals	count=1
arg	rewrite [arg] using a ||| [arg]	count=1
arg	with public key ||| key seed	count=1
function	the module ||| get mod	count=1
function	[function_1] polynomial in ||| [function_2] [function_1]	count=1
function	[function_1] mul ||| [function_1] [function_2]	count=2
function	[function_1] free ||| [function_1] [function_2]	count=8
module	polynomials ||| polys	count=2
function	is strictly [function_2] ||| [function_1] [function_2]	count=6
function	orbits and ||| orbits	count=1
arg	[arg] positive ||| [arg]	count=1
class	converts mutabledensendimarray to ||| ndim	count=1
arg	return iterator [arg] generate ||| [arg]	count=1
arg	the form x ||| func	count=1
function	be of the ||| limits	count=1
function	with constant ||| constant	count=4
arg	defined by [arg] \cdot ||| [arg] w a	count=1
function_arg	[function_1] [arg_2] ||| [function_1] a [arg_2]	count=6
arg	ops ||| ops	count=1
arg	in the mul sorted ||| mul	count=1
function	be of the form ||| process	count=1
function	constants by functions ||| variable	count=1
function	the upper-hessenberg form ||| upper hessenberg	count=1
arg	t and the ||| t	count=1
function	identity homomorphism on ||| identity hom	count=4
function	the maximum possible value ||| max	count=1
function	evaluate a polynomial at ||| dmp eval	count=1
function_arg	zeros square [arg_2] ||| [function_1] cls r [arg_2]	count=2
class	evaluate the transform in ||| transform	count=1
module	the proper line ending ||| printing	count=1
arg	whether i ||| i	count=1
class	groebner [class_2] ||| [class_1] [class_2]	count=2
function	over the convergents ||| convergents	count=1
arg	[arg_1] and b ||| core n2 [arg_1] [arg_2]	count=1
class	polynomials ||| poly	count=2
function_arg	at p ||| at a p	count=1
arg	x gives ||| x	count=1
arg	[arg_1] basis ||| [arg_2] [arg_1]	count=1
arg	function for ||| func order match	count=2
function	writes a ||| get	count=2
function_arg	compute lcm [arg_2] ||| [function_1] [arg_2]	count=2
class	sympy sets ||| set	count=1
arg	multiplicative separation approach ||| fun sep strategy	count=1
class	set ||| finite set	count=1
function	respect [function] the given ||| [function]	count=1
function	inverse sine ||| asin	count=1
arg	binding power ||| s baseline binding	count=1
function_arg	[function_1] matching subexpressions ||| [function_1] query value [arg_2]	count=1
function	assumed ||| sturm pg	count=1
function	domain of ||| empty in	count=1
function	expand the ||| expand delta	count=1
module	in the specified ||| physics quantum	count=1
function	terms of the ||| terms	count=1
function	basic transversals relative ||| basic transversals	count=1
function	the angle bisectors ||| bisectors	count=1
arg	v [arg] (wu_{1} ||| u w [arg]	count=1
function	of coefficients of ||| content	count=2
function	[function_1] sentinel of ||| [function_2] [function_1]	count=1
module	pretty ||| pretty	count=1
module	a sum that ||| simplify	count=1
function	direction ratio between ||| direction ratio	count=2
function	the functions in ||| not empty in	count=1
module_class	which the ray ||| geometry ray	count=1
function	the sum of ||| do sum of	count=2
function	a list of sympy ||| sympy list	count=1
arg	[arg_1] index2 row ||| [arg_1] [arg_2]	count=6
function	the module and the ||| get mod	count=1
arg	and other ||| other	count=1
function	a sympy expression ||| expr	count=1
function	function is continuous ||| continuous domain	count=1
function	series of self ||| series	count=1
arg	s > [arg_2] ||| integrals simplifyconds expr [arg_1] [arg_2]	count=1
arg	to quantum ||| r	count=1
arg	multivariate polynomial f ||| f	count=2
function	a plan consisting ||| plan	count=1
class	create a ||| set	count=1
function	a unit ||| unit	count=1
function	expression in ||| in	count=1
function	[function] partitions of ||| [function]	count=1
function	for the convergence ||| is convergent	count=1
function	[function_1] constant ||| [function_2] [function_1]	count=5
arg	internal use ||| s	count=1
arg	for f [arg_2] ||| [arg_1] [arg_2]	count=4
function	z i ||| commutator zgate	count=1
module	a rotation [module] for ||| [module]	count=3
arg	eqs and checks ||| eqs	count=1
function	around the heurisch ||| heurisch	count=1
function	mpz ||| zz gmpy	count=1
arg	residual mod [arg] that ||| [arg]	count=1
arg	for [arg] terms ||| [arg]	count=1
function	as a mul ||| as coeff mul	count=2
arg	a base and strong ||| base gens	count=1
function	l1 norm ||| l1 norm	count=5
function	of irreducible factors of ||| factor	count=3
arg	text ||| text color align width	count=1
arg	true if expr ||| expr assumptions	count=1
function	examples ||| empty	count=1
function_arg	[function_1] [arg_2] ||| [function_1] poly [arg_2]	count=3
function_arg	bifid [arg_2] ||| [arg_2] [function_1]	count=1
function_arg	square the [arg_2] ||| [arg_2] [function_1]	count=1
function_arg	+ g*h [arg_2] ||| [function_1] f [arg_2]	count=1
arg	for fast calculation ||| args expr modules printer	count=1
arg	a condition [arg] given ||| condition [arg]	count=1
arg	in h ||| h	count=1
class	set ||| set	count=6
class	rectangles ||| complex root of	count=2
function	represents the bending moment ||| bending moment	count=1
function	polynomial ||| global polynomial	count=1
arg	a fraction field ||| a	count=1
function	multivariate ||| dmp zz	count=1
arg	p of ||| p	count=1
function	return whether [function] ||| [function]	count=1
function_arg	[function_1] factors ||| [arg_2] [function_1]	count=1
function	possible to a simplified ||| simplified	count=1
function	series expansion of given ||| series	count=1
function_arg	[function_1] base ||| [function_1] bsgs [arg_2]	count=2
function	convert a k[x] ||| dup	count=1
class	mutabledensendimarray ||| mutable sparse ndim array	count=1
function	scalar return ||| scalar	count=1
function	factors of a ||| factors	count=1
arg	bool where if two ||| two	count=1
function	a non-central chi ||| chi noncentral	count=2
function	intervals the expr ||| expr	count=1
arg	df ||| df	count=1
arg	about c ||| c condition	count=1
function	[function_1] a list ||| [function_2] [function_1]	count=6
function	the different types ||| naive	count=1
function_arg	down [arg_2] ||| [arg_2] [function_1]	count=1
class	for ||| function	count=1
arg	failing using [arg] ||| expr [arg]	count=1
module_class	in the [class_2] ||| [module_1] quantum qubit [class_2]	count=1
class	tuples index pos ||| index	count=1
function	apply additional [function_2] ||| [function_1] beta [function_2]	count=1
arg	at a ||| f m a	count=1
function	printing of expressions generated ||| vpprint	count=1
function	string path ||| mod	count=2
arg	are in z[x] or ||| x	count=1
function_arg	pseudo-division [arg_2] ||| [arg_2] [function_1]	count=2
class	faces ||| polyhedron	count=1
function	gcd using subresultants over ||| dup rr prs gcd	count=1
class	returns a standard basis ||| ring	count=1
function	[function_1] [function_2] ||| [function_2] isolate [function_1]	count=1
function_arg	minimum power [arg_2] ||| [arg_2] [function_1]	count=3
class	x c matrix of ||| dense matrix	count=1
function	absolute ||| abs	count=1
module_class	of the partition ||| combinatorics partition	count=1
class	in the diagram ||| diagram	count=1
arg	expressed [arg] ||| f s [arg]	count=2
class	for the values ||| method	count=1
function	a weak normal form ||| sdm nf mora	count=1
arg	apply func to [arg_1] [arg_2] ||| [arg_1] [arg_2]	count=4
function	[function_1] cdf ||| [function_2] [function_1]	count=2
arg	a and b have ||| a b	count=1
arg	rotation of theta in ||| theta	count=3
arg	[arg_1] field computed ||| [arg_1] [arg_2]	count=3
module	:py meth ~sympy solvers ||| solvers	count=1
function	return a factor ||| factor	count=1
function_arg	coset table [arg_2] ||| [function_1] [arg_2]	count=1
function	is a univariate ||| is univariate	count=3
arg	z at [arg_2] ||| [arg_2] [arg_1]	count=2
module	and return ||| utilities	count=1
class	list of tuples index ||| index	count=1
arg	replaced by ||| args kwargs n	count=1
function	multiply inplace ||| imul num	count=1
function_arg	integrate [arg_2] ||| [function_1] [arg_2]	count=5
arg	p k using ||| b p	count=1
module	standard ||| polys agca	count=2
function	[function] used ||| [function]	count=1
function	hilbert space ||| eval hilbert space	count=2
arg	a single ||| x a b	count=1
arg	for a given backend ||| backend	count=1
arg	x_0 ||| f m u	count=1
class	routine ||| code gen	count=1
module_class	[module_1] n-dim ||| [module_1] [class_2]	count=1
arg	the series expansion ||| x prec	count=4
arg	[arg_1] a ||| [arg_1] [arg_2]	count=29
arg	number of space ||| s	count=1
function	dimensions of each ||| shape	count=1
function	with the ||| get	count=1
function	remove ||| remove	count=1
arg	of morphisms between objects [arg_1] [arg_2] ||| categories diagram hom [arg_1] [arg_2]	count=2
function	as ||| as real	count=1
module	finds the domain ||| calculus	count=1
class	returns a standard basis ||| poly	count=1
arg	another subcircuit [arg] ||| [arg] subcircuit replace	count=1
class	[class_1] code ||| [class_1] [class_2]	count=3
function	sequence in a ||| seq	count=1
arg	expression e x for ||| e x	count=1
module	sparse diagonal [module] from a ||| [module]	count=1
arg	f as a ||| f x	count=1
function	hlt+lookahead method ||| look ahead	count=1
function_arg	[function_1] a given ||| [arg_2] [function_1]	count=3
arg	with public key i ||| i key seed	count=1
class	of the vector ||| f	count=1
arg	instance of fpgroup h ||| fp_grp h	count=1
function	tree as ||| tree	count=1
arg	operator in [arg_2] ||| [arg_1] [arg_2]	count=1
class	string [class] ||| [class]	count=1
arg	variable with a ||| name mean	count=1
function	symmetric ||| get symmetric	count=1
function	all ||| measure all	count=2
function	path ||| get mod	count=2
arg	get_unit method using key ||| key	count=1
function	unknown function that helps ||| search function	count=1
arg	base and strong generating ||| group base	count=1
function	common factors ||| factor	count=1
function_arg	indefinite integral [arg_2] ||| [arg_2] [function_1]	count=3
function	christoffel symbols for the ||| christoffel 2nd	count=1
arg	expression expressions are ||| expr callback_type	count=1
function	single gamma [function_2] ||| [function_1] [function_2]	count=3
function	1 instead ||| combine inverse	count=1
function_arg	points [arg_2] ||| [arg_2] [function_1]	count=1
function	preprocess ||| preprocess	count=1
function	available and leverage ||| pretty try	count=1
arg	[arg_1] [arg_2] to a string of ||| [arg_2] [arg_1]	count=8
function_arg	[function_1] [arg_2] ||| [function_1] horizontal [arg_2]	count=5
arg	arguments ||| args	count=1
function_arg	operators ops to ||| operators obj ops	count=1
function	functions ||| in	count=1
function	factor a [function_2] ||| [function_2] [function_1]	count=2
class	line ||| code	count=1
arg	[arg_1] j_3 ||| [arg_1] [arg_2]	count=5
function	of integers (n_{1}, n_{2}, ||| power representation	count=1
function	first derivative ||| fdiff	count=1
module_class	[module_1] __floordiv__ ||| [module_1] [class_2]	count=4
class	on a ||| commutator	count=1
class	with ||| printer	count=1
function	a single gamma ||| single	count=1
function	count ||| count	count=2
function	returns l1 norm ||| dmp l1 norm	count=3
arg	x_j in k[x] ||| n j	count=1
module	return ||| quantum	count=1
class	operator s [class_1] [class_2] an eigenstate of ||| [class_2] [class_1]	count=1
arg	root v ||| x v dom	count=1
module	in the ||| physics optics	count=1
function_arg	[function_1] [arg_2] ||| [function_1] f [arg_2]	count=98
function	[function_1] root ||| [function_2] [function_1]	count=14
function	sympy's ||| matrix2numpy	count=1
function	oo/oo return 1 instead ||| combine inverse	count=1
arg	[arg_1] g are ||| [arg_1] [arg_2]	count=1
arg	types [arg] integer and ||| [arg]	count=1
function	create particle if ||| is	count=1
class	gray code ||| gray code	count=6
arg	characters of key ||| key	count=1
function	f(exp_polar(2*i*pi*n + pi*i)*x), ||| minus	count=1
class	symmetric/alternating group ||| permutation group	count=1
function	the additive [function] symbol if ||| remove [function]	count=1
class	for the generated files ||| octave code gen	count=1
arg	distinct characters of symbols ||| symbols	count=1
function	berkowitz algorithm [function] whose entries ||| eval berkowitz [function]	count=1
function	gauss jordan ||| gauss jordan	count=1
class	parabola ||| parabola	count=6
arg	n items [arg_2] ||| [arg_1] [arg_2]	count=4
class	of ||| linear entity	count=1
function	computes a functional decomposition ||| decompose	count=1
function	a single [function_2] ||| [function_2] [function_1]	count=2
arg	a value to ||| value	count=1
function	[function_1] free indices ||| [function_2] [function_1]	count=2
module	return the ||| utilities	count=1
function	the sturm sequence ||| sturm	count=2
function	gate with ||| zbasis	count=1
function_arg	[function_1] [arg_2] ||| [function_1] syllables [arg_2]	count=3
arg	the sympy sense ||| include	count=1
function	a standard ||| groebner	count=1
function	tests whether [function] an ||| [function] function class	count=1
module	returns the number ||| combinatorics	count=1
module	and ||| solvers	count=3
function	returns the symbol corresponding ||| i2symbol	count=1
class	non-conjugate ||| complex root	count=1
function	form of singularity ||| singularity	count=1
function	surface ||| surface	count=1
function	is a common ||| common	count=2
arg	small'' matrix m to ||| deg_f deg_g	count=1
function	irreducible ||| factor	count=2
function	of the functions in ||| not empty in	count=1
arg	h a subgroup whose ||| fp_grp h	count=1
arg	of general form ||| x	count=1
module	for the generated ||| utilities	count=2
arg	negative coefficient muls ||| exprs order	count=1
arg	from the user ||| weylelt	count=1
arg	[arg_1] and target_matrix ||| [arg_1] [arg_2]	count=2
arg	triangle from triangles ||| triangles	count=1
function	[function] series ||| ode [function] power	count=1
module	location where p[i] > ||| combinatorics	count=1
arg	of eq such that ||| eq	count=1
function	specific integer modulus ||| modular integer	count=1
function	generate a free ||| free	count=2
function	increment the level ||| increment level	count=2
function	function for :func _dup_decompose ||| dup left decompose	count=1
function_arg	[function_1] with already-processed ||| [arg_2] [function_1]	count=1
module	string as ||| printing	count=1
function	always destroy ||| only	count=1
function	type of ||| linear 2eq	count=1
function	a morse ||| decode morse	count=1
module	+ 1 at most ||| solvers	count=1
function	power series ||| series	count=1
arg	the m ||| m	count=1
function_arg	exponentiation of [arg_2] ||| [arg_2] [function_1]	count=1
class	distribution ||| single discrete distribution	count=1
arg	a polynomial p in ||| f p	count=1
arg	series expansion of ||| n x prec	count=1
function	morse code with ||| decode morse	count=1
arg	the expression ||| expr index	count=1
function	[function] of ||| count [function]	count=1
function	[function_1] line inside ||| [function_2] [function_1]	count=3
function	which the ||| not empty in	count=1
function_arg	[function_1] an ||| [function_1] [arg_2]	count=9
function	[function_1] strong ||| [function_2] [function_1]	count=1
function_arg	normal ordered [function_1] [arg_2] ordered ||| [function_1] [arg_2]	count=1
module	of all [module] numbers in ||| [module]	count=1
module	list the list ||| combinatorics	count=1
function	cdf ||| cdf expression	count=2
class	system ||| dimension system	count=1
arg	polynomial irreducibility test over ||| f p	count=1
class	polynomials ||| poly ring	count=2
function	the given metric ||| metric to	count=2
class	[class] a, such ||| [class]	count=1
function	a random integer partition ||| random integer partition	count=1
module	the [module] the ||| [module]	count=2
function	are generated automatically ||| auto	count=1
arg	[arg] corresponding character ||| msg [arg]	count=2
function_arg	increasing in [arg_2] ||| [arg_2] [function_1]	count=2
arg	given first order ||| order	count=1
function	find optimization opportunities ||| opt	count=1
class	returns ||| permutation	count=2
function	to an algebraic integer ||| to algebraic integer	count=1
class	limits in ||| with int limits	count=1
function	coset ||| coset	count=3
arg	[arg] of ||| expr [arg]	count=3
function	primitive ||| primitive	count=6
module	bounding rectangles ||| polys	count=1
arg	of fpgroup h ||| fp_grp h	count=1
function_arg	[function_1] morphism is ||| [arg_2] [function_1]	count=2
function	mapping of ||| create param dict	count=1
function	the letter ||| letter	count=1
arg	[arg_1] and b ||| [arg_2] [arg_1]	count=47
function	given number of ||| indent	count=1
arg	and _hastypes to ||| attrs types	count=1
arg	x note ||| x	count=1
arg	in [arg_2] ||| [arg_1] [arg_2]	count=18
arg	[arg_1] z0 using ||| [arg_2] [arg_1]	count=5
function_arg	[function_1] i j ||| [arg_2] [function_1]	count=1
function	evaluation of mpf ||| mpf	count=1
function	is a zero ||| is zero	count=15
function	to the module and ||| get mod	count=1
module	returns true if ||| domains	count=4
function	function -> meijerg lookup ||| lookup	count=1
class	mapping ||| code	count=1
function	division with remainder of ||| div	count=1
function	class into ||| get mod func	count=1
arg	points in a certain ||| point1 point2	count=1
arg	j_1 [arg_2] ||| clebsch gordan [arg_1] j_2 j_3 [arg_2]	count=2
function	create a property where ||| property	count=1
function	to ||| mod	count=2
function	of syllables from positions ||| sub syllables	count=1
function	positional distance between ||| get positional distance	count=2
function	precedence matrix this is ||| get precedence matrix	count=1
function	[function_1] [function_2] matrixbase arguments ||| [function_1] [function_2] matmul	count=1
function_arg	hypergeometric [arg_2] ||| [function_1] [arg_2]	count=1
class	in the object ||| base	count=1
function	clairaut ||| order1 type5	count=1
function	negate [function_2] ||| [function_2] [function_1]	count=2
function	rayleigh ||| rayleigh	count=1
arg	[arg] of ||| mul [arg]	count=3
arg	is [arg] default ||| seq directed is_set [arg]	count=1
function	into it's matrix representation ||| matrix	count=1
arg	[arg_1] from gate_list ||| [arg_2] [arg_1]	count=2
function_arg	[function_1] coding ||| [function_1] [arg_2]	count=5
module	the specified qubits ||| physics	count=1
function	[function_1] a single ||| hep [function_1] [function_2]	count=1
function	and negative ||| opt cse	count=1
arg	[arg_1] irreducibility ||| [arg_1] [arg_2]	count=1
arg	the given ||| ratio	count=1
function	complex [function_2] ||| [function_2] [function_1]	count=1
arg	3 1 2 ; [arg_1] [arg_2] 1 3 2 3 ||| physics epsilon [arg_1] [arg_2]	count=1
function	gets the binary ordered ||| binary	count=1
arg	f ||| f s	count=1
class	ray and a ||| ray	count=1
class	set the components ||| lazy	count=1
function	return the truth ||| cond	count=1
function	decodes a morse code ||| decode morse	count=1
module_class	this point ||| vector point	count=2
function	berkowitz algorithm ||| eval det berkowitz	count=1
arg	[arg_1] [arg_2] ||| [arg_2] x [arg_1]	count=8
function	'/' separated [function] ||| convert to native [function]	count=3
function	the direction vector ||| direction	count=1
arg	f s ||| f s	count=3
function	translate substrings of ||| translate str	count=1
function	multiplies two lists representing ||| mulrowcol	count=1
class	increment ||| differential extension	count=1
function_arg	[function_1] component ||| physics hep extract type [function_1] [arg_2]	count=1
function_arg	[function_1] f defined ||| [function_1] [arg_2]	count=5
function	decide how to ||| hprint	count=1
function	substitution [function_2] ||| [function_2] [function_1]	count=1
class	the diagram ||| diagram	count=1
function	using ||| eval	count=2
function	sequences at infinity ||| seq	count=1
class	a simplified intersection ||| intersection	count=1
function	bound for ||| bound	count=1
function	quadrants from ||| to quadrants	count=1
function	returns the length ||| length	count=1
module	the list ||| combinatorics	count=1
function	splits a list ||| list	count=1
function	for specific integer ||| modular integer	count=1
function	whose presentation is to ||| reidemeister presentation	count=1
class	for the symmetric/alternating group ||| permutation group	count=1
arg	after subtracting [arg_2] ||| [arg_1] [arg_2]	count=4
arg	degree of f ||| f	count=1
function_arg	return the [function_1] [arg_2] ||| utilities [function_1] [arg_2]	count=1
function	[function_1] ratio between ||| [function_2] [function_1]	count=3
function_arg	roots of f ||| roots f k	count=2
arg	expr is bounded ||| expr	count=1
arg	== j ||| j	count=1
function	that dummies can be ||| ordered dummies	count=1
function	l1 ||| l1	count=3
arg	index2 row which ||| index2	count=1
function	codomain replaced ||| codomain	count=1
class	index ||| index	count=1
function	a nested tuple of ||| dmp to tuple	count=1
arg	[arg] homogeneous ||| [arg]	count=3
arg	lagrangesmethod lagrangian : ||| lagrangian	count=1
function	the domain ||| not empty in	count=1
function	points used to ||| points	count=1
module	of an algebraic number ||| polys	count=1
arg	c i e e( ||| n c	count=1
class	isolating interval ||| complex interval	count=1
function	calculates the semi-latus ||| semilatus	count=1
arg	of f by a ||| f c	count=1
function	interval ||| interval	count=6
class	generate a ||| module	count=2
arg	and for ||| a	count=1
class	of a single ||| var	count=1
function	is used ||| debug	count=1
function	returns the interior ||| interior	count=1
module	this sparsematrix ||| matrices	count=1
function_arg	expectation of [arg_2] ||| [function_1] [arg_2]	count=4
function	- stop on success ||| once	count=1
arg	whether indices are covariant ||| indices free	count=1
arg	if a given ||| eps	count=1
function	reconstruct ||| reconstruction	count=3
arg	false if n ||| n	count=1
arg	x_j at ||| j	count=1
module	and leverage ||| printing pretty	count=1
arg	tensmul object [arg_2] ||| [arg_2] [arg_1]	count=2
module	polynomials or containers of ||| polys	count=1
function	force to a ||| apply force	count=2
class	coordinate system with respect ||| coord	count=2
module_class	[module_1] lagrange ||| [module_1] [class_2]	count=2
function	iterable or ||| iterable	count=1
module	a positive literal ||| algorithms	count=1
class	the matrix ||| matrix	count=5
function	the heurisch ||| heurisch	count=1
function	replaced by indices ||| call	count=1
function	[function_1] not zero ||| [function_1] [function_2]	count=1
function	product ||| mul	count=7
arg	the value of n ||| factors n	count=1
arg	of two [arg_2] ||| [arg_1] [arg_2]	count=1
function	underlying undirected ||| get undirected	count=1
function	[function_1] hankel ||| [function_1] [function_2]	count=3
arg	with p2 ||| p2	count=1
function_arg	[function_1] function ||| [function_1] [arg_2]	count=16
module_class	[module_1] of stringpicts ||| [module_1] [class_2]	count=1
function	finds the ||| not empty in	count=1
arg	expression about c ||| c condition	count=1
arg	convert f into a ||| f u	count=1
class	a specific value ||| series base	count=1
function	quadratic in all ||| quadratic	count=2
function	a rational number ||| integer rational	count=1
function	[function] summation of ||| telescopic [function]	count=2
arg	f and ||| f	count=1
arg	is ||| r n	count=1
function	a base ||| base	count=1
class	differential ||| differential operator	count=1
function	function with ||| function base	count=1
function	the base of the ||| base	count=1
function	of the linearizer ||| to linearizer	count=1
function	classes to their ||| to	count=1
arg	every non-blank line in ||| s indent	count=1
function	rational power and den ||| rational power	count=1
function	the precedence of ||| precedence	count=1
function_arg	encryption of i ||| encipher rsa i	count=2
class	this [class] entity which ||| [class]	count=1
function	specified axes ||| tensorcontraction	count=1
arg	f to all ||| f atoms	count=1
arg	factor ||| factor	count=2
function	list of terms ||| as terms	count=1
function_arg	g*h where f ||| mul f	count=8
function_arg	[function_1] that ||| [function_1] [arg_2]	count=4
function	from ||| make	count=1
function	the module and the ||| mod	count=1
function	a distributed ||| sdm	count=1
function	products ||| product	count=1
function_arg	[function_1] p parameters ||| [arg_2] [function_1]	count=1
function	[function_1] of free ||| [function_2] [function_1]	count=2
function_arg	renumber [arg_2] ||| [arg_2] [function_1]	count=4
arg	p of k[t 1/t] ||| p	count=1
function_arg	[function_1] two polynomials ||| [function_1] f [arg_2]	count=5
function_arg	evaluate [arg_2] ||| [function_1] f m a [arg_2]	count=1
module	matrix sum ||| matrices	count=1
arg	variable representing a ||| name p succ	count=2
function	copy of ||| copy	count=1
function	of operators corresponding to ||| to operators	count=1
class	module ||| module quotient ring	count=1
function	into ||| mod	count=1
class	method ||| series base	count=2
arg	of morphisms between objects [arg_1] [arg_2] of morphisms listed as ||| categories diagram hom [arg_1] [arg_2]	count=1
function	an explicit [function] possibly trimming ||| [function]	count=1
function	true if the left ||| left	count=1
module	a vector distance ||| vector	count=1
arg	arbitrary constants [arg] ||| [arg] symbolname startnumber	count=2
module	random expression ||| stats	count=5
module	objects handles the ||| physics quantum	count=1
module	[module] expectation of ||| [module]	count=1
function	find the order ||| order	count=1
class	isolating interval until it ||| real interval	count=1
function	cells ||| cells	count=1
arg	[arg_1] variable ||| [arg_1] [arg_2] increment	count=2
function_arg	in gf [arg_2] ||| [function_1] factor sqf f [arg_2]	count=2
arg	x prec ||| x	count=1
module	the various ||| physics	count=1
arg	p == 1 ||| p	count=1
function	[function_1] truncation ||| [function_2] [function_1]	count=2
arg	if f ||| f k irreducible	count=1
function	common absolute value ||| process common	count=1
module	the kinematic differential ||| physics	count=1
arg	transform :math \int_{c+i\infty}^{c-i\infty} f ||| f	count=1
class	a specific value ||| base	count=1
function	anp object [function_2] ||| [function_2] [function_1]	count=4
arg	diagram ||| diagram	count=4
arg	eq ||| eq funcs	count=1
function	linear homogeneous differential ||| linear	count=1
arg	for p ||| p	count=1
arg	m_2 | j_3 ||| j_3	count=1
function	the finite difference approximation ||| apply finite	count=1
function	above fermi? >>> from ||| only above fermi	count=1
function_arg	the sopform [arg_2] ||| [arg_2] [function_1]	count=1
module_class	find the [class_2] ||| [module_1] [class_2]	count=3
function_arg	[function_1] ops ||| [function_1] obj [arg_2]	count=5
module	instance for the ||| physics	count=1
arg	[arg_1] [x] polynomial ||| [arg_1] [arg_2]	count=3
function	the subset defined by ||| subset from	count=1
arg	self other the keys ||| other	count=1
arg	independent [arg] knowledge ||| [arg]	count=1
arg	for [arg] ||| [arg]	count=1
function_arg	a power [arg_2] ||| [function_1] [arg_2]	count=2
function	a cyclotomic polnomial ||| cyclotomic	count=1
function	whether a partial ||| partial	count=1
function	not-empty ||| not	count=1
module	a standard basis ||| polys agca	count=1
arg	to integrate f ||| f	count=1
arg	readable object for a ||| pkgname	count=1
arg	f p [arg_2] ||| [arg_1] [arg_2]	count=7
function	the module and the ||| func	count=1
arg	p [x] and a ||| a	count=4
function	generates laguerre [function_2] ||| [function_2] [function_1]	count=1
arg	the list of \* ||| dir pat init_only	count=1
function	berkowitz algorithm [function] whose ||| eval berkowitz [function]	count=1
function	[function_1] maximum norm ||| [function_2] [function_1]	count=1
class	a diagram ||| diagram grid	count=1
function	given ||| parallel dict from expr if	count=1
function	coefficients try [function] transformation ||| [function] rational	count=1
module	not-empty ||| calculus	count=1
function	multiple of the corresponding ||| multiple	count=1
function	a string path ||| func	count=1
function	finds the domain ||| not	count=1
function	objects ||| objects	count=1
function	[function_1] syllables ||| [function_2] [function_1]	count=3
function	int ||| python	count=1
function	returns all [function_2] ||| [function_2] [function_1]	count=3
function	new line parallel to ||| parallel line	count=1
function	random element from ||| random stab	count=1
function	maximum norm of a ||| max norm	count=1
arg	x ||| n x	count=1
function	optimization ||| opt	count=1
module_class	of this dyadic ||| vector dyadic	count=1
function_arg	[function_1] in ||| [function_1] [arg_2]	count=48
function	[function_1] a zero ||| [function_1] [function_2]	count=6
function_arg	times pi [arg_2] ||| [arg_2] [function_1]	count=1
function	generates symmetric ||| symmetric	count=1
function	a wigner [function_2] ||| [function_1] [function_2]	count=2
function_arg	[function_1] expansion of ||| [arg_2] [function_1]	count=1
module	containers of ||| polys	count=1
function	a dictionary from a ||| dict	count=1
class	the total number of ||| type g	count=1
class	the generated files ||| code	count=1
arg	respect to g and ||| g	count=1
function	bounding ||| complexes	count=1
function	[function_1] in ||| [function_2] [function_1]	count=4
arg	q divides [arg_2] ||| [arg_2] [arg_1]	count=4
function	value ||| value	count=1
function	matrices pq and ||| matrices	count=1
arg	expr for ||| expr	count=1
function	the basic orbits relative ||| basic orbits	count=1
class	j) ||| sparse matrix	count=1
function	exact pseudo-quotient ||| pexquo	count=1
arg	x_j in [arg_2] ||| [arg_1] [arg_2]	count=1
function	it is assumed ||| sturm amv	count=1
class	printer ||| tensorflow printer	count=1
function	as part [function] false otherwise ||| needs [function]	count=1
function_arg	if key is in [function_1] [arg_2] ||| [function_1] [arg_2]	count=3
function	[function_1] sum ||| [function_2] [function_1]	count=4
function	polynomial ring i ||| old poly ring	count=2
function	a primitive form ||| primitive	count=1
class	[class] act ||| [class]	count=3
function	[function_1] key such ||| [function_1] [function_2]	count=1
arg	convert element ||| element	count=2
function	the lower [function_2] ||| [function_1] [function_2]	count=2
function	xor ||| xor	count=1
function	non-commutative objects replaced with ||| mask nc	count=1
function_arg	exact pseudo-quotient [arg_2] ||| [function_1] [arg_2]	count=2
function_arg	return [function_1] [arg_2] ||| diffgeom [function_1] [arg_2]	count=1
arg	expression about c i ||| c	count=1
module	tensor with an equivalent ||| tensor	count=1
class	the kb with ||| fact kb	count=1
function	descents in ||| descents	count=1
arg	a mod [arg] to ||| a [arg]	count=1
function	isolate [function_2] ||| [function_2] [function_1]	count=15
function	equivalent ||| equivalent	count=1
function	roots ||| real roots	count=2
function	finite difference approximation of ||| finite	count=1
function	run all ||| run all	count=2
arg	a k[x] [arg_2] ||| [arg_2] [arg_1]	count=2
module	returns the ||| liealgebras	count=1
function_arg	addition of [arg_2] ||| [arg_2] [function_1]	count=1
function	the lmq upper bound ||| root upper bound	count=1
function	the triangle ||| find triangle	count=1
arg	factors ||| factors u k	count=1
arg	calculate the anti-derivative ||| meijerg risch	count=1
arg	non-conjugate ||| cls	count=1
arg	of alpha ||| degree generators alpha	count=3
arg	b modulo [arg_2] ||| [arg_2] [arg_1]	count=3
function	mapping operator classes to ||| to state	count=1
function	to the module ||| mod func	count=1
function	restricted to values above ||| only above	count=1
module	the faces of ||| combinatorics	count=1
arg	two ||| f g	count=1
class	generate a ||| module quotient	count=1
arg	[arg_1] s over ||| [arg_2] [arg_1]	count=2
function	sequence [function_2] ||| [function_2] sin [function_1]	count=1
function	returns the minimal polynomial ||| minpoly	count=2
module	does the index of ||| physics	count=1
arg	elem ||| elem	count=2
function_arg	normal [function_1] [arg_2] ||| physics quantum [function_1] [arg_2]	count=2
function	nonzero ||| nonzero	count=1
function	compute reduced groebner basis ||| groebner	count=1
arg	a/d ||| d de	count=1
class	limits of expression ||| expr with limits	count=1
arg	ex1 ||| ex1	count=1
class	partition of itself ||| integer partition	count=1
arg	the finite_set is ||| finset_intersection	count=1
arg	polynomial f at ||| f i	count=1
function	\ldots x_{k-1}] [function_2] ||| [function_2] [function_1]	count=8
function	lmq lower bound for ||| root lower bound	count=1
arg	of f given a ||| f m k	count=1
function	primitive polynomial ||| primitive	count=2
function	sequences defined [function] ||| assoc [function]	count=1
function	apply on ||| call	count=1
function	table of ||| table	count=1
function	tangent [function_2] ||| [function_2] [function_1]	count=2
function	coefficient ||| as coeff	count=7
arg	any subexpression of f ||| f	count=1
module_class	[module_1] something ||| [module_1] [class_2]	count=8
function	finite difference approximation ||| apply finite	count=1
class	make ||| generic	count=2
class	that ||| base	count=2
function_arg	[function_1] levels using ||| [function_1] rep [arg_2]	count=1
arg	matching_symbol if [arg_2] ||| [arg_2] [arg_1]	count=1
function	dummies can be substituted ||| dummies	count=1
module	which the ||| calculus	count=1
function_arg	to power [arg_2] ||| [function_1] [arg_2]	count=2
arg	f in ||| f u	count=1
function	the equation is ||| is	count=1
function	[function_1] test ||| [function_2] [function_1]	count=1
function	the quadratic ternary diophantine ||| diop ternary quadratic normal	count=1
arg	a ||| a n p k	count=1
arg	to an accuracy of ||| subs maxn chop	count=1
arg	f x ||| f x	count=5
function_arg	[function_1] [arg_2] ||| polys subresultants [function_1] [arg_2]	count=8
function	binary ordered ||| binary	count=3
function	atan ||| rs atan	count=2
module	a ||| domains	count=1
arg	mod(p** s + ||| s	count=1
arg	it [arg] are comparable ||| [arg]	count=1
function	order of classes ||| class	count=1
function	of a root to ||| root	count=2
arg	the grid and ||| grid fringe	count=1
function	into a string ||| mod	count=1
class	distribution ||| distribution	count=2
function	exact quotient by ||| exquo	count=2
function	sequence in [function_2] ||| [function_2] [function_1]	count=1
function	a von mises ||| von mises	count=2
function	dot product [function_2] ||| [function_2] [function_1]	count=3
arg	[arg_1] to t ||| [arg_1] [arg_2]	count=1
function	composed [function] prod(p2 ||| rs compose [function]	count=1
module	writes ||| utilities	count=2
class	string of [class_2] ||| [class_1] [class_2]	count=1
class	prufer sequence ||| prufer	count=1
function	dummies can be substituted ||| ordered dummies	count=1
function	less than the range ||| lt	count=1
arg	simplifies the [arg_2] ||| [arg_2] [arg_1]	count=4
function	convert modularinteger ||| ff	count=3
arg	[arg] make all ||| [arg]	count=1
arg	poly compatible ||| poly	count=1
arg	if it already is ||| symbol	count=1
function	ground ||| dmp ground	count=1
function	[function_1] entire free ||| [function_1] [function_2]	count=2
arg	f in k[x], ||| f u k	count=1
arg	do ||| do	count=1
class	that are ||| differential	count=1
class	object excluding those ||| base	count=1
arg	:func _symbolic_factor ||| opt method	count=1
class	for ||| method	count=1
class	on the intersection ||| expr op	count=1
module	said to be the ||| ntheory	count=1
function	into [function_2] ||| [function_2] [function_1]	count=2
function_arg	monomials from [arg_2] ||| [function_1] [arg_2]	count=1
function_arg	[function_1] [arg_2] ||| [function_1] rep [arg_2]	count=1
function_arg	[function_1] of an ||| [arg_2] [function_1]	count=11
module	plane along the ||| geometry	count=1
function_arg	a key [arg_2] ||| [function_1] [arg_2] triangle_sizes	count=1
function_arg	functions in expr ||| functions expr x	count=1
function	the convergents ||| convergents	count=1
function_arg	triangle [arg_2] ||| [function_1] [arg_2]	count=6
function	homomorphism with ||| hom	count=1
function	comment ||| get comment	count=1
arg	[arg_1] token ||| [arg_1] [arg_2]	count=3
arg	other is ||| other	count=4
function	[function_1] difference between ||| [function_1] [function_2]	count=4
function	[function_1] space ||| [function_2] [function_1]	count=11
arg	limit or [arg_2] ||| [arg_2] [arg_1]	count=3
function	laplace [function_2] ||| [function_2] [function_1]	count=2
function	mpmath's mpf to ||| real field	count=3
arg	expansion using formula ||| p iv prec	count=1
function	start of sequences ||| prefix	count=1
module	of self by ||| polys agca	count=4
module	proper line ||| printing	count=1
arg	integers [arg] root2 ||| [arg]	count=1
class	the transform ||| transform	count=2
arg	if other is is ||| other	count=1
function	the finite ||| apply finite	count=1
function	returns the operation count ||| count	count=1
function	- a [function_2] ||| [function_2] [function_1]	count=1
function_arg	[function_1] ex1 ||| [arg_2] [function_1]	count=1
function_arg	[function_1] c is ||| [function_1] [arg_2]	count=1
function_arg	[function_1] h as ||| [function_1] [arg_2]	count=4
function	[function_1] for ||| [function_2] [function_1]	count=1
function	minimum [function_2] ||| [function_2] [function_1]	count=2
arg	[arg_1] s ||| symbol [arg_2] [arg_1]	count=3
function	the symbol ||| literal symbol	count=1
function	is [function_2] ||| geometry point [function_1] [function_2]	count=5
function	representation ||| rep	count=1
arg	supply the following ||| qs coneqs forcelist	count=1
arg	c ||| n c	count=1
function	(self's) [function] ||| [function]	count=3
arg	are the actual ||| func	count=1
function	odes ||| 3eq order1 type3	count=1
arg	root if it ||| root	count=1
function	the jacobian matrix ||| jacobian	count=1
arg	rule ||| rule	count=6
class	and a -1 ||| a	count=1
arg	[arg_1] out ||| [arg_2] [arg_1]	count=6
arg	return namespace ||| expr namespace	count=1
function	the name ||| func	count=1
function	homomorphism with same ||| hom	count=1
function	of the form ||| process limits	count=1
function	coefficient of a summation ||| as coeff	count=3
function_arg	square-free factor ||| sqf cls factor	count=1
arg	modulo ||| p	count=1
function_arg	[function_1] a ||| [function_1] sympy [arg_2]	count=16
arg	eq that contain any ||| eq	count=1
function	returns the product ||| mul	count=1
function	[function_1] product of ||| [function_2] [function_1]	count=4
class	returns a ||| poly ring	count=1
arg	f in [arg_2] ||| [arg_2] [arg_1]	count=7
arg	using key ||| key	count=2
arg	in x_j at a ||| m a j	count=1
class	rectangles of non-conjugate ||| complex root	count=1
function	coefficient of a ||| coeff add	count=3
module	of qubits this ||| quantum	count=2
arg	p2 in ||| p2	count=1
function	the inverse mellin ||| inverse mellin	count=2
arg	l ||| l d2	count=1
arg	class initiated from ||| q_ind qd_ind q_dep qd_dep	count=1
arg	creates a small'' matrix ||| deg_f deg_g row1 row2	count=1
function	a class into ||| mod	count=1
function_arg	[function_1] [arg_2] of a positive integer ||| [function_1] [arg_2]	count=6
arg	g functions ||| g x	count=1
module	symbolic base ||| core	count=1
arg	field in k[x] ||| g u k	count=1
arg	polynomial in k[x] ||| m u k	count=1
module_class	[module_1] dyadic ||| [module_1] vector [class_2]	count=1
class	self to the module ||| module quotient ring	count=1
function	structure ||| structure	count=1
arg	polynomials in [arg_2] ||| [arg_1] [arg_2]	count=3
module	color ||| plotting pygletplot	count=1
class	bounding rectangles of ||| complex root	count=1
function_arg	polynomial for [arg_2] ||| [arg_2] [function_1]	count=3
arg	count of e ||| e	count=1
function	[function_1] hankel transform ||| [function_2] [function_1]	count=3
arg	to [arg_1] [arg_2] ||| [arg_1] [arg_2]	count=8
arg	[arg_1] using _dcm_dict ||| [arg_1] [arg_2]	count=1
function	[function_1] to ||| [function_2] [function_1]	count=33
arg	from k0 ||| u k0	count=1
arg	of expression over ||| expr	count=2
function	decimal instance [function_2] ||| [function_2] [function_1]	count=3
function	is nilpotent ||| is nilpotent	count=2
arg	compute polynomial ||| f g	count=1
arg	the key ||| key symbols	count=1
function_arg	[function_1] using vincent-akritas-strzebonski ||| [arg_2] [function_1]	count=3
function	canonical form ||| canonical	count=1
class	a polygon ||| polygon	count=1
function	[function_1] orbits relative ||| [function_1] [function_2]	count=2
function	self to an algebraic ||| to algebraic	count=1
function	ending of sequences ||| suffix	count=1
module	generate a ||| polys agca	count=2
arg	return an equivalent sentence ||| expr	count=2
module	every lie algebra ||| liealgebras	count=1
arg	[arg_1] [arg_2] ||| [arg_1] g [arg_2]	count=12
class	polynomials or containers of ||| poly ring	count=1
class	indices creating new ||| index structure	count=1
class	line ending ||| code	count=1
function	files ||| get test files	count=2
arg	the matching_symbol if ||| matching_symbol	count=1
class	false if any coordinate ||| point	count=1
function	[function_1] l1 norm ||| [function_1] [function_2]	count=1
module_class	the coset ||| combinatorics coset	count=1
function	general ||| diop general	count=1
function	c*b1 + ||| add	count=1
function	nth root ||| nth root1	count=1
module	returns ||| categories	count=1
function	using [function] ||| [function]	count=1
arg	f defined as ||| f k	count=1
function	rational number \frac a ||| integer rational	count=1
arg	polynomials [arg_2] ||| [arg_2] [arg_1]	count=14
class	of this frame in ||| reference frame	count=1
function	return square-free part of ||| sqf part	count=1
module	string with mathml code ||| mathml	count=1
module	a quantum ||| physics quantum	count=1
function	form of sign ||| sign	count=1
arg	q divides [arg_2] ||| [arg_1] [arg_2]	count=4
arg	two labeled polynomials ||| g	count=1
arg	enabled ||| function_args function_kwargs command	count=1
class	return ||| frac	count=1
function	ideal ||| ideal	count=2
arg	see usage examples e ||| initial	count=1
function_arg	[function_1] alpha ||| [function_1] transversal [arg_2]	count=4
class	of the group ||| permutation group	count=1
function	a force to a ||| apply force	count=1
class	overloading for ||| boolean	count=1
arg	targets and [arg_2] ||| [arg_2] [arg_1]	count=1
class	bounding rectangles of ||| complex	count=1
function	list of sympy ||| sympy list	count=1
function	op ||| op algebraic element	count=1
function	bounding rectangles ||| complexes	count=1
function	[function_1] hash ||| [function_2] [function_1]	count=5
module	[module] point ||| physics [module]	count=2
arg	and g which are ||| g exps	count=1
arg	\; j_2 m_2 | ||| j_2	count=1
function	structure of the ||| structure	count=1
arg	[arg_1] \; j_2 ||| [arg_2] j_3 [arg_1]	count=1
arg	k of the ||| k	count=1
function	mpq ||| qq	count=7
class	return ||| frac field	count=1
class	this sparsematrix ||| sparse matrix	count=1
function	algebra ||| algebra	count=4
class	this ||| series base	count=2
function_arg	[function_1] coding ||| [arg_2] [function_1]	count=5
function	the direction ratio between ||| direction ratio	count=1
arg	the morphisms ||| morphisms	count=1
function	pair ||| pair	count=1
module	on a specific value ||| series	count=1
function	right ||| right	count=2
arg	i in the ||| i	count=1
function	[function_1] normal ||| [function_1] [function_2]	count=4
function	the focal distance ||| focus distance	count=1
function	finite_set ||| not empty	count=1
class	of subsset ||| subs set	count=1
arg	a transformation ||| to_sys coords	count=1
function	or an expression ||| expr	count=1
function_arg	[function_1] lhs - ||| [arg_2] [function_1]	count=1
function	[function_1] terms ||| [function_1] [function_2]	count=2
arg	z at ||| z	count=1
module	the ||| functions	count=4
function_arg	affine [arg_2] ||| [function_1] [arg_2]	count=2
function	a dict ||| as dict	count=1
arg	[arg] have numbers ||| [arg] symbolname startnumber	count=1
class	and a ||| type a	count=1
class	dyadic and a vector ||| dyadic	count=1
arg	targets and ||| targets	count=1
class	the proper line ||| code	count=1
function	add the ||| indent	count=1
module	return ||| functions elementary	count=2
function_arg	[function_1] if n ||| [arg_2] [function_1]	count=4
function	opportunities ||| cse	count=1
function	leverage it ||| pretty try use	count=1
class	the proper ||| printer	count=1
function	inverse laplace ||| inverse laplace	count=2
function	that take ||| free	count=1
function	logarithm of ||| rs log	count=1
function	presentation is ||| reidemeister presentation	count=1
function	discriminant ||| discriminant	count=1
function	compute the dagger ||| eval adjoint	count=1
function	the gcd of coefficients ||| ground content	count=1
class	known [class] 'rotation ||| coord [class]	count=1
function	true if [function_2] ||| [function_2] [function_1]	count=1
arg	a polynomial ||| minpoly	count=1
class	method returns ||| series base	count=1
rep	[module_class_1] [function_arg_2] ||| [module_class_1] [function_arg_2]	count=14
function	the number of inversions ||| inversions	count=1
class	polyhedra we can get ||| polyhedron	count=1
function	piecewise [function_2] ||| [function_2] [function_1]	count=4
function	are ||| linear 2eq	count=4
arg	integer power ||| power	count=1
function	generates all the positive ||| positive	count=3
module_class	of [module_1] [class_2] ||| [module_1] [class_2]	count=89
function_arg	substitution [arg_2] ||| [arg_2] [function_1]	count=1
class	a sequence of polynomials ||| ring	count=1
arg	the base b modulo ||| b order	count=3
function	to y_i in a ||| deflate	count=1
function_arg	[function_1] p [x] ||| [function_1] add f g [arg_2]	count=1
arg	given ||| expr	count=1
function	apply state to self ||| apply operator	count=2
module_class	the [class_2] ||| [module_1] [class_2] partition	count=4
function_arg	push a [arg_2] ||| [function_1] [arg_2]	count=8
arg	compute partial ||| f	count=1
arg	and for each di ||| a	count=1
class	self accumulationbounds object ||| accumulation bounds	count=3
class	polynomial ||| poly	count=36
class	for the generated files ||| octave	count=1
function_arg	[function_1] expansion ||| [arg_2] [function_1]	count=1
arg	convenience if reduction is ||| cls ai bj	count=1
class	this [class] which ||| [class]	count=1
class	return ||| base	count=1
module	the canonical base ||| physics units	count=1
arg	-> x + a ||| x	count=1
function	matrix corresponding to the ||| matrix	count=1
class	the ||| piecewise	count=2
function	compute buckets ||| compute buckets	count=1
arg	the public key n ||| key	count=1
function	[function_1] terms of ||| [function_1] [function_2]	count=2
function	convert modularinteger int ||| ff python	count=2
arg	alpha as a ||| degree generators alpha pairs	count=1
arg	objects [arg] ||| [arg]	count=2
arg	points ||| points incremental	count=1
arg	m_{\alpha} ||| p	count=1
arg	running it on the ||| brule fns	count=1
arg	for this ||| expr	count=1
function_arg	[function_1] to name ||| [function_1] [arg_2]	count=3
module_class	a return value ||| utilities result	count=1
class	with the proper line ||| code printer	count=1
function	trace of [function_2] ||| hep [function_1] [function_2]	count=6
function	indices ||| get indices	count=1
arg	= b m ||| b a b	count=1
function	prime ||| zz modular	count=1
class	element of this module ||| module	count=1
class	polynomial ||| poly ring	count=1
class	dtype ||| polynomial ring base	count=4
function	to a fully ||| tensorhead from tensmul	count=1
function_arg	orbit of alpha ||| orbit alpha	count=1
arg	sympy import lex ||| v order	count=1
function	these type ||| 2eq order2	count=1
function	the m-th order derivative ||| diff	count=1
arg	r] for p ||| p	count=1
module	p[i] > ||| combinatorics	count=1
function	method of undetermined ||| undetermined	count=2
arg	k \in [0 \ldots ||| k	count=1
arg	[arg_1] **2 ||| [arg_2] [arg_1]	count=1
function	to a [function_2] ||| [function_1] sympy [function_2]	count=2
class	those ||| base	count=1
function	of singularity ||| rewrite as singularity	count=1
function	to an ode from ||| ode	count=1
module_class	return [module_1] [class_2] ||| [module_1] [class_2]	count=3
module	mathml ||| mathml	count=2
class	that are ||| extension	count=1
function	rule [function] ||| top [function]	count=1
class	polynomial p ||| poly	count=1
function	logarithmic derivative ||| log deriv	count=1
function_arg	n [arg_2] ||| [arg_2] [function_1]	count=5
class	generate ||| free module	count=2
function_arg	[function_1] f g ||| [function_1] [arg_2]	count=16
function_arg	[function_1] an exponential ||| [arg_2] [function_1]	count=4
module	value ||| series	count=1
function_arg	n-th coefficient [arg_2] ||| [arg_2] [function_1]	count=6
arg	is a model ||| expr model deep	count=1
arg	returns a ||| a b	count=1
function	the positional distance between ||| get positional distance	count=1
function	of the asin of ||| rs asin	count=1
class	mutabledensendimarray to matrix can ||| ndim	count=1
function	no ||| no	count=1
function	[function_1] a fourier ||| [function_2] sin [function_1]	count=1
function_arg	roots [arg_2] ||| [function_1] [arg_2]	count=17
arg	[arg_1] a given ||| [arg_2] [arg_1]	count=2
arg	s , ||| s t plane	count=2
module_class	number of roots ||| liealgebras type g	count=1
function	[function_1] constants ||| [function_1] [function_2]	count=4
function_arg	rotates left [arg_2] ||| [function_1] l l [arg_2]	count=1
function_arg	pseudo-quotient of [arg_2] ||| [arg_2] [function_1]	count=2
function	lu the decomposition to ||| lu	count=1
arg	in phrase [arg_2] ||| [arg_1] [arg_2]	count=1
arg	replaced by the ||| kwargs n	count=1
function	normal ||| normal order terms	count=1
function_arg	[function_1] [arg_2] ||| [function_1] hom [arg_2]	count=6
arg	point other lies ||| other	count=1
function	atan of ||| atan	count=1
class	representation of associative ||| free group element	count=1
function	[function] taylor series ||| taylor [function]	count=1
arg	on \xi and \eta ||| match comp	count=3
function	from generators ||| gens from	count=2
arg	[arg_1] pt ||| [arg_2] [arg_1]	count=4
class	tensor ||| anti symmetric tensor	count=1
module	identities from the ||| physics	count=1
function	to a ||| apply	count=1
class	object ||| series base	count=2
function	substitution with ||| subs	count=1
class	the lagrange ||| lagranges	count=1
function_arg	the sopform function ||| sopform variables	count=1
arg	lhs - [arg_2] ||| [arg_1] [arg_2]	count=4
function	rotation about lambda ||| orient	count=1
function	of the cosh ||| cosh	count=1
function	a power [function_2] ||| 2nd [function_1] [function_2]	count=1
arg	provided p is not ||| p c	count=1
function	the identity ||| identity	count=4
function_arg	the scaler-row multiplication ||| mulrowscaler row scaler	count=1
class	permutation ||| permutation	count=2
arg	at the given position ||| name position	count=1
arg	modulo n ||| n	count=3
function	at each vertex ||| angles	count=1
class	using lu decomposition note ||| deprecated	count=1
class	dtype ||| polynomial ring	count=5
function	focal ||| focus	count=1
function	[function_1] polynomial gcd ||| [function_1] [function_2]	count=3
arg	representation [arg] ||| [arg]	count=1
arg	f ||| f front	count=2
function	premises of this ||| premises	count=1
function	of ||| process	count=1
function_arg	[function_1] [arg_2] ||| [function_1] triangles fringe [arg_2]	count=10
function_arg	ode [arg_2] ||| [arg_2] [function_1]	count=1
function	and evaluate a ||| eval	count=1
function	the direction vector of ||| direction	count=1
arg	residual mod [arg] ||| [arg]	count=1
function	name of the class ||| get mod	count=1
class	of this linear ||| linear	count=1
class	a new code block ||| code block	count=1
function	the ||| get	count=7
function	logarithmic derivative [function_2] ||| [function_2] [function_1]	count=2
arg	k \in [0 ||| k	count=1
function	codomain replaced by codomain/sm ||| quotient codomain	count=1
module	the specified ||| physics quantum	count=1
function	root ||| dup inner	count=1
function	ode [function_2] ||| [function_2] [function_1]	count=8
class	the components data ||| data lazy	count=1
function	expand the first add ||| expand delta	count=1
class	of coset table ||| coset table	count=2
function	conjunctions and disjunctions of ||| distribute and over or	count=1
arg	and returns the ||| msg	count=1
function	linear partial ||| pde 1st linear	count=2
arg	x of [arg_2] ||| [arg_2] knots [arg_1]	count=4
arg	summation of [arg] with respect ||| [arg]	count=1
function	solve the equation ||| solve as	count=1
function	third heuristic assumes the ||| lie heuristic bivariate	count=1
arg	return an ||| cls	count=4
arg	[arg_1] two polynomials ||| [arg_2] [arg_1]	count=3
arg	f g h are ||| f g h k	count=2
function	opening statements of the ||| get routine opening	count=2
function	[function_1] a scalar ||| geometry point [function_1] [function_2]	count=1
arg	be expressed [arg] ||| f s [arg]	count=2
function	another fraction field ||| from fraction field	count=2
function	numbers to a ||| from	count=1
class	returns the total ||| g	count=1
function	[function_1] matrix line ||| [function_1] [function_2]	count=4
class	formal ||| formal	count=1
function	[function_1] evaluate ||| [function_1] [function_2]	count=1
arg	of space characters to ||| s	count=1
class	product ||| mul	count=2
function_arg	[function_1] for n ||| [arg_2] [function_1]	count=2
class	group ||| free group element	count=1
module	m corresponding to the ||| physics	count=1
function	free space ||| free space	count=4
class	gray code of ||| gray code	count=2
function	finite_set in which ||| not empty in	count=1
arg	mod [arg] to ||| a [arg]	count=1
function	common start ||| common prefix	count=2
function	hull surrounding the points ||| hull	count=1
function	horizontal ||| horizontal	count=1
function	if unicode output ||| unicode	count=1
class	to ||| algebraic field	count=1
arg	the routines in ||| routines f prefix funcname	count=1
function	higher in rank than ||| add	count=1
function	[function_1] zero ||| [function_1] [function_2]	count=7
function	class into a string ||| func	count=1
function	motion in explicit ||| explicit rhs	count=1
function	lu the ||| lu	count=1
function_arg	[function_1] pairs affect ||| [function_1] [arg_2]	count=5
function	is available and ||| try use	count=1
function	cholesky factorization of ||| cholesky	count=1
function_arg	lambdify [arg_2] ||| [function_1] [arg_2]	count=2
function	an sdm from ||| sdm from	count=2
function	to correct the values ||| correct	count=1
function	map ||| map	count=2
function_arg	set the [arg_2] ||| [arg_2] [function_1]	count=7
function	periodic ||| periodic	count=1
function	full partial fraction ||| full	count=1
arg	factors has root ||| factors	count=1
arg	domain of p1 ||| p1	count=1
function_arg	returns [arg_2] ||| [arg_2] [function_1]	count=5
class	d) [class] ||| [class]	count=1
function_arg	[function_1] stringpict and ||| [arg_2] [function_1]	count=1
function	into a string path ||| get	count=1
module	state ||| quantum	count=6
module_class	the schreier ||| combinatorics permutation group	count=1
function	key for [function_2] ||| [function_2] [function_1]	count=2
arg	[arg] the ||| d [arg]	count=1
class	mutabledensendimarray to matrix can ||| dense ndim	count=1
class	that no bounding ||| complex root of	count=1
function	gaussian elimination ||| ge	count=1
function	cells of ||| cells	count=1
arg	in f and ||| f k	count=2
function	the direct product ||| mul	count=1
function	the cyclic notation from ||| cyclic	count=1
function	rational ||| eval rational	count=1
function	sympy matrix/complex ||| sympy	count=1
class	whether a set ||| set	count=2
function	which are free ||| free	count=1
function	a common ending ||| common suffix	count=2
module_class	of this composite ||| categories composite	count=2
function_arg	[function_1] [arg_2] ||| [function_1] neg [arg_2]	count=8
module	mapping of ||| printing	count=1
arg	c from self and ||| c	count=1
module	of this ||| matrices	count=1
function	list of sympy coefficients ||| sympy list	count=1
arg	x [arg_2] ||| holzer [arg_1] [arg_2]	count=5
function	function is [function_2] ||| [function_1] [function_2] expression interval symbol	count=3
function_arg	zero [arg_2] ||| [arg_2] [function_1]	count=2
module	scipy ||| physics quantum	count=1
class	of ||| subs	count=1
arg	in s, and ||| s	count=1
function	trial ||| trial	count=3
arg	q[x] ||| k0	count=1
module	by the kinematic differential ||| physics	count=1
arg	of terms of f ||| f m n j	count=1
arg	of n [arg_2] ||| [arg_2] [arg_1]	count=5
arg	given domain ||| symbol domain	count=2
function	a gamma ||| gamma	count=1
function	set from ||| from	count=1
module_class	this dyadic in ||| vector dyadic	count=1
arg	x_j in ||| j	count=2
function	polyomials in ||| dup	count=1
function	returns the closing ||| get routine ending	count=1
function	not-empty ||| in	count=1
module_class	of the free ||| combinatorics free	count=1
function	devise a plan consisting ||| devise plan	count=1
function_arg	[function_1] exponentiation ** ||| [function_1] [arg_2]	count=2
arg	denests a ||| av0 h max_depth_level	count=1
arg	sympy expression expressions ||| expr callback_type	count=1
arg	name and token ||| name token	count=3
arg	our container modulo ||| nf	count=1
function	rational [function_2] ||| [function_2] [function_1]	count=5
function	trigamma ||| trigamma	count=1
function_arg	[function_1] for suitability ||| [arg_2] [function_1]	count=4
arg	entries in subs to ||| subs	count=1
function	constant coefficients ||| constant coeff	count=7
function	ending ||| suffix	count=1
module	cross product [module] x dyadic ||| [module]	count=1
arg	return complexes such ||| cls complexes	count=1
class	latex ||| latex printer	count=1
arg	field computed along ||| vect	count=1
function	leverage ||| pretty try	count=1
function	to the same ||| to	count=1
arg	the [arg] i ||| [arg]	count=1
function	n-link pendulum [function_2] ||| [function_2] [function_1]	count=5
class	in the diagram ||| diagram grid	count=1
arg	negative coefficient ||| order	count=1
arg	pt -- default ||| pt	count=1
function	the coefficient of a ||| as coeff	count=7
arg	and for ||| a d de z	count=1
function	[function] cholesky factororization ||| [function] symbolic	count=1
class	pstack if ||| multiset partition traverser	count=2
module	of ||| series	count=2
function	into a ||| to	count=1
function	which ||| not empty in	count=1
function	+ g*h ||| add mul	count=5
