class	return a tree-like ||| parser	count=1
function	masked rec array ||| masked rec array	count=3
arg	which is a ||| to_concat	count=1
class	of the ||| series	count=1
function	create [function_2] ||| [function_1] [function_2]	count=1
function	numpy / pandas type ||| type	count=1
function	[function_1] a groupby ||| [function_2] [function_1]	count=2
class	node must ||| hdfstore	count=1
function	expanding ||| expanding	count=2
module	needs additional handling ||| indexes	count=1
class	array ||| sparse array	count=1
arg	query in a ||| index_col coerce_float	count=1
class	stacked format dataframe ||| data frame	count=1
function	and returns axes if ||| axes	count=1
arg	in file node ||| key value format	count=1
function	applies a moving window ||| apply window	count=1
function	string-like ||| convert string array	count=2
function	all the [function_2] ||| [function_1] [function_2]	count=1
class	index for series ||| ndframe	count=1
function	pack ||| packb	count=1
arg	from 1-dimensional ndarray ||| key	count=1
function	[function_1] closest period ||| [function_2] [function_1]	count=2
arg	new datacol with ||| name cname	count=1
class	more ||| ndframe	count=1
arg	sequence of terms for ||| terms	count=1
function	return a string representation ||| unicode	count=1
class	return the number of ||| multi	count=1
function	to capture stderr in ||| capture stderr	count=1
arg	[arg_1] n ||| [arg_2] [arg_1]	count=4
function	return dtype and n/a ||| get empty dtype and	count=1
function	indices overlap add suffixes ||| overlap	count=1
function	cut where ||| cut	count=1
arg	and right ||| right exact	count=1
arg	possibly casting ||| na_values try_num_bool	count=1
function	[function_1] [function_2] ||| [function_1] str [function_2]	count=3
arg	possible that [arg] ||| mask [arg]	count=2
arg	conversion method for ||| method	count=1
arg	indexer input ||| indexer	count=1
module	property property synonym ||| core	count=1
arg	kwargs ||| kwargs	count=1
function	an [function_2] ||| [function_1] [function_2]	count=4
function	try to convert to ||| maybe to	count=1
function_arg	union [arg_2] ||| [function_1] [arg_2]	count=2
function	full length ||| full	count=1
function	cast it to ||| cast	count=1
function	names to ||| set default names	count=1
arg	to avoid code duplication ||| name str_rep default_axis	count=1
arg	indexer like _name in ||| cls name indexer	count=1
arg	fill with the fill_value ||| allow_fill fill_value	count=1
arg	1-dimensional ndarray ||| key	count=1
function	[function_1] offset/observance to ||| [function_2] [function_1]	count=1
arg	and its label ||| label	count=1
function	a block ||| make block	count=1
class	of sparse/dense and ||| ndframe	count=1
module	:class packer ||| io	count=1
module	reshape ||| reshape	count=1
arg	input value ||| value	count=1
class	1-dimensional ndarray only use ||| index	count=1
function	of entries in index ||| make custom index	count=1
function	[function_1] str ||| [function_2] [function_1]	count=3
module	list-like of ||| core	count=1
module	length is ||| core	count=1
function_arg	init self [arg_2] ||| [arg_2] [function_1]	count=3
function	one higher dimension ||| expanddim	count=1
arg	manager for temporarily setting ||| new_locale lc_var	count=1
function	the required package is ||| package	count=1
function	sets index names to ||| default names	count=1
function	get the [function_2] ||| [function_1] dtype [function_2]	count=1
arg	[arg] actual ||| values [arg]	count=1
arg	in file node must ||| value	count=1
function	data to [function_2] ||| [function_1] [function_2]	count=2
arg	values can be any ||| values name freq	count=1
function_arg	from a [arg_2] ||| [function_1] arrays [arg_2]	count=4
function	in index ||| make custom index	count=1
function	rewrite the assignment ||| rewrite	count=1
function	wide panel ||| wide	count=1
arg	on where ||| key where start	count=1
function	we take a string-like ||| convert string array	count=1
function	colummn ||| attr	count=1
function	[function_1] given ||| [function_2] [function_1]	count=5
function_arg	[function_1] [arg_2] as self ||| [function_1] class values [arg_2]	count=2
class	from maps[0] raise keyerror ||| chain map	count=1
class	[class] going ||| [class]	count=1
function	ndarray only use this ||| set value	count=1
function_arg	[function_1] and expected ||| [function_1] matches [arg_2]	count=3
module	dimensions ||| core	count=1
function	cast the array/value ||| maybe cast	count=1
arg	[arg_1] 'kwargs' ||| [arg_2] [arg_1]	count=4
function	[function_1] ftypes in ||| [function_2] [function_1]	count=4
arg	the blocks collect and ||| f axis consolidate transposed	count=1
class	set ||| sparse series	count=1
function	dtypes to object ||| dtypes	count=1
function	from a [function_2] ||| [function_2] [function_1]	count=2
arg	a higher freq with ||| cls value freq	count=1
class	each index value is ||| datetime index ops	count=1
function	shift ||| shift	count=2
class	object that can be ||| parser	count=1
function	a masked rec ||| masked rec	count=2
arg	left and right ||| cls left right	count=2
arg	use this if ||| arr key	count=1
class	categorical ||| categorical index	count=2
function	process of casting ||| assert safe casting	count=1
function	generate ||| generate	count=1
function	boolean ndarray denoting ||| duplicated	count=1
class	columns for dataframe and ||| ndframe	count=1
arg	numpy values ||| values	count=1
function	validate that we have ||| is	count=1
arg	with labels [arg_2] ||| [arg_2] [arg_1]	count=1
function_arg	table [arg_2] ||| [arg_2] [function_1]	count=8
function	single ||| simple blockify	count=1
function	font object ||| font	count=1
function	a string-like that is ||| string array	count=1
class	additional handling ||| index	count=1
arg	only use ||| key	count=1
function	bind [function_2] ||| [function_1] [function_2]	count=1
function	[function_1] size ||| [function_2] [function_1]	count=1
module	from maps[0] raise keyerror ||| compat	count=1
function_arg	[function_1] as ||| [function_1] [arg_2]	count=1
module	or offset ||| tseries	count=1
module	the ||| core	count=93
function	utc [function] days preserving ||| dt to [function]	count=1
function	size ||| size	count=1
module	sets the ||| core	count=1
function	[function_1] counts ||| [function_1] ftype [function_2]	count=1
function	this ||| set	count=1
function	common [function_2] ||| [function_2] plot logic [function_1]	count=1
function	[function_1] the counts ||| [function_1] ftype [function_2]	count=1
arg	or more existing ||| keys drop append	count=1
function	valid keys across my ||| valid tuple	count=1
class	to iterate over ||| html frame	count=1
function	for interpolate bpoly from_derivatives ||| from derivatives	count=1
function	histogram of the dataframe's ||| hist	count=1
module	new [module] inserting ||| [module]	count=1
class	iterate over ||| frame	count=1
module	single element ||| core	count=1
function	[function_1] dtype ||| [function_1] [function_2]	count=1
arg	[arg_1] axis ||| [arg_2] [arg_1]	count=1
class	values attribute if ||| series	count=1
class	validates that ||| categorical	count=1
function	[function_1] 1d array ||| [function_2] [function_1]	count=3
function	header rows in multiindex ||| pop header	count=1
module	a simple cross-tabulation ||| core	count=1
arg	frequency conversion [arg_2] ||| [arg_1] [arg_2]	count=1
class	manager ||| manager	count=2
function	dict of ||| dict	count=1
function	compat for our index ||| index	count=1
function	render the ||| render	count=1
module	an expression ||| core computation	count=1
arg	upgrading in place ||| mode propindexes keys	count=1
function	delimiter string starting at ||| rsplit	count=1
module	the decimal ||| io	count=1
function_arg	value [arg_2] ||| [function_1] [arg_2] takeable	count=1
function	dtype ||| infer dtype	count=1
arg	higher freq with integer ||| cls value freq	count=1
module	datetime index ||| core indexes	count=2
class	returns a dataframe ||| sparse data frame	count=1
class	[class_1] for groupby ||| [class_2] [class_1]	count=1
arg	of the [arg] if ||| [arg]	count=1
function	object are unique ||| unique	count=1
function	that ||| validate	count=1
function	datetime to the ||| to	count=1
function	function for series ||| bool method series	count=2
function	[function_1] [function_2] ||| [function_1] dtype [function_2]	count=2
arg	fill_value ||| fill_value	count=2
arg	op on a ||| op op_str a	count=3
function	selection ||| selection	count=1
arg	whether ||| compat_args	count=1
function	gets ||| get	count=2
function	see :class packer for ||| packb	count=1
function_arg	[function_1] ndarray ||| [function_1] matrix [arg_2]	count=1
function_arg	require [arg_2] ||| [function_1] cls values [arg_2]	count=2
arg	data to an ndarray ||| data index	count=1
function	is a ||| is	count=5
function	[function] to given ||| tz [function]	count=1
function_arg	repr [arg_2] ||| [arg_2] [function_1]	count=2
function_arg	[function_1] fillvalue for ||| [function_1] [arg_2]	count=2
module	times to midnight ||| core	count=1
class	that dict ||| parser	count=1
module	sparse/dense ||| core	count=1
function	of non-na/null observations ||| count	count=1
arg	converts a ||| num_format_str	count=1
function	indexer even ||| get indexer for	count=1
arg	dataframe the levels ||| data values index columns	count=1
function	datetimelike methods (as we ||| datetimelike methods	count=1
class	values and index ||| index	count=1
arg	fixed size ||| encoding itemsize	count=1
class	the actual ||| bin op	count=1
arg	an expression in the ||| expr inplace	count=1
arg	block ||| block	count=1
class	the number of ||| index	count=2
function	retrieve single [function] at ||| [function]	count=1
class	return the number ||| multi	count=1
function_arg	[function_1] [arg_2] using the provided connection ||| [function_1] [arg_2]	count=1
class	a tree-like object that ||| html	count=1
class	manager with ||| manager	count=1
arg	function to ||| func mgr	count=1
function	labels ||| get compressed ids	count=1
arg	optional fill ||| fill_value	count=1
function	a scalar [function_2] ||| [function_2] [function_1]	count=6
arg	dataframe columns ||| data x y	count=1
arg	of ||| arr	count=1
class	return the number ||| range index	count=1
module	its ||| core	count=1
function	to shift without copying ||| shift	count=1
module	strings to numpy ||| compat numpy	count=1
function_arg	pads it with null [function_1] [arg_2] ||| io pad [function_1] [arg_2]	count=1
arg	value from 1-dimensional ||| value	count=1
arg	by the indexer fill ||| indexer	count=1
arg	convenience function for ||| xi yi x der	count=1
class	index objects contain the ||| index	count=2
arg	ndarray ||| arr	count=1
function	add ||| add delegate	count=1
arg	or by a ||| by axis level	count=2
function	the 'numpy' library ||| validate take with convert	count=1
arg	data ||| cls data	count=1
function_arg	[function_1] of dates ||| [function_1] [arg_2]	count=2
function	of the string ||| string	count=1
class	index objects ||| datetime index ops mixin	count=1
function	[function_1] merge ||| [function_2] [function_1]	count=6
arg	data converts ||| data	count=1
arg	for selected item ndarray ||| item fastpath	count=1
arg	a and b ||| a b	count=4
module	get the ||| core	count=1
function	an index ||| index	count=1
arg	rows/cols [arg] idx_names ||| nrows ncols [arg]	count=1
class	index objects contain ||| datetime index ops	count=1
function_arg	a repr [arg_2] ||| [function_1] [arg_2]	count=2
function_arg	[function_1] ncols - ||| [arg_2] [function_1]	count=1
module	ndarray only use this ||| indexes	count=1
module	schema resets the index ||| io json	count=1
function	values for ||| get level values	count=1
function	hash ||| hash	count=2
function	[function_1] only ||| [function_2] [function_1]	count=3
arg	with nat-like arg is ||| arg errors	count=1
arg	from other to ||| other method	count=1
arg	utility frequency ||| freq	count=1
function	our native [function_2] ||| [function_2] [function_1]	count=12
function_arg	type in [arg_2] ||| [arg_2] [function_1]	count=1
function	a string-like that ||| convert string array	count=1
function	for scalar ||| can do	count=1
function_arg	ensure that [arg_2] ||| [arg_2] [function_1]	count=2
function	table as a ||| table	count=1
function	[function_1] location ||| [function_1] [function_2]	count=4
function	html ||| html	count=2
function_arg	prior [arg_2] ||| [arg_2] [function_1]	count=1
class	iterate over the ||| html frame	count=1
module	datetimeindex with times to ||| indexes	count=1
module	additional handling as ||| core indexes	count=1
class	dataframe to ||| data frame	count=1
class	are valid stata ||| stata writer	count=1
class	to the underlying ||| datetime index ops mixin	count=1
module	single element pandasobject ||| core	count=1
function	we have a ||| ordered	count=1
function	to turn ||| for	count=1
arg	ndarray ||| index columns dtype	count=1
arg	non-tuple ||| target	count=1
function_arg	[function_1] arg ||| [function_1] unit mappings [arg_2]	count=1
function	the mode s ||| mode	count=2
arg	the key or ||| key	count=1
function_arg	[function_1] already made ||| [function_1] [arg_2]	count=4
function	called prior ||| array prepare	count=1
function	lookup of ||| set value	count=1
module	as ||| core indexes	count=3
function	a block of same ||| make block same	count=1
function_arg	[function_1] in ||| [arg_2] [function_1]	count=2
function	little [function_2] ||| [function_2] [function_1]	count=1
function_arg	a categorical possibility ||| categorical array	count=1
function	result and reset test_results ||| result	count=1
function_arg	[function_1] termvalue ||| [arg_2] [function_1]	count=1
function	alert ||| alert	count=1
function_arg	[function_1] terms ||| [function_1] [arg_2]	count=1
module	fast lookup ||| indexes	count=1
function_arg	expanding [arg_2] ||| [function_1] apply arg [arg_2]	count=1
arg	to table in ||| value	count=1
function_arg	[function_1] [arg_2] ||| [function_1] apply index i [arg_2]	count=5
module_class	return block for ||| core block	count=1
function	overlap ||| overlap	count=1
function	counts ||| counts	count=1
arg	utility frequency [arg_2] ||| [arg_2] [arg_1]	count=1
arg	node must already exist ||| value format	count=1
function_arg	the intersection [arg_2] ||| [arg_2] [function_1]	count=2
class	to midnight length ||| index	count=1
module	this is ||| core	count=1
function	to parse ||| convert data	count=1
module	get ||| core computation	count=1
class	a series ||| series group	count=1
arg	substrings ||| start stop step	count=1
arg	given axis [arg_2] ||| [arg_2] [arg_1]	count=1
arg	of query in ||| index_col coerce_float	count=1
arg	exist and ||| key value	count=1
arg	from ndarray or ||| index	count=1
module	from maps[0] raise ||| compat	count=1
arg	a single non-tuple ||| target	count=1
arg	argument return ||| arg	count=1
arg	values can be any ||| values	count=1
class	multiindex has only ||| multi	count=1
function	compute pairwise correlation ||| corr	count=1
class	tree-like ||| frame parser	count=2
arg	given sql query ||| sql con	count=1
class	don't care ||| rolling	count=1
function	infer the fill value ||| infer fill value	count=1
class	used to ||| html	count=1
function	table in file node ||| append	count=1
arg	compute a ||| index columns	count=1
arg	utility frequency [arg_2] ||| [arg_1] [arg_2]	count=1
function_arg	with [arg_2] ||| [function_1] node [arg_2]	count=3
function	apply a ||| apply	count=1
arg	indexer like ||| name indexer	count=1
class	used ||| ndframe	count=1
function	create ||| create indexer	count=2
function	a data ||| validate data columns	count=1
class	of whether each index ||| index	count=1
function_arg	cartesian product [arg_2] ||| [function_1] cls iterables [arg_2]	count=1
function	that an positional ||| valid positional	count=1
function_arg	[function_1] of multiple ||| [arg_2] [function_1]	count=3
function	to connect to ||| connect	count=1
function	use this if you ||| set value	count=1
function	as_blocks() ||| blocks	count=1
arg	retrieve ||| handler	count=1
function	values between particular ||| between	count=2
function	represent time-seires ||| timeseries	count=1
class	sparse/dense and ||| ndframe	count=1
arg	3 columns of ||| index columns	count=1
module	return slice of ||| core	count=2
function	convert timedelta-like to ||| td index cmp	count=1
function_arg	[function_1] data from ||| [arg_2] [function_1]	count=4
function	without null ||| dropna	count=1
function	to sif ||| to	count=1
arg	one or more existing ||| keys drop append	count=1
arg	dom ||| doc	count=1
function	dtype ||| get empty dtype	count=1
class	a series we by ||| series group by	count=1
function_arg	for given [arg_2] ||| [arg_2] [function_1]	count=2
function	stop ||| stop	count=1
class	writer ||| writer	count=1
function	as a [function_2] ||| [function_1] [function_2]	count=2
arg	func to ||| func	count=1
function_arg	[function_1] of obj ||| [function_1] slice [arg_2]	count=2
class	used to iterate over ||| parser	count=1
function_arg	specified [arg_2] ||| [arg_2] [function_1]	count=2
class	underlying ||| datetime index ops mixin	count=1
function	times in parallel ||| parallel	count=1
function_arg	[function_1] this argument ||| [function_1] [arg_2]	count=2
class	make new index ||| categorical index	count=1
module	if not found ||| core	count=1
function	with null [function] until ||| pad [function]	count=1
module	return packed ||| msgpack	count=1
arg	indexer and ||| indexer	count=2
arg	a dataframe the ||| data values index columns	count=1
module	object that ||| io	count=1
arg	specified dtype ||| dtype	count=1
class	the ||| multi index	count=2
module	only use this if ||| indexes	count=1
function	counts [function_2] ||| [function_2] [function_1]	count=6
arg	[arg_1] dataframe and ||| [arg_2] [arg_1]	count=2
class	replace ||| block manager	count=1
function	parse specified sheet ||| parse	count=1
arg	to table ||| key value	count=1
arg	an ndarray copy ||| copy	count=1
arg	we have good categories ||| cls categories fastpath	count=1
class	of the timestamps ||| index	count=1
class	to panel ||| panel	count=1
arg	needs additional handling as ||| result	count=1
function	a string cast it ||| cast	count=1
class	[class] column names ||| [class]	count=3
function	sets index names to ||| set default names	count=1
function	string starting at ||| rsplit	count=1
arg	to target time zone ||| tz	count=1
function	a string ||| string	count=2
class	return the number ||| range	count=1
class	handling ||| period	count=1
function	block [function_2] ||| [function_2] [function_1]	count=1
function	in file ||| append	count=1
module	remove and return ||| compat	count=1
arg	table in ||| value	count=1
function	the counts of ||| counts	count=1
arg	and arr dtype ||| arr	count=1
function_arg	[function_1] *not* ||| [arg_2] [function_1]	count=4
function	to a set ||| to	count=1
arg	to our original type ||| dtype	count=1
arg	regular expression ||| flags	count=4
module	is a ||| indexes	count=1
function	parse [function_2] ||| [function_2] [function_1]	count=2
function	use this ||| set	count=1
arg	obj with indexer ||| obj indexer	count=3
function	a particular ||| bytes	count=1
module	shade [module_2] ||| [module_2] [module_1]	count=2
class	supported for panel objects ||| panel	count=1
arg	the new ||| copy	count=2
class	a tree-like object that ||| html frame	count=1
function	fname ||| validate kwargs	count=1
function	create a [function_2] ||| [function_2] [function_1]	count=5
class	am never ||| categorical	count=1
arg	self [arg] ||| data [arg] columns	count=1
arg	packed ||| packed object_hook list_hook use_list	count=1
module	boolean indicating whether the ||| io	count=1
arg	index if the ||| index	count=1
function	result and ||| result	count=1
function_arg	swap level [arg_2] ||| [function_1] [arg_2]	count=7
class	as a frame table ||| series table	count=2
function	of the keys corresponding ||| keys	count=1
function	string ||| parsed string to	count=1
function	called ||| wrap	count=3
function	[function_1] a named ||| [function_2] [function_1]	count=1
arg	of the values ||| axis	count=1
module	needs ||| core	count=1
arg	function ||| func mgr	count=1
function_arg	[function_1] slice or ||| [arg_2] [function_1]	count=3
class	a ||| categorical block	count=2
module	product [module] all possible ||| [module]	count=1
function_arg	result [arg_2] ||| [function_1] data columns [arg_2]	count=1
function	via the 'numpy' library ||| validate take with	count=1
function	convert timedelta-like to ||| td index	count=1
class	called ||| period index	count=2
arg	a fixed size ||| encoding itemsize	count=1
arg	if the key ||| key	count=1
class	index and its ||| index	count=1
function_arg	quantile [arg_2] ||| [function_1] [arg_2]	count=1
class	parameter ||| categorical	count=1
class	gets called ||| index	count=2
module	internal property ||| core	count=1
class	for dataframe ||| ndframe	count=1
function	is of the string ||| is string	count=1
function	an item pair ||| popitem	count=1
function	new copy of ||| copy	count=1
function	a masked [function_2] ||| [function_1] [function_2]	count=6
function	[function_1] and create ||| [function_2] [function_1]	count=6
function	[function] whose ||| [function]	count=3
function	node must ||| append	count=1
function	in numeric unary methods ||| numeric methods unary	count=1
module	formats a ||| io formats	count=1
class	this if you ||| index	count=1
function	registered ||| registered	count=1
function_arg	and pads it with [function_1] [arg_2] chars ||| io [function_1] name [arg_2]	count=1
arg	upgrading ||| mode propindexes keys	count=1
function	values as ||| values	count=1
function	:mod datetime to the ||| dt to	count=1
function	cast the ||| cast	count=1
arg	and be ||| key value	count=1
arg	ndarray only use this ||| arr key	count=1
module	as ||| indexes	count=2
arg	already made ||| naxes sharex sharey squeeze	count=1
arg	and params args ||| params	count=1
module_class	indices that would sort [module_1] [class_2] 'sort_values' was called ||| [module_1] [class_2] argsort ascending	count=1
arg	is [arg] ||| [arg]	count=1
function	the ||| build	count=1
module	compute a ||| core reshape	count=1
arg	location in the ||| loc	count=1
module	a single ||| core	count=1
arg	value from ||| arr key value	count=1
arg	compute ||| values	count=1
class	remove and ||| chain	count=1
function	this ||| set value	count=2
function	[function_1] value for ||| [function_1] [function_2]	count=4
module	state from the ||| io	count=1
arg	regular expression ||| arr pat case flags	count=1
function_arg	[function_1] two ||| [function_1] [arg_2]	count=20
arg	new item ||| item	count=1
class	the underlying ||| index	count=2
class	group [class_2] ||| [class_1] [class_2]	count=1
module	styles to ||| io formats	count=1
module	from 1-dimensional ndarray only ||| indexes	count=1
function	given an interval or ||| get interval	count=1
function	0 number ||| number	count=1
function	a string format ||| format	count=1
arg	columns of this ||| columns values	count=1
class	underlying ||| range index	count=1
arg	etc' nentries - number ||| nentries nlevels prefix	count=1
function	values between particular times ||| indexer between	count=1
arg	do a ||| src_list dest_list inplace regex	count=1
class	to iterate over ||| parser	count=1
function	[function_1] [function_2] of ||| [function_1] [function_2]	count=4
function	to iterate ||| build	count=1
arg	a b ||| a b	count=1
function	boolean if values ||| is	count=1
function_arg	[function_1] the dtype ||| [function_1] [arg_2]	count=2
module	for ||| core indexes	count=2
module	fast ||| core	count=1
class	single block and ||| block manager	count=1
arg	elements of arr1 ||| arr1	count=1
arg	of values values ||| values	count=1
function_arg	[function_1] [arg_2] ||| [function_1] to protection [arg_2]	count=1
class	already exist ||| hdfstore	count=1
arg	if s is a ||| s	count=1
function	we have a ||| validate	count=1
arg	the values ||| values ndim	count=1
function	[function_1] sparse ||| [function_1] [function_2]	count=3
function_arg	[function_1] binary ||| [arg_2] [function_1]	count=4
class	be used ||| html frame	count=1
module	of a single ||| core	count=1
class	object ||| frame	count=1
function	try to operate on ||| try	count=1
module	packer for options ||| io	count=1
module	set of [module_2] ||| [module_1] [module_2]	count=8
function	coerce a [function_2] ||| [function_2] [function_1]	count=7
class	return index or ||| index ops mixin	count=1
arg	node ||| value	count=1
function_arg	[function_1] [arg_2] ||| [function_1] to alignment [arg_2]	count=1
class	index or ||| index	count=1
function	bind a ||| bind	count=1
class	create index ||| index	count=1
arg	block by ||| axis mgr	count=2
class	up styles to html ||| styler	count=1
function	return a html ||| html	count=1
class	a tree-like ||| frame	count=1
arg	right ||| right check_exact check_dtype	count=1
class	ndarray [class_2] ||| [class_2] [class_1]	count=6
function	ftypes (indication of ||| ftypes	count=1
function	gets called after a ||| array wrap	count=3
function	parse the raw data ||| parse raw data	count=1
class	check ||| block manager	count=1
module	the ||| io	count=44
function_arg	[function_1] a tabular ||| [arg_2] [function_1]	count=1
class	maps[0] ||| chain map	count=2
module	data ||| core	count=2
function	load a pickle with ||| load	count=1
function	leap year ||| is leap year	count=2
function_arg	is [arg_2] ||| [function_1] [arg_2]	count=3
arg	rhs ||| rhs	count=1
function	dtype try ||| maybe	count=1
class	into a list ||| html frame parser	count=1
class	timedelta ||| timedelta	count=1
function	with integer stride ||| get stride	count=1
function	a leap [function_2] ||| [function_1] [function_2]	count=1
function	the info axis of ||| get info	count=1
arg	must ||| key value format	count=1
function	dtype to ||| dtype	count=1
module	packed ||| io	count=1
module	a simple cross-tabulation of ||| reshape	count=1
function	the required package ||| package	count=1
function	to parse ||| parse	count=1
arg	in ||| key	count=1
arg	fill_value and ||| fill_value	count=1
arg	exist and ||| key	count=1
function_arg	types [arg_2] ||| [function_1] [arg_2]	count=2
arg	dataframe ||| data values index	count=1
arg	be a single block ||| new	count=1
module	gets the ||| core	count=2
arg	and other ||| other	count=1
function	path [function] a ||| file path [function]	count=1
class	create a new multiindex ||| multi index	count=1
arg	with level j do ||| j	count=1
module	never a ||| core	count=1
arg	and [arg] see :class ||| o [arg]	count=1
function	set [function] item ||| set [function]	count=1
module	1-dimensional ||| core	count=1
function_arg	[function_1] into ||| [arg_2] [function_1]	count=2
arg	[arg_1] indexer ||| [arg_2] [arg_1]	count=2
function	join ||| join	count=4
class	a single element ||| ndframe	count=1
function	of index to be ||| index	count=1
function	get ||| get	count=16
arg	columns of ||| columns values	count=1
arg	by a series ||| by	count=1
arg	from some accepted ||| cls	count=1
function	(e g [function_2] ||| [function_2] [function_1]	count=1
function	converted [function] periodindex at ||| [function]	count=1
class	return ||| chain map	count=1
arg	axis [arg_2] ||| [arg_2] [arg_1]	count=3
function_arg	a sparse array ||| sparse array	count=1
function_arg	string and pads it [function_1] [arg_2] chars ||| io [function_1] name [arg_2]	count=1
arg	moving ||| window	count=1
class	datetimeindex with times ||| datetime	count=1
function	a regex pattern instance ||| re	count=2
function	from ||| from string	count=4
class	timestamps/timedelta ||| like block mixin	count=1
class	myself ||| datetime tzblock	count=1
function	optional positional and keyword ||| optional	count=1
function	is an iterator ||| is iterator	count=2
class	a ||| frame parser	count=2
function	wide panel [function_2] ||| [function_1] [function_2]	count=2
function	of available options ||| options	count=1
module	set the ||| io	count=3
class	datetimeindex with times ||| datetime index	count=1
function	[function_1] a locale ||| [function_2] [function_1]	count=3
function_arg	[function_1] statement is ||| [arg_2] [function_1]	count=3
function	that ||| ordered	count=1
arg	be ||| value format	count=1
arg	you ||| arr key	count=1
arg	type_map ||| fmt	count=1
module	series columns ||| core	count=1
function	[function_1] series only ||| [function_2] [function_1]	count=1
function	validate [function_2] ||| [function_1] [function_2]	count=1
function	to operate on ||| try operate	count=1
function_arg	arr1 [arg_2] ||| [arg_2] [function_1]	count=3
class	single block and are ||| block manager	count=1
arg	of the _apply kwargs ||| name window center	count=1
arg	object o and return ||| o	count=1
function	temporarily setting a timezone ||| timezone	count=1
arg	left and right array ||| cls left right closed	count=1
function	for valid ||| valid	count=1
module	to its values ||| core	count=1
function_arg	where [arg_2] ||| [function_1] [arg_2]	count=4
function_arg	op result [arg_2] ||| [arg_2] [function_1]	count=2
class	a styler ||| styler	count=1
function	index ||| assert index	count=1
arg	use this ||| arr	count=1
function	as block ||| getitem block	count=1
arg	after a ufunc needs ||| result context	count=1
module	additional ||| core	count=1
function	[function_1] mixed ||| [function_2] [function_1]	count=3
function	parameter if ||| validate	count=1
function	the inferred types one ||| inferred type levels	count=1
function	base ||| base	count=2
function	a repr function return ||| repr	count=1
function	by str ||| str	count=1
arg	the labels ||| labels	count=1
class	block ||| block	count=14
function	index row ||| index	count=1
arg	a simple cross-tabulation ||| index columns	count=1
function	to coerce ||| maybe coerce	count=1
arg	ufunc ||| result context	count=4
arg	node must already ||| key value format	count=1
function_arg	intersection [arg_2] ||| [function_1] [arg_2]	count=2
function	like to ||| string like	count=1
function	info axis ||| info	count=1
arg	[arg_1] method for ||| [arg_1] [arg_2]	count=2
arg	nrows ncols ||| nrows ncols	count=1
module	table ||| io	count=2
module	for ||| core sparse	count=2
arg	index if ||| index	count=1
class	has one ||| series	count=1
function	a string-like ||| string	count=1
arg	object coercible to ||| other join overwrite filter_func	count=1
arg	[arg_1] in ||| [arg_2] [arg_1]	count=2
function	read csv file ||| csv	count=2
arg	other to [arg_2] ||| [arg_2] [arg_1]	count=2
module	function to create an ||| computation	count=1
module_class	[module_1] categorical ||| [module_1] [class_2] argsort ascending	count=1
function	date formats to ||| convert datetime to	count=1
function	[function_1] counts ||| [function_2] [function_1]	count=1
arg	to left <= ||| left	count=1
function	over the dom ||| doc	count=1
module	options ||| msgpack	count=1
arg	simple ||| index columns	count=1
arg	slice or ||| key	count=1
module	the built ||| io formats	count=1
arg	[arg_1] with ||| [arg_2] [arg_1]	count=4
function	compat ||| sort levels monotonic	count=1
class	for panel objects and ||| panel	count=1
function_arg	time [arg_2] ||| [arg_2] [function_1]	count=1
function	validate if we ||| validate for	count=1
arg	upgrading in place parameters ||| mode propindexes keys	count=1
function	group of [function_2] ||| [function_2] freq [function_1]	count=1
function	[function] using ||| [function]	count=2
function_arg	compare numeric [arg_2] ||| [arg_2] [function_1]	count=1
class	a series ||| series	count=4
class	called after ||| period index	count=1
function	2d from ||| dropna	count=1
arg	specified categories ||| categories	count=1
arg	dataframe ||| data x	count=1
arg	indices parameters ||| indices	count=1
function	a floating ||| maybe cast indexer	count=1
function	determine ||| n method	count=1
function_arg	[function_1] to indexer ||| [arg_2] [function_1]	count=2
arg	difference of n ||| n axis	count=2
function	return dtype [function_2] ||| [function_2] [function_1]	count=4
function	evaluate ||| eval	count=1
arg	makes sure that time ||| time	count=1
function_arg	a categorical [arg_2] ||| [arg_2] [function_1]	count=2
function	[function_1] a type ||| [function_1] [function_2]	count=4
arg	and other to int64 ||| other	count=1
arg	left and right data ||| left right	count=1
module	up styles to ||| formats	count=1
arg	delimiter ||| sep	count=1
function	[function_1] type ||| [function_1] [function_2]	count=4
module	create/cache ||| io	count=1
function	[function_1] display ||| [function_2] [function_1]	count=1
function	block of [function_2] ||| [function_2] [function_1]	count=1
function	or sparsearray ||| sparse	count=1
function	[function_1] endian ||| [function_1] [function_2]	count=1
arg	input function ||| copy	count=1
class	stop kwds in sparse ||| sparse	count=1
function	routine to turn ||| for	count=1
function	test result ||| test result	count=2
arg	float key and are ||| key	count=1
function	for header rows ||| pop header	count=1
function	coerce a [function_2] ||| [function_1] [function_2]	count=7
function	for ||| packb	count=1
arg	going back [arg] levels ||| [arg]	count=1
function	validate the ||| validate	count=1
function	with ||| get	count=1
arg	compute a ||| columns	count=1
arg	helper function to ||| rowlabels collabels	count=1
module	the number of ||| indexes	count=2
class	return ||| categorical	count=2
module	concatenation ||| core dtypes	count=2
function	resolve a variable ||| resolve	count=1
function	all the [function_2] ||| [function_1] timeseries [function_2]	count=1
class	maps[0] ||| map	count=2
class	of this ||| index	count=1
function	validate that an positional ||| positional setitem	count=1
class	value in [class] ||| [class]	count=6
arg	panel or object coercible ||| join overwrite filter_func	count=1
function	ftypes in this object ||| ftype	count=1
module	the node in ||| io	count=1
function_arg	define an internal [function_1] [arg_2] it ||| [function_1] [arg_2]	count=3
class	new chainmap or subclass ||| chain map	count=1
arg	only considering ||| subset	count=2
arg	of columns ||| columns	count=2
arg	from the result ||| raise_on_error	count=1
class	a ||| series	count=1
function	format of ||| format	count=1
module	the same ||| core	count=1
function	be ||| as	count=1
class	to html ||| styler	count=1
arg	append ||| format append	count=1
function_arg	location [arg_2] ||| [arg_2] [function_1]	count=6
function	malformed row ||| malformed	count=1
arg	floating point [arg] nans ||| [arg]	count=1
arg	tables into ||| io match flavor	count=1
function	size of the ||| itemsize	count=1
arg	packed ||| packed object_hook list_hook	count=1
arg	key for ||| key	count=1
class	data ||| multi index	count=1
function	going to write ||| write	count=1
function	names to ||| default names	count=1
function	simple cross-tabulation ||| crosstab	count=1
function	[function_1] of a ||| [function_2] [function_1]	count=1
class	to midnight length is ||| index	count=1
function	[function_1] post ||| [function_2] plot logic [function_1]	count=1
class	table in file node ||| hdfstore	count=1
arg	left and right ||| left right check_dtype	count=7
function	date formats to a ||| convert datetime to	count=1
class	can be ||| frame parser	count=1
function	[function_1] object ||| [function_2] [function_1]	count=7
arg	periods possibly upcast ||| periods axis mgr	count=1
module	return datetimeindex with ||| core	count=1
module	the string if not ||| core	count=1
arg	the iterable ||| iterable	count=1
module	to [module] ||| [module]	count=1
function	[function_1] to long ||| [function_1] [function_2]	count=1
arg	on [arg_2] ||| [arg_2] [arg_1]	count=3
function	the correct scope ||| scope	count=1
arg	value from 1-dimensional ndarray ||| arr key value	count=1
arg	[arg_1] params args ||| [arg_1] [arg_2]	count=1
class	coerce ||| period index	count=1
class	am an ||| index	count=1
function	[function_1] of kwargs ||| [function_1] style [function_2]	count=1
function	binners ||| binner	count=1
function	locator ||| get locator	count=1
function	return [function_2] ||| [function_1] ftype [function_2]	count=2
function	to handle na filling ||| fillable	count=2
arg	the fill_value ||| fill_value	count=1
module	be ||| io	count=2
function	missing indexers ||| convert from missing	count=1
arg	in requested ||| level inplace	count=1
module	major_axis for ||| core	count=1
function	first ||| first	count=4
arg	params args ||| params	count=1
function	[function_1] fill value ||| [function_1] [function_2]	count=1
module	the underlying ||| core	count=2
arg	only ||| arr	count=1
function_arg	[function_1] a ||| [function_1] sparse series [arg_2]	count=1
function_arg	array [arg_2] ||| [function_1] vals [arg_2]	count=1
function_arg	categoricals are [arg_2] ||| [arg_2] [function_1]	count=1
function	[function_1] of kwargs ||| [function_2] [function_1]	count=1
function	dictionary for the ||| construct axes dict from	count=1
function_arg	[function_1] block by ||| [arg_2] [function_1]	count=1
arg	[arg] will be ||| [arg]	count=2
function_arg	of subplots [arg_2] ||| [function_1] [arg_2]	count=1
function	the raw ||| raw	count=1
module	element ||| core	count=1
arg	an indexer ||| cls name indexer	count=1
function	or functions ||| rename axis	count=1
class	[class_1] manager parameters ||| [class_1] [class_2]	count=3
arg	totally ordered cartesian product ||| sort xnull	count=1
function	[function_1] fill ||| [function_2] [function_1]	count=1
function	from ||| set value	count=2
module	see :class packer ||| io	count=1
function	style and color based ||| style	count=1
arg	a string ||| string	count=2
function	the given offset/observance ||| rule	count=1
function	ftypes in this ||| ftype	count=1
arg	b ||| a b raise_on_error	count=1
function_arg	[function_1] the same ||| [function_1] [arg_2]	count=3
module	this if you ||| core indexes	count=1
function	the bool of ||| bool	count=1
arg	cartesian product of ||| shape sort	count=1
class	return ||| html frame	count=1
arg	an ndarray copy if ||| copy	count=1
arg	of regular expression pat ||| arr pat flags	count=1
function_arg	determine if [arg_2] ||| [function_1] [arg_2]	count=1
class	new dataframe with ||| data frame	count=1
class	return ||| index	count=6
module	this object ||| core	count=2
class	datetimeindex with times to ||| index	count=1
arg	can safely be cast ||| name val min_val	count=1
arg	node must already exist ||| key value format	count=1
arg	[arg] a fixed-format ||| [arg]	count=3
class	the float ||| float array formatter	count=1
arg	needs ||| result	count=1
function	timezone ||| set timezone	count=2
function	attributes ||| attrs	count=1
module	new [module] with passed ||| [module]	count=1
function	overlap add suffixes ||| items overlap	count=1
class	quickly [class] single ||| [class]	count=1
function	numeric [function_2] ||| [function_2] [function_1]	count=2
function_arg	[function_1] data converts ||| [function_1] [arg_2]	count=4
function	take optional positional and ||| optional	count=1
function_arg	[function_1] other ||| [arg_2] [function_1]	count=3
arg	or regular expression ||| arr pat flags	count=1
function	0 number [function_2] ||| [function_2] [function_1]	count=1
arg	1-dimensional ||| arr	count=1
function	stride parameters ||| stride from	count=1
function	result as block ||| block	count=1
class	a tree-like object ||| html frame parser	count=1
module	a ||| io	count=1
module	used to ||| io	count=1
module	that we ||| core	count=1
function	we have [function_2] ||| [function_2] [function_1]	count=5
class	value is ||| ops	count=1
function	for given ||| get	count=1
module	fast ||| indexes	count=1
function_arg	[function_1] duplicate ||| [function_1] values [arg_2]	count=1
function	of ftypes in this ||| ftype	count=1
function	two indices overlap add ||| overlap	count=1
module	compute a simple ||| reshape	count=1
class	object that can ||| html	count=1
function	select values at ||| at	count=1
function	wrapper function for ||| bool method	count=1
arg	of period frequency ||| freq	count=1
function	option ||| option	count=2
class	can be ||| html	count=1
function	[function_1] display ||| [function_1] [function_2]	count=1
class	is ||| datetime index	count=1
arg	[arg_1] returning new ||| [arg_2] [arg_1]	count=1
arg	a boolean ||| a b	count=2
arg	elements of arr1 and ||| arr1	count=1
function	only use this if ||| set	count=1
module	a simple cross-tabulation of ||| core reshape	count=1
function	fast path for ||| fast	count=1
arg	on where ||| where start stop	count=1
module	simple cross-tabulation of ||| core reshape	count=1
class	[class_1] applicable ||| [class_2] [class_1]	count=1
function	given an interval ||| get	count=1
function	get integer ||| get	count=5
class	dataframe objects and ||| data frame	count=1
arg	a axes ||| axes dtype	count=1
arg	[arg_1] a ||| [arg_2] [arg_1]	count=2
arg	perform an ||| axis limit	count=1
arg	ufunc ||| context	count=4
module	its values attribute if ||| core	count=1
module	of sparse/dense and dtype) ||| core	count=1
function	the 'numpy' library the ||| take with convert	count=1
arg	[arg_1] function designed ||| [arg_2] [arg_1]	count=2
arg	moving function ||| window func	count=1
module	this if you ||| core	count=1
function	file-like ||| file like	count=2
module_class	of the categorical ||| core categorical	count=1
module	the values axes ||| io	count=1
arg	byte ||| column	count=1
class	to ||| data frame	count=1
function	to be [function_2] ||| [function_1] [function_2]	count=1
class	only ||| series	count=1
arg	dtype converting ||| dtype errors	count=1
function	common ||| common	count=2
module	the values parameters ||| core	count=1
function	backward ||| rollback	count=1
function	read text from clipboard ||| read clipboard	count=1
function_arg	from [arg_2] ||| [function_1] unit mappings [arg_2]	count=1
function	create a table reflecting ||| create table setup	count=1
function	constructor ||| constructor	count=1
class	that can be used ||| frame	count=1
function	[function_1] a full ||| [function_2] [function_1]	count=1
function	the cartesian product ||| product	count=1
class	[class_1] the index ||| [class_2] [class_1]	count=3
class	from the input ||| data	count=1
module	each element in the ||| core	count=1
module	the [module_2] ||| [module_1] [module_2] bin op convert value	count=4
arg	i with ||| i	count=1
class	table ||| appendable multi series table	count=1
arg	3 columns of this ||| columns values	count=1
class	new index ||| categorical index	count=1
function_arg	function for [arg_2] ||| [function_1] [arg_2]	count=3
function	we ||| validate	count=1
arg	ndarray ||| key	count=1
function_arg	categoricals are [arg_2] ||| [function_1] [arg_2]	count=1
function_arg	block [arg_2] ||| [arg_2] [function_1]	count=1
function	as utc [function] days ||| dt to [function]	count=1
function	to end ||| end	count=1
function_arg	execute [arg_2] ||| [arg_2] [function_1]	count=5
module_class	of ndframe ||| core ndframe	count=1
function	[function_1] sequence of ||| [function_2] [function_1]	count=1
arg	fast ||| arr	count=1
module	of sparse/dense and ||| core	count=1
function_arg	[function_1] style_dict ||| [arg_2] [function_1]	count=1
function	a sql ||| sql	count=2
arg	already exist and ||| value format	count=1
module	convert from ||| io	count=1
function	hash a ||| hash	count=1
class	we must ||| non consolidatable mix in	count=1
class	more this is index ||| ndframe	count=1
function	the 'numpy' library the ||| validate take with	count=1
function	highlight the ||| highlight	count=1
function	the dtype [function_2] ||| [function_2] [function_1]	count=2
function	make a copy ||| copy	count=1
function	to take optional ||| optional	count=1
function	a view ||| is view	count=1
arg	termvalue ||| v	count=1
function	[function_1] the counts ||| [function_2] [function_1]	count=1
function	[function_1] list-like ||| [function_2] [function_1]	count=1
function	[function_1] the description ||| [function_1] [function_2]	count=1
function_arg	[function_1] type ||| [function_1] [arg_2]	count=3
arg	for this argument return ||| arg	count=1
arg	arr to have ||| arr new_shape	count=1
function	dictionary for the passed ||| dict from	count=1
class	raise ||| chain	count=1
arg	have n indexable columns ||| columns	count=1
function	the fill [function_2] ||| [function_2] [function_1]	count=3
arg	[arg] example ||| [arg]	count=1
arg	msg ||| msg	count=1
class	holidays ||| abstract holiday calendar	count=1
class	called after a ||| series	count=1
function	(e ||| maybe	count=1
function	symmetric [function_2] ||| [function_2] [function_1]	count=2
function	dropna if ||| dropna	count=1
function	called after a ||| wrap	count=3
function	[function_1] the series ||| [function_2] [function_1]	count=2
function	iter1 ||| assert copy	count=1
arg	compatiable fill_value and arr ||| arr fill_value	count=1
function	of all [function_2] ||| [function_1] [function_2]	count=1
arg	a regular expression ||| arr pat case flags	count=1
function	from apply if as_index=true ||| with as	count=1
arg	reconstruct labels ||| labels	count=1
function	op result ||| result	count=1
class	each index [class_2] ||| [class_1] [class_2]	count=2
arg	[arg_1] array ||| [arg_1] [arg_2]	count=4
function	[function_1] axes ||| [function_2] [function_1]	count=1
arg	given sql [arg_2] ||| [arg_2] [arg_1]	count=1
function	to a [function_2] ||| [function_1] style [function_2]	count=2
function_arg	prior to [arg_2] ||| [arg_2] [function_1]	count=1
function	[function_1] a locale ||| [function_1] [function_2]	count=3
function	to convert [function_2] ||| [function_2] [function_1]	count=2
function	that we ||| validate	count=1
function	[function_1] a file-like ||| [function_2] [function_1]	count=1
arg	apply function to ||| func	count=1
function	is datetimelike ||| to datetimelike	count=1
class	dense ||| sparse	count=1
arg	mask see also ||| mask value	count=1
function	method ||| method	count=1
module_class	the categorical ||| core categorical	count=2
module	up styles ||| formats	count=1
function	ndarray flags ||| flags	count=1
function	[function_1] html table ||| [function_1] [function_2]	count=2
arg	column and [arg_2] ||| [arg_2] [arg_1] takeable	count=1
module_class	of [class_2] ||| [module_1] [class_2]	count=26
arg	utility frequency conversion ||| freq	count=1
function	overlap add ||| overlap	count=1
function	[function_1] a cross-section ||| [function_1] [function_2]	count=1
function	(attr formatted_value) ||| format attrs	count=4
function	is an ||| is	count=1
class	of a single ||| ndframe	count=1
function	that ||| build	count=1
arg	data to ||| data index	count=1
function	custom template and ||| custom template	count=1
arg	the indexer ||| indexer allow_fill	count=1
function	off to scipy ||| scipy	count=1
arg	null values converted ||| values	count=1
arg	check that the left ||| left	count=1
function	in file node ||| append	count=1
module	a ||| core indexes	count=6
module	datetimeindex with ||| core indexes	count=1
module	has one ||| core	count=1
function	fill value ||| fill value	count=4
arg	an expression [arg_2] ||| eval [arg_1] [arg_2]	count=4
arg	values and other to ||| other	count=1
function	assemble the ||| assemble	count=1
function	like to compare ||| v string like	count=1
module	[module] for ||| [module]	count=2
class	a new multiindex from ||| multi index	count=1
function	[function_1] and if ||| [function_2] [function_1]	count=6
class	add ||| index ops mixin	count=1
function	packer ||| packb	count=1
arg	indexer information ||| indexer	count=1
arg	we have a dtype ||| name freq	count=1
arg	columns ||| columns values	count=1
function	capture stderr in a ||| capture stderr	count=1
function_arg	string [arg_2] ||| [function_1] [arg_2]	count=1
class	to the ||| index	count=1
function	array of timestamps ||| asof locs	count=1
function	our asof ||| asof	count=1
arg	that [arg] comparable attributes ||| [arg]	count=1
function_arg	type among the ||| type types	count=1
arg	copy if specified ||| copy	count=1
function_arg	method [arg_2] ||| [arg_2] [function_1]	count=4
class	[class_1] groupby ||| [class_2] [class_1]	count=1
function	for scalar [function_2] ||| [function_1] [function_2]	count=1
function	string ||| generate	count=1
function	sparseseries or ||| to	count=1
function	[function_1] kwargs suitable ||| [function_1] style [function_2]	count=1
function	bool of a single ||| bool	count=1
function	starting at the ||| rsplit	count=1
arg	compat for the values ||| values	count=1
function	create the grouper indexers ||| grouper	count=1
function	that an positional ||| has valid positional	count=1
module	needs ||| core indexes	count=2
class	be used to iterate ||| html frame	count=1
function	and create ||| to	count=1
function	the raw data ||| raw data	count=2
module	create an ||| computation	count=1
arg	have ||| cls	count=1
class	index objects sortedness of ||| index	count=1
arg	a given axis ||| axis method	count=1
function	return frequency code group ||| group	count=1
class	maps[0] raise keyerror is ||| chain map	count=1
function	alert a user ||| alert	count=1
function	that ||| validate ordered	count=2
function	extended ||| extended	count=1
class	data are missing ||| data frame	count=1
arg	the left and right ||| left right	count=1
arg	arg ||| arg errors	count=2
arg	that time [arg_2] ||| [arg_2] [arg_1]	count=1
class	a datetimeindex but ||| datetime	count=1
function	feather-format object from the ||| read feather	count=1
arg	block by [arg_2] ||| [arg_2] [arg_1]	count=2
arg	pattern or regular expression ||| arr pat flags	count=1
function	an xpath expression ||| xpath expr	count=1
function	and ||| to	count=1
module	internal property property synonym ||| core	count=1
arg	shape ||| ndim shape	count=1
arg	lookup of value from ||| arr key value	count=1
arg	nrows ncols - ||| nrows ncols	count=1
function	[function_1] description ||| [function_2] [function_1]	count=1
function_arg	quickly retrieve [function_1] [arg_2] ||| [function_1] [arg_2]	count=5
function_arg	apply a [arg_2] ||| [arg_2] [function_1]	count=1
class	to the underlying array ||| ops mixin	count=1
arg	using matplotlib / pylab ||| grid	count=1
class	repr of this ||| index	count=1
class	the ||| index	count=5
arg	the risk of ||| subarr	count=1
arg	j do ||| j	count=1
class	or other [class] operations necessary ||| [class]	count=2
function	a table ||| table	count=2
arg	sql and [arg_2] ||| [arg_1] [arg_2]	count=3
module	generate the ||| io	count=2
function	time ||| like indices	count=1
function	get the [function_2] ||| [function_1] [function_2]	count=2
arg	arr2 are equivalent ||| arr2	count=1
function	load a feather-format ||| read feather	count=1
function	json lists to line ||| to line	count=1
class	single ||| ndframe	count=1
function	string-like array ||| string	count=1
function	[function_1] category labels ||| [function_1] [function_2]	count=1
module	same dimensions as ||| core	count=1
function	as ||| values	count=2
module	the ||| indexes	count=4
function	get ||| get index name	count=2
module	objects ||| indexes	count=1
function	number format ||| number format	count=2
module	and major_axis for ||| core	count=1
function	simple cross-tabulation of ||| crosstab	count=1
function	this is our asof ||| asof	count=1
function	a block of same ||| block same	count=1
module	this is ||| core reshape	count=1
module	numpy ||| numpy	count=1
function	to coerce a ||| maybe coerce	count=1
function	for ||| bool method	count=1
arg	a ||| a dense_index	count=2
function	the given quantile a ||| quantile	count=1
function	to write this as ||| write	count=2
function_arg	and pads it with [function_1] [arg_2] ||| io [function_1] [arg_2]	count=1
class	new manager with ||| manager	count=1
arg	cells ||| formatter subset	count=1
function	positional ||| positional setitem	count=1
arg	columns ||| columns	count=5
function	the series extract groups ||| extract	count=2
function_arg	coerce the [arg_2] ||| [arg_2] [function_1]	count=6
module	fast ||| core indexes	count=2
arg	duplicate [arg_2] ||| [arg_2] [arg_1]	count=2
function	[function_1] line ||| [function_1] [function_2]	count=4
function	detect terminal size ||| terminal size	count=1
function	true if ||| is in table	count=1
function	bind [function_2] ||| [function_2] [function_1]	count=1
function	value ||| get value	count=2
class	index or ||| index ops	count=1
arg	string ||| string	count=2
function	matches the ||| matches	count=1
function	[function_1] represent time-seires ||| [function_2] [function_1]	count=6
arg	from 1-dimensional ndarray ||| arr	count=1
function	xarray object from ||| xarray	count=1
arg	except for allowed ||| allowed	count=1
function	[function_1] table ||| [function_1] [function_2]	count=3
class	can ||| html frame	count=1
class	return a tree-like object ||| html frame parser	count=1
class	that can ||| html frame parser	count=1
class	the underlying data ||| multi	count=1
class	and be table ||| hdfstore	count=1
function_arg	[function_1] other to ||| [function_1] [arg_2]	count=1
module	combine list-like of ||| core	count=1
function	string-like and string-like array ||| string	count=1
function	string ||| string	count=7
function	the join [function_2] ||| [function_1] [function_2]	count=2
function	return the length ||| len	count=2
function	[function_1] type ||| [function_1] dtype [function_2]	count=1
class	single block ||| block	count=1
class	a series to ||| series	count=1
arg	a function to a ||| func	count=2
module	frequency code ||| tseries	count=1
function	expected nrows ||| nrows expected	count=2
function_arg	intersection of two ||| intersection other	count=4
function_arg	[function_1] of terms ||| [arg_2] [function_1]	count=1
function	ids ||| ids	count=1
function	[function_1] [function_2] ||| [function_1] ftype [function_2]	count=4
arg	an indexer like ||| indexer	count=1
arg	[arg_1] by a ||| [arg_2] [arg_1]	count=8
module	is a string ||| indexes	count=1
function	return my self as ||| as	count=1
arg	to table in file ||| key	count=1
function	via the 'numpy' library ||| validate argmin with	count=1
arg	if s is ||| s	count=1
function	a named tuple ||| named tuple	count=2
class	[class] possible ||| [class]	count=1
module	this ||| reshape	count=1
class	values need ||| array	count=1
function	series concat ||| series	count=1
function	find all occurrences ||| findall	count=1
function	the fill value ||| fill value	count=2
arg	:meth ||| inplace limit downcast	count=2
class	on ||| mixin	count=1
function	[function_1] number ||| [function_1] [function_2]	count=1
class	the underlying array which ||| ops mixin	count=1
function	[function_1] zeros ||| [function_2] [function_1]	count=1
function	load a feather-format object ||| feather	count=1
arg	stop_seq ||| cls stop_seq	count=1
function	array to [function_2] ||| [function_2] string [function_1]	count=1
function	pandas type to its ||| type	count=1
class	to ||| styler	count=1
arg	into a ||| index_col coerce_float	count=1
function	check if we are ||| check is	count=1
class	alert ||| python parser	count=1
class	raised ||| assert raises	count=1
function	string and ||| string	count=1
arg	left and [arg_2] ||| [arg_1] [arg_2]	count=10
function	stata ||| stata	count=5
function	[function_1] [function_2] ||| [function_1] [function_2]	count=1738
function	sif to datetime ||| date to datetime	count=1
module	already exist ||| io	count=1
function	might need to coerce ||| maybe coerce freq	count=1
function	openpyxl is supported parameters ||| is	count=1
function	dtype ||| is dtype	count=1
class	index objects sortedness of ||| range index	count=1
function	self as ||| as	count=1
function	read from a url ||| read	count=1
arg	file node must ||| value	count=1
class	raise keyerror ||| chain map	count=1
function	wrapper function for series ||| comp method series	count=1
class	index value is ||| datetime index ops	count=2
arg	for temporarily setting a ||| new_locale lc_var	count=1
module_class	indices that would sort [module_1] [class_2] ||| [module_1] [class_2] argsort ascending	count=2
class	be ||| html frame parser	count=2
class	the index and ||| index	count=1
function	float is formatted in ||| float	count=1
arg	must already ||| format	count=1
function	sanitize input ||| sanitize array	count=1
function	can be ||| build	count=1
function	[function_1] parameters ||| [function_2] [function_1]	count=3
function_arg	[function_1] [arg_2] ||| [function_1] cls [arg_2]	count=10
arg	only use this ||| arr key	count=1
class	index objects ||| datetime index	count=1
class	dataframe and major_axis for ||| ndframe	count=1
function	to all values found ||| transform	count=1
function	the raw [function_2] ||| [function_1] [function_2]	count=1
arg	if you ||| arr key	count=1
arg	wrapper function [arg] appropriate window ||| [arg] arg	count=1
class	rangeindex ||| range index	count=1
arg	generic moving [arg_2] ||| [arg_2] [arg_1]	count=1
arg	ndarray or list ||| data index	count=1
class	each index value ||| index ops	count=1
function	to take optional ||| optional args	count=1
arg	return fillvalue for a ||| fillvalue	count=1
module	packed bytes see :class ||| io	count=1
function	the internal repr ||| values	count=1
function	has data ||| has	count=1
class	an ||| fixed	count=1
function	lists ||| str	count=1
class	this columns ||| index col	count=1
arg	return a [arg_2] ||| [arg_1] [arg_2]	count=3
function	difference ||| difference	count=1
function	boolean ||| is	count=1
class	index objects ||| index ops mixin	count=1
arg	arr2 ||| arr2	count=1
function	am never a ||| is	count=1
function_arg	[function_1] a dataframe ||| [arg_2] [function_1]	count=1
arg	at [arg] follows ||| [arg]	count=1
class	times to ||| datetime index	count=1
arg	[arg_1] requested ||| [arg_1] axis [arg_2]	count=3
arg	duplicate ||| keep	count=1
arg	[arg_1] iterables ||| [arg_2] [arg_1]	count=4
class	of ||| series	count=1
function	gets the ordered attribute ||| get ordered	count=1
function	the best locator ||| get locator	count=1
function	[function] system clipboard ||| [function]	count=2
function	get integer location ||| get loc	count=8
function_arg	[function_1] type_map ||| [arg_2] [function_1]	count=9
arg	ndarray ||| data index	count=1
arg	blocks collect and ||| f axis consolidate transposed	count=1
function	maximum by ||| max	count=1
function_arg	for given [arg_2] ||| [function_1] concatenation plan [arg_2]	count=2
arg	n rows ||| n	count=2
function_arg	assignment [arg_2] ||| [function_1] [arg_2]	count=2
module	underlying ||| indexes	count=2
arg	label is not contained ||| label	count=1
function	counts of ftypes in ||| ftype counts	count=1
class	dateoffset to ||| offset	count=1
arg	that time and ||| time	count=1
function	[function_1] full ||| [function_2] [function_1]	count=1
function	[function_1] classes which ||| [function_2] [function_1]	count=3
function	node with the ||| get node	count=2
function	with the ||| get	count=1
arg	table ||| format	count=2
arg	to ||| key value	count=1
class	only ||| index	count=1
module	to create an ||| core computation	count=1
arg	filter [arg] ||| superclass [arg]	count=1
function_arg	define an internal [function_1] [arg_2] ||| [function_1] [arg_2]	count=6
module	up styles to html ||| io	count=1
module	that we have a ||| core	count=1
arg	1-dimensional ndarray only ||| key	count=1
function_arg	of a [arg_2] ||| [function_1] indexer indexer [arg_2]	count=1
module	index with day calendar ||| core indexes	count=1
arg	simple cross-tabulation ||| index	count=1
function	required package is installed ||| package	count=1
arg	the [arg] using the ||| [arg] cur	count=1
arg	it's [arg] chars ||| name [arg]	count=1
arg	of v should be ||| v	count=1
class	data ||| data col	count=1
function	to capture [function_2] ||| [function_1] [function_2]	count=4
function_arg	exception and [arg_2] ||| [function_1] matches [arg_2]	count=4
function	kwargs suitable for initializing ||| kwargs	count=1
arg	[arg_1] freq ||| [arg_2] [arg_1]	count=4
arg	ndarray copy if specified ||| copy	count=1
class	don't care for groupby ||| rolling groupby	count=1
function	float is ||| float	count=1
function_arg	[function_1] an index ||| [function_1] level lengths [arg_2]	count=1
class	and be ||| hdfstore	count=1
function	radviz - a ||| radviz	count=1
class	get ||| period index	count=1
function	along concatenation ||| concat	count=1
arg	the name ||| name	count=1
module	fixed frequency datetime index ||| core indexes	count=1
arg	code to a rule_code ||| code	count=1
class	a tree-like object that ||| frame	count=1
arg	copy if ||| dtype copy	count=1
function	to compare numeric ||| is numeric v	count=1
function	[function_1] [function_2] ||| [function_2] plot logic [function_1]	count=1
class	the number ||| multi index	count=1
arg	level ||| level	count=3
function	the base ||| get base	count=1
module_class	and [module_1] [class_2] ||| [module_1] [class_2]	count=2
class	type ||| categorical dtype	count=1
function	via the 'numpy' library ||| validate take with convert	count=1
function	dtype possible ||| indexer dtype	count=1
class	of ||| index	count=7
function	header rows in ||| pop header	count=1
function	[function_1] value ||| [function_1] [function_2]	count=4
arg	that [arg] ||| mask [arg]	count=2
module	to ||| io formats	count=2
module	cross-tabulation ||| core	count=1
function	series extract groups from ||| str extract frame	count=1
function	offset/observance to ||| rule	count=1
function	rec ||| rec	count=1
function	return true if this ||| is in table	count=1
arg	with the fill_value ||| fill_value	count=1
function	thereafter ||| to	count=1
arg	[arg_1] dataframe ||| [arg_2] [arg_1]	count=6
arg	input using [arg] ||| maybe_callable [arg]	count=2
class	returns the float ||| float array formatter	count=1
arg	key as ||| key values	count=1
arg	where [arg_2] ||| [arg_1] [arg_2]	count=4
function	base [function_2] ||| [function_2] [function_1]	count=1
function	whether the ||| for	count=1
function	determine if ||| match	count=1
module_class	sets the categorical ||| core categorical	count=1
function	types format ||| types	count=3
function_arg	length of [arg_2] ||| [function_1] indexer indexer [arg_2]	count=1
function	objects (namely the date ||| date	count=1
function	[function_1] convert ||| [function_2] string [function_1]	count=2
arg	block b ||| block block_items	count=1
class	of an series ||| series	count=1
arg	cartesian product ||| sort	count=1
function	the manager ||| mgr	count=1
arg	terms for instances of ||| terms	count=1
function	wrap ||| wrap	count=3
function	after ||| array wrap	count=6
arg	of value from 1-dimensional ||| arr key value	count=1
class	if ||| index	count=1
arg	to ||| cls	count=6
function	entries in index ||| make custom index	count=1
function	feather-format object from ||| read feather	count=1
arg	jinja environment ||| cls searchpath name	count=1
function	set ||| set value	count=1
function	[function_1] values ||| [function_1] [function_2]	count=1
module	and and ||| computation	count=1
function	:class ||| packb	count=1
arg	name this ||| name	count=1
function	index names to ||| set default names	count=1
function	dataframe ||| frame	count=3
class	a ||| frame	count=1
function	from a masked ||| masked	count=1
function	slice ||| slice	count=8
function	cast to ||| to timestamp	count=2
arg	fast ||| key	count=1
arg	[arg_1] possibly upcast ||| [arg_2] [arg_1]	count=1
class	to iterate over ||| frame parser	count=1
arg	a ||| index	count=1
class	underlying array which ||| index ops mixin	count=1
function	is of ||| is	count=3
function	write ||| write	count=3
class	[class_1] only use ||| [class_2] [class_1]	count=2
function	the grouper indexers ||| grouper	count=1
arg	ndarray or list ||| index columns	count=1
class	support start stop ||| fixed	count=1
module	be used ||| io	count=1
function	the bool ||| bool	count=1
function	replace ||| replace	count=1
class	index and ||| index	count=1
function	[function_1] number ||| [function_2] [function_1]	count=1
function_arg	[function_1] non-tuple ||| [function_1] indexer indexer [arg_2]	count=2
function	return boolean if ||| is	count=1
function	locator based ||| locator	count=1
class	be used ||| html frame parser	count=1
arg	sql query ||| sql con	count=1
module	for ||| indexes	count=1
function	[function] to ||| tz [function]	count=1
arg	any values ||| values	count=1
class	to iterate over the ||| html	count=1
module	a ndarray like ||| json	count=1
arg	compute a simple ||| columns	count=1
class	ndframe ||| ndframe	count=3
function	get all the ||| get	count=1
class	reshape data (produce ||| data	count=1
arg	string raise a typeerror ||| string	count=2
module	handling ||| core	count=1
function	indicated if we have ||| have	count=1
arg	i ||| i axis	count=1
module	resets the ||| io	count=1
function_arg	[function_1] the key ||| [function_1] [arg_2]	count=3
arg	number of times ||| arr repeats	count=1
class	as the ||| ndframe	count=1
class	new block ||| block	count=5
class	copy ||| multi index	count=1
function	a moving window of ||| apply window	count=1
function	add in ||| add	count=2
arg	node ||| key value format	count=1
function	handling ||| array wrap	count=2
function	[function_1] year ||| [function_1] [function_2]	count=4
function	returns axes if supplied ||| axes	count=1
arg	must ||| value format	count=1
function	the frequency ||| freq	count=1
arg	a regular expression ||| pat case flags	count=1
function	1d array of ||| intervals	count=1
function	we are a categorical ||| for reshape	count=1
function	ordered ||| ordered	count=2
class	repr of this ||| period index	count=1
function	determines if ||| equals	count=4
class	block for the ||| block	count=1
class	attributes ||| attributes	count=1
module	ndarray ||| indexes	count=1
function	string ||| time string	count=1
function	create and return ||| get	count=1
arg	object o and ||| o	count=1
function	that we have ||| validate	count=1
function	optional ||| optional args	count=1
arg	a and b ||| a b raise_on_error	count=1
function	if categoricals are the ||| equal	count=1
function	[function_1] axes if ||| [function_1] [function_2]	count=1
function	[function_1] length slice ||| [function_2] [function_1]	count=4
function	dtype ||| dtypes	count=1
function_arg	[function_1] a string ||| [arg_2] [function_1]	count=2
module	a ||| reshape	count=1
module	the attrs from ||| io	count=1
function	[function] for ||| [function]	count=3
class	a tree-like ||| html frame	count=1
class	whether each index value ||| datetime index ops	count=1
function	dictionary ||| axes dict from	count=1
function	index type ||| index	count=1
module	a tree-like object ||| io	count=1
function	'numpy' library the third ||| with convert	count=1
class	additional handling ||| period index	count=1
function	[function_1] stderr ||| [function_2] [function_1]	count=3
arg	arg is a ||| arg	count=2
function	a scalar ||| scalar	count=2
class	midnight length is ||| datetime index	count=1
arg	distance ||| dmin dmax	count=1
class	with times ||| datetime	count=1
arg	and index ||| index	count=3
function	need to coerce ||| coerce freq	count=1
function	only use this ||| set	count=1
function	little [function_2] ||| [function_1] [function_2]	count=1
function	the locales that ||| locales	count=1
function	for header rows ||| header name	count=1
class	each interval in ||| interval	count=1
arg	must already exist and ||| value	count=1
class	can be used ||| html frame	count=1
function	hard to parse datetime ||| parse time	count=1
function	we ||| validate ordered	count=2
arg	to axis ||| axis	count=1
arg	is a term ||| scope_level	count=1
arg	as a dataframe the ||| data values	count=1
class	be used to ||| html	count=1
module	can be used ||| io	count=1
module	the same dimensions ||| core	count=1
function	dtype and n/a values ||| empty dtype and	count=1
function	if [function_2] ||| [function_2] [function_1]	count=5
function	in numeric methods ||| numeric methods	count=1
arg	float key and ||| key	count=1
module	condition ||| core computation	count=1
function	tree-like object that can ||| build	count=1
function_arg	[function_1] and other ||| [arg_2] [function_1]	count=1
class	be used to iterate ||| frame parser	count=1
module	for dataframe and ||| core	count=1
module_class	[module_1] values ||| [module_1] [class_2]	count=1
class	downsample ||| datetime index resampler	count=1
function_arg	to a [arg_2] ||| [arg_2] [function_1]	count=2
function	environment table you can ||| latex	count=1
module	to create an ||| computation	count=1
module_class	and replaces these with [module_1] [class_2] missing value ||| [module_1] [class_2]	count=1
function	cases to get ||| get	count=1
arg	a simple cross-tabulation of ||| index	count=1
arg	to [arg_2] ||| [arg_2] [arg_1]	count=5
class	close ||| stata reader	count=1
function	to compare numeric ||| is numeric	count=1
arg	fname ||| fname	count=1
function	to a [function_2] ||| [function_1] stata [function_2]	count=2
function	to a sql ||| to sql	count=6
module	use this ||| core indexes	count=1
class	[class_1] dataframe ||| [class_2] [class_1]	count=4
arg	in file ||| key value	count=1
module	datetimeindex with times to ||| core indexes	count=1
module	pack ||| io msgpack	count=2
arg	of the _apply kwargs ||| func name window center	count=1
arg	exist and be table ||| key	count=1
class	table in ||| hdfstore	count=1
arg	only ||| key	count=1
function	we are ||| for reshape	count=2
class	a series we ||| series	count=1
function	parse datetime ||| parse	count=1
module	and major_axis ||| core	count=1
arg	periods [arg_2] ||| [arg_2] [arg_1]	count=1
arg	to the new ||| copy errors values	count=2
arg	3 columns ||| index columns values	count=1
function	to time objects ||| to time	count=1
function	timedelta ||| timedelta	count=3
function	backward to ||| rollback	count=1
arg	loc ||| loc	count=1
function_arg	with the [arg_2] ||| [arg_2] [function_1]	count=4
arg	using passed [arg] ||| [arg]	count=1
module	datetimeindex with ||| core	count=1
module	columns for dataframe and ||| core	count=1
function	to read from ||| read	count=1
arg	a tabular ||| buf columns col_space header	count=1
function	return a ||| get	count=6
class	series columns for dataframe ||| ndframe	count=1
arg	valid other [arg_2] ||| [arg_2] [arg_1]	count=1
function_arg	[function_1] iter2 iterables ||| [function_1] iter1 [arg_2]	count=1
module	for regular or 'level_x' ||| io json	count=1
function	[function_1] locale ||| [function_2] [function_1]	count=3
function	must be [function_2] ||| [function_2] [function_1]	count=3
arg	the values to be ||| values ndim	count=1
function	gets called after a ||| array	count=3
function	with ||| make	count=1
function	of same ||| same	count=1
arg	is a ||| scope_level	count=1
arg	or ||| axis level	count=1
class	values attribute ||| series	count=1
arg	func ||| func dropna	count=2
function_arg	numeric operations [arg_2] ||| [function_1] [arg_2]	count=4
function	[function_1] mixed levels ||| [function_2] [function_1]	count=3
function	dictionary for the passed ||| construct axes dict from	count=1
function	non-na/null observations ||| count	count=1
arg	query or ||| index_col coerce_float	count=1
function	table as ||| table	count=1
arg	key or ||| key	count=1
module	only use this ||| core indexes	count=1
function	compat ||| blknos	count=1
function	to ||| to dtypes	count=1
module	return the ||| core	count=12
function	for ||| method	count=4
class	can be used to ||| html frame	count=1
arg	sample ||| pairwise	count=1
arg	lookup of value from ||| value	count=1
class	[class_1] applicable ||| [class_1] [class_2]	count=1
function_arg	[function_1] indexer input ||| [arg_2] [function_1]	count=1
module	over ||| io	count=1
arg	and a date_format ||| date_format	count=1
module	of the object ||| core	count=1
class	modify block ||| block	count=1
function	return an indexer ||| get	count=1
arg	to class python ||| cls name func	count=1
class	times to midnight ||| index	count=1
function	stata date formats to ||| convert datetime to stata	count=1
class	setup our ||| resampler	count=1
module	number ||| core indexes	count=4
class	am never a ||| block	count=1
function	matrix [function_2] ||| [function_2] [function_1]	count=2
arg	using matplotlib / pylab ||| by grid	count=1
function	[function_1] method ||| [function_1] [function_2]	count=1
class	a frame ||| data frame	count=1
class	values using _write_array ||| wormtable	count=1
arg	format ||| format	count=1
function	a matrix of ||| matrix	count=1
function_arg	location slice ||| loc key	count=1
class	be ||| frame parser	count=2
arg	ndarray ||| index columns	count=1
arg	[arg_1] [arg_2] a fixed-format series ||| io table write metadata [arg_1] [arg_2]	count=4
function	the fill [function_2] ||| [function_1] [function_2]	count=3
class	apply ||| by mixin	count=1
class	an series ||| series	count=1
function_arg	[function_1] obj ||| [function_1] [arg_2]	count=5
class	index objects and ||| index	count=1
class	return the op ||| bin op	count=1
function	positional ||| valid positional	count=1
arg	compute ||| index columns	count=1
arg	copy if ||| copy	count=1
function	mixed levels ||| mixed levels	count=2
arg	periods ||| periods	count=4
arg	new ||| copy	count=2
function_arg	[function_1] ufunc ||| [arg_2] [function_1]	count=2
function	options grouped by ||| pp options	count=1
arg	given axis ||| axis method na_option	count=1
module	we have ||| core	count=1
class	current [class] ||| [class]	count=1
class	gets ||| index	count=2
function_arg	offset/observance to [arg_2] ||| [arg_2] [function_1]	count=1
module	midnight length is ||| indexes	count=1
function	to ||| date to	count=1
class	index objects ||| index ops	count=1
arg	on a [arg_2] ||| [arg_1] [arg_2]	count=1
module	gets ||| core	count=5
function	akima [function_2] ||| [function_1] [function_2]	count=1
function	take values according ||| take	count=2
function	the 'numpy' library the ||| with convert	count=1
arg	op [arg_2] ||| [arg_2] [arg_1]	count=4
arg	frequency if available ||| freq	count=1
function	a boolean if we ||| is	count=2
function	cast ||| maybe cast	count=1
function	holidays between ||| holidays	count=1
class	the index ||| interval index	count=1
function_arg	[function_1] i ||| [arg_2] [function_1]	count=4
class	a frame table ||| multi series table	count=1
function	get ||| get dtype	count=1
function_arg	[function_1] into ||| [function_1] table_name [arg_2]	count=1
module	of groups ||| core	count=1
function_arg	[function_1] frequency ||| [function_1] apply index i [arg_2]	count=2
class	the built up ||| styler	count=1
class	datetimeindex with times ||| index	count=1
arg	encode input values as ||| values	count=1
function	rec array ||| rec array	count=2
arg	guarantee the shape ||| ndim shape	count=1
function_arg	[function_1] [arg_2] ||| [function_1] like [arg_2]	count=3
function	this ||| value	count=1
function	statement that create ||| create	count=1
class	handling as ||| period index	count=1
arg	be a ||| new align inplace	count=1
module	length ||| core indexes	count=2
arg	n rows of ||| n	count=2
function_arg	given quantile [arg_2] ||| [function_1] [arg_2]	count=1
arg	plural 'names' ||| name names deep	count=1
function	values between ||| indexer between	count=1
function	to parse datetime ||| parse time	count=1
arg	labels in [arg_2] ||| [arg_2] [arg_1]	count=1
arg	and ||| method args	count=1
arg	table in file node ||| key value format	count=1
arg	of the values to ||| values ndim	count=1
module	1-dimensional ndarray only use ||| core indexes	count=1
arg	dtype converting ||| value dtype	count=1
arg	or regular expression ||| flags	count=1
arg	to ||| name	count=5
module	return if the ||| core	count=1
arg	array ||| closed	count=1
class	the op ||| bin op	count=1
arg	columns of this ||| index columns values	count=1
function	dataframe ||| to frame	count=1
class	raise keyerror is ||| chain	count=1
function	boolean if we are ||| is	count=1
class	gets called after a ||| series	count=1
function	update ||| update	count=3
arg	[arg_1] on ||| [arg_2] [arg_1]	count=1
module_class	the generic [class_2] ||| [module_1] [class_2] writer replace nans	count=1
arg	dataframe columns ||| data x y by	count=1
function	generate bin edge offsets ||| generate	count=1
class	return a tree-like object ||| html frame	count=1
function	of bytes in the ||| nbytes	count=2
function	a dataframe to ||| to	count=1
function	closed ||| closed	count=1
function_arg	[function_1] [arg_2] rows/cols ||| [function_1] [arg_2] r_idx_names	count=1
arg	a dataframe the ||| data values index	count=1
arg	of columns ||| columns keep	count=2
arg	left and right ||| left right	count=7
function	an enumerated type ||| factorize	count=1
module	additional handling ||| core indexes	count=1
function	[function_1] year ||| [function_2] [function_1]	count=4
function	to read from a ||| read	count=1
module	original ||| core	count=1
class	[class] converted ||| [class]	count=3
module	strings to numpy ||| numpy	count=1
function	return the dtype str ||| dtype str	count=1
class	only use this if ||| index	count=1
class	dimensions as the ||| ndframe	count=1
function	highlight the [function_2] ||| [function_1] [function_2]	count=3
arg	other to int64 ||| other	count=1
class	attribute if it has ||| series	count=1
function	cut where we convert ||| cut	count=1
function	an xarray object from ||| to xarray	count=1
function	to categorical ||| categorical	count=1
arg	iterables parameters ||| cls iterables	count=2
arg	value ||| value	count=8
class	panel or above ndim ||| panel	count=1
function	[function_1] bounds ||| [function_1] [function_2]	count=2
function	an array or dtype ||| dtype	count=1
function	to parse ||| convert	count=1
arg	or columns using input ||| copy inplace	count=1
function_arg	perform merge [arg_2] ||| [function_1] ordered [arg_2]	count=1
module	midnight ||| indexes	count=1
function	from [function_2] ||| [function_2] [function_1]	count=4
arg	series using mapper dict ||| level as_index	count=1
function	setting a timezone ||| set timezone	count=1
function_arg	to specified [arg_2] ||| [arg_2] [function_1]	count=1
arg	input values as ||| values sort	count=1
module	from the ||| core	count=1
class	current [class] going back ||| [class]	count=1
function	dropna if fill_value=nan ||| dropna	count=1
module	index objects contain ||| core indexes	count=1
function_arg	of casting [arg_2] ||| [function_1] [arg_2]	count=4
class	dataframe with labeling ||| data frame	count=1
function	checks whether the ||| check for	count=1
function	to set the ||| set	count=1
function	render the built up ||| render	count=1
function	datetime to ||| to	count=1
module	dtypes ||| core dtypes	count=1
class	this ||| ndframe	count=2
class	called after ||| index	count=2
function	to an ||| convert to	count=2
arg	a curve with ||| start end return_name	count=1
arg	and be table ||| key	count=1
class	return the op ||| op	count=1
arg	to specified type parameters ||| cast_type column	count=1
function	axis ||| axis	count=1
function_arg	[function_1] using ||| [function_1] keys drop append [arg_2]	count=1
function_arg	datetimelike [arg_2] ||| [function_1] [arg_2]	count=3
function	function for ||| bool method	count=1
function	if categoricals are ||| equal	count=1
function_arg	[function_1] [arg_2] ||| [function_1] periods [arg_2]	count=1
function	wrap result ||| wrap result	count=2
arg	convert the [arg] to ||| [arg]	count=1
class	group ||| series group by	count=1
function	data ||| validate data	count=1
class	index objects sortedness ||| range index	count=1
function	for options ||| packb	count=1
class	to ||| datetime	count=1
function_arg	[function_1] among ||| [arg_2] [function_1]	count=1
arg	set a parameter value ||| value	count=1
arg	by ||| axis	count=1
arg	key [arg_2] ||| [arg_2] [arg_1]	count=1
function	given offset/observance ||| rule	count=1
arg	avoid code duplication ||| str_rep default_axis	count=1
function	from 1-dimensional ndarray ||| set	count=1
function	returns the default ||| default	count=1
arg	arg is a passed ||| arg errors	count=1
arg	we have ||| name	count=1
class	from ||| map	count=1
function_arg	[function_1] node ||| [function_1] [arg_2]	count=1
module	packed bytes ||| io	count=1
function	header rows ||| header	count=1
arg	/ or columns using ||| inplace	count=1
class	used to iterate ||| html	count=1
arg	simple cross-tabulation of ||| index columns	count=1
arg	to the groupby ||| cls	count=1
arg	[arg] to ||| ax [arg] rowlabels	count=2
function	unicode strings ||| randu	count=1
class	stata ||| stata writer	count=1
arg	pattern ||| pat na	count=1
class	single ||| single	count=1
function	read ||| read	count=7
function	return a list ||| tolist	count=1
function	get the category labels ||| get labels	count=1
function	feather-format for dataframes ||| to feather	count=1
arg	arr dtype ||| arr	count=1
function	metadata for ||| metadata	count=1
arg	specified type parameters ||| cast_type column	count=1
function_arg	locator [arg_2] ||| [arg_2] [function_1]	count=1
arg	into a higher ||| cls value	count=1
function	we have mixed ||| have mixed	count=2
function	return copy of ||| copy	count=1
function	custom ||| from custom	count=1
arg	function [arg] ||| [arg] arg	count=2
function	true if this ||| is	count=2
arg	string raise ||| cls string	count=2
function	for header rows in ||| header name	count=1
class	from the ||| data	count=1
class	the ||| frame	count=1
arg	[arg_1] b ||| [arg_2] [arg_1]	count=3
function	try to ||| try convert data	count=2
arg	1-dimensional ||| key	count=1
class	the frame ||| data frame	count=1
arg	and arr2 ||| arr2	count=1
arg	arg is a ||| arg errors	count=1
function	nodes ||| nodes	count=1
function	into a pandas only ||| pandas	count=1
function	[function_1] dict-like ||| [function_2] [function_1]	count=1
function	[function_1] options for ||| [function_1] [function_2]	count=3
module	that we have ||| core	count=1
module	is maps[0] ||| compat	count=1
module_class	indices that would sort [module_1] [class_2] was called ||| [module_1] [class_2] argsort ascending	count=1
function	cross-section ||| xs	count=1
function	matches the [function_2] ||| [function_2] [function_1]	count=4
function	take which sets nan ||| take	count=1
function_arg	shift the [arg_2] ||| [function_1] periods axis [arg_2]	count=1
function	a list ||| tolist	count=1
arg	arithmetic operations ||| op	count=3
arg	corresponding interval with ||| interval	count=1
arg	in file node must ||| key value	count=1
function_arg	info axis [arg_2] ||| [arg_2] [function_1]	count=3
arg	at the requested level ||| level	count=1
function	the block ||| for block	count=1
module	as the ||| core	count=1
arg	of arr1 [arg_2] ||| [arg_2] [arg_1]	count=3
arg	axes ||| axes dtype	count=2
class	series ||| series	count=23
function	float dtype if possible ||| float	count=1
arg	dimensions levels names ||| names	count=1
arg	series or by a ||| by axis	count=1
class	new categorical ||| categorical	count=1
function	data to ||| to	count=1
module	:class packer for ||| msgpack	count=1
function	obj with a groupby ||| groupby	count=1
function	handling ||| wrap	count=1
function	ftypes (indication of sparse/dense ||| ftypes	count=1
arg	a function [arg] ||| [arg] kwargs	count=3
arg	a column [arg_2] ||| [arg_1] [arg_2]	count=1
arg	item ||| item	count=7
class	interval in the ||| interval	count=1
function_arg	take values [arg_2] ||| [function_1] [arg_2] new_mgr_locs fill_tuple	count=2
function	with the rows/columns switched ||| transpose	count=1
function	stata date ||| stata	count=1
class	with times to ||| index	count=1
arg	where is a term ||| where scope_level	count=1
arg	against [arg_2] ||| [arg_2] [arg_1]	count=1
arg	dtypes if ||| dtypes	count=1
arg	and b ||| a b	count=1
function_arg	[function_1] expected error ||| [function_1] [arg_2]	count=1
arg	arr1 and [arg_2] ||| [arg_1] [arg_2]	count=3
arg	table in file node ||| value	count=1
function	has a float dtype ||| float	count=1
class	i ||| block	count=1
class	underlying ||| range	count=1
function	have ||| ordered	count=1
arg	append to table ||| value format append	count=1
module	use this if you ||| core	count=1
function	radviz - a multivariate ||| radviz	count=1
arg	on a particular axis ||| axis	count=2
class	add series to dataframe ||| data frame	count=1
class	the group ||| series group by	count=1
function	asof key ||| asof key	count=2
arg	an ||| vals	count=1
function	data ||| validate data columns	count=1
function	for scalar [function_2] ||| [function_2] [function_1]	count=1
function	from sif to datetime ||| date to datetime	count=1
function	size and ||| size	count=1
module	guess ||| core tools	count=1
function_arg	[function_1] the nan/nat ||| [arg_2] [function_1]	count=4
arg	a string raise a ||| cls string	count=2
function	has ||| has	count=1
function_arg	numeric operations to ||| numeric operations cls	count=1
arg	have a valid ordered ||| ordered	count=1
arg	v should be ||| v	count=1
function	time strings to ||| to	count=1
function	package ||| package	count=1
arg	converts ||| num_format_str	count=1
class	manager parameters ||| manager	count=1
class	index values and index ||| index	count=1
function_arg	take the [arg_2] ||| [arg_2] [function_1]	count=1
module	single ||| core	count=1
arg	ndarray or list of ||| index	count=1
class	block we must ||| non consolidatable mix in	count=1
function	[function_1] nrows ||| [function_2] [function_1]	count=8
arg	set the value ||| value	count=1
function	dtype and ||| empty dtype and	count=1
function_arg	path's extension against ||| check extension cls	count=1
function	of ftypes ||| ftype	count=1
arg	arr1 and [arg_2] ||| [arg_2] [arg_1]	count=3
function	block of same ||| block same	count=1
arg	return a boolean if ||| a b	count=1
arg	from ||| key	count=1
arg	blocks collect and ||| consolidate transposed	count=1
function	called prior to a ||| prepare	count=1
function	convert timedelta-like to timedelta64 ||| td index cmp	count=1
function_arg	[function_1] labels shape ||| [function_1] blocknd values [arg_2]	count=1
class	given ||| multi index	count=1
function_arg	[function_1] unit if ||| [function_1] [arg_2]	count=2
function_arg	[function_1] of obj ||| [arg_2] [function_1]	count=7
function	return label for last ||| last	count=2
class	am never a ||| categorical	count=1
function	take which sets nan ||| take nd	count=1
function	highlight ||| highlight	count=1
function	to coerce a ||| maybe coerce freq	count=1
function	if you ||| set value	count=1
module	of groups excluding ||| core	count=1
arg	be pasted [arg] example ||| [arg]	count=1
arg	:meth ||| inplace limit	count=2
function	[function_1] type in ||| [function_2] [function_1]	count=7
class	sort multiindex at ||| multi	count=1
function_arg	in [arg_2] ||| [function_1] x [arg_2]	count=4
arg	returning new ||| inplace	count=1
module	if it ||| core	count=1
function	pandas type to its ||| table type	count=1
class	number of ||| multi index	count=1
arg	'kwargs' ||| fname kwargs	count=1
arg	panel-like dataframe parameters ||| time panels names	count=1
arg	[arg_1] as ||| io table write metadata [arg_1] [arg_2]	count=4
class	float values converted into ||| float array formatter	count=1
function	we have ||| have	count=1
arg	function to my ||| func mgr	count=1
class	if multiindex has ||| multi	count=1
function	and if so prints ||| warn if	count=1
class	index ||| datetime index ops	count=2
module	times to ||| core	count=1
module	return datetimeindex with ||| core indexes	count=1
arg	using [arg_2] ||| [arg_2] [arg_1]	count=8
function	to determine ||| dtype n method	count=1
arg	after a ufunc ||| context	count=3
arg	and expected error ||| exc_type exc_value trace_back	count=1
function	length ||| length	count=1
module_class	[module_1] block it ||| [module_1] [class_2] putmask mask	count=1
class	return the number of ||| multi index	count=1
module	formats ||| formats	count=1
class	columns for ||| ndframe	count=1
arg	to an ndarray copy ||| dtype copy	count=1
module_class	the object ||| core ndframe	count=1
function_arg	take [arg_2] ||| [arg_2] [function_1]	count=2
arg	values as ||| values sort order na_sentinel	count=1
module	keyerror ||| compat	count=1
function_arg	[function_1] as the ||| [arg_2] [function_1]	count=1
function	try hard to parse ||| parse time	count=1
module	return datetimeindex with times ||| core indexes	count=1
function_arg	iter1 [arg_2] ||| [function_1] iter1 [arg_2]	count=3
function	the expected exception and ||| exception	count=1
function	[function] define an ||| [function] cython	count=1
arg	from 1-dimensional ||| arr key	count=1
arg	source ||| source	count=2
class	and return the op ||| op	count=1
function	index ||| assert almost	count=1
class	create ||| sqlite table	count=1
function	off to scipy interpolate ||| interpolate scipy	count=1
function	not a floating ||| maybe cast indexer	count=1
module	to take the ||| core	count=1
class	and index ||| index	count=1
function	given an interval or ||| get	count=1
arg	to indexer and return ||| indexer axis	count=2
arg	iterable ||| iterable	count=1
function	[function_1] only ||| [function_1] [function_2]	count=3
arg	to have [arg_2] ||| [arg_1] [arg_2]	count=1
arg	as ||| result	count=1
function	[function_1] manager ||| [function_1] [function_2]	count=7
function	base [function_2] ||| [function_1] [function_2]	count=1
arg	the block by periods ||| periods axis mgr	count=1
function	init self ||| init	count=1
arg	and right ||| right check_dtype check_index_type	count=1
class	raise keyerror is maps[0] ||| chain map	count=1
module	length is ||| core indexes	count=1
arg	and 'kwargs' ||| args kwargs	count=2
function	expected [function_2] ||| [function_2] [function_1]	count=2
class	datetimeindex with times to ||| datetime	count=1
function	is monotonic ||| monotonic	count=2
function	info ||| info	count=1
function	/ pandas type ||| table type	count=1
arg	provide ||| to_concat axis typs	count=1
function_arg	moving window [arg_2] ||| [arg_2] [function_1]	count=1
module	with times ||| core indexes	count=1
arg	in file node must ||| key value format	count=1
function	along concatenation [function_2] ||| [function_2] [function_1]	count=1
function	return a tree-like object ||| build	count=1
arg	a boolean if we ||| a b	count=1
function	the date ||| date	count=1
module	node must already exist ||| io	count=1
function	leap year ||| leap year	count=1
arg	[arg_1] [arg_2] to ||| [arg_2] [arg_1]	count=4
arg	must already exist ||| value	count=1
function_arg	[function_1] [arg_2] ||| [function_1] ops [arg_2]	count=4
class	: ||| excel formatter	count=1
class	a ||| parser	count=1
class	new dataframe with labeling ||| data frame	count=1
module	and be table ||| io	count=1
class	writer ||| excel writer	count=1
arg	and labels ||| labels	count=1
module	whether the ||| io	count=1
module	we have an object ||| dtypes	count=1
class	into a list of ||| parser	count=1
module	if we are ||| core	count=1
function_arg	execute [arg_2] ||| io [function_1] [arg_2] params	count=4
function	result ||| result	count=3
function	a html ||| html	count=1
function	index to be ||| index	count=1
class	from maps[0] raise ||| chain	count=1
arg	of values [arg_2] ||| [arg_1] [arg_2]	count=1
function	the best locator ||| locator	count=1
function	[function_1] the maximum ||| [function_2] [function_1]	count=1
class	data are missing ||| data	count=1
function	then fill ||| fill	count=1
module	datetimeindex with times to ||| core	count=1
class	is a categorical ||| categorical	count=1
arg	the left and right ||| left right check_dtype	count=1
function	decorator to capture stderr ||| capture stderr	count=1
function	note this is ||| is	count=1
function	whether ||| validate	count=1
arg	iter1 iter2 iterables ||| iter1 iter2	count=1
function_arg	[function_1] [arg_2] ||| [function_1] x [arg_2]	count=8
class	be ||| frame	count=1
function	wrap [function_2] ||| [function_1] [function_2]	count=3
arg	values converted ||| values	count=1
arg	format ||| format index encoding	count=1
function	multiple times in parallel ||| test parallel	count=1
arg	check if ||| obj	count=5
arg	multiple ||| sortorder names	count=1
module	packed bytes ||| msgpack	count=1
class	raise ||| chain map	count=1
function	stop parameter ||| stop	count=1
arg	of obj [arg_2] ||| [arg_2] [arg_1]	count=1
function	of a ||| of	count=1
class	datetimeindex with times to ||| datetime index	count=1
function	provide concatenation ||| concat	count=1
arg	columns using input function ||| mapper axis copy inplace	count=1
class	of individual [class] series ||| [class] frame	count=1
arg	axis equal values are ||| axis	count=1
function_arg	[function_1] function to ||| [arg_2] [function_1]	count=1
function	whether this ||| validate	count=1
function	a string cast ||| cast	count=1
function	for ordered data like ||| ordered	count=1
module	[module] is list-like ||| [module]	count=3
function	need to coerce ||| maybe coerce	count=1
module	fast lookup ||| core indexes	count=1
arg	ndarray or list ||| data index columns	count=1
module	node must ||| io	count=1
function	cases to get ||| get index name	count=1
module	or not the ||| io	count=1
arg	substrings [arg_2] ||| [arg_2] [arg_1]	count=6
arg	[arg] to a ||| [arg]	count=1
function	after a ||| wrap	count=3
class	object that ||| frame parser	count=1
module	synonym for ||| core	count=1
function_arg	[function_1] [arg_2] ||| [function_1] ordered [arg_2]	count=1
function	index to be returned ||| index	count=1
module_class	the series ||| core series	count=2
arg	cartesian product of all ||| sort	count=1
function	coerce values and ||| coerce	count=1
function	plan [function_2] ||| [function_2] concatenation [function_1]	count=1
function_arg	[function_1] new item ||| [arg_2] [function_1]	count=1
function_arg	[function_1] [arg_2] provided connection object ||| [function_1] [arg_2]	count=1
function	hash [function_2] ||| [function_1] [function_2]	count=1
function	for header rows in ||| header	count=1
function_arg	[function_1] string ||| [arg_2] [function_1]	count=2
arg	return an ||| vals	count=1
function_arg	[function_1] indexer input ||| [function_1] dtype [arg_2]	count=1
module	an object dtype ||| core dtypes	count=2
function	values [function] ||| [function] same	count=2
arg	the key [arg_2] ||| io table write metadata [arg_1] [arg_2]	count=1
class	i am never ||| categorical block	count=1
function	deprecate ||| deprecate	count=1
module	datetimeindex ||| core indexes	count=3
arg	using one ||| inplace	count=1
module	level ||| core indexes	count=1
function	in ||| call	count=1
arg	panels are conformable ||| panels	count=1
module	infer ||| core dtypes	count=2
module_class	true if ndframe ||| core ndframe	count=1
module	for this object ||| core indexes	count=1
class	[class] going back ||| [class]	count=1
function	handling ||| array	count=1
function	ndarray only use this ||| value	count=1
class	property property synonym for ||| ndframe	count=1
function	union of ||| union	count=2
arg	[arg] a ||| [arg]	count=3
arg	1d array return an ||| vals	count=1
module	file node ||| io	count=1
function	our native [function_2] ||| [function_1] [function_2]	count=12
arg	to table in ||| key value	count=1
function	apply if as_index=true ||| index with as	count=1
arg	plural 'names' parameter ||| name names deep	count=1
function	that an positional ||| positional setitem	count=1
arg	expected ||| exc_type exc_value trace_back	count=1
class	[class_1] blockmanager ||| [class_1] [class_2]	count=2
class	return the ||| ndframe	count=2
function	ndarray ||| set value	count=2
function	time part ||| time	count=1
function_arg	a sparse [arg_2] ||| [arg_2] [function_1]	count=1
class	interval in [class_2] ||| [class_2] [class_1]	count=1
arg	ndarray or list of ||| data index columns dtype	count=1
class	dimensions as the original ||| ndframe	count=1
function	csv file (discouraged please ||| from csv	count=2
function	concatenation of an datetimelike ||| concat	count=1
function	test ||| test	count=1
function	[function_1] named tuple ||| [function_2] [function_1]	count=1
class	series ||| sparse series	count=2
class	like into ||| parser	count=1
arg	to class ||| cls	count=1
class	timedelta ||| timedelta index	count=2
module	if you ||| core indexes	count=1
function	[function_1] a valid ||| [function_1] [function_2]	count=1
function	raw [function_2] ||| [function_2] [function_1]	count=1
function	a ||| crosstab	count=1
function	create a pytables ||| create	count=1
function	[function_1] array to ||| [function_1] [function_2]	count=4
class	return a tree-like object ||| frame parser	count=1
function	checking function of type ||| is type	count=1
function	compare numeric ||| numeric v	count=1
function	is of the timedelta64[ns] ||| is timedelta64 ns	count=1
class	be used to ||| frame parser	count=1
arg	this if ||| arr	count=1
arg	that the left and ||| left	count=1
function	from maps[1 ] ||| parents	count=1
function	wide panel to ||| wide to	count=2
function	[function_1] maximum ||| [function_1] [function_2]	count=1
function	mask of index ||| index	count=1
class	if it has one ||| series	count=1
class	valid stata ||| stata writer	count=1
function	:mod datetime to ||| dt to	count=1
arg	the block ||| mgr	count=1
function	a copy of the ||| copy	count=1
arg	python source ||| source	count=1
function	particular ||| bytes	count=1
module	dense ||| core sparse	count=1
function	to ||| append	count=1
function	dataframe [function_2] ||| [function_1] [function_2]	count=1
function	determine if each string ||| match	count=1
function	fast lookup of ||| set	count=1
function_arg	best locator [arg_2] ||| [arg_2] [function_1]	count=1
function	[function_1] take ||| [function_2] [function_1]	count=4
arg	already exist and be ||| key value	count=1
function_arg	unpack [arg_2] ||| io [function_1] [arg_2]	count=3
arg	called after a ufunc ||| result context	count=3
function	wrap op ||| wrap	count=1
function	is [function_2] ||| [function_1] [function_2]	count=13
function	[function_1] template ||| [function_2] [function_1]	count=2
function_arg	define [function_1] [arg_2] it ||| [function_1] [arg_2]	count=4
class	completion ||| pandas object	count=1
function	object that ||| build	count=1
function	tuple ||| tuple	count=1
class	extended ||| range index	count=1
arg	a higher [arg_2] ||| [arg_2] [arg_1]	count=3
function	for akima interpolation ||| akima interpolate	count=2
function_arg	a datetimelike [arg_2] ||| [arg_2] [function_1]	count=3
function	in parallel ||| test parallel	count=1
class	pandasobject ||| ndframe	count=1
module	necessary for ||| core sparse	count=1
arg	returns last [arg] ||| [arg]	count=2
arg	already exist and ||| value	count=1
function	our native types format ||| native types	count=3
function_arg	and [arg_2] ||| [arg_2] [function_1]	count=1
arg	generate an ||| nchars size dtype	count=1
function	[function_1] reflecting the ||| [function_1] [function_2]	count=6
class	up styles ||| styler	count=1
module	row elements from the ||| io	count=1
function	boolean criterion specified ||| filter	count=2
function	a qualified info display ||| memory usage qualified	count=1
arg	from ndarray ||| data index columns	count=1
arg	this object names dtype ||| names dtype	count=1
module	table schema resets the ||| io	count=1
module	object that can be ||| io	count=1
class	index objects contain ||| datetime index	count=1
arg	columns ||| inplace	count=1
arg	block manager and ||| mgr	count=1
function	format ||| format datetime64 from	count=1
function	like ||| string like	count=1
class	ndarray only use ||| categorical index	count=2
function	[function_1] stderr in ||| [function_2] [function_1]	count=3
arg	as series or ||| axis level	count=1
function	symmetric ||| symmetric	count=1
function	positional ||| has valid positional setitem	count=1
function	'numpy' library the third ||| take with convert	count=1
function	numeric ||| is numeric	count=1
class	gets ||| series	count=1
function	shift without copying data ||| slice shift	count=1
arg	the new ||| copy errors	count=2
function	a number ||| number	count=1
class	a new manager with ||| manager	count=1
function	manipulation result has the ||| constructor	count=1
function	given a ||| get	count=1
function	try [function_2] ||| [function_1] [function_2]	count=7
arg	where : ||| where	count=1
function	our asof [function_2] ||| [function_2] [function_1]	count=1
arg	j do not change ||| j	count=1
arg	iter2 iterables ||| iter2	count=1
arg	lookup of ||| arr key	count=1
function	along concatenation [function_2] ||| [function_1] [function_2]	count=1
function	of lists ||| matrix	count=1
class	of sparse/dense and dtype) ||| ndframe	count=1
class	be table ||| hdfstore	count=1
function	particular ||| repr	count=1
function	all the various ||| all	count=1
function	excel sheet ||| excel	count=1
arg	and be table ||| key value format	count=1
arg	scalar data converts ||| data	count=1
module	built up ||| formats	count=1
function_arg	perform merge [arg_2] ||| [arg_2] [function_1]	count=1
class	a ||| block	count=1
function	ensure that ||| ensure	count=2
arg	coerce to the new ||| copy errors values	count=2
class	of a single element ||| ndframe	count=1
class	the ||| frame parser	count=2
function	round a ||| round	count=1
module	with ||| compat	count=1
function	needs additional handling as ||| array wrap	count=1
function	box function to get ||| box func	count=1
class	cast ||| parser base	count=1
function_arg	[function_1] values ||| [function_1] [arg_2]	count=2
function	needs additional handling ||| array wrap	count=1
module_class	indices that would sort [module_1] [class_2] ||| [module_1] [class_2]	count=2
function	sparse [function_2] ||| [function_1] [function_2]	count=1
arg	datetimeindex of dates ||| dates	count=1
function	other ||| validate for numeric binop	count=1
module	if we are not ||| core	count=1
function	localize tz-naive timeseries to ||| localize	count=1
arg	of the values ||| values ndim	count=1
arg	a simple ||| index columns values	count=1
arg	of regular expression ||| flags expand	count=1
function	concatenation of an ||| concat	count=1
class	reshape data ||| data	count=1
class	that ||| html	count=1
function	closed [function_2] ||| [function_1] [function_2]	count=1
arg	as the input ||| values	count=1
class	to midnight ||| datetime index	count=1
function	perform an asof merge ||| merge asof	count=1
function	coerce the ||| coerce indexer	count=1
function	a copy ||| copy	count=3
arg	arithmetic operations to ||| op name	count=6
function	whether ||| for	count=2
module	a typeerror if ||| dtypes	count=1
function	a leap year ||| leap year	count=1
class	css ||| cssto excel converter	count=1
arg	of the values ||| axis mgr	count=1
arg	based on a distance ||| dmin dmax	count=1
arg	strings bq->q etc ||| offset_str	count=1
function	to capture ||| capture	count=1
function	we take a string-like ||| string array	count=1
arg	fill the values parameters ||| limit	count=1
module	ndarray only use ||| core indexes	count=1
class	single block ||| block manager	count=1
class	object ||| frame parser	count=2
function	get [function_2] ||| [function_2] [function_1]	count=5
arg	block b ||| block	count=1
function	given ||| get interval	count=1
function_arg	[function_1] of times ||| [arg_2] [function_1]	count=1
module	times to midnight length ||| indexes	count=1
function	file node ||| append	count=1
class	a tree-like ||| frame parser	count=1
function	[function_1] unit ||| [function_1] from [function_2]	count=1
function	validates that we ||| ordered	count=1
function_arg	the union [arg_2] ||| [function_1] [arg_2]	count=2
class	underlying ||| multi index	count=1
function	[function_1] index ||| [function_1] [function_2]	count=1
function	a table reflecting the ||| table setup	count=1
module	datetimeindex ||| core	count=1
arg	only use this if ||| arr	count=1
function_arg	[function_1] [arg_2] object ||| [function_1] [arg_2]	count=1
function	of series ||| series	count=1
function	the dtype to return ||| dtype	count=1
rep	this type [function_arg_2] ||| [module_class_1] [function_arg_2]	count=4
module	as the original ||| core	count=1
class	the underlying data which ||| index	count=1
arg	panel or object coercible ||| other join overwrite filter_func	count=1
function	never a view ||| is view	count=1
module	this is similar to ||| reshape	count=1
arg	columns ||| columns keep	count=2
function	value for ||| value	count=2
class	new multiindex from the ||| multi	count=1
function_arg	the where [arg_2] ||| [arg_2] [function_1]	count=4
class	times ||| datetime index	count=1
function	[function_1] options ||| [function_2] [function_1]	count=3
arg	a python expression as ||| expr	count=1
function_arg	strip [arg_2] ||| [function_1] [arg_2]	count=3
function	class for resampling with ||| resampler for grouping	count=1
function	to [function_2] ||| [function_1] style [function_2]	count=1
class	object ||| html frame	count=1
arg	validates ||| cls	count=1
module	this ||| core dtypes	count=1
class	that ||| categorical	count=1
class	of the dataset ||| series	count=1
function	pairwise correlation ||| corr	count=1
function	is of [function_2] ||| [function_2] [function_1]	count=3
class	used ||| frame	count=1
function_arg	str against ||| str cls	count=1
arg	result ||| result mask other	count=1
module	check if the object ||| core dtypes	count=3
arg	type window_type on the ||| mean how	count=1
function	node ||| node	count=1
arg	must already exist ||| key	count=1
module	i am ||| core	count=1
arg	the value inplace return ||| value mgr	count=1
function	[function_1] thereafter ||| [function_2] [function_1]	count=2
module	a set of sparseseries ||| core sparse	count=1
class	version ||| block	count=1
function	apply the given offset/observance ||| apply rule	count=1
arg	use this if you ||| key	count=1
function	view ||| is view	count=1
class	over column ||| data frame	count=2
class	data (produce ||| data	count=1
module_class	[module_1] file ||| [module_1] [class_2]	count=6
function_arg	[function_1] length ||| io [function_1] name [arg_2]	count=2
arg	3 columns ||| index columns	count=1
arg	actual interpolation [arg] will ||| [arg]	count=1
class	we have ||| categorical	count=1
function	1-dimensional ndarray only ||| value	count=1
function	for given ||| get mgr	count=1
arg	[arg_1] in requested ||| [arg_2] [arg_1]	count=4
arg	simple cross-tabulation of ||| values	count=1
class	alias for ||| index	count=1
class	attribute if ||| series	count=1
function	location ||| loc	count=4
function	array and create ||| array to	count=2
class	the underlying data ||| multi index	count=1
class	index with target's ||| multi index	count=1
function	datetime [function_2] ||| [function_2] [function_1]	count=5
arg	values ||| values name	count=1
function	and if ||| if	count=1
function	getting a cross-section ||| xs	count=1
function	[function_1] if ||| [function_2] [function_1]	count=2
arg	or by ||| by axis	count=1
function	need to coerce a ||| coerce freq	count=1
function	read csv ||| csv	count=2
function	add the ||| add aggregate	count=1
arg	left and [arg_2] ||| [arg_2] [arg_1]	count=10
module	major_axis ||| core	count=1
module	midnight length is ||| core	count=1
module_class	the [class_2] ||| [module_1] [class_2]	count=61
class	midnight length ||| datetime	count=1
function	to line ||| convert to line	count=2
function	timedelta-like to ||| td index	count=1
arg	object to ||| errors	count=1
arg	[arg_1] j ||| [arg_2] [arg_1]	count=3
function	load ||| load	count=1
class	each index [class_2] ||| [class_2] [class_1]	count=2
arg	byte of ||| column	count=1
function	to datetime ||| to datetime	count=1
function	result set ||| result	count=1
function_arg	extension against the ||| check extension cls	count=1
arg	evaluate [arg_1] [arg_2] ||| eval [arg_1] [arg_2]	count=4
arg	packed ||| packed object_hook	count=1
arg	values values ||| values method axis	count=1
module	a simple ||| reshape	count=1
class	provided date ||| date	count=2
function	[function_1] reflecting ||| [function_1] [function_2]	count=6
function	[function_1] a sql ||| [function_1] [function_2]	count=2
function	a moving window ||| apply window	count=1
function	[function_1] to a ||| [function_1] [function_2]	count=6
arg	apply a function ||| func	count=3
function	add numeric [function_2] ||| [function_2] [function_1]	count=1
arg	1-dimensional ndarray ||| arr key	count=1
function	best locator ||| locator	count=1
function	path's extension ||| check extension	count=1
class	needs additional ||| period	count=1
function	expanding [function_2] ||| [function_1] [function_2]	count=3
function_arg	[function_1] frequency ||| [arg_2] [function_1]	count=7
function_arg	operations to the ||| operations cls	count=1
class	of interval ||| interval index	count=1
module_class	from the [class_2] ||| [module_1] [class_2]	count=2
arg	so [arg] bitwise precedence ||| [arg]	count=1
function	[function_1] given offset/observance ||| [function_1] [function_2]	count=1
function	the block_manager ||| get block manager	count=1
function	that path's extension ||| extension	count=1
function	[function_1] result ||| [function_1] [function_2]	count=4
module_class	sparsearray [class_2] ||| [module_1] [class_2]	count=3
module	only use this if ||| core indexes	count=1
function	that an positional ||| positional	count=1
arg	the [arg] using ||| [arg] cur	count=1
function	of series concat ||| series	count=1
class	manager with ||| block manager	count=1
class	support start stop kwds ||| fixed	count=1
class	index ||| datetime index	count=9
function	the specified categories ||| categories	count=1
function	[function_1] object ||| [function_1] [function_2]	count=6
function	to ndarray raises on ||| to ndarray	count=1
function_arg	[function_1] unit ||| [function_1] [arg_2]	count=2
arg	item [arg_2] ||| insert [arg_2] [arg_1]	count=1
class	a ||| html frame parser	count=2
class	gets the ||| categorical	count=2
arg	[arg_1] returning new ||| [arg_1] [arg_2]	count=1
function	internal ||| values	count=1
arg	substrings from each element ||| arr start stop step	count=1
function	the numeric ||| numeric	count=1
arg	str against ||| cls	count=1
arg	arr1 and arr2 ||| arr1 arr2	count=2
function	categorical ||| categorical	count=4
function	generate bin ||| generate	count=1
arg	category value returning a ||| inplace ascending na_position	count=1
function	exception ||| exception	count=1
class	to its ||| series	count=1
module	see :class packer for ||| io msgpack	count=1
arg	same ||| other	count=1
arg	against the [arg_2] ||| [arg_1] [arg_2]	count=1
arg	the labels [arg_2] ||| [arg_2] [arg_1]	count=2
function	the ftypes (indication ||| ftypes	count=1
arg	a function [arg] as specified ||| [arg] kwargs	count=1
function_arg	[function_1] [arg_2] ||| [function_1] cls iterables [arg_2]	count=6
arg	indexer like _name in ||| name indexer	count=1
class	return the number ||| index	count=2
function	boolean if ||| is dtype	count=1
function	this level ||| has level	count=1
function	binners ||| set binner	count=1
function	true if [function_2] ||| [function_2] [function_1]	count=2
arg	already ||| value format	count=1
arg	dataframe columns parameters ||| data	count=1
function	[function_1] of transform ||| [function_2] [function_1]	count=2
module	if we ||| core indexes	count=1
function	the index ||| index	count=1
arg	indexer ||| indexer allow_fill	count=1
arg	fast lookup ||| arr	count=1
function	[function_1] string ||| [function_2] [function_1]	count=1
function	the classes which ||| index	count=1
function	correlation ||| corr	count=1
class	maps[0] ||| chain	count=2
function	self as [function_2] ||| [function_2] [function_1]	count=2
arg	be table ||| format	count=1
class	after a ||| period index	count=1
arg	reshape [arg] ||| [arg]	count=3
arg	plural 'names' parameter for ||| names deep	count=1
arg	dataframe ||| data x y by	count=1
module	datetime index with business ||| indexes	count=1
class	from maps[0] ||| chain	count=1
function	to the ||| to dtypes	count=1
module	index ||| core indexes	count=20
function	to ||| convert to	count=3
arg	[arg_1] and index ||| [arg_2] [arg_1]	count=5
arg	exist and be ||| format	count=1
function	class for writing stata ||| to stata	count=1
class	over the ||| html	count=1
class	ndarray only ||| categorical index	count=1
module	validates that we have ||| core	count=1
function	string cast ||| cast	count=1
function	return copy ||| copy	count=1
function	additional handling as ||| array wrap	count=1
arg	n indexable columns ||| columns	count=1
arg	[arg_1] freq with ||| [arg_1] [arg_2]	count=4
arg	scalar data converts other ||| cls data	count=1
function	[function_1] exception and ||| [function_2] [function_1]	count=2
arg	render ||| buf columns col_space	count=1
function	to given ||| get	count=1
function	via the 'numpy' library ||| argmin with	count=1
function	use this if ||| set	count=1
class	an ||| categorical index	count=2
function	formats to ||| convert datetime to	count=1
function	to connect to the ||| connect	count=1
class	get ||| ndframe	count=1
class	for series columns for ||| ndframe	count=1
function	[function_1] array ||| [function_2] [function_1]	count=11
function	values ||| from values	count=1
function_arg	types of [arg_2] ||| [arg_2] [function_1]	count=2
arg	columns ||| data	count=1
arg	arithmetic operations [arg_2] ||| [arg_1] [arg_2]	count=6
class	into ||| html frame parser	count=1
function	of index to ||| index	count=1
module	an object dtype ||| dtypes	count=2
module	underlying data ||| core indexes	count=2
arg	or sas7bdat [arg] ||| filepath_or_buffer [arg]	count=1
module	object and return the ||| io	count=1
function	columns as lists of ||| str columns	count=1
function_arg	feather-format object [arg_2] ||| [function_1] [arg_2]	count=1
function	series/index by indicated number ||| str repeat	count=1
class	applies the ||| series	count=1
arg	data ||| data index dtype	count=1
arg	with the fill_value ||| allow_fill fill_value	count=1
function	handling as ||| array	count=1
arg	be table ||| key value format	count=1
class	categorical to ||| categorical	count=2
function	packed ||| packb	count=1
arg	requested ||| level inplace	count=1
class	single element ||| ndframe	count=1
function	take ||| take nd	count=5
arg	info from ||| freqstr	count=1
class	can be ||| html frame	count=1
class	group ||| group by	count=4
class	[class_1] excluding elements ||| [class_1] [class_2]	count=4
class	times to midnight ||| datetime index	count=1
function	create a new ||| new	count=1
class	to timedelta ||| timedelta index	count=1
function	of pandasobject ||| any pandas objects	count=1
module	html ||| formats	count=1
function	for writing stata ||| stata	count=1
class	the ||| html frame parser	count=2
function	pandasobject ||| any pandas objects	count=1
function	label for ||| label	count=1
arg	labels [arg_2] ||| [arg_1] axis [arg_2]	count=1
function	apply the ||| apply	count=3
function_arg	to coerce [arg_2] ||| [function_1] [arg_2]	count=3
function	[function_1] to beginning ||| [function_2] apply [function_1]	count=1
function	positional ||| has valid positional	count=1
function	any axis is ||| is	count=1
arg	dtype if dtype ||| dtype	count=1
arg	query in a dataframe ||| data columns index_col coerce_float	count=1
function	info ||| update info	count=1
arg	series ||| series	count=2
function	'numpy' library the ||| validate take with convert	count=1
arg	to the specified dtype ||| dtype	count=1
class	shift ||| datetime tzblock	count=1
function	base freq and stride ||| base and stride	count=1
arg	the indexer input ||| indexer	count=1
arg	node like ||| node	count=1
module	indexes ||| core indexes	count=2
class	index and its ||| range index	count=1
function_arg	[function_1] column ||| [function_1] key [arg_2]	count=1
function	closed bounds ||| interval closed bounds	count=2
function	numeric ||| is numeric v	count=1
function	never a ||| is	count=1
function	sif to ||| to	count=1
arg	left and ||| left	count=7
class	checks whether the frame ||| data frame	count=1
class	new multiindex from ||| multi	count=1
function	want to set ||| set	count=1
function_arg	fill value [arg_2] ||| [function_1] [arg_2]	count=4
module	is the ||| core	count=1
module_class	of the data ||| core data frame	count=1
class	[class_1] index ||| [class_1] [class_2]	count=2
function	masked rec array and ||| masked rec array to	count=1
arg	[arg_1] arr2 are ||| [arg_2] [arg_1]	count=3
function	[function_1] a malformed ||| [function_2] [function_1]	count=1
function	quantile a ||| quantile	count=1
arg	with optional fill value ||| fill_value	count=1
function_arg	result [arg_2] ||| [arg_2] [function_1]	count=4
class	is maps[0] ||| map	count=1
function	attributes ||| attributes	count=1
function_arg	from [arg_2] ||| [function_1] [arg_2]	count=6
function	raw data ||| raw data	count=2
arg	left and ||| cls left	count=1
function	and be table ||| append	count=1
class	used to iterate ||| html frame	count=1
function	to construct ||| construct	count=1
module	called after a ||| core indexes	count=2
arg	two ||| other	count=12
class	dtype) in this object ||| ndframe	count=1
function	after a ||| array	count=3
function	render the built ||| render	count=1
function	a string-like ||| string array	count=1
function	for header rows in ||| pop header name	count=1
arg	right data ||| right vertical	count=1
function	ordered data ||| ordered	count=1
function	slice the [function_2] ||| [function_2] [function_1]	count=4
class	return ||| sparse array	count=1
arg	ndarray or list ||| index	count=1
module_class	the data for ||| io data col	count=1
arg	nentries ||| nentries	count=1
class	called ||| period	count=1
function_arg	[function_1] file path ||| [arg_2] [function_1]	count=1
class	values but densify first ||| non consolidatable mix in	count=1
function_arg	apply the function ||| apply func mgr	count=2
module	for series columns for ||| core	count=1
arg	a valid ordered ||| ordered	count=1
class	of this indexer ||| index col	count=1
function	type ||| type	count=6
function	string-like and string-like ||| string	count=1
arg	append to table in ||| value format append	count=1
function	a categorical if not ||| categorical	count=1
class	col ||| col	count=2
function_arg	where statement is ||| where w	count=1
module	pack object ||| msgpack	count=1
function_arg	[function_1] [arg_2] ||| [function_1] matrix [arg_2]	count=7
arg	times ||| repeats	count=1
function	series ||| get series	count=1
arg	correct ||| fill_value fill_value_typ	count=1
module	sqlalchemy ||| io	count=1
module	2 [module] consensus ||| [module]	count=1
function	stata and ||| cast to stata	count=1
class	dataframe ||| sparse data frame	count=3
function	compare numeric ||| is numeric v string	count=1
function	the (attr formatted_value) ||| format attrs	count=4
class	datetimeindex with ||| datetime index	count=1
arg	dtype of the ||| dtype	count=1
function	with integer stride ||| stride	count=1
function	integer stride parameters ||| get stride from	count=2
module_class	the pytables file ||| io hdfstore	count=1
class	columns ||| data	count=1
module	file ||| io	count=2
arg	dataframe and ||| data	count=1
function	the best locator based ||| get locator	count=1
function	return an attributes dict ||| get attributes dict	count=1
function	table reflecting the structure ||| table setup	count=1
function	function to determine if ||| dtype n method	count=1
class	dataframe ||| data frame	count=39
arg	of other to ||| other	count=1
class	a dataframe as ||| data frame	count=1
module	calculate ||| core indexes	count=1
function	(namely the date ||| date	count=1
function_arg	string and pads it [function_1] [arg_2] ||| io [function_1] [arg_2]	count=1
module	time index using the ||| core	count=1
arg	higher freq with ||| cls value freq	count=2
function	boolean if ||| is	count=1
arg	have a ||| cls	count=1
function	histogram of the ||| hist	count=1
class	keyerror is maps[0] ||| chain map	count=1
class	*this is an ||| index	count=2
function_arg	[function_1] [arg_2] ||| [function_1] level lengths [arg_2]	count=1
function	array and [function_2] ||| [function_1] [function_2]	count=1
function	malformed ||| malformed	count=1
module	bytes see :class ||| io msgpack	count=1
function	my self as a ||| as	count=1
module	coerce ||| core dtypes	count=3
class	multiindex from ||| multi	count=1
function	style and color ||| style	count=1
arg	[arg] using the ||| [arg] cur	count=2
function	operations to convert timedelta-like ||| td index cmp	count=1
function	columns ||| columns	count=2
arg	each value of x ||| x	count=1
module	from ||| core	count=1
function_arg	series arithmetic operations ||| series op	count=3
function	the ordered attribute ||| get ordered	count=1
arg	and ||| format	count=1
function	locale ||| set locale	count=1
class	index objects and sorts ||| range index	count=1
class	[class] current ||| [class]	count=2
function	copy of the sparsearray ||| copy	count=1
function	dataframe to ||| to	count=1
function	take the codes ||| take	count=1
function	columns to be read ||| columns	count=1
arg	[arg_1] the smallest ||| [arg_1] [arg_2]	count=1
class	it has ||| series	count=1
function	our ||| set	count=1
function	[function_1] types ||| [function_1] [function_2]	count=6
class	use this ||| index	count=1
function	table ||| table	count=6
function	with the block ||| create for block	count=1
function	is our asof key ||| asof key	count=1
arg	statement is of ||| w	count=1
arg	with optional fill ||| fill_value	count=1
class	already exist and ||| hdfstore	count=1
module	simple cross-tabulation ||| reshape	count=1
arg	of arr1 and arr2 ||| arr1 arr2	count=1
arg	a and [arg_2] ||| [arg_2] [arg_1]	count=1
function_arg	[function_1] code ||| [function_1] [arg_2]	count=2
function	index row labels ||| index	count=1
arg	or regular expression in ||| arr pat flags	count=1
function_arg	[function_1] indexer and ||| [arg_2] [function_1]	count=2
arg	the requested level the ||| level	count=1
arg	column and ||| col	count=3
class	a numpy array ||| array	count=1
function	apply ||| apply index	count=1
function	float is formatted ||| set eng float	count=1
function_arg	shift the [arg_2] ||| [function_1] [arg_2]	count=1
function	array and create the ||| array to	count=1
function	to iterate over ||| build	count=1
module_class	return [class_2] ||| [module_1] [class_2]	count=16
function	check [function_2] ||| [function_2] [function_1]	count=2
function	sequence ||| sequence	count=1
class	maps[0] raise ||| chain map	count=1
module	to midnight length ||| indexes	count=1
arg	actual interpolation [arg] ||| [arg]	count=1
function	box function to ||| box func	count=1
arg	data to an ||| data index	count=1
class	and return the op ||| bin op	count=1
arg	state ||| state	count=1
function	function or functions ||| rename axis	count=1
function	formats to [function_2] ||| [function_1] stata [function_2]	count=2
function	dictionary for ||| construct axes dict from	count=1
arg	file node must already ||| format	count=1
class	from maps[0] raise keyerror ||| map	count=1
module	index objects ||| core indexes	count=1
class	maps[0] raise keyerror ||| map	count=1
arg	cross-tabulation ||| columns values	count=1
module	2 [module] consensus name ||| [module]	count=1
module	couple [module] exceptions see ||| [module]	count=1
module	lookup ||| core	count=1
function	internal repr ||| values	count=1
function	unit ||| unit	count=1
function_arg	convert [arg_2] ||| [arg_2] [function_1]	count=12
class	engineering ||| eng formatter	count=1
function	on sunday use day ||| sunday	count=1
function	from ||| parse	count=2
arg	plots a series ||| series	count=1
function	bounds ||| to bounds	count=1
arg	interpolation [arg] will ||| [arg]	count=1
function_arg	set coerce [arg_2] ||| [function_1] to dtypes [arg_2] dtypes	count=2
class	applicable ||| group by	count=1
class	a single block and ||| block manager	count=1
function	to convert to ||| to	count=1
class	the underlying ||| range index	count=1
arg	ndarray copy ||| copy	count=1
function	needs additional handling ||| wrap	count=1
function	[function_1] datetime ||| [function_2] [function_1]	count=4
function	the datetimelike methods (as ||| datetimelike methods	count=1
function	options ||| pp options	count=1
arg	before ||| before	count=1
module_class	putmask the data to [module_1] [class_2] possible that ||| [module_1] [class_2] putmask mask	count=1
class	valid stata ||| stata	count=1
class	each group ||| group by	count=7
function	format as dataframe ||| frame	count=1
arg	an ndarray copy ||| index dtype copy	count=1
function	thereafter monday instead ||| to monday	count=2
module	object datetimeindex timedeltaindex ||| core dtypes	count=1
function	datetimeindexes ||| sub datelike dti	count=1
module	packed bytes see :class ||| io msgpack	count=1
function	check ||| is	count=1
class	raise keyerror is maps[0] ||| map	count=1
function	view of ||| view	count=1
function	a masked [function_2] ||| [function_2] [function_1]	count=6
arg	frequency ||| periods freq	count=3
arg	that time [arg_2] ||| [arg_1] [arg_2]	count=1
function	all the locales ||| locales	count=1
function	fill [function_2] ||| [function_1] [function_2]	count=6
function	our binners ||| binner	count=1
function_arg	[function_1] indexer ||| [function_1] [arg_2]	count=2
arg	to table in ||| key	count=1
function	decorator to add ||| add	count=1
function	test [function_2] ||| [function_1] [function_2]	count=4
function_arg	[function_1] substrings ||| [arg_2] [function_1]	count=1
module	for options ||| io	count=1
module	exist and ||| io	count=1
function	types ||| types	count=6
arg	two ||| other result_name	count=1
function	dtype ||| indexer dtype	count=1
module	indexes give a ||| indexes	count=1
class	over the ||| html frame parser	count=1
arg	sure that time and ||| time	count=1
function	a result set coerce ||| coerce	count=1
function	//www stata ||| stata	count=1
function	load a feather-format ||| feather	count=1
class	index values and index ||| datetime index	count=1
function	coerce values ||| coerce args	count=1
function_arg	result set [arg_2] ||| [function_1] [arg_2]	count=1
class	must ||| non consolidatable mix in	count=1
class	columns excluding na/null values ||| data	count=1
arg	risk of ||| subarr	count=1
arg	use this ||| arr key	count=1
function	dtypes ||| dtypes	count=2
function	operations to convert timedelta-like ||| td	count=1
function	data the shifted data ||| slice	count=1
function	holidays between start_date ||| holidays	count=1
arg	[arg] empty ||| [arg]	count=1
class	of a dataframe ||| data frame	count=4
function	[function_1] interpolate ||| [function_2] [function_1]	count=8
function	[function] of ||| create [function]	count=1
class	times ||| datetime	count=1
arg	the function ||| func	count=1
function	as a ||| as	count=1
arg	on where ||| key where start stop	count=1
class	iterate ||| frame	count=1
function	join columns with ||| join	count=1
function	1d array ||| intervals	count=1
arg	input values as ||| values sort order	count=1
function_arg	[function_1] ncols ||| [function_1] nrows [arg_2]	count=1
arg	this if you ||| key	count=1
function	names ||| set default names	count=2
function	that can be used ||| build	count=1
arg	values ||| values ndim	count=1
function	info axis of ||| info	count=1
arg	to the key ||| key	count=1
function	types of ||| types	count=1
function	[function] item major ||| set [function]	count=1
module	must already exist and ||| io	count=1
arg	numpy ||| dtype	count=1
arg	column and index ||| index col	count=5
function	alias to ||| alias	count=1
arg	of type window_type on ||| mean how	count=1
class	use ||| index	count=1
module	with ||| core indexes	count=2
function_arg	[function_1] and arr2 ||| [function_1] arr1 [arg_2]	count=1
arg	interpret ||| val pandas_dtype	count=1
function	[function_1] the where ||| [function_1] [function_2]	count=1
function	given a tuple ||| get	count=1
function	times in parallel ||| test parallel	count=1
arg	[arg_1] by periods ||| [arg_2] [arg_1]	count=4
arg	terms ||| terms	count=2
arg	or columns using input ||| mapper axis copy inplace	count=1
function_arg	[function_1] *not* the ||| [function_1] [arg_2]	count=4
class	for ||| datetime index	count=1
arg	only use this ||| key	count=1
function	for header ||| header	count=1
function	rewrite the assignment operator ||| rewrite assign	count=1
class	the block we must ||| non consolidatable mix in	count=1
function	keys that are ||| keys	count=1
arg	target time zone ||| tz axis level	count=1
function	autocorrelation ||| autocorrelation	count=1
function	for valid [function_2] ||| [function_1] [function_2]	count=1
function_arg	bytes [arg_2] ||| io pad [function_1] [arg_2]	count=1
module	columns ||| core	count=1
arg	must ||| key value	count=1
function_arg	create an [arg_2] ||| [function_1] [arg_2]	count=4
arg	moving [arg_2] ||| [arg_1] [arg_2]	count=1
function	to compare numeric ||| numeric	count=1
module	using the ||| core	count=1
function	an html ||| to html	count=2
arg	the [arg] if ||| [arg]	count=1
arg	or object coercible ||| join overwrite filter_func	count=1
class	must ||| hdfstore	count=1
function_arg	sanitize input [arg_2] ||| [arg_2] [function_1]	count=4
arg	for requested ||| key method	count=1
arg	and be table ||| key value	count=1
arg	_apply kwargs ||| window center	count=1
arg	values according to indexer ||| indexer axis	count=2
function_arg	[function_1] key ||| [arg_2] [function_1]	count=4
function_arg	quickly [function_1] [arg_2] ||| [function_1] [arg_2] takeable	count=3
module	the ||| formats	count=1
function	used to iterate ||| build	count=1
function	lists to [function_2] ||| [function_2] [function_1]	count=1
function	is supported ||| is	count=1
function	path's extension ||| extension	count=1
function	join [function_2] ||| [function_1] [function_2]	count=2
function	float is formatted in ||| set eng float	count=1
arg	table in ||| key	count=1
function	[function_1] shell ||| [function_1] [function_2]	count=1
class	of datetime ||| datetime	count=1
module	return ||| compat	count=1
arg	be a ||| new align	count=1
arg	out ast ||| all_nodes	count=1
arg	packed object return ||| packed object_hook list_hook use_list	count=1
arg	and plural 'names' parameter ||| names deep	count=1
module	called ||| core indexes	count=4
module	return datetimeindex ||| indexes	count=1
function	strings to [function_2] ||| [function_2] [function_1]	count=2
class	return index or ||| datetime index ops	count=1
arg	array to the smallest ||| categories	count=1
function	given quantile a ||| quantile	count=1
module_class	[module_1] categorical ||| [module_1] [class_2] put	count=1
function	return dtype and n/a ||| dtype and	count=1
class	the current [class] going back ||| [class]	count=1
function_arg	this is [arg_2] ||| [function_1] [arg_2]	count=3
class	remove ||| chain	count=1
arg	after a ufunc ||| result context	count=3
class	type ||| dtype	count=2
arg	[arg_1] right array ||| [arg_1] [arg_2]	count=3
function	return the size ||| itemsize	count=1
arg	match of regular expression ||| flags	count=2
arg	sparse-compatible version of ndarray ||| indices axis allow_fill fill_value	count=1
arg	left and right array ||| left right closed	count=1
function	a table [function_2] ||| [function_2] [function_1]	count=4
arg	do ||| src_list dest_list inplace regex	count=1
function	highlight the maximum by ||| highlight max	count=1
arg	check the key ||| key	count=1
module	from 1-dimensional ndarray ||| indexes	count=1
function	concatenate ||| concatenate	count=1
arg	on 3 columns ||| index columns	count=1
arg	of value from 1-dimensional ||| value	count=1
arg	to cls ||| cls	count=1
arg	from the iterable ||| iterable	count=1
class	from maps[0] raise ||| chain map	count=1
function	from ||| dropna	count=1
module	expression that ||| computation	count=1
arg	check that left and ||| left	count=4
arg	arithmetic operations [arg_2] ||| [arg_2] [arg_1]	count=6
function	add [function_2] ||| [function_1] [function_2]	count=7
function	sets index names ||| names	count=1
function	the metadata for ||| read metadata	count=1
class	never ||| block	count=1
arg	color_spec ||| color_spec	count=1
class	necessary ||| sparse	count=1
function	timeseries to specified ||| asfreq	count=1
class	each dataframe in panel ||| panel	count=1
class	return the ||| multi index	count=1
function	new ||| putmask	count=1
module	object datetimeindex timedeltaindex ||| dtypes	count=1
function	get a ||| get dtype	count=1
class	index ||| datetime index ops mixin	count=2
arg	called upon unpickling ||| cls d	count=1
arg	value using ||| value	count=1
function	a [function] ||| [function]	count=3
class	the list ||| sparse list	count=1
arg	as a dataframe ||| data values index columns	count=1
function	according ||| slice bound	count=1
class	the op ||| op	count=1
arg	packed object return ||| packed	count=1
function	return the slice ||| slice	count=1
arg	boolean if ||| b	count=1
function	downsample the cython defined ||| downsample	count=2
arg	allowed ||| allowed	count=1
class	only applicable ||| series group by	count=2
class	used to ||| parser	count=1
arg	data from some ||| cls data	count=2
function	datetime to the ||| dt to	count=1
function	helper function to determine ||| n method	count=1
function	values ||| level values	count=1
arg	if s ||| s	count=1
function	of kwargs suitable for ||| kwargs	count=1
function_arg	[function_1] of two ||| [function_1] [arg_2]	count=16
module	return packed bytes ||| msgpack	count=1
class	node ||| hdfstore	count=1
function	apply we ||| apply	count=1
function	[function_1] categorical ||| [function_1] [function_2]	count=2
function	to a leap ||| is leap	count=1
function_arg	[function_1] if dtype ||| [arg_2] [function_1]	count=4
module	[module] datetime64's with ||| [module]	count=3
function	holidays ||| holidays	count=1
function	try to read from ||| read	count=1
class	downsample ||| period index resampler	count=1
class	1-dimensional ndarray ||| index	count=1
function	with closed bounds ||| closed bounds	count=1
arg	gets called after ||| result	count=3
function	the display ||| display	count=1
arg	compute a ||| index	count=1
arg	dataframe columns parameters ||| data x y	count=1
class	iterate over the ||| parser	count=1
arg	omitted where alternately any ||| how thresh subset	count=1
arg	either ||| how lsuffix	count=1
function	the first element ||| item	count=1
module	this is similar ||| core reshape	count=1
function	for series ||| method series	count=3
function	we have a null ||| is null	count=1
function	element ||| map indices py	count=1
function	parser based ||| parser	count=1
function	a matrix ||| matrix	count=1
arg	compute a simple cross-tabulation ||| columns values	count=1
module	or all of the ||| core	count=1
module	from ||| io	count=2
class	to ||| datetime index	count=1
class	object ||| html frame parser	count=2
arg	against [arg_2] ||| [arg_1] [arg_2]	count=1
arg	this argument return ||| arg	count=1
function	convert to object if ||| to safe	count=2
function	[function_1] monotonic ||| [function_1] [function_2]	count=1
arg	type window_type on ||| mean how	count=1
arg	file node ||| key value	count=1
arg	[arg_1] cartesian product ||| [arg_2] [arg_1]	count=6
arg	ensure incoming data ||| data subarr	count=1
function	a column ||| col	count=1
function	available options grouped ||| pp options	count=1
class	each interval [class_2] ||| [class_1] [class_2]	count=1
arg	and panels are conformable ||| panels	count=1
class	property synonym ||| ndframe	count=1
arg	to run ||| num_threads kwargs_list	count=1
class	data ||| index	count=3
arg	:meth ||| inplace	count=2
function	only use ||| set value	count=1
arg	at passed [arg] ||| index [arg]	count=1
function	[function_1] parameters ||| [function_1] [function_2]	count=3
function	use ||| value	count=1
class	for this columns ||| index col	count=1
function	registered [function_2] ||| [function_1] [function_2]	count=1
class	iterate over the ||| frame parser	count=1
module	this is similar to ||| core reshape	count=1
function_arg	[function_1] data to ||| [arg_2] [function_1]	count=1
function	that we ||| ordered	count=1
function	numeric ||| numeric	count=6
function	in index ||| index	count=1
arg	o and ||| o	count=1
class	needs additional handling as ||| index	count=1
function	to closest period ||| period	count=1
class	length ||| index	count=1
function	must be ||| maybe	count=1
class	to dataframe ||| sparse data frame	count=1
arg	method ||| method	count=1
function	returns axes if ||| axes	count=1
function	values ||| datetime64 from values	count=1
function	compute the symmetric difference ||| symmetric difference	count=1
module	filter ||| core computation	count=1
function	columns that ||| columns	count=1
class	multiindex at the ||| multi index	count=1
class	are a series ||| series	count=1
function_arg	function for [arg_2] ||| cython [function_1] [arg_2]	count=3
arg	_apply kwargs and ||| name window center	count=1
function	add ||| add	count=13
module_class	return the i-th value [module_1] [class_2] by location ||| [module_1] [class_2] ixs i axis	count=1
function	null_color ||| highlight null	count=1
function	removed if ||| droplevel	count=1
class	op ||| op	count=1
class	columns excluding na/null values ||| data frame	count=1
module	remove ||| compat	count=1
function	[function_1] an iterator ||| [function_2] [function_1]	count=1
module	take the ||| core	count=1
function	of unicode strings ||| randu	count=1
module	values attribute ||| core	count=1
arg	dtype converting float ||| value dtype	count=1
arg	[arg_1] 'kwargs' should ||| [arg_1] [arg_2]	count=2
arg	parameters ||| ax	count=1
function	utility routine to turn ||| for	count=1
function	numpy doesn't like ||| v string like	count=1
function	validates ||| validate	count=1
function	'numpy' library the third ||| take with	count=1
arg	[arg_1] and b ||| [arg_1] [arg_2]	count=3
arg	the shape of the ||| shape	count=1
module	styles to ||| io	count=1
class	tree-like object ||| frame parser	count=1
function	custom ||| custom	count=1
function	[function_1] function ||| [function_2] [function_1]	count=4
function	hash a [function_2] ||| [function_2] [function_1]	count=1
arg	values to be ||| values	count=1
class	other [class] operations necessary ||| [class]	count=2
function	as an html ||| to html	count=2
function	string ||| parsed string	count=1
function_arg	series/index by [arg_2] ||| [function_1] [arg_2]	count=1
function_arg	[function_1] non-tuple ||| [arg_2] [function_1]	count=2
function	construct an intervalindex from ||| from	count=1
function	index [function_2] ||| [function_2] [function_1]	count=5
module	index ||| core	count=1
function_arg	convert [arg_2] ||| [function_1] to number format [arg_2]	count=1
module	see :class packer for ||| io	count=1
arg	be a single ||| new align	count=1
function_arg	called prior [arg_2] ||| [arg_2] [function_1]	count=1
function	dispatch to apply ||| apply	count=1
module	property ||| core	count=2
function	for getting a cross-section ||| xs	count=1
class	it ||| series	count=1
function	ndarray only use ||| value	count=1
arg	object coercible to ||| join overwrite filter_func	count=1
function	string-like array to convert ||| maybe convert string to	count=1
module	built up styles ||| io	count=1
function	return a list of ||| tolist	count=1
function	a leap year ||| is leap year	count=2
function	[function_1] interpolation ||| [function_2] [function_1]	count=2
module	raise keyerror ||| compat	count=1
module	bytes ||| io msgpack	count=2
class	setup ||| resampler	count=1
arg	using one [arg_2] ||| [arg_2] [arg_1]	count=4
arg	indexer like _name in ||| indexer	count=1
function	[function_1] post ||| [function_2] [function_1]	count=1
function	with a groupby ||| groupby	count=1
function	[function_1] beginning of ||| [function_2] [function_1]	count=1
function	hard to parse ||| parse time	count=1
class	attribute ||| series	count=1
function	resolve a variable name ||| resolve	count=1
class	panel or ||| panel	count=1
function	sif to ||| date to	count=1
module	bytes see ||| msgpack	count=1
function	masked [function_2] ||| [function_2] [function_1]	count=6
function	multirow e ||| multirow	count=1
module	create/cache the ||| io	count=1
function	[function_1] the series ||| [function_1] [function_2]	count=2
arg	specialized cython ||| out	count=1
function	read csv file (discouraged ||| from csv	count=2
function	datetime to sif ||| datetime to	count=2
arg	dataframe the levels ||| data values	count=1
module	and the attrs from ||| io	count=1
function	/ pandas type to ||| table type	count=1
class	new block [class_2] ||| [class_1] [class_2]	count=3
function	be [function_2] ||| [function_2] [function_1]	count=1
module	lookup of ||| core indexes	count=1
class	of a categorical ||| categorical	count=1
arg	encode input values as ||| values sort order	count=1
function	determine ||| dtype n method	count=1
module	this object ||| indexes	count=1
arg	[arg_1] arr ||| [arg_2] [arg_1]	count=6
arg	optional set logic ||| join_axes	count=1
function	convert to object ||| to	count=2
arg	moving function ||| arg window func	count=2
arg	exist and ||| value	count=1
function	construct concatenation ||| mgr concatenation	count=1
arg	blocks collect ||| f axis consolidate transposed	count=1
function	a boolean if ||| is dtype	count=1
module	the other axes ||| core	count=1
function	previous ||| previous	count=2
arg	our original type ||| dtype	count=1
function	'numpy' library ||| validate argmin with	count=1
module	cross-tabulation of ||| core	count=1
class	the float values ||| float	count=1
arg	packed ||| packed	count=1
function_arg	[function_1] using ||| [arg_2] [function_1]	count=1
function_arg	union of [arg_2] ||| [arg_2] [function_1]	count=2
function	with the bom ||| bom	count=1
function	and create the ||| to	count=1
arg	a style_dict ||| cls style_dict	count=2
class	block from ||| block	count=1
function_arg	[function_1] [arg_2] ||| [function_1] arrays [arg_2]	count=12
arg	along a given axis ||| axis method na_option	count=1
function_arg	difference of two ||| difference other result_name	count=2
arg	of dates ||| dates	count=1
class	return ||| parser	count=1
arg	from 1-dimensional ||| arr	count=1
function_arg	take the [arg_2] ||| [function_1] [arg_2]	count=1
function	[function_1] type ||| [function_2] [function_1]	count=8
class	underlying array which by-definition ||| datetime index ops mixin	count=1
function	block of [function_2] ||| [function_1] [function_2] class values	count=1
module	with times to ||| core	count=1
function_arg	[function_1] distance ||| [function_1] [arg_2]	count=1
arg	as ||| values	count=2
function	array [function_2] ||| [function_2] [function_1]	count=6
arg	the left [arg_2] ||| [arg_1] [arg_2]	count=1
module	with times to midnight ||| indexes	count=1
function	at the given quantile ||| quantile	count=1
function	parse the [function_2] ||| [function_2] [function_1]	count=2
function_arg	nodes [arg_2] ||| [arg_2] [function_1]	count=1
arg	data to ||| data	count=2
function	take optional positional ||| optional args	count=1
class	my state ||| index col	count=1
function	like to compare ||| string like	count=1
function	series/index ||| str	count=8
function	convert from sif to ||| to	count=1
function_arg	[function_1] arithmetic operations ||| [function_1] [arg_2]	count=12
function	stata and ||| to stata	count=1
arg	valid ordered ||| cls ordered	count=1
class	gets ||| period index	count=2
module	array object ||| dtypes	count=1
arg	or object coercible to ||| other join overwrite filter_func	count=1
arg	be a single ||| new	count=1
arg	write out the binary ||| fname	count=1
arg	after a ufunc needs ||| context	count=1
class	columns excluding ||| data	count=1
arg	on where ||| where	count=1
function	already exist and be ||| append	count=1
function_arg	[function_1] a distance ||| [arg_2] [function_1]	count=2
function	an integer ||| integer	count=1
class	can be ||| frame	count=1
arg	the key ||| key	count=3
function	string and ||| string to	count=1
arg	fname are valid parameters ||| fname	count=1
function	given an ||| get	count=1
function	return the internal repr ||| values	count=1
module	remove and ||| compat	count=1
module	compute ||| reshape	count=1
function	function to determine ||| n method	count=1
arg	freq ||| freq axis	count=1
arg	list of a func ||| func	count=1
function	str df in ||| str	count=1
function	the display options for ||| display options	count=1
function	rec [function_2] ||| [function_2] [function_1]	count=5
arg	fill_value and arr dtype ||| arr fill_value	count=1
module	sparseseries (with nan fill_value) ||| sparse	count=1
arg	values from this ||| values	count=2
function	'numpy' library ||| with convert	count=1
function	function for ||| arith method	count=2
function	as a sparse ||| as sparse	count=2
function	nat which has the ||| nat new	count=1
function	wrap op [function_2] ||| [function_1] [function_2]	count=1
function	to datetime ||| elapsed date to datetime	count=1
module	categorical ||| core indexes	count=4
function	is a deprecated option ||| deprecated	count=1
class	to table in ||| hdfstore	count=1
class	data ||| data	count=3
arg	write it to stream ||| stream	count=1
function	downsample the ||| downsample	count=2
function	stride [function_2] ||| [function_2] [function_1]	count=1
class	series to dataframe ||| data frame	count=1
module	:class packer for options ||| msgpack	count=1
arg	[arg_1] level j ||| [arg_2] [arg_1]	count=1
class	to midnight ||| datetime	count=1
arg	indexer ||| cls name indexer	count=1
class	holidays ||| holiday calendar	count=1
class	the underlying array which ||| index ops mixin	count=1
class	that can be ||| html frame	count=1
function	[function_1] set a ||| [function_1] [function_2]	count=2
arg	the data ||| data	count=1
function_arg	best locator [arg_2] ||| [function_1] [arg_2]	count=1
function	time strings to time ||| to time	count=1
function	parse specified sheet s ||| parse	count=1
function	[function_1] [function_2] ||| [function_1] stata [function_2]	count=12
function	[function_1] html table ||| [function_2] [function_1]	count=2
function	to a timedeltaindex ||| to index	count=1
function	on is monotonic ||| monotonic	count=1
class	iterate over ||| html frame	count=1
class	add ||| group by	count=1
module	of ||| core indexes	count=6
class	create [class] from a ||| [class]	count=1
module	the object ||| core dtypes	count=17
function	the dtype ||| dtype	count=5
arg	into a ||| index_col	count=1
function	validate that the ||| validate	count=1
function	fast lookup ||| set	count=1
arg	statement ||| w	count=1
function	take optional positional ||| optional	count=1
class	series ||| data frame	count=1
function	gets called prior ||| array prepare	count=1
function	validates that ||| validate ordered	count=1
function	return ||| get	count=22
function	string-like [function_2] ||| [function_1] [function_2]	count=1
arg	packed object return an ||| packed object_hook list_hook use_list	count=1
function_arg	period [arg_2] ||| [function_1] alias [arg_2]	count=1
arg	nrows ||| nrows	count=1
arg	return item and ||| item	count=1
class	necessary for ||| sparse array	count=1
function	after ||| wrap	count=3
function	asof [function_2] ||| [function_1] [function_2]	count=1
class	underlying array which by-definition ||| ops mixin	count=1
arg	series or ||| axis level	count=1
function_arg	coerce values [arg_2] ||| [function_1] values [arg_2]	count=3
function	self as [function_2] ||| [function_1] [function_2]	count=2
arg	ndarray or list of ||| index columns	count=1
function_arg	sparse [arg_2] ||| [arg_2] [function_1]	count=1
module_class	and replaces these with [module_1] [class_2] for missing value ||| [module_1] [class_2]	count=2
function_arg	extension [arg_2] ||| [arg_2] [function_1]	count=3
arg	op [arg_2] ||| [arg_1] [arg_2]	count=4
function_arg	operations to ||| operations cls	count=1
arg	to a fixed size ||| itemsize	count=1
function	list of ||| tolist	count=1
function	the slice ||| slice	count=2
function_arg	and pads it with [function_1] [arg_2] ||| [function_1] [arg_2]	count=1
arg	from other to self ||| other method	count=1
function	take values according to ||| take	count=2
class	the dataset ||| series	count=1
class	guaranteed return of an ||| index	count=1
function	shift the ||| shift	count=2
function	to capture [function_2] ||| [function_2] [function_1]	count=4
function	try to parse ||| try convert data	count=2
function	lists to [function_2] ||| [function_1] [function_2]	count=1
arg	be table ||| value format	count=1
arg	that left and right ||| left right exact	count=1
arg	subtraction of two ||| other	count=1
function	cast ||| timestamp	count=1
arg	params args to ||| params	count=1
function	font object parameters ||| font	count=1
arg	a boolean if ||| a b	count=2
function	formats to a ||| to	count=1
function	try to cast ||| try cast	count=2
module_class	the categorical to ||| core categorical	count=2
class	series we by ||| series group by	count=1
function_arg	convert [arg_2] ||| [function_1] to protection [arg_2]	count=1
function	for our index type ||| index	count=1
class	and return ||| chain	count=1
class	be ||| parser	count=1
module	make new [module] with passed ||| [module]	count=1
arg	datetime ||| freq	count=1
module	simple cross-tabulation ||| core reshape	count=1
function_arg	value for [arg_2] ||| [function_1] [arg_2]	count=6
function_arg	[function_1] result ||| [function_1] to dtypes [arg_2] dtypes	count=3
module	compute the ||| core	count=2
class	them as a block ||| block	count=2
function	re-evaluate the obj ||| and	count=1
module	series ||| core	count=1
function	the expected [function_2] ||| [function_2] [function_1]	count=2
function	mixed [function_2] ||| [function_1] [function_2]	count=1
arg	arrays vs scalar string-likes ||| a b	count=1
function	return true if this ||| is in	count=1
function_arg	[function_1] data ||| [function_1] cls [arg_2]	count=4
class	that can be ||| frame	count=1
module	sparse/dense and dtype) in ||| core	count=1
function	in ||| in	count=2
function	concatenation ||| concat sparse	count=1
arg	left and right ||| left right check_exact check_dtype	count=1
function	a datetimelike ||| datetime	count=1
arg	cartesian product of ||| labels shape sort	count=1
function	[function_1] kwargs ||| [function_1] style [function_2]	count=1
function_arg	[function_1] type ||| [arg_2] [function_1]	count=5
module	packed bytes see :class ||| msgpack	count=1
class	of datetime time the ||| datetime	count=1
function	list of lists ||| matrix	count=1
class	underlying data ||| range index	count=1
function	perform merge ||| merge	count=1
function	the len of myself ||| size	count=1
module	handling as ||| core indexes	count=1
module	with times to ||| indexes	count=1
function	the passed type is ||| is	count=3
module	underlying ||| core	count=2
function	be ||| build	count=1
function	valid for ||| valid dtype	count=1
function_arg	op result [arg_2] ||| [function_1] [arg_2]	count=2
arg	and ||| key	count=1
function	cartesian product ||| product	count=1
arg	t or tuple of ||| t	count=1
arg	a particular axis parameters ||| axis	count=2
function	round the ||| round	count=1
function_arg	[function_1] [arg_2] dtype ||| [function_1] [arg_2]	count=2
module	return a ||| core	count=2
arg	in ||| key value format	count=1
module	these with [module] ||| [module]	count=1
function	i am a non-datelike ||| datelike	count=1
module	i ||| core	count=1
function	a latex ||| latex	count=1
arg	the arg ||| arg errors	count=1
arg	to class python ||| cls name	count=1
function	all the locales that ||| locales	count=1
arg	compute a simple cross-tabulation ||| index columns	count=1
class	series to ||| series	count=2
class	index value ||| datetime index ops	count=2
arg	dates ||| dates	count=1
arg	b ||| a b	count=1
function	iterator over ||| iter	count=1
arg	equivalent to left ||| left	count=1
module	array object has ||| dtypes	count=1
class	tree-like ||| html frame	count=1
function_arg	a [function_1] [arg_2] ||| [function_1] [arg_2]	count=2
class	a tree-like object that ||| frame parser	count=1
class	the underlying array ||| index ops mixin	count=1
function	datetime [function_2] ||| [function_1] [function_2]	count=5
class	the underlying data ||| index	count=2
function	have a null ||| null	count=1
function	return a [function_2] ||| [function_1] [function_2]	count=2
function	class constructor ||| constructor	count=1
function	numeric [function_2] ||| [function_1] [function_2]	count=1
arg	provide ||| typs	count=1
function	convert a ||| convert	count=3
arg	cross-tabulation ||| index columns values	count=1
arg	offset ||| offset	count=1
function	if ||| validate	count=1
arg	subclasses of superclass ||| superclass	count=1
function	class for writing stata ||| stata	count=1
class	and ||| hdfstore	count=1
arg	input function ||| axis copy	count=1
module	a ||| indexes	count=3
function	highlight [function_2] ||| [function_1] [function_2]	count=3
function	as ||| wrap	count=1
module	the expression that is ||| core computation	count=1
arg	be ||| format	count=1
function	group [function_2] ||| [function_2] [function_1]	count=1
module	by default ||| formats	count=1
class	to ||| parser	count=1
module	return ||| core computation	count=1
class	element ||| ndframe	count=1
function	or list of lists ||| matrix	count=1
arg	column by inferring dtype ||| data use_dtypes convert_dates	count=1
class	keyerror is ||| map	count=1
function	styled html representation fo ||| style	count=1
function_arg	[function_1] [arg_2] ||| [function_1] values [arg_2]	count=13
function	want to ||| array	count=1
function	series/index to be formatted ||| str	count=1
class	list ||| list	count=1
function	masked rec [function_2] ||| [function_1] [function_2]	count=5
function	[function] leveraging ||| parse [function]	count=1
function_arg	shift the [arg_2] ||| [arg_2] [function_1]	count=3
arg	and b ||| a b raise_on_error	count=1
function	accessor methods ||| accessors	count=1
function_arg	[function_1] nan/nat from ||| [function_1] [arg_2]	count=4
function	a scalar [function_2] ||| [function_1] [function_2]	count=6
function	like to compare ||| like	count=1
function_arg	[function_1] indexer like ||| [arg_2] [function_1]	count=1
arg	node must already ||| key value	count=1
function	series/index by the given ||| str	count=1
function	is our asof ||| asof	count=1
function	append rows ||| append	count=1
function	locales ||| locales	count=1
function	function of type ||| is type	count=1
function	string cast it to ||| cast	count=1
arg	and right ||| right exact check_names	count=1
module	in [module] ||| [module]	count=2
function	to iterate over the ||| build	count=1
module	from 1-dimensional ndarray ||| core	count=1
arg	node must already ||| value format	count=1
module	only use this ||| core	count=1
function	to determine if ||| dtype n method	count=1
class	object that can ||| html frame parser	count=1
function	[function_1] sparseseries or ||| [function_1] [function_2]	count=1
function	the gradientfill stop ||| stop	count=1
function_arg	execute [arg_2] ||| io [function_1] [arg_2]	count=1
class	can ||| html frame parser	count=2
function	a table reflecting ||| table setup	count=2
function	and ||| args	count=1
module	elements in the ||| core	count=1
arg	specified [arg] note ||| [arg] optlevel	count=1
module	to midnight ||| core	count=1
arg	checks if key is ||| key	count=1
module	more ||| core	count=1
arg	values of columns ||| columns keep	count=2
function	the 'numpy' library the ||| validate take with convert	count=1
module	must already ||| io	count=1
class	for table ||| table	count=1
module_class	[module_1] panel ||| [module_1] [class_2]	count=12
arg	for this argument ||| arg	count=1
function	in a block ||| block	count=1
function	full [function_2] ||| [function_2] [function_1]	count=1
arg	value inplace return ||| value mgr	count=1
arg	write records stored in ||| name if_exists index	count=2
arg	n between self ||| n	count=1
function	iterate over the dom ||| build doc	count=1
arg	[arg] as specified ||| [arg] kwargs	count=1
module	series columns for ||| core	count=1
function	ndarray only ||| set	count=1
module_class	[module_1] values ||| [module_1] sparse [class_2]	count=1
class	whether each index ||| index	count=1
arg	axis ||| axis method	count=1
function	period ||| period	count=1
class	used to iterate ||| parser	count=1
arg	of [arg_2] ||| [arg_2] [arg_1]	count=8
function	[function_1] given ||| [function_2] freq [function_1]	count=3
function	feather-format ||| read feather	count=1
function	join indexers ||| join indexers	count=4
function	a boolean ||| is	count=1
arg	compatiable fill_value [arg_2] ||| [arg_2] [arg_1]	count=4
function	quickly set [function] item major ||| set [function]	count=1
module	up ||| io formats	count=2
arg	the function ||| func mgr	count=1
function	beginning of ||| beg	count=1
arg	key and are ||| key	count=1
function	validates that we have ||| validate ordered	count=1
module_class	values of [class_2] ||| [module_1] [class_2]	count=2
function	a view of myself ||| view	count=1
class	pointer ||| index ops mixin	count=1
function	take which ||| take nd	count=1
arg	and ||| name args	count=1
module	a simple cross-tabulation ||| reshape	count=1
function	[function_1] cast ||| [function_2] [function_1]	count=1
class	database ||| database	count=1
function	exist and ||| append	count=1
function	path ||| path	count=1
function	[function_1] [function_2] ||| [function_1] timeseries [function_2]	count=9
function	from sif to ||| to	count=1
function	and create [function_2] ||| [function_1] [function_2]	count=1
arg	of arr1 [arg_2] ||| [arg_1] [arg_2]	count=3
arg	i ||| cls i	count=1
function_arg	[function_1] dataframe ||| [arg_2] [function_1]	count=1
arg	data from ||| cls data	count=2
arg	item at [arg_2] ||| [arg_2] [arg_1]	count=1
module_class	return the i-th [module_1] [class_2] by location ||| [module_1] [class_2] ixs i axis	count=1
arg	target time zone ||| tz axis	count=1
function	a sequence of ||| sequence	count=1
module	from 1-dimensional ndarray only ||| core	count=1
module	exist ||| io	count=1
arg	this if you ||| arr	count=1
function	sets index names ||| set default names	count=1
arg	to target time zone ||| tz axis	count=1
arg	1-dimensional ndarray only use ||| arr key	count=1
arg	unit if needed ||| unit tz	count=1
function	compat na value parameters ||| na value for	count=1
function	the 'numpy' library ||| validate argmin with	count=1
module	make new [module] inserting new ||| [module]	count=1
function	[function_1] [function_2] using fixed strptime formats ||| [function_1] [function_2] arg format infer_time_format errors	count=3
arg	the _apply kwargs ||| window center	count=1
function_arg	[function_1] array ||| [arg_2] [function_1]	count=4
arg	ndarray only use ||| key	count=1
arg	resolution ||| reso	count=1
arg	be ||| new align inplace	count=1
class	i am an ||| index	count=1
arg	the value inplace return ||| value	count=1
class	to iterate ||| frame parser	count=1
arg	regular expression [arg_2] ||| [arg_2] [arg_1]	count=4
arg	for this key ||| key	count=1
class	interval in the index ||| interval index	count=1
class	needs additional handling ||| period	count=1
function	interpolate values ||| interpolate	count=1
function	convert string-like and string-like ||| string	count=1
arg	particular axis [arg_2] ||| [arg_1] [arg_2]	count=2
function	[function] other ||| [function]	count=1
arg	indexer input array ||| indexer	count=1
function_arg	[function_1] color_spec ||| [arg_2] [function_1]	count=1
class	return the actual ||| bin op	count=1
class	index or ndarray ||| datetime index	count=1
function	create an ||| create indexer	count=1
arg	of terms ||| terms	count=2
function	sif to datetime ||| elapsed date to datetime	count=1
class	tree-like object ||| html frame	count=1
function	header ||| header	count=1
function	string-like array to convert ||| convert string to	count=1
arg	an ndarray copy ||| dtype copy	count=1
function_arg	casting [arg_2] ||| [function_1] [arg_2]	count=4
arg	using indicated encoding ||| encoding errors	count=2
function	assemble ||| assemble	count=1
function	object to ||| to	count=2
function	is a named tuple ||| is named tuple	count=1
module	midnight ||| core	count=1
module	gets called after ||| core indexes	count=2
module_class	[module_1] stata ||| [module_1] [class_2]	count=3
arg	blocks collect and create ||| axis consolidate transposed	count=1
function	interpolate values according ||| interpolate	count=1
function	packer for ||| packb	count=1
class	to its values attribute ||| series	count=1
arg	the left [arg_2] ||| [arg_2] [arg_1]	count=1
arg	a simple ||| index	count=1
class	index ||| interval index	count=1
function	a manipulation result has ||| constructor	count=1
function_arg	exception [arg_2] ||| [arg_2] [function_1]	count=3
function	[function_1] values ||| [function_2] [function_1]	count=1
function	symmetric difference of ||| symmetric difference	count=2
arg	scalar data ||| data	count=1
module	needs additional handling ||| core indexes	count=1
arg	nan/nat ||| val	count=1
class	array of python datetime ||| datetime index	count=1
arg	to a fixed size ||| encoding itemsize	count=1
function_arg	template and [arg_2] ||| [arg_2] [function_1]	count=1
arg	render ||| buf columns col_space header	count=1
class	values ||| array	count=1
function	[function_1] this level ||| [function_2] [function_1]	count=2
class	from 1-dimensional ||| index	count=1
arg	to ||| value	count=1
module	to ||| formats	count=1
class	index or ndarray ||| datetime index ops	count=1
function	in file node must ||| append	count=1
function	specialized intersection for ||| intersection	count=1
class	never a ||| block	count=1
arg	of v should ||| v	count=1
function	infer types of ||| infer types	count=1
function	[function_1] file-like ||| [function_2] [function_1]	count=1
function	metadata ||| metadata	count=2
class	index or ndarray filled ||| index ops mixin	count=1
module	deleting the ||| io	count=1
function_arg	[function_1] same ||| [arg_2] [function_1]	count=2
arg	[arg_1] selected position ||| [arg_2] [arg_1]	count=1
function	bounds for ||| bounds	count=1
class	after ||| period index	count=2
function	timezone ||| timezone	count=1
arg	a dataframe ||| data values index	count=1
arg	query in [arg_2] ||| [arg_2] [arg_1]	count=2
class	xlwt ||| xlwt writer	count=2
class	are a series we ||| series	count=1
function_arg	other [arg_2] ||| [arg_2] [function_1]	count=1
function	instances of all ||| all	count=1
function	return result as block ||| getitem block	count=1
arg	[arg_1] is ||| [arg_2] [arg_1]	count=1
class	interval in ||| interval	count=1
function_arg	difference of [arg_2] ||| [arg_2] [function_1]	count=1
function	[function] define ||| [function] cython	count=1
arg	bins to which ||| bins	count=1
arg	packed object ||| packed object_hook list_hook use_list	count=1
function	a ||| build	count=1
arg	simple cross-tabulation ||| columns values	count=1
function	manager ||| mgr	count=1
module_class	putmask the data to [module_1] [class_2] ||| [module_1] [class_2] putmask mask	count=3
arg	values uses ||| values	count=1
function	parser based on the ||| parser	count=1
function_arg	[function_1] i with ||| [function_1] [arg_2]	count=1
function	for a recursive ||| recursive	count=1
function_arg	casting [arg_2] ||| [arg_2] [function_1]	count=5
function_arg	of subplots [arg_2] ||| [arg_2] [function_1]	count=1
arg	to target time zone ||| tz axis level	count=1
arg	values along [arg_2] ||| [arg_1] [arg_2]	count=1
module_class	[module_1] [class_2] ||| [module_1] [class_2]	count=178
function	generator ||| generator	count=2
arg	times ||| arr repeats	count=1
function	datetimelike ||| to datetimelike	count=2
module	over the ||| io	count=1
class	data ||| multi	count=1
arg	the value ||| value mgr	count=1
function_arg	[function_1] dtype of ||| [arg_2] [function_1]	count=2
function	is dict-like ||| is dict like	count=2
function	alias to closest period ||| get period alias	count=1
arg	run the ||| num_threads kwargs_list	count=1
class	remove ||| map	count=1
class	return datetimeindex with ||| index	count=1
function	datetime ||| datetime	count=3
function	float is formatted ||| eng float	count=1
arg	table ||| arr table	count=1
arg	array return an ||| vals	count=1
module	an object ||| dtypes	count=1
function	if you ||| value	count=1
function	timedelta-like to timedelta64 ||| td index	count=1
arg	half-open [arg_1] [arg_2] belongs ||| reshape cut [arg_2] [arg_1] right labels	count=2
arg	key [arg_2] ||| io table write metadata [arg_1] [arg_2]	count=1
arg	category value returning ||| inplace ascending na_position	count=1
class	of the timedeltas ||| timedelta index	count=1
function	function for [function_2] ||| [function_1] [function_2]	count=3
arg	ensure incoming data ||| data	count=1
module	an expression ||| computation	count=1
class	of a series ||| series	count=1
class	be used ||| frame parser	count=1
function	additional ||| array wrap	count=2
arg	values according to indexer ||| indexer	count=2
class	record ||| data col	count=1
module	from 1-dimensional ||| core indexes	count=1
function	decode character ||| decode	count=1
function	from a ||| from	count=5
class	of sparse/dense ||| ndframe	count=1
function	to ||| to index	count=2
arg	label is not ||| label	count=1
function	is a sequence of ||| is sequence	count=1
function	environment table you ||| latex	count=1
function	take the ||| take nd	count=1
class	number ||| multi index	count=1
module	from 1-dimensional ||| core	count=1
arg	the writer's supported extensions ||| ext	count=1
function	timedelta-like ||| td index cmp	count=2
class	remove and return ||| chain map	count=1
arg	[arg_1] right ||| [arg_1] [arg_2]	count=19
arg	converts a style_dict ||| style_dict num_format_str	count=2
class	return index ||| index ops	count=1
function	[function_1] the manager ||| [function_1] [function_2]	count=7
arg	whether 'kwargs' ||| kwargs compat_args	count=1
function	prior to ||| prepare	count=1
module	want to take the ||| core	count=1
function	try ||| try	count=1
class	i ||| categorical block	count=2
function	a repr ||| repr	count=1
arg	ndarray or ||| data index	count=1
arg	to table in ||| format	count=1
function_arg	the type [arg_2] ||| [function_1] [arg_2]	count=1
arg	lookup of ||| key	count=1
module	you ||| core indexes	count=2
class	index or ndarray ||| index	count=1
function	index to ||| index	count=2
arg	[arg_1] convert dataframe ||| [arg_2] [arg_1]	count=2
function	*this is ||| is	count=1
function	validate that we ||| validate	count=1
function	the boolean criterion specified ||| filter	count=2
class	index objects contain ||| range index	count=1
arg	if you ||| key	count=1
arg	function to ||| func	count=3
arg	coerce to the new ||| copy errors	count=2
class	iterate ||| html	count=1
function	dictionary for the passed ||| axes dict from	count=1
arg	level j do not ||| j	count=1
module_class	convert the object ||| core ndframe	count=1
arg	with ||| join	count=1
class	data for this ||| data col	count=1
function	indexer return ||| indexer	count=1
module	columns for ||| core	count=1
arg	return the corresponding interval ||| interval	count=1
function_arg	[function_1] [arg_2] object ||| io [function_1] [arg_2]	count=1
function_arg	[function_1] a style_dict ||| [arg_2] [function_1]	count=1
class	return a tree-like ||| frame parser	count=1
function	numpy doesn't like ||| string like	count=1
function	given an interval ||| get interval	count=1
arg	location in ||| loc	count=1
function	return ||| get values	count=1
function	safe version of putmask ||| putmask	count=1
function	category labels deprecated ||| labels	count=1
function_arg	iter1 [arg_2] ||| [arg_2] [function_1]	count=3
class	that ||| frame	count=1
function	overlap add ||| items overlap	count=1
class	underlying data ||| multi index	count=1
module	return indices of ||| core	count=1
arg	against ||| cls	count=3
function_arg	[function_1] [arg_2] ||| [function_1] vals [arg_2]	count=2
function	stride ||| get stride	count=1
function	pandas type to ||| table type	count=1
module	[module_1] expression that ||| [module_1] [module_2] bin op convert value	count=1
function	[function_1] locale ||| [function_1] [function_2]	count=3
arg	correct dtype ||| data sparse_index fill_value	count=1
class	a categorical ||| categorical index	count=1
arg	target time zone ||| tz	count=1
function_arg	index row [arg_2] ||| [arg_2] [function_1]	count=4
arg	new type ||| dtype copy errors values	count=2
class	return ||| frame	count=1
arg	fast lookup of value ||| value	count=1
function	packer for options ||| packb	count=1
arg	possible reshape [arg] ||| [arg]	count=3
function	value ||| value	count=6
class	is ||| index	count=1
arg	level j ||| j	count=1
function	the unit ||| unit	count=1
arg	left and right data ||| left right vertical	count=1
module	up styles to ||| io	count=1
module	[module_1] index ||| [module_1] [module_2]	count=8
function	update ||| maybe update	count=3
arg	sas7bdat [arg] ||| filepath_or_buffer [arg]	count=1
module	a ||| core	count=10
class	of this frame ||| data frame	count=1
function	style and ||| style	count=1
function	create an ||| create	count=1
class	iterate over the ||| frame	count=1
function_arg	subplots [arg_2] ||| [function_1] [arg_2]	count=1
arg	other to the ||| other	count=1
arg	dtype ||| dtype errors	count=1
function	timedelta-like ||| td index	count=1
module	bytes see :class packer ||| io msgpack	count=1
arg	the corresponding interval ||| interval	count=1
arg	if key ||| key	count=1
class	underlying data ||| index ops mixin	count=5
module	compute a simple cross-tabulation ||| core	count=1
arg	we have a ||| name freq	count=1
class	individual [class] series ||| [class] frame	count=1
function	[function_1] and ||| [function_1] [function_2]	count=8
function_arg	[function_1] y if ||| [arg_2] [function_1]	count=2
function	apply [function_2] ||| [function_2] [function_1]	count=2
module	styles to html ||| formats	count=1
module	:class packer for options ||| io msgpack	count=1
arg	do a ||| src_list dest_list	count=1
function_arg	[function_1] data ||| [function_1] [arg_2]	count=5
class	to the underlying array ||| index ops mixin	count=1
function	write this ||| write	count=2
class	with times to ||| datetime index	count=1
arg	the result will respect ||| ascending sort_remaining	count=1
function	string cast it ||| cast	count=1
function	length of ||| length of	count=2
function	create a table ||| table	count=1
class	object that can be ||| html	count=1
arg	table in file ||| value format	count=1
arg	dataframe the ||| data values index columns	count=1
module	packer for ||| io msgpack	count=1
arg	use this ||| key	count=1
function	re-evaluate ||| and	count=1
function	lists to ||| convert to	count=1
module	[module_1] expression that ||| [module_1] [module_2]	count=1
arg	an expression [arg_2] ||| [arg_2] [arg_1]	count=4
function	must already exist ||| append	count=1
arg	a provided encoding ||| fh encoding compat is_verbose	count=1
function_arg	types of values ||| types values	count=2
class	datetime ||| datetime index	count=3
arg	'kwargs' ||| kwargs	count=3
function	to make a repr ||| repr	count=1
module	gets called after ||| core	count=3
class	after a ||| period	count=1
module	necessary ||| core sparse	count=2
function	wrap long ||| wrap	count=1
module	the underlying data ||| core indexes	count=2
arg	the values to be ||| values	count=1
arg	[arg] present ||| [arg]	count=3
arg	value inplace return ||| value	count=1
arg	the table this is ||| key	count=1
function_arg	[function_1] into ||| [function_1] table_name con schema [arg_2]	count=1
module	iterate ||| io	count=1
function	function for series ||| arith method series	count=2
module_class	this [class_2] ||| [module_1] interval [class_2]	count=1
arg	to have correct dtype ||| name data sparse_index fill_value	count=1
arg	writer's supported extensions ||| ext	count=1
function_arg	[function_1] statement ||| [arg_2] [function_1]	count=3
arg	compute ||| index columns values	count=1
arg	in file node must ||| format	count=1
class	as ||| index	count=1
arg	cross-tabulation of ||| index columns values	count=1
arg	self f skipping as ||| n skiprows	count=1
function	for ordered data ||| ordered	count=1
function	closed [function_2] ||| [function_2] [function_1]	count=1
function	take a string-like that ||| convert string array	count=1
arg	op on [arg_2] ||| [arg_1] [arg_2]	count=3
function	[function_1] dense ||| [function_2] [function_1]	count=2
arg	axis equal ||| axis	count=1
arg	obj [arg_2] ||| [arg_2] [arg_1]	count=1
function	gets called prior to ||| array prepare	count=1
module	already exist and ||| io	count=1
arg	unit if ||| unit	count=1
function	get ||| get index	count=1
function_arg	[function_1] among the ||| [function_1] [arg_2]	count=1
function	wrapper function for series ||| bool method series	count=1
class	already ||| hdfstore	count=1
arg	be a single ||| new align inplace	count=1
class	return ||| html	count=1
function	to ||| convert data	count=2
function	index ||| index	count=10
arg	half-open [arg_1] [arg_2] belongs ||| [arg_2] [arg_1]	count=2
function	a string format ||| format datetime64 from	count=1
function	get test [function_2] ||| [function_2] [function_1]	count=4
function	that create [function_2] ||| [function_1] [function_2]	count=5
arg	exist and be ||| key	count=1
function	get the ||| get	count=2
function	indexer ||| setitem indexer	count=1
function	coerce a string ||| coerce	count=1
module	xport ||| io sas	count=1
function	bytes ||| packb	count=1
function	convert [function_2] ||| [function_1] string to [function_2]	count=2
class	the float ||| float	count=1
arg	a distance ||| dmin dmax	count=1
function	[function_1] key ||| [function_1] [function_2]	count=4
function	to a scipy ||| to	count=1
class	1-dimensional ||| index	count=1
function	groupby ||| groupby	count=3
arg	by the indexer ||| indexer allow_fill	count=1
function	numeric operations ||| numeric operations	count=2
module	cross-tabulation ||| core reshape	count=2
class	with [class_2] ||| [class_2] [class_1]	count=2
module	built up styles to ||| io	count=1
class	datetime date ||| datetime	count=1
module_class	[module_1] data are ||| [module_1] [class_2]	count=8
arg	[arg_1] b ||| [arg_1] [arg_2]	count=3
function	to ||| datetime to	count=1
class	[class_1] for groupby ||| [class_1] [class_2]	count=1
function	a multirow ||| multirow	count=1
function	radviz ||| radviz	count=1
arg	other axis ||| axis	count=1
function	we have a ||| is	count=2
function	a string representation for ||| unicode	count=1
function	1-dimensional ||| value	count=1
class	the ||| html frame	count=1
class	i am never ||| block	count=1
module	1-dimensional ndarray ||| core	count=1
arg	[arg] data rows/cols ||| nrows [arg] c_idx_names	count=1
function_arg	[function_1] the function ||| [function_1] [arg_2]	count=1
function	the object are unique ||| unique	count=1
arg	node must already exist ||| key	count=1
arg	on 3 columns of ||| columns	count=1
arg	ndarray copy if ||| index dtype copy	count=1
class	object that can ||| parser	count=1
module	code ||| tseries	count=3
function	stata date formats to ||| to stata	count=1
function	convert ||| maybe convert	count=1
arg	copy if specified coerce ||| index dtype copy	count=1
function_arg	[function_1] and expected ||| [arg_2] [function_1]	count=4
module	for ||| io	count=1
function_arg	[function_1] labels using ||| [arg_2] [function_1]	count=1
function	as ||| array wrap	count=2
function	[function_1] axis ||| [function_1] [function_2]	count=1
arg	of regular expression pat ||| pat flags expand	count=1
arg	ndarray only ||| key	count=1
class	python datetime ||| datetime index	count=1
function_arg	values [arg_2] ||| [function_1] values [arg_2]	count=2
class	with times to midnight ||| datetime	count=1
function	the 'numpy' library the ||| with	count=1
class	pointer ||| ops mixin	count=1
arg	[arg_1] each string ||| [arg_2] [arg_1]	count=2
function	string-like [function_2] ||| [function_2] [function_1]	count=1
function	categorical if not ||| categorical	count=1
arg	a ||| cls	count=1
function	to datetime ||| date to datetime	count=1
arg	in file ||| value	count=1
function	return an ||| get	count=1
arg	of ||| columns	count=1
function	is [function_2] ||| [function_2] [function_1]	count=14
function	in comparison methods ||| comparison methods	count=1
function	if any axis is ||| is	count=1
arg	node ||| format	count=1
module_class	[module_1] this categorical ||| [module_1] [class_2]	count=6
class	that can be used ||| html frame parser	count=1
arg	a string raise ||| string	count=2
function	validates that we have ||| ordered	count=1
function	asof ||| asof	count=2
function	copy of the ||| copy	count=2
function	offset/observance to a datetimeindex ||| rule	count=1
function	specified categories ||| categories	count=1
arg	[arg_1] and right ||| [arg_2] [arg_1]	count=17
module	in this ||| core	count=1
function	[function_1] block ||| [function_2] [function_1]	count=1
class	index ||| range index	count=4
class	that ||| html frame parser	count=2
arg	columns using [arg_2] ||| [arg_2] [arg_1]	count=6
class	render ||| formatter	count=2
class	exist and be ||| hdfstore	count=1
function	timedelta-like to ||| td	count=1
arg	[arg_1] style_dict ||| [arg_2] [arg_1]	count=2
class	over the ||| frame	count=1
class	length is ||| datetime	count=1
function	registered [function_2] ||| [function_2] [function_1]	count=1
arg	b ||| b	count=1
class	its values attribute if ||| series	count=1
function	post process ||| post	count=1
arg	block by periods ||| periods axis mgr	count=3
function	dates ||| dates	count=1
function_arg	[function_1] ndarray or ||| [arg_2] [function_1]	count=1
arg	panel-like dataframe ||| time panels names	count=1
arg	the same ||| other	count=1
arg	'kwargs' should be empty ||| kwargs	count=2
function	mixed ||| mixed	count=1
arg	simple cross-tabulation of ||| columns	count=1
function	level ||| has level	count=1
class	excluding ||| group	count=1
arg	already exist and be ||| key value format	count=1
class	i am never a ||| block	count=1
module	from 1-dimensional ndarray only ||| core indexes	count=1
arg	decimal places ||| decimals	count=1
module	data ||| core indexes	count=4
arg	evaluate or raise typeerror ||| opstr	count=1
class	of each group ||| group by	count=2
function_arg	apply the [arg_2] ||| [arg_2] [function_1]	count=4
function	the base ||| base	count=1
arg	particular axis with ||| axis join	count=2
module_class	[module_1] from ||| [module_1] [class_2]	count=1
module	we have a ||| core	count=1
module	index for series ||| core	count=1
function	of kwargs suitable ||| kwargs	count=1
arg	simple ||| index	count=1
function	for ||| comp method	count=1
arg	i with level j ||| i j	count=1
function	names to 'index' for ||| set default names	count=1
module	packer ||| io	count=1
arg	for :meth ||| inplace	count=2
arg	into ||| index_col coerce_float	count=1
function	of columns as lists ||| str columns	count=1
function	is datetimelike ||| datetimelike	count=1
function_arg	[function_1] function to ||| [function_1] [arg_2]	count=1
class	the underlying array ||| datetime index ops mixin	count=1
arg	ufunc needs additional ||| context	count=1
function	add in numeric methods ||| add numeric methods binary	count=1
function_arg	with decimal [arg_2] ||| [function_1] [arg_2]	count=4
function	validates that we ||| validate	count=1
arg	arr ||| arr new_shape	count=1
arg	generic moving [arg_2] ||| [arg_1] [arg_2]	count=1
function	return the values ||| get values	count=3
function	[function_1] are equal ||| [function_2] [function_1]	count=3
arg	to table ||| value format	count=1
arg	table ||| value format	count=2
class	insert ||| block manager	count=1
function	datetime string ||| string	count=1
arg	and 'kwargs' should ||| name args kwargs	count=2
arg	key is a ||| key	count=1
function	[function_1] unicode strings ||| [function_2] [function_1]	count=2
function	float is ||| eng float	count=1
function	return the bool of ||| bool	count=1
function	[function_1] convert ||| [function_2] [function_1]	count=10
class	use this if you ||| index	count=1
function	[function_1] a number ||| [function_2] [function_1]	count=1
arg	the left ||| left	count=1
function	a registered option ||| get registered option	count=2
module	packer for options ||| msgpack	count=1
class	[class_1] excluding elements ||| [class_2] [class_1]	count=4
function	coerce a ||| coerce	count=2
module	number of ||| core	count=2
module	for ||| core	count=7
class	we ||| categorical	count=1
arg	key is ||| key	count=1
arg	a compatiable fill_value and ||| fill_value	count=1
module	for more this ||| core	count=1
function	[function_1] our native ||| [function_2] [function_1]	count=3
class	never ||| categorical block	count=2
function	[function_1] [function_2] ||| [function_2] concatenation [function_1]	count=1
class	a new categorical ||| categorical	count=1
module	node must already ||| io	count=1
arg	validates that ||| cls	count=1
class	into a ||| parser	count=2
function	to parse a ||| convert data	count=1
function	'numpy' library the third ||| validate take with convert	count=1
class	of the underlying data ||| index ops mixin	count=1
module	is ||| core	count=2
class	an ||| index	count=7
module	ndarray ||| core	count=1
arg	a higher freq ||| cls value freq	count=2
arg	value ||| key value	count=1
class	return the number of ||| range index	count=1
class	used to iterate ||| frame	count=1
function	shape ||| shape	count=2
arg	a sparseseries ||| a	count=1
arg	values can be any ||| values name	count=1
arg	of periods ||| periods	count=1
arg	[arg_1] n between ||| [arg_2] [arg_1]	count=4
function	apply we are stripping ||| apply	count=1
function	over ||| build	count=1
class	set ||| cparser wrapper	count=1
arg	exist and be table ||| value format	count=1
function	we have a full ||| is full	count=1
function	return the len ||| size	count=1
function	matches the expected ||| matches	count=1
function	group of [function_2] ||| [function_2] [function_1]	count=1
class	return a version ||| block	count=1
function	dtype possible ||| dtype	count=1
function	the dom ||| build doc	count=1
arg	ndarray ||| index	count=1
class	a frame table ||| table	count=2
arg	floating point [arg] nans and ||| [arg]	count=1
function	our binners ||| set binner	count=1
function	return a prettier version ||| get pretty string	count=1
function	valid [function_2] ||| [function_1] [function_2]	count=1
function	if two indices overlap ||| overlap	count=1
function	representing a frequency ||| freq	count=1
function	axis to the block_manager ||| get block manager	count=1
function	all values found in ||| transform	count=1
arg	only use this if ||| arr key	count=1
arg	regular expression ||| flags expand	count=1
function_arg	a locale [arg_2] ||| [function_1] [arg_2]	count=1
function	description ||| description	count=1
arg	given sql ||| sql	count=1
function	to line ||| to line	count=1
function	of all the ||| all	count=1
arg	arr to have shape ||| arr new_shape	count=1
function	node [function_2] ||| [function_2] [function_1]	count=4
module_class	the data ||| core data frame	count=1
arg	values values ||| values	count=1
function	the display [function_2] ||| [function_1] [function_2]	count=4
arg	type ||| dtype	count=4
function_arg	align a [arg_2] ||| [arg_2] [function_1]	count=1
class	engineering notation ||| eng formatter	count=1
function	if ||| ordered	count=1
class	dataframe to a ||| data frame	count=1
arg	of value ||| key value	count=1
function	wrapper function for series ||| method series	count=3
function_arg	str [arg_2] ||| [function_1] [arg_2]	count=1
function_arg	[function_1] tabular ||| [function_1] latex [arg_2]	count=1
class	float ||| float array	count=1
class	[class_1] value is ||| [class_2] [class_1]	count=4
function	sql ||| sql	count=2
function	convert :mod datetime to ||| dt to	count=1
arg	v should ||| v	count=1
module_class	calculate [class_2] ||| [module_1] [class_2]	count=2
function	construct and [function_2] ||| [function_1] [function_2]	count=3
function	capture ||| capture	count=1
class	provided date forward to ||| date	count=1
arg	allows a decorator to ||| decorator	count=1
module	is ||| core indexes	count=3
function	compute ||| crosstab	count=1
arg	by category value returning ||| ascending na_position	count=1
module	we ||| core	count=1
function	moving window ||| window	count=1
function	bytes see :class ||| packb	count=1
function	take optional positional and ||| optional args	count=1
module	if the object is ||| core dtypes	count=1
function	apply the ||| apply index days	count=1
arg	sql and ||| sql	count=1
function_arg	custom template [arg_2] ||| [arg_2] [function_1]	count=1
arg	input function or ||| mapper axis copy	count=1
module	[module_1] the ||| [module_1] [module_2]	count=1
function	counts of [function_2] ||| [function_2] [function_1]	count=8
arg	pack object o and ||| o	count=1
module	to iterate ||| io	count=1
class	that the exception raised ||| assert raises	count=1
function	apply we are ||| apply	count=1
module	[module] series/index with ||| [module]	count=3
function	fast version ||| fast	count=1
class	return ||| merge operation	count=1
function	object invoked by str ||| str	count=1
function	slice/take blocks ||| take blocks	count=1
function	that we have a ||| is	count=1
function	[function_1] categorical ||| [function_2] [function_1]	count=2
arg	from ndarray or ||| index columns dtype	count=1
function	numpy doesn't like to ||| like	count=1
module_class	return dataframe ||| core data frame	count=1
function	[function_1] html ||| [function_2] [function_1]	count=2
function	the given offset/observance to ||| rule	count=1
function	index ||| almost	count=1
function_arg	difference [arg_2] ||| [arg_2] [function_1]	count=1
module_class	of this data ||| core series	count=1
function_arg	[function_1] column ||| [function_1] [arg_2]	count=1
function	string representing a frequency ||| freq	count=1
function	setup the ||| set	count=1
module	:class ||| msgpack	count=1
class	return datetimeindex with times ||| datetime	count=1
class	data ||| range index	count=1
class	date forward ||| date	count=1
class	data ||| series	count=1
class	return ||| html frame parser	count=2
function	a sparse ||| sparse	count=2
function	elements [function] ||| coerce [function]	count=1
function	handle na filling of ||| fillable	count=2
arg	must ||| key	count=1
module	to midnight length is ||| indexes	count=1
arg	of the _apply kwargs ||| window center	count=1
function	to table ||| append	count=1
module	regular or 'level_x' ||| io json	count=1
class	tree-like object that can ||| html	count=1
class	fast lookup ||| index	count=1
function	return ||| get reso	count=2
function	concatenate block ||| concatenate block	count=2
class	to iterate ||| html frame	count=1
function	alias ||| alias	count=2
function	the process of casting ||| assert safe casting	count=1
module	with times to midnight ||| core	count=1
arg	column ||| col	count=3
module	handling as ||| indexes	count=1
function	determine ||| match	count=1
function	read csv ||| from csv	count=2
function_arg	coerce [arg_2] ||| [function_1] values [arg_2]	count=2
module	from 1-dimensional ||| indexes	count=1
function	leap ||| is leap	count=1
function	a tree-like ||| build	count=1
function	[function_1] template and ||| [function_2] [function_1]	count=2
function	a type ||| type	count=1
module	of ||| core reshape	count=2
arg	file node must ||| key value	count=1
module	the item of the ||| core	count=1
class	underlying data ||| series	count=2
module	[module_1] object ||| [module_1] [module_2] is nested list like	count=3
class	block and ||| block	count=1
function_arg	other [arg_2] ||| [function_1] other op [arg_2]	count=1
function	the symmetric ||| symmetric	count=1
arg	additional ||| result	count=1
function	csv ||| csv	count=2
function	[function_1] result and ||| [function_1] [function_2]	count=2
function_arg	string for [arg_2] ||| [arg_2] [function_1]	count=1
function	reset ||| reset	count=3
function	'numpy' library the ||| take with	count=1
module	i am never a ||| core	count=1
class	our ||| index resampler	count=1
arg	to indexer ||| indexer	count=2
function	convert freq with decimal ||| decimal	count=1
function	get test result ||| get test result	count=2
arg	from ndarray or ||| index columns	count=1
function	dataframe ||| dataframe	count=1
function_arg	categorical [arg_2] ||| [function_1] [arg_2]	count=2
arg	of v ||| v	count=1
arg	have good categories ||| categories fastpath	count=1
function	[function_1] operations ||| [function_1] [function_2]	count=2
function	construction ||| construction	count=1
class	used to ||| html frame parser	count=1
function	a list of ||| tolist	count=1
arg	fixed size ||| itemsize	count=1
function	sparseseries [function] ||| sparse series [function]	count=2
arg	expression ||| expr	count=2
class	property synonym for ||| ndframe	count=1
class	used to ||| frame	count=1
arg	python expression as a ||| expr	count=1
function	needs additional ||| wrap	count=1
module	bytes see :class packer ||| io	count=1
function_arg	[function_1] to ||| [function_1] [arg_2]	count=6
class	new index ||| index	count=1
arg	result as series or ||| axis	count=1
arg	right ||| right check_dtype	count=3
function	and return ||| get	count=1
function	key ||| key	count=1
arg	sample ||| other pairwise	count=1
class	html ||| styler	count=1
arg	frequency if ||| freq	count=1
function	build [function_2] ||| [function_2] [function_1]	count=2
function	sparse array ||| sparse array	count=2
module	object that can ||| io	count=1
arg	value inplace return a ||| value mgr	count=1
class	object ||| abstract	count=1
function	multiple times in parallel ||| parallel	count=1
class	index or ndarray filled ||| datetime index	count=1
arg	the [arg] ||| [arg] cur	count=1
function	frequency timedelta ||| timedelta	count=1
function	[function_1] to sif ||| [function_2] [function_1]	count=1
arg	to a left-join except ||| left right on left_on	count=1
function_arg	not in [arg_2] ||| [arg_2] [function_1]	count=4
arg	the columns ||| inplace	count=1
function	create and setup ||| set	count=1
arg	from other to ||| other	count=1
module	cartesian product [module] all ||| [module]	count=1
module	used to iterate ||| io	count=1
function	set a [function_2] ||| [function_1] [function_2]	count=1
function	stacked format as dataframe ||| frame	count=1
function	to capture stderr ||| capture stderr	count=2
module	the number ||| core indexes	count=2
class	result block from the ||| block	count=1
arg	[arg_1] arr dtype ||| [arg_2] [arg_1]	count=6
arg	removes ||| removals inplace	count=1
arg	values to be at ||| values ndim	count=1
arg	object with labels ||| labels	count=1
function	[function_1] mixed ||| [function_1] [function_2]	count=3
arg	a simple cross-tabulation ||| columns	count=1
function	try to ||| try	count=2
function_arg	option [arg_2] ||| [arg_2] [function_1]	count=1
arg	data to ||| data index dtype	count=1
module	for more this is ||| core	count=1
function_arg	[function_1] [arg_2] ||| [function_1] time [arg_2]	count=1
function	a valid ||| valid	count=1
module	parameter ||| core	count=1
arg	exist ||| key value	count=1
function	need to coerce ||| maybe coerce freq	count=1
class	this object ||| ndframe	count=1
arg	j ||| j	count=4
function_arg	[function_1] info from ||| [arg_2] [function_1]	count=2
function	create the ||| create	count=1
function	bytes see :class packer ||| packb	count=1
module	index with day ||| indexes	count=2
function	series extract groups ||| extract	count=2
function	an intervalindex from a ||| from	count=1
class	index ||| multi index	count=1
class	block return result block ||| block	count=2
arg	exist ||| value format	count=1
module	[module] series/index ||| [module]	count=3
function	all the ||| all	count=2
class	the ||| multi	count=2
module	lookup ||| indexes	count=1
arg	block ||| mgr	count=1
arg	[arg_1] indexers ||| [arg_1] [arg_2]	count=1
function	if the levels ||| levels	count=1
class	ndarray ||| index	count=5
arg	result ||| result	count=4
function	create the [function_2] ||| [function_2] [function_1]	count=1
module	function to create an ||| core computation	count=1
function	form the intersection ||| intersection	count=2
function	under the index ||| reset index	count=1
class	length ||| datetime index	count=1
module	objects parameters ||| indexes	count=1
arg	smallest ||| categories	count=1
arg	matches a regular expression ||| case flags	count=1
function_arg	writing stata [arg_2] ||| [arg_2] [function_1]	count=1
function_arg	[function_1] jinja environment ||| [function_1] [arg_2]	count=3
arg	node ||| node	count=1
function	and string-like [function_2] ||| [function_2] [function_1]	count=1
class	block it is ||| block	count=1
function	have ||| validate	count=1
class	multiindex ||| multi	count=5
module	built up styles ||| io formats	count=1
function	need to coerce ||| coerce	count=2
module	the background ||| io	count=1
function	utc [function] days ||| dt to [function]	count=1
arg	the key as ||| key values	count=1
class	to ||| hdfstore	count=1
class	series columns for ||| ndframe	count=1
function	zeros ||| zeros	count=1
function	new copy ||| copy	count=1
function	guess ||| guess	count=1
arg	left and [arg] have ||| left [arg]	count=1
function	code group ||| group	count=1
class	internal property property synonym ||| ndframe	count=1
arg	the new type ||| dtype copy errors values	count=2
arg	by inferring dtype ||| use_dtypes convert_dates	count=1
arg	the totally ordered ||| xnull	count=1
module_class	sparsearray [class_2] ||| [module_1] sparse [class_2]	count=3
module	compute a simple cross-tabulation ||| core reshape	count=1
function	the 'numpy' library ||| take with	count=1
arg	[arg_1] correct dtype ||| [arg_2] [arg_1]	count=1
module	of the values ||| core	count=1
arg	a dataframe the levels ||| data	count=1
function	validates ||| ordered	count=1
arg	by category value returning ||| inplace ascending na_position	count=1
function_arg	[function_1] dtype converting ||| [arg_2] [function_1]	count=2
arg	already exist ||| value format	count=1
class	sort multiindex at the ||| multi	count=1
function	timedelta-like ||| td	count=1
module	use this ||| indexes	count=1
function	[function_1] function for ||| [function_1] [function_2]	count=4
function_arg	[function_1] dtype ||| [function_1] [arg_2]	count=7
class	for series columns ||| ndframe	count=1
function	have a ||| validate ordered	count=1
function	return a ||| get values	count=1
function	feather-format ||| feather	count=2
arg	and 'kwargs' should ||| method args kwargs	count=2
function	scipy interpolate ||| interpolate scipy	count=2
class	[class_1] excluding ||| [class_2] [class_1]	count=6
function	add in numeric methods ||| add numeric methods	count=1
class	return index or ndarray ||| datetime index	count=1
class	index with target's ||| index	count=1
function	a set of kwargs ||| kwargs	count=1
function	a masked rec array ||| masked rec array	count=1
function	return dtype ||| get empty dtype	count=1
arg	the shape ||| shape	count=1
function	[function_1] result ||| [function_2] [function_1]	count=4
function	[function_1] the type ||| [function_2] [function_1]	count=1
function	returns first ||| head	count=1
function	and setup ||| set	count=1
function_arg	[function_1] deterministic integers ||| [function_1] vals [arg_2]	count=1
function	you ||| set value	count=2
function	timedelta-like to timedelta64 ||| td index cmp	count=1
function	dtype [function_1] [function_2] dtype ||| [function_1] [function_2]	count=4
function	'info axis' see indexing ||| keys	count=1
arg	the binary ||| fname	count=1
function	a string-like ||| convert string array	count=1
function	dtype and ||| get empty dtype and	count=1
function	feather-format for ||| feather	count=1
module	the string ||| core	count=1
function	[function_1] are equal ||| [function_1] [function_2]	count=3
function	[function_1] size and ||| [function_1] [function_2]	count=1
class	return new dataframe with ||| data frame	count=1
function	add a ||| add	count=1
function	[function_1] a categorical ||| [function_1] [function_2]	count=3
arg	checks if key ||| key	count=1
arg	freq ||| freq	count=2
function	shift without copying ||| shift	count=1
class	exponential weighted ||| ewm	count=2
module	number ||| core	count=2
class	chainmap or subclass ||| chain map	count=1
function	am ||| is	count=1
function	additional handling as ||| array	count=1
module	pack object ||| io msgpack	count=1
function	to ||| convert	count=1
function	categorical if ||| categorical	count=1
function	via the 'numpy' library ||| with	count=2
function	a new ||| new	count=1
class	index or ndarray filled ||| index	count=1
function	if ||| value	count=1
arg	packed object return ||| packed object_hook	count=1
class	for this object ||| index	count=1
arg	series using mapper dict ||| as_index	count=1
function	qualified info display ||| memory usage qualified	count=1
module	to iterate over the ||| io	count=1
function_arg	to add [arg_2] ||| [arg_2] [function_1]	count=2
arg	x ||| x	count=3
arg	a fixed size ||| data encoding itemsize	count=1
arg	binary ||| fname	count=2
function	is of a ||| is	count=1
function	several cases to get ||| get index	count=1
function	from apply if as_index=true ||| index with as	count=1
class	be ||| hdfstore	count=1
class	the float values converted ||| float	count=1
function	returns a latex ||| latex	count=1
class	datetime date objects ||| datetime	count=1
arg	column and [arg_2] ||| [arg_2] [arg_1]	count=3
function	from ||| from	count=7
module	the html ||| io	count=1
class	times ||| index	count=1
module	an ||| core indexes	count=1
function_arg	a type [arg_2] ||| [arg_2] [function_1]	count=1
module	object datetimeindex ||| dtypes	count=1
arg	on a ||| op_str a	count=2
function_arg	numeric operations [arg_2] ||| [arg_2] [function_1]	count=4
function	capture stderr ||| capture stderr	count=2
class	a tree-like ||| html	count=1
function	to ||| convert datetime to	count=1
function	get ||| get ax	count=1
arg	table in ||| key value	count=1
function	localize tz-naive timeseries ||| localize	count=1
function	column ||| col	count=1
function	get the type ||| get dtype type	count=2
function_arg	[function_1] to class ||| [function_1] [arg_2]	count=3
function	timedelta-like to timedelta64 ||| td	count=1
module	dataframe and major_axis ||| core	count=1
arg	function return fillvalue for ||| fillvalue	count=1
function_arg	[function_1] [arg_2] ||| [function_1] concatenation plan [arg_2]	count=2
function_arg	locale [arg_2] ||| [function_1] [arg_2]	count=1
function	font ||| font	count=1
function	package is installed ||| package	count=1
arg	values from ||| values	count=2
function	wrapper function for ||| arith method	count=2
module	for sequences of ||| core	count=1
function	indexer return the ||| indexer	count=1
function	writing stata ||| stata	count=1
module	needs additional handling as ||| core indexes	count=1
class	can be used to ||| frame	count=1
function_arg	a slice [arg_2] ||| [arg_2] [function_1]	count=1
module	make new [module] inserting ||| [module]	count=1
function_arg	[function_1] iter2 iterables ||| [arg_2] [function_1]	count=1
arg	of regular expression pat ||| pat flags	count=2
function	coerce a scalar ||| coerce scalar	count=2
module	needs additional handling ||| core	count=1
class	gets ||| categorical	count=2
arg	a dataframe the ||| data values	count=1
module	use ||| core	count=1
function_arg	[function_1] multiple iterables ||| [function_1] cls [arg_2]	count=3
class	midnight ||| datetime index	count=1
function	numeric [function_2] ||| [function_1] methods [function_2]	count=1
arg	table in file node ||| value format	count=1
function_arg	apply a function ||| apply func	count=2
function	doesn't like ||| string like	count=1
function_arg	a method [arg_2] ||| [function_1] [arg_2]	count=4
arg	number_format_dict ||| cls number_format_dict	count=1
function	return dtype [function_2] ||| [function_1] [function_2]	count=4
arg	the file path ||| path	count=1
function	and string-like [function_2] ||| [function_1] [function_2]	count=1
class	that ||| frame parser	count=2
function	[function_1] a named ||| [function_1] [function_2]	count=1
class	as a frame table ||| table	count=2
arg	fill_value [arg_2] ||| [arg_2] [arg_1]	count=4
arg	fast ||| arr key	count=1
function	self as a sparse ||| as sparse	count=1
arg	unit ||| cls unit tz	count=1
arg	of cells ||| formatter subset	count=1
function	of series ||| get series	count=1
function_arg	[function_1] scalar data ||| [arg_2] [function_1]	count=4
module	the number ||| core	count=2
arg	wrapper function [arg] ||| [arg] arg	count=2
class	from maps[0] raise ||| map	count=1
arg	specified node (off ||| key start stop	count=1
function	scalar [function_2] ||| [function_2] [function_1]	count=7
arg	func ||| func	count=4
class	the ||| html	count=1
class	and ||| chain	count=1
arg	of regular expression ||| flags	count=2
function	a block [function_2] ||| [function_1] [function_2] class values	count=1
function	an internal [function] ||| is cython [function]	count=2
arg	from 1-dimensional ndarray only ||| arr key	count=1
function	called ||| array	count=3
function	[function_1] open ||| [function_1] [function_2]	count=1
class	but densify first ||| non consolidatable mix in	count=1
arg	sql ||| sql	count=2
module	[module] of ||| [module]	count=2
arg	[arg_1] freq with ||| [arg_2] [arg_1]	count=4
module	the built ||| formats	count=1
module	item of the ||| core	count=1
function	protection ||| protection	count=1
arg	and be ||| key value format	count=1
class	a series [class_2] ||| [class_1] [class_2]	count=4
function	form the union ||| union	count=3
module	return a ||| indexes	count=1
class	to its values ||| series	count=1
module_class	the data are ||| core data frame	count=1
module	tuple of the ||| core	count=1
arg	values [arg_2] ||| [arg_1] [arg_2]	count=3
function	disable ||| sub disabled	count=1
function	overlap add suffixes to ||| items overlap	count=1
function	select values between ||| indexer between	count=1
class	i am ||| categorical	count=1
module	that ||| util	count=3
arg	values of columns ||| columns	count=2
class	[class_1] index ||| [class_2] [class_1]	count=2
arg	dataframe the ||| data values	count=1
function	environment ||| latex	count=1
function	[function_1] types format ||| [function_2] [function_1]	count=6
arg	right array parameters ||| right closed	count=2
function	the locales ||| locales	count=1
function	determine if each string ||| str match	count=1
function_arg	[function_1] key ||| [function_1] node [arg_2]	count=1
function	type ||| is type	count=1
arg	of the ||| axis mgr	count=1
function	as an object ||| to object	count=1
function	to ||| build	count=1
function	alignment ||| alignment	count=1
class	boxed values ||| datetime	count=1
function_arg	append rows [arg_2] ||| [arg_2] [function_1]	count=3
module	to ||| core	count=2
module	this ||| core reshape	count=1
module	the text ||| io	count=1
arg	visualization algorithm parameters ||| frame class_column ax color	count=1
function	string-like array [function_2] ||| [function_2] [function_1]	count=1
module	an expression in ||| core computation	count=1
function_arg	[function_1] [arg_2] as self ||| [function_1] [arg_2]	count=8
class	maps[0] raise keyerror is ||| chain	count=1
arg	obj ||| obj	count=6
function_arg	to determine [arg_2] ||| [arg_2] [function_1]	count=1
class	date ||| date	count=2
function	thereafter [function_2] ||| [function_1] [function_2]	count=1
arg	given axis ||| axis	count=2
module	pack ||| msgpack	count=1
class	must already exist ||| hdfstore	count=1
function	as utc [function] days preserving ||| dt to [function]	count=1
class	[class_1] value ||| [class_2] [class_1]	count=4
arg	function [arg] as ||| [arg] kwargs	count=1
class	value of the index ||| index	count=2
function	validate this column return ||| validate col	count=1
class	dateoffset to ||| date offset	count=1
module	up styles to ||| io formats	count=1
arg	indexer fill with ||| indexer	count=1
function	set a ||| set	count=1
function_arg	a new [arg_2] ||| [arg_2] [function_1]	count=4
arg	ndarray only use this ||| key	count=1
function	dtype object ||| dtypes	count=1
function	format ||| format	count=8
arg	the name this allows ||| name	count=1
class	single block and are ||| block	count=1
function	to parse a ||| to	count=1
class	for more this is ||| ndframe	count=1
arg	append to table in ||| key value format append	count=1
arg	series or by ||| by axis	count=1
function	version of putmask ||| putmask	count=1
function	operations ||| operations	count=1
arg	indexer and return ||| indexer	count=2
arg	into a higher freq ||| cls value freq	count=1
module	shift [module] containing ||| [module]	count=1
function	recursive ||| recursive	count=1
module	for ||| msgpack	count=1
module	if ||| indexes	count=1
function	validates that ||| validate	count=1
function_arg	[function_1] from the ||| [function_1] [arg_2]	count=2
class	tree-like object that ||| html	count=1
function	function to get ||| func	count=1
function	[function_1] lists of ||| [function_2] [function_1]	count=6
function	missing ||| missing	count=1
module	for series ||| core	count=1
arg	values as ||| values sort	count=1
module_class	indices that would sort [module_1] [class_2] was called ||| [module_1] [class_2]	count=1
function	that we have ||| is	count=1
function	all [function_2] ||| [function_1] timeseries [function_2]	count=1
arg	[arg_1] in the ||| [arg_2] [arg_1]	count=2
function	function to get object ||| func	count=1
function	'numpy' library the third ||| with	count=1
function	index to [function_2] ||| [function_2] apply [function_1]	count=2
function	object that can be ||| build	count=1
function	over the ||| build	count=1
function	[function_1] a number ||| [function_1] [function_2]	count=1
class	whether the frame ||| data frame	count=1
class	info ||| data frame	count=1
class	take ||| sparse array	count=1
module_class	of the series ||| core series	count=1
module	expression that is in ||| computation	count=1
class	the same dimensions as ||| ndframe	count=1
function	an attributes dict for ||| attributes dict	count=1
class	a dataframe ||| sparse data frame	count=2
arg	of ||| axis mgr	count=1
class	index objects contain the ||| datetime index ops	count=1
function_arg	take [arg_2] ||| [function_1] [arg_2] new_mgr_locs fill_tuple	count=1
function	to apply ||| apply	count=1
function	stata ||| cast to stata	count=1
module_class	sparse [class_2] ||| [module_1] sparse [class_2]	count=3
class	used to ||| frame parser	count=1
function	datetimelike ||| datetimelike	count=1
function	only use this if ||| set value	count=1
function	try hard to parse ||| parse	count=1
function	construct [function_2] ||| [function_2] [function_1]	count=2
class	additional ||| period index	count=2
module	for this ||| core indexes	count=1
arg	nat-like arg is ||| arg errors	count=1
function	[function_1] period ||| [function_2] [function_1]	count=2
function	feather-format for ||| to feather	count=1
function	return the node with ||| get node	count=1
function_arg	[function_1] [arg_2] ||| [function_1] [arg_2] r_idx_names	count=1
module	[module] is ||| [module]	count=3
function_arg	[function_1] [arg_2] ||| [function_1] to dtypes [arg_2] dtypes	count=3
arg	writer ||| writer	count=1
module_class	[module_1] ndframe as ||| [module_1] [class_2]	count=2
function_arg	[function_1] multiple iterables ||| [arg_2] [function_1]	count=3
class	scope ||| scope	count=2
function	columns to ||| columns	count=1
function	applies a moving window ||| window	count=1
class	values need to ||| array	count=1
function	return dtype and ||| dtype and	count=1
function_arg	[function_1] a separate ||| [function_1] excel [arg_2]	count=1
arg	[arg] to ||| [arg]	count=1
arg	a single [arg] ||| [arg]	count=1
arg	indexer like ||| indexer	count=1
arg	reset_index ||| drop name	count=1
function	1-dimensional ndarray only use ||| value	count=1
class	a new block manager ||| block manager	count=2
arg	indexer like _name ||| name indexer	count=1
module	have a ||| core	count=1
class	index ||| categorical index	count=1
arg	copy if specified coerce ||| copy	count=1
function	of openpyxl is supported ||| is	count=1
arg	copy ||| dtype copy	count=1
function_arg	values [arg_2] ||| [arg_2] [function_1]	count=2
class	series [class_2] ||| [class_2] [class_1]	count=4
arg	unit if needed otherwise ||| cls unit tz	count=1
function_arg	wrap result [arg_2] ||| [function_1] [arg_2]	count=1
module	'args' ||| compat numpy	count=2
function	backward to next offset ||| rollback	count=1
arg	fill ||| limit	count=1
module	return a tree-like object ||| io	count=1
class	lookup of ||| index	count=1
class	with times to midnight ||| datetime index	count=1
class	return the number ||| multi index	count=1
function_arg	[function_1] [arg_2] elements ||| [function_1] to dtypes [arg_2] dtypes	count=6
arg	particular axis [arg_2] ||| [arg_2] [arg_1]	count=2
arg	only use this if ||| key	count=1
arg	to the smallest ||| categories	count=1
function	[function] leveraging dateutil ||| parse [function]	count=1
arg	be a single block ||| new align inplace	count=1
arg	to avoid code duplication ||| name str_rep masker	count=1
function	bounds ||| bounds	count=2
function	float dtype ||| float	count=1
function	concatenation of an ||| concat datetime	count=1
class	[class] for ||| [class]	count=1
function_arg	[function_1] argument return ||| [function_1] [arg_2]	count=2
function	have ||| validate ordered	count=2
function	[function_1] bounds ||| [function_2] [function_1]	count=2
arg	compute a simple ||| values	count=1
function	freq ||| ax freq	count=1
function	counts of ||| counts	count=1
function_arg	table [arg_2] ||| [function_1] table_name [arg_2]	count=3
function	number [function_2] ||| [function_1] [function_2]	count=1
arg	null values ||| values	count=1
function	blocks ||| take blocks	count=1
function	type ||| table type	count=2
class	tree-like object that ||| frame	count=1
class	new manager with the ||| block manager	count=1
function	convert an object ||| convert	count=1
function	see :class ||| packb	count=1
class	single block and ||| block	count=1
class	are a series we ||| series group	count=1
function	returns ||| get	count=1
function_arg	[function_1] expected ||| [arg_2] [function_1]	count=4
function_arg	[function_1] y if ||| [function_1] x [arg_2]	count=2
class	dataframe as ||| data frame	count=1
function	kind of my ||| kind	count=1
function	doesn't like ||| like	count=1
function_arg	locales that [arg_2] ||| [function_1] [arg_2]	count=2
function	is supported parameters ||| is	count=1
arg	or object coercible ||| other join overwrite filter_func	count=1
function	to [function_2] ||| [function_2] [function_1]	count=12
function	under the index ||| index	count=1
function_arg	is *not* the ||| is other	count=1
function_arg	[function_1] [arg_2] ||| [function_1] slice [arg_2]	count=12
module	gets called after a ||| core indexes	count=2
module	only use ||| core	count=1
function	full length slice ||| full slice	count=3
arg	provide explict type ||| dtype	count=1
module	to numpy ||| numpy	count=1
function	series/index ||| str get	count=2
function	panel to long ||| to long	count=2
class	gets called after a ||| index	count=2
module	element pandasobject ||| core	count=1
function	coerce a scalar to ||| coerce scalar to	count=1
function	kwargs suitable for ||| kwargs	count=1
arg	bb ||| axis new_mgr_locs fill_tuple	count=1
arg	helper function to convert ||| rowlabels collabels	count=1
arg	given axis [arg_2] ||| [arg_1] [arg_2]	count=1
class	used to ||| html frame	count=1
function	is monotonic ||| is monotonic	count=2
arg	series or ||| axis	count=1
module	return the ||| indexes	count=2
function_arg	[function_1] obj with ||| [arg_2] [function_1]	count=3
function_arg	[function_1] argument ||| cython [function_1] [arg_2]	count=1
function	[function_1] size and ||| [function_2] [function_1]	count=1
arg	values along a given ||| values	count=1
function	[function_1] fill value ||| [function_2] [function_1]	count=1
function_arg	[function_1] [arg_2] ||| [function_1] to style kwargs [arg_2]	count=2
class	in this object ||| ndframe	count=2
arg	already exist and ||| key	count=1
function	for [function_2] ||| [function_2] [function_1]	count=3
module	the underlying data ||| indexes	count=2
function	and [function_2] ||| [function_2] [function_1]	count=1
function	optional positional and ||| optional args	count=1
class	we have a ||| categorical	count=1
module	long strings in the ||| core	count=1
class	data ||| range	count=1
arg	if ||| cls	count=1
arg	the function to my ||| func	count=1
function_arg	quantile a [arg_2] ||| [arg_2] [function_1]	count=1
class	underlying ||| index ops mixin	count=1
function	node must already ||| append	count=1
class	be used ||| parser	count=1
function	to a pandas ||| to	count=1
arg	specialized cython ||| arr indexer axis out	count=1
function	validate this column ||| validate col	count=1
arg	lookup ||| arr	count=1
function_arg	to the [arg_2] ||| [function_1] blocknd values [arg_2]	count=1
arg	a dataframe ||| data	count=1
function_arg	beginning of [arg_2] ||| [arg_2] [function_1]	count=1
arg	cross-tabulation ||| index columns	count=1
function	needs additional ||| array	count=1
class	a tree-like ||| html frame parser	count=1
module	cross-tabulation of ||| core reshape	count=1
function	return a tree-like ||| build	count=1
class	original ||| ndframe	count=1
function	to an integer ||| integer	count=1
module	necessary ||| sparse	count=1
function	header ||| pop header	count=1
arg	shape of the ||| shape	count=1
arg	append to ||| format append	count=1
function	convert to [function_2] ||| [function_1] [function_2]	count=15
function	[function_1] kwargs ||| [function_2] [function_1]	count=1
function_arg	[function_1] key or ||| [function_1] [arg_2]	count=3
arg	and params args to ||| params	count=1
function	the reindex ||| reindex	count=1
module	gets called after ||| indexes	count=2
arg	[arg_1] inferring dtype ||| [arg_2] [arg_1]	count=2
class	a ||| period	count=1
function	[function_1] same ||| [function_1] [function_2] class values	count=3
arg	[arg_1] and arr2 ||| [arg_1] [arg_2]	count=3
arg	apply a function to ||| func	count=2
function	a custom template ||| from custom template	count=2
function	null [function] until ||| pad [function]	count=1
function	a method ||| method	count=1
function	into codes ||| codes	count=1
function	[function_1] a sparse ||| [function_1] [function_2]	count=3
arg	packed object return an ||| packed object_hook	count=1
function	[function_1] string-like ||| [function_1] [function_2]	count=1
class	apply ||| semi month offset	count=1
function	validates ||| validate ordered	count=2
module	the built up styles ||| io formats	count=1
function	in ||| append	count=1
module	simple cross-tabulation ||| core	count=1
function	a custom ||| from custom	count=1
arg	selected item ndarray ||| item fastpath	count=1
function	version [function] ||| skip if no [function]	count=1
function	determine if ||| n method	count=1
arg	a float key and ||| key	count=1
function	tree-like ||| build	count=1
function_arg	integer location [arg_2] ||| [arg_2] [function_1]	count=6
module	one ||| core	count=1
arg	level of ||| level	count=1
module	return the number ||| core	count=2
arg	window_type and size ||| win_type	count=1
class	as the original ||| ndframe	count=1
arg	to maintain order ||| side sorter	count=1
module_class	replace specific elements in [module_1] [class_2] with given values ||| [module_1] [class_2] put	count=1
arg	to class python 2 ||| cls name	count=1
function	stride [function_2] ||| [function_1] [function_2]	count=1
class	rolling ||| rolling	count=1
function	cast it to ||| maybe cast	count=1
class	series excluding missing ||| series	count=1
function	the stata [function_2] ||| [function_2] [function_1]	count=4
class	whether i am an ||| index	count=1
module_class	[module_1] from ||| [module_1] sparse [class_2]	count=1
arg	other ||| other	count=5
class	transform ||| group by	count=1
function	to coerce ||| coerce freq	count=1
arg	empty except for allowed ||| allowed	count=1
function	a multi [function_2] ||| [function_2] [function_1]	count=2
module	we ||| indexes	count=1
class	that can be used ||| frame parser	count=1
arg	the _apply kwargs and ||| window center	count=1
function	of ftypes in ||| ftype	count=1
function	used to iterate over ||| build	count=1
function	[function_1] axes if ||| [function_2] [function_1]	count=1
function_arg	the index [arg_2] ||| [arg_2] [function_1]	count=1
class	to the underlying ||| index ops mixin	count=1
arg	window_type and size ||| win_type min_periods	count=1
class	pytables file ||| hdfstore	count=1
function	classes which represent time-seires ||| timeseries index	count=1
class	the float values ||| float array	count=1
arg	file node must ||| key	count=1
arg	the default frequency ||| freq	count=3
class	categorical ||| categorical	count=17
function_arg	take values [arg_2] ||| [function_1] [arg_2]	count=2
arg	append ||| key value format append	count=1
function	string cast it to ||| maybe cast	count=1
arg	that left [arg_2] ||| [arg_1] [arg_2]	count=4
class	block as ||| block	count=1
function	index names ||| default names	count=1
function_arg	[function_1] column and ||| [arg_2] [function_1]	count=2
function	sets index names to ||| names	count=1
function	[function_1] array ||| [function_1] [function_2]	count=11
module	be used to ||| io	count=1
function	my dtype ||| dtype	count=1
function	valid for scalar ||| can do	count=1
function	[function_1] key ||| [function_2] [function_1]	count=4
class	function in blockmanager ||| block manager	count=1
arg	an ||| axes	count=1
class	be ||| html frame	count=1
function	[function_1] maximum by ||| [function_1] [function_2]	count=1
function	the display [function_2] ||| [function_2] [function_1]	count=4
function	[function_1] to ||| [function_1] [function_2]	count=13
function	null [function] until it's ||| pad [function]	count=1
arg	where elements of v ||| v	count=1
class	is ||| ndframe	count=1
function	series that is datetimelike ||| datetimelike	count=1
function	format of a given ||| format	count=1
function	names to 'index' ||| default names	count=1
arg	to the groupby generically ||| cls	count=1
function	initializing the gradientfill stop ||| stop	count=1
class	apply ||| group by mixin	count=1
module	lookup of ||| indexes	count=1
function	the union of ||| union	count=2
function	only ||| set value	count=2
function	to beginning of period ||| beg	count=1
class	raised ||| assert raises contextmanager	count=1
arg	to the ||| cls	count=1
function	and string-like array to ||| string to	count=1
module	as a ||| core indexes	count=1
function	a view ||| view	count=3
class	over ||| html frame	count=1
arg	string using various backends ||| parser engine truediv	count=1
function	of ||| set	count=1
class	i am never a ||| categorical block	count=1
function	[function_1] slice ||| [function_1] [function_2]	count=6
arg	match of regular expression ||| flags expand	count=1
arg	value ||| arr key value	count=1
class	series with multiindex to ||| series	count=1
arg	[arg_1] query ||| [arg_1] [arg_2] cur params	count=2
function	closest period ||| get period	count=1
module	is index ||| core	count=1
arg	interpret the ||| val pandas_dtype	count=1
function_arg	[function_1] [arg_2] ||| [function_1] alias [arg_2]	count=3
arg	to the cls ||| cls use_numexpr	count=1
arg	membership of x ||| x	count=2
arg	arg ||| arg	count=3
class	must already exist and ||| hdfstore	count=1
class	return the number of ||| range	count=1
module_class	whether the file ||| io hdfstore	count=1
arg	values to ||| values ndim	count=1
function	full ||| full	count=2
function	and [function_2] ||| [function_1] [function_2]	count=1
function	an index that we ||| index	count=1
function	of the timedelta64[ns] ||| timedelta64 ns	count=1
class	the underlying data ||| datetime index ops mixin	count=1
class	underlying array which by-definition ||| index ops mixin	count=1
function	trims [function_2] ||| [function_1] [function_2]	count=1
class	dimensions ||| ndframe	count=1
function	helper function to determine ||| dtype n method	count=1
function	this if you ||| set value	count=1
function	[function_1] str ||| [function_1] [function_2]	count=3
class	of interval ||| interval	count=1
module	for more ||| core	count=1
arg	[arg] nans ||| [arg]	count=1
class	index ||| index ops mixin	count=2
module	of groups excluding missing ||| core	count=1
function	registered option ||| get registered option	count=2
arg	if dtype ||| dtype	count=1
class	index with target's values ||| index	count=1
class	[class] 'sort_values' ||| [class]	count=1
function	bom ||| bom	count=1
module_class	[module_1] block it ||| [module_1] [class_2]	count=1
function	[function_1] datetime ||| [function_1] [function_2]	count=4
arg	is a term or ||| scope_level	count=1
arg	result will respect ||| ascending sort_remaining	count=1
module_class	the [class_2] ||| [module_1] [class_2] put	count=1
function	json lists to ||| to	count=1
arg	from the first ||| arr	count=1
function_arg	append [arg_2] ||| [function_1] [arg_2]	count=2
arg	[arg_1] 'kwargs' ||| [arg_1] [arg_2]	count=2
function	[function_1] endian ||| [function_2] [function_1]	count=1
function	to closest period ||| get period	count=1
arg	the input value ||| value	count=1
function	are unique ||| unique	count=1
function	align a ||| align	count=1
class	i am ||| block	count=1
function	i am never a ||| is	count=1
arg	over the blocks collect ||| consolidate transposed	count=1
arg	shape of ||| shape	count=1
class	frame table ||| appendable multi series table	count=1
arg	kwds ||| kwds	count=1
function	interactive [function_2] ||| [function_2] [function_1]	count=1
arg	or so [arg] bitwise ||| [arg]	count=1
arg	an indexer ||| indexer	count=1
module	checks ||| util	count=1
class	they are valid stata ||| stata writer	count=1
function	as ||| as	count=1
module	reverse of ||| core	count=2
arg	this if you ||| arr key	count=1
arg	handling as ||| result	count=1
function	info axis ||| get info	count=1
function	[function_1] object dtype ||| [function_1] string to [function_2]	count=1
function	return the join indexers ||| get join indexers	count=2
function	to parse datetime string ||| parse time string	count=1
class	offset ||| offset	count=1
function	the strides ||| strides	count=1
class	used ||| parser	count=1
arg	fill_value and arr ||| arr fill_value	count=3
arg	gets called after a ||| result	count=3
function	gets ||| wrap	count=3
function	len of myself ||| size	count=1
function	prior to a ||| array prepare	count=1
arg	of the ||| axis	count=1
function	exception and ||| exception	count=1
arg	by the n ||| n	count=2
function_arg	[function_1] [arg_2] ||| core computation filter [function_1] [arg_2]	count=1
arg	column by [arg_2] ||| [arg_2] [arg_1]	count=1
module	(e ||| core indexes	count=1
module	the generic ||| io	count=1
function	[function_1] array and ||| [function_1] [function_2]	count=5
function	the block ||| block	count=1
function	for a column ||| col	count=1
function	ndarray argsort ||| argsort	count=1
arg	be a single block ||| new align	count=1
function	interpolate ||| interpolate	count=2
function	to coerce [function_2] ||| [function_1] [function_2]	count=7
class	index objects ||| index	count=4
function	[function_1] metadata ||| [function_1] [function_2]	count=1
module	object ||| core	count=2
function	a ||| array wrap	count=6
module	use this ||| core	count=1
arg	[arg_1] axis ||| [arg_1] [arg_2]	count=1
function	[function_1] unary ||| [function_1] methods [function_2]	count=1
class	a dense type view ||| single block manager	count=1
module	with [module] ||| [module]	count=2
class	that can be used ||| parser	count=1
module	the handle if its ||| io	count=1
function	date ||| date	count=3
class	or other [class] operations ||| [class]	count=2
module	sparsearray ||| core sparse	count=1
arg	a function [arg] as ||| [arg] kwargs	count=1
module_class	[module_1] categorical ||| [module_1] [class_2]	count=14
function	symmetric [function_2] ||| [function_1] [function_2]	count=2
arg	of arr1 and ||| arr1	count=1
module	built ||| io	count=1
arg	and right ||| right check_exact check_dtype	count=1
function	starting at ||| rsplit	count=1
function	'numpy' library ||| validate take with convert	count=1
arg	[arg_1] encoding ||| [arg_2] [arg_1]	count=4
function	parse the raw ||| parse raw	count=3
function_arg	[function_1] against the ||| [arg_2] [function_1]	count=4
function	to deprecate ||| deprecate	count=1
arg	convert dataframe and series ||| data	count=1
function	a multi reindex ||| reindex multi	count=2
function	best locator based ||| locator	count=1
arg	non-unique ||| target	count=1
arg	time series ||| series ax	count=1
function	the metadata for ||| metadata	count=1
class	index objects contain the ||| index ops	count=1
arg	not copy ||| copy	count=1
function	which [function_2] ||| [function_2] [function_1]	count=2
arg	labels ||| labels	count=5
function	to apply we are ||| apply	count=1
class	remove ||| chain map	count=1
arg	a non-unique ||| target	count=1
function_arg	create [arg_2] ||| [function_1] [arg_2]	count=3
arg	check that [arg] comparable ||| [arg]	count=1
class	can be used to ||| parser	count=1
function	environment table ||| latex	count=1
function	slice/take blocks ||| blocks	count=1
arg	[arg_1] as ||| [arg_2] [arg_1]	count=4
function_arg	[function_1] of values ||| [function_1] [arg_2]	count=2
module	return the number of ||| core indexes	count=2
class	gets called after a ||| period index	count=1
function_arg	[function_1] an indexer ||| [arg_2] [function_1]	count=1
class	needs ||| index	count=1
module	parse ||| core tools	count=1
function	numpy doesn't like ||| like	count=1
function	for ordered ||| ordered	count=1
function	be table ||| append	count=1
arg	in values ||| values	count=1
arg	given dimensions levels names ||| names	count=1
function_arg	for series [arg_2] ||| [function_1] [arg_2]	count=9
arg	a dataframe the ||| data	count=1
class	of ||| multi index	count=2
function	block ||| create for block	count=2
class	to midnight length ||| datetime index	count=1
function	full [function_2] ||| [function_1] [function_2]	count=1
function	take a string-like ||| string array	count=1
function	[function_1] open ||| [function_2] [function_1]	count=1
class	dataframe to a variable ||| data frame	count=1
function_arg	coerce values [arg_2] ||| [function_1] [arg_2]	count=2
class	the number ||| index	count=2
class	data for this ||| data	count=1
arg	a code to a ||| code	count=1
function	expected ||| expected	count=1
function	formats to ||| datetime to	count=1
arg	and be ||| value format	count=1
class	[class] with a ||| [class]	count=2
function	(e g ||| maybe	count=1
function_arg	[function_1] default implementation ||| [arg_2] [function_1]	count=2
class	return index or ndarray ||| index	count=1
class	plot ||| plot	count=2
module	indicating whether the ||| io	count=1
arg	dataframe ||| data	count=3
arg	right ||| right exact check_names	count=1
arg	to an ndarray copy ||| index dtype copy	count=1
function_arg	[function_1] already made ||| [arg_2] [function_1]	count=4
arg	already exist ||| value	count=1
function	copy of ||| copy	count=3
arg	1-dimensional ndarray only use ||| key	count=1
arg	valid ||| op	count=1
arg	function designed to ||| func	count=1
class	[class_1] excluding ||| [class_1] [class_2]	count=6
module_class	of ndframe as ||| core ndframe	count=1
class	returns a dense ||| sparse	count=1
arg	dataframe columns parameters ||| data x y by	count=1
class	the underlying ||| multi index	count=1
function	capture [function_2] ||| [function_2] [function_1]	count=4
arg	int64 with null values ||| values	count=1
arg	on 3 columns ||| index columns values	count=1
module	used ||| core	count=1
arg	of obj with ||| obj	count=1
class	and index ||| datetime index	count=1
module	bytes ||| io	count=1
function_arg	same [arg_2] ||| [function_1] class values [arg_2]	count=1
function	fast ||| set	count=1
function	generate bin edge ||| generate	count=1
function	[function_1] join ||| [function_1] [function_2]	count=2
function	closed ||| interval closed	count=1
module	number ||| indexes	count=2
function	to convert timedelta-like to ||| td	count=1
function	view ||| view	count=3
arg	y if possible otherwise ||| y	count=2
arg	called after a ||| result	count=3
class	a ndarray ||| index	count=1
function	[function_1] a scalar ||| [function_2] [function_1]	count=3
arg	the nan/nat ||| val	count=1
class	result block ||| block	count=2
module	return datetimeindex ||| core	count=1
arg	deterministic integers ||| encoding hash_key categorize	count=1
function	[function_1] size ||| [function_1] [function_2]	count=1
arg	with nat-like arg ||| arg	count=1
arg	3 columns of ||| columns values	count=1
function	my self as ||| as	count=1
function	an xpath expression to ||| xpath expr	count=1
function	[function_1] expected exception ||| [function_2] [function_1]	count=2
class	and dtype) ||| ndframe	count=1
function	keys that ||| keys	count=1
arg	to have ||| name	count=1
function	a multirow e ||| format multirow	count=1
class	the ||| series	count=3
function	moving window ||| apply window	count=1
class	underlying data ||| range	count=1
function	which represent time-seires ||| timeseries index	count=2
arg	the left and ||| left	count=1
class	index with target's values ||| multi index	count=1
function	parameter ||| ordered	count=1
function	align a set of ||| align	count=1
class	with ||| datetime index	count=1
module_class	[module_1] type ||| [module_1] interval [class_2]	count=1
module	and dtype) ||| core	count=1
function	multirow ||| format multirow	count=1
module	html ||| io formats	count=2
arg	[arg] using ||| [arg] cur	count=2
arg	i [arg_2] ||| [arg_1] [arg_2]	count=2
arg	unique elements of arr1 ||| arr1	count=1
function	a feather-format object from ||| read feather	count=1
function	downsample ||| downsample	count=2
function	needs ||| wrap	count=1
module	setup ||| core	count=1
arg	data ||| data subarr	count=1
arg	as series or by ||| by axis level	count=1
function	given ||| get	count=9
arg	a simple cross-tabulation of ||| values	count=1
module	of the dataset ||| core	count=1
function	named [function_2] ||| [function_1] [function_2]	count=1
class	can be ||| parser	count=1
function	fill [function_2] ||| [function_2] [function_1]	count=6
function	in index ||| custom index	count=1
function	apply the [function_2] ||| [function_2] [function_1]	count=3
arg	indexer fill with the ||| indexer allow_fill	count=1
function_arg	[function_1] the key ||| [function_1] node [arg_2]	count=1
function	for last ||| last	count=2
function	a data ||| data	count=1
function_arg	[function_1] info ||| [arg_2] [function_1]	count=2
class	fill_value=nan returns a dense ||| sparse	count=1
class	the ||| parser	count=1
function	for akima [function_2] ||| [function_1] [function_2]	count=1
function	operations to convert timedelta-like ||| td index	count=1
function	[function_1] format ||| [function_2] [function_1]	count=3
function	[function_1] dict-like ||| [function_1] [function_2]	count=1
arg	columns using ||| inplace	count=1
function	a registered [function_2] ||| [function_1] [function_2]	count=1
function	[function_1] time ||| [function_1] [function_2] arg format infer_time_format errors	count=3
function_arg	[function_1] function ||| [function_1] apply arg [arg_2]	count=1
function	alert a ||| alert	count=1
function	with closed [function_2] ||| [function_1] [function_2]	count=1
function	series/index by the ||| str	count=1
arg	[arg_1] index parameters ||| [arg_2] [arg_1]	count=2
function	keys for ||| keys	count=1
module	can ||| io	count=1
function	closest period ||| period	count=1
class	group excluding ||| group by	count=2
function	rewrite ||| rewrite	count=1
module	packer ||| msgpack	count=1
function	list-like ||| list like	count=2
module	or values in the ||| core	count=2
arg	series or by a ||| by axis level	count=1
function	1-dimensional ndarray ||| value	count=1
function	[function_1] levels ||| [function_1] [function_2]	count=4
function	1-dimensional ndarray ||| set value	count=1
arg	column by inferring dtype ||| name data use_dtypes convert_dates	count=1
function	evaluate ||| evaluate	count=1
function	are going to write ||| write	count=1
arg	lookup of value ||| value	count=1
class	[class] for missing ||| [class]	count=1
function_arg	[function_1] ndarray or ||| [function_1] matrix [arg_2]	count=1
function	and string-like array ||| string	count=1
module	1-dimensional ||| indexes	count=1
module	return datetimeindex with times ||| core	count=1
class	necessary for ||| sparse	count=1
function	logical ||| logical	count=1
function	localize tz-naive ||| tz localize	count=1
arg	indexer like _name ||| cls name indexer	count=1
class	as a block ||| block	count=2
arg	the _apply kwargs ||| func name window center	count=1
module	return packed bytes see ||| io msgpack	count=1
function	so prints ||| warn	count=1
function	[function_1] counts of ||| [function_1] ftype [function_2]	count=1
class	index with ||| multi index	count=1
function	a string-like that ||| string array	count=1
class	is ||| datetime	count=1
function_arg	[function_1] this termvalue ||| [arg_2] [function_1]	count=1
module	return packed ||| io msgpack	count=1
module	check [module] the ||| [module]	count=1
class	the built ||| styler	count=1
function	multirow e ||| format multirow	count=1
function	to coerce [function_2] ||| [function_2] [function_1]	count=7
arg	append to table ||| format append	count=1
function	assignment ||| assign	count=1
function	take the ||| take	count=1
function	a full length slice ||| full slice	count=1
arg	table ||| key value	count=2
function	if ||| is	count=1
arg	we have a ||| name	count=1
arg	[arg_1] [arg_2] ||| [arg_1] pat [arg_2]	count=2
arg	the [arg] ||| [arg] con cur	count=1
function	new [function_2] ||| [function_2] [function_1]	count=1
class	of python datetime date ||| datetime	count=1
arg	a simple ||| index columns	count=1
arg	simple cross-tabulation ||| index columns values	count=1
function	return a string format ||| format	count=1
function_arg	date [arg_2] ||| [arg_2] [function_1]	count=1
arg	for this termvalue ||| v	count=1
function	from sif to datetime ||| to datetime	count=1
module	gets called ||| core indexes	count=2
arg	format files ||| format index encoding	count=1
arg	level ||| level dropna	count=1
function	unpack ||| unpack	count=1
module	this is index for ||| core	count=1
class	of the index ||| datetime index	count=2
function	nrows ||| make custom dataframe	count=1
class	a datetimeindex ||| datetime	count=1
arg	raises notimplentederror for ||| i	count=1
function	date formats to ||| datetime to	count=1
function	index names to 'index' ||| default names	count=1
function	return a basegrouper ||| get	count=1
function	data to ||| coerce to	count=1
arg	where is a ||| where scope_level	count=2
class	table ||| multi series table	count=1
module	formats ||| io formats	count=1
function_arg	of type [arg_2] ||| [arg_2] [function_1]	count=2
arg	[arg_1] level j ||| [arg_1] [arg_2]	count=1
function_arg	template [arg_2] ||| [function_1] [arg_2]	count=1
function	an iterable but not ||| iterable not	count=1
arg	blocks collect and create ||| consolidate transposed	count=1
class	a single block and ||| block	count=1
class	number ||| range	count=1
module	locations of ||| core	count=1
module_class	[module_1] [class_2] ||| [module_1] sparse [class_2]	count=6
arg	file node ||| key value format	count=1
function_arg	[function_1] to indexer ||| [function_1] [arg_2] new_mgr_locs fill_tuple	count=1
module	bytes see ||| io msgpack	count=1
function	this if you ||| set	count=1
class	[class_1] applicable to ||| [class_1] [class_2]	count=1
function	object ||| to	count=1
arg	if label is ||| label	count=1
class	provided date forward ||| date	count=1
arg	convenience function ||| xi yi x order	count=1
function	ensure that we ||| ensure	count=1
function	validate that an positional ||| has valid positional	count=1
function	drop 2d from ||| dropna	count=1
class	op ||| bin op	count=1
class	index and its underlying ||| index	count=1
class	a ndarray like into ||| parser	count=1
function	is valid ||| is valid dtype	count=1
arg	periods [arg_2] ||| [arg_1] axis [arg_2]	count=1
class	gets called ||| series	count=1
function	series extract groups ||| str extract	count=2
class	styles ||| styler	count=1
function	[function_1] set ||| [function_1] [function_2]	count=2
function	the symmetric difference ||| symmetric difference	count=2
function	coerce ||| coerce indexer	count=1
function	downsample the cython ||| downsample	count=2
function	pickle ||| pickle	count=2
arg	the byte ||| column	count=1
function	interactive ||| interactive	count=1
function	fast ||| value	count=1
class	to midnight length ||| datetime	count=1
function_arg	trims zeros [arg_2] ||| [function_1] [arg_2]	count=1
module_class	the dataframe ||| core data frame	count=2
function	[function_1] which ||| [function_2] [function_1]	count=2
module	already ||| io	count=1
class	with times to midnight ||| index	count=1
module	a tree-like object that ||| io	count=1
function	sparseseries or sparsearray ||| to sparse	count=3
module	deleting the node in ||| io	count=1
arg	that left and right ||| left right check_exact	count=1
function_arg	the block [arg_2] ||| [function_1] [arg_2]	count=1
class	underlying data ||| datetime index ops mixin	count=1
function	or functions ||| rename	count=1
class	datetimeindex but for ||| datetime	count=1
function	the dtype object ||| dtype	count=2
function	interpolate values according to ||| interpolate	count=1
module	typeerror if ||| core dtypes	count=1
arg	as series or ||| axis	count=1
arg	deprecated use :meth ||| ascending	count=1
function	[function_1] a sparse ||| [function_2] [function_1]	count=3
function	bind a [function_2] ||| [function_2] [function_1]	count=1
function	to a ||| convert datetime to	count=1
arg	values ||| values	count=17
function	highlight [function_2] ||| [function_2] [function_1]	count=3
function	not in ||| not in	count=1
function	size and return ||| size	count=1
function	set of kwargs suitable ||| kwargs	count=1
arg	cast object to ||| errors	count=1
arg	info from string ||| freqstr	count=1
class	return datetimeindex with times ||| index	count=1
module_class	indices that would sort [module_1] [class_2] called ||| [module_1] [class_2]	count=1
function_arg	[function_1] groupby ||| [arg_2] [function_1]	count=2
arg	holding passed axis constant ||| axis how inplace	count=1
function	as block ||| block	count=1
function_arg	locator based [arg_2] ||| [arg_2] [function_1]	count=1
function_arg	init self [arg_2] ||| [function_1] matrix [arg_2]	count=3
class	engineering notation appending ||| eng formatter	count=1
arg	moving ||| arg window	count=1
module	midnight length ||| indexes	count=1
arg	the shape of the ||| ndim shape	count=1
class	the index ||| range index	count=1
arg	date_format ||| date_format	count=1
function	add ||| add numeric	count=1
arg	of n between ||| n axis	count=2
function	compat with ||| sort levels monotonic	count=1
function	packed bytes ||| packb	count=1
function_arg	id [arg_2] ||| [arg_2] [function_1]	count=1
module	index with business ||| indexes	count=1
function	for valid [function_2] ||| [function_2] [function_1]	count=1
module	index with day calendar ||| indexes	count=1
arg	a ||| index columns	count=1
class	table ||| hdfstore	count=2
module	float ||| io formats	count=1
class	returns the float values ||| float	count=1
arg	[arg_1] 'kwargs' should ||| [arg_2] [arg_1]	count=2
function	[function_1] axes ||| [function_1] [function_2]	count=1
arg	difference of n between ||| n axis	count=1
function	validate that [function_2] ||| [function_2] [function_1]	count=1
function	label ||| label	count=1
arg	out the binary ||| fname	count=1
arg	[arg_1] on ||| [arg_1] [arg_2]	count=1
function	return a view of ||| view	count=1
function	dtypes to ||| dtypes	count=1
arg	a given axis ||| axis method na_option	count=1
class	a series excluding ||| series group	count=2
function	dictionary for the ||| dict from	count=1
function	to beginning of ||| beg	count=1
function	of the shape ||| shape	count=1
arg	matches a regular expression ||| flags	count=1
module	this is index ||| core	count=1
class	our object ||| generic fixed	count=1
function_arg	[function_1] into a ||| [function_1] table_name [arg_2]	count=1
function	to a [function_2] ||| [function_1] [function_2]	count=6
arg	[arg_1] and arr ||| [arg_2] [arg_1]	count=8
module_class	[module_1] block ||| [module_1] [class_2] putmask mask	count=1
function	[function] gregorian date ||| [function] float	count=3
class	my pandas type ||| fixed	count=1
arg	to class python 2 ||| cls name func	count=1
arg	serialize ||| compression	count=1
arg	table in ||| format	count=1
arg	v ||| v	count=1
class	a frame table ||| series table	count=2
function	set ||| set object info	count=1
class	we by ||| group by	count=1
function	lookup of ||| set	count=1
module	called after ||| core	count=3
module	series columns for dataframe ||| core	count=1
class	python datetime date ||| datetime	count=1
arg	avoid code duplication ||| str_rep fill_zeros	count=1
module	additional handling ||| indexes	count=1
module	value [module] ||| [module]	count=2
arg	arg is ||| arg	count=2
arg	in requested ||| level	count=1
class	block ||| sparse block	count=1
function	bind a method ||| bind method	count=3
arg	indexable columns ||| columns	count=1
function	according to resolution ||| slice bound	count=1
module	lookup of ||| core	count=1
function	are index sliceable then ||| index sliceable	count=1
function	check whether the ||| like	count=1
class	for ||| array	count=1
arg	using input function ||| mapper axis copy inplace	count=1
function	string representation for ||| unicode	count=1
module	map values [module] series ||| [module]	count=1
function_arg	to coerce [arg_2] ||| [arg_2] [function_1]	count=3
arg	columns ||| index columns	count=1
arg	defaults to returning ||| inplace verify_integrity	count=1
function	align ||| align	count=1
function_arg	to [arg_2] ||| [function_1] sparse series [arg_2]	count=2
function	[function_1] [function_2] ||| [function_1] style [function_2]	count=10
arg	each string ||| arr	count=1
module	can be ||| io	count=1
module	used when a ||| core	count=1
arg	array ||| array	count=3
function	dataframe ||| assert frame	count=1
arg	perform __getitem__-like return ||| slicer new_mgr_locs	count=1
module	for this object ||| indexes	count=1
arg	table in file node ||| key value	count=1
module	resets the [module_2] ||| [module_1] [module_2]	count=2
function_arg	[function_1] parameters ||| [function_1] [arg_2]	count=1
arg	right ||| right check_exact	count=1
function	size of the dtype ||| itemsize	count=1
function	/ pandas type to ||| type	count=1
function	use this if ||| value	count=1
arg	the indexer fill with ||| indexer	count=1
arg	i with [arg_2] ||| [arg_1] [arg_2]	count=3
arg	a simple ||| values	count=1
module	the decimal points if ||| io	count=1
function	mode s of the ||| mode	count=1
function	a la re split ||| split	count=1
function	group of given ||| get freq group	count=2
module	scope ||| core computation	count=3
class	the scope ||| scope	count=1
class	a tree-like object ||| frame	count=1
function_arg	id of [arg_2] ||| [function_1] [arg_2]	count=1
function	parallel ||| parallel	count=1
module	[module] datetime64's ||| [module]	count=3
function_arg	[function_1] function ||| [arg_2] [function_1]	count=3
function	wrap given values [function_1] [function_2] ||| [function_1] [function_2] class values	count=2
arg	in file node ||| key value	count=1
arg	wkday ||| wkday	count=1
arg	fixed size ||| data encoding itemsize	count=1
module	you ||| indexes	count=1
function	asof [function_2] ||| [function_2] [function_1]	count=3
function	axes if ||| axes	count=1
module	single column from the ||| io	count=1
module_class	[module_1] generic stata ||| [module_1] [class_2] writer replace nans	count=1
function	[function_1] raw data ||| [function_1] [function_2]	count=1
class	my specific ||| index	count=2
function	[function_1] counts of ||| [function_2] [function_1]	count=1
class	passed dataframe ||| data frame	count=1
class	attribute if it ||| series	count=1
arg	not dtype instance associated ||| arr_or_dtype	count=1
arg	nat-like arg ||| arg	count=1
function	1-dimensional ||| set value	count=2
arg	using input ||| mapper axis copy inplace	count=1
function	to apply we ||| apply	count=1
function	[function_1] maximum by ||| [function_2] [function_1]	count=1
class	a tree-like object that ||| html frame parser	count=1
class	can be used ||| frame parser	count=1
module	use ||| indexes	count=1
arg	dtype converting float ||| dtype	count=1
function_arg	[function_1] [arg_2] ||| io [function_1] [arg_2]	count=3
function_arg	[function_1] into a ||| [function_1] table_name con schema [arg_2]	count=1
class	dtype) in this ||| ndframe	count=1
function	with the block ||| for block	count=1
arg	temporarily setting ||| new_locale lc_var	count=1
arg	data ||| data index	count=2
class	each group if n ||| group by	count=1
arg	[arg] is a ||| [arg]	count=2
function	xarray object from the ||| xarray	count=1
module	built ||| io formats	count=2
function	freq with decimal ||| decimal	count=1
class	the underlying data ||| range index	count=1
function_arg	stata [arg_2] ||| [function_1] [arg_2]	count=1
module	if you ||| core	count=1
function	lists to ||| to	count=1
function	categoricals are ||| equal	count=1
arg	lookup of value from ||| key value	count=1
module_class	[module_1] ndframe ||| [module_1] [class_2]	count=6
function	for as_blocks() ||| blocks	count=1
function	apply the given ||| apply	count=1
module	underlying data ||| indexes	count=2
arg	exist and be ||| key value format	count=1
class	plot ||| series plot	count=1
function_arg	strip [arg_2] ||| [function_1] arr [arg_2]	count=1
function_arg	from a [arg_2] ||| [function_1] [arg_2]	count=8
class	a new multiindex ||| multi index	count=1
function	union ||| union	count=3
function	sparseseries or [function_2] ||| [function_1] [function_2]	count=1
arg	a dataframe ||| data columns	count=1
function	validates that we have ||| validate	count=1
arg	with level j ||| j	count=1
arg	incoming data ||| data subarr	count=1
arg	a series ||| series	count=1
function_arg	[function_1] number_format_dict ||| [arg_2] [function_1]	count=1
function	wrap result set of ||| wrap result	count=1
class	only ||| categorical	count=1
arg	terms for instances ||| terms	count=1
arg	an indexer like _name ||| indexer	count=1
arg	a and ||| a	count=1
class	into a list ||| frame parser	count=1
function	common [function_2] ||| [function_2] [function_1]	count=1
arg	using [arg] ||| [arg]	count=3
class	returning a dataframe ||| data frame	count=1
function	the categories ||| categories	count=1
function	determine ||| str match	count=2
function	array and ||| array to	count=2
arg	read_excel(excelfile ||| sheetname header skiprows skip_footer	count=1
function	used to ||| build	count=1
function	from a dataframe column ||| from	count=1
function	[function_1] sequence ||| [function_1] [function_2]	count=1
arg	the labels shape ||| placement shape labels	count=2
function	return the ndarray flags ||| flags	count=1
module	lookup ||| core indexes	count=2
function	post ||| post	count=2
class	same ||| ndframe	count=1
class	used when ||| ndframe	count=1
function	the display options ||| display options	count=2
function	must be [function_2] ||| [function_1] [function_2]	count=3
function	ndarray only ||| set value	count=1
function	passed off to scipy ||| scipy	count=1
module	midnight length is ||| core indexes	count=1
function	index to beginning ||| beg apply index	count=1
arg	file ||| key	count=1
function	the categories ||| get categories	count=1
function	fast path [function_2] ||| [function_2] [function_1]	count=1
function	index ||| reset index	count=1
module	tree-like object that can ||| io	count=1
function	ndarray only ||| value	count=1
function_arg	[function_1] indexer ||| [function_1] [arg_2] new_mgr_locs fill_tuple	count=1
class	this if ||| index	count=1
function	numeric unary ||| numeric methods unary	count=1
function	from a 1d array ||| from intervals	count=1
module	to numpy ||| compat numpy	count=1
class	to midnight length is ||| datetime index	count=1
function	using ||| can use	count=1
arg	1-dimensional ndarray only ||| arr	count=1
arg	among the ||| types	count=1
class	series we ||| series	count=1
function	lists of ||| str	count=1
module	called after a ||| core	count=3
arg	generate ||| nchars size	count=1
arg	result parameters ||| result mask other	count=1
function	to coerce a scalar ||| coerce scalar	count=1
arg	[arg_1] j ||| [arg_1] [arg_2]	count=1
class	dataframe in panel ||| panel	count=1
arg	avoid code duplication ||| str_rep masker	count=1
arg	[arg_1] array parameters ||| [arg_1] [arg_2]	count=4
class	to iterate over the ||| parser	count=1
class	each level ||| multi	count=1
arg	render a ||| buf columns col_space header	count=1
arg	an expression in ||| expr inplace	count=1
function	result set coerce ||| coerce	count=1
function	like to ||| like	count=1
function	reorders ||| reorder	count=1
class	used ||| html	count=1
function	setting additional ||| freeze	count=1
arg	using [arg] ||| maybe_callable [arg]	count=2
class	a categorical ||| categorical	count=4
module	this if ||| indexes	count=1
function	validate metadata ||| validate metadata	count=2
function	the node ||| node	count=1
class	return the ||| series	count=1
function	attributes e g ||| attributes	count=3
function_arg	[function_1] duplicate ||| [arg_2] [function_1]	count=1
class	from object ||| ndframe	count=1
class	by ||| by	count=3
function	dense representation ||| dense	count=1
arg	[arg_1] [arg_2] ||| [arg_2] [arg_1]	count=302
arg	column and index parameters ||| index col	count=1
function_arg	strip [arg_2] ||| [arg_2] [function_1]	count=4
function_arg	determines if [arg_2] ||| [arg_2] [function_1]	count=4
module	json ||| json	count=1
function_arg	[function_1] argument return ||| cython [function_1] [arg_2]	count=1
arg	file ||| value format	count=1
class	ndarray like into a ||| parser	count=1
function	parse [function_2] ||| [function_1] [function_2]	count=2
function	plan ||| plan	count=1
function	overlap add suffixes to ||| overlap	count=1
class	roll provided date ||| date	count=2
arg	that left and right ||| left right check_dtype	count=2
module	ndarray only use this ||| core indexes	count=1
function	re-evaluate the [function_2] ||| [function_2] [function_1]	count=2
function	reflecting ||| setup	count=1
class	box ||| datetime index ops mixin	count=1
class	property property ||| ndframe	count=1
class	kwds in sparse ||| sparse	count=1
module	condition ||| computation	count=1
arg	or regular expression ||| pat flags	count=1
function	returns length of info ||| len	count=1
function	of mixed type ||| chained assignment possible	count=1
function_arg	set new item ||| set item	count=1
module	of ||| reshape	count=1
arg	arr for sequences ||| arr	count=1
arg	regular expression in ||| flags	count=1
arg	[arg_1] shape ||| [arg_2] [arg_1]	count=4
class	the float values converted ||| float array formatter	count=1
module	the dataset ||| core	count=1
function	array and [function_2] ||| [function_2] [function_1]	count=1
function	mask of index to ||| index	count=1
class	to iterate over ||| html frame parser	count=1
class	into a ||| frame parser	count=1
arg	labels in ||| labels	count=1
class	are a series ||| series group	count=1
class	over the ||| frame parser	count=1
arg	copy if specified ||| index dtype copy	count=1
function	we have mixed levels ||| have mixed levels	count=1
arg	against the [arg_2] ||| [arg_2] [arg_1]	count=1
function	histogram ||| hist	count=1
function_arg	single [arg_2] ||| [function_1] tuples [arg_2]	count=2
function_arg	[function_1] sql and ||| [arg_2] [function_1]	count=1
class	tree-like object that can ||| html frame parser	count=1
class	input ||| ndframe	count=1
arg	that time ||| time	count=1
module	packed bytes ||| io msgpack	count=1
class	only use ||| index	count=1
module	a tuple of the ||| core	count=1
function	function for ||| method	count=4
function	a tree-like object ||| build	count=1
arg	type ||| placement fastpath	count=1
class	returns the float values ||| float array formatter	count=1
class	underlying data as ||| index ops mixin	count=1
function	swap level ||| swaplevel	count=1
function	use this ||| set value	count=1
function	[function_1] rec ||| [function_1] [function_2]	count=4
function	histogram of ||| hist	count=1
arg	data visualization algorithm parameters ||| frame class_column ax color	count=1
function	if we are ||| safe for reshape	count=4
function	for a recursive call ||| recursive	count=1
function	add the ||| add numeric	count=1
function_arg	table as [arg_2] ||| [arg_2] [function_1]	count=3
function_arg	the locales [arg_2] ||| [function_1] [arg_2]	count=1
arg	cross-tabulation of ||| columns values	count=1
class	[class] 'sort_values' was ||| [class]	count=1
class	my ||| col	count=1
module_class	interval [class_2] ||| [module_1] interval [class_2]	count=1
function_arg	[function_1] and expected ||| [function_1] [arg_2]	count=1
module_class	[module_1] categorical to ||| [module_1] [class_2]	count=6
function	[function_1] time ||| [function_2] [function_1]	count=3
class	the index and its ||| range index	count=1
function	check ||| like	count=1
class	like into a ||| parser	count=1
module	return the number ||| indexes	count=2
class	multiindex at ||| multi	count=1
function	attempt to construct this ||| construct	count=1
function	[function] to ||| array [function]	count=1
arg	append ||| value format append	count=1
function	a matrix of scatter ||| scatter matrix	count=1
function	to a timedelta object ||| to timedelta	count=1
arg	packed object ||| packed object_hook	count=1
arg	and j ||| j copy	count=2
arg	use ||| arr	count=1
arg	cross-tabulation ||| values	count=1
module	values [module] series ||| [module]	count=1
arg	copy if ||| index dtype copy	count=1
function	only ||| only	count=1
function	series [function_2] ||| [function_2] [function_1]	count=2
class	gets called after ||| period	count=1
function	to convert timedelta-like to ||| td index	count=1
class	new block manager ||| block manager	count=4
function	[function_1] table reflecting ||| [function_2] [function_1]	count=3
arg	be ||| value	count=1
function	[function_1] type in ||| [function_1] [function_2]	count=4
class	called after a ||| period	count=1
function	1-dimensional ndarray only ||| set value	count=1
arg	interpolation [arg] will be ||| [arg]	count=1
arg	that left and right ||| left right	count=4
class	index or ||| index ops mixin	count=1
arg	arr to ||| arr	count=1
arg	statement is of the ||| w	count=1
function	locales that ||| locales	count=1
function_arg	of a [arg_2] ||| [arg_2] [function_1]	count=1
arg	columns of ||| index columns	count=1
function	available options grouped by ||| options	count=1
function	[function_1] option ||| [function_1] [function_2]	count=2
function	the metadata ||| metadata	count=1
class	each interval [class_2] ||| [class_2] [class_1]	count=1
function	get [function_2] ||| [function_1] dtype [function_2]	count=1
function_arg	repr function [arg_2] ||| [function_1] [arg_2]	count=3
arg	a python source ||| source	count=1
function	object ||| packb	count=1
arg	in ||| value format	count=1
module_class	[module_1] myself as ||| [module_1] [class_2]	count=2
function	a registered ||| get registered	count=1
function	a list of the ||| tolist	count=1
module	parse a ndarray like ||| json	count=1
function	[function_1] block ||| [function_1] [function_2]	count=1
arg	[arg_1] requested ||| [arg_2] [arg_1]	count=3
function	gets called ||| array wrap	count=3
arg	allows a decorator ||| decorator	count=1
class	format dataframe ||| data frame	count=1
function_arg	[function_1] an openpyxl ||| [function_1] style [arg_2]	count=1
function	converted [function] periodindex ||| [function]	count=1
arg	and be ||| value	count=1
class	series excluding elements ||| series group	count=2
function	template and ||| template	count=1
rep	[module_class_1] [function_arg_2] ||| [module_class_1] set [function_arg_2]	count=4
function	[function_1] our index ||| [function_2] [function_1]	count=7
function	form the intersection of ||| intersection	count=2
arg	draw ||| frame alpha figsize	count=1
module	if ||| core dtypes	count=2
module	the underlying data ||| core	count=2
arg	codes by the indexer ||| indexer	count=1
function	of ||| crosstab	count=1
arg	of value from 1-dimensional ||| key value	count=1
function	plan [function_2] ||| [function_2] [function_1]	count=1
class	resolution str against resolution ||| resolution	count=1
function	[function_1] level ||| [function_2] [function_1]	count=2
class	return the ||| multi	count=1
arg	to indexer and ||| indexer	count=2
module	is index for ||| core	count=1
function	try [function_2] ||| [function_2] [function_1]	count=7
function	getitem defers to ||| getitem	count=1
function	return the mode s ||| mode	count=1
function_arg	beginning of [arg_2] ||| [function_1] apply index i [arg_2]	count=1
arg	function [arg] appropriate ||| [arg] arg	count=1
function	axes ||| axes	count=4
function	[function_1] category labels ||| [function_2] [function_1]	count=1
function	create ||| create	count=4
arg	frequency ||| freq method how normalize	count=1
function_arg	set [arg_2] ||| [arg_2] [function_1]	count=1
function	take optional ||| optional args	count=1
arg	the blocks collect ||| consolidate transposed	count=1
function_arg	type [arg_2] ||| [function_1] [arg_2]	count=6
module	[module_1] the ||| [module_2] [module_1]	count=1
arg	unit if ||| unit tz	count=1
arg	to the new ||| copy	count=2
module_class	for [module_1] [class_2] ||| [module_1] [class_2]	count=2
function_arg	[function_1] dataframe the ||| [function_1] [arg_2]	count=1
function	optional positional and keyword ||| optional args	count=1
arg	last [arg] ||| [arg]	count=2
function	convert to ||| to	count=3
function	classes which [function_2] ||| [function_2] [function_1]	count=2
function	reindex for all the ||| reindex	count=1
function_arg	coerce the [arg_2] ||| [function_1] to dtypes [arg_2] dtypes	count=1
arg	use ||| arr key	count=1
arg	append ||| append	count=1
function	bytes ||| bytes	count=1
function	frequency code group of ||| group	count=1
class	tree-like object ||| html frame parser	count=1
function	symmetric difference ||| symmetric difference	count=2
class	datetime date objects ||| datetime index	count=1
module	return the number of ||| indexes	count=2
module	for dataframe and major_axis ||| core	count=1
arg	value is valid for ||| value	count=1
class	evaluate ||| bin op	count=1
arg	1-dimensional ||| arr key	count=1
function	the size ||| itemsize	count=1
arg	dataframe columns parameters ||| data x	count=1
arg	to the cls ||| cls	count=4
class	return a ||| frame parser	count=1
module_class	[module_1] stata ||| [module_1] [class_2] writer replace nans	count=3
module	to midnight length is ||| core indexes	count=1
class	gets called ||| period index	count=1
arg	analogous ||| axis broadcast reduce	count=1
function	might need to coerce ||| coerce freq	count=1
module	raise a typeerror if ||| core dtypes	count=1
module	not ||| core computation	count=1
class	for ||| index	count=5
module	up styles ||| io	count=1
function	bytes in ||| nbytes	count=2
arg	[arg_1] and right ||| [arg_1] [arg_2]	count=17
function	fast version of ||| fast	count=1
function_arg	[function_1] scalar data ||| [function_1] [arg_2]	count=4
class	are creating [class] binner ||| [class]	count=1
function	slice the ||| slice	count=1
class	gets called ||| period	count=1
function	the best locator based ||| locator	count=1
function	[function_1] lists ||| [function_2] [function_1]	count=6
module	attribute ||| core	count=1
module	compute ||| core	count=1
arg	date [arg] ||| [arg]	count=1
arg	a particular axis ||| axis	count=3
arg	to table in file ||| format	count=1
arg	columns of this dataframe ||| index columns	count=1
function	subplots ||| subplots	count=1
function	[function_1] ftypes ||| [function_2] [function_1]	count=4
module	we have an object ||| core dtypes	count=1
module	if we ||| core	count=1
class	times to ||| index	count=1
function	series ||| series	count=6
function	a string format ||| format datetime64	count=1
function	header rows ||| header name	count=1
arg	date_format return ||| date_format	count=1
function	are index sliceable then ||| to index sliceable	count=1
arg	number of decimal places ||| decimals	count=1
class	deep ||| styler	count=1
function	take ||| assert take	count=2
function_arg	a repr [arg_2] ||| [arg_2] [function_1]	count=2
function	the series [function_2] ||| [function_2] [function_1]	count=2
module_class	true if [class_2] ||| [module_1] [class_2]	count=2
function	we create the grouper ||| grouper	count=1
class	a ||| html frame	count=1
arg	to indexer and ||| indexer axis	count=2
function	getitem defers to the ||| getitem	count=1
arg	on 3 columns of ||| index columns	count=1
arg	a new datacol ||| name cname	count=1
function	gets called prior to ||| prepare	count=1
arg	and plural 'names' ||| names deep	count=1
function	[function_1] a sequence ||| [function_1] [function_2]	count=1
function	we have ||| validate ordered	count=1
function	datetime to ||| datetime to	count=2
arg	indexer fill ||| indexer	count=1
arg	the shape of ||| ndim shape	count=1
arg	totally ordered [arg_2] ||| [arg_2] [arg_1]	count=6
arg	to ||| value format	count=1
arg	dataframe ||| data values	count=1
function	correct scope ||| scope	count=1
module	my ||| core indexes	count=1
class	to table in file ||| hdfstore	count=1
arg	must already exist and ||| key	count=1
arg	a dataframe ||| frame	count=2
function	for ||| extract axes for	count=1
arg	the mask see also ||| mask value	count=1
module	the underlying ||| core indexes	count=2
arg	draw a ||| frame alpha figsize	count=1
arg	to convert dataframe and ||| data	count=1
class	is index for ||| ndframe	count=1
function	format of a ||| format	count=1
function	from 1-dimensional ||| set value	count=1
function	file node must ||| append	count=1
function	are of mixed type ||| chained assignment possible	count=1
arg	i with [arg_2] ||| [arg_2] [arg_1]	count=3
module	pack object ||| io	count=1
function	using ||| use	count=1
arg	guarantee the shape of ||| shape	count=1
function	[function_1] rec array ||| [function_1] [function_2]	count=4
function	stderr ||| stderr	count=1
function_arg	[function_1] terms ||| [arg_2] [function_1]	count=1
class	table ||| appendable series table	count=1
function	we want to set ||| set	count=1
function	our native ||| native	count=3
function	localize tz-naive ||| localize	count=2
arg	compute a simple cross-tabulation ||| index columns values	count=1
function	matrix of scatter ||| scatter matrix	count=3
function	array of ||| array	count=2
function	the default ||| default	count=1
function_arg	the intersection [arg_2] ||| [function_1] [arg_2]	count=2
function	style ||| style	count=4
arg	from 1-dimensional ||| key	count=1
function	single [function] at ||| [function]	count=1
function	load a feather-format object ||| read feather	count=1
function	the frequency is ||| freq	count=1
function	matches the expected exception ||| exception matches	count=1
function	[function_1] join ||| [function_2] [function_1]	count=2
class	singleblockmanager ||| block manager	count=1
class	from ||| index	count=1
class	after a ||| series	count=1
function	for header rows ||| header	count=1
function	sets index names ||| default names	count=1
arg	[arg] as ||| [arg] kwargs	count=1
module	strings in the ||| core	count=2
arg	copy if specified coerce ||| dtype copy	count=1
function	names to 'index' ||| set default names	count=1
module	& with [module] | ||| [module]	count=1
class	over the ||| parser	count=1
function	positional ||| positional	count=1
class	and major_axis for ||| ndframe	count=1
class	myself as ||| datetime tzblock	count=1
class	implementation ||| index ops mixin	count=1
function	dtype and ||| dtype and	count=1
function	dropna ||| dropna	count=1
arg	passed [arg] ||| [arg] value	count=2
class	columns ||| ndframe	count=2
class	index objects ||| datetime index ops	count=1
module_class	[module_1] values need ||| [module_1] sparse [class_2]	count=1
class	return datetimeindex ||| datetime index	count=1
function	construct and returns axes ||| construct axes	count=1
arg	sql and [arg_2] ||| [arg_2] [arg_1]	count=3
function	we ||| ordered	count=1
function	needs ||| array	count=1
class	a [class] return ||| [class]	count=1
function	infer the ||| infer	count=3
function	masked rec ||| masked rec	count=2
function	doesn't like ||| v string like	count=1
function	set [function] item major ||| set [function]	count=1
arg	representation or datetime ||| freq	count=1
arg	if label ||| label side	count=1
arg	in the context of ||| inplace	count=1
function	the reindex for ||| reindex	count=1
function	concatenate [function_2] ||| [function_2] [function_1]	count=1
arg	bins to ||| bins	count=1
class	create/cache the ||| table	count=1
module	ndarray only use ||| core	count=1
class	to the underlying ||| ops mixin	count=1
function	array of unicode strings ||| randu array	count=1
function	[function_1] scalar to ||| [function_2] [function_1]	count=3
function_arg	specified [arg_2] ||| [function_1] [arg_2]	count=1
function	to convert [function_2] ||| [function_1] [function_2]	count=2
arg	return fillvalue ||| fillvalue	count=1
arg	data ||| data groups dropna label	count=1
function_arg	zeros [arg_2] ||| [function_1] [arg_2]	count=1
arg	contained in values ||| values	count=1
module	pivot ||| core reshape	count=1
function	display options for ||| display options	count=2
function	validates that ||| ordered	count=1
class	return ||| series	count=1
class	tree-like object that ||| parser	count=1
class	return a tree-like object ||| parser	count=1
function	is of [function_2] ||| [function_1] [function_2]	count=3
function	indices overlap ||| items overlap	count=1
function	to a [function_2] ||| [function_2] [function_1]	count=11
function_arg	path's extension [arg_2] ||| [arg_2] [function_1]	count=3
class	array of datetime time ||| datetime	count=1
arg	a ||| a	count=4
module	cross-tabulation ||| reshape	count=1
function	interactive [function_2] ||| [function_1] [function_2]	count=1
class	that can be ||| parser	count=1
arg	a and [arg_2] ||| [arg_1] [arg_2]	count=1
function	locator ||| locator	count=1
function	try to connect ||| connect	count=1
function	sif to [function_2] ||| [function_1] [function_2]	count=1
function	index ||| custom index	count=1
function	that path's extension ||| check extension	count=1
function	assemble the unit ||| assemble from unit	count=1
function	construct and returns ||| construct	count=1
arg	columns using input ||| axis copy inplace	count=1
arg	bins ||| bins	count=1
function	concat ||| concat	count=1
module	compute ||| core reshape	count=2
module	return datetimeindex with ||| indexes	count=1
arg	inserting new [arg_1] [arg_2] ||| [arg_2] [arg_1]	count=1
function	try to connect to ||| can connect	count=1
class	memory ||| range index	count=1
class	dataframe ||| frame	count=2
function_arg	convert a [arg_2] ||| [arg_2] [function_1]	count=1
function_arg	[function_1] fillvalue ||| [function_1] [arg_2]	count=2
arg	node must already ||| value	count=1
function_arg	[function_1] protection_dict ||| [arg_2] [function_1]	count=1
function	reset the [function_2] ||| [function_2] [function_1]	count=6
function	for header rows ||| pop header name	count=1
module	[module] most ||| [module]	count=1
arg	with labels [arg_2] ||| [arg_1] axis [arg_2]	count=1
function	[function_1] a type ||| [function_2] [function_1]	count=7
arg	exist and be table ||| key value	count=1
module	raise ||| compat	count=1
arg	block ||| block block_items existing_col	count=1
function	to ||| dt to	count=1
function	applies the put method ||| put	count=1
class	if multiindex has only ||| multi	count=1
function	of all [function_2] ||| [function_2] [function_1]	count=2
module	array object has ||| core dtypes	count=1
arg	scalar data converts ||| cls data	count=1
function_arg	set [arg_2] ||| [function_1] [arg_2]	count=1
function_arg	type [arg_2] ||| [arg_2] [function_1]	count=6
function	internal [function] ||| is cython [function]	count=2
function	op ||| op	count=2
function	'numpy' library the ||| validate take with	count=1
module	am never a ||| core	count=1
module	can be used to ||| io	count=1
class	be used ||| frame	count=1
arg	a scipy ||| a	count=1
arg	of dtypes if ||| dtypes	count=1
arg	values to [arg_2] ||| [arg_2] [arg_1]	count=1
function	this level ||| level	count=1
function	infer the dtype ||| infer dtype	count=2
function	read csv file ||| from csv	count=2
arg	packed bytes ||| default encoding unicode_errors	count=1
function	[function_1] rec array ||| [function_2] [function_1]	count=4
arg	must already ||| key value	count=1
function	table reflecting the ||| table setup	count=2
class	into a ||| html frame parser	count=1
function	[function_1] sql ||| [function_1] [function_2]	count=2
arg	exist and be ||| value format	count=1
class	dataframe ||| data frame formatter	count=1
function_arg	dataframe [arg_2] ||| [arg_2] [function_1]	count=1
arg	as series or by ||| by axis	count=1
module	the built up ||| io formats	count=1
function	indexed ||| indexed	count=1
function	[function_1] rec ||| [function_2] [function_1]	count=4
arg	node must ||| value format	count=1
class	a ||| categorical	count=3
function	the series ||| series	count=2
function_arg	[function_1] sql ||| [function_1] [arg_2]	count=1
class	the underlying array ||| ops mixin	count=1
function	[function_1] histogram of ||| [function_2] [function_1]	count=2
function	reset the ||| reset	count=2
class	handling ||| index	count=1
class	return of an ||| index	count=1
function	parse the ||| parse	count=1
module	necessary for ||| sparse	count=1
function	[function_1] cast ||| [function_1] [function_2]	count=1
function	the symmetric difference of ||| symmetric difference	count=1
function	grouper ||| grouper	count=2
function	property synonym for as_blocks() ||| blocks	count=1
function	string cast it ||| maybe cast	count=1
function_arg	[function_1] two ||| [arg_2] [function_1]	count=20
function	to the block_manager ||| get block manager	count=1
arg	if key is a ||| key	count=2
function	converts json lists to ||| to	count=1
function	0 number [function_2] ||| [function_1] [function_2]	count=1
function	of casting ||| casting	count=1
module	packed ||| msgpack	count=1
function	to write ||| write	count=2
function_arg	returns first [arg_2] ||| [arg_2] [function_1]	count=2
function	to a ||| to index	count=1
function_arg	check whether [arg_2] ||| [arg_2] [function_1]	count=2
arg	or [arg_2] ||| [arg_2] [arg_1]	count=8
arg	return a new datacol ||| name cname	count=1
arg	from ndarray or ||| data index columns dtype	count=1
module	attribute if it has ||| core	count=1
function	ftypes ||| ftype	count=1
function	[function_1] raw ||| [function_1] [function_2]	count=1
function	the maximum by shading ||| max	count=1
class	the current [class] ||| [class]	count=1
function	want to construct this ||| array	count=1
class	from each group if ||| group by	count=1
arg	already exist and be ||| value format	count=1
arg	the _apply kwargs ||| name window center	count=1
function	[function_1] 1d array ||| [function_1] [function_2]	count=3
class	[class_1] the index ||| [class_1] [class_2]	count=3
class	return ||| frame parser	count=2
function	is ||| is	count=23
function	1 0 number format ||| number format	count=1
function	from a dataframe ||| from	count=1
module_class	[module_1] columns ||| [module_1] [class_2]	count=2
function	'numpy' library ||| with	count=2
function	reshape ||| reshape	count=1
function	hard to parse ||| parse	count=1
function	return an item pair ||| popitem	count=1
class	returns the float values ||| float array	count=1
arg	to ||| cls name	count=1
arg	file node must already ||| value format	count=1
arg	convert dataframe and ||| data	count=1
arg	stop_seq ||| stop_seq	count=1
function	the series extract groups ||| str extract	count=2
function	compute a simple cross-tabulation ||| crosstab	count=1
module	that do not throw ||| util	count=1
arg	values and other ||| other	count=1
arg	and be table ||| value	count=1
function	nat which has ||| nat new	count=1
function	compat ||| blklocs	count=1
function	datetime to [function_2] ||| [function_1] [function_2]	count=1
arg	floating point [arg] ||| [arg]	count=2
arg	a given width ||| arr width	count=1
arg	be table ||| value	count=1
function_arg	is [arg_2] ||| [arg_2] [function_1]	count=3
class	additional handling ||| period	count=1
class	dataframe with labeling information ||| data frame	count=1
arg	from some ||| cls	count=1
class	styler ||| styler	count=2
function	string-like that is object ||| convert string array	count=1
function	align a set ||| align	count=1
function	ensure that an ||| ensure	count=1
function_arg	[function_1] block by ||| [function_1] periods [arg_2]	count=1
class	group [class_2] ||| [class_2] [class_1]	count=1
function	the counts ||| counts	count=1
function	see :class packer ||| packb	count=1
class	to ||| index	count=1
arg	query in ||| index_col coerce_float	count=1
function	[function_1] monday instead ||| [function_2] [function_1]	count=3
arg	byte of the ||| column	count=1
function	[function_1] template and ||| [function_1] [function_2]	count=2
arg	[arg_1] on a ||| [arg_2] [arg_1]	count=1
module	from ||| indexes	count=1
function_arg	types [arg_2] ||| [arg_2] [function_1]	count=2
arg	sparse-compatible version of ||| indices axis convert	count=1
function	length slice ||| slice	count=1
function	block ||| make block	count=1
function	with decimal stride into ||| decimal	count=1
class	for more ||| ndframe	count=1
function	result set of ||| result	count=1
function	dtype [function_2] ||| [function_1] [function_2]	count=6
arg	y if ||| y	count=2
function_arg	[function_1] [arg_2] using the provided connection ||| io [function_1] [arg_2] params	count=1
function	parse ||| parse	count=4
arg	and ||| value format	count=1
arg	shape ||| shape	count=1
function	bool ||| bool	count=1
arg	to table ||| key value format	count=1
function	use ||| set	count=1
function	be used ||| build	count=1
class	to a dataframe ||| data frame	count=2
arg	fname are valid ||| fname	count=1
function	with integer stride parameters ||| stride from	count=1
arg	[arg_1] to ||| [arg_2] [arg_1]	count=4
function	reset the [function_2] ||| [function_1] [function_2]	count=6
class	data are ||| data frame	count=1
arg	cond ||| cond	count=1
arg	location parameters ||| loc	count=1
arg	[arg] see ||| o [arg]	count=1
class	apply ||| month offset	count=1
arg	by a ||| by	count=1
arg	frequency ||| end periods freq	count=3
arg	op ||| op	count=1
function	i am ||| is	count=1
class	as ||| ndframe	count=1
function_arg	[function_1] [arg_2] ||| [function_1] table_name [arg_2]	count=3
arg	to an ndarray copy ||| copy	count=1
class	a tree-like object ||| frame parser	count=1
function	compare numeric ||| numeric	count=1
module	only the ||| io json	count=1
function	type in ||| type	count=1
function	coerce ||| coerce	count=5
function_arg	[function_1] statement is ||| [function_1] [arg_2]	count=3
arg	i ||| i	count=3
function	rank ||| rank	count=1
arg	indexer fill ||| indexer allow_fill	count=1
function_arg	[function_1] [arg_2] rows/cols ||| [function_1] [arg_2]	count=1
function	block ||| for block	count=2
function	to an ||| to	count=8
function	group of ||| group	count=1
module	its values attribute ||| core	count=1
function_arg	[function_1] stop_seq ||| [function_1] to stop [arg_2]	count=1
class	return ||| as of merge	count=1
arg	helper function ||| rowlabels collabels	count=1
arg	date_format return a ||| date_format	count=1
function	return a dict of ||| get	count=1
function	apply if as_index=true ||| with as	count=1
arg	to table ||| format	count=1
arg	compared against itemsize ||| itemsize	count=1
function	blocks ||| blocks	count=2
arg	the dtype of ||| dtype	count=1
module	intervalindex ||| core indexes	count=1
function	round ||| round	count=4
module	index with business day ||| core indexes	count=1
function_arg	prettier version [arg_2] ||| [function_1] [arg_2]	count=1
module	of myself ||| core	count=2
function	perform a numeric ||| numeric	count=1
function	can be used ||| build	count=1
function	series/index ||| str repeat	count=2
function	[function] datetimeindex ||| [function]	count=1
function	scope ||| scope	count=1
module	a simple cross-tabulation of ||| core	count=1
class	a tree-like object ||| parser	count=1
function	ndarray only use ||| set value	count=1
function	return the dtypes ||| dtypes	count=1
arg	half-open [arg] ||| x [arg] right	count=3
arg	pattern ||| pat	count=1
function_arg	[function_1] unit ||| [arg_2] [function_1]	count=2
function_arg	[function_1] y ||| [function_1] x [arg_2]	count=2
class	interval ||| interval index	count=1
arg	after ||| result	count=3
function	the stata ||| stata	count=1
arg	generic moving function ||| arg window func	count=2
function	return dtype and ||| get empty dtype and	count=1
function	[function_1] cacher ||| [function_2] [function_1]	count=1
class	result block from ||| block	count=1
function	wrap op [function_2] ||| [function_2] [function_1]	count=1
function	number [function_2] ||| [function_2] [function_1]	count=1
function	return ||| packb	count=1
module	datetime index with business ||| core indexes	count=1
function	must already exist and ||| append	count=1
class	from 1-dimensional ndarray ||| index	count=1
arg	point [arg] nans ||| [arg]	count=1
arg	expected error ||| exc_type exc_value trace_back	count=1
function	series or dataframe only ||| series or dataframe	count=1
function	the maximum ||| max	count=1
arg	a column [arg_2] ||| [arg_2] [arg_1]	count=1
module	deleting the node ||| io	count=1
arg	la numpy percentile ||| q interpolation	count=1
class	checks whether the frame ||| frame	count=1
function	cast it ||| cast	count=1
function	this column return the ||| col	count=1
function	id of ||| id	count=1
arg	data to ||| data groups dropna label	count=1
class	float values ||| float	count=1
function	from 1-dimensional ndarray ||| value	count=1
function	the put method ||| put	count=1
arg	dataframe columns ||| data	count=1
function	[function_1] description ||| [function_1] [function_2]	count=1
function	[function_1] [function_2] ||| [function_1] [function_2] arg format infer_time_format errors	count=3
arg	simple cross-tabulation ||| columns	count=1
function	validate that an positional ||| valid positional setitem	count=1
arg	converts a style_dict ||| style_dict	count=2
arg	possibly upcast ||| mgr	count=1
function	take values according to ||| take nd	count=2
function	extension ||| check extension	count=1
function_arg	[function_1] [arg_2] ||| [function_1] blocknd values [arg_2]	count=2
function	index are equal ||| almost equal	count=1
function	a sparseseries [function] ||| sparse series [function]	count=2
class	be used to ||| parser	count=1
class	get ||| multi index	count=1
arg	dtype ||| dtype	count=6
class	if it has ||| series	count=1
arg	and 'kwargs' ||| method args kwargs	count=2
arg	or ||| axis	count=2
class	datetimeindex with ||| index	count=1
function	all [function_2] ||| [function_1] [function_2]	count=1
function	functions ||| rename axis	count=2
arg	perform ||| level limit tolerance	count=1
function	views note this is ||| is	count=1
function	like ||| like	count=1
function	can be used to ||| build	count=1
function	return an [function_2] ||| [function_2] [function_1]	count=2
function	get all ||| get	count=1
function_arg	[function_1] value ||| [function_1] can do op [arg_2]	count=1
module	is ||| core dtypes	count=3
class	our ||| period index resampler	count=1
function	rec array and create ||| rec array to	count=1
function	that create a ||| create	count=1
arg	object with labels in ||| labels	count=1
arg	from ||| cls	count=1
function_arg	arr1 [arg_2] ||| [function_1] arr1 [arg_2]	count=3
function_arg	index [arg_2] ||| [arg_2] [function_1]	count=5
arg	already ||| key value format	count=1
arg	data to an ndarray ||| data	count=1
function	be ||| append	count=1
arg	evaluate [arg] ||| [arg]	count=1
class	of that group ||| group by	count=1
function_arg	[function_1] to ||| [function_1] disabled [arg_2]	count=2
function_arg	[function_1] [arg_2] ||| [function_1] [arg_2] new_mgr_locs fill_tuple	count=10
function	raw ||| raw	count=1
function	to be ||| as	count=1
class	index or ||| datetime index ops mixin	count=1
function_arg	categorical possibility ||| categorical array	count=1
function	index are equal ||| assert almost equal	count=2
module_class	[module_1] unaltered ||| [module_1] [class_2]	count=8
module	see ||| msgpack	count=1
function_arg	[function_1] of times ||| [function_1] [arg_2]	count=1
function_arg	bytes [arg_2] ||| [arg_2] [function_1]	count=1
class	have ||| categorical	count=1
function	sequence of objects ||| sequence	count=1
arg	file ||| key value format	count=1
arg	other to ||| other	count=2
class	datetimeindex ||| index	count=1
function	the dtype [function_2] ||| [function_1] [function_2]	count=2
module	plots ||| plotting	count=1
class	not on offset ||| offset	count=1
arg	group_index is ||| group_index	count=1
function	[function_1] a sql ||| [function_2] [function_1]	count=2
module	you ||| core	count=1
function_arg	location [arg_2] ||| [function_1] [arg_2]	count=6
function	of the required package ||| package	count=1
module	the function ||| io formats	count=2
function	encoding ||| encoding	count=1
class	[class_1] value is ||| [class_1] [class_2]	count=4
arg	values along [arg_2] ||| [arg_2] [arg_1]	count=1
function	are a view ||| view	count=1
arg	the specified dtype ||| result dtype	count=1
arg	cartesian product of all ||| shape sort	count=1
arg	indexer input [arg_2] ||| [arg_2] [arg_1]	count=1
function	gets called ||| array	count=3
function	gets the ordered attribute ||| ordered	count=1
arg	wrapper function [arg] appropriate ||| [arg] arg	count=1
function_arg	[function_1] a code ||| [function_1] [arg_2]	count=3
function	all ||| all	count=2
arg	query ||| index_col coerce_float	count=1
function_arg	[function_1] other to ||| [function_1] values [arg_2]	count=1
arg	database ||| table_name	count=1
function	midnight length is unaltered ||| normalize	count=1
arg	a ||| columns	count=1
arg	we have a ||| cls	count=1
class	panel objects and will ||| panel	count=1
class	by ||| group by	count=2
class	interval in [class_2] ||| [class_1] [class_2]	count=1
class	gets called after ||| index	count=2
function	rewrite the ||| rewrite assign	count=1
arg	already ||| value	count=1
class	indicating ||| ndframe	count=1
function	parse datetime ||| parse time	count=1
function	[function_1] object dtype ||| [function_1] [function_2]	count=6
arg	the nan/nat from ||| val	count=1
module	to ||| core tools	count=1
class	reshape data (produce ||| data frame	count=1
class	with blockmanager ||| single block manager	count=4
arg	[arg_1] arr2 ||| [arg_1] [arg_2]	count=3
function	we need to coerce ||| coerce	count=1
arg	sql and params args ||| sql params	count=1
function	by str df in ||| str	count=1
arg	draw ||| frame alpha figsize ax	count=1
function	validate that an positional ||| has valid positional setitem	count=1
function	rows ||| rows	count=1
function	as dataframe ||| to frame	count=1
arg	on 3 columns ||| columns	count=1
module	in file node must ||| io	count=1
function	that we have ||| validate ordered	count=1
arg	to indexer ||| indexer axis	count=2
arg	already ||| key	count=1
arg	elements of v should ||| v	count=1
function	type to ||| table type	count=1
function	try to cast the ||| try cast	count=1
function_arg	[function_1] [arg_2] ||| [function_1] excel [arg_2]	count=2
arg	background null_color ||| null_color	count=1
class	return datetimeindex with ||| datetime	count=1
function	[function_1] plan ||| [function_1] [function_2]	count=1
arg	[arg_1] is ||| [arg_1] [arg_2]	count=1
function	[function_1] a file-like ||| [function_1] [function_2]	count=1
arg	compute a simple ||| index	count=1
class	index objects contain the ||| datetime index ops mixin	count=1
arg	file node ||| value format	count=1
class	sort multiindex at the ||| multi index	count=1
function	excel ||| excel	count=1
function	a full length ||| full	count=1
arg	returning a ||| ignore_index verify_integrity	count=1
class	object that ||| parser	count=1
function	return true if ||| is	count=5
arg	check that [arg] comparable attributes ||| [arg]	count=1
module	i am never ||| core	count=1
function	axes if supplied ||| axes	count=1
function	[function_1] full length ||| [function_2] [function_1]	count=1
function	[function_1] the values ||| [function_1] [function_2]	count=1
module	new [module] with ||| [module]	count=1
arg	iter1 iter2 iterables that ||| iter1 iter2	count=1
function_arg	[function_1] when non-unique ||| [function_1] [arg_2]	count=1
function	of ||| value	count=1
class	ndarray only use this ||| categorical index	count=1
function	the put method to ||| put	count=1
class	creating [class] binner & ||| [class]	count=1
arg	shape of ||| ndim shape	count=1
function	dtype and n/a values ||| dtype and	count=1
arg	pasted [arg] example ||| [arg]	count=1
function	might need to coerce ||| coerce	count=1
module	maps[0] raise keyerror ||| compat	count=1
class	length is ||| index	count=1
arg	are going ||| obj data_columns	count=1
function	string-like that is ||| string array	count=1
function	get integer [function_2] ||| [function_2] [function_1]	count=4
arg	[arg_1] [arg_2] a fixed-format series ||| [arg_1] [arg_2]	count=4
function_arg	[function_1] protection_dict ||| [function_1] to protection [arg_2]	count=1
function	[function_1] location ||| [function_2] [function_1]	count=4
module	see :class packer ||| msgpack	count=1
function	join [function_2] ||| [function_2] [function_1]	count=2
function	la re split ||| split	count=1
module	packer ||| io msgpack	count=2
function	a named [function_2] ||| [function_2] [function_1]	count=1
function	true if categoricals are ||| equal	count=1
function_arg	apply [arg_2] ||| [function_1] [arg_2]	count=4
arg	exist and be ||| key value	count=1
arg	and a date_format return ||| date_format	count=1
class	infer ||| parser base	count=1
function_arg	[function_1] other ||| [function_1] [arg_2]	count=1
function_arg	string and pads it [function_1] [arg_2] chars ||| [function_1] [arg_2]	count=1
class	multiindex at ||| multi index	count=1
arg	are available on the ||| prefix normalize locale_getter	count=1
function	of entries in index ||| index	count=1
arg	regular expression pat ||| pat flags	count=2
function_arg	ensure that [arg_2] ||| [function_1] scope [arg_2]	count=2
arg	python expression as ||| expr	count=1
function	and ||| and	count=2
function	a multi ||| multi	count=2
class	maps[0] raise ||| map	count=1
arg	this ||| arr key	count=1
function	called prior to ||| array prepare	count=1
function	returns axes ||| axes	count=1
arg	in ||| value	count=1
function_arg	[function_1] [arg_2] ||| [function_1] scope [arg_2]	count=2
function	of the stata ||| stata	count=1
function_arg	given [arg_2] ||| [function_1] level lengths [arg_2]	count=1
function	group [function_2] ||| [function_2] freq [function_1]	count=1
function	[function_1] a method ||| [function_2] [function_1]	count=1
class	array repr of this ||| period index	count=1
arg	and [arg_2] ||| [arg_2] [arg_1]	count=11
module	exist and be table ||| io	count=1
function	return the bool ||| bool	count=1
module	bytes see :class packer ||| msgpack	count=1
function	[function_1] types format ||| [function_1] [function_2]	count=6
function	must be sparseseries or ||| maybe to	count=1
function	return the ftypes (indication ||| ftypes	count=1
arg	dtype converting float ||| value dtype errors	count=1
arg	terms for ||| terms	count=1
function	the node with the ||| get node	count=1
function	panel to [function_2] ||| [function_2] [function_1]	count=1
function_arg	of casting [arg_2] ||| [arg_2] [function_1]	count=5
class	a single ||| ndframe	count=1
arg	as a dataframe ||| data values	count=1
function	[function_1] unary ||| [function_2] [function_1]	count=1
arg	dtype converting ||| value dtype errors	count=1
arg	values values ||| values method	count=1
class	object that ||| frame	count=1
arg	table in file ||| key value format	count=1
function_arg	symmetric difference [arg_2] ||| [arg_2] [function_1]	count=1
arg	draw a ||| frame alpha figsize ax	count=1
function	want to set the ||| set	count=1
function	for akima ||| akima	count=1
function	must be sparseseries ||| maybe to	count=2
function	numpy / pandas type ||| table type	count=1
arg	right ||| right strict_nan	count=1
function	convert timedelta-like ||| td index cmp	count=1
function	[function_1] result set ||| [function_1] [function_2]	count=1
function	return the strides ||| strides	count=1
function	a malformed row ||| malformed	count=1
function	[function_1] sparsearray ||| [function_1] [function_2]	count=2
arg	values can be ||| values name	count=1
arg	check ||| obj	count=7
module_class	[module_1] datetime ||| [module_1] [class_2]	count=2
arg	file ||| format	count=1
function	that create ||| create	count=1
module	the number ||| indexes	count=2
arg	the values ||| values	count=2
function_arg	[function_1] a function ||| [function_1] [arg_2]	count=1
arg	arr to have shape ||| arr	count=1
function	that ||| dtype	count=1
function	a datetime with tz ||| datetimetz	count=1
function	add numeric [function_2] ||| [function_1] [function_2]	count=1
module_class	[module_1] categorical instance ||| [module_1] [class_2]	count=1
function	setup ||| set	count=3
function	for a particular ||| bytes	count=1
function	quickly set [function] ||| set [function]	count=1
arg	ndarray ||| arr key	count=1
function_arg	[function_1] ncols - ||| [function_1] nrows [arg_2]	count=1
class	excluding ||| group by	count=1
function_arg	[function_1] labels using ||| [function_1] keys drop append [arg_2]	count=1
function	be used to iterate ||| build	count=1
arg	single [arg] at ||| label [arg]	count=1
arg	indexer ||| indexer	count=7
module	built up styles ||| formats	count=1
arg	decorator to run ||| num_threads kwargs_list	count=1
function_arg	a date column ||| date data	count=1
function	table in ||| append	count=1
function	with decimal stride ||| decimal	count=1
function_arg	[function_1] a dataframe ||| [function_1] [arg_2]	count=1
function	little ||| little	count=1
function	validate [function_2] ||| [function_2] [function_1]	count=1
class	block for ||| block	count=1
module_class	return series ||| core series	count=2
function	for instances of pandasobject ||| any pandas objects	count=1
module	same dimensions as the ||| core	count=1
arg	and [arg] have equal ||| left [arg]	count=1
arg	result set ||| result	count=1
function_arg	[function_1] names defaulting ||| [arg_2] [function_1]	count=4
arg	already exist ||| key value format	count=1
function	[function_1] options for ||| [function_2] [function_1]	count=3
arg	dataframe ||| frame	count=2
function	to a set of ||| to	count=1
function	try to connect to ||| connect	count=1
class	keyerror ||| chain map	count=1
arg	[arg] appropriate ||| [arg] arg	count=1
class	needs additional ||| period index	count=1
function	length of this ||| len	count=1
arg	and plural 'names' parameter ||| name names deep	count=1
class	return a tree-like object ||| frame	count=1
module	the other ||| core	count=1
function	:mod datetime to ||| to	count=1
arg	superclass ||| superclass	count=1
function	to set ||| set	count=1
arg	[arg] will ||| [arg]	count=2
module	object with the ||| core	count=1
function	to a leap year ||| leap year	count=1
arg	than a given width ||| width	count=1
class	sql ||| sqldatabase	count=1
class	[class] current that ||| [class]	count=2
module	& with [module] | with ||| [module]	count=1
arg	the [arg] to a ||| [arg]	count=1
function	[function_1] given offset/observance ||| [function_2] [function_1]	count=1
arg	on where ||| key where	count=1
function_arg	integer location slice ||| loc key	count=1
arg	as a dataframe ||| data	count=1
arg	return an ||| axes	count=1
function	an ||| to	count=2
class	called after ||| series	count=1
function	header rows in multiindex ||| pop header name	count=1
function	box function ||| box func	count=1
class	return ||| map	count=1
class	internal property property ||| ndframe	count=1
function	returns an iterator over ||| iter	count=1
module	same ||| core	count=1
arg	[arg] offsets into ||| [arg]	count=1
function	belongs to a leap ||| leap	count=1
class	that dict has ||| parser	count=1
module	indexes ||| indexes	count=1
module	we ||| core indexes	count=1
function	if ||| for	count=1
class	the current [class] going ||| [class]	count=1
function	connect to ||| can connect	count=1
arg	[arg] see :class ||| o [arg]	count=1
function_arg	in [arg_2] ||| [arg_2] [function_1]	count=4
arg	as the default frequency ||| freq	count=2
function_arg	operations [arg_2] ||| [function_1] [arg_2]	count=4
function	that we all have ||| dtype	count=1
class	a datetimeindex but for ||| datetime	count=1
arg	upgrading in ||| mode propindexes keys	count=1
function	type is ||| is	count=3
class	i ||| categorical	count=1
function	categories ||| categories	count=1
function_arg	[function_1] duplicate values ||| [function_1] [arg_2]	count=1
function	from the [function_2] ||| [function_2] [function_1]	count=2
function	deprecated option [function_2] ||| [function_2] [function_1]	count=8
function_arg	[function_1] a ufunc ||| [arg_2] [function_1]	count=3
function	validates that we ||| validate ordered	count=1
arg	if you ||| arr	count=1
arg	higher ||| cls value	count=1
function	parse datetime string ||| parse time string	count=1
arg	array to the key ||| key	count=1
function	term ||| term	count=1
function	create the manager ||| mgr	count=1
function_arg	[function_1] into a ||| [arg_2] [function_1]	count=2
function_arg	in y if ||| in x y	count=1
module	sparse/dense and ||| core	count=1
module	an expression in ||| computation	count=1
class	styles to html ||| styler	count=1
function	[function_1] named tuple ||| [function_1] [function_2]	count=1
function	index ||| set value	count=2
module_class	[module_1] data for ||| [module_1] [class_2]	count=2
arg	left-join except ||| left right on left_on	count=1
function	process of casting ||| safe casting	count=1
function	sequence of ||| sequence	count=1
function	categories ||| get categories	count=1
module	string-like attributes from the ||| core	count=1
arg	higher [arg_2] ||| [arg_2] [arg_1]	count=3
function	byte ||| rands	count=1
function	decorator to capture ||| capture	count=1
function_arg	method [arg_2] ||| [function_1] [arg_2]	count=4
function	the numeric add/sub ||| numeric	count=1
module	to ||| io	count=3
arg	name ||| name	count=2
arg	rows if n ||| n dropna	count=1
arg	plural 'names' parameter for ||| name names deep	count=1
class	as ||| sparse series	count=1
function	integer stride [function_2] ||| [function_1] [function_2]	count=1
class	file node ||| hdfstore	count=1
function	1-dimensional ndarray only use ||| set value	count=1
function_arg	node with [arg_2] ||| [function_1] [arg_2]	count=3
arg	returning ||| inplace verify_integrity	count=1
arg	[arg_1] [arg_2] using the provided connection ||| [arg_1] [arg_2] cur params	count=1
function_arg	[function_1] against ||| [arg_2] [function_1]	count=5
module_class	[module_1] columns excluding ||| [module_1] [class_2]	count=2
function	to convert to dense ||| to dense	count=1
function	to get ||| get index	count=1
function	a feather-format object ||| feather	count=1
function	an attributes dict ||| attributes dict	count=1
function	a custom template and ||| custom template	count=1
function	prior to ||| array prepare	count=1
function	a sequence ||| sequence	count=1
function	the expected ||| expected	count=1
function	return the counts ||| get ftype counts	count=2
arg	fast lookup of value ||| key value	count=1
function	a categorical if ||| categorical	count=1
function_arg	writing stata binary ||| to stata fname	count=1
class	calling [class] instance ||| [class]	count=1
module	times to midnight ||| core indexes	count=1
class	that group ||| group by	count=1
function	stata date formats to ||| datetime to stata	count=1
arg	values ||| values name freq	count=1
arg	generic moving ||| window	count=1
arg	node must already exist ||| key value	count=1
module	maps[0] raise ||| compat	count=1
arg	[arg_1] given axis ||| [arg_2] [arg_1]	count=1
function_arg	[function_1] dataframe the ||| [arg_2] [function_1]	count=1
module	in this object ||| core	count=1
arg	label ||| label	count=5
function_arg	value [arg_2] ||| [arg_2] [function_1]	count=6
function_arg	[function_1] [arg_2] provided connection object ||| io [function_1] [arg_2] params	count=1
function_arg	[function_1] from ||| [function_1] [arg_2]	count=2
function	data the shifted ||| slice	count=1
function_arg	[function_1] and other ||| [function_1] values [arg_2]	count=1
module	the index ||| io json	count=2
class	and ||| chain map	count=1
class	a dense ||| sparse	count=1
module	if we ||| indexes	count=1
arg	equivalent to left <= ||| left	count=1
class	to ||| html frame parser	count=2
function	for header rows in ||| pop header	count=1
function_arg	[function_1] as the ||| [function_1] [arg_2]	count=1
arg	a table ||| table	count=1
function	ndarray only use ||| set	count=1
function	indices that would sort ||| argsort	count=2
module	be table ||| io	count=1
class	the underlying ||| range	count=1
module	as a unicode string ||| core indexes	count=1
arg	provided array or ||| arr_or_dtype	count=3
function	in a block of ||| make block	count=1
arg	passed [arg] ||| [arg]	count=2
module	more this is index ||| core	count=1
function	append ||| append	count=1
class	datetimeindex with ||| datetime	count=1
function	to parse ||| to	count=1
function	if we are a ||| safe for reshape	count=2
class	they are valid stata ||| stata	count=1
function	only use ||| set	count=1
function	display options for printing ||| display options	count=1
module	shade the ||| io formats	count=2
arg	arg is a passed ||| arg	count=1
function	indices overlap ||| overlap	count=1
function	concat ||| concat index	count=1
function	[function_1] sparse array ||| [function_2] [function_1]	count=3
class	return a ||| categorical	count=1
class	into a list ||| parser	count=1
function	bool of a ||| bool	count=1
class	is an ||| categorical index	count=2
function	a scalar to ||| scalar to	count=2
function	the ndarray flags ||| flags	count=1
class	class ||| pandas	count=1
arg	file node must already ||| key value	count=1
function	metaclass ||| add metaclass	count=1
function	and return a basegrouper ||| get	count=1
arg	query or database table ||| index_col coerce_float	count=1
function	values ||| values	count=5
rep	[module_class_1] [function_arg_2] ||| [module_class_1] construct [function_arg_2]	count=4
function	package is ||| package	count=1
module	dict has only the ||| io json	count=1
module	if it has one ||| core	count=1
function_arg	[function_1] other to ||| [arg_2] [function_1]	count=2
arg	y if possible ||| y	count=2
class	parse ||| excel file	count=1
class	multiindex from the ||| multi	count=1
module	used to iterate over ||| io	count=1
function_arg	the where statement ||| where w	count=1
function	other ||| numeric binop	count=1
class	midnight length ||| index	count=1
arg	exist and be table ||| value	count=1
function_arg	[function_1] of terms ||| [function_1] [arg_2]	count=1
class	i am ||| categorical block	count=1
arg	columns of this dataframe ||| index columns values	count=1
function	slice the info axis ||| get info slice	count=1
function_arg	not in [arg_2] ||| [function_1] x [arg_2]	count=4
class	a new multiindex ||| multi	count=1
class	in sparse ||| sparse	count=1
function	can ||| build	count=1
module_class	indices that would sort [module_1] [class_2] 'sort_values' was called ||| [module_1] [class_2]	count=1
arg	obj with [arg_2] ||| [arg_1] [arg_2]	count=1
function	result set coerce the ||| coerce	count=1
class	more this is ||| ndframe	count=1
function	from a a ||| from	count=1
arg	compatiable fill_value and ||| fill_value	count=1
function_arg	[function_1] [arg_2] ||| [function_1] arr [arg_2]	count=2
function_arg	and [arg_2] ||| [function_1] values [arg_2]	count=1
function	a leap ||| is leap	count=1
module	options ||| io msgpack	count=2
class	don't care [class_2] ||| [class_1] [class_2]	count=1
arg	a simple cross-tabulation ||| columns values	count=1
function	[function_1] count of ||| [function_2] [function_1]	count=1
function	[function_1] method ||| [function_2] [function_1]	count=1
class	series ||| frame	count=1
arg	_apply kwargs ||| name window center	count=1
module	values [module] series using ||| [module]	count=1
class	after ||| index	count=2
arg	values to [arg_2] ||| [arg_1] [arg_2]	count=1
arg	function [arg] ||| [arg] kwargs	count=3
arg	or columns using input ||| axis copy inplace	count=1
class	validates ||| categorical	count=1
module	check [module] the min/max ||| [module]	count=1
function_arg	coerce [arg_2] ||| [arg_2] [function_1]	count=3
function	a block of ||| make block	count=1
class	[class] column ||| [class]	count=3
arg	of ||| index columns	count=1
function	empty ||| empty	count=1
function	temporarily setting a timezone ||| set timezone	count=1
module	dtypes ||| dtypes	count=1
arg	codes by the indexer ||| indexer allow_fill	count=1
arg	a a left and ||| cls left	count=1
function	returns the base ||| get base	count=1
class	to dataframe ||| data frame	count=2
arg	only use this ||| arr	count=1
arg	to have [arg_2] ||| [arg_2] [arg_1]	count=1
module	index with business ||| core indexes	count=1
arg	encode input values as ||| values sort	count=1
class	is index ||| ndframe	count=1
function	apply [function_2] ||| [function_1] [function_2]	count=2
arg	fast lookup of ||| key	count=1
class	in this ||| ndframe	count=1
function_arg	cartesian product [arg_2] ||| [function_1] [arg_2]	count=1
arg	from ndarray or list ||| data index columns	count=1
arg	possibly local context ||| key is_local	count=1
arg	blocks collect ||| axis consolidate transposed	count=1
arg	c_idx_names ||| c_idx_names	count=1
arg	given width ||| arr width	count=1
function	custom [function_2] ||| [function_1] [function_2]	count=2
arg	convenience function ||| xi yi x	count=1
function	try to parse ||| try convert	count=1
function	[function_1] result and ||| [function_2] [function_1]	count=2
function	formats to [function_2] ||| [function_2] [function_1]	count=2
arg	converts a style_dict ||| cls style_dict num_format_str	count=3
function	of bytes in ||| nbytes	count=2
function	the levels ||| levels	count=1
arg	column values ||| values	count=1
function_arg	[function_1] in type_map ||| [arg_2] [function_1]	count=9
class	to midnight ||| index	count=1
function	is valid for ||| is valid dtype	count=1
class	numpy array of datetime ||| datetime	count=1
arg	is ||| scope_level	count=1
function	best locator ||| get locator	count=1
function_arg	[function_1] [arg_2] ||| [function_1] tuples [arg_2]	count=2
arg	[arg_1] and arr2 ||| [arg_2] [arg_1]	count=3
arg	[arg] dtype ||| [arg]	count=2
function	[function_1] locales that ||| [function_1] [function_2]	count=1
function	from the ||| from	count=2
module	this object ||| core indexes	count=1
function	a locale ||| set locale	count=1
function	return copy of the ||| copy	count=1
function	are index sliceable then ||| convert to index sliceable	count=1
function_arg	[function_1] nan/nat ||| [function_1] [arg_2]	count=4
function	a list of term ||| term	count=1
function_arg	[function_1] type_map ||| [function_1] [arg_2]	count=9
arg	curve with ||| start end return_name	count=1
module	return a ||| io	count=1
function	numpy doesn't like to ||| v string like	count=1
class	raise keyerror is maps[0] ||| chain	count=1
arg	key and are not ||| key	count=1
function	csv file (discouraged ||| csv	count=2
function_arg	[function_1] node like ||| [function_1] [arg_2]	count=1
arg	called after ||| result	count=3
arg	set of terms ||| terms	count=1
function	doesn't like to compare ||| string like	count=1
module	of this ||| core	count=2
function	boolean if values in ||| is	count=1
module	interval ||| core indexes	count=1
function	write this as a ||| write	count=2
class	only applicable to ||| series group by	count=2
function	to sif [function_2] ||| [function_2] [function_1]	count=1
function	options grouped ||| pp options	count=1
arg	the fill_value ||| allow_fill fill_value	count=1
function	stride parameters ||| get stride from	count=2
function	axes compute the expected ||| expected	count=1
arg	[arg_1] [arg_2] ||| [arg_1] [arg_2]	count=458
class	each ||| data frame	count=1
function_arg	[function_1] substrings ||| [function_1] arr [arg_2]	count=1
function	numeric ||| add numeric	count=1
function	use this ||| value	count=1
function	names ||| names	count=1
function	scalar [function_2] ||| [function_1] [function_2]	count=7
class	return ||| range index	count=1
function_arg	[function_1] period frequency ||| [function_1] i [arg_2]	count=1
function	level ||| level	count=3
arg	cross-tabulation of ||| index	count=1
class	index objects and sorts ||| index	count=1
arg	temporarily setting a ||| new_locale lc_var	count=1
function	coerce the ||| coerce	count=2
function	the length of this ||| len	count=1
function	must already ||| append	count=1
function_arg	series [arg_2] ||| [arg_2] [function_1]	count=9
class	object that can be ||| html frame	count=1
function	rewrite ||| rewrite assign	count=2
function	strings to [function_2] ||| [function_1] [function_2] arg format infer_time_format errors	count=2
class	value ||| array formatter	count=1
arg	needs additional handling ||| result	count=1
arg	style_dict ||| cls style_dict	count=2
function	read from a ||| read	count=1
function	the block ||| create for block	count=1
function_arg	[function_1] of other ||| [function_1] [arg_2]	count=1
rep	the dataframe [function_arg_2] ||| [module_class_1] [function_arg_2]	count=4
function_arg	for [arg_2] ||| [function_1] [arg_2]	count=3
function	[function_1] columns as ||| [function_1] str [function_2]	count=1
class	of a frame ||| data frame	count=1
class	tree-like object ||| html	count=1
function_arg	define an [function_1] [arg_2] ||| [function_1] [arg_2]	count=8
class	series to a ||| series	count=1
module	for series columns ||| core	count=1
arg	refer to numpy ndarray ||| repeats	count=1
module	is of ||| core	count=1
function	via the 'numpy' library ||| with convert	count=1
function	intervalindex from [function_2] ||| [function_1] [function_2]	count=2
arg	to ||| format	count=1
function	is empty ||| is line empty	count=1
function	return dtype and n/a ||| empty dtype and	count=1
arg	packed object return ||| packed object_hook list_hook	count=1
arg	from ndarray ||| index	count=1
module	json ||| io json	count=2
function	compute the symmetric ||| symmetric	count=1
function	dataframe are equal ||| assert frame equal	count=2
module	to midnight ||| indexes	count=1
module	array object has a ||| core dtypes	count=1
arg	cross-tabulation ||| columns	count=1
arg	iter2 iterables that produce ||| iter2	count=1
arg	incoming data ||| data	count=1
module	validates ||| core	count=1
class	handling ||| period index	count=2
arg	see ||| other how level return_indexers	count=1
class	item from object ||| ndframe	count=1
arg	[arg_1] in ||| eval [arg_1] [arg_2]	count=2
arg	return item ||| item	count=1
arg	input function ||| mapper axis copy	count=1
arg	if ||| arr	count=1
function	unordered ||| unordered	count=1
function	a float ||| float	count=1
function	return a formatter function ||| get	count=1
function	index names to 'index' ||| set default names	count=1
function_arg	[function_1] number_format_dict ||| [function_1] to number format [arg_2]	count=1
arg	we are going ||| obj data_columns	count=1
arg	generic moving function ||| window func	count=1
function	the info axis ||| info	count=1
function	[function_1] function for ||| [function_2] [function_1]	count=4
arg	new type ||| dtype copy	count=2
class	datetime date objects (namely ||| datetime index	count=1
arg	multiple [arg_2] ||| [arg_2] [arg_1]	count=4
function	get test ||| get test	count=1
function_arg	[function_1] [arg_2] ||| [function_1] sparse series [arg_2]	count=2
arg	function to my values ||| func mgr	count=1
module	from maps[0] ||| compat	count=1
module	to midnight length ||| core	count=1
arg	in ||| arr pat	count=1
class	a frame table ||| appendable multi series table	count=1
function	header rows in ||| header	count=1
function	a string cast ||| maybe cast	count=1
arg	columns using input ||| mapper axis copy inplace	count=1
arg	new datacol with the ||| name cname	count=1
function	called after a ||| array wrap	count=3
class	index [class_2] ||| [class_1] [class_2]	count=2
class	/ try_operate ||| time delta block	count=1
function	series extract groups from ||| extract	count=1
class	dataframe ||| ndframe	count=3
class	the list ||| list	count=1
arg	or columns using ||| inplace	count=1
arg	in file ||| value format	count=1
function	a data ||| data columns	count=1
class	of group [class_2] ||| [class_1] [class_2]	count=1
function_arg	exception [arg_2] ||| [function_1] matches [arg_2]	count=3
function_arg	this is *not* ||| is other	count=1
function	[function_1] thereafter ||| [function_1] [function_2]	count=2
function	self as a ||| as	count=1
module_class	[module_1] data ||| [module_1] [class_2]	count=12
class	additional ||| index	count=1
class	the number of ||| range index	count=1
function	box ||| box	count=1
function_arg	from the [arg_2] ||| [arg_2] [function_1]	count=1
module	to iterate over ||| io	count=1
module	this is ||| reshape	count=1
class	[class] essentially ||| [class]	count=2
module	called after ||| core indexes	count=2
arg	in ||| arr	count=1
module	see :class ||| io msgpack	count=1
function_arg	[function_1] string raise ||| [function_1] [arg_2]	count=2
arg	that left and right ||| left right check_dtype check_index_type	count=1
function_arg	[function_1] this argument ||| [arg_2] [function_1]	count=3
arg	using input function ||| axis copy inplace	count=1
class	reindex ||| categorical index	count=1
function	get all the locales ||| get locales	count=1
function	the given quantile ||| quantile	count=1
arg	that ||| tok	count=1
arg	a left-join except ||| left right on left_on	count=1
module	1-dimensional ndarray only use ||| indexes	count=1
function	a block ||| block	count=1
function	tree-like object ||| build	count=1
function_arg	[function_1] the indexer ||| [function_1] [arg_2]	count=1
function	single [function] at passed ||| [function]	count=1
class	<= series ||| series	count=1
module	a tree-like ||| io	count=1
function	options grouped ||| options	count=1
class	block it ||| block	count=1
function_arg	period [arg_2] ||| [arg_2] [function_1]	count=1
class	return datetimeindex ||| index	count=1
arg	fast lookup ||| arr key	count=1
function_arg	with [arg_2] ||| [arg_2] [function_1]	count=3
function	[function_1] indexers ||| [function_1] [function_2]	count=6
arg	a dataframe the levels ||| data values index	count=1
arg	function designed ||| func	count=1
function	for writing stata ||| to stata	count=1
function_arg	locales [arg_2] ||| [function_1] [arg_2]	count=1
function_arg	[function_1] return fillvalue ||| [function_1] [arg_2]	count=3
arg	table in file ||| value	count=1
arg	axis of ||| axis	count=1
function	[function_1] time objects ||| [function_2] [function_1]	count=3
module	packed bytes see ||| io msgpack	count=1
arg	a ||| result	count=3
class	my ||| fixed	count=1
function	index names to ||| default names	count=1
function	convert from sif to ||| elapsed date to	count=1
function	we have ||| ordered	count=1
module	to table in file ||| io	count=1
module_class	from the table ||| io table	count=1
function_arg	[function_1] expected ||| [function_1] matches [arg_2]	count=3
arg	[arg] belongs ||| [arg] bins right	count=3
function	header rows in ||| pop header name	count=1
module	only ||| core indexes	count=3
arg	the shape ||| ndim shape	count=1
arg	left and right ||| left right exact	count=1
function	the dom ||| doc	count=1
arg	already ||| key value	count=1
function	compare numeric ||| is numeric	count=1
function	[function_1] scatter ||| [function_2] [function_1]	count=4
function	[function_1] axis ||| [function_2] [function_1]	count=1
function	[function_1] indexers ||| [function_2] [function_1]	count=6
class	sort multiindex ||| multi	count=1
arg	already exist and ||| key value	count=1
class	a single block ||| block manager	count=1
class	index ||| ndframe	count=1
function	[function_1] sql ||| [function_2] [function_1]	count=2
function	that create a table ||| create table	count=1
function	[function_1] full ||| [function_1] [function_2]	count=1
class	object that can ||| html frame	count=1
function	evaluate and ||| evaluate	count=1
function	a float dtype if ||| float	count=1
function	numeric ||| numeric v string	count=1
arg	of n between self ||| n axis	count=1
class	to iterate over the ||| html frame	count=1
arg	ndarray or ||| index	count=1
class	series we ||| series group	count=1
function	the cacher ||| cacher	count=1
function	string-like array to ||| string to	count=3
function	we ||| is	count=3
arg	node ||| key value	count=1
class	for more this ||| ndframe	count=1
class	tree-like object that ||| frame parser	count=1
function	insert ||| insert	count=1
function	detect terminal [function_2] ||| [function_1] [function_2]	count=4
function	sparsearray ||| sparse	count=1
function	dropna if fill_value=nan returns ||| dropna	count=1
function	from a ||| from string	count=2
function	the series [function_2] ||| [function_1] [function_2]	count=2
function	expected exception and ||| exception	count=1
function	note cannot [function] time64col() ||| create [function]	count=1
arg	compute ||| columns values	count=1
arg	must already ||| key value format	count=1
function	to scipy ||| scipy	count=1
function	reindex for all ||| reindex	count=1
function	manipulation result has ||| constructor	count=1
arg	[arg_1] is a ||| [arg_2] [arg_1]	count=1
function_arg	quickly retrieve [function_1] [arg_2] ||| [function_1] index [arg_2] takeable	count=2
function	[function_1] [function_2] ||| [function_1] methods [function_2]	count=1
function_arg	[function_1] [arg_2] ||| [function_1] i [arg_2]	count=3
arg	freq with integer ||| freq	count=1
module	and be ||| io	count=1
function_arg	[function_1] from ndarray ||| [arg_2] [function_1]	count=1
module	object datetimeindex ||| core dtypes	count=1
arg	i and j in ||| i j copy	count=1
function_arg	to add [arg_2] ||| [function_1] ops [arg_2]	count=2
function	node ||| append	count=1
arg	where is ||| where scope_level	count=2
function	from ||| set	count=1
arg	right ||| right check_dtype check_index_type	count=1
arg	only ||| arr key	count=1
arg	according to indexer ||| indexer axis	count=2
function	floating ||| maybe cast indexer	count=1
arg	as the default frequency ||| end periods freq	count=2
module	rewrite ||| core computation	count=1
module	ndarray like ||| json	count=1
function_arg	with the key ||| get node key	count=2
class	for ||| sparse array	count=1
class	appropriate for table ||| table	count=1
function	perform an asof ||| asof	count=1
function	to a compat for ||| to	count=1
function	locator based on ||| get locator	count=1
arg	code to ||| code	count=1
class	and dtype) in ||| ndframe	count=1
arg	retrieve the ||| handler	count=1
function	parameters ||| from	count=2
function	am never a view ||| is view	count=1
arg	run the same ||| num_threads kwargs_list	count=1
function_arg	[function_1] and arr2 ||| [arg_2] [function_1]	count=1
function	values ||| block shape	count=1
arg	passed to the engine ||| engine	count=1
module	built up ||| io formats	count=1
function	integer stride ||| stride	count=1
function	columns as [function_2] ||| [function_2] [function_1]	count=6
arg	of obj ||| obj	count=3
function	as an html table ||| to html	count=1
arg	of n ||| n axis	count=2
function	intersection of ||| intersection	count=2
function	casting ||| casting	count=1
function	trims ||| trim	count=1
arg	on column values uses ||| values	count=1
arg	new object with labels ||| labels	count=1
function	connect to the ||| connect	count=1
class	keyerror ||| chain	count=1
arg	boolean ||| b	count=1
function	and string-like ||| string	count=1
class	this frame ||| frame	count=1
arg	alignment_dict ||| cls alignment_dict	count=1
function	[function] dtype ||| is [function] like	count=2
function	repr ||| repr	count=1
arg	a set of terms ||| terms	count=1
function	return the [function_2] ||| [function_1] ftype [function_2]	count=2
module	ndarray only ||| indexes	count=1
arg	with nat-like arg ||| arg errors	count=1
arg	over the blocks collect ||| axis consolidate transposed	count=1
class	from maps[0] raise keyerror ||| chain	count=1
function	for scalar op ||| can do op	count=2
arg	a left and ||| cls left	count=1
function	bytes in the underlying ||| nbytes	count=2
function	moving window of ||| window	count=1
function	the numeric add/sub ||| add numeric	count=1
function	unary ||| unary	count=1
function	check ||| check for	count=1
arg	perform an ||| limit	count=1
function	scalar to ||| scalar to	count=2
function	[function_1] scalar to ||| [function_1] [function_2]	count=3
function	columns as ||| columns	count=1
arg	rows ||| rows	count=1
function	parse time strings to ||| to	count=1
arg	column ||| name data	count=1
arg	given width ||| width	count=1
module	round ||| core reshape	count=1
function_arg	[function_1] obj ||| [arg_2] [function_1]	count=7
function	[function_1] data ||| [function_2] [function_1]	count=7
function	[function_1] fill ||| [function_1] [function_2]	count=1
function	and are a view ||| view	count=1
function_arg	[function_1] the arg ||| [arg_2] [function_1]	count=1
function_arg	[function_1] ufunc ||| [function_1] [arg_2]	count=2
arg	ndarray only use ||| arr	count=1
function	convert ||| convert params	count=1
arg	format files ||| format index	count=1
class	lookup ||| index	count=1
module	iterate over ||| io	count=1
function	prettier version of ||| pretty string	count=1
function	a sparse [function_2] ||| [function_2] [function_1]	count=1
class	with times ||| index	count=1
class	to timedelta ||| timedelta	count=1
arg	column values uses ||| values	count=1
function	version of putmask that ||| putmask	count=1
arg	to a ufunc ||| context	count=1
function	about a malformed row ||| malformed	count=1
class	return ||| datetime index	count=1
class	you ||| index	count=1
function	the ftypes (indication of ||| ftypes	count=1
arg	bb ||| new_mgr_locs fill_tuple	count=1
class	date forward to ||| date	count=1
function	block of ||| block	count=1
function	convert timedelta-like to timedelta64 ||| td index	count=1
module_class	[module_1] categorical instance ||| [module_1] [class_2] argsort ascending	count=1
function_arg	[function_1] [arg_2] data rows/cols ||| [function_1] [arg_2]	count=1
function_arg	[function_1] i ||| [function_1] [arg_2]	count=4
arg	dtype of the values ||| dtype	count=1
function	this if ||| set value	count=1
arg	inserting new [arg_1] [arg_2] ||| insert [arg_2] [arg_1]	count=1
function	need to coerce a ||| maybe coerce	count=1
module_class	of the [class_2] ||| [module_1] [class_2]	count=24
function	a leap ||| leap	count=1
function	engine ||| engine	count=1
arg	must already exist ||| key value	count=1
class	that can be used ||| html frame	count=1
function	packed bytes see :class ||| packb	count=1
function	is a string ||| string	count=1
arg	tables into a list ||| io match flavor	count=1
arg	to run the same ||| num_threads kwargs_list	count=1
arg	on a and b ||| op_str a b	count=1
module	dtype) in ||| core	count=1
function_arg	given quantile [arg_2] ||| [arg_2] [function_1]	count=1
class	panel or above ||| panel	count=1
function_arg	union [arg_2] ||| [arg_2] [function_1]	count=2
function	metadata for ||| read metadata	count=1
arg	according to indexer and ||| indexer	count=2
function	checks ||| check	count=3
function	if we are a ||| is	count=2
class	this frame ||| data frame	count=1
arg	column by [arg_2] ||| [arg_1] [arg_2]	count=1
arg	and arr2 are ||| arr2	count=1
function	the values ||| values	count=1
function	[function_1] or sparsearray ||| [function_1] [function_2]	count=2
arg	indexer like ||| cls name indexer	count=1
function	0 number format ||| number format	count=2
module_class	slice of [class_2] ||| [module_1] [class_2]	count=4
function	already exist ||| append	count=1
function	[function_1] and n/a ||| [function_1] [function_2]	count=2
arg	a regular expression ||| case flags	count=1
function	a named [function_2] ||| [function_1] [function_2]	count=1
function	[function_1] the display ||| [function_1] [function_2]	count=1
arg	check the key for ||| key	count=1
arg	append to ||| append	count=1
function	intervalindex from ||| from	count=1
function	cast [function_2] ||| [function_2] [function_1]	count=2
class	return a ||| parser	count=1
arg	function designed to be ||| func	count=1
arg	that left and right ||| left right check_exact check_dtype	count=1
arg	ndarray only use this ||| arr	count=1
function	names to 'index' ||| names	count=1
module	our ||| core	count=1
arg	ndarray or ||| data index columns	count=1
arg	a column by ||| name data	count=1
class	create index with target's ||| index	count=1
class	minimum ||| ops mixin	count=2
module_class	[module_1] generic stata ||| [module_1] [class_2]	count=1
function_arg	[function_1] *not* ||| [function_1] [arg_2]	count=4
function	called prior ||| prepare	count=1
arg	with null values ||| values	count=1
module	this ||| core indexes	count=4
function_arg	subplots [arg_2] ||| [arg_2] [function_1]	count=1
function	ndarray ||| value	count=1
function	[function_1] the timedelta64[ns] ||| [function_2] [function_1]	count=1
function	validate that we ||| is	count=1
function	a custom ||| custom	count=1
class	series with ||| series	count=1
function	function to ||| func	count=1
class	a version ||| block	count=1
function	locations ||| set locs	count=1
function	try_coerce_args ||| try coerce result	count=1
arg	for :meth ||| inplace limit	count=2
function	of ||| of	count=1
arg	a python expression ||| expr	count=1
function	scalar ||| scalar	count=2
function	reflecting the ||| setup	count=1
function	a tree-like object that ||| build	count=1
function	a ||| validate ordered	count=2
module_class	the data ||| io data col	count=1
arg	append to table in ||| append	count=1
arg	item [arg_2] ||| [arg_1] [arg_2]	count=1
module_class	of [module_1] [class_2] ||| [module_1] [class_2]	count=4
class	can be used to ||| frame parser	count=1
module	see :class packer for ||| msgpack	count=1
function_arg	result to have ||| result name	count=1
arg	query ||| con	count=1
function	if we have mixed ||| have mixed	count=1
module	that can be ||| io	count=1
function	return the data ||| data	count=1
class	blockmanager ||| block manager	count=7
function_arg	to specified [arg_2] ||| [function_1] [arg_2]	count=1
class	parameter if ||| categorical	count=1
function	latex [function_2] ||| [function_2] [function_1]	count=2
function	parse specified ||| parse	count=1
class	keyerror is maps[0] ||| chain	count=1
arg	synonym for :meth ||| inplace limit downcast	count=2
class	one ||| series	count=1
function_arg	array [arg_2] ||| [arg_2] [function_1]	count=1
arg	of this container ||| slobj axis kind	count=1
function	options grouped by prefix ||| pp options	count=1
arg	on given axis ||| axis	count=1
function	must ||| append	count=1
arg	[arg] data ||| nrows [arg] c_idx_names	count=1
class	return a string ||| string	count=2
function	into codes [function_2] ||| [function_2] [function_1]	count=2
arg	given axis ||| axis method	count=1
arg	shape ||| placement shape	count=1
class	return ||| categorical index	count=1
function_arg	[function_1] as ||| [arg_2] [function_1]	count=1
function	[function_1] sparse array ||| [function_1] [function_2]	count=3
function	strings to ||| to	count=1
module	of the values set ||| core	count=1
function_arg	[function_1] the result ||| [function_1] to dtypes [arg_2] dtypes	count=3
function_arg	datetimelike [arg_2] ||| [arg_2] [function_1]	count=3
function	resolve a ||| resolve	count=1
function	like to compare numeric ||| numeric v string like	count=1
arg	if key is ||| key	count=3
arg	dtype ||| value dtype errors	count=1
arg	label ||| label side kind	count=1
class	a block ||| block	count=3
class	index objects contain ||| datetime index ops mixin	count=1
function	locale ||| locale	count=2
function	flags ||| flags	count=1
function_arg	[function_1] among ||| [function_1] [arg_2]	count=1
class	panel objects ||| panel	count=1
function	[function_1] beginning of ||| [function_2] apply [function_1]	count=1
class	index or ||| datetime index ops	count=1
function	entries in index ||| index	count=1
function	view of myself ||| view	count=1
module	its values ||| core	count=1
class	underlying data which is ||| index	count=1
arg	data converts ||| cls data	count=1
function	a recursive ||| recursive	count=1
class	other [class] operations ||| [class]	count=2
arg	category value returning ||| ascending na_position	count=1
class	times to midnight length ||| datetime	count=1
arg	query or database ||| index_col coerce_float	count=1
arg	elements of v ||| v	count=1
class	[class_1] applicable to ||| [class_2] [class_1]	count=1
class	rows of a dataframe ||| data frame	count=2
function	index names ||| set default names	count=1
function	labels ||| compressed ids	count=1
class	new block ||| sparse block	count=1
class	return index or ||| datetime index ops mixin	count=1
arg	guarantee the shape of ||| ndim shape	count=1
module	[module_1] object ||| [module_1] [module_2]	count=37
module	sparseseries (with ||| sparse	count=1
function	in a block of ||| block	count=1
function	categorical if not already ||| categorical	count=1
module	index using the ||| core	count=1
function	is unaltered ||| normalize	count=1
function	scalar to a ||| scalar to	count=2
module	html ||| io	count=1
module	for this ||| indexes	count=1
function	which ||| index	count=1
function	to connect to ||| can connect	count=1
function	add in [function_2] ||| [function_2] [function_1]	count=1
arg	this ||| arr	count=1
arg	the _apply kwargs and ||| name window center	count=1
function	as a sparse array ||| as sparse array	count=1
function	of series concat ||| get series	count=1
function_arg	[function_1] the result ||| [arg_2] [function_1]	count=3
function	[function_1] locales ||| [function_2] [function_1]	count=1
function	[function_1] histogram ||| [function_2] [function_1]	count=2
function	ordered data like time ||| ordered	count=1
class	create index ||| multi index	count=1
function	with integer stride parameters ||| get stride from	count=1
function_arg	repr [arg_2] ||| [function_1] [arg_2]	count=2
function	the stata date ||| stata	count=1
function	re-evaluate the ||| and	count=1
arg	column [arg_2] ||| [arg_1] [arg_2]	count=1
function	attributes e g freq ||| attributes	count=3
arg	each date [arg] ||| [arg]	count=1
module_class	[module_1] series ||| [module_1] [class_2] ixs i axis	count=6
arg	a scipy ||| a dense_index	count=1
class	return datetimeindex with ||| datetime index	count=1
module	must already exist ||| io	count=1
class	table ||| table	count=9
class	series columns ||| ndframe	count=1
arg	arr1 ||| arr1	count=1
function	to take optional positional ||| optional args	count=1
module	and dtype) in ||| core	count=1
function	kwargs if it is ||| if	count=1
function	reconstruct ||| reconstruct	count=1
function	the type ||| type	count=1
function	function to determine if ||| n method	count=1
arg	must ||| format	count=1
arg	(header new_data) for ||| row index_col	count=1
function	stata ||| stata elapsed date	count=1
function	a malformed ||| malformed	count=1
module	indices of ||| core	count=1
arg	and ||| value	count=1
function	the dtype str ||| dtype str	count=2
arg	in type_map ||| fmt	count=1
class	object that can be ||| html frame parser	count=1
arg	from some accepted dtype ||| cls	count=1
function	[function_1] array and ||| [function_2] [function_1]	count=5
module	column from the ||| io	count=1
function	valid for ||| valid	count=1
arg	a column ||| name data	count=1
class	return the ||| range	count=1
function_arg	of [arg_2] ||| [arg_2] [function_1]	count=1
module	return a tree-like ||| io	count=1
function	new [function_2] ||| [function_1] [function_2]	count=1
function	node must already exist ||| append	count=1
function	from the [function_2] ||| [function_1] [function_2]	count=2
module	return ||| msgpack	count=1
module	the decimal points ||| io	count=1
module	columns for dataframe ||| core	count=1
arg	the values to ||| values	count=1
function	by default ||| sort	count=1
module_class	sets the [class_2] ||| [module_1] [class_2]	count=4
function	matrix of [function_2] ||| [function_2] [function_1]	count=2
arg	target ||| target	count=1
function	methods ||| methods	count=1
arg	requested level [arg_2] ||| [arg_1] [arg_2]	count=1
function	multi reindex ||| reindex multi	count=2
arg	until it's [arg] chars ||| name [arg]	count=1
function	evaluate the ||| eval	count=1
arg	result parameters ||| result mask	count=1
arg	cartesian product of ||| sort	count=1
module	as a unicode ||| indexes	count=1
arg	and expected error message ||| exc_type exc_value trace_back	count=1
module	sparse/dense and dtype) ||| core	count=1
class	a series of columns ||| ndframe	count=1
function	construct [function_2] ||| [function_1] [function_2]	count=2
arg	file node ||| key	count=1
arg	arg is ||| arg errors	count=1
function_arg	type in [arg_2] ||| [function_1] [arg_2]	count=1
function	return if we are ||| is	count=1
module	dataframe and major_axis for ||| core	count=1
module	object dtype ||| core dtypes	count=2
function_arg	array of [arg_2] ||| [arg_2] [function_1]	count=1
class	ndarray like into ||| parser	count=1
function	sparseseries [function_2] ||| [function_1] [function_2]	count=1
function	specified ||| asfreq	count=1
function_arg	prior [arg_2] ||| [function_1] [arg_2]	count=1
module	dtype) in this object ||| core	count=1
class	underlying ||| ops mixin	count=1
class	return index ||| index	count=2
arg	file node must already ||| value	count=1
function	return the node ||| node	count=1
arg	slice or [arg_2] ||| [arg_1] [arg_2]	count=1
function	[function_1] series ||| [function_2] [function_1]	count=11
function	scalar op ||| can do op	count=2
arg	raises notimplentederror for offsets ||| i	count=1
module	if ||| dtypes	count=1
class	of each interval ||| interval	count=1
function_arg	[function_1] unit if ||| [arg_2] [function_1]	count=2
function	[function_1] //www stata ||| [function_1] [function_2]	count=2
function_arg	[function_1] of obj ||| [function_1] [arg_2]	count=5
function	reverse convert a missing ||| convert missing	count=1
function	additional ||| array	count=1
class	used ||| frame parser	count=2
arg	an openpyxl ||| cls	count=1
arg	for allowed ||| allowed	count=1
function	string representation ||| unicode	count=1
function	[function_1] difference of ||| [function_2] [function_1]	count=3
function	masked [function_2] ||| [function_1] [function_2]	count=6
arg	frequency ||| freq method	count=1
function_arg	[function_1] in ||| [function_1] [arg_2]	count=2
function	radviz - ||| radviz	count=1
module	of data ||| core	count=1
function_arg	[function_1] ncols ||| [arg_2] [function_1]	count=1
function_arg	[function_1] nan/nat ||| [arg_2] [function_1]	count=4
function_arg	[function_1] termvalue ||| [function_1] [arg_2]	count=1
function	get instances of all ||| all	count=1
function	string and ||| parsed string to	count=1
function	try to operate ||| try	count=1
module	this ||| core	count=4
function	that we have a ||| validate ordered	count=1
module	the decimal points if ||| io formats	count=1
arg	dataframe the ||| data values index	count=1
arg	[arg_1] in requested ||| [arg_1] axis [arg_2]	count=4
function	dataframe are equal ||| frame equal	count=1
module	return the ||| io	count=6
function_arg	take [arg_2] ||| [function_1] [arg_2]	count=1
function	[function_1] to a ||| [function_2] [function_1]	count=10
arg	frequency if available ||| freq axis	count=1
arg	data to ||| data groups	count=1
function	an positional ||| has valid positional setitem	count=1
arg	a float key ||| key	count=1
module	number of ||| core indexes	count=2
function_arg	intersection of [arg_2] ||| [arg_2] [function_1]	count=2
function_arg	sparse array ||| sparse array	count=1
module	dimensions as ||| core	count=1
function	arr1 ||| equal contents	count=1
arg	are available on ||| prefix normalize locale_getter	count=1
function	thereafter [function_2] ||| [function_2] [function_1]	count=1
arg	url ||| url	count=1
function	that is datetimelike (e ||| maybe to datetimelike	count=1
class	sparse/dense and dtype) in ||| ndframe	count=1
arg	or datetime ||| freq	count=1
function	1-dimensional ndarray ||| set	count=1
function	create a pytables index ||| create	count=1
class	for each group ||| group by	count=4
arg	in ||| inplace	count=1
arg	and ||| key value	count=1
class	this is index ||| ndframe	count=1
module	return packed bytes ||| io	count=1
arg	and arr2 are equivalent ||| arr2	count=1
arg	that we have ||| cls	count=1
module_class	[module_1] table ||| [module_1] [class_2]	count=8
function	type is an ||| is	count=1
class	the number of ||| range	count=1
function_arg	[function_1] [arg_2] ||| [function_1] dtype [arg_2]	count=7
class	long stacked format dataframe ||| data frame	count=1
function	stderr in a buffer ||| stderr	count=1
module	gets called after a ||| indexes	count=2
function	panel to ||| to	count=1
class	node must already ||| hdfstore	count=1
class	each index value ||| datetime index ops	count=2
arg	arr2 are ||| arr2	count=1
function	length [function_2] ||| [function_1] [function_2]	count=3
function	intervalindex from a ||| from	count=1
arg	ncols - number of ||| ncols	count=1
arg	the name this ||| name	count=1
class	of the index ||| index	count=2
arg	exist and be ||| value	count=1
arg	for temporarily setting ||| new_locale lc_var	count=1
function	the mode s of ||| mode	count=1
function	parameter if ||| validate ordered	count=1
class	datetimeindex from one ||| datetime index	count=1
arg	the new type ||| dtype copy	count=2
module	already exist and be ||| io	count=1
module	set of ||| core	count=2
function	series/index by given ||| str	count=1
function	asof merge ||| merge asof	count=2
arg	series arithmetic operations to ||| op name	count=1
arg	a regular expression ||| flags	count=1
function_arg	[function_1] left and ||| [arg_2] [function_1]	count=1
arg	perform __getitem__-like return result ||| slicer new_mgr_locs	count=1
arg	gets ||| result	count=3
function_arg	a sparse [arg_2] ||| [function_1] [arg_2]	count=1
function	[function_1] cacher ||| [function_1] [function_2]	count=1
function	[function_1] data ||| [function_1] [function_2]	count=3
function	return label for first ||| first	count=2
module	simple ||| core reshape	count=2
function	1-dimensional ||| set	count=1
module	fast lookup of ||| indexes	count=1
function	and return a ||| get	count=1
function_arg	[function_1] argument ||| [function_1] [arg_2]	count=2
arg	y ||| y	count=2
class	whether each index ||| datetime index	count=1
function	capture [function_2] ||| [function_1] [function_2]	count=4
function	[function] dtype ||| [function] like	count=1
function_arg	[function_1] length ||| [arg_2] [function_1]	count=2
class	boxed ||| datetime	count=2
class	to table ||| hdfstore	count=1
arg	of other to the ||| other	count=1
function	[function_1] to parse ||| [function_2] [function_1]	count=2
module	up styles to html ||| formats	count=1
function	fast version [function_2] ||| [function_2] [function_1]	count=2
function	line ||| line	count=1
arg	op on ||| op op_str	count=2
class	new multiindex ||| multi	count=1
arg	frequency ||| freq method how	count=1
arg	of values ||| values	count=1
module	packer for ||| msgpack	count=1
module	in the ||| core	count=15
module	as a unicode ||| core indexes	count=1
arg	and right ||| right	count=6
function	[function_1] transform ||| [function_2] [function_1]	count=2
arg	_apply kwargs and ||| window center	count=1
function	ids parameters ||| ids	count=1
arg	we are going to ||| obj data_columns	count=1
function	offset/observance to a ||| rule	count=1
class	return a new block ||| block	count=2
arg	using matplotlib / pylab ||| column by grid	count=1
class	multiindex from the ||| multi index	count=1
class	multiindex from ||| multi index	count=1
function	columns under the index ||| index	count=1
class	from maps[0] ||| map	count=1
class	called ||| index	count=2
function	tree-like object that ||| build	count=1
function	return packed bytes ||| packb	count=1
function	[function_1] [function_2] ||| [function_1] line [function_2]	count=1
function_arg	compare numeric [arg_2] ||| [function_1] like [arg_2]	count=1
module	new object with the ||| core	count=1
arg	sql [arg_2] ||| [arg_2] [arg_1]	count=3
arg	compute a simple cross-tabulation ||| columns	count=1
arg	with [arg_2] ||| [arg_1] [arg_2]	count=1
function_arg	swap level [arg_2] ||| [arg_2] [function_1]	count=7
function	count of ||| count	count=1
class	applies ||| series	count=1
arg	background null_color for missing ||| null_color	count=1
arg	string raise a typeerror ||| cls string	count=2
class	this object ||| index	count=1
function	and n/a values ||| and	count=1
module	necessary ||| core	count=1
function	like to compare numeric ||| is numeric v string like	count=1
function	convert timedelta-like to ||| td	count=1
function	set the ||| set	count=2
class	use this if ||| index	count=1
function	'numpy' library ||| take with	count=1
function	intersection ||| intersection	count=2
arg	indexers ||| indexers	count=1
function_arg	quantile [arg_2] ||| [arg_2] [function_1]	count=1
function	a ||| is	count=1
function	infer the [function_2] ||| [function_1] [function_2]	count=5
arg	input function or ||| copy	count=1
module	styles to html ||| io	count=1
function	extensions ||| extensions	count=1
module	index with day ||| core indexes	count=2
function	the full ||| full	count=1
arg	encoding ||| encoding compat	count=1
module	with the ||| core	count=1
arg	decorator ||| decorator	count=1
arg	that left ||| left	count=4
function	convert back to bool/int ||| downcast to dtype	count=1
class	internal property ||| ndframe	count=1
arg	return a ||| a	count=1
class	must already ||| hdfstore	count=1
function	[function_1] a table ||| [function_2] [function_1]	count=3
arg	the function to ||| func mgr	count=1
function	construct and [function_2] ||| [function_2] [function_1]	count=3
arg	input ||| mapper axis copy	count=1
arg	result as series or ||| axis level	count=1
function	check [function_2] ||| [function_1] [function_2]	count=2
arg	time series ||| series	count=1
function	block of same ||| make block same	count=1
arg	value of x ||| x	count=1
arg	a sparseseries ||| a dense_index	count=1
function	detect terminal [function_2] ||| [function_2] [function_1]	count=4
class	series excluding elements from ||| series group	count=1
arg	function return fillvalue ||| fillvalue	count=1
function	try ||| maybe	count=2
class	be used to ||| html frame	count=1
arg	on 3 columns ||| columns values	count=1
function	to a timedeltaindex ||| to	count=1
arg	compute ||| columns	count=1
function	alignment object ||| alignment	count=1
arg	to avoid code duplication ||| name str_rep	count=1
function	color ||| color	count=1
function	feather-format ||| to feather	count=1
function	number ||| number	count=2
class	major_axis for ||| ndframe	count=1
arg	unit if ||| cls unit	count=1
arg	dom ||| doc match attrs	count=1
function	[function_1] sparsearray ||| [function_2] [function_1]	count=2
class	1-dimensional ndarray only ||| index	count=1
arg	that the left ||| left	count=1
function	an index that ||| index	count=1
arg	of ||| key	count=1
class	roll provided date forward ||| date	count=1
function	float is formatted in ||| eng float	count=1
function_arg	[function_1] the dtype ||| [arg_2] [function_1]	count=2
function	scatter ||| scatter	count=1
function	axis is ||| is	count=1
arg	be table ||| key value	count=1
function	[function_1] returns axes ||| [function_1] [function_2]	count=1
module_class	of columns ||| core data frame	count=1
arg	[arg_1] iterables parameters ||| [arg_2] [arg_1]	count=4
class	float values converted into ||| float array	count=1
arg	synonym for :meth ||| inplace	count=2
class	are creating [class] binner & ||| [class]	count=1
function_arg	[function_1] binary ||| [function_1] [arg_2]	count=4
module_class	if [class_2] ||| [module_1] [class_2]	count=2
arg	string raise ||| string	count=2
function	[function_1] our native ||| [function_1] [function_2]	count=3
function	[function_1] our index ||| [function_1] [function_2]	count=7
function	as ||| array	count=1
class	this ||| interval	count=1
function	feather-format object ||| read feather	count=1
arg	or by ||| by axis level	count=2
class	tree-like ||| html	count=1
function_arg	union of two ||| union other	count=4
arg	a left and ||| left	count=1
module	dict has only the ||| io	count=1
arg	left [arg_2] ||| [arg_2] [arg_1]	count=7
arg	[arg_1] with indexer ||| [arg_1] [arg_2]	count=2
function	best locator based on ||| locator	count=1
function	series/index to be ||| str	count=1
arg	item [arg_2] ||| [arg_2] [arg_1]	count=2
class	remove and ||| map	count=1
class	iterate over ||| frame parser	count=1
arg	by ||| by	count=1
arg	the columns of ||| inplace	count=1
arg	the key or none ||| key	count=1
function_arg	[function_1] tabular ||| [arg_2] [function_1]	count=1
module	index objects contain ||| indexes	count=1
function	options ||| options	count=2
function	representation of object to ||| to	count=1
class	series ||| ndframe	count=1
function	leap [function_2] ||| [function_2] [function_1]	count=1
arg	a sequence of terms ||| terms	count=1
class	a dataframe to ||| data frame	count=1
arg	or by a series ||| by axis level	count=1
module_class	of panel ||| core panel	count=2
arg	axis ||| axis method na_option	count=1
arg	convert the [arg] to a ||| [arg]	count=1
function	user about a malformed ||| malformed	count=1
function_arg	[function_1] a separate ||| [arg_2] [function_1]	count=1
function	additional handling ||| array	count=1
arg	labels using one ||| inplace	count=1
function	[function_1] sequence of ||| [function_1] [function_2]	count=1
function	[function_1] unit ||| [function_2] [function_1]	count=1
function	[function_1] to parse ||| [function_1] [function_2]	count=2
arg	format return python ||| datestr	count=1
function	style object ||| style	count=3
class	is ||| extension dtype	count=1
function	for this level ||| has level	count=1
arg	stride into a higher ||| cls value	count=1
arg	axis ||| axis	count=10
arg	columns of a ||| inplace	count=1
arg	append to table in ||| format append	count=1
function	group ||| group	count=1
function	if we are ||| is	count=2
function	endian ||| endian	count=1
arg	frequency [arg_2] ||| [arg_1] [arg_2]	count=1
class	return ||| datetime	count=1
class	number of ||| index	count=2
arg	requested ||| level	count=1
class	index or ndarray filled ||| index ops	count=1
class	in file ||| hdfstore	count=1
module	built up ||| io	count=1
function	return an ||| to	count=1
class	panel objects and ||| panel	count=1
function	[function_1] operations ||| [function_2] [function_1]	count=2
arg	blocks collect ||| consolidate transposed	count=1
module	the decimal ||| io formats	count=1
function	type to its ||| table type	count=1
function_arg	[function_1] column and ||| [function_1] index [arg_2] takeable	count=2
arg	valid ordered ||| ordered	count=1
function	that an positional ||| has valid positional setitem	count=1
function	if the frequency is ||| freq	count=1
function	parameter ||| validate	count=1
class	i am never a ||| categorical	count=1
function	compute a simple ||| crosstab	count=1
arg	bins to which each ||| bins	count=1
function	alias to closest period ||| period alias	count=1
arg	left and right ||| left right exact check_names	count=1
arg	the default frequency ||| periods freq	count=3
function	return the len of ||| size	count=1
arg	dataframe the levels ||| data	count=1
function	concatenation ||| concat	count=2
function	function for this argument ||| func	count=2
function	connect ||| connect	count=1
function	of casting ||| assert safe casting	count=1
function	are equal ||| equal	count=6
arg	and right data ||| right vertical	count=1
arg	regular expression pat ||| arr pat flags	count=2
arg	utility ||| skipna fill_value fill_value_typ	count=1
function_arg	closest period [arg_2] ||| [function_1] alias [arg_2]	count=1
arg	ncols - ||| ncols	count=1
function	this column return ||| col	count=1
function	[function_1] to sif ||| [function_1] [function_2]	count=1
function_arg	where [arg_2] ||| [arg_2] [function_1]	count=4
function_arg	of casting [arg_2] ||| [function_1] cls [arg_2]	count=1
function	lists ||| matrix	count=1
function	representation for a particular ||| repr	count=2
function	and create the manager ||| to mgr	count=1
function	to a list ||| to	count=2
function_arg	the union [arg_2] ||| [arg_2] [function_1]	count=2
arg	fill the values ||| limit	count=1
function	object ||| build	count=1
arg	moving [arg_2] ||| [arg_2] [arg_1]	count=1
arg	point [arg] ||| [arg]	count=2
module	wide ||| core reshape	count=1
function	expanding count of number ||| expanding count	count=1
module	convert [module_1] [module_2] ||| [module_1] [module_2]	count=4
function	return a boolean if ||| is dtype	count=1
function_arg	set coerce [arg_2] ||| [arg_2] [function_1]	count=2
function	of scatter ||| scatter	count=1
module	an ||| computation	count=3
arg	1-dimensional ndarray only ||| arr key	count=1
arg	a ufunc ||| context	count=4
arg	leaving just one before ||| str_floats na_rep	count=1
function_arg	[function_1] deterministic integers ||| [arg_2] [function_1]	count=1
function_arg	intersection [arg_2] ||| [arg_2] [function_1]	count=2
function	concatenation of ||| concat	count=1
function	data ||| data	count=4
function	gets ||| array	count=3
arg	packed object return an ||| packed object_hook list_hook	count=1
arg	node ||| value format	count=1
arg	a valid ordered parameter ||| ordered	count=1
function_arg	for [arg_2] ||| [arg_2] [function_1]	count=3
arg	array parameters ||| closed	count=1
class	used to iterate over ||| frame parser	count=1
arg	input order may not ||| order	count=2
function	[function_1] metadata ||| [function_2] [function_1]	count=1
class	the exception raised ||| assert raises contextmanager	count=1
module	use ||| core indexes	count=2
function	frequency code group ||| group	count=1
function	from 1-dimensional ||| value	count=1
function_arg	determine if [arg_2] ||| [arg_2] [function_1]	count=1
function_arg	type among ||| type types	count=1
arg	[arg_1] a style_dict ||| [arg_2] [arg_1]	count=2
function	is a [function_2] ||| [function_1] [function_2]	count=8
arg	fillvalue for ||| fillvalue	count=1
module	index objects contain the ||| core indexes	count=1
function	return a boolean ||| is	count=1
arg	already exist ||| key	count=1
arg	[arg_1] array parameters ||| [arg_2] [arg_1]	count=4
function	gets called prior ||| prepare	count=1
function	string-like that is ||| convert string array	count=1
function	a list replace ||| replace list	count=1
module	handling ||| core indexes	count=2
function	kwargs ||| kwargs	count=1
arg	encode input values as ||| values sort order na_sentinel	count=1
class	object ||| ndframe	count=3
arg	over the other axis ||| axis	count=1
function	a simple cross-tabulation of ||| crosstab	count=1
function_arg	option [arg_2] ||| [function_1] [arg_2]	count=1
class	underlying ||| index	count=2
arg	a higher ||| cls value	count=1
function	an enumerated type or ||| factorize	count=1
function	label [function_2] ||| [function_2] [function_1]	count=2
function_arg	and other ||| args values other	count=1
arg	function or ||| arg	count=1
module_class	of this categorical ||| core categorical	count=1
function_arg	[function_1] to indexer ||| [function_1] [arg_2]	count=1
class	and return ||| chain map	count=1
module	object ||| core dtypes	count=7
arg	from ndarray or list ||| data index	count=1
function_arg	a categorical [arg_2] ||| [function_1] [arg_2]	count=2
class	sparse/dense ||| ndframe	count=1
class	file node must already ||| hdfstore	count=1
function	leap ||| leap	count=1
arg	as a dataframe the ||| data values index	count=1
module	can ||| core indexes	count=1
function	cases to get ||| get index	count=1
function	values ||| get level values	count=1
class	with [class_2] ||| [class_1] [class_2]	count=2
class	of myself ||| categorical	count=2
arg	columns of ||| index columns values	count=1
function_arg	swap level i ||| swaplevel i	count=1
module	align ||| core computation	count=1
arg	a valid ordered ||| cls ordered	count=1
function	iterator over the ||| iter	count=1
function	dtype and n/a ||| get empty dtype and	count=1
arg	exist ||| value	count=1
arg	[arg_1] pat ||| [arg_2] [arg_1]	count=12
function	add numeric operations ||| add numeric operations	count=2
module	table in file ||| io	count=1
arg	as the ||| values	count=1
function	get test result and ||| get test result	count=1
function	integer ||| integer	count=1
function	rewrite the ||| rewrite	count=1
class	necessary for ||| array	count=1
class	of this frame ||| frame	count=1
function	alert a [function_2] ||| [function_1] [function_2]	count=1
class	the underlying ||| multi	count=1
module	return my values ||| core	count=1
function	[function_1] and n/a ||| [function_2] [function_1]	count=2
class	the original ||| ndframe	count=1
function_arg	dataframe parameters ||| frame name	count=1
arg	[arg_1] j do ||| [arg_1] [arg_2]	count=1
function	csv file ||| csv	count=2
class	to the underlying array ||| datetime index ops mixin	count=1
function	index are equal ||| assert index equal	count=2
module	have ||| core	count=1
function_arg	[function_1] [arg_2] ||| [function_1] periods axis [arg_2]	count=1
function	to construct this ||| construct	count=1
arg	a separate ||| path na_rep engine	count=1
class	the float ||| float array	count=1
function	nrows ||| custom dataframe	count=1
arg	axis parameters ||| axis	count=2
module	more this ||| core	count=1
arg	additional handling as ||| result	count=1
function	of term ||| term	count=1
function_arg	expected exception [arg_2] ||| [arg_2] [function_1]	count=3
arg	generate ||| nchars	count=1
function	[function] using ||| to [function]	count=1
arg	obj and kwargs ||| obj	count=1
function	indexed ||| is indexed	count=1
class	don't care for ||| rolling	count=1
arg	a decorator to ||| decorator	count=1
function	wide ||| wide	count=1
function	for header ||| pop header	count=1
function	the 'numpy' library ||| argmin with	count=1
module	object ||| dtypes	count=16
arg	sparse-compatible version of ||| indices axis	count=1
function	masked ||| masked	count=1
function	reset the display options ||| reset display options	count=1
function_arg	[function_1] [arg_2] data rows/cols ||| [function_1] nrows [arg_2]	count=1
arg	equivalent to read_excel(excelfile ||| sheetname header skiprows skip_footer	count=1
module	times to ||| core indexes	count=1
function	overlap ||| items overlap	count=1
module_class	return block ||| core block	count=1
function	datetime to [function_2] ||| [function_2] [function_1]	count=1
arg	file ||| value	count=1
arg	fill value ||| fill_value	count=1
function	get test [function_2] ||| [function_1] [function_2]	count=4
arg	pattern or regular expression ||| flags	count=1
arg	the block [arg_2] ||| [arg_2] [arg_1]	count=4
class	render [class_2] ||| [class_2] [class_1]	count=4
function	a list/array of tuples ||| tuples	count=1
arg	must already exist ||| key value format	count=1
function	[function_1] a string ||| [function_2] [function_1]	count=1
arg	column [arg_2] ||| [arg_2] [arg_1] takeable	count=1
module	the underlying ||| indexes	count=2
arg	from the first match ||| arr	count=1
arg	cross-tabulation of ||| index columns	count=1
arg	number_format_dict ||| number_format_dict	count=1
function	return [function_2] ||| [function_2] [function_1]	count=9
function	with closed ||| closed	count=1
module	number of ||| indexes	count=2
function	series only ||| series only	count=2
function	to connect to the ||| can connect	count=1
module	[module_1] [module_2] is list-like and that ||| [module_1] [module_2]	count=3
function_arg	[function_1] the same ||| [arg_2] [function_1]	count=3
arg	from ||| index	count=1
arg	nat-like arg ||| arg errors	count=1
class	microsecond ||| datetime index ops mixin	count=1
class	for panel objects ||| panel	count=1
function	construct concatenation [function_2] ||| [function_1] [function_2]	count=1
module	for options ||| msgpack	count=1
function	from 1-dimensional ndarray ||| set value	count=1
class	each index ||| index	count=1
function	one of the stata ||| stata	count=1
module	file node must ||| io	count=1
function	[function_1] a type ||| [function_1] stata [function_2]	count=3
function	convert from sif to ||| date to	count=1
arg	parameter if ||| cls	count=1
arg	to the new ||| copy errors	count=2
module	a ||| core reshape	count=2
function	file ||| append	count=1
function	an asof [function_2] ||| [function_2] [function_1]	count=2
function_arg	[function_1] n rows ||| [function_1] [arg_2]	count=1
class	only [class_2] ||| [class_1] [class_2]	count=2
module	for this object ||| core	count=1
class	block and are ||| block manager	count=1
function	to parse a ndarray ||| convert data	count=1
class	ndframe as opposed ||| ndframe	count=1
arg	a string raise ||| cls string	count=2
class	underlying data ||| multi	count=1
function	html table ||| html	count=1
function	[function_1] the manager ||| [function_2] [function_1]	count=7
module	try ||| core sparse	count=1
function_arg	types of [arg_2] ||| [function_1] [arg_2]	count=2
class	return ||| chain	count=1
arg	inferring dtype ||| use_dtypes convert_dates	count=1
function_arg	[function_1] data converts ||| [arg_2] [function_1]	count=4
function	dense representation ||| to dense	count=1
function_arg	[function_1] block ||| [arg_2] [function_1]	count=1
function	available options ||| options	count=1
arg	a date_format return ||| date_format	count=1
function	to ||| block2d to	count=1
module	boxed ||| core indexes	count=1
function_arg	feather-format object [arg_2] ||| [arg_2] [function_1]	count=1
function	and ||| append	count=1
function	html [function_2] ||| [function_2] [function_1]	count=2
function	two indices overlap ||| items overlap	count=1
function	[function_1] unordered ||| [function_2] [function_1]	count=2
function_arg	pads it with null [function_1] [arg_2] ||| [function_1] [arg_2]	count=1
class	reindex ||| sparse block	count=1
arg	itemsize ||| itemsize	count=1
function	mixed [function_2] ||| [function_2] [function_1]	count=1
arg	deal with nat-like arg ||| arg	count=1
function_arg	returns first [arg_2] ||| [function_1] [arg_2]	count=2
function_arg	[function_1] indexer ||| [function_1] dtype [arg_2]	count=1
class	dataframe and ||| ndframe	count=1
arg	this ||| key	count=2
function_arg	numeric [arg_2] ||| [arg_2] [function_1]	count=1
function	apply ||| apply index days	count=1
arg	of value from ||| arr key value	count=1
function	argsort ||| argsort	count=1
function	sif to ||| elapsed date to	count=1
class	myself ||| categorical	count=2
function	[function_1] sparse ||| [function_2] [function_1]	count=3
function_arg	[function_1] arg ||| [arg_2] [function_1]	count=1
arg	data columns for ||| data	count=1
class	of the list ||| sparse list	count=1
function	ndarray raises on scalar ||| ndarray	count=1
function_arg	assignment node like ||| assign node	count=1
arg	using input function or ||| copy inplace	count=1
class	and return ||| map	count=1
arg	table ||| table	count=5
arg	as a dataframe ||| data values index	count=1
arg	each ||| arr	count=1
function	array to [function_2] ||| [function_2] [function_1]	count=1
arg	item at selected position ||| loc item value allow_duplicates	count=1
arg	we are grabbing the ||| level global_dict local_dict resolvers	count=1
function	invoked by str ||| str	count=1
class	group excluding ||| data frame group by	count=1
function	true if this is ||| is in table	count=1
function	take the codes by ||| take	count=1
function_arg	[function_1] parameters ||| [arg_2] [function_1]	count=1
function	with any ||| make	count=1
class	ndframe as ||| ndframe	count=1
function_arg	[function_1] to the ||| [function_1] [arg_2]	count=3
arg	data [arg_2] ||| [arg_2] [arg_1]	count=8
arg	frequency ||| freq axis	count=1
function	header rows in multiindex ||| header	count=1
function	[function_1] the locales ||| [function_1] [function_2]	count=1
function_arg	[function_1] n rows ||| [arg_2] [function_1]	count=1
function_arg	[function_1] [arg_2] ||| io [function_1] [arg_2] params	count=1
module	[module] half-open ||| [module]	count=2
class	a series to the ||| series	count=1
function	true if [function_2] ||| [function_1] [function_2]	count=2
class	exist ||| hdfstore	count=1
function	of take ||| take	count=2
class	or ||| map	count=1
function	series extract groups ||| extract frame	count=1
arg	using indicated encoding ||| arr encoding errors	count=4
class	nth row [class] ||| [class]	count=2
function	[function] using fixed ||| to [function]	count=1
arg	table ||| key value format	count=2
module	length ||| core	count=1
function_arg	fill value [arg_2] ||| [arg_2] [function_1]	count=4
function	series/index by indicated ||| str repeat	count=1
module	has only the ||| io json	count=1
function	overlap add suffixes ||| overlap	count=1
function	all possible [function] this ||| [function]	count=1
arg	return valid other ||| other op	count=1
function	return dtype ||| empty dtype	count=1
class	after ||| period	count=1
function_arg	block [arg_2] ||| [function_1] [arg_2]	count=1
function	expected exception ||| exception	count=1
arg	data to an ||| data index dtype	count=1
function	float dtype if ||| float	count=1
arg	dtype converting float ||| dtype errors	count=1
function	header rows ||| pop header	count=1
function	if you ||| set	count=1
function	function of type ||| type	count=1
function_arg	from [arg_2] ||| [arg_2] [function_1]	count=11
function	to connect ||| can connect	count=1
class	underlying data which ||| index	count=1
arg	number of times ||| repeats	count=1
class	sparse/dense and dtype) ||| ndframe	count=1
arg	if ||| key	count=1
function	header rows in multiindex ||| header name	count=1
function	in logical methods ||| logical methods	count=1
arg	left ||| left	count=7
class	used to iterate over ||| html frame parser	count=1
class	the float values converted ||| float array	count=1
arg	name this allows ||| name	count=1
function	pack ||| pack	count=1
arg	the we have ||| name	count=1
function	[function_1] timedelta64[ns] ||| [function_2] [function_1]	count=1
module	dataframe and ||| core	count=1
function	[function_1] stata ||| [function_2] [function_1]	count=2
arg	perform __getitem__-like ||| slicer new_mgr_locs	count=1
function_arg	slice [arg_2] ||| [function_1] arr [arg_2]	count=1
function	lists to line ||| to line	count=1
class	ndarray ||| sparse series	count=1
module	the decimal points ||| io formats	count=1
class	python datetime date objects ||| datetime	count=1
module	if ||| core indexes	count=2
function	[function_1] for given ||| [function_2] [function_1]	count=1
arg	two multiindex objects ||| other	count=1
function	quantile ||| quantile	count=1
arg	the nan/nat from the ||| val	count=1
arg	a a left and ||| left	count=1
function	available options grouped ||| options	count=1
module_class	return the i-th [module_1] [class_2] by location ||| [module_1] [class_2]	count=1
function	interpolate bpoly from_derivatives ||| from derivatives	count=1
function	[function_1] dense ||| [function_1] [function_2]	count=2
arg	fast lookup ||| key	count=1
class	return ||| ndframe	count=2
function	ordered attribute ||| get ordered	count=1
function	create a table ||| create table	count=2
class	for ||| ndframe	count=5
function	display ||| display	count=1
function	of elements ||| size	count=1
module	used when ||| core	count=1
arg	data to ||| data groups dropna	count=1
module	ndarray only ||| core	count=1
arg	from ndarray or list ||| index columns	count=1
function_arg	prior to [arg_2] ||| [function_1] [arg_2]	count=1
class	needs additional handling as ||| period	count=1
class	be used to ||| html frame parser	count=1
function	[function_1] where ||| [function_2] [function_1]	count=1
function	result and reset ||| result	count=1
arg	right [arg_2] ||| [arg_2] [arg_1]	count=2
class	dense type view ||| single block manager	count=1
function	table [function_2] ||| [function_1] [function_2]	count=4
function	the specified categories ||| remove categories	count=1
arg	row labels using ||| inplace	count=1
module	see :class packer ||| io msgpack	count=1
module_class	indices that would sort [module_1] [class_2] called ||| [module_1] [class_2] argsort ascending	count=1
arg	on a [arg_2] ||| [arg_2] [arg_1]	count=1
arg	compatibility with the data ||| data	count=1
function_arg	[function_1] type ||| [function_1] class values [arg_2]	count=2
function	cannot [function] time64col() ||| create [function]	count=1
arg	table ||| value	count=2
arg	to table ||| value	count=1
arg	only use ||| arr key	count=1
function_arg	extension against ||| check extension cls	count=1
function	cannot [function] time64col() or ||| create [function]	count=1
arg	shape of the values ||| values ndim shape	count=1
arg	to returning ||| level inplace verify_integrity	count=1
module	gets called after a ||| core	count=3
class	for each ||| index	count=1
function	reflecting the structure of ||| setup	count=1
function	return a new ||| putmask	count=1
arg	the [arg] ||| [arg]	count=1
function	[function] system ||| [function]	count=2
arg	a axes ||| axes dtype copy	count=1
function_arg	check [arg_2] ||| [function_1] can do op [arg_2]	count=4
function	[function_1] same ||| [function_2] [function_1]	count=3
arg	returning ||| level inplace verify_integrity	count=1
module	1-dimensional ndarray only use ||| core	count=1
arg	a date_format ||| date_format	count=1
function	names to 'index' for ||| default names	count=1
function	rec array [function_2] ||| [function_1] [function_2]	count=4
arg	that left and ||| left	count=4
arg	[arg_1] possibly casting ||| [arg_1] [arg_2]	count=2
function	string representation for this ||| unicode	count=1
class	value of the index ||| datetime index	count=2
module	given ||| io formats	count=1
function	of subplots ||| subplots	count=1
class	that can be used ||| html	count=1
class	table ||| series table	count=2
function	our index ||| index	count=1
function_arg	[function_1] stop_seq ||| [arg_2] [function_1]	count=1
arg	fill ||| fill_value	count=1
function	load a ||| load	count=1
function	positional ||| valid positional setitem	count=1
arg	matches a regular expression ||| pat case flags	count=1
function	year ||| year	count=1
function	values between particular times ||| between	count=2
class	if not on offset ||| offset	count=1
arg	unit if needed otherwise ||| unit tz	count=1
arg	for the nan/nat ||| val	count=1
function	use this if you ||| set	count=1
function	an item pair from ||| popitem	count=1
arg	are going to ||| obj data_columns	count=1
class	[class_1] a categorical ||| [class_2] [class_1]	count=2
arg	o and [arg] see :class ||| o [arg]	count=1
function	hash a [function_2] ||| [function_1] [function_2]	count=1
function	color object ||| color	count=1
class	index or ||| datetime index	count=1
arg	from ndarray or list ||| index columns dtype	count=1
function_arg	[function_1] code ||| [arg_2] [function_1]	count=2
function_arg	[function_1] indexer and ||| [function_1] [arg_2]	count=1
function	[function_1] maximum ||| [function_2] [function_1]	count=1
function	[function] callable ||| apply [function]	count=2
function	make a repr ||| repr	count=1
arg	table in ||| key value format	count=1
arg	unit if needed otherwise ||| cls unit	count=1
function	for header ||| pop header name	count=1
arg	use ||| key	count=1
function	table ||| append	count=2
function	[function_1] columns as ||| [function_2] [function_1]	count=1
class	iterate ||| parser	count=1
module	is a string ||| core indexes	count=1
arg	[arg_1] possibly upcast ||| [arg_1] axis [arg_2]	count=1
class	return a block ||| block	count=1
class	iterate over ||| html frame parser	count=1
class	generic stata ||| stata	count=1
function_arg	apply a [arg_2] ||| [function_1] [arg_2]	count=1
arg	can safely be cast ||| val min_val	count=1
class	the underlying ||| index ops mixin	count=1
function	gets called after a ||| wrap	count=3
function_arg	id of [arg_2] ||| [arg_2] [function_1]	count=1
arg	block ||| block block_items existing_col min_itemsize	count=1
function_arg	given [arg_2] ||| [arg_2] [function_1]	count=1
arg	to ||| key	count=1
function	to compare numeric ||| numeric v string	count=1
arg	values as ||| values sort order	count=1
function	casting ||| assert safe casting	count=1
class	new multiindex ||| multi index	count=1
arg	expected error message ||| exc_type exc_value trace_back	count=1
arg	file node must already ||| key	count=1
module	styles to html ||| io formats	count=1
arg	that we have a ||| cls	count=1
function	[function_1] the string ||| [function_2] [function_1]	count=1
function	string-like ||| string	count=2
class	end ||| date offset	count=1
class	return the ||| range index	count=1
function	all values found ||| transform	count=1
function_arg	convert [arg_2] ||| [function_1] [arg_2]	count=5
function	block_manager ||| get block manager	count=1
arg	using input function ||| copy inplace	count=1
function	return [function_2] ||| [function_1] [function_2]	count=7
function	adjusted ||| codes for	count=1
function	[function] to ||| [function]	count=3
function	compare numeric ||| is numeric v	count=1
function	after a ||| array wrap	count=3
function	construct and ||| construct	count=1
function	the timedelta64[ns] ||| timedelta64 ns	count=1
class	rangeindex ||| index	count=1
arg	already exist and be ||| key	count=1
arg	bears the risk of ||| subarr	count=1
function	[function_1] manager ||| [function_2] [function_1]	count=7
function	dense ||| dense	count=1
arg	regular expression ||| arr pat flags	count=2
function	dtype [function] ||| [function] like	count=1
module	the expression ||| core computation	count=1
module	shade ||| formats	count=1
arg	group_index is ||| group_index sort	count=1
arg	nat-like arg is a ||| arg errors	count=1
function	like ||| v string like	count=1
function	float64index of julian dates ||| julian date	count=1
arg	to convert dataframe ||| data	count=1
arg	value using the ||| value	count=1
class	[class_1] value ||| [class_1] [class_2]	count=4
arg	[arg_1] given axis ||| [arg_1] [arg_2]	count=1
function	[function_1] a scalar ||| [function_1] [function_2]	count=3
function	of a single ||| of	count=1
class	from ||| chain map	count=1
arg	exist and ||| key value format	count=1
function	a slice ||| slice	count=1
class	that ||| parser	count=2
function	is a sequence ||| is sequence	count=3
function	integer location ||| loc	count=4
function	little endian ||| little endian	count=2
arg	time ||| time	count=1
function	the metadata ||| read metadata	count=1
module	the handle ||| io	count=1
arg	right ||| right exact	count=1
class	of styler with ||| styler	count=1
arg	columns of ||| inplace	count=1
function	[function_1] mixed levels ||| [function_1] [function_2]	count=3
arg	labels in [arg_2] ||| [arg_1] axis [arg_2]	count=1
arg	[arg_1] a and ||| [arg_2] [arg_1]	count=2
function_arg	nrows [arg_2] ||| [function_1] nrows [arg_2]	count=4
function	the join indexers ||| join indexers	count=4
function	whether ||| validate iterable	count=2
function	a particular ||| repr	count=1
function	alias to [function_2] ||| [function_2] [function_1]	count=2
module	object ||| msgpack	count=2
class	series ||| series group	count=1
function	pandas only dtype object ||| pandas	count=1
class	used when a ||| ndframe	count=1
function	the series extract groups ||| str extract frame	count=1
class	[class] with ||| [class]	count=2
module_class	return the [module_1] [class_2] by location ||| [module_1] [class_2]	count=1
class	float ||| float	count=1
function	the symmetric [function_2] ||| [function_1] [function_2]	count=2
function_arg	[function_1] [arg_2] ||| [function_1] to font [arg_2]	count=1
arg	key and ||| key	count=1
module	the html representation ||| io	count=1
arg	of values values ||| values method	count=1
function	count of number ||| count	count=1
function	connect to the ||| can connect	count=1
arg	exist and be table ||| format	count=1
arg	at selected position ||| value allow_duplicates	count=1
function	best locator based ||| get locator	count=1
function	gradientfill stop ||| stop	count=1
module	index with ||| core indexes	count=3
function	[function_1] template ||| [function_1] [function_2]	count=2
function	validate that ||| validate	count=1
function	the intersection of ||| intersection	count=2
arg	a ||| columns values	count=1
module	built ||| formats	count=1
arg	values can ||| values name	count=1
class	the underlying array which ||| datetime index ops mixin	count=1
arg	where : ||| where mask	count=1
function_arg	[function_1] column ||| [function_1] index [arg_2] takeable	count=2
module	needs additional ||| core indexes	count=1
class	pointer of ||| index ops mixin	count=1
function	stata date [function_2] ||| [function_2] [function_1]	count=4
function	[function] leveraging dateutil ||| [function]	count=2
function	header ||| pop header name	count=1
class	my pandas type & ||| fixed	count=1
arg	the dtype ||| dtype	count=1
function_arg	[function_1] *not* the ||| [arg_2] [function_1]	count=4
class	tree-like ||| html frame parser	count=2
arg	helper function [arg_2] ||| [arg_2] [arg_1]	count=4
function	a string-like that is ||| convert string array	count=1
arg	and be ||| format	count=1
function	columns to be ||| columns	count=1
class	data (produce ||| data frame	count=1
function	rec array [function_2] ||| [function_2] [function_1]	count=4
class	return index or ||| index ops	count=1
function	the stata date formats ||| stata	count=1
arg	length ||| length	count=2
module	the number of ||| core	count=2
function_arg	create an [arg_2] ||| [arg_2] [function_1]	count=4
module	has ||| core	count=1
arg	dataframe the levels in ||| data values index columns	count=1
class	ticks ||| time series date	count=1
function	be used to ||| build	count=1
arg	of ||| axis	count=2
function	a moving window of ||| window	count=1
arg	function ||| func	count=10
arg	from scipy ||| index	count=1
function	function for [function_2] ||| [function_2] [function_1]	count=3
arg	indexer input [arg_2] ||| [arg_1] [arg_2]	count=1
function	unaltered ||| normalize	count=1
function	a timezone ||| set timezone	count=1
function	[function_1] set a ||| [function_2] [function_1]	count=2
arg	node must ||| key	count=1
function	called prior to a ||| array prepare	count=1
function	[function_1] option ||| [function_2] [function_1]	count=2
function	get all [function_2] ||| [function_2] [function_1]	count=2
function	a feather-format ||| feather	count=1
function	date formats to a ||| to	count=1
function	is open ||| is open	count=2
function	optional positional ||| optional args	count=1
arg	for the dtype ||| dtype	count=1
class	of group [class_2] ||| [class_2] [class_1]	count=1
arg	append to ||| key value format append	count=1
class	called after a ||| index	count=2
function	fast version of transform ||| transform fast	count=1
function_arg	[function_1] info from ||| [function_1] [arg_2]	count=2
function	length of a single ||| length of	count=1
class	in panel ||| panel	count=1
arg	to a ufunc ||| result context	count=1
class	of whether each index ||| datetime index	count=1
function_arg	[function_1] the indexer ||| [arg_2] [function_1]	count=1
function	only ||| set	count=1
arg	arr to have ||| arr	count=1
arg	indexer input array to ||| indexer	count=1
class	reset ||| pandas object	count=1
function_arg	assignment [arg_2] ||| [arg_2] [function_1]	count=2
arg	must already exist ||| format	count=1
function_arg	this is [arg_2] ||| [arg_2] [function_1]	count=3
arg	by [arg_2] ||| [arg_2] [arg_1]	count=2
class	the index and ||| range index	count=1
arg	be pasted [arg] ||| [arg]	count=1
arg	columns of this dataframe ||| columns	count=1
function	detect terminal ||| get terminal	count=1
module	styles ||| io	count=1
arg	[arg_1] a dataframe ||| [arg_2] [arg_1]	count=10
arg	a parameter value using ||| value	count=1
arg	as a dataframe the ||| data values index columns	count=1
arg	deprecated use :meth ||| ascending inplace	count=1
arg	and be table ||| format	count=1
function	for header ||| header name	count=1
function	you ||| value	count=1
function	for a particular ||| repr	count=1
function	[function_1] //www stata ||| [function_2] [function_1]	count=2
arg	be ||| key	count=1
function	[function_1] value for ||| [function_2] [function_1]	count=4
class	return a ||| html frame parser	count=1
module	perform the ||| core	count=1
function	[function_1] type in ||| [function_1] stata [function_2]	count=3
function	deprecated option ||| deprecated	count=1
class	panel to a ||| panel	count=1
class	used to iterate over ||| html	count=1
function	lookup ||| set value	count=2
module_class	[module_1] object ||| [module_1] [class_2]	count=4
module	[module_1] [module_2] ||| [module_2] [module_1]	count=4
arg	return a [arg_2] ||| [arg_2] [arg_1]	count=3
module	the store close it ||| io	count=1
arg	particular axis parameters ||| axis	count=2
function	json lists to ||| convert to	count=1
arg	indexer fill with ||| indexer allow_fill	count=1
function	cut where we ||| cut	count=1
function	[function_1] series only ||| [function_1] [function_2]	count=1
class	maps[0] raise ||| chain	count=1
class	sort multiindex at ||| multi index	count=1
arg	a [arg_2] ||| [arg_1] [arg_2]	count=4
function	specified ||| set item	count=1
class	of group excluding ||| frame group by	count=1
function_arg	index row [arg_2] ||| [function_1] keys drop append [arg_2]	count=2
arg	number and its label ||| label	count=1
function_arg	single [arg_2] ||| [arg_2] [function_1]	count=2
module_class	putmask the data to [module_1] [class_2] that ||| [module_1] [class_2] putmask mask	count=1
function	functions ||| rename	count=1
arg	make ||| deep	count=2
module	dtype) in this ||| core	count=1
class	series excluding missing values ||| series	count=1
class	whether the frame ||| frame	count=1
arg	to the specified dtype ||| result dtype	count=1
function	from 1-dimensional ||| set	count=1
arg	the function to my ||| func mgr	count=1
module	times ||| core indexes	count=2
function	leap [function_2] ||| [function_1] [function_2]	count=1
function_arg	[function_1] this argument ||| cython [function_1] [arg_2]	count=1
arg	of ||| columns values	count=1
module	schema resets the ||| io	count=1
function	deprecate a ||| deprecate	count=1
module	index for series columns ||| core	count=1
function_arg	[function_1] of two ||| [arg_2] [function_1]	count=16
function	to a pandas or ||| to	count=1
class	if ||| categorical	count=1
arg	a simple cross-tabulation of ||| columns	count=1
function	that we ||| is	count=1
class	into ||| frame parser	count=1
class	current [class] going ||| [class]	count=1
function_arg	[function_1] if dtype ||| [function_1] [arg_2]	count=4
function	am never ||| is	count=1
arg	along a given axis ||| axis	count=1
arg	a [arg] ||| [arg]	count=3
module	midnight length ||| core indexes	count=1
function	capture stderr in ||| capture stderr	count=2
arg	[arg_1] freq ||| [arg_1] [arg_2]	count=4
arg	[arg] on the ||| [arg] plotf	count=2
function	for akima [function_2] ||| [function_2] [function_1]	count=1
class	string ||| string	count=2
function	additional handling as ||| wrap	count=1
function	excel sheet parameters ||| excel	count=1
arg	possibility ||| array	count=1
arg	use this if you ||| arr	count=1
function_arg	[function_1] query in ||| [function_1] data columns [arg_2]	count=2
function	[function_1] a full ||| [function_1] [function_2]	count=1
function	if two indices overlap ||| items overlap	count=1
function	number of bytes in ||| nbytes	count=2
function	named [function_2] ||| [function_2] [function_1]	count=1
function	end ||| end	count=1
function	size of ||| itemsize	count=1
module	datetime ||| core indexes	count=2
class	to iterate over the ||| frame parser	count=1
function	ndarray only use this ||| set	count=1
class	pointer of the ||| index ops mixin	count=1
arg	the default frequency ||| end periods freq	count=3
function	gets the ||| get	count=2
function	the expected nrows ||| nrows expected	count=2
arg	an ||| size dtype	count=1
module	function ||| formats	count=1
class	add ||| datetime index ops mixin	count=1
function	coerces data to ||| coerce to	count=1
function	wide panel [function_2] ||| [function_2] [function_1]	count=2
arg	a simple cross-tabulation of ||| index columns	count=1
module	called ||| indexes	count=2
function	a numeric ||| numeric	count=1
arg	and ||| key value format	count=1
function_arg	[function_1] fillvalue for ||| [arg_2] [function_1]	count=2
function	[function_1] count of ||| [function_1] [function_2]	count=1
function	label for [function_2] ||| [function_2] [function_1]	count=2
function	try to parse ||| try convert to	count=2
arg	where [arg_2] ||| [arg_2] [arg_1]	count=4
function	a 1d array ||| intervals	count=1
module	and ||| compat	count=1
class	raise ||| map	count=1
function	to ndarray raises on ||| coerce to ndarray	count=1
function_arg	indexer even [arg_2] ||| [function_1] [arg_2]	count=1
arg	dataframe the ||| data	count=1
class	render a dataframe ||| data frame formatter	count=7
function	test result and reset ||| test result	count=1
function	string for ||| generate	count=1
function_arg	[function_1] data to ||| [function_1] [arg_2]	count=1
function	guess the ||| guess	count=1
arg	ndarray copy ||| index dtype copy	count=1
arg	the values to ||| values ndim	count=1
arg	data ||| data groups	count=1
class	used ||| html frame	count=1
function	a timezone ||| timezone	count=1
module	validates that ||| core	count=1
arg	the new ||| copy errors values	count=2
arg	con ||| con	count=1
arg	item and ||| item	count=1
class	data (produce a ||| data	count=1
module_class	nans and replaces these [module_1] [class_2] for missing value ||| [module_1] [class_2]	count=1
function_arg	[function_1] the key ||| [arg_2] [function_1]	count=4
class	values and index ||| datetime index	count=1
module_class	[module_1] block for ||| [module_1] [class_2]	count=2
arg	parameters ||| cls	count=1
function	: ||| write	count=1
function_arg	[function_1] return fillvalue ||| [arg_2] [function_1]	count=3
arg	a ||| values	count=1
arg	requested level ||| level	count=1
arg	flavor ||| flavor	count=1
function	[function] gregorian ||| [function] float	count=3
function	integer stride parameters ||| stride from	count=1
function_arg	[function_1] multiple ||| [function_1] cls iterables [arg_2]	count=3
function	instances of pandasobject ||| any pandas objects	count=1
class	list ||| sparse list	count=1
function	from a masked rec ||| masked rec	count=1
arg	ufunc needs additional handling ||| context	count=1
class	synonym ||| ndframe	count=1
module	the values ||| io	count=1
function	index to [function_2] ||| [function_2] [function_1]	count=2
arg	tuple representation or datetime ||| freq	count=1
class	a string ||| string	count=2
module_class	the generic [class_2] ||| [module_1] [class_2]	count=1
function	monday instead ||| monday	count=1
class	index objects contain the ||| range index	count=1
function	values for ||| values	count=1
module	a simple ||| core reshape	count=1
arg	series equivalent to left ||| left	count=1
module	gets called ||| indexes	count=2
function	'numpy' library ||| argmin with	count=1
class	of each interval in ||| interval	count=1
class	underlying array ||| index ops mixin	count=1
arg	a date_format return a ||| date_format	count=1
class	sparse ||| sparse	count=2
function_arg	[function_1] a string ||| [function_1] [arg_2]	count=2
class	group ||| group	count=2
function	dom ||| doc	count=1
class	pointer of the ||| ops mixin	count=1
arg	we have good categories ||| categories fastpath	count=1
function	a full [function_2] ||| [function_2] [function_1]	count=1
arg	fast lookup of ||| arr	count=1
function	datetimelike (e ||| maybe to datetimelike	count=1
function	[function_1] the raw ||| [function_2] [function_1]	count=1
class	property ||| ndframe	count=2
class	keyerror is maps[0] ||| map	count=1
arg	lookup of ||| arr	count=1
arg	at passed [arg_1] [arg_2] ||| [arg_2] [arg_1] takeable	count=2
class	a single element pandasobject ||| ndframe	count=1
module_class	the [class_2] ||| [module_1] [class_2] writer replace nans	count=3
class	new ||| datetime tzdtype	count=1
arg	arr1 and arr2 are ||| arr1 arr2	count=1
class	as ||| period index	count=2
module	shade [module_2] ||| [module_1] [module_2]	count=2
function	[function] whose columns ||| [function]	count=3
module	use this if ||| core indexes	count=1
arg	string raise a ||| cls string	count=2
class	can be used ||| frame	count=1
function_arg	[function_1] an openpyxl ||| [arg_2] [function_1]	count=1
function	[function_1] line ||| [function_2] [function_1]	count=4
function	get integer [function_2] ||| [function_1] [function_2]	count=4
function	to beginning ||| beg	count=1
function_arg	[function_1] [arg_2] dtype ||| [function_1] dtype [arg_2]	count=2
arg	1-dimensional ndarray ||| arr	count=1
arg	o and [arg] see ||| o [arg]	count=1
arg	[arg_1] from ||| [arg_2] [arg_1]	count=2
arg	which ||| to_concat	count=1
arg	from ndarray ||| data index	count=1
function	selection used ||| selection	count=1
function	gets the categories ||| categories	count=1
arg	from ndarray or ||| data index columns	count=1
function	stata [function_2] ||| [function_2] [function_1]	count=4
function	set new ||| set	count=1
function	select values between ||| between	count=2
function_arg	of same [arg_2] ||| [arg_2] [function_1]	count=1
arg	index parameters ||| index	count=1
arg	in file ||| key	count=1
function	synonym for as_blocks() ||| blocks	count=1
class	used to iterate over ||| html frame	count=1
class	multiindex ||| multi index	count=3
class	return a tree-like ||| html frame parser	count=1
module	object ||| indexes	count=1
function	already exist and ||| append	count=1
module	underlying data ||| core	count=2
function	gets ||| array wrap	count=6
function	[function_1] unordered ||| [function_1] [function_2]	count=2
arg	make a ||| deep	count=2
class	only use ||| categorical	count=1
function	that is datetimelike ||| to datetimelike	count=1
arg	of value ||| value	count=1
module	if the object ||| core dtypes	count=16
module	that can ||| io	count=1
class	same dimensions ||| ndframe	count=1
function	coerce values and ||| coerce args	count=1
function	is [function_2] ||| [function_1] line [function_2]	count=1
function	[function_1] if ||| [function_1] [function_2]	count=2
function	long ||| long	count=1
function	read from ||| read	count=2
function	create [function_2] ||| [function_2] [function_1]	count=1
arg	compute a simple ||| index columns values	count=1
arg	write records stored in ||| name if_exists	count=2
function	gradientfill stop parameter ||| stop	count=1
function_arg	[function_1] of multiple ||| [function_1] cls iterables [arg_2]	count=3
function	size ||| itemsize	count=1
module_class	slice of panel ||| core panel	count=2
arg	color_spec ||| cls color_spec	count=1
function	convert timeseries to specified ||| asfreq	count=1
function	list/array of tuples ||| tuples	count=1
function_arg	[function_1] [arg_2] ||| [function_1] matches [arg_2]	count=21
arg	and [arg] see ||| o [arg]	count=1
function	to get ||| get	count=2
function	format as dataframe ||| to frame	count=1
arg	result will respect the ||| ascending sort_remaining	count=1
function	[function_1] of given ||| [function_2] freq [function_1]	count=4
arg	using ||| inplace	count=2
function	dom ||| build doc	count=1
arg	with labels in ||| labels	count=1
function	casting ||| safe casting	count=1
arg	a ufunc needs additional ||| context	count=1
function	the category labels ||| labels	count=1
arg	[arg_1] params args ||| [arg_2] [arg_1]	count=1
function	return a string format ||| format datetime64 from	count=1
arg	frequency conversion ||| freq	count=1
function	bytes see ||| packb	count=1
arg	regular expression ||| pat case flags	count=1
class	support ||| fixed	count=1
function_arg	infer types [arg_2] ||| [function_1] [arg_2]	count=2
module	index objects ||| indexes	count=1
module	a simple cross-tabulation ||| core reshape	count=1
arg	to [arg_2] ||| [arg_1] [arg_2]	count=5
arg	have a compatiable fill_value ||| fill_value	count=1
arg	input order ||| order	count=2
arg	the shape of ||| shape	count=1
arg	left and right ||| left right check_dtype check_index_type	count=1
function	string-like that ||| convert string array	count=1
function	[function_1] exception ||| [function_2] [function_1]	count=2
module	:class ||| io	count=1
function_arg	[function_1] a sparseseries ||| [arg_2] [function_1]	count=1
function	to coerce a ||| coerce	count=2
function	a named ||| named	count=1
arg	*not* ||| other	count=1
function_arg	copy of [arg_2] ||| [function_1] [arg_2]	count=1
function	keys ||| keys	count=2
arg	selected position ||| value allow_duplicates	count=1
class	major_axis ||| ndframe	count=1
function	of available options ||| pp options	count=1
function	to sif http ||| to	count=1
class	a tree-like object ||| html	count=1
module	return [module_2] ||| [module_1] [module_2]	count=2
function	put method to its ||| put	count=1
class	midnight length is ||| datetime	count=1
class	columns excluding na/null ||| data frame	count=1
function	evaluate a binary ||| evaluate	count=1
function_arg	[function_1] arithmetic operations ||| [arg_2] [function_1]	count=12
function	add the [function_2] ||| [function_1] [function_2]	count=4
arg	of decimal places ||| decimals	count=1
arg	column by ||| name data	count=1
arg	unit if needed ||| unit	count=1
arg	already exist ||| key value	count=1
function	non-na/null observations in ||| count	count=1
arg	axes ||| axes	count=2
arg	new ||| copy errors	count=2
arg	ndarray ||| data index columns	count=1
function_arg	the where [arg_2] ||| [function_1] [arg_2]	count=4
arg	dataframe ||| data values index columns	count=1
function	sunday use day thereafter ||| sunday to	count=1
arg	sql [arg_2] ||| [arg_1] [arg_2]	count=2
function	length of a ||| length of	count=2
module	necessary for ||| core	count=1
module	fast lookup of ||| core	count=1
class	for each level ||| multi index	count=2
function	given offset/observance to ||| rule	count=1
class	[class_1] in sparse ||| [class_2] [class_1]	count=2
class	called after ||| period	count=1
function_arg	[function_1] [arg_2] ||| [function_1] indexer indexer [arg_2]	count=6
arg	we may create a ||| new align inplace	count=1
function	pandas type ||| type	count=1
module	handling ||| indexes	count=1
arg	totally ordered cartesian product ||| labels shape sort xnull	count=1
arg	to ||| key value format	count=1
function	the len of ||| size	count=1
arg	fast lookup of value ||| arr key value	count=1
arg	columns ||| index columns values	count=1
class	with times ||| datetime index	count=1
class	dimensions as ||| ndframe	count=1
class	create a new block ||| block	count=2
function	this column ||| col	count=1
arg	boolean mask for requested ||| method	count=1
module	bytes see :class ||| msgpack	count=1
arg	of two ||| other	count=6
arg	of value from ||| value	count=1
arg	of other ||| other	count=1
class	and dtype) in this ||| ndframe	count=1
function	read rows ||| get rows	count=1
function	single value at ||| value	count=1
class	the number of ||| multi	count=1
function	attempt to construct ||| construct	count=1
function	list of the ||| tolist	count=1
class	"reset" the styler ||| styler	count=1
function	options for printing and ||| options	count=1
class	series to the given ||| series	count=1
class	the underlying data ||| range	count=1
arg	have a valid ordered ||| cls ordered	count=1
class	this type ||| interval dtype	count=1
class	dtype) ||| ndframe	count=1
class	return datetimeindex with times ||| datetime index	count=1
arg	set the value inplace ||| value mgr	count=1
module	indexes give a ||| core indexes	count=1
arg	a ufunc needs ||| context	count=1
function	series/index by indicated number ||| str	count=1
function	a data ||| validate data	count=1
module	have an object dtype ||| core dtypes	count=2
function	datetimelike methods (as ||| datetimelike methods	count=1
function	that create [function_2] ||| [function_2] [function_1]	count=5
module	and dtype) in this ||| core	count=1
function	a simple ||| crosstab	count=1
function_arg	indexer even [arg_2] ||| [arg_2] [function_1]	count=1
function	the process of casting ||| casting	count=1
class	midnight ||| datetime	count=1
module	shading the ||| io	count=1
arg	of obj with indexer ||| obj indexer	count=1
class	that can be ||| frame parser	count=1
function	a table [function_2] ||| [function_1] [function_2]	count=4
function_arg	slice [arg_2] ||| [function_1] [arg_2]	count=4
arg	statistical measure using supplied ||| name window center	count=1
module	:class ||| io msgpack	count=2
function	convert :mod datetime to ||| to	count=1
arg	in file ||| key value format	count=1
function_arg	sparse [arg_2] ||| [function_1] [arg_2]	count=1
function	add the series ||| add series	count=6
arg	expected error message regular ||| exc_type exc_value trace_back	count=1
function	of putmask ||| putmask	count=1
arg	must already exist ||| value format	count=1
module	from ||| core indexes	count=2
module	be used to iterate ||| io	count=1
module	datetimeindex with times ||| core indexes	count=1
arg	against itemsize ||| itemsize	count=1
function	new index ||| new index	count=2
function	specialized intersection for datetimeindex ||| intersection	count=1
function	create the [function_2] ||| [function_1] [function_2]	count=1
function	dtype [function] ||| dtype [function] default stata	count=1
function	a registered ||| registered	count=1
module	use this if you ||| indexes	count=1
function	by default ||| sort values	count=1
function_arg	[function_1] [arg_2] ||| [function_1] can do op [arg_2]	count=4
function	from a scalar parameters ||| from scalar	count=1
function_arg	a type [arg_2] ||| [function_1] [arg_2]	count=1
arg	of multiple ||| sortorder names	count=1
class	return a categorical ||| categorical	count=1
function	data to [function_2] ||| [function_2] [function_1]	count=2
arg	[arg_1] with indexer ||| [arg_2] [arg_1]	count=2
class	to iterate ||| html frame parser	count=1
function	options for printing ||| options	count=1
class	to ||| frame parser	count=2
arg	parameter value using the ||| value	count=1
function_arg	value for [arg_2] ||| [arg_2] [function_1]	count=6
arg	input order may ||| order	count=2
function	load a pickle ||| load	count=1
arg	and jinja environment ||| cls searchpath name	count=1
arg	returning a new object ||| ignore_index verify_integrity	count=1
module	maps[0] ||| compat	count=2
class	tree-like object that can ||| frame parser	count=1
arg	and [arg] ||| o [arg]	count=1
function	length ||| len	count=2
function	after ||| array	count=3
function_arg	[function_1] multiple ||| [arg_2] [function_1]	count=3
class	reshape data ||| data frame	count=1
function	or dtype ||| dtype	count=1
module	simple ||| reshape	count=1
class	indexer ||| ndframe indexer	count=2
arg	arr for ||| arr	count=1
class	new block manager parameters ||| block manager	count=1
arg	arr1 and ||| arr1	count=1
class	that can ||| frame	count=1
arg	compute a ||| columns values	count=1
arg	j do not ||| j	count=1
function	check ||| assert	count=1
function	valid ||| has valid	count=1
function	locator based on a ||| locator	count=1
function	about a malformed ||| malformed	count=1
function	close ||| close	count=1
module	in file node ||| io	count=1
function	dictionary ||| dict from	count=1
class	to iterate over the ||| html frame parser	count=1
module	the keys ||| core	count=1
function	closed bounds ||| closed bounds	count=1
function	if we have ||| have	count=1
module	index ||| json	count=1
function_arg	quickly [function_1] [arg_2] ||| [function_1] index [arg_2] takeable	count=2
module	the node ||| io	count=1
class	object ||| index	count=1
class	of a frame ||| frame	count=1
module	to midnight ||| core indexes	count=1
function	the category labels deprecated ||| labels	count=1
function	return result as block ||| block	count=1
arg	only use ||| arr	count=1
arg	perform the ||| level limit tolerance	count=1
arg	of multiple iterables ||| iterables sortorder names	count=2
arg	3 columns of ||| index columns values	count=1
function	a custom [function_2] ||| [function_1] [function_2]	count=2
arg	3 columns of ||| columns	count=1
class	from ||| frame parser	count=1
function_arg	[function_1] [arg_2] ||| [function_1] to color [arg_2]	count=1
function_arg	[function_1] alignment_dict ||| [arg_2] [function_1]	count=1
arg	into excel for ||| excel	count=1
function	wrapper function for ||| method	count=4
arg	nan/nat from the provided ||| val	count=1
function	converts json lists to ||| convert to	count=1
arg	copy if specified ||| dtype copy	count=1
function	moving window of ||| apply window	count=1
arg	called ||| result	count=3
module	after ||| core	count=3
module	typeerror if ||| dtypes	count=1
class	times to midnight ||| datetime	count=1
class	length is ||| datetime index	count=1
function	return the join ||| get join	count=4
function	try to [function_2] ||| [function_1] [function_2]	count=2
class	return new dataframe ||| data frame	count=1
class	create a new multiindex ||| multi	count=1
arg	simple cross-tabulation of ||| index	count=1
function	numpy dtype [function] ||| dtype [function] default stata	count=1
arg	function [arg] as specified ||| [arg] kwargs	count=1
class	series [class_2] ||| [class_1] [class_2]	count=4
arg	a simple cross-tabulation of ||| columns values	count=1
function	regex pattern instance ||| re	count=2
function	trims zeros ||| trim zeros	count=2
function	like to ||| v string like	count=1
arg	from ndarray or ||| data index	count=1
function	the 'numpy' library the ||| take with	count=1
arg	be ||| new	count=1
function_arg	locator [arg_2] ||| [function_1] [arg_2]	count=1
function	[function_1] [function_2] ||| [function_1] string to [function_2]	count=2
function	both ||| equal	count=1
function	add the ||| add	count=4
function	matrix ||| matrix	count=1
class	after a ||| index	count=2
arg	and [arg] have ||| left [arg]	count=1
arg	multiple iterables parameters ||| cls iterables sortorder names	count=1
class	number of ||| multi	count=1
function	return the first element ||| item	count=1
class	this ||| index	count=3
function	id ||| id	count=1
arg	to table in file ||| key value	count=1
function	date formats to a ||| datetime to	count=1
arg	given sql [arg_2] ||| [arg_1] [arg_2] cur params	count=1
function	formatted ||| formatter func	count=1
module	have an object dtype ||| dtypes	count=2
function	sif to [function_2] ||| [function_2] [function_1]	count=1
arg	a ufunc ||| result context	count=4
function	slice the info axis ||| info slice	count=1
class	that we have ||| categorical	count=1
arg	column [arg_2] ||| [arg_2] [arg_1]	count=8
module	string in the ||| core	count=5
function	index are equal ||| index equal	count=1
arg	[arg_1] input ||| [arg_2] [arg_1]	count=8
class	the ||| table	count=1
function	gets called after ||| array wrap	count=3
function	only use this ||| set value	count=1
arg	[arg_1] values ||| [arg_2] [arg_1]	count=2
arg	table in file ||| format	count=1
module	additional ||| core indexes	count=2
arg	table in ||| value format	count=1
function	take the codes ||| take nd	count=1
arg	format files ||| format	count=1
class	exist and be table ||| hdfstore	count=1
function	via the 'numpy' library ||| take with convert	count=1
function_arg	closest period [arg_2] ||| [arg_2] [function_1]	count=1
module	more this is ||| core	count=1
module	simple cross-tabulation of ||| reshape	count=1
module	midnight length ||| core	count=1
function	header ||| header name	count=1
function	use ||| set value	count=2
function	determine if each ||| str match	count=1
class	for this ||| index col	count=1
function	[function_1] function ||| [function_1] [function_2]	count=4
function	cross-tabulation of ||| crosstab	count=1
arg	axes ||| axes dtype copy	count=1
class	of ||| multi	count=1
arg	substrings from each ||| arr start stop step	count=1
function	a feather-format object from ||| feather	count=1
function	[function_1] difference ||| [function_1] [function_2]	count=3
module	have an object ||| dtypes	count=1
arg	[arg_1] with ||| [arg_1] [arg_2]	count=4
arg	and ||| copy	count=1
arg	alignment_dict ||| alignment_dict	count=1
function_arg	[function_1] node ||| [arg_2] [function_1]	count=1
function	over the dom ||| build doc	count=1
function	len of ||| size	count=1
arg	a ||| index columns values	count=1
arg	and 'kwargs' should be ||| args kwargs	count=2
function	concatenation of ||| concat datetime	count=1
function	exist ||| append	count=1
function	argsort argsorts the value ||| argsort	count=1
arg	where ||| where	count=2
function_arg	[function_1] the nan/nat ||| [function_1] [arg_2]	count=4
module	a single element ||| core	count=1
function	return my dtype ||| dtype	count=1
class	to iterate ||| frame	count=1
arg	an ndarray copy if ||| index dtype copy	count=1
function	series extract groups from ||| extract frame	count=1
arg	indices ||| indices	count=1
function	rewrite the assignment operator ||| rewrite	count=1
arg	exist and be table ||| key value format	count=1
class	my ||| index	count=2
class	multiindex at the ||| multi	count=1
function	build ||| build	count=1
function	[function_1] types ||| [function_2] [function_1]	count=6
function	to a [function_2] ||| [function_1] str [function_2]	count=1
class	a dataframe to a ||| data frame	count=1
module	if the [module_2] ||| [module_1] [module_2]	count=15
function	csv ||| from csv	count=4
function	series [function_2] ||| [function_1] [function_2]	count=2
arg	a column ||| data	count=1
function	function for ||| comp method	count=1
function	detect terminal size and ||| terminal size	count=1
module	of ||| indexes	count=3
function_arg	shift the [arg_2] ||| [function_1] periods [arg_2]	count=1
module_class	[module_1] our ||| [module_1] [class_2]	count=2
function	[function_1] so prints ||| [function_2] [function_1]	count=8
function	in a block ||| make block	count=1
function	take a string-like ||| convert string array	count=1
class	to a dataframe ||| sparse data frame	count=1
module	the handle if ||| io	count=1
arg	unit if needed ||| cls unit	count=1
class	groupby ||| groupby	count=1
module	return ||| io formats	count=1
function	iterate over ||| build	count=1
function	fast ||| set value	count=2
arg	in ||| key value	count=1
class	row [class] ||| [class]	count=2
class	a series [class_2] ||| [class_2] [class_1]	count=4
arg	metadata if key is ||| key	count=1
class	object that can ||| frame parser	count=1
function	mode s ||| mode	count=2
function	passed type is ||| is	count=3
module	if the [module_2] ||| [module_1] [module_2] is nested list like	count=1
module	property synonym ||| core	count=1
arg	we have a dtype ||| name	count=1
function	'numpy' library the ||| with	count=1
arg	simple cross-tabulation ||| index columns	count=1
module	a typeerror if ||| core dtypes	count=1
arg	levels using [arg] ||| [arg]	count=3
function_arg	[function_1] left and ||| [function_1] arrays [arg_2]	count=1
function	handling as ||| wrap	count=1
function_arg	[function_1] array ||| [function_1] [arg_2]	count=4
class	each index ||| datetime index	count=1
function	the join ||| join	count=3
class	the number ||| range index	count=1
function	[function_1] formats to ||| [function_2] [function_1]	count=6
arg	requested level [arg_2] ||| [arg_2] [arg_1]	count=1
arg	cross-tabulation of ||| columns	count=1
arg	raises notimplentederror ||| i	count=1
class	used ||| html frame parser	count=2
arg	[arg_1] data ||| [arg_2] [arg_1]	count=2
function_arg	[function_1] new item ||| [function_1] [arg_2]	count=1
class	[class_1] column ||| [class_2] [class_1]	count=2
function	[function_1] set ||| [function_2] [function_1]	count=2
class	render a ||| formatter	count=2
arg	dataframe ||| data x y	count=1
module	return ||| indexes	count=4
function	to a ||| datetime to	count=1
module	1-dimensional ndarray ||| indexes	count=1
arg	to table in ||| value format	count=1
class	support start [class_2] ||| [class_2] [class_1]	count=2
arg	that are available on ||| prefix normalize locale_getter	count=1
function	iterate ||| build	count=1
function	return the full ||| full	count=1
arg	new datacol ||| name cname	count=1
arg	the key for ||| key	count=1
arg	append to table ||| key value format append	count=1
class	new block [class_2] ||| [class_2] [class_1]	count=3
module	by default ||| io formats	count=1
function	protection object ||| protection	count=1
function	size and return tuple ||| size	count=1
module_class	[module_1] block ||| [module_1] [class_2]	count=5
class	value ||| float array formatter	count=1
function	xpath ||| xpath	count=1
function	the union ||| union	count=3
function	doesn't like to ||| string like	count=1
arg	using indicated ||| errors	count=2
function	take a string-like that ||| string array	count=1
module	raise keyerror is ||| compat	count=1
arg	frequency conversion [arg_2] ||| [arg_2] [arg_1]	count=1
function	convert ||| convert	count=15
function_arg	moving window [arg_2] ||| [function_1] [arg_2]	count=1
function	[function_1] [function_2] ||| [function_1] from [function_2]	count=1
function	feather-format object from the ||| feather	count=1
class	of datetime time ||| datetime	count=1
arg	in i ||| i before_day_of_month after_day_of_month	count=1
arg	right [arg_2] ||| [arg_1] [arg_2]	count=2
arg	indexer and return them ||| indexer axis	count=2
function_arg	template and [arg_2] ||| [function_1] [arg_2]	count=1
arg	series or [arg_2] ||| [arg_2] [arg_1]	count=8
function_arg	infer types [arg_2] ||| [arg_2] [function_1]	count=2
arg	file node ||| value	count=1
arg	return python ||| datestr	count=1
module	datetimeindex ||| indexes	count=1
arg	the new type ||| dtype copy errors	count=2
function	set a [function_2] ||| [function_2] [function_1]	count=1
module	only use this if ||| core	count=1
class	of python datetime ||| datetime index	count=1
arg	to the new type ||| dtype copy	count=2
class	of index ||| datetime index	count=1
class	panel ||| panel	count=8
function	needs additional handling as ||| array	count=1
arg	indexer and return ||| indexer axis	count=2
arg	[arg] nans and ||| [arg]	count=1
module_class	[module_1] from the ||| [module_1] sparse [class_2]	count=1
class	index objects ||| range index	count=3
module	if not ||| core	count=2
arg	n between ||| n	count=1
function	a scalar to a ||| scalar to	count=1
function	timedelta-like to ||| td index cmp	count=1
module	times to midnight ||| indexes	count=1
function_arg	[function_1] same ||| [function_1] [arg_2]	count=2
function	strides ||| strides	count=1
arg	query [arg] ||| expr [arg]	count=3
function	index [function_2] ||| [function_1] [function_2]	count=2
function	1-dimensional ndarray only ||| set	count=1
arg	object coercible ||| other join overwrite filter_func	count=1
arg	into a dataframe ||| index_col coerce_float parse_dates	count=1
function	init self from ||| init	count=1
module_class	replace specific elements in [module_1] [class_2] with given values ||| [module_1] [class_2]	count=1
module	additional handling as ||| indexes	count=1
function	[function_1] stata ||| [function_1] [function_2]	count=2
function_arg	array of [arg_2] ||| [function_1] vals [arg_2]	count=1
arg	the we have a ||| name	count=1
class	over ||| frame	count=2
class	a series we ||| series group	count=1
module	use this if ||| indexes	count=1
arg	use this if ||| arr	count=1
module	get ||| core	count=1
function	return a formatter ||| get	count=1
class	return an ||| index	count=1
arg	input values as ||| values sort order na_sentinel	count=1
function	[function_1] to beginning ||| [function_2] [function_1]	count=1
arg	and expected ||| exc_type exc_value trace_back	count=1
arg	boolean if we ||| b	count=1
function	minor ||| minor	count=1
function	coerce ||| coerce args	count=1
arg	totally ordered ||| xnull	count=1
module	[module] | ||| [module]	count=1
function	a sparse [function_2] ||| [function_1] [function_2]	count=1
function_arg	[function_1] separate ||| [function_1] excel [arg_2]	count=1
function	:class packer for options ||| packb	count=1
class	block and ||| block manager	count=1
function	as a ||| values	count=1
arg	[arg_1] right ||| [arg_2] [arg_1]	count=19
class	each interval ||| interval	count=1
arg	values possibly casting ||| values na_values try_num_bool	count=2
module	with ||| indexes	count=1
function	from sif to datetime ||| elapsed date to datetime	count=1
arg	from 1-dimensional ndarray only ||| key	count=1
class	number ||| index	count=2
module	up ||| formats	count=1
function	several cases to get ||| get	count=1
function_arg	[function_1] dtype of ||| [function_1] [arg_2]	count=2
arg	frequency ||| freq	count=11
function	return true if ||| is in	count=1
arg	fname are ||| fname	count=1
function	table [function_2] ||| [function_2] [function_1]	count=4
module	needs ||| indexes	count=1
arg	unit ||| unit	count=1
function	to coerce a ||| coerce freq	count=1
function	reindex for ||| reindex	count=1
arg	encoding ||| encoding	count=3
function_arg	to beginning [arg_2] ||| [function_1] apply index i [arg_2]	count=1
class	return the number of ||| index	count=2
arg	an index ||| index	count=1
function	to take optional positional ||| optional	count=1
class	are valid stata ||| stata	count=1
function_arg	copy of [arg_2] ||| [arg_2] [function_1]	count=1
function	doesn't like to ||| v string like	count=1
function	the fill ||| fill	count=1
function_arg	[function_1] string ||| [function_1] [arg_2]	count=2
function_arg	convert sql ||| convert params sql	count=1
function	block ||| getitem block	count=1
class	additional handling as ||| period	count=1
module	that do not ||| util	count=1
module	product [module] all ||| [module]	count=1
arg	exist ||| key	count=1
arg	a particular axis with ||| axis join	count=1
function	table reflecting ||| table setup	count=2
function	custom template and ||| from custom template	count=2
function	series/index by ||| str	count=3
class	column ||| col	count=1
arg	the provided array or ||| arr_or_dtype	count=3
function	dtype to return ||| dtype	count=1
function	display [function_2] ||| [function_1] [function_2]	count=4
arg	if label ||| label side kind	count=1
arg	already exist and be ||| format	count=1
function	parms ||| parms	count=1
function	dictionary for ||| axes dict from	count=1
module	same dimensions ||| core	count=1
arg	pat ||| arr pat	count=1
function	mode s of ||| mode	count=1
function	cross-tabulation ||| crosstab	count=1
function	our asof key ||| asof key	count=2
arg	data ||| data	count=6
arg	on 3 columns of ||| columns values	count=1
arg	freq with ||| freq	count=1
function	to the ||| block2d to	count=1
arg	value from 1-dimensional ||| arr key value	count=1
arg	as the default frequency ||| periods freq	count=2
module_class	[module_1] dataframe ||| [module_1] [class_2]	count=6
arg	a simple cross-tabulation ||| index	count=1
function	wrap result set ||| wrap result	count=2
class	underlying array ||| datetime index ops mixin	count=1
arg	values along ||| values	count=1
class	excluding elements from groups ||| group	count=1
class	return a tree-like object ||| html	count=1
function_arg	the type [arg_2] ||| [arg_2] [function_1]	count=1
function	fast lookup ||| set value	count=1
class	return index or ndarray ||| index ops mixin	count=1
function	a string representation ||| unicode	count=1
function	draw histogram of ||| hist frame	count=2
class	truncates a sorted ndframe ||| ndframe	count=1
class	[class] having ||| [class]	count=3
function	that we ||| dtype	count=1
class	over ||| html	count=1
module	times to midnight length ||| core	count=1
arg	key ||| key	count=5
arg	dtype ||| result dtype	count=1
module	dimensions as the ||| core	count=1
class	and ||| ndframe	count=2
arg	only - where ||| where	count=1
arg	columns using input function ||| copy inplace	count=1
function	integer stride [function_2] ||| [function_2] [function_1]	count=1
function	returns the base ||| base	count=1
function_arg	location slice or ||| loc key	count=1
function_arg	[function_1] code to ||| [arg_2] [function_1]	count=2
class	interval ||| interval	count=2
class	[class] essentially equivalent ||| [class]	count=2
module	tree-like object that ||| io	count=1
arg	arr to ||| arr new_shape	count=1
function	vectorized apply ||| apply	count=1
function_arg	from the [arg_2] ||| [function_1] unit mappings [arg_2]	count=1
function	that is datetimelike ||| datetimelike	count=1
module	the built ||| io	count=1
class	after ||| series	count=1
function	validate that an positional ||| positional	count=1
arg	a function ||| func	count=4
arg	converts [arg_2] ||| [arg_2] [arg_1]	count=2
function_arg	[function_1] [arg_2] ||| [function_1] cls values [arg_2]	count=2
arg	using input function or ||| mapper axis copy inplace	count=1
class	if ||| series	count=1
function_arg	[function_1] a higher ||| [arg_2] [function_1]	count=1
function	to compare numeric ||| numeric v	count=1
function	/ pandas type ||| type	count=1
function_arg	a datetimelike [arg_2] ||| [function_1] [arg_2]	count=3
function	time objects ||| time	count=1
function_arg	to [arg_2] ||| [function_1] latex [arg_2]	count=1
arg	or regular expression in ||| pat flags	count=1
arg	data corresponding to axis ||| axis	count=1
class	datetimeindex ||| datetime index	count=3
arg	to indexer and return ||| indexer	count=2
class	has ||| series	count=1
function	a custom template and ||| from custom template	count=1
arg	column ||| value	count=1
function_arg	[function_1] from ndarray ||| [function_1] matrix [arg_2]	count=1
function_arg	[function_1] value ||| [arg_2] [function_1]	count=1
class	never a ||| categorical	count=1
function	for [function_2] ||| [function_1] [function_2]	count=3
arg	value is ||| value	count=1
function	only ||| value	count=1
function	exist and be table ||| append	count=1
arg	we have ||| name freq	count=1
class	can ||| frame parser	count=2
arg	an ndarray copy if ||| dtype copy	count=1
function	of ops ||| ops	count=1
arg	other to the end ||| other	count=1
function	i ||| is	count=1
function	dictionary for ||| dict from	count=1
class	a ||| period index	count=2
function_arg	[function_1] slice ||| [arg_2] [function_1]	count=3
function	optional positional ||| optional	count=1
function_arg	[function_1] duplicate values ||| [arg_2] [function_1]	count=1
function_arg	to determine [arg_2] ||| [function_1] [arg_2]	count=1
function	we have ||| validate	count=1
arg	axis with [arg_2] ||| [arg_2] [arg_1]	count=1
function_arg	check [arg_2] ||| [arg_2] [function_1]	count=4
function	that we have a ||| validate	count=1
arg	ndarray copy if ||| dtype copy	count=1
function_arg	convert a [arg_2] ||| [function_1] to style kwargs [arg_2]	count=1
module_class	return the i-th value [module_1] [class_2] by location ||| [module_1] [class_2]	count=1
class	of group excluding ||| group by	count=2
function	of take ||| assert take	count=2
function	with ||| with	count=1
class	the built up styles ||| styler	count=1
function	of openpyxl is ||| is	count=1
class	a blockmanager ||| block manager	count=1
arg	time and [arg_2] ||| [arg_2] [arg_1]	count=1
function	dictionary for the ||| axes dict from	count=1
function	options ||| packb	count=1
class	am ||| block	count=1
function	infer the fill ||| infer fill	count=2
function_arg	[function_1] data ||| [arg_2] [function_1]	count=9
function	to parse datetime ||| parse	count=1
function_arg	to [arg_2] ||| [function_1] style [arg_2]	count=1
function	from 1-dimensional ndarray only ||| set value	count=1
arg	style_dict ||| style_dict	count=4
function	is a number ||| is number	count=3
module	frequency datetime index ||| core indexes	count=2
arg	function to my values ||| func	count=1
function	wide panel to long ||| wide to long	count=1
function	offset/observance ||| rule	count=1
function	matrix of ||| matrix	count=1
class	index objects contain ||| index ops mixin	count=1
function	a moving window ||| window	count=1
arg	an indexer like ||| name indexer	count=1
function	argsort argsorts ||| argsort	count=1
function	return a string format ||| format datetime64	count=1
class	float values converted ||| float array	count=1
function	simple ||| crosstab	count=1
function	add in [function_2] ||| [function_1] [function_2]	count=1
arg	data rows/cols [arg] idx_names - ||| nrows ncols [arg]	count=1
class	built ||| styler	count=1
class	iterate ||| frame parser	count=2
arg	this if ||| arr key	count=1
function	sparseseries [function_2] ||| [function_2] [function_1]	count=1
class	only [class_2] ||| [class_2] [class_1]	count=2
function	doesn't like to compare ||| like	count=1
arg	render a ||| buf columns col_space	count=1
function	handle na filling ||| fillable	count=2
function	make a copy of ||| copy	count=1
arg	and right ||| right check_dtype	count=3
module	all of the ||| core	count=1
function	of casting ||| safe casting	count=1
arg	string raise a ||| string	count=2
function_arg	[function_1] values ||| [arg_2] [function_1]	count=2
arg	default frequency ||| periods freq	count=3
arg	op on [arg_2] ||| [arg_2] [arg_1]	count=3
module_class	length is [class_2] ||| [module_1] [class_2]	count=2
function	is of a string-like ||| is string	count=1
function	indices overlap add ||| overlap	count=1
function	function for ||| func	count=3
class	fast ||| index	count=1
arg	already ||| format	count=1
class	from maps[0] ||| chain map	count=1
arg	values along a ||| values	count=1
arg	and plural 'names' ||| name names deep	count=1
arg	indicated number of times ||| repeats	count=1
module	the ||| io json	count=1
class	this ||| period index	count=1
function	an positional ||| positional	count=1
module	the ||| core indexes	count=8
arg	of the values ||| values	count=1
function	list replace ||| replace list	count=1
function_arg	[function_1] among the ||| [arg_2] [function_1]	count=1
arg	t or tuple ||| t	count=1
arg	lookup of value ||| arr key value	count=1
arg	be table ||| key	count=1
arg	fill value parameters ||| fill_value	count=1
function	sparseseries ||| to	count=1
function_arg	quickly retrieve single [function_1] [arg_2] ||| [function_1] [arg_2]	count=3
function	open ||| open	count=1
arg	row ||| row	count=1
class	as a frame table ||| multi series table	count=1
arg	self f skipping ||| n skiprows	count=1
module_class	of this [class_2] ||| [module_1] [class_2]	count=2
function	[function_1] value ||| [function_2] [function_1]	count=4
module	called ||| core	count=3
function	return dtype ||| dtype	count=1
function	[function_1] difference ||| [function_2] [function_1]	count=3
arg	expression as ||| expr	count=1
class	returns a dataframe ||| data frame	count=1
arg	do ||| src_list dest_list inplace	count=1
module	index for ||| core	count=1
arg	blocks collect and create ||| f axis consolidate transposed	count=1
arg	for the dtype of ||| dtype	count=1
class	midnight length ||| datetime index	count=1
function	backward to next ||| rollback	count=1
function	[function_1] scalar ||| [function_2] [function_1]	count=3
function	from the cartesian product ||| from product	count=1
module	return my ||| core	count=1
module	is ||| indexes	count=2
arg	optional fill value parameters ||| fill_value	count=1
function	[function_1] and create ||| [function_1] [function_2]	count=6
function	[function_1] options ||| [function_1] [function_2]	count=3
class	resolution ||| resolution	count=1
function_arg	with the [arg_2] ||| [function_1] node [arg_2]	count=4
module	a single element pandasobject ||| core	count=1
arg	over the blocks collect ||| f axis consolidate transposed	count=1
arg	axis [arg_2] ||| [arg_1] [arg_2]	count=3
module	values ||| core	count=1
class	node must already exist ||| hdfstore	count=1
function	valid for scalar op ||| can do op	count=1
function	localize tz-naive timeseries to ||| tz localize	count=1
class	return a new block ||| sparse block	count=1
function	is a [function_2] ||| [function_2] [function_1]	count=8
function	a string cast it ||| maybe cast	count=1
function	to scipy [function_2] ||| [function_2] [function_1]	count=2
function	base ||| get base	count=1
arg	[arg_1] right data ||| [arg_2] [arg_1]	count=1
function_arg	[function_1] the function ||| [arg_2] [function_1]	count=1
module	when a ||| core	count=1
class	into a list of ||| frame parser	count=1
function	string format ||| format datetime64	count=1
module	and ||| core	count=2
class	can be used ||| html	count=1
arg	block [arg_2] ||| [arg_2] [arg_1]	count=4
arg	regular expression in ||| pat flags	count=1
class	get the ||| ndframe	count=1
arg	tabular ||| buf columns col_space header	count=1
class	support start ||| fixed	count=1
function	string for this ||| generate	count=1
arg	table in file node ||| key	count=1
class	return ||| of merge	count=1
arg	needs additional ||| result	count=1
arg	frequency conversion method for ||| freq method	count=1
module	after ||| indexes	count=2
function	true if the levels ||| levels	count=1
function	type to ||| type	count=1
arg	if label is not ||| label	count=1
module	to table in ||| io	count=1
arg	the indexer ||| indexer	count=2
function	determine if ||| str match	count=1
class	sort multiindex ||| multi index	count=1
arg	to ||| cls name func	count=1
function	of available options grouped ||| options	count=1
function	the 'numpy' library ||| take with convert	count=1
function_arg	[function_1] [arg_2] the provided connection object ||| [function_1] [arg_2]	count=1
class	new manager with the ||| manager	count=1
module	[module] | with ||| [module]	count=1
function	the intersection ||| intersection	count=2
function	types format slicing if ||| types	count=3
function	[function] using fixed ||| [function]	count=2
function	string-like ||| string array	count=2
module	the ||| io formats	count=6
function	take values ||| take	count=2
class	index for series columns ||| ndframe	count=1
arg	[arg] on ||| [arg] plotf	count=2
arg	append to ||| value format append	count=1
arg	decorator to run the ||| num_threads kwargs_list	count=1
function	of entries in index ||| custom index	count=1
module	if you ||| indexes	count=1
arg	already exist ||| format	count=1
function	[function_1] stderr in ||| [function_1] [function_2]	count=3
class	tree-like object that ||| html frame parser	count=1
module	index ||| indexes	count=5
class	get ||| timedelta index	count=1
arg	against the ||| cls	count=1
arg	date_format return a string ||| date_format	count=1
function_arg	[function_1] [arg_2] the provided connection object ||| io [function_1] [arg_2] params	count=1
arg	of a func ||| func	count=1
arg	to class ||| cls name func	count=1
arg	data rows/cols [arg] idx_names ||| nrows ncols [arg]	count=1
arg	expression as a ||| expr	count=1
function	repr function return ||| repr	count=1
arg	data ||| data groups dropna	count=1
class	is ||| map	count=1
function	scipy [function_2] ||| [function_2] [function_1]	count=2
class	values ||| series	count=2
arg	[arg_1] [arg_2] ||| eval [arg_1] [arg_2]	count=4
function	available options ||| pp options	count=1
function	a set of subplots ||| subplots	count=1
function	a custom [function_2] ||| [function_2] [function_1]	count=2
class	a single block ||| block	count=1
module	in file ||| io	count=1
class	raise keyerror is ||| chain map	count=1
arg	valid ordered parameter if ||| cls ordered	count=1
module	compute locations of ||| core	count=1
module	internal ||| core	count=1
function	the counts [function_2] ||| [function_2] [function_1]	count=6
function	hard to parse datetime ||| parse	count=1
function	matches [function_2] ||| [function_2] [function_1]	count=4
function	interpolation ||| interpolate	count=1
arg	[arg_1] index ||| [arg_2] [arg_1]	count=1
function	indexers ||| indexers	count=2
class	block and are a ||| block	count=1
class	dateoffset ||| date offset	count=1
function	last ||| last	count=2
function	going to write this ||| write	count=1
function	string format ||| format	count=1
class	for ||| sparse	count=1
function	read rows ||| rows	count=1
class	data ||| data frame	count=3
class	needs additional handling as ||| period index	count=1
class	an ||| datetime index	count=1
module	see :class ||| io	count=1
module	gets ||| indexes	count=2
class	to iterate ||| html	count=1
function_arg	[function_1] frequency ||| [function_1] [arg_2]	count=4
class	level ||| multi	count=1
function	list of columns as ||| columns	count=1
module	setup our ||| core	count=1
arg	pat ||| pat	count=2
module	[module_1] expression ||| [module_1] [module_2] bin op convert value	count=1
function_arg	[function_1] period frequency ||| [arg_2] [function_1]	count=3
arg	by a series of ||| by	count=1
arg	reset_index ||| level drop name	count=1
arg	occupying requested label default ||| label default	count=1
function	index ||| to index	count=1
module	for ||| io msgpack	count=2
function_arg	in y ||| in x y	count=1
function	if we ||| is	count=4
function	rec [function_2] ||| [function_1] [function_2]	count=5
function	numeric ||| is numeric v string	count=1
function	return true if this ||| is	count=2
function	a cross-section ||| xs	count=1
module	property property synonym for ||| core	count=1
class	used to iterate ||| frame parser	count=1
arg	arr ||| arr	count=3
class	render a dataframe ||| data frame	count=3
arg	from each element ||| arr	count=1
arg	by the indexer ||| indexer	count=1
function	put method ||| put	count=1
class	create index with ||| index	count=1
class	return result block ||| block	count=2
function	is valid for scalar ||| can do	count=1
function_arg	[function_1] slice ||| [function_1] [arg_2]	count=3
function	ndarray argsort argsorts the ||| argsort	count=1
function	1 0 number ||| number	count=1
arg	must already exist and ||| key value format	count=1
function_arg	offset/observance to [arg_2] ||| [function_1] [arg_2]	count=1
function	array or dtype ||| dtype	count=1
function_arg	[function_1] against ||| [function_1] [arg_2]	count=5
arg	ndarray or list of ||| data index columns	count=1
class	styler with ||| styler	count=1
class	over ||| html frame parser	count=2
arg	must already ||| key	count=1
function	the keys corresponding ||| keys	count=1
module	simple ||| core	count=1
class	over [class_2] ||| [class_2] [class_1]	count=2
arg	or so [arg] bitwise precedence ||| [arg]	count=1
function	of tuples ||| tuples	count=1
function	pick the best locator ||| get locator	count=1
function	form the union of ||| union	count=2
function	matches ||| matches	count=1
function	setup our binners ||| set binner	count=1
class	columns excluding ||| data frame	count=1
class	end of this frame ||| frame	count=1
class	of the timedeltas ||| index	count=1
class	data (produce a ||| data frame	count=1
arg	a axes ||| axes	count=1
module	the store close ||| io	count=1
class	a series ||| sparse series	count=1
function	fixed ||| bdate range	count=1
function	required package ||| package	count=1
class	the ||| range index	count=2
function	additional handling ||| wrap	count=1
function	we [function_2] ||| [function_1] [function_2]	count=5
function	the bom ||| bom	count=1
function	categoricals are the ||| equal	count=1
function	float ||| float	count=3
arg	style_dict ||| style_dict num_format_str	count=1
function_arg	[function_1] [arg_2] ||| [function_1] nrows [arg_2]	count=3
function	a type in ||| type	count=1
function	by ||| sort	count=1
class	the number ||| multi	count=1
function	raw [function_2] ||| [function_1] [function_2]	count=1
arg	a [arg_2] ||| [arg_2] [arg_1]	count=4
class	tree-like object that can ||| frame	count=1
function	checks whether ||| check for	count=1
class	to iterate ||| parser	count=1
arg	indexer ||| indexer axis	count=2
arg	object coercible ||| join overwrite filter_func	count=1
arg	into a dataframe ||| index_col coerce_float	count=1
function	missing indexers ||| missing	count=1
class	validate ||| index col	count=1
function	dtype to return if ||| dtype	count=1
arg	you ||| key	count=1
rep	this type [function_arg_2] ||| [module_class_1] construct [function_arg_2]	count=4
arg	must already exist and ||| format	count=1
class	built up styles to ||| styler	count=1
class	to iterate over the ||| frame	count=1
class	as ||| period	count=1
function	add ||| add aggregate	count=1
class	index for ||| ndframe	count=1
function	making this object picklable ||| reduce	count=1
function	the 'numpy' library ||| validate take with	count=1
function	rows ||| get rows	count=1
module	only the ||| io	count=1
class	resolution str ||| resolution	count=1
function_arg	[function_1] indexer and ||| [function_1] [arg_2] new_mgr_locs fill_tuple	count=1
module	shade the background ||| io formats	count=2
function	construct concatenation plan ||| mgr concatenation plan	count=2
function_arg	function [arg_2] ||| cython [function_1] [arg_2]	count=3
class	copy of a series ||| series	count=1
function	'numpy' library the ||| with convert	count=1
function_arg	where statement ||| where w	count=1
function_arg	align a [arg_2] ||| [function_1] [arg_2]	count=1
module	ndarray only use ||| indexes	count=1
module	times to ||| indexes	count=1
class	of the ||| timedelta index	count=1
class	exist and ||| hdfstore	count=1
function	dtype then fill ||| fill	count=1
function	[function_1] op ||| [function_1] [function_2]	count=4
function	an iterator ||| iterator	count=1
arg	dataframe ||| data columns	count=1
function	for our index ||| index	count=1
arg	from ndarray or list ||| index	count=1
arg	of rows if n ||| n dropna	count=1
function	prior to a ||| prepare	count=1
function	mixed type ||| chained assignment possible	count=1
class	a ||| ndframe	count=2
function	return the correct ||| get	count=1
function	color object parameters ||| color	count=1
arg	[arg_1] function ||| [arg_1] [arg_2]	count=2
class	axis ||| ndframe	count=1
module	is index for series ||| core	count=1
arg	after a ||| result	count=3
arg	3 columns of this ||| index columns	count=1
arg	node ||| key	count=1
function	named ||| named	count=1
function	an asof ||| asof	count=1
class	array ||| array	count=1
function	names ||| default names	count=2
arg	dict of dtypes if ||| dtypes	count=1
module	frequency datetime index with ||| core indexes	count=1
module	is ||| compat	count=1
function	by ||| sort values	count=2
arg	indexer fill with the ||| indexer	count=1
arg	input ||| copy	count=1
function	and if [function_2] ||| [function_2] [function_1]	count=6
arg	the function to ||| func	count=1
arg	fill_value and [arg_2] ||| [arg_2] [arg_1]	count=4
function	called ||| array wrap	count=6
function	of type ||| is type	count=1
arg	[arg_1] from some ||| [arg_2] [arg_1]	count=2
function_arg	define [function_1] [arg_2] ||| [function_1] [arg_2]	count=8
arg	of value ||| arr key value	count=1
arg	node must already ||| format	count=1
function_arg	[function_1] color_spec ||| [function_1] to color [arg_2]	count=1
arg	of times ||| arr repeats	count=1
arg	the other axis ||| axis	count=1
function_arg	difference [arg_2] ||| [function_1] [arg_2]	count=1
function_arg	result [arg_2] ||| [function_1] [arg_2]	count=3
function	specified categories ||| remove categories	count=1
function	return packed ||| packb	count=1
arg	new type ||| dtype copy errors	count=2
arg	obj with [arg_2] ||| [arg_2] [arg_1]	count=1
function	values ||| na values	count=1
class	iterate over the ||| html frame parser	count=1
class	of the ||| index	count=2
function	test [function_2] ||| [function_2] [function_1]	count=4
function	: write out the ||| write	count=1
function	names to ||| names	count=1
arg	v should be inserted ||| v	count=1
module_class	the block ||| core block	count=1
class	the exception raised ||| assert raises	count=1
arg	ufunc needs additional handling ||| result context	count=1
class	into a list of ||| html frame parser	count=1
arg	default implementation ||| op_classes	count=1
function	to stata's ||| to	count=1
function	of putmask that ||| putmask	count=1
module_class	of blockmanager ||| core block manager	count=1
arg	rows if n ||| n	count=1
function	levels ||| levels	count=3
module	only use ||| indexes	count=1
arg	gets called ||| result	count=3
arg	data to an ||| data	count=1
arg	a simple cross-tabulation ||| values	count=1
function	the description ||| description	count=1
function_arg	[function_1] file path ||| [function_1] [arg_2]	count=1
arg	to returning ||| inplace verify_integrity	count=1
function	this colummn ||| attr	count=1
function	that can ||| build	count=1
function	dtype [function_2] ||| [function_2] [function_1]	count=6
arg	slice ||| key	count=1
module	attribute if ||| core	count=1
class	be used to iterate ||| parser	count=1
function	dtype str ||| dtype str	count=2
arg	difference of [arg_2] ||| [arg_2] [arg_1]	count=8
function	value to format it ||| value	count=1
function	we have ||| is	count=2
arg	scalar data ||| cls data	count=1
arg	null_color for missing ||| null_color	count=1
function	value to ||| value	count=1
function	transform ||| transform	count=2
function	block ||| block	count=4
function	take the codes by ||| take nd	count=1
module	[module] most recent ||| [module]	count=1
class	object that ||| html frame	count=1
module	the values ||| core	count=1
function_arg	[function_1] font_dict ||| [function_1] to font [arg_2]	count=1
arg	already exist and ||| key value format	count=1
class	and major_axis ||| ndframe	count=1
function	return ||| build	count=1
arg	of arr1 ||| arr1	count=1
function	find all occurrences of ||| findall	count=1
arg	ncols - number ||| ncols	count=1
function_arg	[function_1] block ||| [function_1] periods axis [arg_2]	count=1
arg	series ||| series ax	count=1
module	the expression that ||| core computation	count=1
function	entries in index ||| custom index	count=1
function	csv file ||| from csv	count=2
arg	whether [arg_2] ||| [arg_2] [arg_1]	count=2
arg	[arg_1] boolean ||| [arg_2] [arg_1]	count=2
function_arg	from [arg_2] ||| [function_1] arrays [arg_2]	count=4
module	as ||| core	count=2
function	assemble the [function_2] ||| [function_1] from [function_2]	count=1
function	that an positional ||| valid positional setitem	count=1
function	return the dtype ||| dtype	count=1
class	[class_1] a dataframe ||| [class_2] [class_1]	count=4
module	return an ||| core computation	count=2
function	take values ||| take nd	count=2
function_arg	determines if two ||| equals other	count=4
class	return ||| interval index	count=1
function	feather-format for dataframes ||| feather	count=1
function_arg	[function_1] [arg_2] ||| [function_1] arr1 [arg_2]	count=3
module	if the ||| core	count=11
function_arg	[function_1] to the ||| [arg_2] [function_1]	count=3
function	from 1-dimensional ndarray only ||| set	count=1
class	validates that we ||| categorical	count=1
arg	and be ||| key	count=1
arg	parameter value using ||| value	count=1
arg	inserting new [arg] at ||| loc [arg]	count=1
arg	separate ||| path na_rep engine	count=1
class	checks ||| python parser	count=1
arg	or by a series ||| by axis	count=1
arg	a new datacol with ||| name cname	count=1
arg	fill_value ||| allow_fill fill_value	count=1
class	am never ||| block	count=1
arg	the compared against itemsize ||| itemsize	count=1
class	return the ||| categorical	count=1
class	index ||| index ops	count=2
arg	columns of this ||| columns	count=1
module_class	and replaces these with [module_1] [class_2] value ||| [module_1] [class_2] writer replace nans	count=1
module	a simple ||| core	count=1
function	[function_1] of ||| [function_2] [function_1]	count=1
function_arg	[function_1] data from ||| [function_1] [arg_2]	count=4
arg	in ||| format	count=1
arg	right array ||| right closed	count=2
arg	node must ||| key value format	count=1
function	names to 'index' for ||| names	count=1
function	handling as ||| array wrap	count=1
function	a block of ||| block	count=1
class	same dimensions as ||| ndframe	count=1
function_arg	[function_1] labels shape ||| [arg_2] [function_1]	count=1
function	extension ||| extension	count=1
class	times to ||| datetime	count=1
module	of sparseseries ||| core sparse	count=2
function	and n/a ||| and	count=1
module	:class packer ||| msgpack	count=1
function_arg	[function_1] to have ||| [function_1] [arg_2]	count=3
class	datetime time the ||| datetime	count=1
function_arg	unpack [arg_2] ||| [arg_2] [function_1]	count=3
class	be used to iterate ||| html	count=1
function	full length [function_2] ||| [function_2] [function_1]	count=1
class	return datetimeindex ||| datetime	count=1
function	index ||| make custom index	count=1
arg	and index parameters ||| index	count=1
function	and returns axes ||| axes	count=1
function	validate ||| validate	count=7
arg	for requested label ||| key method tolerance	count=3
arg	use this if ||| key	count=1
class	if it ||| series	count=1
function	localize tz-naive datetimeindex ||| localize	count=1
class	return result block from ||| block	count=1
function	to coerce ||| coerce	count=2
module	bytes ||| msgpack	count=1
arg	dtype if dtype is ||| dtype	count=1
class	maximum ||| ops mixin	count=1
class	dtype) in ||| ndframe	count=1
function	additional ||| wrap	count=1
arg	of deterministic integers ||| encoding hash_key categorize	count=1
module	[module] consensus ||| [module]	count=1
function_arg	[function_1] jinja environment ||| [arg_2] [function_1]	count=3
module	map values [module] series using ||| [module]	count=1
module	element in the ||| core	count=2
class	pointer of the underlying ||| index ops mixin	count=1
function	to determine ||| n method	count=1
function	of kwargs ||| kwargs	count=1
module	property property ||| core	count=1
module	with [module] | with ||| [module]	count=1
arg	type ||| placement	count=1
module	this ||| indexes	count=2
module	return ||| io	count=2
function	install ||| coerce method	count=1
class	of group ||| group	count=2
class	[class] having a ||| [class]	count=3
function	[function_1] cast the ||| [function_1] [function_2]	count=1
function	fast transform path for ||| transform fast	count=1
class	up styles to ||| styler	count=1
class	labels returning a dataframe ||| data frame	count=1
arg	new [arg] at ||| loc [arg]	count=1
class	my specific ||| interval index	count=1
function	elements ||| size	count=1
module_class	convert the [class_2] ||| [module_1] [class_2]	count=2
function	[function_1] html ||| [function_1] [function_2]	count=2
function	convert an ||| convert	count=1
class	length ||| datetime	count=1
arg	o and return ||| o	count=1
arg	node must already exist ||| format	count=1
function	(e g [function_2] ||| [function_1] [function_2]	count=1
function	construct ||| construct	count=2
class	panel to ||| panel	count=1
function_arg	[function_1] dtype converting ||| [function_1] [arg_2]	count=2
function	freq with decimal stride ||| decimal	count=1
module	compute a simple ||| core	count=1
class	series of columns ||| ndframe	count=1
function	slice/take blocks ||| slice take blocks	count=1
module	the ||| plotting	count=3
module	called after a ||| indexes	count=2
module	pandasobject ||| core	count=1
class	excluding elements from ||| group	count=1
arg	value inplace ||| value mgr	count=1
module	with times ||| indexes	count=1
class	tree-like object ||| parser	count=1
module	to ||| indexes	count=1
module	[module_1] function ||| [module_1] [module_2]	count=2
function_arg	[function_1] indexer ||| [arg_2] [function_1]	count=4
function	a masked ||| masked	count=1
arg	to table in file ||| key value format	count=1
arg	the value inplace ||| value mgr	count=1
function	put method to ||| put	count=1
arg	convenience function for ||| xi yi x order	count=1
class	return index ||| datetime index	count=1
function	options for ||| options	count=1
function	this if you ||| value	count=1
module	return ||| io msgpack	count=2
arg	so [arg] bitwise ||| [arg]	count=1
function	packed bytes see ||| packb	count=1
arg	interval with ||| interval	count=1
function	sunday use day ||| sunday	count=1
class	block from the ||| block	count=1
class	our ||| resampler	count=4
function_arg	result set [arg_2] ||| [arg_2] [function_1]	count=3
module	and return ||| compat	count=1
function	bind ||| bind	count=1
arg	for the values ||| values	count=1
arg	rows of other ||| other	count=1
function	needs additional ||| array wrap	count=1
function	memory ||| memory	count=2
arg	to table in ||| key value format	count=1
function	parse the [function_2] ||| [function_1] [function_2]	count=2
function	a sequence of objects ||| sequence	count=1
function	stata ||| stata elapsed	count=1
arg	an indexer like ||| cls name indexer	count=1
module	to html ||| formats	count=1
function	to the ||| dt to	count=1
function	the series extract groups ||| extract frame	count=1
class	am never a ||| categorical block	count=1
class	dataframe objects ||| data frame	count=1
function	not ||| not	count=1
arg	simple cross-tabulation of ||| columns values	count=1
arg	3 columns ||| columns values	count=1
function_arg	to [arg_2] ||| [function_1] blocknd values [arg_2]	count=1
arg	on [arg_2] ||| [arg_1] [arg_2]	count=3
class	needs additional handling ||| index	count=1
function	ordered attribute ||| ordered	count=1
function	concatenate [function_2] ||| [function_1] [function_2]	count=1
module	fully deleting the node ||| io	count=1
module	handling as ||| core	count=1
function	optional ||| optional	count=1
function	[function] in compat_args ||| check [function]	count=1
class	new dataframe ||| data frame	count=1
arg	with [arg_2] ||| [arg_2] [arg_1]	count=1
arg	protection_dict ||| cls protection_dict	count=1
function	[function_1] string ||| [function_1] [function_2]	count=1
arg	data from some accepted ||| cls data	count=1
function	that we have ||| ordered	count=1
arg	we may create ||| new align inplace	count=1
arg	an expression ||| expr	count=1
module	sparseseries (with nan ||| sparse	count=1
function_arg	[function_1] single non-tuple ||| [function_1] indexer indexer [arg_2]	count=2
function	try to [function_2] ||| [function_2] [function_1]	count=2
arg	columns of ||| columns	count=1
class	number ||| multi	count=1
function	as dataframe ||| frame	count=1
class	iterate over ||| html	count=1
function_arg	[function_1] separate ||| [arg_2] [function_1]	count=1
module	2 [module] ||| [module]	count=2
arg	key or none ||| key	count=1
module	a set of ||| core	count=1
arg	that left [arg_2] ||| [arg_2] [arg_1]	count=4
class	validates that we have ||| categorical	count=1
function	from sif to ||| elapsed date to	count=1
arg	defaults to returning ||| level inplace verify_integrity	count=1
arg	this termvalue ||| v	count=1
arg	perform an ||| method axis limit	count=1
function_arg	[function_1] a tabular ||| [function_1] latex [arg_2]	count=1
class	map ||| map	count=1
arg	value from ||| value	count=1
class	if multiindex ||| multi	count=1
function	to connect ||| connect	count=1
function	a deprecated option ||| deprecated	count=1
arg	the indexer fill ||| indexer allow_fill	count=1
function_arg	sanitize input [arg_2] ||| [function_1] [arg_2]	count=4
function	block [function_2] ||| [function_1] [function_2] class values	count=1
function	new ||| new	count=3
function	akima [function_2] ||| [function_2] [function_1]	count=1
arg	set the value inplace ||| value	count=1
function_arg	[function_1] key ||| [function_1] [arg_2]	count=3
class	python datetime date objects ||| datetime index	count=1
arg	than a given width ||| arr width	count=1
function	array to ||| to	count=1
function_arg	a slice [arg_2] ||| [function_1] [arg_2]	count=1
arg	function to my ||| func	count=1
function	infer the [function_2] ||| [function_2] [function_1]	count=5
module_class	[module_1] [class_2] ||| [module_1] interval [class_2]	count=2
arg	or columns ||| axis	count=1
arg	default frequency ||| end periods freq	count=3
arg	with null values converted ||| values	count=1
function	an html table ||| to html	count=2
module	additional handling as ||| core	count=1
arg	regular expression ||| pat flags	count=1
function	compat with multiindex ||| sort levels monotonic	count=1
class	object that can be ||| frame parser	count=1
arg	regular expression in ||| arr pat flags	count=1
function_arg	a method [arg_2] ||| [arg_2] [function_1]	count=4
function	to parse a ndarray ||| convert	count=1
arg	nat-like arg is ||| arg	count=1
function	[function_1] length slice ||| [function_1] [function_2]	count=4
class	from ||| chain	count=1
function	set [function_2] ||| [function_1] [function_2]	count=1
arg	value is valid ||| value	count=1
module	set of sparseseries (with ||| core sparse	count=1
arg	compute a simple cross-tabulation ||| values	count=1
function	compute a ||| crosstab	count=1
function	[function_1] raw data ||| [function_2] [function_1]	count=1
arg	ndarray or ||| data index columns dtype	count=1
class	indexer ||| indexer	count=1
arg	compatiable fill_value ||| fill_value	count=1
function	[function_1] data the ||| [function_2] [function_1]	count=4
function	code group [function_2] ||| [function_2] [function_1]	count=1
module	table in file node ||| io	count=1
arg	single [arg] ||| [arg]	count=1
function	sql statement that create ||| create	count=1
function_arg	difference of [arg_2] ||| [function_1] [arg_2]	count=1
class	more this ||| ndframe	count=1
function	an [function_2] ||| [function_2] [function_1]	count=4
class	maps[0] raise keyerror is ||| map	count=1
module	1-dimensional ndarray ||| core indexes	count=1
arg	of terms for instances ||| terms	count=1
function	try ||| try convert	count=1
function	[function] in ||| check [function]	count=1
function	[function_1] interpolation ||| [function_1] [function_2]	count=2
arg	time and [arg_2] ||| [arg_1] [arg_2]	count=1
class	index objects contain ||| index ops	count=1
module	make new [module] with ||| [module]	count=1
arg	from ||| raise_on_error	count=1
class	array of python datetime ||| datetime	count=1
function	the gradientfill stop parameter ||| stop	count=1
function	same ||| same	count=1
function	assemble the [function_2] ||| [function_2] [function_1]	count=1
arg	explict type ||| dtype	count=1
class	the index and its ||| index	count=1
class	needs ||| period	count=1
arg	[arg_1] null values ||| [arg_2] [arg_1]	count=2
module	for options ||| io msgpack	count=1
function	of all the classes ||| all	count=1
class	have a ||| categorical	count=1
class	columns ||| data frame	count=1
function	use this if ||| set value	count=1
class	my ||| index col	count=1
function	to be [function_2] ||| [function_2] [function_1]	count=1
function	several cases to get ||| get index name	count=1
arg	which is ||| to_concat	count=1
function	label for this level ||| level label	count=1
arg	from ndarray ||| index columns	count=1
function	for first ||| first	count=2
arg	the corresponding interval with ||| interval	count=1
arg	the [arg] to ||| [arg]	count=1
module_class	return the categorical ||| core categorical	count=2
module	values attribute if it ||| core	count=1
function	count of number of ||| count	count=1
function	[function_1] a malformed ||| [function_1] [function_2]	count=1
module	of sparseseries (with ||| core sparse	count=2
module	from the ||| io	count=3
module	an expression in python ||| core computation	count=1
arg	obj [arg_2] ||| [arg_1] [arg_2]	count=1
class	downsample ||| index resampler	count=2
class	of ||| range index	count=1
arg	passed [arg] ||| index [arg]	count=1
function	time the time part ||| time	count=1
class	to ||| series	count=1
arg	cross-tabulation of ||| values	count=1
class	array of datetime ||| datetime	count=1
function	dtypes to object for ||| dtypes	count=1
function	doesn't like to compare ||| v string like	count=1
function	csv file (discouraged please ||| csv	count=2
module	return ||| core	count=25
function	missing indexers ||| from missing	count=1
function	beginning ||| beg	count=1
module	packed bytes see ||| io	count=1
function	akima ||| akima	count=1
function	[function_1] difference of ||| [function_1] [function_2]	count=3
function	return an [function_2] ||| [function_1] [function_2]	count=2
function	additional handling ||| array wrap	count=1
function	[function_1] table ||| [function_2] [function_1]	count=3
function	length [function_2] ||| [function_2] [function_1]	count=3
function	ordered data like ||| ordered	count=1
function	fast path [function_2] ||| [function_1] [function_2]	count=1
function	fast transform path ||| transform fast	count=1
arg	left and right ||| left right check_exact	count=1
arg	right ||| right vertical	count=1
function	the dtype object ||| dtypes	count=1
function_arg	a new [arg_2] ||| [function_1] [arg_2]	count=4
module	styles ||| formats	count=1
class	property property synonym ||| ndframe	count=1
arg	table ||| key	count=2
function	lists of strings ||| str	count=1
class	a dataframe ||| data frame	count=16
class	return index ||| datetime index ops	count=1
arg	left and right ||| left right vertical	count=3
function	if ||| set value	count=2
function	iterable ||| iterable	count=1
function	[function_1] we are ||| [function_2] [function_1]	count=4
module_class	sparse [class_2] ||| [module_1] [class_2]	count=3
function	have a full length ||| full	count=1
function	wrapper function for series ||| arith method series	count=1
arg	values to be ||| values ndim	count=1
function_arg	[function_1] expected error ||| [arg_2] [function_1]	count=4
function	index [function_2] ||| [function_2] apply [function_1]	count=3
arg	series arithmetic operations ||| op	count=1
class	make new index ||| index	count=1
arg	right ||| right	count=9
function	the numeric ||| add numeric	count=1
class	of a series excluding ||| series group	count=1
function_arg	[function_1] from the ||| [arg_2] [function_1]	count=2
class	in ||| ndframe	count=1
function	reindex ||| reindex	count=4
function	date formats to ||| to	count=1
class	if you ||| index	count=1
function	to convert timedelta-like ||| td index cmp	count=1
function	values between particular ||| indexer between	count=1
function	fill ||| fill	count=2
function_arg	[function_1] [arg_2] ||| [function_1] keys drop append [arg_2]	count=6
arg	with indexer ||| indexer	count=1
arg	or more existing columns ||| keys drop append	count=1
module	myself ||| core	count=2
function	string-like that ||| string array	count=1
function_arg	[function_1] [arg_2] ||| [function_1] latex [arg_2]	count=2
function	dict-like ||| dict like	count=2
class	the index ||| datetime index	count=2
module	groupby ||| core reshape	count=1
arg	of superclass ||| superclass	count=1
arg	simple cross-tabulation ||| values	count=1
module_class	return myself as ||| core datetime tzblock	count=1
function_arg	quickly [function_1] [arg_2] ||| [function_1] [arg_2]	count=5
function	called after ||| array wrap	count=3
function	to ||| to	count=46
function_arg	[function_1] font_dict ||| [arg_2] [function_1]	count=1
class	this is ||| ndframe	count=1
arg	cartesian product ||| shape sort	count=1
arg	ndarray copy ||| dtype copy	count=1
class	new manager with ||| block manager	count=1
arg	[arg_1] [arg_2] ||| [arg_1] axis [arg_2]	count=8
arg	returning ||| ignore_index verify_integrity	count=1
class	convert ||| ndframe indexer	count=1
class	that we ||| categorical	count=1
function	we [function_2] ||| [function_2] [function_1]	count=5
class	into ||| parser	count=2
arg	specified node (off of ||| key start stop	count=1
function_arg	quickly retrieve [function_1] [arg_2] ||| [function_1] [arg_2] takeable	count=3
function	dtype then fill ||| maybe fill	count=1
function	attributes e ||| attributes	count=3
function	strip ||| strip	count=1
function	prettier version ||| pretty string	count=1
function	get a ||| get	count=1
function	locator based on ||| locator	count=1
function	custom template ||| from custom template	count=2
arg	[arg_1] periods ||| [arg_2] [arg_1]	count=6
function	add in the ||| add	count=1
function_arg	pickle [arg_2] ||| [function_1] path [arg_2]	count=1
function	valid [function_2] ||| [function_2] [function_1]	count=1
arg	a dataframe the levels ||| data values index columns	count=1
function	dtype and n/a ||| empty dtype and	count=1
arg	columns of this ||| index columns	count=1
function	[function_1] the cacher ||| [function_2] [function_1]	count=1
arg	that left and right ||| left right exact check_names	count=1
function	that we have a ||| ordered	count=1
arg	simple ||| values	count=1
function_arg	series/index by [arg_2] ||| [arg_2] [function_1]	count=1
function_arg	[function_1] ndarray ||| [arg_2] [function_1]	count=1
module	this if you ||| indexes	count=1
class	only use this if ||| categorical	count=1
class	underlying array which ||| datetime index ops mixin	count=1
arg	values ||| values na_sentinel	count=1
function_arg	casting [arg_2] ||| [function_1] cls [arg_2]	count=1
function	a view of ||| view	count=1
function_arg	called prior [arg_2] ||| [function_1] [arg_2]	count=1
function	:class packer for ||| packb	count=1
module	node ||| io	count=1
function	[function_1] of take ||| [function_2] [function_1]	count=8
function	[function_1] join indexers ||| [function_2] [function_1]	count=2
class	the styler ||| styler	count=1
arg	the arg ||| arg	count=1
function_arg	numeric [arg_2] ||| [function_1] like [arg_2]	count=1
module	only ||| core	count=1
arg	to the new type ||| dtype copy errors values	count=2
function_arg	[function_1] [arg_2] ||| [function_1] [arg_2]	count=1645
function	[function_1] stderr ||| [function_1] [function_2]	count=3
class	scope by ||| scope	count=1
class	array repr of this ||| index	count=1
arg	the specified dtype ||| dtype	count=1
class	index or ndarray ||| index ops	count=1
module	with times to midnight ||| core indexes	count=1
function	parallel ||| test parallel	count=1
arg	a fixed size ||| itemsize	count=1
arg	corresponding interval ||| interval	count=1
function	series that is datetimelike ||| to datetimelike	count=1
function	formats to a ||| convert datetime to	count=1
module	numpy ||| compat numpy	count=1
arg	a dataframe ||| data values	count=1
function	value to format ||| value	count=1
module	attributes from the ||| core	count=1
function	the grouper ||| grouper	count=1
arg	in file node ||| key	count=1
function	if we [function_2] ||| [function_1] [function_2]	count=10
function_arg	[function_1] frequency ||| [function_1] i [arg_2]	count=1
class	index with ||| index	count=1
class	number of ||| range	count=1
arg	multiple iterables [arg_2] ||| [arg_2] [arg_1]	count=2
arg	block ||| block block_items	count=1
function_arg	locales that [arg_2] ||| [arg_2] [function_1]	count=2
arg	handling ||| result	count=1
function	[function_1] plan ||| [function_2] [function_1]	count=1
arg	for the nan/nat from ||| val	count=1
function	of all [function_2] ||| [function_1] timeseries [function_2]	count=1
class	length of that group ||| group by	count=1
class	underlying array ||| ops mixin	count=1
arg	column ||| data	count=2
arg	into ||| index_col	count=1
module	that ||| core	count=1
arg	[arg_1] j do ||| [arg_2] [arg_1]	count=1
function	a registered option ||| registered option	count=1
class	multiindex has ||| multi	count=1
arg	in file node ||| format	count=1
class	the underlying data ||| index ops mixin	count=1
arg	dataframe the levels ||| data values index	count=1
function_arg	[function_1] obj with ||| [function_1] slice [arg_2]	count=2
class	the underlying ||| ops mixin	count=1
arg	[arg_1] by ||| [arg_2] [arg_1]	count=12
function	options grouped by prefix ||| options	count=1
arg	convert dataframe ||| data	count=1
class	a ||| index	count=3
class	the underlying ||| datetime index ops mixin	count=1
arg	validates that we ||| cls	count=1
arg	[arg_1] indexer ||| [arg_1] [arg_2]	count=2
rep	the dataframe [function_arg_2] ||| [module_class_1] set [function_arg_2]	count=4
function	array [function_2] ||| [function_1] [function_2]	count=4
function_arg	union of [arg_2] ||| [function_1] [arg_2]	count=2
arg	in file node must ||| key	count=1
function	gets called ||| wrap	count=3
function	[function] item ||| set [function]	count=1
function_arg	[function_1] obj with ||| [function_1] [arg_2]	count=1
arg	or by a ||| by axis	count=1
function	strings to time objects ||| to time	count=1
arg	the byte of the ||| column	count=1
module_class	of our ||| core resampler	count=1
function	with null [function] until it's ||| pad [function]	count=1
function	[function_1] of same ||| [function_1] [function_2] class values	count=3
function	alias to closest ||| alias	count=1
arg	dom ||| doc match	count=1
function_arg	[function_1] distance ||| [arg_2] [function_1]	count=1
module	return packed bytes see ||| msgpack	count=1
function	validate that the where ||| validate where	count=1
function	belongs to a leap ||| is leap	count=1
arg	the blocks collect ||| axis consolidate transposed	count=1
arg	in ||| arr pat n	count=1
module_class	the [class_2] ||| [module_1] [class_2] putmask mask	count=5
class	ticks ||| time series date formatter	count=3
class	get ||| datetime index	count=1
function	construct concatenation ||| concatenation	count=1
class	this is index for ||| ndframe	count=1
class	each index value is ||| index ops	count=1
module	return ||| core indexes	count=9
class	a tree-like object ||| html frame	count=1
function	lookup ||| value	count=1
class	datetime time ||| datetime	count=1
class	tree-like object that can ||| html frame	count=1
arg	lookup ||| key	count=1
module	of [module_2] ||| [module_1] [module_2]	count=8
class	called after a ||| period index	count=1
function	note cannot [function] time64col() or ||| create [function]	count=1
arg	this is ||| key	count=1
function	bind a [function_2] ||| [function_1] [function_2]	count=1
class	a [class] return the ||| [class]	count=1
arg	'kwargs' should ||| kwargs	count=2
class	from ||| html frame parser	count=1
arg	packed object ||| packed	count=1
function	this if ||| value	count=1
arg	of terms for ||| terms	count=1
class	return index or ||| datetime index	count=1
class	be used to iterate ||| frame	count=1
function	array of ||| hash array	count=1
function_arg	function for [arg_2] ||| [arg_2] [function_1]	count=6
function	take which sets ||| take	count=1
module	:class packer ||| io msgpack	count=1
function	custom template ||| custom template	count=1
function	beginning of period ||| beg	count=1
function	create the join ||| join	count=1
arg	to class python 2 ||| cls	count=1
class	be used to ||| frame	count=1
function	reset the display ||| reset display	count=3
class	render a [class_2] ||| [class_2] [class_1]	count=4
arg	duplicate values ||| values keep	count=2
function	write a dataframe to ||| to	count=1
function_arg	determine [arg_2] ||| [function_1] [arg_2]	count=1
arg	be a ||| new	count=1
class	the boxed values ||| datetime	count=1
function	by str df ||| str	count=1
function_arg	integer location [arg_2] ||| [function_1] [arg_2]	count=6
function	return the [function_2] ||| [function_2] [function_1]	count=11
arg	to avoid code duplication ||| name str_rep fill_zeros	count=1
module	with [module] | ||| [module]	count=1
function	a sparse array ||| sparse array	count=2
arg	the value ||| value	count=1
module	after a ||| core	count=3
function	a locale ||| locale	count=2
function	to ||| elapsed date to	count=1
function	alert a user about ||| alert	count=1
function	difference of ||| difference	count=1
function	data ||| slice	count=1
class	excluding elements ||| group	count=1
class	gets called after ||| series	count=1
module	the [module_2] ||| [module_1] [module_2]	count=25
function	from sif to ||| date to	count=1
module	[module] number ||| [module]	count=1
arg	on 3 columns of ||| index columns values	count=1
class	the index ||| index	count=5
function	multi [function_2] ||| [function_2] [function_1]	count=2
class	return index or ||| index	count=1
arg	ndarray only ||| arr	count=1
function	of index ||| index	count=1
class	series excluding ||| series group	count=2
class	subset of a dataframe ||| data frame	count=1
arg	protection_dict ||| protection_dict	count=1
arg	file path ||| path	count=3
function	where ||| where	count=1
class	gets called after a ||| period	count=1
function	function to determine ||| dtype n method	count=1
arg	ndarray or ||| index columns dtype	count=1
function	elementwise ||| applymap	count=1
module	array object ||| core dtypes	count=1
function_arg	the index [arg_2] ||| [function_1] [arg_2]	count=1
function	via the 'numpy' library ||| take with	count=1
module	only ||| indexes	count=1
arg	label is ||| label	count=1
function	temporary variables in this ||| ntemps	count=1
function	a pandas only dtype ||| pandas	count=1
function	fill value for ||| fill value	count=4
function_arg	take values [arg_2] ||| [arg_2] [function_1]	count=4
function	the expected exception ||| exception	count=1
module	this if ||| core	count=1
class	for dataframe and major_axis ||| ndframe	count=1
function	index names ||| names	count=1
class	of python datetime ||| datetime	count=1
function_arg	[function_1] from ||| [arg_2] [function_1]	count=2
function_arg	extension [arg_2] ||| [function_1] [arg_2]	count=3
module	as a unicode string ||| indexes	count=1
arg	simple ||| columns values	count=1
function	formats to a ||| datetime to	count=1
arg	op on a and ||| op op_str a	count=1
function_arg	convert [arg_2] ||| [function_1] to style kwargs [arg_2]	count=1
module	1-dimensional ndarray only ||| indexes	count=1
arg	node must already ||| key	count=1
arg	whitespace including newlines from ||| to_strip side	count=1
function_arg	table as [arg_2] ||| [function_1] [arg_2]	count=3
class	whole block as one ||| single block manager	count=1
module	additional handling ||| core	count=1
function	to sif [function_2] ||| [function_1] [function_2]	count=1
module_class	nans and replaces [module_1] [class_2] for missing value ||| [module_1] [class_2]	count=1
function	json lists to line ||| convert to line	count=1
arg	[arg_1] arr2 are ||| [arg_1] [arg_2]	count=3
module	in ||| core computation	count=1
function	default values as specified ||| for default values	count=1
function	datetime string ||| time string	count=1
arg	nat-like arg is a ||| arg	count=1
class	that we have a ||| categorical	count=1
arg	parameter value ||| value	count=1
arg	the we have a ||| name freq	count=1
class	i am never ||| categorical	count=1
function	full length [function_2] ||| [function_1] [function_2]	count=1
arg	a ufunc needs additional ||| result context	count=1
function	removed ||| droplevel	count=1
arg	label ||| label side	count=1
function	repeat ||| repeat	count=1
function	akima interpolation ||| akima interpolate	count=2
function	index ||| convert to index	count=1
module	gets ||| core indexes	count=4
function	given offset/observance to a ||| rule	count=1
function	inferred types one ||| inferred type levels	count=1
function	the 'numpy' library ||| with	count=2
class	when ||| ndframe	count=1
arg	in i ||| i before_day_of_month	count=1
module	parameter if ||| core	count=1
function	the size of ||| itemsize	count=1
arg	node must ||| key value	count=1
arg	optional fill value ||| fill_value	count=1
function	a matrix [function_2] ||| [function_2] [function_1]	count=2
function	[function_1] long ||| [function_2] [function_1]	count=3
function	the maximum by ||| max	count=1
function	checks that path's extension ||| check extension	count=1
function	[function_1] the string ||| [function_1] [function_2]	count=1
class	with ||| datetime	count=1
arg	python expression ||| expr	count=1
module	for dataframe ||| core	count=1
function	one lower dimension s ||| sliced	count=1
function	try to connect ||| can connect	count=1
module	raise keyerror is maps[0] ||| compat	count=1
class	of python datetime date ||| datetime index	count=1
class	to the scope ||| scope	count=1
function	[function_1] time objects ||| [function_1] [function_2] arg format infer_time_format errors	count=3
function	[function_1] sequence ||| [function_2] [function_1]	count=1
function	return a basegrouper which ||| get	count=1
function_arg	function [arg_2] ||| [arg_2] [function_1]	count=3
function	template ||| template	count=1
arg	use this if you ||| arr key	count=1
function	a common ||| common	count=1
function	wrap long strings in ||| wrap	count=1
function	an positional ||| valid positional setitem	count=1
module	tree-like ||| io	count=1
arg	using input function or ||| axis copy inplace	count=1
arg	ndarray or list ||| data index columns dtype	count=1
function	convert timedelta-like ||| td	count=1
function	axes ||| axes index	count=2
arg	result ||| result mask	count=1
function	values at ||| at	count=1
arg	a compatiable fill_value ||| fill_value	count=1
class	series excluding ||| series	count=1
class	series to dataframe in ||| data frame	count=1
class	ndarray of ||| index	count=1
function	fast lookup ||| value	count=1
function_arg	append [arg_2] ||| [arg_2] [function_1]	count=2
class	whether each index value ||| index ops	count=1
class	return a ||| html	count=1
function_arg	[function_1] code to ||| [function_1] [arg_2]	count=2
class	midnight length is ||| index	count=1
function	our native types ||| native types	count=6
arg	null_color for ||| null_color	count=1
arg	cartesian product of all ||| labels shape sort	count=1
arg	node must ||| format	count=1
arg	info ||| freqstr	count=1
function	to time ||| to time	count=1
arg	float key ||| key	count=1
arg	ndarray or list of ||| index columns dtype	count=1
arg	matches a regular expression ||| arr pat case flags	count=1
arg	that ||| cls	count=1
module	this is similar ||| reshape	count=1
arg	from [arg_2] ||| [arg_2] [arg_1]	count=2
function	sum of non-na/null observations ||| count	count=1
module	maps[0] raise keyerror is ||| compat	count=1
function	float ||| set eng float	count=1
class	dataset ||| series	count=1
module	sparse ||| core sparse	count=4
function	a block [function_2] ||| [function_2] [function_1]	count=1
module	[module] for multi ||| [module]	count=2
function	our index type ||| index	count=1
module	frequency datetime index ||| indexes	count=2
class	keyerror ||| map	count=1
arg	right data ||| right	count=1
function	pandas type ||| table type	count=1
class	to ||| html	count=1
arg	table in file ||| key value	count=1
arg	returns a curve with ||| start end return_name	count=1
class	index objects sortedness ||| index	count=1
function	all the [function_2] ||| [function_2] [function_1]	count=2
class	return a tree-like ||| html frame	count=1
class	columns for dataframe ||| ndframe	count=1
function	ndarray raises on ||| ndarray	count=1
arg	simple ||| columns	count=1
function_arg	[function_1] indexer like ||| [function_1] [arg_2]	count=1
arg	or object coercible to ||| join overwrite filter_func	count=1
arg	null_color ||| null_color	count=1
arg	compute a ||| index columns values	count=1
module	styler ||| io formats	count=2
function	set ||| set object	count=1
function	returns [function] ||| [function]	count=1
class	float ||| float array formatter	count=2
arg	label if label ||| label	count=1
function	create a [function_2] ||| [function_1] [function_2]	count=5
function	true if this ||| is in table	count=1
function	[function_1] a string-like ||| [function_1] [function_2]	count=1
module_class	[module_1] [class_2] by location ||| [module_1] [class_2]	count=3
module	values attribute if ||| core	count=1
arg	exist ||| format	count=1
function	string cast ||| maybe cast	count=1
class	to iterate over ||| frame	count=1
function	set [function] ||| set [function]	count=1
arg	left <= ||| left	count=1
arg	of the [arg] if any ||| [arg]	count=1
function	true if ||| is	count=6
function	want ||| array	count=1
arg	to a fixed size ||| data encoding itemsize	count=1
function	datetime with tz ||| datetimetz	count=1
class	python datetime ||| datetime	count=1
class	that can be ||| html	count=1
module	return a ||| core indexes	count=1
arg	unit if needed otherwise ||| unit	count=1
arg	value inplace return a ||| value	count=1
module	datetime index ||| indexes	count=2
module	into ||| io json	count=1
arg	ndarray copy if ||| copy	count=1
function	return packed bytes see ||| packb	count=1
function	infer ||| infer	count=4
arg	in file node ||| value format	count=1
arg	from data ||| data index primary_key	count=2
function	execute ||| execute	count=1
arg	indexer and return them ||| indexer	count=2
function_arg	create [arg_2] ||| [arg_2] [function_1]	count=3
function	series/index to ||| str	count=1
class	from 1-dimensional ndarray only ||| index	count=1
function	a copy of ||| copy	count=2
arg	be ||| key value format	count=1
function	set [function_2] ||| [function_2] [function_1]	count=1
arg	[arg_1] boolean if ||| [arg_2] [arg_1]	count=2
module	return the number of ||| core	count=2
module	keyerror is ||| compat	count=1
function	for series ||| bool method series	count=2
function	quickly set [function] item ||| set [function]	count=1
function	the time part ||| time	count=1
arg	requested level the ||| level	count=1
function	[function_1] series ||| [function_1] [function_2]	count=11
module	dataset ||| core	count=1
arg	moving ||| bias	count=1
function	values ||| stringify na values	count=1
arg	provide ||| axis typs	count=1
function	to long ||| to long	count=2
arg	unit ||| unit tz	count=1
function	an object ||| to object	count=1
class	get ||| categorical index	count=1
function_arg	[function_1] [arg_2] ||| [function_1] other op [arg_2]	count=1
arg	font_dict ||| font_dict	count=1
class	a ndarray of the ||| index	count=1
class	index or ndarray filled ||| datetime index ops	count=1
function	shell ||| session	count=1
function	this is ||| is	count=1
arg	from each element in ||| arr	count=1
arg	a code ||| code	count=1
function	console ||| console	count=1
arg	default implementation of ||| op_classes	count=1
function	from a ||| parse	count=1
class	handling as ||| index	count=1
class	values attribute if it ||| series	count=1
module	convert [module_1] [module_2] ||| [module_1] [module_2] bin op convert value	count=4
function_arg	to [arg_2] ||| [arg_2] [function_1]	count=6
function	set ||| set	count=13
function	compute the expected nrows ||| nrows expected	count=1
function	are not a floating ||| maybe cast indexer	count=1
class	with ||| index	count=1
function_arg	[function_1] dataframe ||| [function_1] [arg_2]	count=1
function	str ||| str from	count=1
function	index names to ||| names	count=1
arg	we are grabbing ||| level global_dict local_dict resolvers	count=1
function	dtype object ||| dtype	count=2
arg	dataframe and series ||| data	count=1
function	[function_1] [function_2] ||| [function_1] [function_2] class values	count=4
module_class	[module_1] pytables file ||| [module_1] [class_2]	count=2
module	to its ||| core	count=1
class	of ||| range	count=1
module	from 1-dimensional ndarray ||| core indexes	count=1
module	pack ||| io	count=1
arg	single [arg] at passed ||| label [arg]	count=1
class	can be used to ||| html frame parser	count=1
module	the number of ||| core indexes	count=2
function	all [function_2] ||| [function_2] [function_1]	count=2
module	return packed ||| io	count=1
function	counts of ftypes ||| ftype counts	count=3
function	feather-format object ||| feather	count=1
module	the same dimensions as ||| core	count=1
class	return index or ndarray ||| datetime index ops	count=1
function	[function_1] the cacher ||| [function_1] [function_2]	count=1
arg	dataframe equivalent to read_excel(excelfile ||| sheetname header skiprows skip_footer	count=1
class	[class_1] manager parameters ||| [class_2] [class_1]	count=3
arg	[arg] actual interpolation ||| values [arg]	count=1
arg	with optional set logic ||| join join_axes	count=1
function	for this level ||| level	count=1
arg	level of ||| level dropna	count=1
arg	regular expression ||| case flags	count=1
arg	iter1 ||| iter1	count=1
arg	into a dataframe ||| index_col	count=1
function	stderr in ||| stderr	count=1
arg	coerce to the new ||| copy	count=2
function	set a locale ||| set locale	count=3
class	write a dataframe ||| data frame	count=1
function	cacher ||| cacher	count=1
arg	in the context ||| inplace	count=1
class	gets called after ||| period index	count=1
class	stata ||| stata	count=2
module	data ||| indexes	count=2
arg	a code to ||| code	count=1
arg	the key [arg_2] ||| [arg_2] [arg_1]	count=1
arg	encoding ||| arr encoding	count=2
function	dict of array-like or ||| dict	count=1
module	add ||| core computation	count=1
module	as a ||| indexes	count=1
arg	corresponding to axis ||| axis	count=1
class	index value ||| index ops	count=1
arg	in file node must ||| value format	count=1
arg	must already exist and ||| key value	count=1
function	locator based on a ||| get locator	count=1
class	a series excluding elements ||| series group	count=1
class	reshape data (produce a ||| data	count=1
class	this categorical ||| categorical	count=1
arg	from other to self ||| other	count=1
arg	obj with ||| obj	count=1
arg	an indexer like _name ||| name indexer	count=1
module_class	putmask the data to [module_1] [class_2] ||| [module_1] [class_2]	count=3
class	return a ||| html frame	count=1
function	merge ||| merge	count=2
arg	of values values ||| values method axis	count=1
class	the number of ||| multi index	count=1
class	data for ||| data	count=1
arg	data_columns ||| data_columns	count=1
arg	must already exist and ||| value format	count=1
function	panel to [function_2] ||| [function_1] [function_2]	count=1
module	object datetimeindex timedeltaindex and ||| dtypes	count=1
function_arg	expanding [arg_2] ||| [arg_2] [function_1]	count=1
module	of strings to numpy ||| compat numpy	count=1
arg	among ||| types	count=1
function	resolve ||| resolve	count=1
function	bytes in the ||| nbytes	count=2
arg	is called upon unpickling ||| cls d	count=1
module	datetimeindex with times ||| indexes	count=1
module_class	return the [module_1] [class_2] by location ||| [module_1] [class_2] ixs i axis	count=1
class	datetime date ||| datetime index	count=1
arg	a la numpy percentile ||| q interpolation	count=1
arg	from 1-dimensional ndarray only ||| arr	count=1
function	add the [function_2] ||| [function_2] [function_1]	count=4
function	stata date formats ||| stata	count=1
class	we by ||| by	count=1
module_class	[module_1] series ||| [module_1] [class_2]	count=16
arg	value from 1-dimensional ndarray ||| value	count=1
class	the same dimensions ||| ndframe	count=1
class	index value is ||| index ops	count=1
function	cast ||| cast	count=3
class	its values attribute ||| series	count=1
class	end of this frame ||| data frame	count=1
arg	valid ordered parameter ||| ordered	count=1
arg	columns using input function ||| axis copy inplace	count=1
function	indices overlap add suffixes ||| items overlap	count=1
module	return if ||| core	count=1
module	[module] consensus name ||| [module]	count=1
class	can be used ||| parser	count=1
function	compute the expected ||| expected	count=1
function_arg	and pads it with [function_1] [arg_2] chars ||| [function_1] [arg_2]	count=1
arg	sql [arg_2] ||| [arg_1] [arg_2] cur params	count=1
class	float values ||| float array formatter	count=1
function	code group [function_2] ||| [function_2] freq [function_1]	count=1
arg	the blocks collect and ||| axis consolidate transposed	count=1
class	only use this ||| categorical	count=1
arg	apply function ||| func level	count=1
function	the symmetric [function_2] ||| [function_2] [function_1]	count=2
module	the [module_2] ||| [module_1] [module_2] is nested list like	count=1
function	validate that an positional ||| valid positional	count=1
function	determine if each ||| match	count=1
module_class	interval [class_2] ||| [module_1] [class_2]	count=1
function	disable other than add/sub ||| disabled	count=1
module	objects ||| core indexes	count=1
arg	unit if needed ||| cls unit tz	count=1
class	built up ||| styler	count=1
function	bool of ||| bool	count=1
function	for valid ||| has valid	count=1
arg	regular expression pat ||| pat flags expand	count=2
arg	on where ||| where start	count=1
arg	to table in file ||| value format	count=1
arg	3 columns of this ||| columns	count=1
function	value for the ||| value	count=2
function	create a ||| create	count=2
function_arg	[function_1] i with ||| [arg_2] [function_1]	count=1
function	[function_1] a string-like ||| [function_2] [function_1]	count=1
class	[class_1] each level ||| [class_2] [class_1]	count=2
function	to compare numeric ||| is numeric v string	count=1
class	float values ||| float array	count=1
arg	dtype ||| value dtype	count=1
function_arg	convert [arg_2] ||| [function_1] to stop [arg_2]	count=1
module	compute a simple ||| core reshape	count=1
function	[function_1] zeros ||| [function_1] [function_2]	count=1
module	with times ||| core	count=1
function_arg	convert [arg_2] ||| [function_1] to alignment [arg_2]	count=1
function	lookup ||| set	count=1
function	for ||| for	count=1
arg	argument ||| arg	count=1
class	series with multiindex ||| series	count=1
arg	pasted [arg] ||| [arg]	count=1
class	[class_1] blockmanager ||| [class_2] [class_1]	count=2
arg	new [arg_2] ||| [arg_2] [arg_1]	count=4
class	ndframe as opposed to ||| ndframe	count=1
function	create the description ||| create description	count=1
function	given values [function] ||| [function] same	count=2
function	alert a [function_2] ||| [function_2] [function_1]	count=1
module	to ||| core indexes	count=2
module	applies the ||| core	count=1
arg	specialized cython ||| indexer axis out	count=1
class	number ||| range index	count=1
function	reset the cacher ||| reset cacher	count=3
function	[function_1] type ||| [function_1] stata [function_2]	count=3
module	ndarray ||| core indexes	count=2
function	grouped ||| grouped	count=1
module	bytes see ||| io	count=1
function	grouper indexers ||| grouper	count=1
function	prior ||| array prepare	count=2
function_arg	date [arg_2] ||| [function_1] [arg_2]	count=1
function	of transform ||| transform	count=1
function	[function_1] the type ||| [function_1] dtype [function_2]	count=1
function	number of elements ||| size	count=1
arg	[arg_1] index ||| [arg_2] [arg_1] takeable	count=1
class	over the ||| html frame	count=1
class	same dimensions as the ||| ndframe	count=1
function	get all [function_2] ||| [function_1] [function_2]	count=2
function	a multirow ||| format multirow	count=1
module	compute a ||| reshape	count=1
function	the raw [function_2] ||| [function_2] [function_1]	count=1
class	[class_1] groupby ||| [class_1] [class_2]	count=1
module	objects parameters ||| core indexes	count=1
function	to each ||| apply	count=1
module	needs additional ||| indexes	count=1
arg	the [arg] if any ||| [arg]	count=1
function	available options grouped by ||| pp options	count=1
function	render ||| render	count=1
arg	difference of ||| axis	count=1
function_arg	of type [arg_2] ||| [function_1] [arg_2]	count=2
module	must ||| io	count=1
class	of the underlying data ||| datetime index ops mixin	count=1
function	have a ||| validate	count=1
class	float values converted ||| float array formatter	count=1
function	construct concatenation plan ||| concatenation plan	count=1
arg	and 'kwargs' should be ||| name args kwargs	count=1
arg	you ||| arr	count=1
function	take optional ||| optional	count=1
arg	the indexer input array ||| indexer	count=1
function	[function_1] the raw ||| [function_1] [function_2]	count=1
class	in file node ||| hdfstore	count=1
module	the keys will be ||| core	count=1
arg	duplicate rows ||| keep	count=1
function	label for last ||| last	count=2
module	has only the ||| io	count=1
arg	must already ||| value format	count=1
function	stata ||| to stata	count=2
function	return dense representation ||| to dense	count=1
function_arg	[function_1] sql ||| [arg_2] [function_1]	count=1
function	return an indexer for ||| get	count=1
module	it has ||| core	count=1
function	the bool of a ||| bool	count=1
function	parser ||| parser	count=1
module	indexes give ||| core indexes	count=1
arg	of query in a ||| index_col coerce_float	count=1
module	after a ||| core indexes	count=2
arg	the blocks collect and ||| consolidate transposed	count=1
function	decorator to deprecate ||| deprecate	count=1
arg	of ||| arr key	count=1
function	[function_1] reflecting the ||| [function_2] [function_1]	count=6
module	fast lookup ||| core	count=1
module_class	[module_1] blockmanager ||| [module_1] [class_2]	count=2
module	for ||| sparse	count=1
arg	data to an ndarray ||| data index dtype	count=1
arg	names [arg_2] ||| [arg_2] [arg_1]	count=2
arg	the columns of a ||| inplace	count=1
function	[function_1] empty ||| [function_2] [function_1]	count=1
class	data are ||| data	count=1
arg	whether 'kwargs' ||| fname kwargs compat_args	count=2
function_arg	trims zeros [arg_2] ||| [arg_2] [function_1]	count=1
arg	a parameter value ||| value	count=1
class	frame table ||| table	count=2
function	i am never ||| is	count=1
arg	the [arg_1] [arg_2] using the provided connection ||| [arg_1] [arg_2]	count=1
module	never ||| core	count=1
arg	fill with the fill_value ||| fill_value	count=1
function	frequency is ||| freq	count=1
arg	single non-tuple ||| target	count=1
function_arg	to a [arg_2] ||| [function_1] excel [arg_2]	count=1
module_class	return the [class_2] ||| [module_1] [class_2]	count=4
arg	file node ||| format	count=1
function	only use this if ||| value	count=1
function	with decimal ||| decimal	count=1
arg	from other ||| other	count=1
class	gets ||| period	count=1
arg	'kwargs' should be ||| kwargs	count=2
function_arg	the block [arg_2] ||| [arg_2] [function_1]	count=1
function_arg	index row [arg_2] ||| [function_1] [arg_2]	count=2
function	return dense representation ||| dense	count=1
class	can ||| parser	count=1
function	sparseseries or [function_2] ||| [function_2] [function_1]	count=1
class	fast lookup of ||| index	count=1
arg	deprecated use :meth ||| ascending sort_remaining	count=1
module	to midnight length is ||| core	count=1
arg	simple ||| index columns values	count=1
function	float is ||| set eng float	count=1
class	a frame table ||| appendable series table	count=1
function_arg	[function_1] groupby ||| [function_1] [arg_2]	count=2
arg	table this is ||| key	count=1
module_class	the table ||| io table	count=1
function	to a compat ||| to	count=1
arg	from the ||| raise_on_error	count=1
function	each ||| apply	count=1
function	to deprecate a ||| deprecate	count=1
function	wrap op result ||| wrap result	count=2
arg	dataframe the levels in ||| data values	count=1
module	file node must already ||| io	count=1
function	to add ||| add	count=1
module	values in the ||| core	count=2
function	[function_1] with the ||| [function_2] [function_1]	count=6
function	[function_1] of ftypes ||| [function_2] [function_1]	count=4
function	cast ||| cast types	count=1
arg	default frequency ||| freq	count=3
class	is index for series ||| ndframe	count=1
arg	a decorator ||| decorator	count=1
function	starting at the end ||| rsplit	count=1
function	check whether ||| like	count=1
class	index objects contain the ||| datetime index	count=1
arg	a higher [arg_2] ||| [arg_1] [arg_2]	count=3
function_arg	[function_1] [arg_2] ||| [function_1] path [arg_2]	count=1
function	[function_1] for given ||| [function_2] concatenation [function_1]	count=1
arg	along a particular axis ||| axis	count=1
function	function or functions ||| rename	count=1
module	cross-tabulation of ||| reshape	count=1
function	make a repr function ||| repr	count=1
class	keyerror is ||| chain map	count=1
function_arg	define an internal [function_1] [arg_2] it ||| cython [function_1] [arg_2]	count=3
arg	[arg_1] the smallest ||| [arg_2] [arg_1]	count=1
arg	[arg_1] on a ||| [arg_1] [arg_2]	count=1
function	[function_1] we are ||| [function_1] [function_2]	count=4
class	float values converted ||| float	count=1
function	values between ||| between	count=2
function	classes which ||| index	count=1
arg	rows/cols [arg] idx_names - ||| nrows ncols [arg]	count=1
arg	value omitting na/null values ||| axis kind order	count=1
arg	evaluate [arg_1] [arg_2] ||| [arg_1] [arg_2]	count=4
function	return the size of ||| itemsize	count=1
function	overrides ndarray argsort argsorts ||| argsort	count=1
function_arg	specified [arg_2] ||| [function_1] key [arg_2]	count=1
function	has a float ||| float	count=1
arg	file ||| key value	count=1
class	a frame ||| frame	count=1
module	synonym ||| core	count=1
class	frame ||| data frame	count=3
arg	for a panel-like dataframe ||| time panels names	count=1
function	of object to ||| to	count=1
function	frontend ||| frontend	count=1
module	only use ||| core indexes	count=1
module	internal property property ||| core	count=1
arg	groupby ||| groupby	count=1
class	a sorted ndframe ||| ndframe	count=1
arg	interval ||| interval	count=1
arg	ufunc needs ||| result context	count=1
function	write this as ||| write	count=2
class	the number ||| range	count=1
module	exist and be ||| io	count=1
function	gets the categories ||| get categories	count=1
class	datetimeindex but ||| datetime	count=1
function	result as block ||| getitem block	count=1
arg	a func ||| func	count=1
arg	file node must ||| key value format	count=1
function	wrapper function for ||| comp method	count=1
function	numpy doesn't like to ||| string like	count=1
function_arg	[function_1] a style_dict ||| [function_1] to style kwargs [arg_2]	count=1
class	styles to ||| styler	count=1
class	can ||| frame	count=1
function_arg	[function_1] [arg_2] ||| [function_1] to stop [arg_2]	count=1
function	ops ||| ops	count=1
function	[function_1] [function_2] ||| [function_2] apply [function_1]	count=5
function	pick the best locator ||| locator	count=1
function	other ||| for numeric binop	count=1
function	overrides ndarray argsort ||| argsort	count=1
arg	to dispatch to ||| dispatch name	count=1
function_arg	[function_1] [arg_2] ||| [function_1] key [arg_2]	count=1
arg	utility to ||| skipna fill_value fill_value_typ	count=1
class	create/cache ||| table	count=1
arg	a function to ||| func	count=2
arg	other to int64 with ||| other	count=1
class	object that ||| html	count=1
arg	by periods ||| periods axis	count=2
module	indexes give ||| indexes	count=1
class	handling as ||| period	count=1
arg	item ||| loc item	count=1
function	a feather-format object ||| read feather	count=1
class	with ||| single	count=2
arg	we have ||| cls	count=1
function	define an builtin function ||| builtin func	count=2
class	array ||| sparse series	count=1
class	of columns ||| ndframe	count=1
function	instances of all the ||| all	count=1
function_arg	[function_1] function ||| [function_1] [arg_2]	count=2
arg	input ||| axis copy	count=1
function_arg	string [arg_2] ||| [arg_2] [function_1]	count=1
function	openpyxl is supported ||| is	count=1
module	validates that we ||| core	count=1
class	value ||| ops	count=1
function	list of term ||| term	count=1
class	manager with the ||| manager	count=1
class	times to midnight length ||| datetime index	count=1
module	[module_1] expression ||| [module_1] [module_2]	count=1
arg	lookup ||| arr key	count=1
arg	values can ||| values	count=1
module	whether or not the ||| io	count=1
class	never ||| categorical	count=1
class	it has one ||| series	count=1
module	this if ||| core indexes	count=1
class	exception raised ||| assert raises contextmanager	count=1
function	default values as specified ||| default values	count=1
module	and and ||| core computation	count=1
arg	location ||| loc	count=7
class	additional handling as ||| period index	count=1
arg	with nat-like arg is ||| arg	count=1
arg	of ||| index	count=2
arg	item at ||| loc item	count=1
function	encode character ||| encode	count=1
module	by ||| formats	count=1
arg	ndarray ||| data index columns dtype	count=1
arg	dtype converting ||| dtype	count=1
function	as an [function_2] ||| [function_2] [function_1]	count=2
arg	a style_dict ||| style_dict	count=4
module	when ||| core	count=1
function	cartesian product of ||| product	count=1
function	highlight the [function_2] ||| [function_2] [function_1]	count=3
arg	iterables [arg_2] ||| [arg_2] [arg_1]	count=2
arg	plural 'names' ||| names deep	count=1
arg	index ||| index	count=4
function_arg	[function_1] serialize ||| [arg_2] [function_1]	count=1
arg	a string raise a ||| string	count=2
function	registered ||| get registered	count=1
function	the shape ||| shape	count=1
function	to table in file ||| append	count=1
class	the boxed ||| datetime	count=1
arg	ndarray copy if specified ||| dtype copy	count=1
function_arg	stata [arg_2] ||| [arg_2] [function_1]	count=1
arg	fill the ||| limit	count=1
class	from ||| data	count=2
function	true if this ||| is in	count=1
arg	of multiple [arg_2] ||| [arg_2] [arg_1]	count=4
function	to scipy interpolate ||| interpolate scipy	count=2
function	openpyxl is ||| is	count=1
function	a list ||| list	count=1
arg	by hashing its categories ||| c encoding hash_key	count=1
module	[module_1] the background ||| [module_1] [module_2]	count=1
arg	with requested level ||| level	count=1
function	then fill ||| maybe fill	count=1
function	for series ||| arith method series	count=2
function	[function] of ||| convert [function]	count=1
arg	of ||| values	count=1
function	holidays between start_date and ||| holidays	count=1
module_class	[module_1] from the ||| [module_1] [class_2]	count=1
function	a repr function ||| repr	count=1
function	[function_1] op ||| [function_2] [function_1]	count=4
arg	totally ordered cartesian product ||| shape sort xnull	count=1
arg	to dispatch to the ||| dispatch name	count=1
function	to ||| dtype to	count=1
arg	o and [arg] ||| o [arg]	count=1
module	array object has a ||| dtypes	count=1
function	am never a view ||| view	count=1
function	post process for ||| post	count=1
function	an positional ||| has valid positional	count=1
function	that can be ||| build	count=1
class	new block ||| block manager	count=1
function	pack object ||| packb	count=1
module	expression ||| computation	count=2
function	trims [function_2] ||| [function_2] [function_1]	count=1
function	reflecting the structure ||| setup	count=1
arg	on a distance ||| dmin dmax	count=1
class	when a ||| ndframe	count=1
function	value from 1-dimensional ||| get value	count=1
class	dataframe with ||| data frame	count=1
function	ndarray ||| set	count=1
arg	each string in ||| arr	count=1
function	numeric add/sub ||| add numeric	count=1
function	don't ||| valid	count=1
class	file ||| hdfstore	count=2
module	return the ||| core indexes	count=2
function	[function_1] cast the ||| [function_2] [function_1]	count=1
function_arg	[function_1] y ||| [arg_2] [function_1]	count=2
function_arg	[function_1] [arg_2] ||| [function_1] disabled [arg_2]	count=2
function	cross-product ||| maybe convert ix	count=1
function	stacked format as dataframe ||| to frame	count=1
function	putmask ||| putmask	count=1
module_class	the [class_2] ||| [module_1] [class_2] argsort ascending	count=5
function	series/index by ||| str repeat	count=1
function	to a list of ||| to	count=1
class	group excluding ||| frame group by	count=1
arg	actual interpolation [arg] will be ||| [arg]	count=1
function	types format slicing ||| types	count=3
function	float is formatted ||| float	count=1
class	database ||| sqldatabase	count=1
arg	have good categories ||| cls categories fastpath	count=1
arg	the _apply kwargs and ||| func name window center	count=1
function	try to ||| try convert to	count=2
function	called after a ||| array	count=3
arg	and other to ||| other	count=1
function	table in file ||| append	count=1
function_arg	apply the [arg_2] ||| [function_1] [arg_2]	count=4
function_arg	[function_1] a distance ||| [function_1] [arg_2]	count=2
arg	sequence of terms ||| terms	count=1
function	return a view ||| view	count=1
module	get ||| core dtypes	count=1
class	built up styles ||| styler	count=1
function	parameter ||| validate ordered	count=2
arg	column by ||| data	count=1
function	columns as lists ||| str columns	count=2
arg	simple cross-tabulation of ||| index columns values	count=1
class	of ||| categorical	count=2
function	fast lookup of ||| set value	count=1
function	(e ||| maybe to	count=1
arg	[arg_1] [arg_2] using the provided connection ||| [arg_1] [arg_2]	count=1
class	create index with target's ||| multi index	count=1
arg	a to maintain order ||| side sorter	count=1
function	of ||| set value	count=2
module	an ||| core computation	count=2
function_arg	[function_1] single non-tuple ||| [arg_2] [function_1]	count=2
function	to get ||| get index name	count=1
arg	node must ||| value	count=1
function_arg	with decimal [arg_2] ||| [arg_2] [function_1]	count=4
arg	kwds ||| kwds y	count=1
function	freq ||| freq	count=1
function	convert to [function_2] ||| [function_2] [function_1]	count=15
arg	values to ||| values	count=2
function	to [function_2] ||| [function_1] stata [function_2]	count=2
arg	levels names ||| names	count=1
function_arg	time [arg_2] ||| [function_1] time [arg_2]	count=1
class	pointer of the underlying ||| ops mixin	count=1
class	creating [class] binner ||| [class]	count=1
function	if the frequency ||| freq	count=1
class	for dataframe and ||| ndframe	count=1
function_arg	determines if [arg_2] ||| [function_1] [arg_2]	count=4
function_arg	[function_1] value is ||| [function_1] can do op [arg_2]	count=1
function	[function_1] the values ||| [function_2] [function_1]	count=1
class	datetimeindex ||| datetime	count=2
function	called after ||| array	count=3
class	frame table ||| appendable series table	count=1
module	[module_1] [module_2] is list-like and that ||| [module_1] [module_2] is nested list like	count=3
function	a feather-format ||| read feather	count=1
function	and be ||| append	count=1
module_class	nans and replaces [module_1] [class_2] for missing value ||| [module_1] [class_2] writer replace nans	count=1
function	nrows ||| nrows	count=1
function	numeric ||| numeric v	count=1
class	ndarray ||| series	count=1
function	dtype [function] ||| [function] string like	count=2
arg	left and [arg] have equal ||| left [arg]	count=1
arg	labels [arg_2] ||| [arg_2] [arg_1]	count=3
function	return the ||| get	count=7
function	needs additional handling as ||| wrap	count=1
arg	do ||| src_list dest_list	count=1
arg	[arg_1] selected position ||| [arg_1] [arg_2]	count=1
class	for [class_2] ||| [class_2] [class_1]	count=2
function_arg	[function_1] using one ||| [function_1] keys drop append [arg_2]	count=1
function	object that can ||| build	count=1
arg	code ||| code	count=1
arg	as a dataframe the ||| data	count=1
class	block and are a ||| block manager	count=1
function	datetime to ||| dt to	count=1
class	return ||| multi	count=1
function_arg	[function_1] sql and ||| [function_1] [arg_2]	count=1
function	build an xpath expression ||| build xpath expr	count=1
function	an positional ||| positional setitem	count=1
arg	synonym for :meth ||| inplace limit	count=2
arg	exist ||| key value format	count=1
arg	pattern or regular expression ||| pat flags	count=1
arg	the blocks collect ||| f axis consolidate transposed	count=1
class	by ||| ndframe group by	count=1
module	[module_1] an ||| [module_1] [module_2]	count=2
module	and return the ||| io	count=2
module	gets called ||| core	count=3
arg	result parameters ||| result	count=1
class	frame table ||| series table	count=2
arg	label if label is ||| label	count=1
function	setup our ||| set	count=1
class	is ||| period dtype	count=1
function	selection used for ||| selection	count=1
function_arg	the locales [arg_2] ||| [arg_2] [function_1]	count=1
class	an ||| generic fixed	count=1
function	http //www stata ||| stata	count=1
function	dataframe [function_2] ||| [function_2] [function_1]	count=1
class	transform ||| ndframe group by	count=1
arg	the numpy ||| dtype	count=1
function	to a leap ||| leap	count=1
arg	a left and right ||| cls left right	count=1
function_arg	locator based [arg_2] ||| [function_1] [arg_2]	count=1
module	index objects contain the ||| indexes	count=1
module	the original ||| core	count=1
class	on ||| rolling	count=1
class	needs additional handling ||| period index	count=1
function_arg	a locale [arg_2] ||| [arg_2] [function_1]	count=1
arg	by the indexer fill ||| indexer allow_fill	count=1
function	a full ||| full	count=1
function_arg	slice [arg_2] ||| [arg_2] [function_1]	count=5
function	and create [function_2] ||| [function_2] [function_1]	count=1
function	the cartesian product of ||| product	count=1
arg	on column values ||| values	count=1
arg	vectorized membership of x ||| x	count=2
arg	compute a simple ||| columns values	count=1
function	[function_1] array to ||| [function_2] [function_1]	count=4
arg	method for ||| method	count=1
arg	valid other ||| other op	count=1
function	object to the ||| to	count=1
module	with times to ||| core indexes	count=1
arg	a ufunc needs ||| result context	count=1
function_arg	convert [arg_2] ||| [function_1] to color [arg_2]	count=1
function	[function_1] the locales ||| [function_2] [function_1]	count=1
class	that can be ||| html frame parser	count=1
arg	values can be ||| values	count=1
class	of ||| timedelta index	count=1
function_arg	str [arg_2] ||| [arg_2] [function_1]	count=1
class	for series ||| ndframe	count=1
class	a new block ||| block	count=4
function	a float dtype ||| float	count=1
function	provide concatenation ||| concat sparse	count=1
function	to [function_2] ||| [function_2] string [function_1]	count=1
function_arg	[function_1] a ||| [arg_2] [function_1]	count=1
arg	the risk ||| subarr	count=1
arg	block b ||| block block_items existing_col	count=1
arg	columns of this dataframe ||| columns values	count=1
function_arg	type in type_map ||| type fmt	count=2
class	am ||| categorical	count=1
class	return index or ndarray ||| datetime index ops mixin	count=1
module	the built up ||| io	count=1
function	time ||| time	count=1
arg	ndarray or list ||| index columns dtype	count=1
function	[function_1] tuple ||| [function_2] [function_1]	count=3
function	cast it ||| maybe cast	count=1
function	a 1d array of ||| intervals	count=1
function	the ||| get	count=2
function	timedelta parameters ||| timedelta	count=1
arg	from 1-dimensional ndarray ||| arr key	count=1
class	index [class_2] ||| [class_2] [class_1]	count=2
function	and n/a values to ||| and	count=1
arg	dtype of ||| dtype	count=1
function_arg	to the [arg_2] ||| [arg_2] [function_1]	count=1
function	fast path for getting ||| fast	count=1
arg	[arg] is ||| [arg]	count=2
arg	set the value ||| value mgr	count=1
function_arg	custom template [arg_2] ||| [function_1] [arg_2]	count=1
arg	axis equal values ||| axis	count=1
arg	two multiindex ||| other	count=1
function	file node must already ||| append	count=1
function_arg	index [arg_2] ||| [function_1] keys drop append [arg_2]	count=2
arg	a simple ||| columns	count=1
class	return ||| range	count=1
module	the values of ||| core	count=1
class	needs additional ||| index	count=1
class	block and are ||| block	count=1
arg	file node must ||| format	count=1
function	return the dtype object ||| dtypes	count=1
module	:class packer for ||| io msgpack	count=1
arg	to table ||| key	count=1
arg	in i ||| i	count=2
arg	be ||| key value	count=1
function	pandas type to ||| type	count=1
function	localize tz-naive timeseries ||| tz localize	count=1
function	try to ||| try convert	count=1
module	fully deleting the ||| io	count=1
function_arg	[function_1] column ||| [arg_2] [function_1]	count=4
arg	table in file node ||| format	count=1
function_arg	info axis [arg_2] ||| [function_1] slice [arg_2]	count=3
module_class	[module_1] underlying data ||| [module_1] [class_2]	count=16
function	scipy ||| scipy	count=1
function	[function_1] [function_2] using fixed strptime formats ||| [function_1] [function_2]	count=3
module_class	in the [class_2] ||| [module_1] [class_2] ixs i axis	count=1
arg	this argument ||| arg	count=1
module	in ||| core	count=1
module	compute a ||| core	count=1
function	expanding [function_2] ||| [function_2] [function_1]	count=3
class	with times to ||| datetime	count=1
function_arg	convert [arg_2] ||| [function_1] to font [arg_2]	count=1
module	if it has ||| core	count=1
module_class	is [class_2] ||| [module_1] [class_2]	count=2
class	for groupby ||| groupby	count=1
arg	nan/nat from the ||| val	count=1
arg	levels names [arg_2] ||| [arg_2] [arg_1]	count=2
arg	parameter ||| cls	count=1
function_arg	id [arg_2] ||| [function_1] [arg_2]	count=1
class	internal ||| ndframe	count=1
arg	for :meth ||| inplace limit downcast	count=2
function	[function_1] display options ||| [function_2] [function_1]	count=1
function	feather-format object from ||| feather	count=1
arg	from ndarray ||| index columns dtype	count=1
module	i-th value [module] ||| [module]	count=2
function	array ||| hash array	count=1
class	raise keyerror ||| chain	count=1
function	masked rec [function_2] ||| [function_2] [function_1]	count=5
arg	[arg] offsets ||| [arg]	count=1
module	length is ||| indexes	count=1
arg	along a given axis ||| axis method	count=1
function	wrap [function_2] ||| [function_2] [function_1]	count=3
arg	indicated number of times ||| arr repeats	count=1
function	set coerce the ||| coerce	count=1
class	each group if ||| group by	count=1
function	hash a categorical ||| hash categorical	count=3
function	string format ||| format datetime64 from	count=1
arg	the [arg_1] [arg_2] using the provided connection ||| [arg_1] [arg_2] cur params	count=1
function	to sif http //www ||| to	count=1
function	[function_1] object dtype ||| [function_2] [function_1]	count=7
arg	packed object return an ||| packed	count=1
module	of sparse/dense ||| core	count=1
function	use this if you ||| value	count=1
arg	o and return packed ||| o	count=1
function	valid ||| valid dtype	count=1
function	return a dict ||| get	count=1
module	to html ||| io	count=1
class	beginning ||| date offset	count=1
function_arg	string for [arg_2] ||| [function_1] [arg_2]	count=1
class	is an ||| index	count=2
function_arg	[function_1] style_dict ||| [function_1] to style kwargs [arg_2]	count=1
class	of styler with a ||| styler	count=1
function	header rows ||| pop header name	count=1
module	property synonym for ||| core	count=1
function	that we ||| validate ordered	count=1
function	deprecated option and if ||| if deprecated	count=1
function_arg	categorical [arg_2] ||| [arg_2] [function_1]	count=2
function	return true if ||| is in table	count=1
arg	convenience function ||| xi yi x der	count=1
arg	a datetimeindex of dates ||| dates	count=1
function	to determine if ||| n method	count=1
class	a tree-like object that ||| parser	count=1
function	is datetimelike (e ||| maybe to datetimelike	count=1
arg	parameters ||| name	count=1
module	am never ||| core	count=1
class	dateoffset ||| offset	count=1
function	fast path ||| fast	count=1
function_arg	[function_1] to ||| [arg_2] [function_1]	count=8
arg	labels using [arg_2] ||| [arg_2] [arg_1]	count=2
function_arg	[function_1] result ||| [arg_2] [function_1]	count=3
function_arg	[function_1] serialize ||| [function_1] path [arg_2]	count=1
arg	on a and ||| op_str a	count=2
function	[function_1] an iterator ||| [function_1] [function_2]	count=1
function	without null values ||| dropna	count=1
arg	item at [arg_2] ||| [arg_1] [arg_2]	count=1
class	is ||| select n	count=1
function	[function_1] [function_2] ||| [function_2] string [function_1]	count=2
arg	to read_excel(excelfile ||| sheetname header skiprows skip_footer	count=1
module	use this if you ||| core indexes	count=1
function	the formatted ||| formatter func	count=1
function	hash [function_2] ||| [function_2] [function_1]	count=1
function	getitem defers ||| getitem	count=1
arg	with the data ||| data	count=1
module	up styles to html ||| io formats	count=1
arg	value from 1-dimensional ndarray ||| key value	count=1
class	in the index ||| index	count=1
function	sif http //www stata ||| stata	count=1
arg	n between self analagoust ||| n	count=1
function_arg	of same [arg_2] ||| [function_1] class values [arg_2]	count=1
module	slice of ||| core	count=2
class	to midnight length is ||| datetime	count=1
function	the reindex for all ||| reindex	count=1
arg	a possibly local context ||| key is_local	count=1
function	the info axis ||| get info	count=1
module	use this if ||| core	count=1
arg	nrows ncols - number ||| nrows ncols	count=1
function	convert back to bool/int ||| downcast to	count=1
class	datetime date objects (namely ||| datetime	count=1
class	single element pandasobject ||| ndframe	count=1
class	ndarray only use this ||| index	count=3
arg	data converts other ||| data	count=1
class	the frame ||| frame	count=1
module	new [module] inserting new ||| [module]	count=1
class	needs ||| period index	count=2
function	display [function_2] ||| [function_2] [function_1]	count=4
function_arg	intersection of [arg_2] ||| [function_1] [arg_2]	count=2
module	object ||| io	count=2
function	passed type is an ||| is	count=1
function	invert ||| invert	count=1
arg	in the ||| inplace	count=1
arg	object dtype ||| dtype	count=1
function	tuples ||| tuples	count=1
arg	_apply kwargs and ||| func name window center	count=1
function	ftypes (indication ||| ftypes	count=1
function	[function_1] classes which ||| [function_1] timeseries [function_2]	count=3
class	iterate over the ||| html	count=1
arg	return object dtype ||| dtype	count=1
arg	3 columns of this ||| index columns values	count=1
module	iterate over the ||| io	count=1
function	series/index by indicated ||| str	count=1
function	[function_1] named ||| [function_1] [function_2]	count=1
arg	dataframe is [arg] ||| [arg]	count=1
function	want to construct ||| array	count=1
function	re-evaluate the obj with ||| and	count=1
arg	decorator to ||| decorator	count=1
arg	specified dtype ||| result dtype	count=1
arg	the requested level ||| level	count=1
function	prior ||| prepare	count=1
arg	[arg] it ||| [arg]	count=3
arg	input values as ||| values	count=1
class	additional handling as ||| index	count=1
class	be ||| html	count=1
arg	return fillvalue for ||| fillvalue	count=1
arg	from each ||| arr	count=1
arg	exist and ||| format	count=1
module	the keys will ||| core	count=1
function	stderr in a ||| stderr	count=1
function_arg	writing stata [arg_2] ||| [function_1] [arg_2]	count=1
module	and ||| io	count=1
function_arg	cartesian product [arg_2] ||| [function_1] cls [arg_2]	count=1
function	[function_1] a table ||| [function_1] [function_2]	count=3
class	underlying ||| multi	count=1
arg	compute a ||| values	count=1
function	csv file (discouraged ||| from csv	count=2
arg	[arg_1] in the ||| eval [arg_1] [arg_2]	count=2
arg	higher [arg_2] ||| [arg_1] [arg_2]	count=3
module	the built up ||| formats	count=1
function	if ||| safe	count=2
arg	a panel-like dataframe ||| time panels names	count=1
module	timedelta-like ||| core indexes	count=1
function	for this colummn ||| attr	count=1
arg	ndarray copy if specified ||| index dtype copy	count=1
function	detect terminal size and ||| get terminal size	count=1
module	return the number ||| core indexes	count=2
module	true if ||| core	count=1
function	of the stata date ||| stata	count=1
function	of non-na/null observations in ||| count	count=1
arg	fast lookup of ||| arr key	count=1
arg	bears the risk ||| subarr	count=1
function	a new ||| putmask	count=1
arg	row labels using one ||| inplace	count=1
arg	rows of other to ||| other	count=1
function	[function_1] result set ||| [function_2] [function_1]	count=1
arg	[arg_1] arr2 ||| [arg_2] [arg_1]	count=3
module	to its values attribute ||| core	count=1
function	string-like that is object ||| string array	count=1
arg	of multiple iterables parameters ||| cls iterables sortorder names	count=1
class	can ||| html	count=1
function_arg	[function_1] dtype ||| [arg_2] [function_1]	count=7
function	dict of array-like ||| dict	count=1
class	return ||| multi index	count=1
class	database ||| sqlite database	count=1
function	of object to the ||| to	count=1
arg	of value from ||| key value	count=1
module	to midnight length ||| core indexes	count=1
module	elements from the ||| io	count=1
function	only use ||| value	count=1
class	exception raised ||| assert raises	count=1
arg	values can be ||| values name freq	count=1
arg	back [arg] levels ||| [arg]	count=1
arg	the new [arg_2] ||| [arg_2] [arg_1]	count=4
class	return the ||| index	count=2
function	with closed ||| interval closed	count=1
function	used ||| build	count=1
function	locator based ||| get locator	count=1
function	never a view ||| view	count=1
arg	to returning new ||| name inplace	count=2
function	category labels ||| labels	count=1
function	draw [function_2] ||| [function_2] [function_1]	count=8
function	scalar to a compat ||| scalar to	count=1
class	up ||| styler	count=1
function	our asof [function_2] ||| [function_1] [function_2]	count=1
module	up styles ||| io formats	count=1
function	metadata ||| read metadata	count=1
function	is valid for ||| is valid	count=1
module	[module_1] the background ||| [module_2] [module_1]	count=1
class	index return new dataframe ||| data frame	count=1
function_arg	[function_1] a sparseseries ||| [function_1] sparse series [arg_2]	count=1
function	kwargs suitable ||| kwargs	count=1
function	rewrite the assignment ||| rewrite assign	count=1
function	[function_1] dtype ||| [function_2] [function_1]	count=1
function	string ||| string to	count=1
arg	valid other [arg_2] ||| [arg_1] [arg_2]	count=1
function	[function_1] where ||| [function_1] [function_2]	count=1
class	subclass of styler with ||| styler	count=1
arg	specialized cython ||| axis out	count=1
arg	a column by ||| data	count=1
function	[function_1] info axis ||| [function_2] [function_1]	count=2
function	with closed [function_2] ||| [function_2] [function_1]	count=1
function_arg	zeros [arg_2] ||| [arg_2] [function_1]	count=1
function	[function] datetimeindex to ||| [function]	count=1
module	index with ||| indexes	count=3
module	of strings to numpy ||| numpy	count=1
function	a registered [function_2] ||| [function_2] [function_1]	count=1
function	[function_1] format ||| [function_1] [function_2]	count=3
function	given quantile ||| quantile	count=1
class	over ||| frame parser	count=2
class	synonym for ||| ndframe	count=1
class	box ||| index ops mixin	count=1
function	the process of casting ||| safe casting	count=1
class	[class] bb ||| categorical [class]	count=3
function	to a leap year ||| is leap year	count=1
arg	in file node ||| value	count=1
function	to be unordered ||| as unordered	count=2
function	a html [function_2] ||| [function_2] [function_1]	count=2
class	frame ||| frame	count=3
class	[class_1] [class_2] ||| [class_1] [class_2]	count=96
function	gets called after ||| wrap	count=3
class	applicable to ||| group by	count=1
function	[function_1] list-like ||| [function_1] [function_2]	count=1
class	that can ||| parser	count=1
function	slice [function_2] ||| [function_2] [function_1]	count=4
arg	table in file ||| key	count=1
function	list ||| tolist	count=1
arg	of two ||| other result_name	count=1
function	[function_1] sparseseries or ||| [function_2] [function_1]	count=1
module	return ||| tseries	count=1
function	options grouped by ||| options	count=1
function	format ||| format datetime64	count=1
module	that do ||| util	count=1
function_arg	pickle serialize ||| pickle path compression	count=1
function	is a file-like ||| is file like	count=3
arg	using input ||| copy inplace	count=1
function_arg	[function_1] fillvalue ||| [arg_2] [function_1]	count=2
class	values return a block ||| block	count=1
function	given an ||| get interval	count=1
module	return frequency code ||| tseries	count=1
module	of a single element ||| core	count=1
function	whether this ||| validate iterable	count=1
function	the index ||| reset index	count=1
function	lookup of ||| value	count=1
class	element pandasobject ||| ndframe	count=1
function	float ||| eng float	count=1
function	according to ||| slice bound	count=1
function	[function_1] monday instead ||| [function_1] [function_2]	count=3
module	return packed bytes see ||| io	count=1
module	create an ||| core computation	count=1
function	[function_1] locales that ||| [function_2] [function_1]	count=1
function	is a valid ||| valid	count=1
function_arg	[function_1] [arg_2] ||| [function_1] unit mappings [arg_2]	count=2
function	so prints a warning ||| warn	count=1
arg	ufunc needs additional ||| result context	count=1
arg	[arg_1] type ||| [arg_2] [arg_1]	count=16
module_class	and replaces these with [module_1] [class_2] value ||| [module_1] [class_2]	count=1
module_class	putmask the data to [module_1] [class_2] that ||| [module_1] [class_2]	count=1
arg	time and ||| time	count=1
function	to write this ||| write	count=2
module	called after ||| indexes	count=2
function_arg	locale [arg_2] ||| [arg_2] [function_1]	count=1
class	series to the ||| series	count=1
arg	a dataframe ||| data values index columns	count=1
module	in ||| io	count=1
function	boolean if we need ||| is	count=1
function	[function_1] of scatter ||| [function_2] [function_1]	count=4
function	take which ||| take	count=1
function	a simple cross-tabulation ||| crosstab	count=1
function	freq and stride ||| and stride	count=1
function	that ||| assert	count=1
class	tree-like object that can ||| parser	count=1
class	iterate over ||| parser	count=1
function	iterate over the dom ||| doc	count=1
arg	an indexer like _name ||| cls name indexer	count=1
function	if [function_2] ||| [function_1] [function_2]	count=5
module	times ||| indexes	count=1
arg	blocks collect and ||| axis consolidate transposed	count=1
arg	and [arg_2] ||| [arg_1] [arg_2]	count=9
function	of available options grouped ||| pp options	count=1
class	it to timedelta ||| timedelta	count=1
class	a new manager with ||| block manager	count=1
function_arg	dataframe [arg_2] ||| [function_1] [arg_2]	count=1
function	missing ||| from missing	count=1
function	min/max version [function] ||| skip if no [function]	count=1
function	two indices overlap ||| overlap	count=1
function	to convert timedelta-like ||| td index	count=1
module	formats a ||| formats	count=1
function_arg	[function_1] node like ||| [arg_2] [function_1]	count=1
module	used ||| io	count=1
function	the node with ||| get node	count=2
arg	new ||| copy errors values	count=2
arg	set of query in ||| index_col coerce_float	count=1
function	multirow ||| multirow	count=1
arg	name this allows simpler ||| name	count=1
module	return datetimeindex with times ||| indexes	count=1
class	am never ||| categorical block	count=1
class	manager with the ||| block manager	count=1
function	named tuple ||| named tuple	count=2
function_arg	nodes [arg_2] ||| core computation filter [function_1] [arg_2]	count=1
class	is ||| chain	count=1
function	[function_1] named ||| [function_2] [function_1]	count=1
arg	the indexer fill with ||| indexer allow_fill	count=1
module	as elements in the ||| core	count=1
function	checking function of type ||| type	count=1
function	a ||| ordered	count=1
function	a ||| validate	count=1
class	datetimeindex from ||| datetime index	count=1
module	of ||| core	count=32
function	default ||| default	count=1
function	[function_1] or sparsearray ||| [function_2] [function_1]	count=2
arg	and be table ||| value format	count=1
function	select values between particular ||| between	count=2
arg	at passed [arg] ||| [arg] value	count=2
function_arg	[function_1] alignment_dict ||| [function_1] to alignment [arg_2]	count=1
function	[function_1] empty ||| [function_1] line [function_2]	count=1
function	of type ||| type	count=1
arg	using input ||| axis copy inplace	count=1
function	exist and be ||| append	count=1
arg	*not* the ||| other	count=1
arg	with optional filling/interpolation designed ||| left right on left_on	count=1
function	code group of ||| group	count=1
arg	exist and ||| value format	count=1
function	of columns as ||| columns	count=1
class	underlying data as a ||| index ops mixin	count=1
class	sorted ndframe ||| ndframe	count=1
class	to iterate over ||| html	count=1
arg	according to indexer ||| indexer	count=2
function	the len ||| size	count=1
class	maps[0] raise keyerror ||| chain	count=1
function	needs ||| array wrap	count=2
module	ndarray only ||| core indexes	count=1
function	[function_1] returns axes ||| [function_2] [function_1]	count=1
function	coerces data to ||| to	count=1
function	a prettier version ||| pretty string	count=1
function	[function] leveraging ||| [function]	count=2
class	excluding ||| by	count=1
function	datetimelike ||| datetime	count=1
arg	to class python ||| cls	count=1
arg	valid ordered parameter if ||| ordered	count=1
module	couple [module] exceptions ||| [module]	count=1
module	conform a set of ||| core	count=1
function	only use this ||| value	count=1
class	of ||| ndframe	count=2
class	of this ||| period index	count=1
arg	obj and ||| obj	count=1
class	return a ndarray of ||| index	count=1
class	raise keyerror is ||| map	count=1
arg	frequency if ||| freq axis	count=1
function	gets the mode s ||| mode	count=1
arg	[arg_1] correct dtype ||| [arg_1] [arg_2]	count=1
arg	plural 'names' parameter ||| names deep	count=1
function	called prior to ||| prepare	count=1
module	needs additional handling as ||| core	count=1
function	1-dimensional ndarray only use ||| set	count=1
function_arg	append rows [arg_2] ||| [function_1] [arg_2]	count=3
function	series concat ||| get series	count=1
function	missing ||| convert from missing	count=1
function	as a [function_2] ||| [function_2] [function_1]	count=2
function	concatenation of an datetimelike ||| concat datetime	count=1
module	multiindex ||| core indexes	count=8
arg	from the ||| arr	count=1
module	built up styles to ||| formats	count=1
arg	[arg_1] method for ||| [arg_2] [arg_1]	count=2
arg	frequency [arg_2] ||| [arg_2] [arg_1]	count=1
module	packed bytes see ||| msgpack	count=1
class	block from the result ||| block	count=1
function	take which sets ||| take nd	count=1
function_arg	define an internal [function_1] [arg_2] ||| cython [function_1] [arg_2]	count=6
arg	and ||| args	count=2
function	[function_1] prettier version ||| [function_1] [function_2]	count=1
arg	_apply kwargs ||| func name window center	count=1
class	index or ndarray filled ||| datetime index ops mixin	count=1
function	evaluate the block return ||| eval	count=1
function	the size of the ||| itemsize	count=1
function	return a [function_2] ||| [function_2] [function_1]	count=2
arg	indexer ||| name indexer	count=1
arg	evaluate a python expression ||| expr	count=1
function	display options ||| display options	count=2
function	[function_1] cartesian product ||| [function_1] [function_2]	count=1
arg	values [arg_2] ||| [arg_2] [arg_1]	count=3
function	str df ||| str	count=1
function_arg	[function_1] [arg_2] ||| [function_1] data columns [arg_2]	count=10
class	the ||| styler	count=1
function	for ||| arith method	count=2
function_arg	repr function [arg_2] ||| [arg_2] [function_1]	count=3
class	categorical instance ||| categorical	count=1
class	create index with ||| multi index	count=1
class	tree-like object that ||| html frame	count=1
function	which ||| new	count=1
function	of the (attr formatted_value) ||| format attrs	count=4
module	of a ||| core	count=1
function	evaluate a ||| evaluate	count=1
module	raise a typeerror if ||| dtypes	count=1
function	'numpy' library the ||| take with convert	count=1
arg	to the key as ||| key values	count=1
function	a full [function_2] ||| [function_1] [function_2]	count=1
class	datetimeindex from one time ||| datetime index	count=1
class	table in file ||| hdfstore	count=1
class	the same ||| ndframe	count=1
class	unaltered ||| datetime index	count=1
function_arg	is *not* ||| is other	count=1
class	for this ||| index	count=1
function	a latex [function_2] ||| [function_2] [function_1]	count=2
function	wrap long strings ||| wrap	count=1
arg	scalar data converts other ||| data	count=1
function	object dtype ||| object	count=1
arg	append to table ||| append	count=1
function	the 'numpy' library ||| with convert	count=1
class	styler with a ||| styler	count=1
function	highlight the maximum ||| highlight max	count=3
class	a dataframe ||| data frame formatter	count=1
arg	*not* the same ||| other	count=1
arg	run the same function ||| num_threads kwargs_list	count=1
function	dict ||| dict	count=2
arg	when non-unique ||| target	count=1
function_arg	[function_1] key or ||| [function_1] node [arg_2]	count=1
arg	a style_dict ||| style_dict num_format_str	count=1
arg	of ||| index columns values	count=1
function	parameter if ||| ordered	count=1
function	an positional ||| valid positional	count=1
arg	[arg_1] is a ||| [arg_1] [arg_2]	count=1
class	iterate ||| html frame parser	count=2
module	that can be used ||| io	count=1
arg	do a ||| src_list dest_list inplace	count=1
arg	decorator to take ||| decorator	count=1
module	an expression in python ||| computation	count=1
function	[function_1] [function_2] ||| [function_2] [function_1]	count=308
class	of the list ||| list	count=1
function	native path [function] a ||| file path [function]	count=1
function	arguments ||| args	count=1
arg	converts a [arg_2] ||| [arg_2] [arg_1]	count=2
function	str ||| str	count=3
function	[function_1] full length ||| [function_1] [function_2]	count=1
function	[function_1] offset/observance ||| [function_1] [function_2]	count=1
function	time ||| ensure like indices	count=1
function	process of casting ||| casting	count=1
function	draw ||| frame	count=1
function	build [function_2] ||| [function_1] [function_2]	count=2
function	construct a slice ||| slice	count=1
function	a categorical ||| categorical	count=3
function	'numpy' library ||| validate take with	count=1
arg	fillvalue ||| fillvalue	count=1
function	construct concatenation [function_2] ||| [function_2] [function_1]	count=1
function	given a tuple of ||| get	count=1
arg	[arg_1] right data ||| [arg_1] [arg_2]	count=1
class	new multiindex from ||| multi index	count=1
function	[function_1] of given ||| [function_2] [function_1]	count=4
module	:class packer for options ||| io	count=1
class	a ndarray of ||| index	count=1
function	[function_1] a sequence ||| [function_2] [function_1]	count=1
function_arg	prettier version [arg_2] ||| [arg_2] [function_1]	count=1
function	to the ||| to	count=3
function	convert timedelta-like to timedelta64 ||| td	count=1
function	the info axis of ||| info	count=1
class	index ||| index	count=18
function	expanding count of ||| expanding count	count=2
class	remove and return ||| map	count=1
function	select values between particular ||| indexer between	count=1
function	needs additional handling ||| array	count=1
arg	n ||| n	count=1
function	the dtype to ||| dtype	count=1
function	to table in ||| append	count=1
class	return a ndarray ||| index	count=1
function	[function_1] scalar ||| [function_1] [function_2]	count=3
function	a ||| wrap	count=3
arg	labels using ||| inplace	count=1
module	convert ||| core computation	count=1
arg	nan/nat from ||| val	count=1
function	checks that path's extension ||| extension	count=1
function_arg	wrap result [arg_2] ||| [arg_2] [function_1]	count=2
function	try to parse a ||| try convert	count=1
module	attribute if it ||| core	count=1
function	function ||| func	count=4
function	first element ||| item	count=1
function	[function_1] sparseseries ||| [function_2] [function_1]	count=1
arg	item at ||| item	count=1
arg	run ||| num_threads kwargs_list	count=1
function	add [function_2] ||| [function_2] [function_1]	count=7
function	valid ||| valid	count=3
module	midnight ||| core indexes	count=2
arg	from ||| primary_key	count=1
function_arg	[function_1] argument return ||| [arg_2] [function_1]	count=3
arg	indexer and ||| indexer axis	count=2
module	dimensions as the original ||| core	count=1
function_arg	[function_1] an index ||| [arg_2] [function_1]	count=1
function_arg	[function_1] [arg_2] ||| [function_1] to number format [arg_2]	count=1
class	over ||| parser	count=1
function	test result and ||| test result	count=2
arg	[arg_1] from each ||| [arg_2] [arg_1]	count=2
arg	this if ||| key	count=1
function_arg	[function_1] [arg_2] ||| [function_1] table_name con schema [arg_2]	count=3
function	if we can set ||| can set	count=1
function	we have a ||| validate ordered	count=1
class	index objects and ||| range index	count=1
arg	two multiindex objects sorting ||| other	count=1
function	with the block ||| block	count=1
function_arg	nrows [arg_2] ||| [arg_2] [function_1]	count=6
function	the dtype ||| infer dtype	count=1
module	check if the ||| core	count=4
module	object ||| io msgpack	count=3
function_arg	[function_1] expected ||| [function_1] [arg_2]	count=1
function	we have [function_2] ||| [function_1] [function_2]	count=5
arg	input function or ||| axis copy	count=1
arg	using indicated [arg_2] ||| [arg_2] [arg_1]	count=4
arg	already exist and ||| format	count=1
arg	ndarray only ||| arr key	count=1
arg	and 'kwargs' should ||| args kwargs	count=2
arg	a left-join except that ||| left right on left_on	count=1
function	parse ||| parse time	count=1
arg	[arg] appropriate window ||| [arg] arg	count=1
function	to parse ||| parse time	count=1
function	optional positional and ||| optional	count=1
function	[function_1] a method ||| [function_1] [function_2]	count=1
arg	node must already exist ||| value	count=1
function	convert [function_2] ||| [function_2] [function_1]	count=2
module	keyerror is maps[0] ||| compat	count=1
function	into codes given ||| get codes	count=2
function	be [function_2] ||| [function_1] [function_2]	count=1
function	take ||| take	count=9
class	panel to a specified ||| panel	count=1
arg	a given width ||| width	count=1
arg	info from string representation ||| freqstr	count=1
function	from ||| value	count=1
module_class	[module_1] myself ||| [module_1] [class_2]	count=2
arg	the smallest ||| categories	count=1
class	new multiindex from the ||| multi index	count=1
function	get the [function_2] ||| [function_2] [function_1]	count=3
function	of all ||| all	count=1
function_arg	[function_1] of dates ||| [arg_2] [function_1]	count=2
arg	already exist and be ||| value	count=1
function	is of the ||| is	count=2
function	[function_1] display options ||| [function_1] [function_2]	count=1
function_arg	index [arg_2] ||| [function_1] [arg_2]	count=3
function	label for this ||| label	count=1
class	to ||| html frame	count=1
module	the built up styles ||| io	count=1
function	[function_1] sparseseries ||| [function_1] [function_2]	count=1
arg	in file ||| format	count=1
function	keys across my ||| tuple	count=1
class	tree-like ||| parser	count=1
function	label for first ||| first	count=2
function	monotonic ||| monotonic	count=1
arg	its label ||| label	count=1
function	two indices overlap add ||| items overlap	count=1
function	coerce values ||| coerce	count=1
arg	and 'kwargs' should be ||| method args kwargs	count=1
arg	of a table ||| table	count=1
arg	specified [arg] note cannot ||| [arg] optlevel	count=1
class	is ||| interval dtype	count=1
function	ftypes in ||| ftype	count=1
arg	converts dtype ||| dtype	count=1
class	this ||| index col	count=2
module	length ||| indexes	count=1
function	append rows of ||| append	count=1
arg	omitting na/null values ||| axis kind order	count=1
function	required package is ||| package	count=1
function	detect terminal size ||| get terminal size	count=2
function	is valid ||| is valid	count=1
arg	file node must already ||| key value format	count=1
function	the where ||| where	count=1
arg	cross-tabulation ||| index	count=1
module	resets the index ||| io json	count=2
arg	value from ||| key value	count=1
class	times to midnight length ||| index	count=1
function	[function_1] reflecting ||| [function_2] [function_1]	count=6
function	the dtypes ||| dtypes	count=1
function	the join [function_2] ||| [function_2] [function_1]	count=2
class	return index ||| datetime index ops mixin	count=1
function_arg	[function_1] key or ||| [arg_2] [function_1]	count=4
class	raise keyerror ||| map	count=1
arg	value ||| value mgr	count=1
class	can be ||| html frame parser	count=1
module	after ||| core indexes	count=4
arg	frequency freq ||| freq	count=1
function	set of kwargs ||| kwargs	count=1
arg	to class ||| cls name	count=1
arg	left-join except that we ||| left right on left_on	count=1
function	a frequency ||| freq	count=1
function_arg	[function_1] a code ||| [arg_2] [function_1]	count=3
function	stata and ||| stata	count=1
module	object dtype ||| dtypes	count=2
arg	sure that time ||| time	count=1
arg	the we have ||| name freq	count=1
module_class	if ndframe ||| core ndframe	count=1
module	bytes see :class ||| io	count=1
function	header rows in ||| header name	count=1
class	that can ||| html	count=1
function_arg	stata binary ||| to stata fname	count=1
arg	ndarray or ||| index columns	count=1
class	each interval in the ||| interval	count=1
function	invoked by str df ||| str	count=1
function	[function_1] to long ||| [function_2] [function_1]	count=1
arg	3 columns ||| columns	count=1
arg	check that left ||| left	count=4
function	alignment object parameters ||| alignment	count=1
function_arg	to beginning [arg_2] ||| [arg_2] [function_1]	count=1
function	setup our binners ||| binner	count=1
module	times to midnight length ||| core indexes	count=1
function	might need to coerce ||| maybe coerce	count=1
function_arg	quickly retrieve single [function_1] [arg_2] ||| [function_1] [arg_2] takeable	count=1
class	[class_1] [class_2] ||| [class_2] [class_1]	count=30
class	returns the float ||| float	count=1
function	[function_1] offset/observance ||| [function_2] [function_1]	count=1
class	dataframe and major_axis ||| ndframe	count=1
function	[function_1] of a ||| [function_1] [function_2]	count=1
arg	[arg_1] a ||| [arg_1] [arg_2]	count=2
function_arg	same [arg_2] ||| [arg_2] [function_1]	count=1
arg	multiple iterables ||| iterables sortorder names	count=2
function	registered option ||| registered option	count=1
function	indexer ||| indexer	count=4
function	[function_1] which ||| [function_1] timeseries [function_2]	count=2
arg	(header new_data) ||| row index_col	count=1
function	have a ||| ordered	count=1
class	that ||| html frame	count=1
function	formats to ||| to	count=1
function	fast lookup of ||| value	count=1
module	datetime index with ||| indexes	count=1
arg	values can ||| values name freq	count=1
module	the html representation with ||| io	count=1
module	it has one ||| core	count=1
arg	point [arg] nans and ||| [arg]	count=1
function	info axis of ||| get info	count=1
function	[function_1] offset/observance to ||| [function_1] [function_2]	count=1
class	returns the float ||| float array	count=1
function_arg	check whether [arg_2] ||| [function_1] dtype [arg_2]	count=2
function_arg	table [arg_2] ||| [function_1] [arg_2]	count=2
module	see ||| io msgpack	count=2
arg	[arg_1] inferring dtype ||| [arg_1] [arg_2]	count=2
class	tree-like ||| frame	count=1
function_arg	[function_1] when non-unique ||| [arg_2] [function_1]	count=1
class	python datetime date ||| datetime index	count=1
module	not the ||| io	count=1
function	[function_1] tuple ||| [function_1] [function_2]	count=3
function	the internal ||| values	count=1
module	applies ||| core	count=1
module	that ||| io	count=1
arg	and b ||| b	count=1
function	pandas only dtype ||| pandas	count=1
function	you ||| set	count=1
class	additional ||| period	count=1
function	try to parse a ||| try convert to	count=1
class	used to iterate ||| html frame parser	count=1
arg	code to a ||| code	count=1
module	datetimeindex with ||| indexes	count=1
class	the group ||| group by	count=1
function	infer types ||| infer types	count=1
function_arg	[function_1] obj ||| [function_1] slice [arg_2]	count=2
class	it to timedelta ||| timedelta index	count=1
function	dtype and n/a values ||| get empty dtype and	count=1
class	frame table ||| multi series table	count=1
function	to coerce ||| maybe coerce freq	count=1
function	to ||| coerce to	count=1
function	an asof merge ||| merge asof	count=2
function	multi ||| multi	count=2
function	[function_1] index ||| [function_2] [function_1]	count=1
function	best locator based on ||| get locator	count=1
arg	a simple ||| columns values	count=1
function_arg	apply [arg_2] ||| [arg_2] [function_1]	count=4
class	be used to iterate ||| html frame parser	count=1
arg	removes the ||| removals inplace	count=1
class	backward ||| group by	count=1
function_arg	coerce the [arg_2] ||| [function_1] dtype [arg_2]	count=5
module	each string in the ||| core	count=4
class	of index ||| index	count=1
class	its values ||| series	count=1
arg	a simple cross-tabulation ||| index columns values	count=1
function_arg	result set [arg_2] ||| [function_1] data columns [arg_2]	count=2
function	if we [function_2] ||| [function_2] [function_1]	count=10
function	provide iteration over ||| iter	count=1
class	float values converted into ||| float	count=1
module	wrap ||| core sparse	count=1
arg	the indexer fill ||| indexer	count=1
class	return index or ndarray ||| index ops	count=1
module	index with business day ||| indexes	count=1
function	need to coerce a ||| coerce	count=2
function	[function_1] table reflecting ||| [function_1] [function_2]	count=3
class	its ||| series	count=1
arg	params args to dbapi2 ||| params	count=1
module	the string if ||| core	count=1
function	compare numeric ||| numeric v string	count=1
arg	null_color for missing values ||| null_color	count=1
function	data the ||| slice	count=1
arg	ufunc needs ||| context	count=1
module	reshape ||| core reshape	count=1
arg	and arr ||| arr	count=1
class	as a frame table ||| appendable multi series table	count=1
arg	compute a simple ||| index columns	count=1
class	to ||| frame	count=1
function	class ||| append	count=1
arg	block manager and indexers ||| mgr indexers	count=1
module	of sparseseries (with nan ||| core sparse	count=1
arg	fillvalue for a ||| fillvalue	count=1
class	index objects contain ||| index	count=2
class	that dict has only ||| parser	count=1
function	boolean mask of index ||| index	count=1
class	from each group ||| group by	count=1
class	and ||| map	count=1
arg	validates that we have ||| cls	count=1
function	writing stata ||| to stata	count=1
class	in file node must ||| hdfstore	count=1
function	indices overlap add ||| items overlap	count=1
arg	axis with [arg_2] ||| [arg_1] [arg_2]	count=1
module	:class packer for ||| io	count=1
function_arg	exception and [arg_2] ||| [arg_2] [function_1]	count=4
module_class	return myself ||| core datetime tzblock	count=1
function	bounds for ||| to bounds	count=1
function_arg	[function_1] statement ||| [function_1] [arg_2]	count=3
function	string and ||| parsed string	count=1
function	alias [function_2] ||| [function_2] [function_1]	count=2
function_arg	[function_1] possibility ||| [arg_2] [function_1]	count=4
function	[function_1] object ||| [function_1] string to [function_2]	count=1
arg	[arg_1] query ||| [arg_2] [arg_1]	count=2
function	this if ||| set	count=1
function_arg	length of [arg_2] ||| [arg_2] [function_1]	count=1
function	numeric add/sub ||| numeric	count=1
function	the string ||| string	count=1
arg	provided encoding ||| fh encoding compat is_verbose	count=1
function_arg	symmetric difference [arg_2] ||| [function_1] [arg_2]	count=1
function	argsort argsorts the ||| argsort	count=1
function	string-like array [function_2] ||| [function_1] [function_2]	count=1
class	the ||| ndframe	count=5
class	data for ||| data col	count=1
function	called after ||| wrap	count=3
function	reset [function_2] ||| [function_2] [function_1]	count=6
module_class	the [class_2] ||| [module_1] [class_2] ixs i axis	count=1
arg	[arg_1] array ||| [arg_2] [arg_1]	count=4
function	true if this is ||| is	count=2
function_arg	[function_1] value is ||| [arg_2] [function_1]	count=1
arg	guarantee the shape ||| shape	count=1
function	specific types ||| types	count=2
function	connect ||| can connect	count=1
arg	risk ||| subarr	count=1
function	so prints a ||| warn	count=1
module	see ||| io	count=1
class	is maps[0] ||| chain map	count=1
function_arg	[function_1] a function ||| [arg_2] [function_1]	count=1
function	turn ||| for	count=1
module	by ||| io formats	count=1
module_class	nans and replaces these [module_1] [class_2] for missing value ||| [module_1] [class_2] writer replace nans	count=1
module_class	putmask the data to [module_1] [class_2] possible that ||| [module_1] [class_2]	count=1
class	only use this ||| index	count=1
function	[function_1] [function_2] ||| [function_2] freq [function_1]	count=7
module_class	[module_1] values need ||| [module_1] [class_2]	count=1
function	[function_1] monotonic ||| [function_2] [function_1]	count=1
arg	dataframe the levels in ||| data values index	count=1
function	datetime to sif http ||| datetime to	count=1
module	of the ||| core	count=17
class	are ||| numeric index	count=1
arg	value inplace ||| value	count=1
function	variance ||| var	count=1
arg	or columns of ||| axis	count=1
arg	return a boolean ||| a b	count=2
function	is list-like ||| is list like	count=2
function	repr function ||| repr	count=1
function_arg	convert sql and ||| convert params sql	count=1
function	a prettier version of ||| pretty string	count=1
arg	packed object ||| packed object_hook list_hook	count=1
arg	[arg] elements ||| [arg]	count=1
function	node with ||| get node	count=2
function	forward ||| pad	count=1
function	the counts of ftypes ||| ftype counts	count=1
function	from 1-dimensional ndarray only ||| value	count=1
arg	to length ||| length	count=1
function	atom ||| atom	count=1
class	am ||| categorical block	count=2
function	[function_1] of same ||| [function_2] [function_1]	count=3
function	doesn't like to ||| like	count=1
function_arg	[function_1] names defaulting ||| [function_1] [arg_2]	count=4
module	1-dimensional ||| core indexes	count=2
class	index ||| timedelta index	count=2
arg	ncols ||| ncols	count=1
arg	left [arg_2] ||| [arg_1] [arg_2]	count=7
function	check ||| check	count=2
class	can be used to ||| html	count=1
module	if ||| core	count=7
arg	original type ||| dtype	count=1
function	statement that create a ||| create	count=1
class	datetime ||| datetime	count=3
arg	from ||| arr key	count=1
function	add numeric ||| add numeric	count=1
function	see ||| packb	count=1
function	apply the [function_2] ||| [function_1] [function_2]	count=3
function	draw histogram of the ||| hist frame	count=1
function	function for series ||| comp method series	count=2
function	interactive shell ||| interactive session	count=2
arg	at passed [arg_1] [arg_2] ||| [arg_2] [arg_1]	count=2
arg	must ||| value	count=1
class	midnight ||| index	count=1
module	return datetimeindex ||| core indexes	count=1
module	packer for options ||| io msgpack	count=1
function	comparison ||| comparison	count=1
function_arg	assignment node ||| assign node	count=1
function	see if we can ||| can	count=1
function	dtype and n/a ||| dtype and	count=1
arg	for [arg] ||| [arg]	count=1
class	return a tree-like ||| html	count=1
module	boolean ||| core indexes	count=1
arg	that [arg] ||| [arg]	count=1
arg	of values possibly casting ||| values na_values try_num_bool	count=1
arg	[arg_1] and b ||| [arg_2] [arg_1]	count=3
module	conform set of ||| core	count=1
module	frequency datetime index with ||| indexes	count=1
module_class	in the [class_2] ||| [module_1] [class_2]	count=1
function	series extract groups from ||| str extract	count=1
function	[function_1] the where ||| [function_2] [function_1]	count=1
arg	to left ||| left	count=1
function	strings to time ||| to time	count=1
function_arg	[function_1] to class ||| [arg_2] [function_1]	count=3
function	convert timedelta-like ||| td index	count=1
module	cartesian product [module] all possible ||| [module]	count=1
arg	an ||| dtype	count=1
function	frequency ||| freq	count=2
arg	particular axis ||| axis	count=3
module_class	of columns excluding ||| core data frame	count=1
class	index objects contain the ||| index ops mixin	count=1
function	timedelta64[ns] ||| timedelta64 ns	count=1
function	have a null slice ||| null slice	count=1
function_arg	[function_1] against the ||| [function_1] [arg_2]	count=4
function_arg	operations [arg_2] ||| [arg_2] [function_1]	count=4
class	return a tree-like ||| frame	count=1
function	values for ||| level values	count=1
arg	string ||| cls string	count=2
class	of an ||| index	count=1
module	1-dimensional ndarray only ||| core	count=1
module	the store ||| io	count=1
class	on offset ||| offset	count=1
function_arg	[function_1] a ufunc ||| [function_1] [arg_2]	count=3
function	[function_1] string-like ||| [function_2] [function_1]	count=1
arg	tables into a ||| io match flavor	count=1
class	in ||| hdfstore	count=1
arg	a dataframe the levels ||| data values	count=1
class	object ||| html	count=1
function	apply ||| apply	count=6
arg	values as ||| values	count=1
function	a multirow e ||| multirow	count=1
arg	1-dimensional ndarray only use ||| arr	count=1
arg	[arg_1] a and ||| [arg_1] [arg_2]	count=2
function	stride ||| stride	count=1
function	to convert timedelta-like ||| td	count=1
function_arg	[function_1] nan/nat from ||| [arg_2] [function_1]	count=4
function_arg	[function_1] of values ||| [arg_2] [function_1]	count=2
arg	target time zone ||| tz axis level copy	count=1
arg	a given axis ||| axis	count=1
function	block of ||| make block	count=1
class	dataframe in ||| data frame	count=1
function_arg	define an [function_1] [arg_2] it ||| [function_1] [arg_2]	count=4
function	tuple of the shape ||| shape	count=1
function_arg	[function_1] an indexer ||| [function_1] [arg_2]	count=1
function	[function_1] of ||| [function_1] [function_2]	count=1
arg	font_dict ||| cls font_dict	count=1
function	from a row ||| parse	count=1
arg	left-join except that ||| left right on left_on	count=1
module	needs additional handling as ||| indexes	count=1
class	is maps[0] ||| chain	count=1
function	removed ||| drop	count=1
class	to dataframe in ||| data frame	count=1
function	construct this ||| construct	count=1
function_arg	for series [arg_2] ||| [arg_2] [function_1]	count=9
function	[function_1] shell ||| [function_2] [function_1]	count=1
class	*this is an ||| categorical index	count=2
function	[function_1] the display ||| [function_2] [function_1]	count=1
arg	of rows if n ||| n	count=1
function	in numeric methods ||| numeric methods binary	count=1
arg	called after a ufunc ||| context	count=3
function	return dtype and ||| empty dtype and	count=1
function	type to its ||| type	count=1
class	number of ||| range index	count=1
function_arg	coerce values [arg_2] ||| [arg_2] [function_1]	count=5
arg	[arg_1] function ||| [arg_2] [arg_1]	count=4
function	length is unaltered ||| normalize	count=1
function_arg	[function_1] expected error ||| [function_1] matches [arg_2]	count=3
function_arg	node with [arg_2] ||| [arg_2] [function_1]	count=3
function	ndarray argsort argsorts ||| argsort	count=1
module	options ||| io	count=1
module	additional ||| indexes	count=1
function	if we can ||| can	count=1
module	sequences of ||| core	count=1
function	extract from a masked ||| masked	count=1
function	fill value for the ||| fill value	count=2
arg	unit ||| cls unit	count=1
function	with nat which has ||| nat new	count=1
function	[function_1] a valid ||| [function_2] [function_1]	count=1
arg	a left and right ||| left right	count=1
function	have a full ||| full	count=1
arg	with labels ||| labels	count=1
function	dispatch to apply we ||| apply	count=1
class	index or ndarray ||| index ops mixin	count=1
function	blocks ||| slice take blocks	count=1
class	the ||| range	count=2
function	setting a timezone ||| timezone	count=1
class	an xlwt ||| xlwt writer	count=1
arg	valid ordered parameter ||| cls ordered	count=1
module	to table ||| io	count=1
arg	to the new type ||| dtype copy errors	count=2
function	[function_1] the timedelta64[ns] ||| [function_1] [function_2]	count=1
arg	labels on given axis ||| axis	count=1
module_class	[module_1] ticks ||| [module_1] [class_2]	count=4
function	to [function_2] ||| [function_1] [function_2]	count=8
function	of value from 1-dimensional ||| get value	count=1
class	two [class] ||| [class]	count=3
arg	ndarray only use ||| arr key	count=1
module	with ||| core	count=1
arg	[arg_1] boolean if ||| [arg_1] [arg_2]	count=2
function	columns under the index ||| reset index	count=1
module	[module_1] sparseseries (with ||| [module_1] [module_2]	count=8
class	create [class] from ||| [class]	count=1
class	of a ||| ndframe	count=1
function	dtype ||| empty dtype	count=1
module	times ||| core	count=1
module	ndarray only use this ||| core	count=1
arg	have a float key ||| key	count=1
function	from a [function_2] ||| [function_1] [function_2]	count=2
arg	returning a new ||| ignore_index verify_integrity	count=1
function	in parallel ||| parallel	count=1
function	[function_1] with ||| [function_2] [function_1]	count=6
arg	names ||| names	count=2
arg	apply function ||| func	count=1
function	if ||| set	count=1
arg	slice or [arg_2] ||| [arg_2] [arg_1]	count=1
arg	of times ||| repeats	count=1
function	reset [function_2] ||| [function_1] [function_2]	count=6
module	datetimeindex with times ||| core	count=1
function	possible [function] this ||| [function]	count=1
arg	to table in file ||| value	count=1
arg	generic moving ||| arg window	count=1
arg	shape of the ||| ndim shape	count=1
function	series extract groups ||| str extract frame	count=1
function	parser based on ||| parser	count=1
function_arg	[function_1] the arg ||| [function_1] unit mappings [arg_2]	count=1
class	necessary ||| sparse array	count=1
function	retrieve single [function] at passed ||| [function]	count=1
arg	convert the [arg] ||| [arg]	count=1
function	connect to ||| connect	count=1
arg	the byte of ||| column	count=1
arg	avoid code duplication ||| str_rep	count=1
arg	cartesian product ||| labels shape sort	count=1
function	keys that are not ||| keys	count=1
function	a timedelta ||| timedelta	count=1
arg	init self [arg] ||| data [arg] columns	count=1
function_arg	nrows [arg_2] ||| [function_1] [arg_2] r_idx_names	count=2
class	can be used ||| html frame parser	count=1
class	remove and ||| chain map	count=1
function_arg	[function_1] using one ||| [arg_2] [function_1]	count=1
arg	an indexer ||| name indexer	count=1
rep	[module_class_1] [function_arg_2] ||| [module_class_1] [function_arg_2]	count=8
function	len ||| size	count=1
module	an object ||| core dtypes	count=1
function	a pandas only ||| pandas	count=1
function	sif to datetime ||| to datetime	count=1
function_arg	to a [arg_2] ||| [function_1] latex [arg_2]	count=1
arg	copy ||| index dtype copy	count=1
arg	value from 1-dimensional ||| key value	count=1
function	create the grouper ||| grouper	count=1
class	box ||| ops mixin	count=1
class	this column ||| index col	count=1
function	create and return a ||| get	count=1
function	the fill value for ||| fill value	count=1
function	for ||| axes for	count=1
class	file node must ||| hdfstore	count=1
function	array ||| array	count=8
module	have an object ||| core dtypes	count=1
function	compute the slice ||| slice	count=1
arg	convenience function for ||| xi yi x	count=1
class	used to iterate over ||| frame	count=1
arg	and right ||| right check_exact	count=1
function_arg	[function_1] info ||| [function_1] [arg_2]	count=2
function	return a ||| build	count=1
arg	without throwing an exception ||| lc	count=1
function_arg	expected exception [arg_2] ||| [function_1] matches [arg_2]	count=3
function	take values according ||| take nd	count=2
function	maximum ||| max	count=1
class	numpy array ||| array	count=1
function	to parse a ||| convert	count=1
function	object ||| object	count=1
function	iterate over the ||| build	count=1
function	[function_1] slice ||| [function_2] [function_1]	count=6
arg	key or none if ||| key	count=1
function	[function_1] a categorical ||| [function_2] [function_1]	count=3
function	[function_1] locales ||| [function_1] [function_2]	count=1
module	assemble ||| core tools	count=1
class	elements of an series ||| series	count=1
function	or dataframe only ||| or dataframe	count=1
arg	to run the ||| num_threads kwargs_list	count=1
function	a ||| array	count=3
arg	background null_color for ||| null_color	count=1
class	that can ||| html frame	count=1
arg	file node must ||| value format	count=1
function_arg	coerce [arg_2] ||| [function_1] [arg_2]	count=1
arg	higher freq ||| cls value freq	count=2
arg	representing the totally ordered ||| xnull	count=1
arg	a valid ordered parameter ||| cls ordered	count=1
function	is a named ||| is named	count=3
class	engineering notation appending a ||| eng formatter	count=1
function	return the [function_2] ||| [function_1] [function_2]	count=9
arg	i [arg_2] ||| [arg_2] [arg_1]	count=2
function	a recursive call ||| recursive	count=1
module	up ||| io	count=1
module	styles ||| io formats	count=2
function	need to coerce a ||| maybe coerce freq	count=1
function	true if this is ||| is in	count=1
function	apply the ||| apply index	count=1
arg	of values [arg_2] ||| [arg_2] [arg_1]	count=1
function	at ||| at	count=1
arg	[arg_1] parameters ||| [arg_2] [arg_1]	count=6
arg	that we ||| cls	count=1
function_arg	cartesian product [arg_2] ||| [arg_2] [function_1]	count=3
function_arg	[function_1] this termvalue ||| [function_1] [arg_2]	count=1
function_arg	[function_1] possibility ||| [function_1] [arg_2]	count=4
function	boolean if we ||| is	count=2
function_arg	determine [arg_2] ||| [arg_2] [function_1]	count=1
arg	data converts other ||| cls data	count=1
function	recursive call ||| recursive	count=1
class	as a frame table ||| appendable series table	count=1
module	needs additional ||| core	count=1
function	gets called after ||| array	count=3
arg	a simple cross-tabulation of ||| index columns values	count=1
function	that we all ||| dtype	count=1
function	try to parse a ||| try convert data	count=1
function	get [function_2] ||| [function_1] [function_2]	count=4
arg	unit if ||| cls unit tz	count=1
arg	the result ||| result	count=1
class	reshape data (produce a ||| data frame	count=1
module	[module_1] [module_2] ||| [module_1] [module_2]	count=78
function	cut ||| cut	count=1
function_arg	[function_1] in type_map ||| [function_1] [arg_2]	count=9
class	don't care [class_2] ||| [class_2] [class_1]	count=1
module	index with day as ||| indexes	count=1
function	[function_1] join indexers ||| [function_1] [function_2]	count=2
class	pointer of ||| ops mixin	count=1
module	expression that is ||| computation	count=1
function	read csv file (discouraged ||| csv	count=2
function	[function_1] kwargs suitable ||| [function_2] [function_1]	count=1
class	a new block ||| sparse block	count=1
module	compute a simple cross-tabulation ||| reshape	count=1
function	the ordered attribute ||| ordered	count=1
function	the info ||| info	count=1
class	actual ||| bin op	count=1
module	support fully deleting the ||| io	count=1
function	convert to our native ||| to native	count=3
class	the ||| categorical	count=3
class	ndarray only ||| index	count=3
arg	from ||| arr	count=2
class	underlying data ||| index	count=2
function_arg	template [arg_2] ||| [arg_2] [function_1]	count=1
class	that can ||| frame parser	count=1
class	a ||| html	count=1
function	for series ||| comp method series	count=2
function	intervalindex from [function_2] ||| [function_2] [function_1]	count=2
class	index or ndarray ||| datetime index ops mixin	count=1
function	valid keys across my ||| has valid tuple	count=1
function_arg	path's extension [arg_2] ||| [function_1] [arg_2]	count=3
function	[function_1] to ||| [function_2] [function_1]	count=19
function	a groupby ||| groupby	count=1
arg	apply function to ||| func level	count=1
function	specialized intersection ||| intersection	count=1
function	putmask that ||| putmask	count=1
module	packer for ||| io	count=1
function	true if ||| is in	count=1
arg	period frequency ||| freq	count=1
class	of group excluding ||| data frame group by	count=1
module	convert the ||| core	count=2
arg	this key ||| key	count=2
arg	the dtype of the ||| dtype	count=1
function	detect terminal ||| terminal	count=1
arg	series or by ||| by axis level	count=2
function	of a string-like ||| string	count=1
arg	[arg_1] input function ||| [arg_2] [arg_1]	count=8
arg	columns using input ||| copy inplace	count=1
function	index names to 'index' ||| names	count=1
module	packed ||| io msgpack	count=2
function	'numpy' library ||| take with convert	count=1
function	'numpy' library the third ||| validate take with	count=1
function	:mod datetime to the ||| to	count=1
class	of this ||| index col	count=1
class	underlying array which ||| ops mixin	count=1
function	a file-like ||| file like	count=1
function	this is a valid ||| valid	count=1
function_arg	[function_1] period frequency ||| [function_1] apply index i [arg_2]	count=2
function	function for series ||| method series	count=3
function	rec array and ||| rec array to	count=3
function_arg	[function_1] default implementation ||| [function_1] ops [arg_2]	count=2
function	lists to line ||| convert to line	count=2
class	that the exception raised ||| assert raises contextmanager	count=1
class	already exist and be ||| hdfstore	count=1
function	if ||| validate ordered	count=2
module	set of sparseseries ||| core sparse	count=2
function_arg	series [arg_2] ||| [function_1] [arg_2]	count=9
function	list ||| list	count=1
function	to specified ||| asfreq	count=1
class	these are ||| panel	count=1
arg	function [arg] appropriate window ||| [arg] arg	count=1
function	:class packer ||| packb	count=1
function	be unordered ||| as unordered	count=2
function	never ||| is	count=1
function_arg	quantile a [arg_2] ||| [function_1] [arg_2]	count=1
function_arg	[function_1] of other ||| [arg_2] [function_1]	count=1
function_arg	[function_1] [arg_2] ||| [function_1] style [arg_2]	count=1
arg	and right data ||| right	count=1
class	return a ||| index	count=1
class	object that ||| html frame parser	count=1
function	string starting at the ||| rsplit	count=1
module_class	and replaces these with [module_1] [class_2] for missing value ||| [module_1] [class_2] writer replace nans	count=2
class	multiindex has only 2 ||| multi	count=1
module	datetime index with ||| core indexes	count=1
class	object ||| parser	count=1
module	only use this ||| indexes	count=1
module	the built up styles ||| formats	count=1
class	to appropriate for table ||| table	count=1
function	: write out ||| write	count=1
function_arg	to [arg_2] ||| [function_1] excel [arg_2]	count=1
arg	values to be at ||| values	count=1
function	keys corresponding ||| keys	count=1
function	from a row element ||| parse	count=1
class	a tree-like ||| parser	count=1
function	[function_1] timedelta64[ns] ||| [function_1] [function_2]	count=1
function	the kind of my ||| kind	count=1
arg	byte of the given ||| column	count=1
function	[function_1] and ||| [function_2] [function_1]	count=8
arg	the value inplace ||| value	count=1
arg	or columns of dataframe ||| axis	count=1
arg	labels shape ||| placement shape labels	count=2
arg	of the values to ||| values	count=1
function	maximum by shading ||| max	count=1
function	to a ||| to	count=17
arg	return valid ||| op	count=1
module	fixed frequency datetime index ||| indexes	count=1
function	a custom template ||| custom template	count=1
function	a leap [function_2] ||| [function_2] [function_1]	count=1
arg	format ||| format index	count=1
function_arg	pickle [arg_2] ||| [arg_2] [function_1]	count=1
function	all the classes ||| all	count=1
arg	statement is ||| w	count=1
function	add the series only ||| add series only	count=1
function_arg	wrap result [arg_2] ||| [function_1] data columns [arg_2]	count=1
arg	dataframe the levels in ||| data	count=1
module	sparseseries ||| sparse	count=1
function_arg	string and pads it [function_1] [arg_2] ||| [function_1] [arg_2]	count=1
function	sparse [function_2] ||| [function_2] [function_1]	count=1
arg	[arg_1] each ||| [arg_2] [arg_1]	count=2
arg	lookup of value ||| key value	count=1
arg	and 'kwargs' ||| name args kwargs	count=2
arg	iter2 iterables that ||| iter2	count=1
function	we are a ||| for reshape	count=2
arg	that [arg] comparable ||| [arg]	count=1
arg	a panel-like dataframe parameters ||| time panels names	count=1
function	if it is ||| if	count=1
arg	[arg_1] boolean ||| [arg_1] [arg_2]	count=2
module	calculate ||| indexes	count=1
function	[function_1] levels ||| [function_2] [function_1]	count=4
arg	s bears the risk ||| subarr	count=1
class	ndarray only use ||| index	count=3
class	in blockmanager ||| block manager	count=1
module	tree-like object ||| io	count=1
module	for this ||| core	count=1
arg	ndarray or list of ||| data index	count=1
class	necessary ||| array	count=1
module	table in ||| io	count=1
function_arg	value [arg_2] ||| [function_1] [arg_2]	count=5
class	particular ||| extension dtype	count=2
class	object that can ||| frame	count=1
class	never a ||| categorical block	count=1
function	custom [function_2] ||| [function_2] [function_1]	count=2
function_arg	of [arg_2] ||| [function_1] indexer indexer [arg_2]	count=1
function_arg	[function_1] string raise ||| [arg_2] [function_1]	count=2
function	to : write out ||| write	count=1
arg	to target time zone ||| tz axis level copy	count=1
class	return index ||| index ops mixin	count=1
module	index with day as ||| core indexes	count=1
module	1-dimensional ndarray only ||| core indexes	count=1
function	convert an object to ||| convert	count=1
module	& with [module] ||| [module]	count=1
function	concatenation ||| concat datetime	count=2
function	as an ||| to	count=1
function	new copy of maps[0] ||| copy	count=1
function	along concatenation axis ||| concat axis	count=2
module_class	[module_1] [class_2] by location ||| [module_1] [class_2] ixs i axis	count=3
arg	with a provided encoding ||| fh encoding compat is_verbose	count=1
class	remove and return ||| chain	count=1
module	underlying ||| core indexes	count=4
class	the float values ||| float array formatter	count=1
arg	category value returning a ||| ascending na_position	count=1
function	period ||| get period	count=1
function	set coerce ||| coerce	count=1
module	return packed bytes ||| io msgpack	count=1
class	a new multiindex from ||| multi	count=1
module	to html ||| io formats	count=1
arg	block b ||| block block_items existing_col min_itemsize	count=1
class	tree-like object ||| frame	count=1
arg	be ||| new align	count=1
arg	copy ||| copy	count=2
function_arg	locales [arg_2] ||| [arg_2] [function_1]	count=1
function	sparse ||| sparse	count=4
arg	interpolation [arg] ||| [arg]	count=1
module_class	whether the [class_2] ||| [module_1] [class_2]	count=2
function	copy ||| copy	count=5
arg	compute a simple cross-tabulation ||| index	count=1
arg	into ||| index_col coerce_float parse_dates	count=1
arg	or regular expression in ||| flags	count=1
function_arg	[function_1] a higher ||| [function_1] [arg_2]	count=1
arg	indexer like _name ||| indexer	count=1
function	major ||| major	count=1
function	of given ||| get	count=1
arg	we ||| cls	count=1
function	decorator to deprecate a ||| deprecate	count=1
module_class	and replaces these with [module_1] [class_2] missing value ||| [module_1] [class_2] writer replace nans	count=1
function	function for this ||| func	count=3
arg	i with level ||| i	count=1
function	can be compiled into ||| compilable	count=1
arg	on ||| op_str	count=1
module_class	this [class_2] ||| [module_1] [class_2]	count=1
function	scalar ||| can do	count=1
arg	[arg_1] right array ||| [arg_2] [arg_1]	count=3
arg	if ||| arr key	count=1
function	as an [function_2] ||| [function_1] [function_2]	count=2
module	by shading the ||| io	count=1
function	the length ||| len	count=2
function	the data ||| data	count=1
module	object ||| core indexes	count=2
function	dtype ||| dtype	count=10
class	in [class] ||| [class]	count=6
module	object datetimeindex timedeltaindex and ||| core dtypes	count=1
arg	[arg_1] possibly casting ||| [arg_2] [arg_1]	count=2
arg	data columns ||| data	count=1
arg	[arg_1] indexers ||| [arg_2] [arg_1]	count=1
module	is a ||| core indexes	count=1
class	iterate ||| html frame	count=1
class	the function in blockmanager ||| block manager	count=1
function	array of [function_2] ||| [function_2] [function_1]	count=2
class	[class_1] manager ||| [class_1] [class_2]	count=6
function	pandas only ||| pandas	count=1
function	data ||| data columns	count=1
module	after a ||| indexes	count=2
function	return boolean if values ||| is	count=1
arg	using matplotlib / pylab ||| data column by grid	count=1
class	maps[0] raise keyerror ||| chain map	count=1
function_arg	[function_1] [arg_2] ||| [function_1] apply arg [arg_2]	count=1
arg	and right ||| right vertical	count=1
arg	a string ||| cls string	count=2
arg	if label ||| label	count=2
class	[class] possible that ||| [class]	count=1
arg	from the file path ||| path	count=1
function_arg	[function_1] query in ||| [arg_2] [function_1]	count=2
class	add two [class] ||| [class]	count=3
arg	from ndarray or list ||| data index columns dtype	count=1
function	[function_1] reindex ||| [function_2] [function_1]	count=4
module	dtype) ||| core	count=1
arg	compute ||| index	count=1
function	define an builtin ||| builtin	count=2
function	with closed bounds ||| interval closed bounds	count=2
function	draw histogram ||| hist frame	count=2
class	column ||| data	count=1
function	require ||| simple new	count=1
function	set of subplots ||| subplots	count=1
arg	are subclasses of superclass ||| superclass	count=1
arg	iterables ||| iterables	count=1
class	called ||| series	count=1
function_arg	[function_1] [arg_2] ||| [function_1] node [arg_2]	count=7
arg	the block by ||| axis mgr	count=2
function_arg	table [arg_2] ||| [function_1] table_name con schema [arg_2]	count=3
function	[function_1] raw ||| [function_2] [function_1]	count=1
function	for ||| get	count=1
arg	from other ||| other method	count=1
function_arg	from a [arg_2] ||| [arg_2] [function_1]	count=12
class	is ||| chain map	count=1
class	be used ||| html	count=1
module	[module_1] sparseseries ||| [module_1] [module_2]	count=8
arg	of x ||| x	count=3
module	fast lookup of ||| core indexes	count=1
arg	additional handling ||| result	count=1
function_arg	[function_1] [arg_2] elements ||| [function_1] [arg_2]	count=6
class	add ||| ops mixin	count=1
arg	function to a ||| func	count=2
module	values of ||| core	count=1
arg	dataframe columns ||| data x	count=1
function	latex ||| latex	count=1
arg	from ndarray ||| data index columns dtype	count=1
function	evaluate the block ||| eval	count=1
module	dataframe ||| core	count=1
function	integer stride ||| get stride	count=1
module	am ||| core	count=1
function	wrap given values [function_1] [function_2] ||| [function_1] [function_2]	count=2
class	my ||| interval index	count=1
function	the node [function_2] ||| [function_2] [function_1]	count=4
function	from [function_2] ||| [function_1] [function_2]	count=4
arg	according to indexer and ||| indexer axis	count=2
arg	a decorator to take ||| decorator	count=1
function_arg	[function_1] slice or ||| [function_1] [arg_2]	count=3
function_arg	[function_1] [arg_2] ||| [function_1] iter1 [arg_2]	count=3
function_arg	[function_1] argument ||| [arg_2] [function_1]	count=3
arg	must already ||| value	count=1
class	block ||| block manager	count=2
function	[function_1] file-like ||| [function_1] [function_2]	count=1
arg	python ||| datestr	count=1
arg	of obj [arg_2] ||| [arg_1] [arg_2]	count=1
module	it ||| core	count=1
module	styles to ||| formats	count=1
function	return the formatted ||| formatter func	count=1
function	validate that [function_2] ||| [function_1] [function_2]	count=1
function	[function_1] the description ||| [function_2] [function_1]	count=1
class	index and its underlying ||| range index	count=1
arg	[arg_1] and index ||| [arg_2] [arg_1] takeable	count=1
class	dataframe objects and do ||| data frame	count=1
class	[class_1] manager ||| [class_2] [class_1]	count=6
class	my pandas ||| fixed	count=1
class	keyerror is ||| chain	count=1
function	an intervalindex from ||| from	count=1
module	from ||| compat	count=1
function_arg	id of obj ||| id obj	count=2
function	dictionary ||| construct axes dict from	count=1
arg	axis with ||| axis join	count=2
class	columns excluding na/null ||| data	count=1
function	[function_1] cartesian product ||| [function_2] [function_1]	count=1
function	containing only true/non-nan ||| remove na	count=1
class	ndarray of the ||| index	count=1
class	categorical instance if ||| categorical	count=1
function	the series only ||| series only	count=2
module	see :class ||| msgpack	count=1
function	[function_1] prettier version ||| [function_2] [function_1]	count=1
arg	into a ||| index_col coerce_float parse_dates	count=1
arg	item at selected position ||| item value allow_duplicates	count=1
arg	deal with nat-like arg ||| arg errors	count=1
module	simple cross-tabulation of ||| core	count=1
function	[function_1] a cross-section ||| [function_2] [function_1]	count=1
arg	names defaulting ||| level drop inplace col_level	count=1
function_arg	[function_1] other ||| [function_1] values [arg_2]	count=2
function_arg	[function_1] to have ||| [arg_2] [function_1]	count=3
class	return a ||| frame	count=1
function	return the dtype object ||| dtype	count=2
arg	analogous to ||| axis broadcast reduce	count=1
module	given ||| core indexes	count=1
function	[function_1] the maximum ||| [function_1] [function_2]	count=1
function	determine if ||| dtype n method	count=1
arg	[arg_1] to ||| [arg_1] [arg_2]	count=4
function	[function_1] long ||| [function_1] [function_2]	count=3
function	already ||| append	count=1
class	index and ||| range index	count=1
module_class	[module_1] type ||| [module_1] [class_2]	count=1
module	built up styles to ||| io formats	count=1
function_arg	require [arg_2] ||| [arg_2] [function_1]	count=2
function	[function_1] a string ||| [function_1] [function_2]	count=1
arg	level j do ||| j	count=1
function	to convert timedelta-like to ||| td index cmp	count=1
class	object that can be ||| frame	count=1
function	label for this level ||| has level label	count=1
